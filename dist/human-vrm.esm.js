/*
  Human-VRM
  homepage: <https://github.com/vladmandic/human-vrm>
  author: <https://github.com/vladmandic>'
*/

var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a6, b2) => (typeof require !== "undefined" ? require : a6)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});

// node_modules/.pnpm/three@0.133.1/node_modules/three/build/three.module.js
var REVISION = "133";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
var EventDispatcher = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array2 = listenerArray.slice(0);
      for (let i2 = 0, l3 = array2.length; i2 < l3; i2++) {
        array2[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
var _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
var hasRandomUUID = typeof crypto !== "undefined" && "randomUUID" in crypto;
function generateUUID() {
  if (hasRandomUUID) {
    return crypto.randomUUID().toUpperCase();
  }
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp(value, min7, max7) {
  return Math.max(min7, Math.min(max7, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x2, a12, a22, b1, b2) {
  return b1 + (x2 - a12) * (b2 - b1) / (a22 - a12);
}
function inverseLerp(x2, y2, value) {
  if (x2 !== y2) {
    return (value - x2) / (y2 - x2);
  } else {
    return 0;
  }
}
function lerp(x2, y2, t2) {
  return (1 - t2) * x2 + t2 * y2;
}
function damp(x2, y2, lambda, dt) {
  return lerp(x2, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x2, length = 1) {
  return length - Math.abs(euclideanModulo(x2, length * 2) - length);
}
function smoothstep(x2, min7, max7) {
  if (x2 <= min7)
    return 0;
  if (x2 >= max7)
    return 1;
  x2 = (x2 - min7) / (max7 - min7);
  return x2 * x2 * (3 - 2 * x2);
}
function smootherstep(x2, min7, max7) {
  if (x2 <= min7)
    return 0;
  if (x2 >= max7)
    return 1;
  x2 = (x2 - min7) / (max7 - min7);
  return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range7) {
  return range7 * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0)
    _seed = s2 % 2147483647;
  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a6, b2, c2, order) {
  const cos5 = Math.cos;
  const sin5 = Math.sin;
  const c22 = cos5(b2 / 2);
  const s2 = sin5(b2 / 2);
  const c13 = cos5((a6 + c2) / 2);
  const s13 = sin5((a6 + c2) / 2);
  const c1_3 = cos5((a6 - c2) / 2);
  const s1_3 = sin5((a6 - c2) / 2);
  const c3_1 = cos5((c2 - a6) / 2);
  const s3_1 = sin5((c2 - a6) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
var Vector2 = class {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a6, b2) {
    this.x = a6.x + b2.x;
    this.y = a6.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a6, b2) {
    this.x = a6.x - b2.x;
    this.y = a6.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min7, max7) {
    this.x = Math.max(min7.x, Math.min(max7.x, this.x));
    this.y = Math.max(min7.y, Math.min(max7.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min7, max7) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min7, Math.min(max7, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle2 = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle2;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    return array2;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle2) {
    const c2 = Math.cos(angle2), s2 = Math.sin(angle2);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a6, b2) {
    const ae2 = a6.elements;
    const be = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[3] *= s2;
    te2[6] *= s2;
    te2[1] *= s2;
    te2[4] *= s2;
    te2[7] *= s2;
    te2[2] *= s2;
    te2[5] *= s2;
    te2[8] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a6 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e2 = te2[4], f2 = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
    return a6 * e2 * i2 - a6 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te2 = this.elements;
    te2[0] *= sx;
    te2[3] *= sx;
    te2[6] *= sx;
    te2[1] *= sy;
    te2[4] *= sy;
    te2[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te2 = this.elements;
    const a11 = te2[0], a12 = te2[3], a13 = te2[6];
    const a21 = te2[1], a22 = te2[4], a23 = te2[7];
    te2[0] = c2 * a11 + s2 * a21;
    te2[3] = c2 * a12 + s2 * a22;
    te2[6] = c2 * a13 + s2 * a23;
    te2[1] = -s2 * a11 + c2 * a21;
    te2[4] = -s2 * a12 + c2 * a22;
    te2[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te2 = this.elements;
    te2[0] += tx * te2[2];
    te2[3] += tx * te2[5];
    te2[6] += tx * te2[8];
    te2[1] += ty * te2[2];
    te2[4] += ty * te2[5];
    te2[7] += ty * te2[8];
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array2, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array2[i2 + offset];
    }
    return this;
  }
  toArray(array2 = [], offset = 0) {
    const te2 = this.elements;
    array2[offset] = te2[0];
    array2[offset + 1] = te2[1];
    array2[offset + 2] = te2[2];
    array2[offset + 3] = te2[3];
    array2[offset + 4] = te2[4];
    array2[offset + 5] = te2[5];
    array2[offset + 6] = te2[6];
    array2[offset + 7] = te2[7];
    array2[offset + 8] = te2[8];
    return array2;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
function arrayMax(array2) {
  if (array2.length === 0)
    return -Infinity;
  let max7 = array2[0];
  for (let i2 = 1, l3 = array2.length; i2 < l3; ++i2) {
    if (array2[i2] > max7)
      max7 = array2[i2];
  }
  return max7;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
var _canvas;
var ImageUtils = class {
  static getDataURL(image2) {
    if (/^data:/i.test(image2.src)) {
      return image2.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image2.src;
    }
    let canvas3;
    if (image2 instanceof HTMLCanvasElement) {
      canvas3 = image2;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image2.width;
      _canvas.height = image2.height;
      const context = _canvas.getContext("2d");
      if (image2 instanceof ImageData) {
        context.putImageData(image2, 0, 0);
      } else {
        context.drawImage(image2, 0, 0, image2.width, image2.height);
      }
      canvas3 = _canvas;
    }
    if (canvas3.width > 2048 || canvas3.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image2);
      return canvas3.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas3.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image2 = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.image = image2;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image2 = this.image;
      if (image2.uuid === void 0) {
        image2.uuid = generateUUID();
      }
      if (!isRootObject && meta.images[image2.uuid] === void 0) {
        let url;
        if (Array.isArray(image2)) {
          url = [];
          for (let i2 = 0, l3 = image2.length; i2 < l3; i2++) {
            if (image2[i2].isDataTexture) {
              url.push(serializeImage(image2[i2].image));
            } else {
              url.push(serializeImage(image2[i2]));
            }
          }
        } else {
          url = serializeImage(image2);
        }
        meta.images[image2.uuid] = {
          uuid: image2.uuid,
          url
        };
      }
      output.image = image2.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image2) {
  if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image2);
  } else {
    if (image2.data) {
      return {
        data: Array.prototype.slice.call(image2.data),
        width: image2.width,
        height: image2.height,
        type: image2.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    this.z = scalar2;
    this.w = scalar2;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a6, b2) {
    this.x = a6.x + b2.x;
    this.y = a6.y + b2.y;
    this.z = a6.z + b2.z;
    this.w = a6.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a6, b2) {
    this.x = a6.x - b2.x;
    this.y = a6.y - b2.y;
    this.z = a6.z - b2.z;
    this.w = a6.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    this.z *= scalar2;
    this.w *= scalar2;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
    return this;
  }
  divideScalar(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle2, x2, y2, z2;
    const epsilon3 = 0.01, epsilon22 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon3 && Math.abs(m13 - m31) < epsilon3 && Math.abs(m23 - m32) < epsilon3) {
      if (Math.abs(m12 + m21) < epsilon22 && Math.abs(m13 + m31) < epsilon22 && Math.abs(m23 + m32) < epsilon22 && Math.abs(m11 + m22 + m33 - 3) < epsilon22) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle2 = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon3) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon3) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon3) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle2);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min7, max7) {
    this.x = Math.max(min7.x, Math.min(max7.x, this.x));
    this.y = Math.max(min7.y, Math.min(max7.y, this.y));
    this.z = Math.max(min7.z, Math.min(max7.z, this.z));
    this.w = Math.max(min7.w, Math.min(max7.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min7, max7) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min7, Math.min(max7, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    this.w = array2[offset + 3];
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    array2[offset + 3] = this.w;
    return array2;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options3 = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    this.texture = new Texture(void 0, options3.mapping, options3.wrapS, options3.wrapT, options3.magFilter, options3.minFilter, options3.format, options3.type, options3.anisotropy, options3.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.image = { width, height, depth: 1 };
    this.texture.generateMipmaps = options3.generateMipmaps !== void 0 ? options3.generateMipmaps : false;
    this.texture.internalFormat = options3.internalFormat !== void 0 ? options3.internalFormat : null;
    this.texture.minFilter = options3.minFilter !== void 0 ? options3.minFilter : LinearFilter;
    this.depthBuffer = options3.depthBuffer !== void 0 ? options3.depthBuffer : true;
    this.stencilBuffer = options3.stencilBuffer !== void 0 ? options3.stencilBuffer : false;
    this.depthTexture = options3.depthTexture !== void 0 ? options3.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = { ...this.texture.image };
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
  constructor(width, height, count3) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];
    for (let i2 = 0; i2 < count3; i2++) {
      this.texture[i2] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
        this.texture[i2].image.width = width;
        this.texture[i2].image.height = height;
        this.texture[i2].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;
    for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
      this.texture[i2] = source.texture[i2].clone();
    }
    return this;
  }
};
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options3) {
    super(width, height, options3);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerp(qa, qb, qm, t2) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos5 = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos5 >= 0 ? 1 : -1, sqrSin = 1 - cos5 * cos5;
      if (sqrSin > Number.EPSILON) {
        const sin5 = Math.sqrt(sqrSin), len = Math.atan2(sin5, cos5 * dir);
        s2 = Math.sin(s2 * len) / sin5;
        t2 = Math.sin(t2 * len) / sin5;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update2) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos5 = Math.cos;
    const sin5 = Math.sin;
    const c1 = cos5(x2 / 2);
    const c2 = cos5(y2 / 2);
    const c3 = cos5(z2 / 2);
    const s1 = sin5(x2 / 2);
    const s2 = sin5(y2 / 2);
    const s3 = sin5(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update2 !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle2) {
    const halfAngle = angle2 / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step5) {
    const angle2 = this.angleTo(q2);
    if (angle2 === 0)
      return this;
    const t2 = Math.min(1, step5 / angle2);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l3 = this.length();
    if (l3 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l3 = 1 / l3;
      this._x = this._x * l3;
      this._y = this._y * l3;
      this._z = this._z * l3;
      this._w = this._w * l3;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p3) {
    if (p3 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p3);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a6, b2) {
    const qax = a6._x, qay = a6._y, qaz = a6._z, qaw = a6._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    this.copy(qa).slerp(qb, t2);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array2, offset = 0) {
    this._x = array2[offset];
    this._y = array2[offset + 1];
    this._z = array2[offset + 2];
    this._w = array2[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._w;
    return array2;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    this.z = scalar2;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a6, b2) {
    this.x = a6.x + b2.x;
    this.y = a6.y + b2.y;
    this.z = a6.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a6, b2) {
    this.x = a6.x - b2.x;
    this.y = a6.y - b2.y;
    this.z = a6.z - b2.z;
    return this;
  }
  multiply(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    this.z *= scalar2;
    return this;
  }
  multiplyVectors(a6, b2) {
    this.x = a6.x * b2.x;
    this.y = a6.y * b2.y;
    this.z = a6.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle2) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle2));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera2) {
    return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
  }
  unproject(camera2) {
    return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min7, max7) {
    this.x = Math.max(min7.x, Math.min(max7.x, this.x));
    this.y = Math.max(min7.y, Math.min(max7.y, this.y));
    this.z = Math.max(min7.z, Math.min(max7.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min7, max7) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min7, Math.min(max7, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a6, b2) {
    const ax = a6.x, ay = a6.y, az = a6.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar2 = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar2);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    return array2;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u2 = (Math.random() - 0.5) * 2;
    const t2 = Math.random() * Math.PI * 2;
    const f2 = Math.sqrt(1 - u2 ** 2);
    this.x = f2 * Math.cos(t2);
    this.y = f2 * Math.sin(t2);
    this.z = u2;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
Vector3.prototype.isVector3 = true;
var _vector$c = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min7 = new Vector3(Infinity, Infinity, Infinity), max7 = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min7;
    this.max = max7;
  }
  set(min7, max7) {
    this.min.copy(min7);
    this.max.copy(max7);
    return this;
  }
  setFromArray(array2) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l3 = array2.length; i2 < l3; i2 += 3) {
      const x2 = array2[i2];
      const y2 = array2[i2 + 1];
      const z2 = array2[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l3 = attribute.count; i2 < l3; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$b.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object2) {
    this.makeEmpty();
    return this.expandByObject(object2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar2) {
    this.min.addScalar(-scalar2);
    this.max.addScalar(scalar2);
    return this;
  }
  expandByObject(object2) {
    object2.updateWorldMatrix(false, false);
    const geometry = object2.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object2.matrixWorld);
      this.union(_box$3);
    }
    const children = object2.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      this.expandByObject(children[i2]);
    }
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y || point2.z < this.min.z || point2.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point2, target) {
    return target.set((point2.x - this.min.x) / (this.max.x - this.min.x), (point2.y - this.min.y) / (this.max.y - this.min.y), (point2.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min7, max7;
    if (plane.normal.x > 0) {
      min7 = plane.normal.x * this.min.x;
      max7 = plane.normal.x * this.max.x;
    } else {
      min7 = plane.normal.x * this.max.x;
      max7 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min7 += plane.normal.y * this.min.y;
      max7 += plane.normal.y * this.max.y;
    } else {
      min7 += plane.normal.y * this.max.y;
      max7 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min7 += plane.normal.z * this.min.z;
      max7 += plane.normal.z * this.max.z;
    } else {
      min7 += plane.normal.z * this.max.z;
      max7 += plane.normal.z * this.min.z;
    }
    return min7 <= -plane.constant && max7 >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    const clampedPoint = _vector$b.copy(point2).clamp(this.min, this.max);
    return clampedPoint.sub(point2).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$b = /* @__PURE__ */ new Vector3();
var _box$3 = /* @__PURE__ */ new Box3();
var _v0$2 = /* @__PURE__ */ new Vector3();
var _v1$7 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p22 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$2 = /* @__PURE__ */ new Box3();
var _v1$6 = /* @__PURE__ */ new Vector3();
var _toFarthestPoint = /* @__PURE__ */ new Vector3();
var _toPoint = /* @__PURE__ */ new Vector3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point2) {
    return point2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point2) {
    return point2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point2, target) {
    const deltaLengthSq = this.center.distanceToSquared(point2);
    target.copy(point2);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point2) {
    _toPoint.subVectors(point2, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal$1 = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point2, target) {
    target.subVectors(point2, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point2) {
    return Math.sqrt(this.distanceSqToPoint(point2));
  }
  distanceSqToPoint(point2) {
    const directionDistance = _vector$a.subVectors(point2, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point2);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point2);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a6, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a6);
    _edge2.subVectors(c2, a6);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign4;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign4 = 1;
    } else if (DdN < 0) {
      sign4 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a6);
    const DdQxE2 = sign4 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign4 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign4 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m2) {
    const te2 = this.elements, me2 = m2.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te2 = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a6 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae2 = a6 * e2, af = a6 * f2, be = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = -c2 * f2;
      te2[8] = d2;
      te2[1] = af + be * d2;
      te2[5] = ae2 - bf * d2;
      te2[9] = -b2 * c2;
      te2[2] = bf - ae2 * d2;
      te2[6] = be + af * d2;
      te2[10] = a6 * c2;
    } else if (euler.order === "YXZ") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 + df * b2;
      te2[4] = de2 * b2 - cf;
      te2[8] = a6 * d2;
      te2[1] = a6 * f2;
      te2[5] = a6 * e2;
      te2[9] = -b2;
      te2[2] = cf * b2 - de2;
      te2[6] = df + ce2 * b2;
      te2[10] = a6 * c2;
    } else if (euler.order === "ZXY") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 - df * b2;
      te2[4] = -a6 * f2;
      te2[8] = de2 + cf * b2;
      te2[1] = cf + de2 * b2;
      te2[5] = a6 * e2;
      te2[9] = df - ce2 * b2;
      te2[2] = -a6 * d2;
      te2[6] = b2;
      te2[10] = a6 * c2;
    } else if (euler.order === "ZYX") {
      const ae2 = a6 * e2, af = a6 * f2, be = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = be * d2 - af;
      te2[8] = ae2 * d2 + bf;
      te2[1] = c2 * f2;
      te2[5] = bf * d2 + ae2;
      te2[9] = af * d2 - be;
      te2[2] = -d2;
      te2[6] = b2 * c2;
      te2[10] = a6 * c2;
    } else if (euler.order === "YZX") {
      const ac = a6 * c2, ad = a6 * d2, bc = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = bd - ac * f2;
      te2[8] = bc * f2 + ad;
      te2[1] = f2;
      te2[5] = a6 * e2;
      te2[9] = -b2 * e2;
      te2[2] = -d2 * e2;
      te2[6] = ad * f2 + bc;
      te2[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a6 * c2, ad = a6 * d2, bc = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = -f2;
      te2[8] = d2 * e2;
      te2[1] = ac * f2 + bd;
      te2[5] = a6 * e2;
      te2[9] = ad * f2 - bc;
      te2[2] = bc * f2 - ad;
      te2[6] = b2 * e2;
      te2[10] = bd * f2 + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye2, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye2, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a6, b2) {
    const ae2 = a6.elements;
    const be = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[4] *= s2;
    te2[8] *= s2;
    te2[12] *= s2;
    te2[1] *= s2;
    te2[5] *= s2;
    te2[9] *= s2;
    te2[13] *= s2;
    te2[2] *= s2;
    te2[6] *= s2;
    te2[10] *= s2;
    te2[14] *= s2;
    te2[3] *= s2;
    te2[7] *= s2;
    te2[11] *= s2;
    te2[15] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp2;
    tmp2 = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp2;
    tmp2 = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp2;
    tmp2 = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp2;
    tmp2 = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp2;
    tmp2 = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp2;
    tmp2 = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp2;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te2 = this.elements;
    if (x2.isVector3) {
      te2[12] = x2.x;
      te2[13] = x2.y;
      te2[14] = x2.z;
    } else {
      te2[12] = x2;
      te2[13] = y2;
      te2[14] = z2;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te2 = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te2[0] *= x2;
    te2[4] *= y2;
    te2[8] *= z2;
    te2[1] *= x2;
    te2[5] *= y2;
    te2[9] *= z2;
    te2[2] *= x2;
    te2[6] *= y2;
    te2[10] *= z2;
    te2[3] *= x2;
    te2[7] *= y2;
    te2[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle2) {
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale3) {
    const te2 = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
    const sx = scale3.x, sy = scale3.y, sz = scale3.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale3) {
    const te2 = this.elements;
    let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale3.x = sx;
    scale3.y = sy;
    scale3.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te2 = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a6 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = a6;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = b2;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te2 = this.elements;
    const w2 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p3 = 1 / (far - near);
    const x2 = (right + left) * w2;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p3;
    te2[0] = 2 * w2;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x2;
    te2[1] = 0;
    te2[5] = 2 * h2;
    te2[9] = 0;
    te2[13] = -y2;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = -2 * p3;
    te2[14] = -z2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array2, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array2[i2 + offset];
    }
    return this;
  }
  toArray(array2 = [], offset = 0) {
    const te2 = this.elements;
    array2[offset] = te2[0];
    array2[offset + 1] = te2[1];
    array2[offset + 2] = te2[2];
    array2[offset + 3] = te2[3];
    array2[offset + 4] = te2[4];
    array2[offset + 5] = te2[5];
    array2[offset + 6] = te2[6];
    array2[offset + 7] = te2[7];
    array2[offset + 8] = te2[8];
    array2[offset + 9] = te2[9];
    array2[offset + 10] = te2[10];
    array2[offset + 11] = te2[11];
    array2[offset + 12] = te2[12];
    array2[offset + 13] = te2[13];
    array2[offset + 14] = te2[14];
    array2[offset + 15] = te2[15];
    return array2;
  }
};
Matrix4.prototype.isMatrix4 = true;
var _v1$5 = /* @__PURE__ */ new Vector3();
var _m1$2 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix$1 = /* @__PURE__ */ new Matrix4();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order = this._order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update2 = true) {
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update2 === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update2) {
    _matrix$1.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$1, order, update2);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array2) {
    this._x = array2[0];
    this._y = array2[1];
    this._z = array2[2];
    if (array2[3] !== void 0)
      this._order = array2[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._order;
    return array2;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = /* @__PURE__ */ new Vector3();
var _q1 = /* @__PURE__ */ new Quaternion();
var _m1$1 = /* @__PURE__ */ new Matrix4();
var _target = /* @__PURE__ */ new Vector3();
var _position$3 = /* @__PURE__ */ new Vector3();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _quaternion$2 = /* @__PURE__ */ new Quaternion();
var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale3 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale3
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle2) {
    this.quaternion.setFromAxisAngle(axis, angle2);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle2) {
    return this.rotateOnAxis(_xAxis, angle2);
  }
  rotateY(angle2) {
    return this.rotateOnAxis(_yAxis, angle2);
  }
  rotateZ(angle2) {
    return this.rotateOnAxis(_zAxis, angle2);
  }
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object2) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object2 === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object2);
      return this;
    }
    if (object2 && object2.isObject3D) {
      if (object2.parent !== null) {
        object2.parent.remove(object2);
      }
      object2.parent = this;
      this.children.push(object2);
      object2.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object2);
    }
    return this;
  }
  remove(object2) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object2);
    if (index !== -1) {
      object2.parent = null;
      this.children.splice(index, 1);
      object2.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object2 = this.children[i2];
      object2.parent = null;
      object2.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object2) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object2.parent !== null) {
      object2.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object2.parent.matrixWorld);
    }
    object2.applyMatrix4(_m1$1);
    this.add(object2);
    object2.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i2 = 0, l3 = this.children.length; i2 < l3; i2++) {
      const child = this.children[i2];
      const object2 = child.getObjectByProperty(name, value);
      if (object2 !== void 0) {
        return object2;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object2 = {};
    object2.uuid = this.uuid;
    object2.type = this.type;
    if (this.name !== "")
      object2.name = this.name;
    if (this.castShadow === true)
      object2.castShadow = true;
    if (this.receiveShadow === true)
      object2.receiveShadow = true;
    if (this.visible === false)
      object2.visible = false;
    if (this.frustumCulled === false)
      object2.frustumCulled = false;
    if (this.renderOrder !== 0)
      object2.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object2.userData = this.userData;
    object2.layers = this.layers.mask;
    object2.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object2.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object2.type = "InstancedMesh";
      object2.count = this.count;
      object2.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object2.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object2.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object2.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object2.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object2.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l3 = shapes.length; i2 < l3; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object2.bindMode = this.bindMode;
      object2.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object2.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l3 = this.material.length; i2 < l3; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object2.material = uuids;
      } else {
        object2.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object2.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object2.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object2.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object2.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object2;
    return output;
    function extractFromCache(cache5) {
      const values = [];
      for (const key in cache5) {
        const data = cache5[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var _v3$1 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a6 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a6;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a6, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a6, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point2, a6, b2, c2, target) {
    _v0$1.subVectors(c2, a6);
    _v1$3.subVectors(b2, a6);
    _v2$2.subVectors(point2, a6);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point2, a6, b2, c2) {
    this.getBarycoord(point2, a6, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point2, p1, p22, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point2, p1, p22, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a6, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a6, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a6, b2, c2) {
    this.a.copy(a6);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point2, target) {
    return Triangle.getBarycoord(point2, this.a, this.b, this.c, target);
  }
  getUV(point2, uv1, uv2, uv3, target) {
    return Triangle.getUV(point2, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point2) {
    return Triangle.containsPoint(point2, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p3, target) {
    const a6 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a6);
    _vac.subVectors(c2, a6);
    _vap.subVectors(p3, a6);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a6);
    }
    _vbp.subVectors(p3, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a6).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p3, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a6).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w2 = vc * denom;
    return target.copy(a6).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.format = RGBAFormat;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenTint && this.sheenTint.isColor)
      data.sheenTint = this.sheenTint.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularTint && this.specularTint.isColor)
      data.specularTint = this.specularTint.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularTintMap && this.specularTintMap.isTexture)
      data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationTint !== void 0)
      data.attenuationTint = this.attenuationTint.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.format !== RGBAFormat)
      data.format = this.format;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache5) {
      const values = [];
      for (const key in cache5) {
        const data2 = cache5[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.format = source.format;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Material.prototype.isMaterial = true;
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p3, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p3 + (q2 - p3) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p3 + (q2 - p3) * 6 * (2 / 3 - t2);
  return p3;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var Color = class {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar2) {
    this.r = scalar2;
    this.g = scalar2;
    this.b = scalar2;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l3) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l3 = clamp(l3, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l3;
    } else {
      const p3 = l3 <= 0.5 ? l3 * (1 + s2) : l3 + s2 - l3 * s2;
      const q2 = 2 * l3 - p3;
      this.r = hue2rgb(q2, p3, h2 + 1 / 3);
      this.g = hue2rgb(q2, p3, h2);
      this.b = hue2rgb(q2, p3, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string2) {
      if (string2 === void 0)
        return;
      if (parseFloat(string2) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m2[1];
      const components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h2 = parseFloat(color[1]) / 360;
            const s2 = parseInt(color[2], 10) / 100;
            const l3 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h2, s2, l3);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size2 = hex.length;
      if (size2 === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size2 === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max7 = Math.max(r2, g2, b2);
    const min7 = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min7 + max7) / 2;
    if (min7 === max7) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max7 - min7;
      saturation = lightness <= 0.5 ? delta / (max7 + min7) : delta / (2 - max7 - min7);
      switch (max7) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l3) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l3;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l3 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l3);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array2, offset = 0) {
    this.r = array2[offset];
    this.g = array2[offset + 1];
    this.b = array2[offset + 2];
    return this;
  }
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.r;
    array2[offset + 1] = this.g;
    array2[offset + 2] = this.b;
    return array2;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$9 = /* @__PURE__ */ new Vector3();
var _vector2$1 = /* @__PURE__ */ new Vector2();
var BufferAttribute = class {
  constructor(array2, itemSize, normalized) {
    if (Array.isArray(array2)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array2;
    this.itemSize = itemSize;
    this.count = array2 !== void 0 ? array2.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l3 = this.itemSize; i2 < l3; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array2) {
    this.array.set(array2);
    return this;
  }
  copyColorsArray(colors) {
    const array2 = this.array;
    let offset = 0;
    for (let i2 = 0, l3 = colors.length; i2 < l3; i2++) {
      let color = colors[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array2[offset++] = color.r;
      array2[offset++] = color.g;
      array2[offset++] = color.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array2 = this.array;
    let offset = 0;
    for (let i2 = 0, l3 = vectors.length; i2 < l3; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array2[offset++] = vector.x;
      array2[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array2 = this.array;
    let offset = 0;
    for (let i2 = 0, l3 = vectors.length; i2 < l3; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array2[offset++] = vector.x;
      array2[offset++] = vector.y;
      array2[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array2 = this.array;
    let offset = 0;
    for (let i2 = 0, l3 = vectors.length; i2 < l3; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array2[offset++] = vector.x;
      array2[offset++] = vector.y;
      array2[offset++] = vector.z;
      array2[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x2) {
    this.array[index * this.itemSize] = x2;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y2) {
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x2, y2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
};
BufferAttribute.prototype.isBufferAttribute = true;
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(array2, itemSize, normalized) {
    super(new Uint16Array(array2), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(array2, itemSize, normalized) {
    super(new Uint32Array(array2), itemSize, normalized);
  }
};
var Float16BufferAttribute = class extends BufferAttribute {
  constructor(array2, itemSize, normalized) {
    super(new Uint16Array(array2), itemSize, normalized);
  }
};
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(array2, itemSize, normalized) {
    super(new Float32Array(array2), itemSize, normalized);
  }
};
var _id = 0;
var _m1 = /* @__PURE__ */ new Matrix4();
var _obj = /* @__PURE__ */ new Object3D();
var _offset = /* @__PURE__ */ new Vector3();
var _box$1 = /* @__PURE__ */ new Box3();
var _boxMorphTargets = /* @__PURE__ */ new Box3();
var _vector$8 = /* @__PURE__ */ new Vector3();
var BufferGeometry = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count3, materialIndex = 0) {
    this.groups.push({
      start,
      count: count3,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count3) {
    this.drawRange.start = start;
    this.drawRange.count = count3;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle2) {
    _m1.makeRotationX(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle2) {
    _m1.makeRotationY(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle2) {
    _m1.makeRotationZ(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l3 = points.length; i2 < l3; i2++) {
      const point2 = points[i2];
      position.push(point2.x, point2.y, point2.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan22 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan22[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a6, b2, c2) {
      vA.fromArray(positions, a6 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a6 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a6].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan22[a6].add(tdir);
      tan22[b2].add(tdir);
      tan22[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count3 = group.count;
      for (let j2 = start, jl = start + count3; j2 < jl; j2 += 3) {
        handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp22.crossVectors(n22, t2);
      const test = tmp22.dot(tan22[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count3 = group.count;
      for (let j2 = start, jl = start + count3; j2 < jl; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array2 = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array22 = new array2.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l3 = indices2.length; i2 < l3; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array22[index2++] = array2[index++];
        }
      }
      return new BufferAttribute(array22, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l3 = groups.length; i2 < l3; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array2 = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array2.push(attribute.toJSON(data.data));
      }
      if (array2.length > 0) {
        morphAttributes[key] = array2;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array2 = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l3 = morphAttribute.length; i2 < l3; i2++) {
        array2.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array2;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l3 = groups.length; i2 < l3; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
BufferGeometry.prototype.isBufferGeometry = true;
var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
var _ray$2 = /* @__PURE__ */ new Ray();
var _sphere$3 = /* @__PURE__ */ new Sphere();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _tempA = /* @__PURE__ */ new Vector3();
var _tempB = /* @__PURE__ */ new Vector3();
var _tempC = /* @__PURE__ */ new Vector3();
var _morphA = /* @__PURE__ */ new Vector3();
var _morphB = /* @__PURE__ */ new Vector3();
var _morphC = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var _intersectionPoint = /* @__PURE__ */ new Vector3();
var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
var Mesh = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a6 = index.getX(j2);
              const b2 = index.getX(j2 + 1);
              const c2 = index.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a6, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a6 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            const c2 = index.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a6, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a6 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a6, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a6 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a6, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
};
Mesh.prototype.isMesh = true;
function checkIntersection(object2, material, raycaster, ray, pA, pB, pC, point2) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point2);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point2);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point2);
  _intersectionPointWorld.applyMatrix4(object2.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far)
    return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object: object2
  };
}
function checkBufferGeometryIntersection(object2, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a6, b2, c2) {
  _vA$1.fromBufferAttribute(position, a6);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object2.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a6);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object2.isSkinnedMesh) {
    object2.boneTransform(a6, _vA$1);
    object2.boneTransform(b2, _vB$1);
    object2.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object2, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a6);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a6);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face4 = {
      a: a6,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face4.normal);
    intersection.face = face4;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a6 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a6, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p3 in src[u2]) {
      const property = src[u2][p3];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p3] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p3] = property.slice();
      } else {
        dst[u2][p3] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p3 in tmp2) {
      merged[p3] = tmp2[p3];
    }
  }
  return merged;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions2 = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions2[key] = true;
    }
    if (Object.keys(extensions2).length > 0)
      data.extensions = extensions2;
    return data;
  }
};
ShaderMaterial.prototype.isShaderMaterial = true;
var Camera = class extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera.prototype.isCamera = true;
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
PerspectiveCamera.prototype.isPerspectiveCamera = true;
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer2, scene2) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer2.xr.enabled;
    const currentRenderTarget = renderer2.getRenderTarget();
    renderer2.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer2.setRenderTarget(renderTarget, 0);
    renderer2.render(scene2, cameraPX);
    renderer2.setRenderTarget(renderTarget, 1);
    renderer2.render(scene2, cameraNX);
    renderer2.setRenderTarget(renderTarget, 2);
    renderer2.render(scene2, cameraPY);
    renderer2.setRenderTarget(renderTarget, 3);
    renderer2.render(scene2, cameraNY);
    renderer2.setRenderTarget(renderTarget, 4);
    renderer2.render(scene2, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer2.setRenderTarget(renderTarget, 5);
    renderer2.render(scene2, cameraNZ);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size2, options3, dummy) {
    if (Number.isInteger(options3)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options3 = dummy;
    }
    super(size2, size2, options3);
    options3 = options3 || {};
    this.texture = new CubeTexture(void 0, options3.mapping, options3.wrapS, options3.wrapT, options3.magFilter, options3.minFilter, options3.format, options3.type, options3.anisotropy, options3.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options3.generateMipmaps !== void 0 ? options3.generateMipmaps : false;
    this.texture.minFilter = options3.minFilter !== void 0 ? options3.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer2, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    camera2.update(renderer2, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer2, color, depth, stencil) {
    const currentRenderTarget = renderer2.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer2.setRenderTarget(this, i2);
      renderer2.clear(color, depth, stencil);
    }
    renderer2.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant2 = 0) {
    this.normal = normal;
    this.constant = constant2;
  }
  set(normal, constant2) {
    this.normal.copy(normal);
    this.constant = constant2;
    return this;
  }
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point2) {
    this.normal.copy(normal);
    this.constant = -point2.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a6, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a6, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a6);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point2) {
    return this.normal.dot(point2) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point2, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point2)).add(point2);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t2).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _sphere$2 = /* @__PURE__ */ new Sphere();
var _vector$7 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p22 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p22, p3, p4, p5];
  }
  set(p0, p1, p22, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p22);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me2 = m2.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object2) {
    const geometry = object2.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object2.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance2 = planes[i2].distanceToPoint(center);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point2) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point2) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time2, frame2) {
    animationLoop(time2, frame2);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array2 = attribute.array;
    const usage = attribute.usage;
    const buffer2 = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer2);
    gl.bufferData(bufferType, array2, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array2 instanceof Float32Array) {
      type = 5126;
    } else if (array2 instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array2 instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array2 instanceof Int16Array) {
      type = 5122;
    } else if (array2 instanceof Uint32Array) {
      type = 5125;
    } else if (array2 instanceof Int32Array) {
      type = 5124;
    } else if (array2 instanceof Int8Array) {
      type = 5120;
    } else if (array2 instanceof Uint8Array) {
      type = 5121;
    } else if (array2 instanceof Uint8ClampedArray) {
      type = 5121;
    }
    return {
      buffer: buffer2,
      type,
      bytesPerElement: array2.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer2, attribute, bufferType) {
    const array2 = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer2);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array2);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array2.BYTES_PER_ELEMENT, array2, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array2.BYTES_PER_ELEMENT, array2.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get4(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get4,
    remove,
    update: update2
  };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a6 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a6, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenTint * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenTint = sheenTint;\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenTint;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenTint;\n	uniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenTint: { value: new Color(0) },
      sheenRoughness: { value: 0 },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationTint: { value: new Color(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularTint: { value: new Color(1, 1, 1) },
      specularTintMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer2, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene2) {
    let forceClear = false;
    let background = scene2.isScene === true ? scene2.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer2.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer2.autoClear || forceClear) {
      renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer3, scene3, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions2, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions2.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup46(object2, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object2.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object2, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache5 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache5[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache5;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions2.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size2, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size2, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size2, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object2, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object2.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions2.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object2.instanceMatrix)
            geometryAttribute = object2.instanceMatrix;
          if (name === "instanceColor" && object2.instanceColor)
            geometryAttribute = object2.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size2 = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer2 = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement2 = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object2.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer2);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size2 / programAttribute.locationSize, type, normalized, stride * bytesPerElement2, (offset + size2 / programAttribute.locationSize * i2) * bytesPerElement2);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object2.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer2);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size2 / programAttribute.locationSize, type, normalized, size2 * bytesPerElement2, size2 / programAttribute.locationSize * i2 * bytesPerElement2);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose2() {
    reset2();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset2() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup: setup46,
    reset: reset2,
    resetDefaultState,
    dispose: dispose2,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions2, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count3) {
    gl.drawArrays(mode, start, count3);
    info.update(count3, mode, 1);
  }
  function renderInstances(start, count3, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions2.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count3, primcount);
    info.update(count3, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions2, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions2.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions2.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision4) {
    if (precision4 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision4 = "mediump";
    }
    if (precision4 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision3 = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision3);
  if (maxPrecision !== precision3) {
    console.warn("THREE.WebGLRenderer:", precision3, "not supported, using", maxPrecision, "instead.");
    precision3 = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions2.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions2.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision: precision3,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera2) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera2, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera2, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera2, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer2) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get4(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image2 = texture.image;
          if (image2 && image2.height > 0) {
            const currentRenderTarget = renderer2.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image2.height / 2);
            renderTarget.fromEquirectangularTexture(renderer2, texture);
            cubemaps.set(texture, renderTarget);
            renderer2.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose2() {
    cubemaps = new WeakMap();
  }
  return {
    get: get4,
    dispose: dispose2
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var MAX_SAMPLES = 20;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
var PMREMGenerator = class {
  constructor(renderer2) {
    this._renderer = renderer2;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene2, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene2, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
      _lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene2, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer2 = this._renderer;
    const originalAutoClear = renderer2.autoClear;
    const outputEncoding = renderer2.outputEncoding;
    const toneMapping = renderer2.toneMapping;
    renderer2.getClearColor(_clearColor);
    renderer2.toneMapping = NoToneMapping;
    renderer2.outputEncoding = LinearEncoding;
    renderer2.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene2.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene2.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer2.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer2.render(backgroundBox, cubeCamera);
      }
      renderer2.render(scene2, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer2.toneMapping = toneMapping;
    renderer2.outputEncoding = outputEncoding;
    renderer2.autoClear = originalAutoClear;
    scene2.background = background;
  }
  _setEncoding(uniform, texture) {
    if (this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding) {
      uniform.value = ENCODINGS[LinearEncoding];
    } else {
      uniform.value = ENCODINGS[texture.encoding];
    }
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!texture.isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    this._setEncoding(uniforms["inputEncoding"], texture);
    this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer2.setRenderTarget(cubeUVRenderTarget);
    renderer2.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const autoClear = renderer2.autoClear;
    renderer2.autoClear = false;
    for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
      const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer2.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer2 = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum7 = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 == 0) {
        sum7 += weight;
      } else if (i2 < samples) {
        sum7 += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum7;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
    this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
    const outputSize2 = _sizeLods[lodOut];
    const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize2);
    const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize2 * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x2, y2, 3 * outputSize2, 2 * outputSize2);
    renderer2.setRenderTarget(targetOut);
    renderer2.render(blurMesh, _flatCamera);
  }
};
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
    } else if (i2 == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min7 = -texelSize / 2;
    const max7 = 1 + texelSize / 2;
    const uv1 = [min7, min7, max7, min7, max7, max7, min7, min7, max7, max7, min7, max7];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex2 = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face4 = 0; face4 < cubeFaces; face4++) {
      const x2 = face4 % 3 * 2 / 3 - 1;
      const y2 = face4 > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face4);
      uv.set(uv1, uvSize * vertices * face4);
      const fill6 = [face4, face4, face4, face4, face4, face4];
      faceIndex2.set(fill6, faceIndexSize * vertices * face4);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex2, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { "n": maxSamples },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "texelSize": { value: texelSize },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function WebGLCubeUVMaps(renderer2) {
  let cubeUVmaps = new WeakMap();
  let pmremGenerator = null;
  function get4(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (cubeUVmaps.has(texture)) {
          return cubeUVmaps.get(texture).texture;
        } else {
          const image2 = texture.image;
          if (isEquirectMap && image2 && image2.height > 0 || isCubeMap && image2 && isCubeTextureComplete(image2)) {
            const currentRenderTarget = renderer2.getRenderTarget();
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer2);
            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
            cubeUVmaps.set(texture, renderTarget);
            renderer2.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return renderTarget.texture;
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image2) {
    let count3 = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image2[i2] !== void 0)
        count3++;
    }
    return count3 === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose2() {
    cubeUVmaps = new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get4,
    dispose: dispose2
  };
}
function WebGLExtensions(gl) {
  const extensions2 = {};
  function getExtension(name) {
    if (extensions2[name] !== void 0) {
      return extensions2[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions2[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get4(object2, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update2(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array2 = morphAttributes[name];
      for (let i2 = 0, l3 = array2.length; i2 < l3; i2++) {
        attributes.update(array2[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version7 = 0;
    if (geometryIndex !== null) {
      const array2 = geometryIndex.array;
      version7 = geometryIndex.version;
      for (let i2 = 0, l3 = array2.length; i2 < l3; i2 += 3) {
        const a6 = array2[i2 + 0];
        const b2 = array2[i2 + 1];
        const c2 = array2[i2 + 2];
        indices.push(a6, b2, b2, c2, c2, a6);
      }
    } else {
      const array2 = geometryPosition.array;
      version7 = geometryPosition.version;
      for (let i2 = 0, l3 = array2.length / 3 - 1; i2 < l3; i2 += 3) {
        const a6 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a6, b2, b2, c2, c2, a6);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version7;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get4,
    update: update2,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions2, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement2;
  function setIndex(value) {
    type = value.type;
    bytesPerElement2 = value.bytesPerElement;
  }
  function render(start, count3) {
    gl.drawElements(mode, count3, type, start * bytesPerElement2);
    info.update(count3, mode, 1);
  }
  function renderInstances(start, count3, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions2.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count3, type, start * bytesPerElement2, primcount);
    info.update(count3, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory2 = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update2(count3, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count3 / 3);
        break;
      case 1:
        render.lines += instanceCount * (count3 / 2);
        break;
      case 3:
        render.lines += instanceCount * (count3 - 1);
        break;
      case 2:
        render.lines += instanceCount * count3;
        break;
      case 0:
        render.points += instanceCount * count3;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset2() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory: memory2,
    render,
    programs: null,
    autoReset: true,
    reset: reset2,
    update: update2
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function numericalSort(a6, b2) {
  return a6[0] - b2[0];
}
function absNumericalSort(a6, b2) {
  return Math.abs(b2[1]) - Math.abs(a6[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array2 = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array2 instanceof Int8Array)
    denominator = 127;
  else if (array2 instanceof Int16Array)
    denominator = 32767;
  else if (array2 instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array2);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = new WeakMap();
  const morph = new Vector3();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update2(object2, geometry, material, program) {
    const objectInfluences = object2.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const numberOfMorphTargets = geometry.morphAttributes.position.length;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== numberOfMorphTargets) {
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal || [];
        const numberOfVertices = geometry.attributes.position.count;
        const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
        let width = numberOfVertices * numberOfVertexData;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer2 = new Float32Array(width * height * 4 * numberOfMorphTargets);
        const texture = new DataTexture2DArray(buffer2, width, height, numberOfMorphTargets);
        texture.format = RGBAFormat;
        texture.type = FloatType;
        const vertexDataStride = numberOfVertexData * 4;
        for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const offset = width * height * 4 * i2;
          for (let j2 = 0; j2 < morphTarget.count; j2++) {
            morph.fromBufferAttribute(morphTarget, j2);
            if (morphTarget.normalized === true)
              denormalize(morph, morphTarget);
            const stride = j2 * vertexDataStride;
            buffer2[offset + stride + 0] = morph.x;
            buffer2[offset + stride + 1] = morph.y;
            buffer2[offset + stride + 2] = morph.z;
            buffer2[offset + stride + 3] = 0;
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j2);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer2[offset + stride + 4] = morph.x;
              buffer2[offset + stride + 5] = morph.y;
              buffer2[offset + stride + 6] = morph.z;
              buffer2[offset + stride + 7] = 0;
            }
          }
        }
        entry = {
          count: numberOfMorphTargets,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
            geometry.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
            geometry.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update: update2
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update2(object2) {
    const frame2 = info.render.frame;
    const geometry = object2.geometry;
    const buffergeometry = geometries.get(object2, geometry);
    if (updateMap.get(buffergeometry) !== frame2) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame2);
    }
    if (object2.isInstancedMesh) {
      if (object2.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object2.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object2.instanceMatrix, 34962);
      if (object2.instanceColor !== null) {
        attributes.update(object2.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose2() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update2,
    dispose: dispose2
  };
}
var DataTexture3D = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array2, nBlocks, blockSize) {
  const firstElem = array2[0];
  if (firstElem <= 0 || firstElem > 0)
    return array2;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array2[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a6, b2) {
  if (a6.length !== b2.length)
    return false;
  for (let i2 = 0, l3 = a6.length; i2 < l3; i2++) {
    if (a6[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a6, b2) {
  for (let i2 = 0, l3 = b2.length; i2 < l3; i2++) {
    a6[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache5 = this.cache;
  if (cache5[0] === v2)
    return;
  gl.uniform1f(this.addr, v2);
  cache5[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache5 = this.cache;
  if (v2.x !== void 0) {
    if (cache5[0] !== v2.x || cache5[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache5[0] = v2.x;
      cache5[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache5, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache5 = this.cache;
  if (v2.x !== void 0) {
    if (cache5[0] !== v2.x || cache5[1] !== v2.y || cache5[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache5[0] = v2.x;
      cache5[1] = v2.y;
      cache5[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache5[0] !== v2.r || cache5[1] !== v2.g || cache5[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache5[0] = v2.r;
      cache5[1] = v2.g;
      cache5[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache5, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache5 = this.cache;
  if (v2.x !== void 0) {
    if (cache5[0] !== v2.x || cache5[1] !== v2.y || cache5[2] !== v2.z || cache5[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache5[0] = v2.x;
      cache5[1] = v2.y;
      cache5[2] = v2.z;
      cache5[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache5, v2);
  }
}
function setValueM2(gl, v2) {
  const cache5 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache5, v2);
  } else {
    if (arraysEqual(cache5, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache5, elements);
  }
}
function setValueM3(gl, v2) {
  const cache5 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache5, v2);
  } else {
    if (arraysEqual(cache5, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache5, elements);
  }
}
function setValueM4(gl, v2) {
  const cache5 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache5, v2))
      return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache5, v2);
  } else {
    if (arraysEqual(cache5, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache5, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache5 = this.cache;
  if (cache5[0] === v2)
    return;
  gl.uniform1i(this.addr, v2);
  cache5[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueV3i(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueV4i(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueV1ui(gl, v2) {
  const cache5 = this.cache;
  if (cache5[0] === v2)
    return;
  gl.uniform1ui(this.addr, v2);
  cache5[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform2uiv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueV3ui(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform3uiv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueV4ui(gl, v2) {
  const cache5 = this.cache;
  if (arraysEqual(cache5, v2))
    return;
  gl.uniform4uiv(this.addr, v2);
  copyArray(cache5, v2);
}
function setValueT1(gl, v2, textures) {
  const cache5 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache5[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache5[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache5 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache5[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache5[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl, v2, textures) {
  const cache5 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache5[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache5[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache5 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache5[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache5[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache5 = this.cache;
  if (data instanceof Float32Array && cache5.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache5, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match3 = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match3[1];
    const idIsIndex = match3[2] === "]", subscript = match3[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u2 = this.map[name];
  if (u2 !== void 0)
    u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object2, name) {
  const v2 = object2[name];
  if (v2 !== void 0)
    this.setValue(gl, name, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl, type, string2) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string2);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string2) {
  const lines2 = string2.split("\n");
  for (let i2 = 0; i2 < lines2.length; i2++) {
    lines2[i2] = i2 + 1 + ": " + lines2[i2];
  }
  return lines2.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string2) {
  return string2 !== "";
}
function replaceLightNums(string2, parameters) {
  return string2.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string2, parameters) {
  return string2.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string2) {
  return string2.replace(includePattern, includeReplacer);
}
function includeReplacer(match3, include) {
  const string2 = ShaderChunk[include];
  if (string2 === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string2);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string2) {
  return string2.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match3, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match3, start, end, snippet);
}
function loopReplacer(match3, start, end, snippet) {
  let string2 = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string2 += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string2;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
  const gl = renderer2.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer2.gammaFactor > 0 ? renderer2.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.format === RGBFormat ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.specularTintMap ? getTexelDecodingFunction("specularTintMapTexelToLinear", parameters.specularTintMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer2.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer2, cubemaps, cubeuvmaps, extensions2, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision3 = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoat",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "specularIntensityMap",
    "specularTintMap",
    "specularTintMapEncoding",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "alphaTest",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "morphTargetsCount",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "format",
    "sheen",
    "transmission",
    "transmissionMap",
    "thicknessMap"
  ];
  function getMaxBones(object2) {
    const skeleton = object2.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    if (isWebGL2 && map && map.isTexture && map.format === RGBAFormat && map.type === UnsignedByteType && map.encoding === sRGBEncoding) {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene2, object2) {
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object2.isSkinnedMesh ? getMaxBones(object2) : 0;
    if (material.precision !== null) {
      precision3 = capabilities.getMaxPrecision(material.precision);
      if (precision3 !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision3, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer2.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision3,
      instancing: object2.isInstancedMesh === true,
      instancingColor: object2.isInstancedMesh === true && object2.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer2.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularTintMap: !!material.specularTintMap,
      specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!object2.geometry && !!object2.geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!object2.geometry && !!object2.geometry.attributes.color && object2.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object2.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: !!object2.geometry && !!object2.geometry.morphAttributes.position,
      morphNormals: !!object2.geometry && !!object2.geometry.morphAttributes.normal,
      morphTargetsCount: !!object2.geometry && !!object2.geometry.morphAttributes.position ? object2.geometry.morphAttributes.position.length : 0,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      format: material.format,
      dithering: material.dithering,
      shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer2.shadowMap.type,
      toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer2.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions2.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions2.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions2.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array2 = [];
    if (parameters.shaderID) {
      array2.push(parameters.shaderID);
    } else {
      array2.push(parameters.fragmentShader);
      array2.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array2.push(name);
        array2.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array2.push(parameters[parameterNames[i2]]);
      }
      array2.push(renderer2.outputEncoding);
      array2.push(renderer2.gammaFactor);
    }
    array2.push(parameters.customProgramCacheKey);
    return array2.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p3 = 0, pl = programs.length; p3 < pl; p3++) {
      const preexistingProgram = programs[p3];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get4(object2) {
    let map = properties.get(object2);
    if (map === void 0) {
      map = {};
      properties.set(object2, map);
    }
    return map;
  }
  function remove(object2) {
    properties.delete(object2);
  }
  function update2(object2, key, value) {
    properties.get(object2)[key] = value;
  }
  function dispose2() {
    properties = new WeakMap();
  }
  return {
    get: get4,
    remove,
    update: update2,
    dispose: dispose2
  };
}
function painterSortStable(a6, b2) {
  if (a6.groupOrder !== b2.groupOrder) {
    return a6.groupOrder - b2.groupOrder;
  } else if (a6.renderOrder !== b2.renderOrder) {
    return a6.renderOrder - b2.renderOrder;
  } else if (a6.program !== b2.program) {
    return a6.program.id - b2.program.id;
  } else if (a6.material.id !== b2.material.id) {
    return a6.material.id - b2.material.id;
  } else if (a6.z !== b2.z) {
    return a6.z - b2.z;
  } else {
    return a6.id - b2.id;
  }
}
function reversePainterSortStable(a6, b2) {
  if (a6.groupOrder !== b2.groupOrder) {
    return a6.groupOrder - b2.groupOrder;
  } else if (a6.renderOrder !== b2.renderOrder) {
    return a6.renderOrder - b2.renderOrder;
  } else if (a6.z !== b2.z) {
    return b2.z - a6.z;
  } else {
    return a6.id - b2.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object2, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object2.id,
        object: object2,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object2.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object2.id;
      renderItem.object = object2;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object2.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object2, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object2, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object2, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object2, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get4(scene2, renderCallDepth) {
    let list;
    if (lists.has(scene2) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene2, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene2).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene2).push(list);
      } else {
        list = lists.get(scene2)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose2() {
    lists = new WeakMap();
  }
  return {
    get: get4,
    dispose: dispose2
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions2, capabilities) {
  const cache5 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup46(lights, physicallyCorrectLights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i2 = 0, l3 = lights.length; i2 < l3; i2++) {
      const light2 = lights[i2];
      const color = light2.color;
      const intensity = light2.intensity;
      const distance2 = light2.distance;
      const shadowMap = light2.shadow && light2.shadow.map ? light2.shadow.map.texture : null;
      if (light2.isAmbientLight) {
        r2 += color.r * intensity * scaleFactor;
        g2 += color.g * intensity * scaleFactor;
        b2 += color.b * intensity * scaleFactor;
      } else if (light2.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light2.sh.coefficients[j2], intensity);
        }
      } else if (light2.isDirectionalLight) {
        const uniforms = cache5.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light2.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = cache5.get(light2);
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance2;
        uniforms.coneCos = Math.cos(light2.angle);
        uniforms.penumbraCos = Math.cos(light2.angle * (1 - light2.penumbra));
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light2.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = cache5.get(light2);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = cache5.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        uniforms.distance = light2.distance;
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light2.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = cache5.get(light2);
        uniforms.skyColor.copy(light2.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light2.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions2.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions2.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera2) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera2.matrixWorldInverse;
    for (let i2 = 0, l3 = lights.length; i2 < l3; i2++) {
      const light2 = lights[i2];
      if (light2.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light2.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup: setup46,
    setupView,
    state
  };
}
function WebGLRenderState(extensions2, capabilities) {
  const lights = new WebGLLights(extensions2, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light2) {
    lightsArray.push(light2);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera2) {
    lights.setupView(lightsArray, camera2);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions2, capabilities) {
  let renderStates = new WeakMap();
  function get4(scene2, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene2) === false) {
      renderState = new WebGLRenderState(extensions2, capabilities);
      renderStates.set(scene2, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene2).length) {
        renderState = new WebGLRenderState(extensions2, capabilities);
        renderStates.get(scene2).push(renderState);
      } else {
        renderState = renderStates.get(scene2)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = new WeakMap();
  }
  return {
    get: get4,
    dispose: dispose2
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 },
      samples: { value: 8 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene2, camera2) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light2 = lights[i2];
      const shadow = light2.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light2, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light2.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light2.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light2, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene2, camera2, shadow.camera, light2, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera2);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera2) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    shadowMaterialVertical.uniforms.samples.value = shadow.blurSamples;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    shadowMaterialHorizontal.uniforms.samples.value = shadow.blurSamples;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object2, geometry, material, light2, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light2.isPointLight === true ? object2.customDistanceMaterial : object2.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light2.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light2.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light2.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object2, camera2, shadowCamera, light2, type) {
    if (object2.visible === false)
      return;
    const visible = object2.layers.test(camera2.layers);
    if (visible && (object2.isMesh || object2.isLine || object2.isPoints)) {
      if ((object2.castShadow || object2.receiveShadow && type === VSMShadowMap) && (!object2.frustumCulled || _frustum.intersectsObject(object2))) {
        object2.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object2.matrixWorld);
        const geometry = _objects.update(object2);
        const material = object2.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k3 = 0, kl = groups.length; k3 < kl; k3++) {
            const group = groups[k3];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object2, geometry, groupMaterial, light2, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object2, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object2, geometry, material, light2, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object2, null);
        }
      }
    }
    const children = object2.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      renderObject(children[i2], camera2, shadowCamera, light2, type);
    }
  }
}
function WebGLState(gl, extensions2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a6, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a6;
          g2 *= a6;
          b2 *= a6;
        }
        color.set(r2, g2, b2, a6);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a6);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version7 = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version7 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version7 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version7 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version7 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture2(type, target, count3) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count3; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture2(3553, 3553, 1);
  emptyTextures[34067] = createTexture2(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null)
      framebuffer = xrFramebuffer;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions2.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset2() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    bindXRFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset: reset2
  };
}
function WebGLTextures(_gl, extensions2, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas2(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image2, needsPowerOfTwo, needsNewCanvas, maxSize2) {
    let scale3 = 1;
    if (image2.width > maxSize2 || image2.height > maxSize2) {
      scale3 = maxSize2 / Math.max(image2.width, image2.height);
    }
    if (scale3 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
        const floor5 = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor5(scale3 * image2.width);
        const height = floor5(scale3 * image2.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas2(width, height);
        const canvas3 = needsNewCanvas ? createCanvas2(width, height) : _canvas2;
        canvas3.width = width;
        canvas3.height = height;
        const context = canvas3.getContext("2d");
        context.drawImage(image2, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image2.width + "x" + image2.height + ") to (" + width + "x" + height + ").");
        return canvas3;
      } else {
        if ("data" in image2) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image2.width + "x" + image2.height + ").");
        }
        return image2;
      }
    }
    return image2;
  }
  function isPowerOfTwo$1(image2) {
    return isPowerOfTwo(image2.width) && isPowerOfTwo(image2.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height, depth = 1) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding ? 35907 : 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions2.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image2 = texture.image;
      if (image2 === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image2.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions2.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions2.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions2.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions2.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image2 = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image2) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, image2.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image2);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image2.width, image2.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i2 = 0; i2 < 6; i2++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
      } else {
        cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
      }
    }
    const image2 = cubeImage[0], supportsMips = isPowerOfTwo$1(image2) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i2 = 0; i2 < 6; i2++) {
        mipmaps = cubeImage[i2].mipmaps;
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            const mipmapImage = mipmap.image[i2].image;
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image2.width, image2.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    state.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      textureProperties.__webglTexture = _gl.createTexture();
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame2 = info.render.frame;
    if (_videoTextures.get(texture) !== frame2) {
      _videoTextures.set(texture, frame2);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p3) {
    let extension;
    if (p3 === UnsignedByteType)
      return 5121;
    if (p3 === UnsignedShort4444Type)
      return 32819;
    if (p3 === UnsignedShort5551Type)
      return 32820;
    if (p3 === UnsignedShort565Type)
      return 33635;
    if (p3 === ByteType)
      return 5120;
    if (p3 === ShortType)
      return 5122;
    if (p3 === UnsignedShortType)
      return 5123;
    if (p3 === IntType)
      return 5124;
    if (p3 === UnsignedIntType)
      return 5125;
    if (p3 === FloatType)
      return 5126;
    if (p3 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions2.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p3 === AlphaFormat)
      return 6406;
    if (p3 === RGBFormat)
      return 6407;
    if (p3 === RGBAFormat)
      return 6408;
    if (p3 === LuminanceFormat)
      return 6409;
    if (p3 === LuminanceAlphaFormat)
      return 6410;
    if (p3 === DepthFormat)
      return 6402;
    if (p3 === DepthStencilFormat)
      return 34041;
    if (p3 === RedFormat)
      return 6403;
    if (p3 === RedIntegerFormat)
      return 36244;
    if (p3 === RGFormat)
      return 33319;
    if (p3 === RGIntegerFormat)
      return 33320;
    if (p3 === RGBIntegerFormat)
      return 36248;
    if (p3 === RGBAIntegerFormat)
      return 36249;
    if (p3 === RGB_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT3_Format || p3 === RGBA_S3TC_DXT5_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p3 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p3 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p3 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p3 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RGB_PVRTC_4BPPV1_Format || p3 === RGB_PVRTC_2BPPV1_Format || p3 === RGBA_PVRTC_4BPPV1_Format || p3 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p3 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p3 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p3 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p3 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC1_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC2_Format || p3 === RGBA_ETC2_EAC_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p3 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p3 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p3 === RGBA_ASTC_4x4_Format || p3 === RGBA_ASTC_5x4_Format || p3 === RGBA_ASTC_5x5_Format || p3 === RGBA_ASTC_6x5_Format || p3 === RGBA_ASTC_6x6_Format || p3 === RGBA_ASTC_8x5_Format || p3 === RGBA_ASTC_8x6_Format || p3 === RGBA_ASTC_8x8_Format || p3 === RGBA_ASTC_10x5_Format || p3 === RGBA_ASTC_10x6_Format || p3 === RGBA_ASTC_10x8_Format || p3 === RGBA_ASTC_10x10_Format || p3 === RGBA_ASTC_12x10_Format || p3 === RGBA_ASTC_12x12_Format || p3 === SRGB8_ALPHA8_ASTC_4x4_Format || p3 === SRGB8_ALPHA8_ASTC_5x4_Format || p3 === SRGB8_ALPHA8_ASTC_5x5_Format || p3 === SRGB8_ALPHA8_ASTC_6x5_Format || p3 === SRGB8_ALPHA8_ASTC_6x6_Format || p3 === SRGB8_ALPHA8_ASTC_8x5_Format || p3 === SRGB8_ALPHA8_ASTC_8x6_Format || p3 === SRGB8_ALPHA8_ASTC_8x8_Format || p3 === SRGB8_ALPHA8_ASTC_10x5_Format || p3 === SRGB8_ALPHA8_ASTC_10x6_Format || p3 === SRGB8_ALPHA8_ASTC_10x8_Format || p3 === SRGB8_ALPHA8_ASTC_10x10_Format || p3 === SRGB8_ALPHA8_ASTC_12x10_Format || p3 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p3;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_BPTC_Format) {
      extension = extensions2.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p3;
      } else {
        return null;
      }
    }
    if (p3 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions2.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array2 = []) {
    super();
    this.cameras = array2;
  }
};
ArrayCamera.prototype.isArrayCamera = true;
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame2, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand3 = this._hand;
    if (inputSource && frame2.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame2.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand3 && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame2.getJointPose(inputjoint, referenceSpace);
          if (hand3.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand3.joints[inputjoint.jointName] = joint2;
            hand3.add(joint2);
          }
          const joint = hand3.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand3.joints["index-finger-tip"];
        const thumbTip = hand3.joints["thumb-tip"];
        const distance2 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold3 = 5e-3;
        if (hand3.inputState.pinching && distance2 > distanceToPinch + threshold3) {
          hand3.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand3.inputState.pinching && distance2 <= distanceToPinch - threshold3) {
          hand3.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame2.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand3 !== null) {
      hand3.visible = handPose !== null;
    }
    return this;
  }
};
var WebXRManager = class extends EventDispatcher {
  constructor(renderer2, gl) {
    super();
    const scope = this;
    const state = renderer2.state;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    let glBinding = null;
    let glFramebuffer = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let isMultisample = false;
    let glMultisampledFramebuffer = null;
    let glColorRenderbuffer = null;
    let glDepthRenderbuffer = null;
    let xrFrame = null;
    let depthStyle = null;
    let clearStyle = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      state.bindXRFramebuffer(null);
      renderer2.setRenderTarget(renderer2.getRenderTarget());
      if (glFramebuffer)
        gl.deleteFramebuffer(glFramebuffer);
      if (glMultisampledFramebuffer)
        gl.deleteFramebuffer(glMultisampledFramebuffer);
      if (glColorRenderbuffer)
        gl.deleteRenderbuffer(glColorRenderbuffer);
      if (glDepthRenderbuffer)
        gl.deleteRenderbuffer(glDepthRenderbuffer);
      glFramebuffer = null;
      glMultisampledFramebuffer = null;
      glColorRenderbuffer = null;
      glDepthRenderbuffer = null;
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        const attributes = gl.getContextAttributes();
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
        } else if (gl instanceof WebGLRenderingContext) {
          const layerInit = {
            antialias: true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ layers: [glBaseLayer] });
        } else {
          isMultisample = attributes.antialias;
          let depthFormat = null;
          if (attributes.depth) {
            clearStyle = 256;
            if (attributes.stencil)
              clearStyle |= 1024;
            depthStyle = attributes.stencil ? 33306 : 36096;
            depthFormat = attributes.stencil ? 35056 : 33190;
          }
          const projectionlayerInit = {
            colorFormat: attributes.alpha ? 32856 : 32849,
            depthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          glFramebuffer = gl.createFramebuffer();
          session.updateRenderState({ layers: [glProjLayer] });
          if (isMultisample) {
            glMultisampledFramebuffer = gl.createFramebuffer();
            glColorRenderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(36161, glColorRenderbuffer);
            gl.renderbufferStorageMultisample(36161, 4, 32856, glProjLayer.textureWidth, glProjLayer.textureHeight);
            state.bindFramebuffer(36160, glMultisampledFramebuffer);
            gl.framebufferRenderbuffer(36160, 36064, 36161, glColorRenderbuffer);
            gl.bindRenderbuffer(36161, null);
            if (depthFormat !== null) {
              glDepthRenderbuffer = gl.createRenderbuffer();
              gl.bindRenderbuffer(36161, glDepthRenderbuffer);
              gl.renderbufferStorageMultisample(36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
              gl.framebufferRenderbuffer(36160, depthStyle, 36161, glDepthRenderbuffer);
              gl.bindRenderbuffer(36161, null);
            }
            state.bindFramebuffer(36160, null);
          }
        }
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        inputSourcesMap.set(inputSources[i2], controllers[i2]);
      }
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.translateX(xOffset);
      camera2.translateZ(zOffset);
      camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera2, parent) {
      if (parent === null) {
        camera2.matrixWorld.copy(camera2.matrix);
      } else {
        camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
      }
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
    }
    this.updateCamera = function(camera2) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera2.near;
      cameraVR.far = cameraR.far = cameraL.far = camera2.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera2.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera2.position.copy(cameraVR.position);
      camera2.quaternion.copy(cameraVR.quaternion);
      camera2.scale.copy(cameraVR.scale);
      camera2.matrix.copy(cameraVR.matrix);
      camera2.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera2.children;
      for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time2, frame2) {
      pose = frame2.getViewerPose(referenceSpace);
      xrFrame = frame2;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          state.bindXRFramebuffer(glBaseLayer.framebuffer);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            state.bindXRFramebuffer(glFramebuffer);
            if (glSubImage.depthStencilTexture !== void 0) {
              gl.framebufferTexture2D(36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0);
            }
            gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
            viewport = glSubImage.viewport;
          }
          const camera2 = cameras[i2];
          camera2.matrix.fromArray(view.transform.matrix);
          camera2.projectionMatrix.fromArray(view.projectionMatrix);
          camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraVR.matrix.copy(camera2.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera2);
          }
        }
        if (isMultisample) {
          state.bindXRFramebuffer(glMultisampledFramebuffer);
          if (clearStyle !== null)
            gl.clear(clearStyle);
        }
      }
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const controller = controllers[i2];
        const inputSource = inputSources[i2];
        controller.update(inputSource, frame2, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time2, frame2);
      if (isMultisample) {
        const width = glProjLayer.textureWidth;
        const height = glProjLayer.textureHeight;
        state.bindFramebuffer(36008, glMultisampledFramebuffer);
        state.bindFramebuffer(36009, glFramebuffer);
        gl.invalidateFramebuffer(36008, [depthStyle]);
        gl.invalidateFramebuffer(36009, [depthStyle]);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, 16384, 9728);
        gl.invalidateFramebuffer(36008, [36064]);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, null);
        state.bindFramebuffer(36160, glMultisampledFramebuffer);
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularTintMap) {
      uvScaleMap = material.specularTintMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenTint.value.copy(material.sheenTint).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationTint.value.copy(material.attenuationTint);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularTint.value.copy(material.specularTint);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularTintMap) {
      uniforms.specularTintMap.value = material.specularTintMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas3 = createElementNS("canvas");
  canvas3.style.display = "block";
  return canvas3;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _currentDrawBuffers = [];
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions2, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions2 = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions2, parameters);
    extensions2.init(capabilities);
    utils = new WebGLUtils(_gl, extensions2, capabilities);
    state = new WebGLState(_gl, extensions2, capabilities);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions2, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions2, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions2, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions2, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions2, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions2, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions2;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions2.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions2.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  function renderObjectImmediate(object2, program) {
    object2.render(function(object3) {
      _this.renderBufferImmediate(object3, program);
    });
  }
  this.renderBufferImmediate = function(object2, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object2);
    if (object2.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object2.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object2.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object2.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object2.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object2.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position.location);
      _gl.vertexAttribPointer(programAttributes.position.location, 3, 5126, false, 0, 0);
    }
    if (object2.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object2.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal.location);
      _gl.vertexAttribPointer(programAttributes.normal.location, 3, 5126, false, 0, 0);
    }
    if (object2.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object2.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv.location);
      _gl.vertexAttribPointer(programAttributes.uv.location, 2, 5126, false, 0, 0);
    }
    if (object2.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object2.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color.location);
      _gl.vertexAttribPointer(programAttributes.color.location, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object2.count);
    object2.count = 0;
  };
  this.renderBufferDirect = function(camera2, scene2, geometry, material, object2, group) {
    if (scene2 === null)
      scene2 = _emptyScene;
    const frontFaceCW = object2.isMesh && object2.matrixWorld.determinant() < 0;
    const program = setProgram(camera2, scene2, geometry, material, object2);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object2, material, program, geometry, index);
    let attribute;
    let renderer2 = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer2 = indexedBufferRenderer;
      renderer2.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object2.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer2.setMode(1);
      } else {
        renderer2.setMode(4);
      }
    } else if (object2.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object2.isLineSegments) {
        renderer2.setMode(1);
      } else if (object2.isLineLoop) {
        renderer2.setMode(2);
      } else {
        renderer2.setMode(3);
      }
    } else if (object2.isPoints) {
      renderer2.setMode(0);
    } else if (object2.isSprite) {
      renderer2.setMode(4);
    }
    if (object2.isInstancedMesh) {
      renderer2.renderInstances(drawStart, drawCount, object2.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer2.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer2.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene2, camera2) {
    currentRenderState = renderStates.get(scene2);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene2.traverseVisible(function(object2) {
      if (object2.isLight && object2.layers.test(camera2.layers)) {
        currentRenderState.pushLight(object2);
        if (object2.castShadow) {
          currentRenderState.pushShadow(object2);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene2.traverse(function(object2) {
      const material = object2.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene2, object2);
          }
        } else {
          getProgram(material, scene2, object2);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time2) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time2);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene2, camera2) {
    if (camera2 !== void 0 && camera2.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene2.autoUpdate === true)
      scene2.updateMatrixWorld();
    if (camera2.parent === null)
      camera2.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera2);
      camera2 = xr.getCamera();
    }
    if (scene2.isScene === true)
      scene2.onBeforeRender(_this, scene2, camera2, _currentRenderTarget);
    currentRenderState = renderStates.get(scene2, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
    currentRenderList = renderLists.get(scene2, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene2, camera2, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene2, camera2);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene2);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera2.isArrayCamera) {
      const cameras = camera2.cameras;
      for (let i2 = 0, l3 = cameras.length; i2 < l3; i2++) {
        const camera22 = cameras[i2];
        renderScene(currentRenderList, scene2, camera22, camera22.viewport);
      }
    } else {
      renderScene(currentRenderList, scene2, camera2);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene2.isScene === true)
      scene2.onAfterRender(_this, scene2, camera2);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object2, camera2, groupOrder, sortObjects) {
    if (object2.visible === false)
      return;
    const visible = object2.layers.test(camera2.layers);
    if (visible) {
      if (object2.isGroup) {
        groupOrder = object2.renderOrder;
      } else if (object2.isLOD) {
        if (object2.autoUpdate === true)
          object2.update(camera2);
      } else if (object2.isLight) {
        currentRenderState.pushLight(object2);
        if (object2.castShadow) {
          currentRenderState.pushShadow(object2);
        }
      } else if (object2.isSprite) {
        if (!object2.frustumCulled || _frustum.intersectsSprite(object2)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object2);
          const material = object2.material;
          if (material.visible) {
            currentRenderList.push(object2, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object2.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object2, null, object2.material, groupOrder, _vector3.z, null);
      } else if (object2.isMesh || object2.isLine || object2.isPoints) {
        if (object2.isSkinnedMesh) {
          if (object2.skeleton.frame !== info.render.frame) {
            object2.skeleton.update();
            object2.skeleton.frame = info.render.frame;
          }
        }
        if (!object2.frustumCulled || _frustum.intersectsObject(object2)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object2);
          const material = object2.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l3 = groups.length; i2 < l3; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object2, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object2, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object2.children;
    for (let i2 = 0, l3 = children.length; i2 < l3; i2++) {
      projectObject(children[i2], camera2, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene2, camera2, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera2);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene2, camera2);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene2, camera2);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene2, camera2);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene2, camera2);
  }
  function renderTransmissionPass(opaqueObjects, scene2, camera2) {
    if (_transmissionRenderTarget === null) {
      const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      _transmissionRenderTarget = new renderTargetType(1024, 1024, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene2, camera2);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene2, camera2) {
    const overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
    for (let i2 = 0, l3 = renderList.length; i2 < l3; i2++) {
      const renderItem = renderList[i2];
      const object2 = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object2.layers.test(camera2.layers)) {
        renderObject(object2, scene2, camera2, geometry, material, group);
      }
    }
  }
  function renderObject(object2, scene2, camera2, geometry, material, group) {
    object2.onBeforeRender(_this, scene2, camera2, geometry, material, group);
    object2.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object2.matrixWorld);
    object2.normalMatrix.getNormalMatrix(object2.modelViewMatrix);
    material.onBeforeRender(_this, scene2, camera2, geometry, object2, group);
    if (object2.isImmediateRenderObject) {
      const program = setProgram(camera2, scene2, geometry, material, object2);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object2, program);
    } else {
      if (material.transparent === true && material.side === DoubleSide) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
      }
    }
    object2.onAfterRender(_this, scene2, camera2, geometry, material, group);
  }
  function getProgram(material, scene2, object2) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object2);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
    materialProperties.fog = scene2.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
  }
  function setProgram(camera2, scene2, geometry, material, object2) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry && !!geometry.attributes.tangent;
    const morphTargets = !!geometry && !!geometry.morphAttributes.position;
    const morphNormals = !!geometry && !!geometry.morphAttributes.normal;
    const morphTargetsCount = !!geometry && !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera2 !== _currentCamera) {
        const useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera2, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object2.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object2.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object2.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object2.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene2, object2);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera2) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera2) {
        _currentCamera = camera2;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object2.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
      }
    }
    if (object2.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object2, "bindMatrix");
      p_uniforms.setOptional(_gl, object2, "bindMatrixInverse");
      const skeleton = object2.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
      morphtargets.update(object2, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object2.receiveShadow) {
      materialProperties.receiveShadow = object2.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object2.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object2.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object2.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object2.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object2.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers) {
      let needsUpdate = false;
      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures2 = renderTarget.texture;
          if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
            for (let i2 = 0, il = textures2.length; i2 < il; i2++) {
              _currentDrawBuffers[i2] = 36064 + i2;
            }
            _currentDrawBuffers.length = textures2.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions2.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer2, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions2.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions2.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions2.has("OES_texture_float") || extensions2.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer2);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils.convert(texture.format);
    if (capabilities.isWebGL2) {
      if (glFormat === 6407)
        glFormat = 32849;
      if (glFormat === 6408)
        glFormat = 32856;
    }
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image2.width);
    _gl.pixelStorei(32878, image2.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image2.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image2.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image2);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density = 25e-5) {
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near = 1, far = 1e3) {
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
};
Scene.prototype.isScene = true;
var InterleavedBuffer = class {
  constructor(array2, stride) {
    this.array = array2;
    this.stride = stride;
    this.count = array2 !== void 0 ? array2.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l3 = this.stride; i2 < l3; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array2 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array2, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
InterleavedBuffer.prototype.isInterleavedBuffer = true;
var _vector$6 = /* @__PURE__ */ new Vector3();
var InterleavedBufferAttribute = class {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l3 = this.data.count; i2 < l3; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l3 = this.count; i2 < l3; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.transformDirection(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index, x2) {
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  }
  setY(index, y2) {
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  setW(index, w2) {
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }
  setXY(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array2 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array2.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array2), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array2 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array2.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array2,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
var _vA = /* @__PURE__ */ new Vector3();
var _vB = /* @__PURE__ */ new Vector3();
var _vC = /* @__PURE__ */ new Vector3();
var _uvA = /* @__PURE__ */ new Vector2();
var _uvB = /* @__PURE__ */ new Vector2();
var _uvC = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin5, cos5;
    if (rotation !== 0) {
      cos5 = Math.cos(rotation);
      sin5 = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin5, cos5);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin5, cos5);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin5, cos5);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin5, cos5);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance2 = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale3, sin5, cos5) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale3);
  if (sin5 !== void 0) {
    _rotatedPosition.x = cos5 * _alignedPosition.x - sin5 * _alignedPosition.y;
    _rotatedPosition.y = sin5 * _alignedPosition.x + cos5 * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _basePosition = /* @__PURE__ */ new Vector3();
var _skinIndex = /* @__PURE__ */ new Vector4();
var _skinWeight = /* @__PURE__ */ new Vector4();
var _vector$5 = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix4();
var SkinnedMesh = class extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l3 = skinWeight.count; i2 < l3; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale3 = 1 / vector.manhattanLength();
      if (scale3 !== Infinity) {
        vector.multiplyScalar(scale3);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
};
SkinnedMesh.prototype.isSkinnedMesh = true;
var Bone = class extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
};
Bone.prototype.isBone = true;
var DataTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { data, width, height };
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4);
    size2 = ceilPowerOfTwo(size2);
    size2 = Math.max(size2, 4);
    const boneMatrices = new Float32Array(size2 * size2 * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size2;
    return this;
  }
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json20, bones) {
    this.uuid = json20.uuid;
    for (let i2 = 0, l3 = json20.bones.length; i2 < l3; i2++) {
      const uuid = json20.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json20.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l3 = bones.length; i2 < l3; i2++) {
      const bone = bones[i2];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
var InstancedBufferAttribute = class extends BufferAttribute {
  constructor(array2, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array2, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
};
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
var _instanceIntersects = [];
var _mesh = /* @__PURE__ */ new Mesh();
var InstancedMesh = class extends Mesh {
  constructor(geometry, material, count3) {
    super(geometry, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count3 * 16), 16);
    this.instanceColor = null;
    this.count = count3;
    this.frustumCulled = false;
  }
  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l3 = _instanceIntersects.length; i2 < l3; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
InstancedMesh.prototype.isInstancedMesh = true;
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start$1 = /* @__PURE__ */ new Vector3();
var _end$1 = /* @__PURE__ */ new Vector3();
var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
var _ray$1 = /* @__PURE__ */ new Ray();
var _sphere$1 = /* @__PURE__ */ new Sphere();
var Line = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l3 = positionAttribute.count; i2 < l3; i2++) {
          _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold3 = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold3;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold3 / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step5 = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, l3 = end - 1; i2 < l3; i2 += step5) {
          const a6 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          vStart.fromBufferAttribute(positionAttribute, a6);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l3 = end - 1; i2 < l3; i2 += step5) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Line.prototype.isLine = true;
var _start = /* @__PURE__ */ new Vector3();
var _end = /* @__PURE__ */ new Vector3();
var LineSegments = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l3 = positionAttribute.count; i2 < l3; i2 += 2) {
          _start.fromBufferAttribute(positionAttribute, i2);
          _end.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
};
LineSegments.prototype.isLineSegments = true;
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix = /* @__PURE__ */ new Matrix4();
var _ray = /* @__PURE__ */ new Ray();
var _sphere = /* @__PURE__ */ new Sphere();
var _position$2 = /* @__PURE__ */ new Vector3();
var Points = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold3 = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold3;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold3 / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2++) {
          const a6 = index.getX(i2);
          _position$2.fromBufferAttribute(positionAttribute, a6);
          testPoint(_position$2, a6, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l3 = end; i2 < l3; i2++) {
          _position$2.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Points.prototype.isPoints = true;
function testPoint(point2, index, localThresholdSq, matrixWorld, raycaster, intersects2, object2) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point2);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point2, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object: object2
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas3, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas3, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var _v0 = new Vector3();
var _v1$1 = new Vector3();
var _normal = new Vector3();
var _triangle = new Triangle();
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  getPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  }
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  }
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache5 = [];
    let current, last5 = this.getPoint(0);
    let sum7 = 0;
    cache5.push(0);
    for (let p3 = 1; p3 <= divisions; p3++) {
      current = this.getPoint(p3 / divisions);
      sum7 += current.distanceTo(last5);
      cache5.push(sum7);
      last5 = current;
    }
    this.cacheArcLengths = cache5;
    return cache5;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  getUtoTmapping(u2, distance2) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance2) {
      targetArcLength = distance2;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  }
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min7 = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min7) {
      min7 = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min7) {
      min7 = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min7) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json20) {
    this.arcLengthDivisions = json20.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point2 = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle2 = this.aStartAngle + t2 * deltaAngle;
    let x2 = this.aX + this.xRadius * Math.cos(angle2);
    let y2 = this.aY + this.yRadius * Math.sin(angle2);
    if (this.aRotation !== 0) {
      const cos5 = Math.cos(this.aRotation);
      const sin5 = Math.sin(this.aRotation);
      const tx = x2 - this.aX;
      const ty = y2 - this.aY;
      x2 = tx * cos5 - ty * sin5 + this.aX;
      y2 = tx * sin5 + ty * cos5 + this.aY;
    }
    return point2.set(x2, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.aX = json20.aX;
    this.aY = json20.aY;
    this.xRadius = json20.xRadius;
    this.yRadius = json20.yRadius;
    this.aStartAngle = json20.aStartAngle;
    this.aEndAngle = json20.aEndAngle;
    this.aClockwise = json20.aClockwise;
    this.aRotation = json20.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init2(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init2(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const points = this.points;
    const l3 = points.length;
    const p3 = (l3 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p3);
    let weight = p3 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l3) + 1) * l3;
    } else if (weight === 0 && intPoint === l3 - 1) {
      intPoint = l3 - 2;
      weight = 1;
    }
    let p0, p32;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l3];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l3];
    const p22 = points[(intPoint + 1) % l3];
    if (this.closed || intPoint + 2 < l3) {
      p32 = points[(intPoint + 2) % l3];
    } else {
      tmp.subVectors(points[l3 - 1], points[l3 - 2]).add(points[l3 - 1]);
      p32 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow5 = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow5);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow5);
      let dt2 = Math.pow(p22.distanceToSquared(p32), pow5);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p32.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p32.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p32.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p32.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p32.z, this.tension);
    }
    point2.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l3 = source.points.length; i2 < l3; i2++) {
      const point2 = source.points[i2];
      this.points.push(point2.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l3 = this.points.length; i2 < l3; i2++) {
      const point2 = this.points[i2];
      data.points.push(point2.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.points = [];
    for (let i2 = 0, l3 = json20.points.length; i2 < l3; i2++) {
      const point2 = json20.points[i2];
      this.points.push(new Vector3().fromArray(point2));
    }
    this.closed = json20.closed;
    this.curveType = json20.curveType;
    this.tension = json20.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t2, p0, p1, p22, p3) {
  const v0 = (p22 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p22 + v0 + v1) * t3 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p3) {
  const k3 = 1 - t2;
  return k3 * k3 * p3;
}
function QuadraticBezierP1(t2, p3) {
  return 2 * (1 - t2) * t2 * p3;
}
function QuadraticBezierP2(t2, p3) {
  return t2 * t2 * p3;
}
function QuadraticBezier(t2, p0, p1, p22) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p22);
}
function CubicBezierP0(t2, p3) {
  const k3 = 1 - t2;
  return k3 * k3 * k3 * p3;
}
function CubicBezierP1(t2, p3) {
  const k3 = 1 - t2;
  return 3 * k3 * k3 * t2 * p3;
}
function CubicBezierP2(t2, p3) {
  return 3 * (1 - t2) * t2 * t2 * p3;
}
function CubicBezierP3(t2, p3) {
  return t2 * t2 * t2 * p3;
}
function CubicBezier(t2, p0, p1, p22, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p22) + CubicBezierP3(t2, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v0.fromArray(json20.v0);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    this.v3.fromArray(json20.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v0.fromArray(json20.v0);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    this.v3.fromArray(json20.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    if (t2 === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t2).add(this.v1);
    }
    return point2;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    if (t2 === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t2).add(this.v1);
    }
    return point2;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v0.fromArray(json20.v0);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.v0.fromArray(json20.v0);
    this.v1.fromArray(json20.v1);
    this.v2.fromArray(json20.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const points = this.points;
    const p3 = (points.length - 1) * t2;
    const intPoint = Math.floor(p3);
    const weight = p3 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point2.set(CatmullRom(weight, p0.x, p1.x, p22.x, p32.x), CatmullRom(weight, p0.y, p1.y, p22.y, p32.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l3 = source.points.length; i2 < l3; i2++) {
      const point2 = source.points[i2];
      this.points.push(point2.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l3 = this.points.length; i2 < l3; i2++) {
      const point2 = this.points[i2];
      data.points.push(point2.toArray());
    }
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.points = [];
    for (let i2 = 0, l3 = json20.points.length; i2 < l3; i2++) {
      const point2 = json20.points[i2];
      this.points.push(new Vector2().fromArray(point2));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t2, optionalTarget) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2, optionalTarget);
      }
      i2++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l3 = this.curves.length; i2 < l3; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last5;
    for (let i2 = 0, curves2 = this.curves; i2 < curves2.length; i2++) {
      const curve = curves2[i2];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point2 = pts[j2];
        if (last5 && last5.equals(point2))
          continue;
        points.push(point2);
        last5 = point2;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l3 = source.curves.length; i2 < l3; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l3 = this.curves.length; i2 < l3; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.autoClose = json20.autoClose;
    this.curves = [];
    for (let i2 = 0, l3 = json20.curves.length; i2 < l3; i2++) {
      const curve = json20.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l3 = points.length; i2 < l3; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x2, y2) {
    this.currentPoint.set(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
    this.curves.push(curve);
    this.currentPoint.set(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.currentPoint.fromArray(json20.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l3 = this.holes.length; i2 < l3; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l3 = source.holes.length; i2 < l3; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l3 = this.holes.length; i2 < l3; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json20) {
    super.fromJSON(json20);
    this.uuid = json20.uuid;
    this.holes = [];
    for (let i2 = 0, l3 = json20.holes.length; i2 < l3; i2++) {
      const hole = json20.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y2 = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i2, last5;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last5 = insertNode(i2, data[i2], data[i2 + 1], last5);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last5 = insertNode(i2, data[i2], data[i2 + 1], last5);
  }
  if (last5 && equals(last5, last5.next)) {
    removeNode(last5);
    last5 = last5.next;
  }
  return last5;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p3 = start, again;
  do {
    again = false;
    if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
      removeNode(p3);
      p3 = end = p3.prev;
      if (p3 === p3.next)
        break;
      again = true;
    } else {
      p3 = p3.next;
    }
  } while (again || p3 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a6 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a6, b2, c2) >= 0)
    return false;
  let p3 = ear.next.next;
  while (p3 !== ear.prev) {
    if (pointInTriangle(a6.x, a6.y, b2.x, b2.y, c2.x, c2.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a6 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a6, b2, c2) >= 0)
    return false;
  const minTX = a6.x < b2.x ? a6.x < c2.x ? a6.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a6.y < b2.y ? a6.y < c2.y ? a6.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a6.x > b2.x ? a6.x > c2.x ? a6.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a6.y > b2.y ? a6.y > c2.y ? a6.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p3 = ear.prevZ, n2 = ear.nextZ;
  while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
    if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a6.x, a6.y, b2.x, b2.y, c2.x, c2.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a6.x, a6.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p3 && p3.z >= minZ) {
    if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a6.x, a6.y, b2.x, b2.y, c2.x, c2.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a6.x, a6.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p3 = start;
  do {
    const a6 = p3.prev, b2 = p3.next.next;
    if (!equals(a6, b2) && intersects(a6, p3, p3.next, b2) && locallyInside(a6, b2) && locallyInside(b2, a6)) {
      triangles.push(a6.i / dim);
      triangles.push(p3.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p3);
      removeNode(p3.next);
      p3 = start = b2;
    }
    p3 = p3.next;
  } while (p3 !== start);
  return filterPoints(p3);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a6 = start;
  do {
    let b2 = a6.next.next;
    while (b2 !== a6.prev) {
      if (a6.i !== b2.i && isValidDiagonal(a6, b2)) {
        let c2 = splitPolygon(a6, b2);
        a6 = filterPoints(a6, a6.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a6, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a6 = a6.next;
  } while (a6 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a6, b2) {
  return a6.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p3 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m2;
  do {
    if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
      const x2 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p3.y)
            return p3;
          if (hy === p3.next.y)
            return p3.next;
        }
        m2 = p3.x < p3.next.x ? p3 : p3.next;
      }
    }
    p3 = p3.next;
  } while (p3 !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan4;
  p3 = m2;
  do {
    if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
      tan4 = Math.abs(hy - p3.y) / (hx - p3.x);
      if (locallyInside(p3, hole) && (tan4 < tanMin || tan4 === tanMin && (p3.x > m2.x || p3.x === m2.x && sectorContainsSector(m2, p3)))) {
        m2 = p3;
        tanMin = tan4;
      }
    }
    p3 = p3.next;
  } while (p3 !== stop);
  return m2;
}
function sectorContainsSector(m2, p3) {
  return area(m2.prev, m2, p3.prev) < 0 && area(p3.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p3 = start;
  do {
    if (p3.z === null)
      p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
    p3.prevZ = p3.prev;
    p3.nextZ = p3.next;
    p3 = p3.next;
  } while (p3 !== start);
  p3.prevZ.nextZ = null;
  p3.prevZ = null;
  sortLinked(p3);
}
function sortLinked(list) {
  let i2, p3, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p3 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p3) {
      numMerges++;
      q2 = p3;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
          e2 = p3;
          p3 = p3.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p3 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p3 = start, leftmost = start;
  do {
    if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
      leftmost = p3;
    p3 = p3.next;
  } while (p3 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a6, b2) {
  return a6.next.i !== b2.i && a6.prev.i !== b2.i && !intersectsPolygon(a6, b2) && (locallyInside(a6, b2) && locallyInside(b2, a6) && middleInside(a6, b2) && (area(a6.prev, a6, b2.prev) || area(a6, b2.prev, b2)) || equals(a6, b2) && area(a6.prev, a6, a6.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p3, q2, r2) {
  return (q2.y - p3.y) * (r2.x - q2.x) - (q2.x - p3.x) * (r2.y - q2.y);
}
function equals(p1, p22) {
  return p1.x === p22.x && p1.y === p22.y;
}
function intersects(p1, q1, p22, q2) {
  const o1 = sign(area(p1, q1, p22));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p22, q2, p1));
  const o4 = sign(area(p22, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p22, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p22, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p22, q1, q2))
    return true;
  return false;
}
function onSegment(p3, q2, r2) {
  return q2.x <= Math.max(p3.x, r2.x) && q2.x >= Math.min(p3.x, r2.x) && q2.y <= Math.max(p3.y, r2.y) && q2.y >= Math.min(p3.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a6, b2) {
  let p3 = a6;
  do {
    if (p3.i !== a6.i && p3.next.i !== a6.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a6, b2))
      return true;
    p3 = p3.next;
  } while (p3 !== a6);
  return false;
}
function locallyInside(a6, b2) {
  return area(a6.prev, a6, a6.next) < 0 ? area(a6, b2, a6.next) >= 0 && area(a6, a6.prev, b2) >= 0 : area(a6, b2, a6.prev) < 0 || area(a6, a6.next, b2) < 0;
}
function middleInside(a6, b2) {
  let p3 = a6, inside = false;
  const px2 = (a6.x + b2.x) / 2, py2 = (a6.y + b2.y) / 2;
  do {
    if (p3.y > py2 !== p3.next.y > py2 && p3.next.y !== p3.y && px2 < (p3.next.x - p3.x) * (py2 - p3.y) / (p3.next.y - p3.y) + p3.x)
      inside = !inside;
    p3 = p3.next;
  } while (p3 !== a6);
  return inside;
}
function splitPolygon(a6, b2) {
  const a22 = new Node(a6.i, a6.x, a6.y), b22 = new Node(b2.i, b2.x, b2.y), an = a6.next, bp = b2.prev;
  a6.next = b2;
  b2.prev = a6;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last5) {
  const p3 = new Node(i2, x2, y2);
  if (!last5) {
    p3.prev = p3;
    p3.next = p3;
  } else {
    p3.next = last5.next;
    p3.prev = last5;
    last5.next.prev = p3;
    last5.next = p3;
  }
  return p3;
}
function removeNode(p3) {
  p3.next.prev = p3.prev;
  p3.prev.next = p3.next;
  if (p3.prevZ)
    p3.prevZ.nextZ = p3.nextZ;
  if (p3.nextZ)
    p3.nextZ.prevZ = p3.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum7 = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum7 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum7;
}
var ShapeUtils = class {
  static area(contour) {
    const n2 = contour.length;
    let a6 = 0;
    for (let p3 = n2 - 1, q2 = 0; q2 < n2; p3 = q2++) {
      a6 += contour[p3].x * contour[q2].y - contour[q2].x * contour[p3].y;
    }
    return a6 * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l3 = points.length;
  if (l3 > 2 && points[l3 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options3 = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options3
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l3 = shapes.length; i2 < l3; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options3.curveSegments !== void 0 ? options3.curveSegments : 12;
      const steps = options3.steps !== void 0 ? options3.steps : 1;
      let depth = options3.depth !== void 0 ? options3.depth : 1;
      let bevelEnabled = options3.bevelEnabled !== void 0 ? options3.bevelEnabled : true;
      let bevelThickness = options3.bevelThickness !== void 0 ? options3.bevelThickness : 0.2;
      let bevelSize = options3.bevelSize !== void 0 ? options3.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options3.bevelOffset !== void 0 ? options3.bevelOffset : 0;
      let bevelSegments = options3.bevelSegments !== void 0 ? options3.bevelSegments : 3;
      const extrudePath = options3.extrudePath;
      const uvgen = options3.UVGenerator !== void 0 ? options3.UVGenerator : WorldUVGenerator;
      if (options3.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options3.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse5 = !ShapeUtils.isClockWise(vertices);
      if (reverse5) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size2) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size2).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j2 = il - 1, k3 = i2 + 1; i2 < il; i2++, j2++, k3++) {
        if (j2 === il)
          j2 = 0;
        if (k3 === il)
          k3 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k3]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j2 = il - 1, k3 = i2 + 1; i2 < il; i2++, j2++, k3++) {
          if (j2 === il)
            j2 = 0;
          if (k3 === il)
            k3 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k3]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z2);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face4 = faces[i2];
            f3(face4[2] + offset, face4[1] + offset, face4[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face4 = faces[i2];
            f3(face4[0] + offset, face4[1] + offset, face4[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face4 = faces[i2];
            f3(face4[2], face4[1], face4[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face4 = faces[i2];
            f3(face4[0] + vlen * steps, face4[1] + vlen * steps, face4[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k3 = i2 - 1;
          if (k3 < 0)
            k3 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a6 = layeroffset + j2 + slen1, b2 = layeroffset + k3 + slen1, c2 = layeroffset + k3 + slen2, d2 = layeroffset + j2 + slen2;
            f4(a6, b2, c2, d2);
          }
        }
      }
      function v2(x2, y2, z2) {
        placeholder.push(x2);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a6, b2, c2) {
        addVertex(a6);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a6, b2, c2, d2) {
        addVertex(a6);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options3 = this.parameters.options;
    return toJSON$1(shapes, options3, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options3, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l3 = shapes.length; i2 < l3; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options3.extrudePath !== void 0)
    data.options.extrudePath = options3.extrudePath.toJSON();
  return data;
}
var ShapeGeometry = class extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l3 = shapeHoles.length; i2 < l3; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l3 = shapeHoles.length; i2 < l3; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l3 = shapeVertices.length; i2 < l3; i2++) {
        const vertex2 = shapeVertices[i2];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i2 = 0, l3 = faces.length; i2 < l3; i2++) {
        const face4 = faces[i2];
        const a6 = face4[0] + indexOffset;
        const b2 = face4[1] + indexOffset;
        const c2 = face4[2] + indexOffset;
        indices.push(a6, b2, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l3 = shapes.length; i2 < l3; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a6 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a6, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var MeshStandardMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenTint = new Color(0);
    this.sheenRoughness = 1;
    this.transmissionMap = null;
    this.thickness = 0.01;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationTint = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularTint = new Color(1, 1, 1);
    this.specularTintMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.sheen = source.sheen;
    this.sheenTint.copy(source.sheenTint);
    this.sheenRoughness = source.sheenRoughness;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationTint.copy(source.attenuationTint);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularTint.copy(source.specularTint);
    this.specularTintMap = source.specularTintMap;
    return this;
  }
};
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var AnimationUtils = {
  arraySlice: function(array2, from, to) {
    if (AnimationUtils.isTypedArray(array2)) {
      return new array2.constructor(array2.subarray(from, to !== void 0 ? to : array2.length));
    }
    return array2.slice(from, to);
  },
  convertArray: function(array2, type, forceClone) {
    if (!array2 || !forceClone && array2.constructor === type)
      return array2;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array2);
    }
    return Array.prototype.slice.call(array2);
  },
  isTypedArray: function(object2) {
    return ArrayBuffer.isView(object2) && !(object2 instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip3 = sourceClip.clone();
    clip3.name = name;
    const tracks = [];
    for (let i2 = 0; i2 < clip3.tracks.length; ++i2) {
      const track = clip3.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame2 = track.times[j2] * fps;
        if (frame2 < startFrame || frame2 >= endFrame)
          continue;
        times.push(track.times[j2]);
        for (let k3 = 0; k3 < valueSize; ++k3) {
          values.push(track.values[j2 * valueSize + k3]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip3.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip3.tracks.length; ++i2) {
      if (minStartTime > clip3.tracks[i2].times[0]) {
        minStartTime = clip3.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip3.tracks.length; ++i2) {
      clip3.tracks[i2].shift(-1 * minStartTime);
    }
    clip3.resetDuration();
    return clip3;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k3 = 0; k3 < valueEnd; ++k3) {
            targetTrack.values[valueStart + k3] -= referenceValue[k3];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p3 = (t2 - t0) / (t1 - t0), pp = p3 * p3, ppp = pp * p3;
    const sP = -wP * ppp + 2 * wP * pp - wP * p3;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p3 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p3;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json20;
    if (trackType.toJSON !== this.toJSON) {
      json20 = trackType.toJSON(track);
    } else {
      json20 = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json20.interpolation = interpolation;
      }
    }
    json20.type = track.ValueTypeName;
    return json20;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep2 = false;
      const time2 = times[i2];
      const timeNext = times[i2 + 1];
      if (time2 !== timeNext && (i2 !== 1 || time2 !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep2 = true;
              break;
            }
          }
        } else {
          keep2 = true;
        }
      }
      if (keep2) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json20) {
    const tracks = [], jsonTracks = json20.tracks, frameTime = 1 / (json20.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip3 = new this(json20.name, json20.duration, tracks, json20.blendMode);
    clip3.uuid = json20.uuid;
    return clip3;
  }
  static toJSON(clip3) {
    const tracks = [], clipTracks = clip3.tracks;
    const json20 = {
      "name": clip3.name,
      "duration": clip3.duration,
      "tracks": tracks,
      "uuid": clip3.uuid,
      "blendMode": clip3.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json20;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k3;
        for (k3 = 0; k3 < animationKeys.length; k3++) {
          if (animationKeys[k3].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k3].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k3].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k3].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k3];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip3 = new this(clipName, duration, tracks, blendMode);
    return clip3;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json20) {
  if (json20.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json20.type);
  if (json20.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json20.keys, times, values, "value");
    json20.times = times;
    json20.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json20);
  } else {
    return new trackType(json20.name, json20.times, json20.values, json20.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform6) {
      urlModifier = transform6;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l3 = handlers.length; i2 < l3; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
var loading = {};
var FileLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i2 = 0; i2 < data.length; i2++) {
              view[i2] = data.charCodeAt(i2);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], { type: mimeType });
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks2 = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i2 = 0, il = callbacks2.length; i2 < il; i2++) {
            const callback = callbacks2[i2];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i2 = 0, il = callbacks2.length; i2 < il; i2++) {
            const callback = callbacks2[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks2 = loading[url];
        for (let i2 = 0, il = callbacks2.length; i2 < il; i2++) {
          const callback = callbacks2[i2];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks2 = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks2.length; i2 < il; i2++) {
          const callback = callbacks2[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks2 = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks2.length; i2 < il; i2++) {
          const callback = callbacks2[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image2 = createElementNS("img");
    function onImageLoad() {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image2.addEventListener("load", onImageLoad, false);
    image2.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image2.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image2.src = url;
    return image2;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image2) {
        texture.images[i2] = image2;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
};
var TextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image2) {
      texture.image = image2;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera2) {
    this.camera = camera2;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light2) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light2.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light2.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object2 = {};
    if (this.bias !== 0)
      object2.bias = this.bias;
    if (this.normalBias !== 0)
      object2.normalBias = this.normalBias;
    if (this.radius !== 1)
      object2.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object2.mapSize = this.mapSize.toArray();
    object2.camera = this.camera.toJSON(false).object;
    delete object2.camera.matrix;
    return object2;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light2) {
    const camera2 = this.camera;
    const fov2 = RAD2DEG * 2 * light2.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light2.distance || camera2.far;
    if (fov2 !== camera2.fov || aspect2 !== camera2.aspect || far !== camera2.far) {
      camera2.fov = fov2;
      camera2.aspect = aspect2;
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    super.updateMatrices(light2);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance2 = 0, angle2 = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance2;
    this.angle = angle2;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light2, viewportIndex = 0) {
    const camera2 = this.camera;
    const shadowMatrix = this.matrix;
    const far = light2.distance || camera2.far;
    if (far !== camera2.far) {
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light2.matrixWorld);
    camera2.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera2.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera2.up.copy(this._cubeUps[viewportIndex]);
    camera2.lookAt(_lookTarget);
    camera2.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance2 = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance2;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x2);
    target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array2, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array2, offset + i2 * 3);
    }
    return this;
  }
  toArray(array2 = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array2, offset + i2 * 3);
    }
    return array2;
  }
  static getBasisAt(normal, shBasis) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json20) {
    this.intensity = json20.intensity;
    this.sh.fromArray(json20.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
LightProbe.prototype.isLightProbe = true;
var LoaderUtils = class {
  static decodeText(array2) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array2);
    }
    let s2 = "";
    for (let i2 = 0, il = array2.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array2[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
};
var InstancedBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
};
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
var ImageBitmapLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options3) {
    this.options = options3;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res2) {
      return res2.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError)
        onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
};
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        const bufferCopy = buffer2.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var Clock = class {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l3 = this.filters.length; i2 < l3; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l3 = this.filters.length; i2 < l3; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i2 = 0; i2 < data.length; i2++) {
      value += data[i2];
    }
    return value / data.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer2 = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer2[offset + i2] = buffer2[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer2, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer2 = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer2, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer2 = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer2, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer2, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer2[i2] !== buffer2[i2 + stride]) {
        binding.setValue(buffer2, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer2 = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer2, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer2[i2] = buffer2[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  _select(buffer2, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer2[dstOffset + i2] = buffer2[srcOffset + i2];
      }
    }
  }
  _slerp(buffer2, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer2, dstOffset, buffer2, dstOffset, buffer2, srcOffset, t2);
  }
  _slerpAdditive(buffer2, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer2, workOffset, buffer2, dstOffset, buffer2, srcOffset);
    Quaternion.slerpFlat(buffer2, dstOffset, buffer2, dstOffset, buffer2, workOffset, t2);
  }
  _lerp(buffer2, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer2[j2] = buffer2[j2] * s2 + buffer2[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer2, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer2[j2] = buffer2[j2] + buffer2[srcOffset + i2] * t2;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array2, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array2, offset);
  }
  setValue(array2, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array2, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer2, offset) {
    buffer2[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer2, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
      buffer2[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer2, offset) {
    buffer2[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer2, offset) {
    this.resolvedProperty.toArray(buffer2, offset);
  }
  _setValue_direct(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      indices[arguments[i2].uuid] = i2;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object2 = arguments[i2], uuid = object2.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object2);
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          bindings[j2].push(new PropertyBinding(object2, paths[j2], parsedPaths[j2]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object2;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object2, paths[j2], parsedPaths[j2]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object2 = arguments[i2], uuid = object2.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object2;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object2 = arguments[i2], uuid = object2.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last5 = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last5;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0)
      return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
      const object2 = objects[i2];
      bindingsForPath[i2] = new PropertyBinding(object2, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip3, localRoot = null, blendMode = clip3.blendMode) {
    this._mixer = mixer;
    this._clip = clip3;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip3.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time2) {
    this._startTime = time2;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    times[1] = now3 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time2, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time2);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time2 - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time2);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time2);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time2) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time2)[0];
        weight *= interpolantValue;
        if (time2 > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time2) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time2)[0];
        timeScale *= interpolantValue;
        if (time2 > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time2 = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time2;
      return pingPong && (loopCount & 1) === 1 ? duration - time2 : time2;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time2 >= duration) {
          time2 = duration;
        } else if (time2 < 0) {
          time2 = 0;
        } else {
          this.time = time2;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time2;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time2 >= duration || time2 < 0) {
        const loopDelta = Math.floor(time2 / duration);
        time2 -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time2 = deltaTime > 0 ? duration : 0;
          this.time = time2;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time2;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time2;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time2;
      }
    }
    return time2;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now3 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    values[0] = weightNow;
    times[1] = now3 + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip3, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip3 === "string" ? AnimationClip.findByName(root, clip3) : clip3;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip3;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip3, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip3 === "string" ? AnimationClip.findByName(root, clip3) : clip3, clipUuid = clipObject ? clipObject.uuid : clip3, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions[i2].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time2 = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions[i2];
      action._update(time2, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip3) {
    const actions = this._actions, clipUuid = clip3.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip3, optionalRoot) {
    const action = this.existingAction(clip3, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
  constructor(array2, stride, meshPerAttribute = 1) {
    super(array2, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json20 = super.toJSON(data);
    json20.isInstancedInterleavedBuffer = true;
    json20.meshPerAttribute = this.meshPerAttribute;
    return json20;
  }
};
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
var GLBufferAttribute = class {
  constructor(buffer2, type, itemSize, elementSize, count3) {
    this.buffer = buffer2;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count3;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setBuffer(buffer2) {
    this.buffer = buffer2;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count3) {
    this.count = count3;
    return this;
  }
};
GLBufferAttribute.prototype.isGLBufferAttribute = true;
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x2, y2, z2) {
    this.radius = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x2, z2);
      this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$4 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min7 = new Vector2(Infinity, Infinity), max7 = new Vector2(-Infinity, -Infinity)) {
    this.min = min7;
    this.max = max7;
  }
  set(min7, max7) {
    this.min.copy(min7);
    this.max.copy(max7);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$4.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar2) {
    this.min.addScalar(-scalar2);
    this.max.addScalar(scalar2);
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point2, target) {
    return target.set((point2.x - this.min.x) / (this.max.x - this.min.x), (point2.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    const clampedPoint = _vector$4.copy(point2).clamp(this.min, this.max);
    return clampedPoint.sub(point2).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t2, target) {
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  closestPointToPointParameter(point2, clampToLine) {
    _startP.subVectors(point2, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t2 = startEnd_startP / startEnd2;
    if (clampToLine) {
      t2 = clamp(t2, 0, 1);
    }
    return t2;
  }
  closestPointToPoint(point2, clampToLine, target) {
    const t2 = this.closestPointToPointParameter(point2, clampToLine);
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var ImmediateRenderObject = class extends Object3D {
  constructor(material) {
    super();
    this.material = material;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
  }
};
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$2 = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix4();
var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object2) {
    const bones = getBoneList(object2);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object2;
    this.bones = bones;
    this.matrix = object2.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j2 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object2) {
  const boneList = [];
  if (object2 && object2.isBone) {
    boneList.push(object2);
  }
  for (let i2 = 0; i2 < object2.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object2.children[i2]));
  }
  return boneList;
}
var GridHelper = class extends LineSegments {
  constructor(size2 = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step5 = size2 / divisions;
    const halfSize = size2 / 2;
    const vertices = [], colors = [];
    for (let i2 = 0, j2 = 0, k3 = -halfSize; i2 <= divisions; i2++, k3 += step5) {
      vertices.push(-halfSize, 0, k3, halfSize, 0, k3);
      vertices.push(k3, 0, -halfSize, k3, 0, halfSize);
      const color = i2 === center ? color1 : color2;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Matrix3.prototype.flattenToArrayOffset = function(array2, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array2, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array2, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array2, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point2, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point2, a6, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point2, a6, b2, c2, target);
};
Triangle.normal = function(a6, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a6, b2, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options3) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options3);
};
Shape.prototype.makeGeometry = function(options3) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options3);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance2, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance2);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count3, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count3);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
  return this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer2) {
    scope.setBuffer(buffer2);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer2, scene2) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer2, scene2);
};
CubeCamera.prototype.clear = function(renderer2, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer2, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/.pnpm/three@0.133.1/node_modules/three/examples/jsm/libs/stats.module.js
var Stats = function() {
  var mode = 0;
  var container = document.createElement("div");
  container.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  container.addEventListener("click", function(event) {
    event.preventDefault();
    showPanel(++mode % container.children.length);
  }, false);
  function addPanel(panel) {
    container.appendChild(panel.dom);
    return panel;
  }
  function showPanel(id) {
    for (var i2 = 0; i2 < container.children.length; i2++) {
      container.children[i2].style.display = i2 === id ? "block" : "none";
    }
    mode = id;
  }
  var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
  var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
  var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) {
    var memPanel = addPanel(new Stats.Panel("MB", "#f08", "#201"));
  }
  showPanel(0);
  return {
    REVISION: 16,
    dom: container,
    addPanel,
    showPanel,
    begin: function() {
      beginTime = (performance || Date).now();
    },
    end: function() {
      frames++;
      var time2 = (performance || Date).now();
      msPanel.update(time2 - beginTime, 200);
      if (time2 >= prevTime + 1e3) {
        fpsPanel.update(frames * 1e3 / (time2 - prevTime), 100);
        prevTime = time2;
        frames = 0;
        if (memPanel) {
          var memory2 = performance.memory;
          memPanel.update(memory2.usedJSHeapSize / 1048576, memory2.jsHeapSizeLimit / 1048576);
        }
      }
      return time2;
    },
    update: function() {
      beginTime = this.end();
    },
    domElement: container,
    setMode: showPanel
  };
};
Stats.Panel = function(name, fg, bg) {
  var min7 = Infinity, max7 = 0, round5 = Math.round;
  var PR = round5(window.devicePixelRatio || 1);
  var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;
  var canvas3 = document.createElement("canvas");
  canvas3.width = WIDTH;
  canvas3.height = HEIGHT;
  canvas3.style.cssText = "width:80px;height:48px";
  var context = canvas3.getContext("2d");
  context.font = "bold " + 9 * PR + "px Helvetica,Arial,sans-serif";
  context.textBaseline = "top";
  context.fillStyle = bg;
  context.fillRect(0, 0, WIDTH, HEIGHT);
  context.fillStyle = fg;
  context.fillText(name, TEXT_X, TEXT_Y);
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  context.fillStyle = bg;
  context.globalAlpha = 0.9;
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  return {
    dom: canvas3,
    update: function(value, maxValue) {
      min7 = Math.min(min7, value);
      max7 = Math.max(max7, value);
      context.fillStyle = bg;
      context.globalAlpha = 1;
      context.fillRect(0, 0, WIDTH, GRAPH_Y);
      context.fillStyle = fg;
      context.fillText(round5(value) + " " + name + " (" + round5(min7) + "-" + round5(max7) + ")", TEXT_X, TEXT_Y);
      context.drawImage(canvas3, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
      context.fillStyle = bg;
      context.globalAlpha = 0.9;
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round5((1 - value / maxValue) * GRAPH_HEIGHT));
    }
  };
};
var stats_module_default = Stats;

// node_modules/.pnpm/three@0.133.1/node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object2, domElement) {
    super();
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object2;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object2.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update2() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min7 = scope.minAzimuthAngle;
        let max7 = scope.maxAzimuthAngle;
        if (isFinite(min7) && isFinite(max7)) {
          if (min7 < -Math.PI)
            min7 += twoPI;
          else if (min7 > Math.PI)
            min7 -= twoPI;
          if (max7 < -Math.PI)
            max7 += twoPI;
          else if (max7 > Math.PI)
            max7 -= twoPI;
          if (min7 <= max7) {
            spherical.theta = Math.max(min7, Math.min(max7, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min7 + max7) / 2 ? Math.max(min7, spherical.theta) : Math.min(max7, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale3;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale3 = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale3 = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle2) {
      sphericalDelta.theta -= angle2;
    }
    function rotateUp(angle2) {
      sphericalDelta.phi -= angle2;
    }
    const panLeft = function() {
      const v2 = new Vector3();
      return function panLeft2(distance2, objectMatrix) {
        v2.setFromMatrixColumn(objectMatrix, 0);
        v2.multiplyScalar(-distance2);
        panOffset.add(v2);
      };
    }();
    const panUp = function() {
      const v2 = new Vector3();
      return function panUp2(distance2, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v2.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v2.setFromMatrixColumn(objectMatrix, 0);
          v2.crossVectors(scope.object.up, v2);
        }
        v2.multiplyScalar(distance2);
        panOffset.add(v2);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale3 /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale3 *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseUp() {
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x2, y2);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x2, y2);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance2);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x2 = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x2, y2);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x2 = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        panEnd.set(x2, y2);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance2);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function handleTouchEnd() {
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchEnd();
      } else {
        onMouseUp(event);
      }
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseUp(event) {
      handleMouseUp(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onTouchEnd(event) {
      handleTouchEnd(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i2 = 0; i2 < pointers.length; i2++) {
        if (pointers[i2].pointerId == event.pointerId) {
          pointers.splice(i2, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// node_modules/.pnpm/three@0.133.1/node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e2) {
      if (onError) {
        onError(e2);
      } else {
        console.error(e2);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e2) {
        _onError(e2);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions2 = {};
    const plugins = {};
    if (typeof data === "string") {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions2[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        content = extensions2[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json20 = JSON.parse(content);
    if (json20.asset === void 0 || json20.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json20, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
      const plugin = this.pluginCallbacks[i2](parser);
      plugins[plugin.name] = plugin;
      extensions2[plugin.name] = true;
    }
    if (json20.extensionsUsed) {
      for (let i2 = 0; i2 < json20.extensionsUsed.length; ++i2) {
        const extensionName = json20.extensionsUsed[i2];
        const extensionsRequired = json20.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions2[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions2[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions2[extensionName] = new GLTFDracoMeshCompressionExtension(json20, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions2[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions2[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions2);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object2) {
      objects[key] = object2;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json20 = parser.json;
    const extensions2 = json20.extensions && json20.extensions[this.name] || {};
    const lightDefs = extensions2.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range7 = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range7;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range7;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json20 = parser.json;
    const nodeDef = json20.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light2) {
      return parser._getNodeRef(self2.cache, lightIndex, light2);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array2 = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array2);
        materialParams.opacity = array2[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale3 = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale3, scale3);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularTintMap", extension.specularColorTexture).then(function(texture) {
        texture.encoding = sRGBEncoding;
      }));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json20 = parser.json;
    const textureDef = json20.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const source = json20.images[extension.source];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json20.extensionsRequired && json20.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json20 = parser.json;
    const textureDef = json20.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json20.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json20.extensionsRequired && json20.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image2 = new Image();
        image2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image2.onload = image2.onerror = function() {
          resolve(image2.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json20 = this.parser.json;
    const bufferView = json20.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer2 = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json20.extensionsRequired && json20.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer2, decoder.ready]).then(function(res2) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count3 = extensionDef.count;
        const stride = extensionDef.byteStride;
        const result = new ArrayBuffer(count3 * stride);
        const source = new Uint8Array(res2[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count3, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json20, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json20;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json20 = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json20.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform6) {
    if (transform6.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform6.offset === void 0 && transform6.rotation === void 0 && transform6.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform6.offset !== void 0) {
      texture.offset.fromArray(transform6.offset);
    }
    if (transform6.rotation !== void 0) {
      texture.rotation = transform6.rotation;
    }
    if (transform6.scale !== void 0) {
      texture.repeat.fromArray(transform6.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshStandardSGMaterial = class extends MeshStandardMaterial {
  constructor(params) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;
    const specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    const glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    const specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    const glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    const lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.roughness += geometryRoughness;",
      "material.roughness = min( material.roughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    const uniforms = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v2) {
          uniforms.specular.value = v2;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v2) {
          uniforms.specularMap.value = v2;
          if (v2) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v2) {
          uniforms.glossiness.value = v2;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v2) {
          uniforms.glossinessMap.value = v2;
          if (v2) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
};
var GLTFMaterialsPbrSpecularGlossinessExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array2 = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array2);
      materialParams.opacity = array2[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
    }
    materialParams.emissive = new Color(0, 0, 0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
    materialParams.specular = new Color(1, 1, 1);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === void 0 ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1;
    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
    material.aoMapIntensity = 1;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = 1;
    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
    material.envMapIntensity = 1;
    material.refractionRatio = 0.98;
    return material;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i2 = 0; i2 !== valueSize; i2++) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
};
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t2, t1) {
  const result = this.resultBuffer;
  const values = this.sampleValues;
  const stride = this.valueSize;
  const stride2 = stride * 2;
  const stride3 = stride * 3;
  const td = t1 - t0;
  const p3 = (t2 - t0) / td;
  const pp = p3 * p3;
  const ppp = pp * p3;
  const offset1 = i1 * stride3;
  const offset0 = offset1 - stride3;
  const s2 = -2 * ppp + 3 * pp;
  const s3 = ppp - pp;
  const s0 = 1 - s2;
  const s1 = s3 - pp + p3;
  for (let i2 = 0; i2 !== stride; i2++) {
    const p0 = values[offset0 + i2 + stride];
    const m0 = values[offset0 + i2 + stride2] * td;
    const p1 = values[offset1 + i2 + stride];
    const m1 = values[offset1 + i2] * td;
    result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
  }
  return result;
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function resolveURL(url, path) {
  if (typeof url !== "string" || url === "")
    return "";
  if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
    path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
  }
  if (/^(https?:)?\/\//i.test(url))
    return url;
  if (/^data:.*,.*$/i.test(url))
    return url;
  if (/^blob:.*$/i.test(url))
    return url;
  return path + url;
}
function createDefaultMaterial(cache5) {
  if (cache5["DefaultMaterial"] === void 0) {
    cache5["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache5["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object2, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object2.userData.gltfExtensions = object2.userData.gltfExtensions || {};
      object2.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object2, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object2.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
      mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
        mesh.morphTargetDictionary[targetNames[i2]] = i2;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i2 = 0, il = keys.length; i2 < il; i2++) {
    attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
var GLTFParser = class {
  constructor(json20 = {}, options3 = {}) {
    this.json = json20;
    this.extensions = {};
    this.plugins = {};
    this.options = options3;
    this.cache = new GLTFRegistry();
    this.associations = new Map();
    this.primitiveCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.textureCache = {};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions2) {
    this.extensions = extensions2;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json20 = this.json;
    const extensions2 = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json20.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json20.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions2, result, json20);
      assignExtrasToUserData(result, json20);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i2 = 0, il = joints.length; i2 < il; i2++) {
        nodeDefs[joints[i2]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  _addNodeRef(cache5, index) {
    if (index === void 0)
      return;
    if (cache5.refs[index] === void 0) {
      cache5.refs[index] = cache5.uses[index] = 0;
    }
    cache5.refs[index]++;
  }
  _getNodeRef(cache5, index, object2) {
    if (cache5.refs[index] <= 1)
      return object2;
    const ref = object2.clone();
    const updateMappings = (original, clone2) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone2, mappings);
      }
      for (const [i2, child] of original.children.entries()) {
        updateMappings(child, clone2.children[i2]);
      }
    };
    updateMappings(object2, ref);
    ref.name += "_instance_" + cache5.uses[index]++;
    return ref;
  }
  _invokeOne(func2) {
    const extensions2 = Object.values(this.plugins);
    extensions2.push(this);
    for (let i2 = 0; i2 < extensions2.length; i2++) {
      const result = func2(extensions2[i2]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func2) {
    const extensions2 = Object.values(this.plugins);
    extensions2.unshift(this);
    const pending = [];
    for (let i2 = 0; i2 < extensions2.length; i2++) {
      const result = func2(extensions2[i2]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this.loadAnimation(index);
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options3 = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options3.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer2) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  loadAccessor(accessorIndex) {
    const parser = this;
    const json20 = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json20.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array2, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array2 = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array2, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array2 = new TypedArray(accessorDef.count * itemSize);
        } else {
          array2 = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array2, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
          const index = sparseIndices[i2];
          bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  loadTexture(textureIndex) {
    const json20 = this.json;
    const options3 = this.options;
    const textureDef = json20.textures[textureIndex];
    const source = json20.images[textureDef.source];
    let loader = this.textureLoader;
    if (source.uri) {
      const handler = options3.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  }
  loadTextureImage(textureIndex, source, loader) {
    const parser = this;
    const json20 = this.json;
    const options3 = this.options;
    const textureDef = json20.textures[textureIndex];
    const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = source.uri || "";
    let isObjectURL = false;
    if (source.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: source.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(resolveURL(sourceURI2, options3.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      const samplers = json20.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  assignTexture(materialParams, mapName, mapDef) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform6 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform6) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform6);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(materialIndex) {
    const parser = this;
    const json20 = this.json;
    const extensions2 = this.extensions;
    const materialDef = json20.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions2[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions2[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array2 = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array2);
        materialParams.opacity = array2[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.format = RGBFormat;
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale3 = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale3, scale3);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions2[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions2, material, materialDef);
      return material;
    });
  }
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    let name = sanitizedName;
    for (let i2 = 1; this.nodeNamesUsed[name]; ++i2) {
      name = sanitizedName + "_" + i2;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }
  loadGeometries(primitives) {
    const parser = this;
    const extensions2 = this.extensions;
    const cache5 = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions2[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const primitive = primitives[i2];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache5[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache5[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  loadMesh(meshIndex) {
    const parser = this;
    const json20 = this.json;
    const extensions2 = this.extensions;
    const meshDef = json20.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
        const geometry = geometries[i2];
        const primitive = primitives[i2];
        let mesh;
        const material = materials[i2];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions2, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        parser.associations.set(meshes[i2], {
          meshes: meshIndex,
          primitives: i2
        });
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      parser.associations.set(group, { meshes: meshIndex });
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    });
  }
  loadCamera(cameraIndex) {
    let camera2;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera2 = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera2 = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera2.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera2, cameraDef);
    return Promise.resolve(camera2);
  }
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = { joints: skinDef.joints };
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }
  loadAnimation(animationIndex) {
    const json20 = this.json;
    const animationDef = json20.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
      const channel = animationDef.channels[i2];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node !== void 0 ? target.node : target.id;
      const input2 = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input2));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
        const node = nodes[i2];
        const inputAccessor = inputAccessors[i2];
        const outputAccessor = outputAccessors[i2];
        const sampler = samplers[i2];
        const target = targets[i2];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object2) {
            if (object2.isMesh === true && object2.morphTargetInfluences) {
              targetNames.push(object2.name ? object2.name : object2.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale3 = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
            scaled[j2] = outputArray[j2] * scale3;
          }
          outputArray = scaled;
        }
        for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
          const track = new TypedKeyframeTrack(targetNames[j2] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json20 = this.json;
    const parser = this;
    const nodeDef = json20.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o2) {
          if (!o2.isMesh)
            return;
          for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
            o2.morphTargetInfluences[i2] = nodeDef.weights[i2];
          }
        });
      }
      return node;
    });
  }
  loadNode(nodeIndex) {
    const json20 = this.json;
    const extensions2 = this.extensions;
    const parser = this;
    const nodeDef = json20.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera2) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera2);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i2 = 0, il = objects.length; i2 < il; i2++) {
          node.add(objects[i2]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions2, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
  }
  loadScene(sceneIndex) {
    const json20 = this.json;
    const extensions2 = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene2 = new Group();
    if (sceneDef.name)
      scene2.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene2, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions2, scene2, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
      pending.push(buildNodeHierarchy(nodeIds[i2], scene2, json20, parser));
    }
    return Promise.all(pending).then(function() {
      const reduceAssociations = (node) => {
        const reducedAssociations = new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene2);
      return scene2;
    });
  }
};
function buildNodeHierarchy(nodeId, parentObject, json20, parser) {
  const nodeDef = json20.nodes[nodeId];
  return parser.getDependency("node", nodeId).then(function(node) {
    if (nodeDef.skin === void 0)
      return node;
    let skinEntry;
    return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
        pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
      }
      return Promise.all(pendingJoints);
    }).then(function(jointNodes) {
      node.traverse(function(mesh) {
        if (!mesh.isMesh)
          return;
        const bones = [];
        const boneInverses = [];
        for (let j2 = 0, jl = jointNodes.length; j2 < jl; j2++) {
          const jointNode = jointNodes[j2];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== void 0) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j2 * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j2]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function(node) {
    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i2 = 0, il = children.length; i2 < il; i2++) {
        const child = children[i2];
        pending.push(buildNodeHierarchy(child, node, json20, parser));
      }
    }
    return Promise.all(pending);
  });
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min7 = accessor.min;
    const max7 = accessor.max;
    if (min7 !== void 0 && max7 !== void 0) {
      box.set(new Vector3(min7[0], min7[1], min7[2]), new Vector3(max7[0], max7[1], max7[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min7 = accessor.min;
        const max7 = accessor.max;
        if (min7 !== void 0 && max7 !== void 0) {
          vector.setX(Math.max(Math.abs(min7[0]), Math.abs(max7[0])));
          vector.setY(Math.max(Math.abs(min7[1]), Math.abs(max7[1])));
          vector.setZ(Math.max(Math.abs(min7[2]), Math.abs(max7[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
function toTrianglesDrawMode(geometry, drawMode) {
  let index = geometry.getIndex();
  if (index === null) {
    const indices = [];
    const position = geometry.getAttribute("position");
    if (position !== void 0) {
      for (let i2 = 0; i2 < position.count; i2++) {
        indices.push(i2);
      }
      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
      return geometry;
    }
  }
  const numberOfTriangles = index.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(i2));
      newIndices.push(index.getX(i2 + 1));
    }
  } else {
    for (let i2 = 0; i2 < numberOfTriangles; i2++) {
      if (i2 % 2 === 0) {
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2 + 2));
      } else {
        newIndices.push(index.getX(i2 + 2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  }
  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}

// node_modules/.pnpm/@pixiv+three-vrm@0.6.7_three@0.133.1/node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js
function t(e2, t2, n2, i2) {
  return new (n2 || (n2 = Promise))(function(r2, o2) {
    function s2(e3) {
      try {
        l3(i2.next(e3));
      } catch (e4) {
        o2(e4);
      }
    }
    function a6(e3) {
      try {
        l3(i2.throw(e3));
      } catch (e4) {
        o2(e4);
      }
    }
    function l3(e3) {
      var t3;
      e3.done ? r2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
        e4(t3);
      })).then(s2, a6);
    }
    l3((i2 = i2.apply(e2, t2 || [])).next());
  });
}
function n(e2) {
  Object.keys(e2).forEach((t2) => {
    const n2 = e2[t2];
    if (n2 == null ? void 0 : n2.isTexture) {
      n2.dispose();
    }
  }), e2.dispose();
}
function i(e2) {
  const t2 = e2.geometry;
  t2 && t2.dispose();
  const i2 = e2.material;
  i2 && (Array.isArray(i2) ? i2.forEach((e3) => n(e3)) : i2 && n(i2));
}
var r;
!function(e2) {
  e2[e2.NUMBER = 0] = "NUMBER", e2[e2.VECTOR2 = 1] = "VECTOR2", e2[e2.VECTOR3 = 2] = "VECTOR3", e2[e2.VECTOR4 = 3] = "VECTOR4", e2[e2.COLOR = 4] = "COLOR";
}(r || (r = {}));
var o = new Vector2();
var s = new Vector3();
var a = new Vector4();
var l = new Color();
var d = class extends Object3D {
  constructor(e2) {
    super(), this.weight = 0, this.isBinary = false, this._binds = [], this._materialValues = [], this.name = `BlendShapeController_${e2}`, this.type = "BlendShapeController", this.visible = false;
  }
  addBind(e2) {
    const t2 = e2.weight / 100;
    this._binds.push({ meshes: e2.meshes, morphTargetIndex: e2.morphTargetIndex, weight: t2 });
  }
  addMaterialValue(t2) {
    const n2 = t2.material, i2 = t2.propertyName;
    let o2, s2, a6, l3, d2 = n2[i2];
    d2 && (d2 = t2.defaultValue || d2, d2.isVector2 ? (o2 = r.VECTOR2, s2 = d2.clone(), a6 = new Vector2().fromArray(t2.targetValue), l3 = a6.clone().sub(s2)) : d2.isVector3 ? (o2 = r.VECTOR3, s2 = d2.clone(), a6 = new Vector3().fromArray(t2.targetValue), l3 = a6.clone().sub(s2)) : d2.isVector4 ? (o2 = r.VECTOR4, s2 = d2.clone(), a6 = new Vector4().fromArray([t2.targetValue[2], t2.targetValue[3], t2.targetValue[0], t2.targetValue[1]]), l3 = a6.clone().sub(s2)) : d2.isColor ? (o2 = r.COLOR, s2 = d2.clone(), a6 = new Color().fromArray(t2.targetValue), l3 = a6.clone().sub(s2)) : (o2 = r.NUMBER, s2 = d2, a6 = t2.targetValue[0], l3 = a6 - s2), this._materialValues.push({ material: n2, propertyName: i2, defaultValue: s2, targetValue: a6, deltaValue: l3, type: o2 }));
  }
  applyWeight() {
    const e2 = this.isBinary ? this.weight < 0.5 ? 0 : 1 : this.weight;
    this._binds.forEach((t2) => {
      t2.meshes.forEach((n2) => {
        n2.morphTargetInfluences && (n2.morphTargetInfluences[t2.morphTargetIndex] += e2 * t2.weight);
      });
    }), this._materialValues.forEach((t2) => {
      if (t2.material[t2.propertyName] !== void 0) {
        if (t2.type === r.NUMBER) {
          const n2 = t2.deltaValue;
          t2.material[t2.propertyName] += n2 * e2;
        } else if (t2.type === r.VECTOR2) {
          const n2 = t2.deltaValue;
          t2.material[t2.propertyName].add(o.copy(n2).multiplyScalar(e2));
        } else if (t2.type === r.VECTOR3) {
          const n2 = t2.deltaValue;
          t2.material[t2.propertyName].add(s.copy(n2).multiplyScalar(e2));
        } else if (t2.type === r.VECTOR4) {
          const n2 = t2.deltaValue;
          t2.material[t2.propertyName].add(a.copy(n2).multiplyScalar(e2));
        } else if (t2.type === r.COLOR) {
          const n2 = t2.deltaValue;
          t2.material[t2.propertyName].add(l.copy(n2).multiplyScalar(e2));
        }
        typeof t2.material.shouldApplyUniforms == "boolean" && (t2.material.shouldApplyUniforms = true);
      }
    });
  }
  clearAppliedWeight() {
    this._binds.forEach((e2) => {
      e2.meshes.forEach((t2) => {
        t2.morphTargetInfluences && (t2.morphTargetInfluences[e2.morphTargetIndex] = 0);
      });
    }), this._materialValues.forEach((e2) => {
      if (e2.material[e2.propertyName] !== void 0) {
        if (e2.type === r.NUMBER) {
          const t2 = e2.defaultValue;
          e2.material[e2.propertyName] = t2;
        } else if (e2.type === r.VECTOR2) {
          const t2 = e2.defaultValue;
          e2.material[e2.propertyName].copy(t2);
        } else if (e2.type === r.VECTOR3) {
          const t2 = e2.defaultValue;
          e2.material[e2.propertyName].copy(t2);
        } else if (e2.type === r.VECTOR4) {
          const t2 = e2.defaultValue;
          e2.material[e2.propertyName].copy(t2);
        } else if (e2.type === r.COLOR) {
          const t2 = e2.defaultValue;
          e2.material[e2.propertyName].copy(t2);
        }
        typeof e2.material.shouldApplyUniforms == "boolean" && (e2.material.shouldApplyUniforms = true);
      }
    });
  }
};
var h;
function u(e2, t2, n2) {
  const i2 = e2.parser.json.nodes[t2].mesh;
  if (i2 == null)
    return null;
  const r2 = e2.parser.json.meshes[i2].primitives.length, o2 = [];
  return n2.traverse((e3) => {
    o2.length < r2 && e3.isMesh && o2.push(e3);
  }), o2;
}
function c(e2) {
  return t(this, void 0, void 0, function* () {
    const t2 = yield e2.parser.getDependencies("node"), n2 = new Map();
    return t2.forEach((t3, i2) => {
      const r2 = u(e2, i2, t3);
      r2 != null && n2.set(i2, r2);
    }), n2;
  });
}
function p(e2) {
  return e2[0] !== "_" ? (console.warn(`renameMaterialProperty: Given property name "${e2}" might be invalid`), e2) : (e2 = e2.substring(1), /[A-Z]/.test(e2[0]) ? e2[0].toLowerCase() + e2.substring(1) : (console.warn(`renameMaterialProperty: Given property name "${e2}" might be invalid`), e2));
}
!function(e2) {
  var t2, n2, i2, r2, o2, s2;
  (t2 = e2.BlendShapePresetName || (e2.BlendShapePresetName = {})).A = "a", t2.Angry = "angry", t2.Blink = "blink", t2.BlinkL = "blink_l", t2.BlinkR = "blink_r", t2.E = "e", t2.Fun = "fun", t2.I = "i", t2.Joy = "joy", t2.Lookdown = "lookdown", t2.Lookleft = "lookleft", t2.Lookright = "lookright", t2.Lookup = "lookup", t2.Neutral = "neutral", t2.O = "o", t2.Sorrow = "sorrow", t2.U = "u", t2.Unknown = "unknown", (n2 = e2.FirstPersonLookAtTypeName || (e2.FirstPersonLookAtTypeName = {})).BlendShape = "BlendShape", n2.Bone = "Bone", (i2 = e2.HumanoidBoneName || (e2.HumanoidBoneName = {})).Chest = "chest", i2.Head = "head", i2.Hips = "hips", i2.Jaw = "jaw", i2.LeftEye = "leftEye", i2.LeftFoot = "leftFoot", i2.LeftHand = "leftHand", i2.LeftIndexDistal = "leftIndexDistal", i2.LeftIndexIntermediate = "leftIndexIntermediate", i2.LeftIndexProximal = "leftIndexProximal", i2.LeftLittleDistal = "leftLittleDistal", i2.LeftLittleIntermediate = "leftLittleIntermediate", i2.LeftLittleProximal = "leftLittleProximal", i2.LeftLowerArm = "leftLowerArm", i2.LeftLowerLeg = "leftLowerLeg", i2.LeftMiddleDistal = "leftMiddleDistal", i2.LeftMiddleIntermediate = "leftMiddleIntermediate", i2.LeftMiddleProximal = "leftMiddleProximal", i2.LeftRingDistal = "leftRingDistal", i2.LeftRingIntermediate = "leftRingIntermediate", i2.LeftRingProximal = "leftRingProximal", i2.LeftShoulder = "leftShoulder", i2.LeftThumbDistal = "leftThumbDistal", i2.LeftThumbIntermediate = "leftThumbIntermediate", i2.LeftThumbProximal = "leftThumbProximal", i2.LeftToes = "leftToes", i2.LeftUpperArm = "leftUpperArm", i2.LeftUpperLeg = "leftUpperLeg", i2.Neck = "neck", i2.RightEye = "rightEye", i2.RightFoot = "rightFoot", i2.RightHand = "rightHand", i2.RightIndexDistal = "rightIndexDistal", i2.RightIndexIntermediate = "rightIndexIntermediate", i2.RightIndexProximal = "rightIndexProximal", i2.RightLittleDistal = "rightLittleDistal", i2.RightLittleIntermediate = "rightLittleIntermediate", i2.RightLittleProximal = "rightLittleProximal", i2.RightLowerArm = "rightLowerArm", i2.RightLowerLeg = "rightLowerLeg", i2.RightMiddleDistal = "rightMiddleDistal", i2.RightMiddleIntermediate = "rightMiddleIntermediate", i2.RightMiddleProximal = "rightMiddleProximal", i2.RightRingDistal = "rightRingDistal", i2.RightRingIntermediate = "rightRingIntermediate", i2.RightRingProximal = "rightRingProximal", i2.RightShoulder = "rightShoulder", i2.RightThumbDistal = "rightThumbDistal", i2.RightThumbIntermediate = "rightThumbIntermediate", i2.RightThumbProximal = "rightThumbProximal", i2.RightToes = "rightToes", i2.RightUpperArm = "rightUpperArm", i2.RightUpperLeg = "rightUpperLeg", i2.Spine = "spine", i2.UpperChest = "upperChest", (r2 = e2.MetaAllowedUserName || (e2.MetaAllowedUserName = {})).Everyone = "Everyone", r2.ExplicitlyLicensedPerson = "ExplicitlyLicensedPerson", r2.OnlyAuthor = "OnlyAuthor", (o2 = e2.MetaUssageName || (e2.MetaUssageName = {})).Allow = "Allow", o2.Disallow = "Disallow", (s2 = e2.MetaLicenseName || (e2.MetaLicenseName = {})).Cc0 = "CC0", s2.CcBy = "CC_BY", s2.CcByNc = "CC_BY_NC", s2.CcByNcNd = "CC_BY_NC_ND", s2.CcByNcSa = "CC_BY_NC_SA", s2.CcByNd = "CC_BY_ND", s2.CcBySa = "CC_BY_SA", s2.Other = "Other", s2.RedistributionProhibited = "Redistribution_Prohibited";
}(h || (h = {}));
var m = new Vector3();
var f = new Vector3();
function g(e2, t2) {
  return e2.matrixWorld.decompose(m, t2, f), t2;
}
new Quaternion();
var _ = class {
  constructor() {
    this._blendShapeGroups = {}, this._blendShapePresetMap = {}, this._unknownGroupNames = [];
  }
  get expressions() {
    return Object.keys(this._blendShapeGroups);
  }
  get blendShapePresetMap() {
    return this._blendShapePresetMap;
  }
  get unknownGroupNames() {
    return this._unknownGroupNames;
  }
  getBlendShapeGroup(e2) {
    const t2 = this._blendShapePresetMap[e2], n2 = t2 ? this._blendShapeGroups[t2] : this._blendShapeGroups[e2];
    if (n2)
      return n2;
    console.warn(`no blend shape found by ${e2}`);
  }
  registerBlendShapeGroup(e2, t2, n2) {
    this._blendShapeGroups[e2] = n2, t2 ? this._blendShapePresetMap[t2] = e2 : this._unknownGroupNames.push(e2);
  }
  getValue(e2) {
    var t2;
    const n2 = this.getBlendShapeGroup(e2);
    return (t2 = n2 == null ? void 0 : n2.weight) !== null && t2 !== void 0 ? t2 : null;
  }
  setValue(e2, t2) {
    const n2 = this.getBlendShapeGroup(e2);
    var i2;
    n2 && (n2.weight = (i2 = t2, Math.max(Math.min(i2, 1), 0)));
  }
  getBlendShapeTrackName(e2) {
    const t2 = this.getBlendShapeGroup(e2);
    return t2 ? `${t2.name}.weight` : null;
  }
  update() {
    Object.keys(this._blendShapeGroups).forEach((e2) => {
      this._blendShapeGroups[e2].clearAppliedWeight();
    }), Object.keys(this._blendShapeGroups).forEach((e2) => {
      this._blendShapeGroups[e2].applyWeight();
    });
  }
};
var v = class {
  import(e2) {
    var n2;
    return t(this, void 0, void 0, function* () {
      const i2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
      if (!i2)
        return null;
      const r2 = i2.blendShapeMaster;
      if (!r2)
        return null;
      const o2 = new _(), s2 = r2.blendShapeGroups;
      if (!s2)
        return o2;
      const a6 = {};
      return yield Promise.all(s2.map((n3) => t(this, void 0, void 0, function* () {
        const i3 = n3.name;
        if (i3 === void 0)
          return void console.warn("VRMBlendShapeImporter: One of blendShapeGroups has no name");
        let r3;
        n3.presetName && n3.presetName !== h.BlendShapePresetName.Unknown && !a6[n3.presetName] && (r3 = n3.presetName, a6[n3.presetName] = i3);
        const s3 = new d(i3);
        e2.scene.add(s3), s3.isBinary = n3.isBinary || false, n3.binds && n3.binds.forEach((i4) => t(this, void 0, void 0, function* () {
          if (i4.mesh === void 0 || i4.index === void 0)
            return;
          const r4 = [];
          e2.parser.json.nodes.forEach((e3, t2) => {
            e3.mesh === i4.mesh && r4.push(t2);
          });
          const o3 = i4.index;
          yield Promise.all(r4.map((r5) => t(this, void 0, void 0, function* () {
            var a7;
            const l4 = yield function(e3, n4) {
              return t(this, void 0, void 0, function* () {
                const t2 = yield e3.parser.getDependency("node", n4);
                return u(e3, n4, t2);
              });
            }(e2, r5);
            l4.every((e3) => Array.isArray(e3.morphTargetInfluences) && o3 < e3.morphTargetInfluences.length) ? s3.addBind({ meshes: l4, morphTargetIndex: o3, weight: (a7 = i4.weight) !== null && a7 !== void 0 ? a7 : 100 }) : console.warn(`VRMBlendShapeImporter: ${n3.name} attempts to index ${o3}th morph but not found.`);
          })));
        }));
        const l3 = n3.materialValues;
        l3 && l3.forEach((t2) => {
          if (t2.materialName === void 0 || t2.propertyName === void 0 || t2.targetValue === void 0)
            return;
          const n4 = [];
          e2.scene.traverse((e3) => {
            if (e3.material) {
              const i4 = e3.material;
              Array.isArray(i4) ? n4.push(...i4.filter((e4) => e4.name === t2.materialName && n4.indexOf(e4) === -1)) : i4.name === t2.materialName && n4.indexOf(i4) === -1 && n4.push(i4);
            }
          }), n4.forEach((e3) => {
            s3.addMaterialValue({ material: e3, propertyName: p(t2.propertyName), targetValue: t2.targetValue });
          });
        }), o2.registerBlendShapeGroup(i3, r3, s3);
      }))), o2;
    });
  }
};
var y = Object.freeze(new Vector3(0, 0, -1));
var T = new Quaternion();
var x;
!function(e2) {
  e2[e2.Auto = 0] = "Auto", e2[e2.Both = 1] = "Both", e2[e2.ThirdPersonOnly = 2] = "ThirdPersonOnly", e2[e2.FirstPersonOnly = 3] = "FirstPersonOnly";
}(x || (x = {}));
var S = class {
  constructor(e2, t2) {
    this.firstPersonFlag = S._parseFirstPersonFlag(e2), this.primitives = t2;
  }
  static _parseFirstPersonFlag(e2) {
    switch (e2) {
      case "Both":
        return x.Both;
      case "ThirdPersonOnly":
        return x.ThirdPersonOnly;
      case "FirstPersonOnly":
        return x.FirstPersonOnly;
      default:
        return x.Auto;
    }
  }
};
var M = class {
  constructor(e2, t2, n2) {
    this._meshAnnotations = [], this._firstPersonOnlyLayer = M._DEFAULT_FIRSTPERSON_ONLY_LAYER, this._thirdPersonOnlyLayer = M._DEFAULT_THIRDPERSON_ONLY_LAYER, this._initialized = false, this._firstPersonBone = e2, this._firstPersonBoneOffset = t2, this._meshAnnotations = n2;
  }
  get firstPersonBone() {
    return this._firstPersonBone;
  }
  get meshAnnotations() {
    return this._meshAnnotations;
  }
  getFirstPersonWorldDirection(e2) {
    return e2.copy(y).applyQuaternion(g(this._firstPersonBone, T));
  }
  get firstPersonOnlyLayer() {
    return this._firstPersonOnlyLayer;
  }
  get thirdPersonOnlyLayer() {
    return this._thirdPersonOnlyLayer;
  }
  getFirstPersonBoneOffset(e2) {
    return e2.copy(this._firstPersonBoneOffset);
  }
  getFirstPersonWorldPosition(t2) {
    const n2 = this._firstPersonBoneOffset, i2 = new Vector4(n2.x, n2.y, n2.z, 1);
    return i2.applyMatrix4(this._firstPersonBone.matrixWorld), t2.set(i2.x, i2.y, i2.z);
  }
  setup({ firstPersonOnlyLayer: e2 = M._DEFAULT_FIRSTPERSON_ONLY_LAYER, thirdPersonOnlyLayer: t2 = M._DEFAULT_THIRDPERSON_ONLY_LAYER } = {}) {
    this._initialized || (this._initialized = true, this._firstPersonOnlyLayer = e2, this._thirdPersonOnlyLayer = t2, this._meshAnnotations.forEach((e3) => {
      e3.firstPersonFlag === x.FirstPersonOnly ? e3.primitives.forEach((e4) => {
        e4.layers.set(this._firstPersonOnlyLayer);
      }) : e3.firstPersonFlag === x.ThirdPersonOnly ? e3.primitives.forEach((e4) => {
        e4.layers.set(this._thirdPersonOnlyLayer);
      }) : e3.firstPersonFlag === x.Auto && this._createHeadlessModel(e3.primitives);
    }));
  }
  _excludeTriangles(e2, t2, n2, i2) {
    let r2 = 0;
    if (t2 != null && t2.length > 0)
      for (let o2 = 0; o2 < e2.length; o2 += 3) {
        const s2 = e2[o2], a6 = e2[o2 + 1], l3 = e2[o2 + 2], d2 = t2[s2], h2 = n2[s2];
        if (d2[0] > 0 && i2.includes(h2[0]))
          continue;
        if (d2[1] > 0 && i2.includes(h2[1]))
          continue;
        if (d2[2] > 0 && i2.includes(h2[2]))
          continue;
        if (d2[3] > 0 && i2.includes(h2[3]))
          continue;
        const u2 = t2[a6], c2 = n2[a6];
        if (u2[0] > 0 && i2.includes(c2[0]))
          continue;
        if (u2[1] > 0 && i2.includes(c2[1]))
          continue;
        if (u2[2] > 0 && i2.includes(c2[2]))
          continue;
        if (u2[3] > 0 && i2.includes(c2[3]))
          continue;
        const p3 = t2[l3], m2 = n2[l3];
        p3[0] > 0 && i2.includes(m2[0]) || (p3[1] > 0 && i2.includes(m2[1]) || p3[2] > 0 && i2.includes(m2[2]) || p3[3] > 0 && i2.includes(m2[3]) || (e2[r2++] = s2, e2[r2++] = a6, e2[r2++] = l3));
      }
    return r2;
  }
  _createErasedMesh(t2, n2) {
    const i2 = new SkinnedMesh(t2.geometry.clone(), t2.material);
    i2.name = `${t2.name}(erase)`, i2.frustumCulled = t2.frustumCulled, i2.layers.set(this._firstPersonOnlyLayer);
    const r2 = i2.geometry, o2 = r2.getAttribute("skinIndex").array, s2 = [];
    for (let e2 = 0; e2 < o2.length; e2 += 4)
      s2.push([o2[e2], o2[e2 + 1], o2[e2 + 2], o2[e2 + 3]]);
    const a6 = r2.getAttribute("skinWeight").array, l3 = [];
    for (let e2 = 0; e2 < a6.length; e2 += 4)
      l3.push([a6[e2], a6[e2 + 1], a6[e2 + 2], a6[e2 + 3]]);
    const d2 = r2.getIndex();
    if (!d2)
      throw new Error("The geometry doesn't have an index buffer");
    const h2 = Array.from(d2.array), u2 = this._excludeTriangles(h2, l3, s2, n2), c2 = [];
    for (let e2 = 0; e2 < u2; e2++)
      c2[e2] = h2[e2];
    return r2.setIndex(c2), t2.onBeforeRender && (i2.onBeforeRender = t2.onBeforeRender), i2.bind(new Skeleton(t2.skeleton.bones, t2.skeleton.boneInverses), new Matrix4()), i2;
  }
  _createHeadlessModelForSkinnedMesh(e2, t2) {
    const n2 = [];
    if (t2.skeleton.bones.forEach((e3, t3) => {
      this._isEraseTarget(e3) && n2.push(t3);
    }), !n2.length)
      return t2.layers.enable(this._thirdPersonOnlyLayer), void t2.layers.enable(this._firstPersonOnlyLayer);
    t2.layers.set(this._thirdPersonOnlyLayer);
    const i2 = this._createErasedMesh(t2, n2);
    e2.add(i2);
  }
  _createHeadlessModel(e2) {
    e2.forEach((e3) => {
      if (e3.type === "SkinnedMesh") {
        const t2 = e3;
        this._createHeadlessModelForSkinnedMesh(t2.parent, t2);
      } else
        this._isEraseTarget(e3) && e3.layers.set(this._thirdPersonOnlyLayer);
    });
  }
  _isEraseTarget(e2) {
    return e2 === this._firstPersonBone || !!e2.parent && this._isEraseTarget(e2.parent);
  }
};
M._DEFAULT_FIRSTPERSON_ONLY_LAYER = 9, M._DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
var E = class {
  import(n2, i2) {
    var r2;
    return t(this, void 0, void 0, function* () {
      const t2 = (r2 = n2.parser.json.extensions) === null || r2 === void 0 ? void 0 : r2.VRM;
      if (!t2)
        return null;
      const o2 = t2.firstPerson;
      if (!o2)
        return null;
      const s2 = o2.firstPersonBone;
      let a6;
      if (a6 = s2 === void 0 || s2 === -1 ? i2.getBoneNode(h.HumanoidBoneName.Head) : yield n2.parser.getDependency("node", s2), !a6)
        return console.warn("VRMFirstPersonImporter: Could not find firstPersonBone of the VRM"), null;
      const l3 = o2.firstPersonBoneOffset ? new Vector3(o2.firstPersonBoneOffset.x, o2.firstPersonBoneOffset.y, -o2.firstPersonBoneOffset.z) : new Vector3(0, 0.06, 0), d2 = [], u2 = yield c(n2);
      return Array.from(u2.entries()).forEach(([e2, t3]) => {
        const i3 = n2.parser.json.nodes[e2], r3 = o2.meshAnnotations ? o2.meshAnnotations.find((e3) => e3.mesh === i3.mesh) : void 0;
        d2.push(new S(r3 == null ? void 0 : r3.firstPersonFlag, t3));
      }), new M(a6, l3, d2);
    });
  }
};
var L = class {
  constructor(e2, t2) {
    this.node = e2, this.humanLimit = t2;
  }
};
function w(e2) {
  return e2.invert ? e2.invert() : e2.inverse(), e2;
}
var R = new Vector3();
var P = new Quaternion();
var A = class {
  constructor(e2, t2) {
    this.restPose = {}, this.humanBones = this._createHumanBones(e2), this.humanDescription = t2, this.restPose = this.getPose();
  }
  getPose() {
    const e2 = {};
    return Object.keys(this.humanBones).forEach((t2) => {
      const n2 = this.getBoneNode(t2);
      if (!n2)
        return;
      if (e2[t2])
        return;
      R.set(0, 0, 0), P.identity();
      const i2 = this.restPose[t2];
      (i2 == null ? void 0 : i2.position) && R.fromArray(i2.position).negate(), (i2 == null ? void 0 : i2.rotation) && w(P.fromArray(i2.rotation)), R.add(n2.position), P.premultiply(n2.quaternion), e2[t2] = { position: R.toArray(), rotation: P.toArray() };
    }, {}), e2;
  }
  setPose(e2) {
    Object.keys(e2).forEach((t2) => {
      const n2 = e2[t2], i2 = this.getBoneNode(t2);
      if (!i2)
        return;
      const r2 = this.restPose[t2];
      r2 && (n2.position && (i2.position.fromArray(n2.position), r2.position && i2.position.add(R.fromArray(r2.position))), n2.rotation && (i2.quaternion.fromArray(n2.rotation), r2.rotation && i2.quaternion.multiply(P.fromArray(r2.rotation))));
    });
  }
  resetPose() {
    Object.entries(this.restPose).forEach(([e2, t2]) => {
      const n2 = this.getBoneNode(e2);
      n2 && ((t2 == null ? void 0 : t2.position) && n2.position.fromArray(t2.position), (t2 == null ? void 0 : t2.rotation) && n2.quaternion.fromArray(t2.rotation));
    });
  }
  getBone(e2) {
    var t2;
    return (t2 = this.humanBones[e2][0]) !== null && t2 !== void 0 ? t2 : void 0;
  }
  getBones(e2) {
    var t2;
    return (t2 = this.humanBones[e2]) !== null && t2 !== void 0 ? t2 : [];
  }
  getBoneNode(e2) {
    var t2, n2;
    return (n2 = (t2 = this.humanBones[e2][0]) === null || t2 === void 0 ? void 0 : t2.node) !== null && n2 !== void 0 ? n2 : null;
  }
  getBoneNodes(e2) {
    var t2, n2;
    return (n2 = (t2 = this.humanBones[e2]) === null || t2 === void 0 ? void 0 : t2.map((e3) => e3.node)) !== null && n2 !== void 0 ? n2 : [];
  }
  _createHumanBones(e2) {
    const t2 = Object.values(h.HumanoidBoneName).reduce((e3, t3) => (e3[t3] = [], e3), {});
    return e2.forEach((e3) => {
      t2[e3.name].push(e3.bone);
    }), t2;
  }
};
var C = class {
  import(n2) {
    var i2;
    return t(this, void 0, void 0, function* () {
      const r2 = (i2 = n2.parser.json.extensions) === null || i2 === void 0 ? void 0 : i2.VRM;
      if (!r2)
        return null;
      const o2 = r2.humanoid;
      if (!o2)
        return null;
      const s2 = [];
      o2.humanBones && (yield Promise.all(o2.humanBones.map((i3) => t(this, void 0, void 0, function* () {
        if (!i3.bone || i3.node == null)
          return;
        const t2 = yield n2.parser.getDependency("node", i3.node);
        s2.push({ name: i3.bone, bone: new L(t2, { axisLength: i3.axisLength, center: i3.center && new Vector3(i3.center.x, i3.center.y, i3.center.z), max: i3.max && new Vector3(i3.max.x, i3.max.y, i3.max.z), min: i3.min && new Vector3(i3.min.x, i3.min.y, i3.min.z), useDefaultValues: i3.useDefaultValues }) });
      }))));
      const a6 = { armStretch: o2.armStretch, legStretch: o2.legStretch, upperArmTwist: o2.upperArmTwist, lowerArmTwist: o2.lowerArmTwist, upperLegTwist: o2.upperLegTwist, lowerLegTwist: o2.lowerLegTwist, feetSpacing: o2.feetSpacing, hasTranslationDoF: o2.hasTranslationDoF };
      return new A(s2, a6);
    });
  }
};
var O = class {
  constructor(e2, t2, n2) {
    this.curve = [0, 0, 0, 1, 1, 1, 1, 0], this.curveXRangeDegree = 90, this.curveYRangeDegree = 10, e2 !== void 0 && (this.curveXRangeDegree = e2), t2 !== void 0 && (this.curveYRangeDegree = t2), n2 !== void 0 && (this.curve = n2);
  }
  map(e2) {
    const t2 = Math.min(Math.max(e2, 0), this.curveXRangeDegree) / this.curveXRangeDegree;
    return this.curveYRangeDegree * ((e3, t3) => {
      if (e3.length < 8)
        throw new Error("evaluateCurve: Invalid curve detected! (Array length must be 8 at least)");
      if (e3.length % 4 != 0)
        throw new Error("evaluateCurve: Invalid curve detected! (Array length must be multiples of 4");
      let n2;
      for (n2 = 0; ; n2++) {
        if (e3.length <= 4 * n2)
          return e3[4 * n2 - 3];
        if (t3 <= e3[4 * n2])
          break;
      }
      const i2 = n2 - 1;
      if (i2 < 0)
        return e3[4 * i2 + 5];
      const r2 = e3[4 * i2], o2 = (t3 - r2) / (e3[4 * n2] - r2);
      return ((e4, t4, n3, i3, r3) => {
        const o3 = r3 * r3 * r3, s2 = r3 * r3;
        return e4 + (t4 - e4) * (-2 * o3 + 3 * s2) + n3 * (o3 - 2 * s2 + r3) + i3 * (o3 - s2);
      })(e3[4 * i2 + 1], e3[4 * n2 + 1], e3[4 * i2 + 3], e3[4 * n2 + 2], o2);
    })(this.curve, t2);
  }
};
var b = class {
};
var I = class extends b {
  constructor(e2, t2, n2, i2) {
    super(), this.type = h.FirstPersonLookAtTypeName.BlendShape, this._curveHorizontal = t2, this._curveVerticalDown = n2, this._curveVerticalUp = i2, this._blendShapeProxy = e2;
  }
  name() {
    return h.FirstPersonLookAtTypeName.BlendShape;
  }
  lookAt(e2) {
    const t2 = e2.x, n2 = e2.y;
    t2 < 0 ? (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-t2))) : (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup, this._curveVerticalUp.map(t2))), n2 < 0 ? (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright, this._curveHorizontal.map(-n2))) : (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft, this._curveHorizontal.map(n2)));
  }
};
var N = Object.freeze(new Vector3(0, 0, -1));
var D = new Vector3();
var U = new Vector3();
var B = new Vector3();
var V = new Quaternion();
var G = class {
  constructor(t2, n2) {
    this.autoUpdate = true, this._euler = new Euler(0, 0, 0, G.EULER_ORDER), this.firstPerson = t2, this.applyer = n2;
  }
  getLookAtWorldDirection(e2) {
    const t2 = g(this.firstPerson.firstPersonBone, V);
    return e2.copy(N).applyEuler(this._euler).applyQuaternion(t2);
  }
  lookAt(e2) {
    this._calcEuler(this._euler, e2), this.applyer && this.applyer.lookAt(this._euler);
  }
  update(e2) {
    this.target && this.autoUpdate && (this.lookAt(this.target.getWorldPosition(D)), this.applyer && this.applyer.lookAt(this._euler));
  }
  _calcEuler(e2, t2) {
    const n2 = this.firstPerson.getFirstPersonWorldPosition(U), i2 = B.copy(t2).sub(n2).normalize();
    return i2.applyQuaternion(w(g(this.firstPerson.firstPersonBone, V))), e2.x = Math.atan2(i2.y, Math.sqrt(i2.x * i2.x + i2.z * i2.z)), e2.y = Math.atan2(-i2.x, -i2.z), e2;
  }
};
G.EULER_ORDER = "YXZ";
var F = new Euler(0, 0, 0, G.EULER_ORDER);
var k = class extends b {
  constructor(e2, t2, n2, i2, r2) {
    super(), this.type = h.FirstPersonLookAtTypeName.Bone, this._curveHorizontalInner = t2, this._curveHorizontalOuter = n2, this._curveVerticalDown = i2, this._curveVerticalUp = r2, this._leftEye = e2.getBoneNode(h.HumanoidBoneName.LeftEye), this._rightEye = e2.getBoneNode(h.HumanoidBoneName.RightEye);
  }
  lookAt(e2) {
    const t2 = e2.x, n2 = e2.y;
    this._leftEye && (F.x = t2 < 0 ? -this._curveVerticalDown.map(-t2) : this._curveVerticalUp.map(t2), F.y = n2 < 0 ? -this._curveHorizontalInner.map(-n2) : this._curveHorizontalOuter.map(n2), this._leftEye.quaternion.setFromEuler(F)), this._rightEye && (F.x = t2 < 0 ? -this._curveVerticalDown.map(-t2) : this._curveVerticalUp.map(t2), F.y = n2 < 0 ? -this._curveHorizontalOuter.map(-n2) : this._curveHorizontalInner.map(n2), this._rightEye.quaternion.setFromEuler(F));
  }
};
var H = Math.PI / 180;
var W = class {
  import(e2, t2, n2, i2) {
    var r2;
    const o2 = (r2 = e2.parser.json.extensions) === null || r2 === void 0 ? void 0 : r2.VRM;
    if (!o2)
      return null;
    const s2 = o2.firstPerson;
    if (!s2)
      return null;
    const a6 = this._importApplyer(s2, n2, i2);
    return new G(t2, a6 || void 0);
  }
  _importApplyer(e2, t2, n2) {
    const i2 = e2.lookAtHorizontalInner, r2 = e2.lookAtHorizontalOuter, o2 = e2.lookAtVerticalDown, s2 = e2.lookAtVerticalUp;
    switch (e2.lookAtTypeName) {
      case h.FirstPersonLookAtTypeName.Bone:
        return i2 === void 0 || r2 === void 0 || o2 === void 0 || s2 === void 0 ? null : new k(n2, this._importCurveMapperBone(i2), this._importCurveMapperBone(r2), this._importCurveMapperBone(o2), this._importCurveMapperBone(s2));
      case h.FirstPersonLookAtTypeName.BlendShape:
        return r2 === void 0 || o2 === void 0 || s2 === void 0 ? null : new I(t2, this._importCurveMapperBlendShape(r2), this._importCurveMapperBlendShape(o2), this._importCurveMapperBlendShape(s2));
      default:
        return null;
    }
  }
  _importCurveMapperBone(e2) {
    return new O(typeof e2.xRange == "number" ? H * e2.xRange : void 0, typeof e2.yRange == "number" ? H * e2.yRange : void 0, e2.curve);
  }
  _importCurveMapperBlendShape(e2) {
    return new O(typeof e2.xRange == "number" ? H * e2.xRange : void 0, e2.yRange, e2.curve);
  }
};
var z = (t2, n2) => {
  const i2 = ((t3) => {
    switch (t3) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw new Error("unsupported encoding: " + t3);
    }
  })(n2);
  return "vec4 " + t2 + "( vec4 value ) { return " + i2[0] + "ToLinear" + i2[1] + "; }";
};
var j = 2 * Math.PI;
var Y;
var X;
var q;
var Q;
var Z;
!function(e2) {
  e2[e2.Off = 0] = "Off", e2[e2.Front = 1] = "Front", e2[e2.Back = 2] = "Back";
}(Y || (Y = {})), function(e2) {
  e2[e2.None = 0] = "None", e2[e2.Normal = 1] = "Normal", e2[e2.LitShadeRate = 2] = "LitShadeRate", e2[e2.UV = 3] = "UV";
}(X || (X = {})), function(e2) {
  e2[e2.FixedColor = 0] = "FixedColor", e2[e2.MixedLighting = 1] = "MixedLighting";
}(q || (q = {})), function(e2) {
  e2[e2.None = 0] = "None", e2[e2.WorldCoordinates = 1] = "WorldCoordinates", e2[e2.ScreenCoordinates = 2] = "ScreenCoordinates";
}(Q || (Q = {})), function(e2) {
  e2[e2.Opaque = 0] = "Opaque", e2[e2.Cutout = 1] = "Cutout", e2[e2.Transparent = 2] = "Transparent", e2[e2.TransparentWithZWrite = 3] = "TransparentWithZWrite";
}(Z || (Z = {}));
var $ = class extends ShaderMaterial {
  constructor(t2 = {}) {
    super(), this.isMToonMaterial = true, this.cutoff = 0.5, this.color = new Vector4(1, 1, 1, 1), this.shadeColor = new Vector4(0.97, 0.81, 0.86, 1), this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this.shadeTexture = null, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.receiveShadowRate = 1, this.receiveShadowTexture = null, this.shadingGradeRate = 1, this.shadingGradeTexture = null, this.shadeShift = 0, this.shadeToony = 0.9, this.lightColorAttenuation = 0, this.indirectLightIntensity = 0.1, this.rimTexture = null, this.rimColor = new Vector4(0, 0, 0, 1), this.rimLightingMix = 0, this.rimFresnelPower = 1, this.rimLift = 0, this.sphereAdd = null, this.emissionColor = new Vector4(0, 0, 0, 1), this.emissiveMap = null, this.outlineWidthTexture = null, this.outlineWidth = 0.5, this.outlineScaledMaxDistance = 1, this.outlineColor = new Vector4(0, 0, 0, 1), this.outlineLightingMix = 1, this.uvAnimMaskTexture = null, this.uvAnimScrollX = 0, this.uvAnimScrollY = 0, this.uvAnimRotation = 0, this.shouldApplyUniforms = true, this._debugMode = X.None, this._blendMode = Z.Opaque, this._outlineWidthMode = Q.None, this._outlineColorMode = q.FixedColor, this._cullMode = Y.Back, this._outlineCullMode = Y.Front, this._isOutline = false, this._uvAnimOffsetX = 0, this._uvAnimOffsetY = 0, this._uvAnimPhase = 0, this.encoding = t2.encoding || LinearEncoding, this.encoding !== LinearEncoding && this.encoding !== sRGBEncoding && console.warn("The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead."), ["mToonVersion", "shadeTexture_ST", "bumpMap_ST", "receiveShadowTexture_ST", "shadingGradeTexture_ST", "rimTexture_ST", "sphereAdd_ST", "emissionMap_ST", "outlineWidthTexture_ST", "uvAnimMaskTexture_ST", "srcBlend", "dstBlend"].forEach((e2) => {
      t2[e2] !== void 0 && delete t2[e2];
    }), t2.fog = true, t2.lights = true, t2.clipping = true, parseInt(REVISION, 10) < 129 && (t2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (t2.morphTargets = t2.morphTargets || false, t2.morphNormals = t2.morphNormals || false), t2.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.normalmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { cutoff: { value: 0.5 }, color: { value: new Color(1, 1, 1) }, colorAlpha: { value: 1 }, shadeColor: { value: new Color(0.97, 0.81, 0.86) }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) }, shadeTexture: { value: null }, receiveShadowRate: { value: 1 }, receiveShadowTexture: { value: null }, shadingGradeRate: { value: 1 }, shadingGradeTexture: { value: null }, shadeShift: { value: 0 }, shadeToony: { value: 0.9 }, lightColorAttenuation: { value: 0 }, indirectLightIntensity: { value: 0.1 }, rimTexture: { value: null }, rimColor: { value: new Color(0, 0, 0) }, rimLightingMix: { value: 0 }, rimFresnelPower: { value: 1 }, rimLift: { value: 0 }, sphereAdd: { value: null }, emissionColor: { value: new Color(0, 0, 0) }, outlineWidthTexture: { value: null }, outlineWidth: { value: 0.5 }, outlineScaledMaxDistance: { value: 1 }, outlineColor: { value: new Color(0, 0, 0) }, outlineLightingMix: { value: 1 }, uvAnimMaskTexture: { value: null }, uvAnimOffsetX: { value: 0 }, uvAnimOffsetY: { value: 0 }, uvAnimTheta: { value: 0 } }]), this.setValues(t2), this._updateShaderCode(), this._applyUniforms();
  }
  get mainTex() {
    return this.map;
  }
  set mainTex(e2) {
    this.map = e2;
  }
  get bumpMap() {
    return this.normalMap;
  }
  set bumpMap(e2) {
    this.normalMap = e2;
  }
  get bumpScale() {
    return this.normalScale.x;
  }
  set bumpScale(e2) {
    this.normalScale.set(e2, e2);
  }
  get emissionMap() {
    return this.emissiveMap;
  }
  set emissionMap(e2) {
    this.emissiveMap = e2;
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(e2) {
    this._blendMode = e2, this.depthWrite = this._blendMode !== Z.Transparent, this.transparent = this._blendMode === Z.Transparent || this._blendMode === Z.TransparentWithZWrite, this._updateShaderCode();
  }
  get debugMode() {
    return this._debugMode;
  }
  set debugMode(e2) {
    this._debugMode = e2, this._updateShaderCode();
  }
  get outlineWidthMode() {
    return this._outlineWidthMode;
  }
  set outlineWidthMode(e2) {
    this._outlineWidthMode = e2, this._updateShaderCode();
  }
  get outlineColorMode() {
    return this._outlineColorMode;
  }
  set outlineColorMode(e2) {
    this._outlineColorMode = e2, this._updateShaderCode();
  }
  get cullMode() {
    return this._cullMode;
  }
  set cullMode(e2) {
    this._cullMode = e2, this._updateCullFace();
  }
  get outlineCullMode() {
    return this._outlineCullMode;
  }
  set outlineCullMode(e2) {
    this._outlineCullMode = e2, this._updateCullFace();
  }
  get zWrite() {
    return this.depthWrite ? 1 : 0;
  }
  set zWrite(e2) {
    this.depthWrite = 0.5 <= e2;
  }
  get isOutline() {
    return this._isOutline;
  }
  set isOutline(e2) {
    this._isOutline = e2, this._updateShaderCode(), this._updateCullFace();
  }
  updateVRMMaterials(e2) {
    this._uvAnimOffsetX = this._uvAnimOffsetX + e2 * this.uvAnimScrollX, this._uvAnimOffsetY = this._uvAnimOffsetY - e2 * this.uvAnimScrollY, this._uvAnimPhase = this._uvAnimPhase + e2 * this.uvAnimRotation, this._applyUniforms();
  }
  copy(e2) {
    return super.copy(e2), this.cutoff = e2.cutoff, this.color.copy(e2.color), this.shadeColor.copy(e2.shadeColor), this.map = e2.map, this.mainTex_ST.copy(e2.mainTex_ST), this.shadeTexture = e2.shadeTexture, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(this.normalScale), this.receiveShadowRate = e2.receiveShadowRate, this.receiveShadowTexture = e2.receiveShadowTexture, this.shadingGradeRate = e2.shadingGradeRate, this.shadingGradeTexture = e2.shadingGradeTexture, this.shadeShift = e2.shadeShift, this.shadeToony = e2.shadeToony, this.lightColorAttenuation = e2.lightColorAttenuation, this.indirectLightIntensity = e2.indirectLightIntensity, this.rimTexture = e2.rimTexture, this.rimColor.copy(e2.rimColor), this.rimLightingMix = e2.rimLightingMix, this.rimFresnelPower = e2.rimFresnelPower, this.rimLift = e2.rimLift, this.sphereAdd = e2.sphereAdd, this.emissionColor.copy(e2.emissionColor), this.emissiveMap = e2.emissiveMap, this.outlineWidthTexture = e2.outlineWidthTexture, this.outlineWidth = e2.outlineWidth, this.outlineScaledMaxDistance = e2.outlineScaledMaxDistance, this.outlineColor.copy(e2.outlineColor), this.outlineLightingMix = e2.outlineLightingMix, this.uvAnimMaskTexture = e2.uvAnimMaskTexture, this.uvAnimScrollX = e2.uvAnimScrollX, this.uvAnimScrollY = e2.uvAnimScrollY, this.uvAnimRotation = e2.uvAnimRotation, this.debugMode = e2.debugMode, this.blendMode = e2.blendMode, this.outlineWidthMode = e2.outlineWidthMode, this.outlineColorMode = e2.outlineColorMode, this.cullMode = e2.cullMode, this.outlineCullMode = e2.outlineCullMode, this.isOutline = e2.isOutline, this;
  }
  _applyUniforms() {
    this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX, this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY, this.uniforms.uvAnimTheta.value = j * this._uvAnimPhase, this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z), this.uniforms.colorAlpha.value = this.color.w, this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z), this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST), this.uniforms.shadeTexture.value = this.shadeTexture, this.uniforms.normalMap.value = this.normalMap, this.uniforms.normalScale.value.copy(this.normalScale), this.uniforms.receiveShadowRate.value = this.receiveShadowRate, this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture, this.uniforms.shadingGradeRate.value = this.shadingGradeRate, this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture, this.uniforms.shadeShift.value = this.shadeShift, this.uniforms.shadeToony.value = this.shadeToony, this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation, this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity, this.uniforms.rimTexture.value = this.rimTexture, this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z), this.uniforms.rimLightingMix.value = this.rimLightingMix, this.uniforms.rimFresnelPower.value = this.rimFresnelPower, this.uniforms.rimLift.value = this.rimLift, this.uniforms.sphereAdd.value = this.sphereAdd, this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z), this.uniforms.emissiveMap.value = this.emissiveMap, this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture, this.uniforms.outlineWidth.value = this.outlineWidth, this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance, this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z), this.uniforms.outlineLightingMix.value = this.outlineLightingMix, this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture, this.encoding === sRGBEncoding && (this.uniforms.color.value.convertSRGBToLinear(), this.uniforms.shadeColor.value.convertSRGBToLinear(), this.uniforms.rimColor.value.convertSRGBToLinear(), this.uniforms.emissionColor.value.convertSRGBToLinear(), this.uniforms.outlineColor.value.convertSRGBToLinear()), this._updateCullFace());
  }
  _updateShaderCode() {
    const t2 = this.outlineWidthTexture !== null, n2 = this.map !== null || this.shadeTexture !== null || this.receiveShadowTexture !== null || this.shadingGradeTexture !== null || this.rimTexture !== null || this.uvAnimMaskTexture !== null;
    this.defines = { THREE_VRM_THREE_REVISION: parseInt(REVISION, 10), OUTLINE: this._isOutline, BLENDMODE_OPAQUE: this._blendMode === Z.Opaque, BLENDMODE_CUTOUT: this._blendMode === Z.Cutout, BLENDMODE_TRANSPARENT: this._blendMode === Z.Transparent || this._blendMode === Z.TransparentWithZWrite, MTOON_USE_UV: t2 || n2, MTOON_UVS_VERTEX_ONLY: t2 && !n2, USE_SHADETEXTURE: this.shadeTexture !== null, USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null, USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null, USE_RIMTEXTURE: this.rimTexture !== null, USE_SPHEREADD: this.sphereAdd !== null, USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null, USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null, DEBUG_NORMAL: this._debugMode === X.Normal, DEBUG_LITSHADERATE: this._debugMode === X.LitShadeRate, DEBUG_UV: this._debugMode === X.UV, OUTLINE_WIDTH_WORLD: this._outlineWidthMode === Q.WorldCoordinates, OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === Q.ScreenCoordinates, OUTLINE_COLOR_FIXED: this._outlineColorMode === q.FixedColor, OUTLINE_COLOR_MIXED: this._outlineColorMode === q.MixedLighting };
    const i2 = (this.shadeTexture !== null ? z("shadeTextureTexelToLinear", this.shadeTexture.encoding) + "\n" : "") + (this.sphereAdd !== null ? z("sphereAddTexelToLinear", this.sphereAdd.encoding) + "\n" : "") + (this.rimTexture !== null ? z("rimTextureTexelToLinear", this.rimTexture.encoding) + "\n" : "");
    this.vertexShader = "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  #ifdef MTOON_UVS_VERTEX_ONLY\n    vec2 vUv;\n  #else\n    varying vec2 vUv;\n  #endif\n\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHTEXTURE\n  uniform sampler2D outlineWidthTexture;\n#endif\n\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    vUv = uv;\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHTEXTURE\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = i2 + '// #define PHONG\n\n#ifdef BLENDMODE_CUTOUT\n  uniform float cutoff;\n#endif\n\nuniform vec3 color;\nuniform float colorAlpha;\nuniform vec3 shadeColor;\n#ifdef USE_SHADETEXTURE\n  uniform sampler2D shadeTexture;\n#endif\n\nuniform float receiveShadowRate;\n#ifdef USE_RECEIVESHADOWTEXTURE\n  uniform sampler2D receiveShadowTexture;\n#endif\n\nuniform float shadingGradeRate;\n#ifdef USE_SHADINGGRADETEXTURE\n  uniform sampler2D shadingGradeTexture;\n#endif\n\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\n\n#ifdef USE_RIMTEXTURE\n  uniform sampler2D rimTexture;\n#endif\nuniform vec3 rimColor;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\n\n#ifdef USE_SPHEREADD\n  uniform sampler2D sphereAdd;\n#endif\n\nuniform vec3 emissionColor;\n\nuniform vec3 outlineColor;\nuniform float outlineLightingMix;\n\n#ifdef USE_UVANIMMASKTEXTURE\n  uniform sampler2D uvAnimMaskTexture;\n#endif\n\nuniform float uvAnimOffsetX;\nuniform float uvAnimOffsetY;\nuniform float uvAnimTheta;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n#include <lights_pars_begin>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingGrade;\n  float receiveShadow;\n};\n\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126\n  // See: #21205, #21307, #21299\n  #if THREE_VRM_THREE_REVISION >= 126\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      S = normalize( S );\n      T = normalize( T );\n      vec3 N = normalize( surf_norm );\n\n      #ifdef DOUBLE_SIDED\n\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\n      #else\n\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n      mat3 tsn = mat3( S, T, N );\n      return normalize( tsn * mapN );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == lighting stuff ===========================================================\nfloat getLightIntensity(\n  const in IncidentLight directLight,\n  const in GeometricContext geometry,\n  const in float shadow,\n  const in float shadingGrade\n) {\n  float lightIntensity = dot( geometry.normal, directLight.direction );\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\n  lightIntensity = lightIntensity * shadow;\n  lightIntensity = lightIntensity * shadingGrade;\n  lightIntensity = lightIntensity * 2.0 - 1.0;\n  return shadeToony == 1.0\n    ? step( shadeShift, lightIntensity )\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\n}\n\nvec3 getLighting( const in vec3 lightColor ) {\n  vec3 lighting = lightColor;\n  lighting = mix(\n    lighting,\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\n    lightColorAttenuation\n  );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    lighting *= PI;\n  #endif\n\n  return lighting;\n}\n\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float lightIntensity,\n  const in vec3 lighting\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( lightIntensity * lighting ) );\n  #endif\n\n  return lighting * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\n}\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMMASKTEXTURE\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\n    #endif\n\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( color, colorAlpha );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissionColor;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // -- MToon: alpha -----------------------------------------------------------\n  // #include <alphatest_fragment>\n  #ifdef BLENDMODE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef BLENDMODE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  #ifdef OBJECTSPACE_NORMALMAP\n\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = normal * faceDirection;\n\n      #else\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  #elif defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    #ifdef USE_TANGENT\n\n      normal = normalize( vTBN * mapN );\n\n    #else\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n      #else\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\n\n      #endif\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColor;\n  #ifdef USE_SHADETEXTURE\n    material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\n  #endif\n\n  material.shadingGrade = 1.0;\n  #ifdef USE_SHADINGGRADETEXTURE\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\n  #endif\n\n  material.receiveShadow = receiveShadowRate;\n  #ifdef USE_RECEIVESHADOWTEXTURE\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\n  #endif\n\n  // #include <lights_fragment_begin>\n  GeometricContext geometry;\n\n  geometry.position = - vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n  IncidentLight directLight;\n  vec3 lightingSum = vec3( 0.0 );\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float atten, shadow, lightIntensity;\n  vec3 lighting;\n\n  #if ( NUM_POINT_LIGHTS > 0 )\n    PointLight pointLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n      pointLight = pointLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getPointLightInfo( pointLight, geometry, directLight );\n      #else\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 )\n    SpotLight spotLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #else\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 )\n    DirectionalLight directionalLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      directionalLight = directionalLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #else\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  // #if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n  #if THREE_VRM_THREE_REVISION >= 133\n    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  #else\n    irradiance += getLightProbeIrradiance( lightProbe, geometry );\n  #endif\n  #if ( NUM_HEMI_LIGHTS > 0 )\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n    }\n    #pragma unroll_loop_end\n  #endif\n  // #endif\n\n  // #include <lights_fragment_maps>\n  #ifdef USE_LIGHTMAP\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n    vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lightMapIrradiance *= PI;\n    #endif\n    irradiance += lightMapIrradiance;\n  #endif\n\n  // #include <lights_fragment_end>\n  // RE_IndirectDiffuse here\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Lambert( material.diffuseColor );\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  // The "comment out if you want to PBR absolutely" line\n  #ifndef DEBUG_LITSHADERATE\n    col = min(col, material.diffuseColor);\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\n    gl_FragColor = vec4(\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\n      diffuseColor.a\n    );\n    postCorrection();\n    return;\n  #endif\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: parametric rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\n  #ifdef USE_RIMTEXTURE\n    rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\n  #endif\n  col += rim;\n\n  // -- MToon: additive matcap -------------------------------------------------\n  #ifdef USE_SPHEREADD\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\n      col += matcap;\n    }\n  #endif\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}', this.needsUpdate = true;
  }
  _updateCullFace() {
    this.isOutline ? this.outlineCullMode === Y.Off ? this.side = DoubleSide : this.outlineCullMode === Y.Front ? this.side = BackSide : this.outlineCullMode === Y.Back && (this.side = FrontSide) : this.cullMode === Y.Off ? this.side = DoubleSide : this.cullMode === Y.Front ? this.side = BackSide : this.cullMode === Y.Back && (this.side = FrontSide);
  }
};
var J;
!function(e2) {
  e2[e2.Opaque = 0] = "Opaque", e2[e2.Cutout = 1] = "Cutout", e2[e2.Transparent = 2] = "Transparent", e2[e2.TransparentWithZWrite = 3] = "TransparentWithZWrite";
}(J || (J = {}));
var K = class extends ShaderMaterial {
  constructor(t2) {
    super(), this.isVRMUnlitMaterial = true, this.cutoff = 0.5, this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this._renderType = J.Opaque, this.shouldApplyUniforms = true, t2 === void 0 && (t2 = {}), t2.fog = true, t2.clipping = true, parseInt(REVISION, 10) < 129 && (t2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (t2.morphTargets = t2.morphTargets || false, t2.morphNormals = t2.morphNormals || false), t2.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, { cutoff: { value: 0.5 }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) } }]), this.setValues(t2), this._updateShaderCode(), this._applyUniforms();
  }
  get mainTex() {
    return this.map;
  }
  set mainTex(e2) {
    this.map = e2;
  }
  get renderType() {
    return this._renderType;
  }
  set renderType(e2) {
    this._renderType = e2, this.depthWrite = this._renderType !== J.Transparent, this.transparent = this._renderType === J.Transparent || this._renderType === J.TransparentWithZWrite, this._updateShaderCode();
  }
  updateVRMMaterials(e2) {
    this._applyUniforms();
  }
  copy(e2) {
    return super.copy(e2), this.cutoff = e2.cutoff, this.map = e2.map, this.mainTex_ST.copy(e2.mainTex_ST), this.renderType = e2.renderType, this;
  }
  _applyUniforms() {
    this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST));
  }
  _updateShaderCode() {
    this.defines = { RENDERTYPE_OPAQUE: this._renderType === J.Opaque, RENDERTYPE_CUTOUT: this._renderType === J.Cutout, RENDERTYPE_TRANSPARENT: this._renderType === J.Transparent || this._renderType === J.TransparentWithZWrite }, this.vertexShader = "#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef USE_MAP\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n  #include <skinbase_vertex>\n\n  #ifdef USE_ENVMAP\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n\n  #endif\n\n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n\n  #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n  #include <envmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = "#ifdef RENDERTYPE_CUTOUT\n  uniform float cutoff;\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n// #include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n// #include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4( 1.0 );\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // MToon: alpha\n  // #include <alphatest_fragment>\n  #ifdef RENDERTYPE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef RENDERTYPE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  // #include <specularmap_fragment>\n\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n  // accumulation (baked indirect lighting only)\n  #ifdef USE_LIGHTMAP\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  #else\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\n  #endif\n\n  // modulation\n  // #include <aomap_fragment>\n\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n  // #include <envmap_fragment>\n\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}", this.needsUpdate = true;
  }
};
var ee = class {
  constructor(t2 = {}) {
    this._encoding = t2.encoding || LinearEncoding, this._encoding !== LinearEncoding && this._encoding !== sRGBEncoding && console.warn("The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead."), this._requestEnvMap = t2.requestEnvMap;
  }
  convertGLTFMaterials(e2) {
    var n2;
    return t(this, void 0, void 0, function* () {
      const i2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
      if (!i2)
        return null;
      const r2 = i2.materialProperties;
      if (!r2)
        return null;
      const o2 = yield c(e2), s2 = {}, a6 = [];
      return yield Promise.all(Array.from(o2.entries()).map(([n3, i3]) => t(this, void 0, void 0, function* () {
        const o3 = e2.parser.json.nodes[n3], l3 = e2.parser.json.meshes[o3.mesh];
        yield Promise.all(i3.map((n4, i4) => t(this, void 0, void 0, function* () {
          const t2 = l3.primitives[i4];
          if (!t2)
            return;
          const o4 = n4.geometry, d2 = o4.index ? o4.index.count : o4.attributes.position.count / 3;
          Array.isArray(n4.material) || (n4.material = [n4.material], o4.addGroup(0, d2, 0));
          const h2 = t2.material;
          let u2, c2 = r2[h2];
          c2 || (console.warn(`VRMMaterialImporter: There are no material definition for material #${h2} on VRM extension.`), c2 = { shader: "VRM_USE_GLTFSHADER" }), s2[h2] ? u2 = s2[h2] : (u2 = yield this.createVRMMaterials(n4.material[0], c2, e2), s2[h2] = u2, a6.push(u2.surface), u2.outline && a6.push(u2.outline)), n4.material[0] = u2.surface, this._requestEnvMap && u2.surface.isMeshStandardMaterial && this._requestEnvMap().then((e3) => {
            u2.surface.envMap = e3, u2.surface.needsUpdate = true;
          }), n4.renderOrder = c2.renderQueue || 2e3, u2.outline && (n4.material[1] = u2.outline, o4.addGroup(0, d2, 1));
        })));
      }))), a6;
    });
  }
  createVRMMaterials(e2, n2, i2) {
    return t(this, void 0, void 0, function* () {
      let t2, r2;
      if (n2.shader === "VRM/MToon") {
        const o2 = yield this._extractMaterialProperties(e2, n2, i2);
        ["srcBlend", "dstBlend", "isFirstSetup"].forEach((e3) => {
          o2[e3] !== void 0 && delete o2[e3];
        }), ["mainTex", "shadeTexture", "emissionMap", "sphereAdd", "rimTexture"].forEach((e3) => {
          o2[e3] !== void 0 && (o2[e3].encoding = this._encoding);
        }), o2.encoding = this._encoding, t2 = new $(o2), o2.outlineWidthMode !== Q.None && (o2.isOutline = true, r2 = new $(o2));
      } else if (n2.shader === "VRM/UnlitTexture") {
        const r3 = yield this._extractMaterialProperties(e2, n2, i2);
        r3.renderType = J.Opaque, t2 = new K(r3);
      } else if (n2.shader === "VRM/UnlitCutout") {
        const r3 = yield this._extractMaterialProperties(e2, n2, i2);
        r3.renderType = J.Cutout, t2 = new K(r3);
      } else if (n2.shader === "VRM/UnlitTransparent") {
        const r3 = yield this._extractMaterialProperties(e2, n2, i2);
        r3.renderType = J.Transparent, t2 = new K(r3);
      } else if (n2.shader === "VRM/UnlitTransparentZWrite") {
        const r3 = yield this._extractMaterialProperties(e2, n2, i2);
        r3.renderType = J.TransparentWithZWrite, t2 = new K(r3);
      } else
        n2.shader !== "VRM_USE_GLTFSHADER" && console.warn(`Unknown shader detected: "${n2.shader}"`), t2 = this._convertGLTFMaterial(e2.clone());
      return t2.name = e2.name, t2.userData = JSON.parse(JSON.stringify(e2.userData)), t2.userData.vrmMaterialProperties = n2, r2 && (r2.name = e2.name + " (Outline)", r2.userData = JSON.parse(JSON.stringify(e2.userData)), r2.userData.vrmMaterialProperties = n2), { surface: t2, outline: r2 };
    });
  }
  _renameMaterialProperty(e2) {
    return e2[0] !== "_" ? (console.warn(`VRMMaterials: Given property name "${e2}" might be invalid`), e2) : (e2 = e2.substring(1), /[A-Z]/.test(e2[0]) ? e2[0].toLowerCase() + e2.substring(1) : (console.warn(`VRMMaterials: Given property name "${e2}" might be invalid`), e2));
  }
  _convertGLTFMaterial(t2) {
    if (t2.isMeshStandardMaterial) {
      const n2 = t2;
      n2.map && (n2.map.encoding = this._encoding), n2.emissiveMap && (n2.emissiveMap.encoding = this._encoding), this._encoding === LinearEncoding && (n2.color.convertLinearToSRGB(), n2.emissive.convertLinearToSRGB());
    }
    if (t2.isMeshBasicMaterial) {
      const n2 = t2;
      n2.map && (n2.map.encoding = this._encoding), this._encoding === LinearEncoding && n2.color.convertLinearToSRGB();
    }
    return t2;
  }
  _extractMaterialProperties(t2, n2, i2) {
    const r2 = [], o2 = {};
    if (n2.textureProperties)
      for (const e2 of Object.keys(n2.textureProperties)) {
        const t3 = this._renameMaterialProperty(e2), s2 = n2.textureProperties[e2];
        r2.push(i2.parser.getDependency("texture", s2).then((e3) => {
          o2[t3] = e3;
        }));
      }
    if (n2.floatProperties)
      for (const e2 of Object.keys(n2.floatProperties)) {
        const t3 = this._renameMaterialProperty(e2);
        o2[t3] = n2.floatProperties[e2];
      }
    if (n2.vectorProperties)
      for (const t3 of Object.keys(n2.vectorProperties)) {
        let i3 = this._renameMaterialProperty(t3);
        ["_MainTex", "_ShadeTexture", "_BumpMap", "_ReceiveShadowTexture", "_ShadingGradeTexture", "_RimTexture", "_SphereAdd", "_EmissionMap", "_OutlineWidthTexture", "_UvAnimMaskTexture"].some((e2) => t3 === e2) && (i3 += "_ST"), o2[i3] = new Vector4(...n2.vectorProperties[t3]);
      }
    return parseInt(REVISION, 10) < 129 && (o2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (o2.morphTargets = t2.morphTargets || false, o2.morphNormals = t2.morphNormals || false), Promise.all(r2).then(() => o2);
  }
};
var te = class {
  constructor(e2) {
    var t2;
    this.ignoreTexture = (t2 = e2 == null ? void 0 : e2.ignoreTexture) !== null && t2 !== void 0 && t2;
  }
  import(e2) {
    var n2;
    return t(this, void 0, void 0, function* () {
      const t2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
      if (!t2)
        return null;
      const i2 = t2.meta;
      if (!i2)
        return null;
      let r2;
      return this.ignoreTexture || i2.texture == null || i2.texture === -1 || (r2 = yield e2.parser.getDependency("texture", i2.texture)), { allowedUserName: i2.allowedUserName, author: i2.author, commercialUssageName: i2.commercialUssageName, contactInformation: i2.contactInformation, licenseName: i2.licenseName, otherLicenseUrl: i2.otherLicenseUrl, otherPermissionUrl: i2.otherPermissionUrl, reference: i2.reference, sexualUssageName: i2.sexualUssageName, texture: r2 != null ? r2 : void 0, title: i2.title, version: i2.version, violentUssageName: i2.violentUssageName };
    });
  }
};
var ne = new Matrix4();
function ie(e2) {
  return e2.invert ? e2.invert() : e2.getInverse(ne.copy(e2)), e2;
}
var re = class {
  constructor(t2) {
    this._inverseCache = new Matrix4(), this._shouldUpdateInverse = true, this.matrix = t2;
    const n2 = { set: (e2, t3, n3) => (this._shouldUpdateInverse = true, e2[t3] = n3, true) };
    this._originalElements = t2.elements, t2.elements = new Proxy(t2.elements, n2);
  }
  get inverse() {
    return this._shouldUpdateInverse && (ie(this._inverseCache.copy(this.matrix)), this._shouldUpdateInverse = false), this._inverseCache;
  }
  revert() {
    this.matrix.elements = this._originalElements;
  }
};
var oe = Object.freeze(new Matrix4());
var se = Object.freeze(new Quaternion());
var ae = new Vector3();
var le = new Vector3();
var de = new Vector3();
var he = new Quaternion();
var ue = new Matrix4();
var ce = new Matrix4();
var pe = class {
  constructor(t2, n2 = {}) {
    var i2, r2, o2, s2, a6, l3;
    if (this._currentTail = new Vector3(), this._prevTail = new Vector3(), this._nextTail = new Vector3(), this._boneAxis = new Vector3(), this._centerSpacePosition = new Vector3(), this._center = null, this._parentWorldRotation = new Quaternion(), this._initialLocalMatrix = new Matrix4(), this._initialLocalRotation = new Quaternion(), this._initialLocalChildPosition = new Vector3(), this.bone = t2, this.bone.matrixAutoUpdate = false, this.radius = (i2 = n2.radius) !== null && i2 !== void 0 ? i2 : 0.02, this.stiffnessForce = (r2 = n2.stiffnessForce) !== null && r2 !== void 0 ? r2 : 1, this.gravityDir = n2.gravityDir ? new Vector3().copy(n2.gravityDir) : new Vector3().set(0, -1, 0), this.gravityPower = (o2 = n2.gravityPower) !== null && o2 !== void 0 ? o2 : 0, this.dragForce = (s2 = n2.dragForce) !== null && s2 !== void 0 ? s2 : 0.4, this.colliders = (a6 = n2.colliders) !== null && a6 !== void 0 ? a6 : [], this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this._initialLocalMatrix.copy(this.bone.matrix), this._initialLocalRotation.copy(this.bone.quaternion), this.bone.children.length === 0)
      this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);
    else {
      const e2 = this.bone.children[0];
      this._initialLocalChildPosition.copy(e2.position);
    }
    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail), this._boneAxis.copy(this._initialLocalChildPosition).normalize(), this._centerSpaceBoneLength = ae.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length(), this.center = (l3 = n2.center) !== null && l3 !== void 0 ? l3 : null;
  }
  get center() {
    return this._center;
  }
  set center(e2) {
    var t2;
    this._getMatrixCenterToWorld(ue), this._currentTail.applyMatrix4(ue), this._prevTail.applyMatrix4(ue), this._nextTail.applyMatrix4(ue), ((t2 = this._center) === null || t2 === void 0 ? void 0 : t2.userData.inverseCacheProxy) && (this._center.userData.inverseCacheProxy.revert(), delete this._center.userData.inverseCacheProxy), this._center = e2, this._center && (this._center.userData.inverseCacheProxy || (this._center.userData.inverseCacheProxy = new re(this._center.matrixWorld))), this._getMatrixWorldToCenter(ue), this._currentTail.applyMatrix4(ue), this._prevTail.applyMatrix4(ue), this._nextTail.applyMatrix4(ue), ue.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(ue), this._centerSpaceBoneLength = ae.copy(this._initialLocalChildPosition).applyMatrix4(ue).sub(this._centerSpacePosition).length();
  }
  reset() {
    this.bone.quaternion.copy(this._initialLocalRotation), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail);
  }
  update(e2) {
    if (e2 <= 0)
      return;
    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this.bone.parent ? g(this.bone.parent, this._parentWorldRotation) : this._parentWorldRotation.copy(se), this._getMatrixWorldToCenter(ue), ue.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(ue), this._getMatrixWorldToCenter(ce), ce.multiply(this._getParentMatrixWorld());
    const t2 = this.stiffnessForce * e2, n2 = le.copy(this.gravityDir).multiplyScalar(this.gravityPower * e2);
    this._nextTail.copy(this._currentTail).add(ae.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.dragForce)).add(ae.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(ce).sub(this._centerSpacePosition).normalize().multiplyScalar(t2)).add(n2), this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition), this._collision(this._nextTail), this._prevTail.copy(this._currentTail), this._currentTail.copy(this._nextTail);
    const i2 = ie(ue.copy(ce.multiply(this._initialLocalMatrix))), r2 = he.setFromUnitVectors(this._boneAxis, ae.copy(this._nextTail).applyMatrix4(i2).normalize());
    this.bone.quaternion.copy(this._initialLocalRotation).multiply(r2), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);
  }
  _collision(e2) {
    this.colliders.forEach((t2) => {
      this._getMatrixWorldToCenter(ue), ue.multiply(t2.matrixWorld);
      const n2 = ae.setFromMatrixPosition(ue), i2 = t2.geometry.boundingSphere.radius, r2 = this.radius + i2;
      if (e2.distanceToSquared(n2) <= r2 * r2) {
        const t3 = le.subVectors(e2, n2).normalize(), i3 = de.addVectors(n2, t3.multiplyScalar(r2));
        e2.copy(i3.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition));
      }
    });
  }
  _getMatrixCenterToWorld(e2) {
    return this._center ? e2.copy(this._center.matrixWorld) : e2.identity(), e2;
  }
  _getMatrixWorldToCenter(e2) {
    return this._center ? e2.copy(this._center.userData.inverseCacheProxy.inverse) : e2.identity(), e2;
  }
  _getParentMatrixWorld() {
    return this.bone.parent ? this.bone.parent.matrixWorld : oe;
  }
};
var me = class {
  constructor(e2, t2) {
    this.colliderGroups = [], this.springBoneGroupList = [], this.colliderGroups = e2, this.springBoneGroupList = t2;
  }
  setCenter(e2) {
    this.springBoneGroupList.forEach((t2) => {
      t2.forEach((t3) => {
        t3.center = e2;
      });
    });
  }
  lateUpdate(e2) {
    this.springBoneGroupList.forEach((t2) => {
      t2.forEach((t3) => {
        t3.update(e2);
      });
    });
  }
  reset() {
    this.springBoneGroupList.forEach((e2) => {
      e2.forEach((e3) => {
        e3.reset();
      });
    });
  }
};
var fe = new Vector3();
var ge = new MeshBasicMaterial({ visible: false });
var _e = class {
  import(e2) {
    var n2;
    return t(this, void 0, void 0, function* () {
      const t2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
      if (!t2)
        return null;
      const i2 = t2.secondaryAnimation;
      if (!i2)
        return null;
      const r2 = yield this._importColliderMeshGroups(e2, i2), o2 = yield this._importSpringBoneGroupList(e2, i2, r2);
      return new me(r2, o2);
    });
  }
  _createSpringBone(e2, t2 = {}) {
    return new pe(e2, t2);
  }
  _importSpringBoneGroupList(n2, i2, r2) {
    return t(this, void 0, void 0, function* () {
      const o2 = i2.boneGroups || [], s2 = [];
      return yield Promise.all(o2.map((i3) => t(this, void 0, void 0, function* () {
        if (i3.stiffiness === void 0 || i3.gravityDir === void 0 || i3.gravityDir.x === void 0 || i3.gravityDir.y === void 0 || i3.gravityDir.z === void 0 || i3.gravityPower === void 0 || i3.dragForce === void 0 || i3.hitRadius === void 0 || i3.colliderGroups === void 0 || i3.bones === void 0 || i3.center === void 0)
          return;
        const o3 = i3.stiffiness, a6 = new Vector3(i3.gravityDir.x, i3.gravityDir.y, -i3.gravityDir.z), l3 = i3.gravityPower, d2 = i3.dragForce, h2 = i3.hitRadius, u2 = [];
        i3.colliderGroups.forEach((e2) => {
          u2.push(...r2[e2].colliders);
        });
        const c2 = [];
        yield Promise.all(i3.bones.map((e2) => t(this, void 0, void 0, function* () {
          const t2 = yield n2.parser.getDependency("node", e2), r3 = i3.center !== -1 ? yield n2.parser.getDependency("node", i3.center) : null;
          t2 && t2.traverse((e3) => {
            const t3 = this._createSpringBone(e3, { radius: h2, stiffnessForce: o3, gravityDir: a6, gravityPower: l3, dragForce: d2, colliders: u2, center: r3 });
            c2.push(t3);
          });
        }))), s2.push(c2);
      }))), s2;
    });
  }
  _importColliderMeshGroups(e2, n2) {
    return t(this, void 0, void 0, function* () {
      const i2 = n2.colliderGroups;
      if (i2 === void 0)
        return [];
      const r2 = [];
      return i2.forEach((n3) => t(this, void 0, void 0, function* () {
        if (n3.node === void 0 || n3.colliders === void 0)
          return;
        const t2 = yield e2.parser.getDependency("node", n3.node), i3 = [];
        n3.colliders.forEach((e3) => {
          if (e3.offset === void 0 || e3.offset.x === void 0 || e3.offset.y === void 0 || e3.offset.z === void 0 || e3.radius === void 0)
            return;
          const n4 = fe.set(e3.offset.x, e3.offset.y, -e3.offset.z), r3 = this._createColliderMesh(e3.radius, n4);
          t2.add(r3), i3.push(r3);
        });
        const o2 = { node: n3.node, colliders: i3 };
        r2.push(o2);
      })), r2;
    });
  }
  _createColliderMesh(t2, n2) {
    const i2 = new Mesh(new SphereGeometry(t2, 8, 4), ge);
    return i2.position.copy(n2), i2.name = "vrmColliderSphere", i2.geometry.computeBoundingSphere(), i2;
  }
};
var ve = class {
  constructor(e2 = {}) {
    this._metaImporter = e2.metaImporter || new te(), this._blendShapeImporter = e2.blendShapeImporter || new v(), this._lookAtImporter = e2.lookAtImporter || new W(), this._humanoidImporter = e2.humanoidImporter || new C(), this._firstPersonImporter = e2.firstPersonImporter || new E(), this._materialImporter = e2.materialImporter || new ee(), this._springBoneImporter = e2.springBoneImporter || new _e();
  }
  import(e2) {
    return t(this, void 0, void 0, function* () {
      if (e2.parser.json.extensions === void 0 || e2.parser.json.extensions.VRM === void 0)
        throw new Error("Could not find VRM extension on the GLTF");
      const t2 = e2.scene;
      t2.updateMatrixWorld(false), t2.traverse((e3) => {
        e3.isMesh && (e3.frustumCulled = false);
      });
      const n2 = (yield this._metaImporter.import(e2)) || void 0, i2 = (yield this._materialImporter.convertGLTFMaterials(e2)) || void 0, r2 = (yield this._humanoidImporter.import(e2)) || void 0, o2 = r2 && (yield this._firstPersonImporter.import(e2, r2)) || void 0, s2 = (yield this._blendShapeImporter.import(e2)) || void 0, a6 = o2 && s2 && r2 && (yield this._lookAtImporter.import(e2, o2, s2, r2)) || void 0, l3 = (yield this._springBoneImporter.import(e2)) || void 0;
      return new ye({ scene: e2.scene, meta: n2, materials: i2, humanoid: r2, firstPerson: o2, blendShapeProxy: s2, lookAt: a6, springBoneManager: l3 });
    });
  }
};
var ye = class {
  constructor(e2) {
    this.scene = e2.scene, this.humanoid = e2.humanoid, this.blendShapeProxy = e2.blendShapeProxy, this.firstPerson = e2.firstPerson, this.lookAt = e2.lookAt, this.materials = e2.materials, this.springBoneManager = e2.springBoneManager, this.meta = e2.meta;
  }
  static from(e2, n2 = {}) {
    return t(this, void 0, void 0, function* () {
      const t2 = new ve(n2);
      return yield t2.import(e2);
    });
  }
  update(e2) {
    this.lookAt && this.lookAt.update(e2), this.blendShapeProxy && this.blendShapeProxy.update(), this.springBoneManager && this.springBoneManager.lateUpdate(e2), this.materials && this.materials.forEach((t2) => {
      t2.updateVRMMaterials && t2.updateVRMMaterials(e2);
    });
  }
  dispose() {
    var e2, t2;
    const n2 = this.scene;
    n2 && n2.traverse(i), (t2 = (e2 = this.meta) === null || e2 === void 0 ? void 0 : e2.texture) === null || t2 === void 0 || t2.dispose();
  }
};
var Te = new Vector2();
var xe = new OrthographicCamera(-1, 1, -1, 1, -1, 1);
var Se = new MeshBasicMaterial({ color: 16777215, side: DoubleSide });
var Me = new Mesh(new PlaneGeometry(2, 2), Se);
var Ee = new Scene();
Ee.add(Me);
var Le = class {
  constructor() {
  }
};
Le.extractThumbnailBlob = function(e2, t2, n2 = 512) {
  var i2;
  const r2 = (i2 = t2.meta) === null || i2 === void 0 ? void 0 : i2.texture;
  if (!r2)
    throw new Error("extractThumbnailBlob: This VRM does not have a thumbnail");
  const o2 = e2.getContext().canvas;
  e2.getSize(Te);
  const s2 = Te.x, a6 = Te.y;
  return e2.setSize(n2, n2, false), Se.map = r2, e2.render(Ee, xe), Se.map = null, o2 instanceof OffscreenCanvas ? o2.convertToBlob().finally(() => {
    e2.setSize(s2, a6, false);
  }) : new Promise((t3, n3) => {
    o2.toBlob((i3) => {
      e2.setSize(s2, a6, false), i3 == null ? n3("extractThumbnailBlob: Failed to create a blob") : t3(i3);
    });
  });
}, Le.removeUnnecessaryJoints = function(t2) {
  const n2 = new Map();
  t2.traverse((t3) => {
    if (t3.type !== "SkinnedMesh")
      return;
    const i2 = t3, r2 = i2.geometry.getAttribute("skinIndex");
    let o2 = n2.get(r2);
    if (!o2) {
      const t4 = [], s2 = [], a6 = {}, l3 = r2.array;
      for (let e2 = 0; e2 < l3.length; e2++) {
        const n3 = l3[e2];
        a6[n3] === void 0 && (a6[n3] = t4.length, t4.push(i2.skeleton.bones[n3]), s2.push(i2.skeleton.boneInverses[n3])), l3[e2] = a6[n3];
      }
      r2.copyArray(l3), r2.needsUpdate = true, o2 = new Skeleton(t4, s2), n2.set(r2, o2);
    }
    i2.bind(o2, new Matrix4());
  });
};
var we = new Vector3();
var Ae = new MeshBasicMaterial({ color: 16711935, wireframe: true, transparent: true, depthTest: false });
var Oe = new Vector3();

// node_modules/.pnpm/github.com+vladmandic+human@7b61812dffb578a4ae49ee260184e16a94f5e642/node_modules/@vladmandic/human/dist/human.esm.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require2 = /* @__PURE__ */ ((x2) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a6, b2) => (typeof __require !== "undefined" ? __require : a6)[b2]
}) : x2)(function(x2) {
  if (typeof __require !== "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __export = (target, all6) => {
  __markAsModule(target);
  for (var name in all6)
    __defProp(target, name, { get: all6[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
function join(folder, file) {
  const separator = folder.endsWith("/") ? "" : "/";
  const skipJoin = file.startsWith(".") || file.startsWith("/") || file.startsWith("http:") || file.startsWith("https:") || file.startsWith("file:");
  const path = skipJoin ? `${file}` : `${folder}${separator}${file}`;
  if (!path.toLocaleLowerCase().includes(".json"))
    throw new Error(`modelpath error: ${path} expecting json file`);
  return path;
}
function log(...msg) {
  const dt = new Date();
  const ts = `${dt.getHours().toString().padStart(2, "0")}:${dt.getMinutes().toString().padStart(2, "0")}:${dt.getSeconds().toString().padStart(2, "0")}.${dt.getMilliseconds().toString().padStart(3, "0")}`;
  if (msg)
    console.log(ts, "Human:", ...msg);
}
var now2 = () => {
  if (typeof performance !== "undefined")
    return performance.now();
  return parseInt((Number(process.hrtime.bigint()) / 1e3 / 1e3).toString());
};
function validate(defaults, config3, parent = "config", msgs = []) {
  for (const key of Object.keys(config3)) {
    if (typeof config3[key] === "object") {
      validate(defaults[key], config3[key], key, msgs);
    } else {
      const defined = defaults && typeof defaults[key] !== "undefined";
      if (!defined)
        msgs.push({ reason: "unknown property", where: `${parent}.${key} = ${config3[key]}` });
      const same = defaults && typeof defaults[key] === typeof config3[key];
      if (defined && !same)
        msgs.push({ reason: "property type mismatch", where: `${parent}.${key} = ${config3[key]}`, expected: typeof defaults[key] });
    }
  }
  if (config3.debug && parent === "config" && msgs.length > 0)
    log("invalid configuration", msgs);
  return msgs;
}
function mergeDeep(...objects) {
  const isObject = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj || {}).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal))
        prev[key] = pVal.concat(...oVal);
      else if (isObject(pVal) && isObject(oVal))
        prev[key] = mergeDeep(pVal, oVal);
      else
        prev[key] = oVal;
    });
    return prev;
  }, {});
}
var config = {
  backend: "",
  modelBasePath: "",
  wasmPath: "",
  debug: true,
  async: true,
  warmup: "full",
  cacheSensitivity: 0.75,
  skipFrame: false,
  filter: {
    enabled: true,
    width: 0,
    height: 0,
    flip: false,
    return: true,
    brightness: 0,
    contrast: 0,
    sharpness: 0,
    blur: 0,
    saturation: 0,
    hue: 0,
    negative: false,
    sepia: false,
    vintage: false,
    kodachrome: false,
    technicolor: false,
    polaroid: false,
    pixelate: 0
  },
  gesture: {
    enabled: true
  },
  face: {
    enabled: true,
    detector: {
      modelPath: "blazeface.json",
      rotation: true,
      maxDetected: 1,
      skipFrames: 11,
      minConfidence: 0.2,
      iouThreshold: 0.1,
      return: false
    },
    mesh: {
      enabled: true,
      modelPath: "facemesh.json"
    },
    iris: {
      enabled: true,
      modelPath: "iris.json"
    },
    emotion: {
      enabled: true,
      minConfidence: 0.1,
      skipFrames: 12,
      modelPath: "emotion.json"
    },
    description: {
      enabled: true,
      modelPath: "faceres.json",
      skipFrames: 13,
      minConfidence: 0.1
    }
  },
  body: {
    enabled: true,
    modelPath: "movenet-lightning.json",
    detector: {
      modelPath: ""
    },
    maxDetected: -1,
    minConfidence: 0.2,
    skipFrames: 1
  },
  hand: {
    enabled: true,
    rotation: true,
    skipFrames: 2,
    minConfidence: 0.5,
    iouThreshold: 0.2,
    maxDetected: -1,
    landmarks: true,
    detector: {
      modelPath: "handtrack.json"
    },
    skeleton: {
      modelPath: "handskeleton.json"
    }
  },
  object: {
    enabled: false,
    modelPath: "mb3-centernet.json",
    minConfidence: 0.2,
    iouThreshold: 0.4,
    maxDetected: 10,
    skipFrames: 15
  },
  segmentation: {
    enabled: false,
    modelPath: "selfie.json",
    blur: 8
  }
};
var tfjs_esm_exports = {};
__export(tfjs_esm_exports, {
  Abs: () => Abs,
  Acos: () => Acos,
  Acosh: () => Acosh,
  AdadeltaOptimizer: () => AdadeltaOptimizer,
  AdagradOptimizer: () => AdagradOptimizer,
  AdamOptimizer: () => AdamOptimizer,
  AdamaxOptimizer: () => AdamaxOptimizer,
  Add: () => Add,
  AddN: () => AddN,
  All: () => All,
  Any: () => Any,
  ArgMax: () => ArgMax,
  ArgMin: () => ArgMin,
  Asin: () => Asin,
  Asinh: () => Asinh,
  Atan: () => Atan,
  Atan2: () => Atan2,
  Atanh: () => Atanh,
  AvgPool: () => AvgPool,
  AvgPool3D: () => AvgPool3D,
  AvgPool3DGrad: () => AvgPool3DGrad,
  AvgPoolGrad: () => AvgPoolGrad,
  BackendWasm: () => BackendWasm,
  BatchMatMul: () => BatchMatMul,
  BatchToSpaceND: () => BatchToSpaceND,
  Bincount: () => Bincount,
  BroadcastArgs: () => BroadcastArgs,
  BroadcastTo: () => BroadcastTo,
  Callback: () => Callback,
  CallbackList: () => CallbackList,
  Cast: () => Cast,
  Ceil: () => Ceil,
  ClipByValue: () => ClipByValue,
  Complex: () => Complex,
  ComplexAbs: () => ComplexAbs,
  Concat: () => Concat,
  Conv2D: () => Conv2D,
  Conv2DBackpropFilter: () => Conv2DBackpropFilter,
  Conv2DBackpropInput: () => Conv2DBackpropInput,
  Conv3D: () => Conv3D,
  Conv3DBackpropFilterV2: () => Conv3DBackpropFilterV2,
  Conv3DBackpropInputV2: () => Conv3DBackpropInputV2,
  Cos: () => Cos,
  Cosh: () => Cosh,
  CropAndResize: () => CropAndResize,
  Cumsum: () => Cumsum,
  CustomCallback: () => CustomCallback,
  DataStorage: () => DataStorage,
  DenseBincount: () => DenseBincount,
  DepthToSpace: () => DepthToSpace,
  DepthwiseConv2dNative: () => DepthwiseConv2dNative,
  DepthwiseConv2dNativeBackpropFilter: () => DepthwiseConv2dNativeBackpropFilter,
  DepthwiseConv2dNativeBackpropInput: () => DepthwiseConv2dNativeBackpropInput,
  Diag: () => Diag,
  Dilation2D: () => Dilation2D,
  Dilation2DBackpropFilter: () => Dilation2DBackpropFilter,
  Dilation2DBackpropInput: () => Dilation2DBackpropInput,
  ENV: () => ENV,
  EarlyStopping: () => EarlyStopping,
  Einsum: () => Einsum,
  Elu: () => Elu,
  EluGrad: () => EluGrad,
  Environment: () => Environment,
  Equal: () => Equal,
  Erf: () => Erf,
  Exp: () => Exp,
  ExpandDims: () => ExpandDims,
  Expm1: () => Expm1,
  FFT: () => FFT,
  Fill: () => Fill,
  FlipLeftRight: () => FlipLeftRight,
  Floor: () => Floor,
  FloorDiv: () => FloorDiv,
  FromPixels: () => FromPixels,
  FusedBatchNorm: () => FusedBatchNorm,
  FusedConv2D: () => FusedConv2D,
  FusedDepthwiseConv2D: () => FusedDepthwiseConv2D,
  GPGPUContext: () => GPGPUContext,
  GatherNd: () => GatherNd,
  GatherV2: () => GatherV2,
  GraphModel: () => GraphModel,
  Greater: () => Greater,
  GreaterEqual: () => GreaterEqual,
  History: () => History,
  IFFT: () => IFFT,
  Identity: () => Identity,
  Imag: () => Imag,
  InputSpec: () => InputSpec,
  IsFinite: () => IsFinite,
  IsInf: () => IsInf,
  IsNan: () => IsNan,
  KernelBackend: () => KernelBackend,
  LRN: () => LRN,
  LRNGrad: () => LRNGrad,
  LayerVariable: () => LayerVariable,
  LayersModel: () => LayersModel,
  LeakyRelu: () => LeakyRelu,
  Less: () => Less,
  LessEqual: () => LessEqual,
  LinSpace: () => LinSpace,
  Log: () => Log,
  Log1p: () => Log1p,
  LogSoftmax: () => LogSoftmax,
  LogicalAnd: () => LogicalAnd,
  LogicalNot: () => LogicalNot,
  LogicalOr: () => LogicalOr,
  MathBackendWebGL: () => MathBackendWebGL,
  Max: () => Max,
  MaxPool: () => MaxPool,
  MaxPool3D: () => MaxPool3D,
  MaxPool3DGrad: () => MaxPool3DGrad,
  MaxPoolGrad: () => MaxPoolGrad,
  MaxPoolWithArgmax: () => MaxPoolWithArgmax,
  Maximum: () => Maximum,
  Mean: () => Mean,
  Min: () => Min,
  Minimum: () => Minimum,
  MirrorPad: () => MirrorPad,
  Mod: () => Mod,
  MomentumOptimizer: () => MomentumOptimizer,
  Multinomial: () => Multinomial,
  Multiply: () => Multiply,
  Neg: () => Neg,
  NonMaxSuppressionV3: () => NonMaxSuppressionV3,
  NonMaxSuppressionV4: () => NonMaxSuppressionV4,
  NonMaxSuppressionV5: () => NonMaxSuppressionV5,
  NotEqual: () => NotEqual,
  OP_SCOPE_SUFFIX: () => OP_SCOPE_SUFFIX,
  OneHot: () => OneHot,
  OnesLike: () => OnesLike,
  Optimizer: () => Optimizer,
  Pack: () => Pack,
  PadV2: () => PadV2,
  Pool: () => Pool,
  Pow: () => Pow,
  Prelu: () => Prelu,
  Prod: () => Prod,
  RMSPropOptimizer: () => RMSPropOptimizer,
  RNN: () => RNN,
  Range: () => Range,
  Rank: () => Rank,
  Real: () => Real,
  RealDiv: () => RealDiv,
  Reciprocal: () => Reciprocal,
  Reduction: () => Reduction,
  Relu: () => Relu,
  Relu6: () => Relu6,
  Reshape: () => Reshape,
  ResizeBilinear: () => ResizeBilinear,
  ResizeBilinearGrad: () => ResizeBilinearGrad,
  ResizeNearestNeighbor: () => ResizeNearestNeighbor,
  ResizeNearestNeighborGrad: () => ResizeNearestNeighborGrad,
  Reverse: () => Reverse,
  RotateWithOffset: () => RotateWithOffset,
  Round: () => Round,
  Rsqrt: () => Rsqrt,
  SGDOptimizer: () => SGDOptimizer,
  ScatterNd: () => ScatterNd,
  Select: () => Select,
  Selu: () => Selu,
  Sequential: () => Sequential,
  Sigmoid: () => Sigmoid,
  Sign: () => Sign,
  Sin: () => Sin,
  Sinh: () => Sinh,
  Slice: () => Slice,
  Softmax: () => Softmax,
  Softplus: () => Softplus,
  SpaceToBatchND: () => SpaceToBatchND,
  SparseFillEmptyRows: () => SparseFillEmptyRows,
  SparseReshape: () => SparseReshape,
  SparseSegmentMean: () => SparseSegmentMean,
  SparseSegmentSum: () => SparseSegmentSum,
  SparseToDense: () => SparseToDense,
  SplitV: () => SplitV,
  Sqrt: () => Sqrt,
  Square: () => Square,
  SquaredDifference: () => SquaredDifference,
  Step: () => Step,
  StridedSlice: () => StridedSlice,
  StringNGrams: () => StringNGrams,
  StringSplit: () => StringSplit,
  StringToHashBucketFast: () => StringToHashBucketFast,
  Sub: () => Sub,
  Sum: () => Sum,
  SymbolicTensor: () => SymbolicTensor,
  Tan: () => Tan,
  Tanh: () => Tanh,
  Tensor: () => Tensor,
  TensorBuffer: () => TensorBuffer,
  Tile: () => Tile,
  TopK: () => TopK,
  Transform: () => Transform,
  Transpose: () => Transpose,
  Unique: () => Unique,
  Unpack: () => Unpack,
  UnsortedSegmentSum: () => UnsortedSegmentSum,
  Variable: () => Variable,
  ZerosLike: () => ZerosLike,
  _FusedMatMul: () => _FusedMatMul,
  abs: () => abs,
  acos: () => acos,
  acosh: () => acosh,
  add: () => add2,
  addN: () => addN,
  all: () => all,
  any: () => any,
  argMax: () => argMax,
  argMin: () => argMin,
  asin: () => asin,
  asinh: () => asinh,
  atan: () => atan,
  atan2: () => atan2,
  atanh: () => atanh,
  avgPool: () => avgPool,
  avgPool3d: () => avgPool3d,
  backend: () => backend,
  backend_util: () => backend_util_exports,
  basicLSTMCell: () => basicLSTMCell,
  batchNorm: () => batchNorm,
  batchNorm2d: () => batchNorm2d,
  batchNorm3d: () => batchNorm3d,
  batchNorm4d: () => batchNorm4d,
  batchToSpaceND: () => batchToSpaceND,
  bincount: () => bincount,
  booleanMaskAsync: () => booleanMaskAsync,
  broadcastArgs: () => broadcastArgs,
  broadcastTo: () => broadcastTo,
  browser: () => browser_exports,
  buffer: () => buffer,
  callbacks: () => callbacks,
  cast: () => cast,
  ceil: () => ceil,
  clipByValue: () => clipByValue,
  clone: () => clone,
  complex: () => complex,
  concat: () => concat,
  concat1d: () => concat1d,
  concat2d: () => concat2d,
  concat3d: () => concat3d,
  concat4d: () => concat4d,
  constraints: () => exports_constraints_exports,
  conv1d: () => conv1d,
  conv2d: () => conv2d,
  conv2dTranspose: () => conv2dTranspose,
  conv3d: () => conv3d,
  conv3dTranspose: () => conv3dTranspose,
  copyRegisteredKernels: () => copyRegisteredKernels,
  cos: () => cos,
  cosh: () => cosh,
  cosineWindow: () => cosineWindow,
  cumsum: () => cumsum,
  customGrad: () => customGrad,
  data: () => dist_exports,
  denseBincount: () => denseBincount,
  deprecationWarn: () => deprecationWarn,
  depthToSpace: () => depthToSpace,
  depthwiseConv2d: () => depthwiseConv2d,
  deregisterOp: () => deregisterOp,
  device_util: () => device_util_exports,
  diag: () => diag,
  dilation2d: () => dilation2d,
  disableDeprecationWarnings: () => disableDeprecationWarnings,
  dispose: () => dispose,
  disposeVariables: () => disposeVariables,
  div: () => div,
  divNoNan: () => divNoNan,
  dot: () => dot,
  dropout: () => dropout,
  einsum: () => einsum,
  elu: () => elu,
  enableDebugMode: () => enableDebugMode,
  enableProdMode: () => enableProdMode,
  enclosingPowerOfTwo: () => enclosingPowerOfTwo,
  engine: () => engine,
  env: () => env,
  equal: () => equal,
  erf: () => erf,
  exp: () => exp,
  expandDims: () => expandDims,
  expm1: () => expm1,
  eye: () => eye,
  fft: () => fft,
  fill: () => fill,
  findBackend: () => findBackend,
  findBackendFactory: () => findBackendFactory,
  floor: () => floor,
  floorDiv: () => floorDiv,
  forceHalfFloat: () => forceHalfFloat,
  fused: () => fused_ops_exports,
  gather: () => gather,
  gatherND: () => gatherND,
  gather_util: () => gather_nd_util_exports,
  getBackend: () => getBackend,
  getGradient: () => getGradient,
  getKernel: () => getKernel,
  getKernelsForBackend: () => getKernelsForBackend,
  gpgpu_util: () => gpgpu_util_exports,
  grad: () => grad,
  grads: () => grads,
  greater: () => greater,
  greaterEqual: () => greaterEqual,
  ifft: () => ifft,
  imag: () => imag,
  image: () => image,
  inTopKAsync: () => inTopKAsync,
  initializers: () => exports_initializers_exports,
  input: () => input,
  io: () => io_exports,
  irfft: () => irfft,
  isFinite: () => isFinite2,
  isInf: () => isInf,
  isNaN: () => isNaN2,
  keep: () => keep,
  kernel_impls: () => kernel_impls_exports,
  layers: () => exports_layers_exports,
  leakyRelu: () => leakyRelu,
  less: () => less,
  lessEqual: () => lessEqual,
  linalg: () => linalg,
  linspace: () => linspace,
  loadGraphModel: () => loadGraphModel,
  loadLayersModel: () => loadLayersModel,
  localResponseNormalization: () => localResponseNormalization,
  log: () => log5,
  log1p: () => log1p,
  logSigmoid: () => logSigmoid,
  logSoftmax: () => logSoftmax,
  logSumExp: () => logSumExp,
  logicalAnd: () => logicalAnd,
  logicalNot: () => logicalNot,
  logicalOr: () => logicalOr,
  logicalXor: () => logicalXor,
  losses: () => losses,
  matMul: () => matMul,
  math: () => math_exports,
  max: () => max,
  maxPool: () => maxPool,
  maxPool3d: () => maxPool3d,
  maxPoolWithArgmax: () => maxPoolWithArgmax,
  maximum: () => maximum,
  mean: () => mean,
  memory: () => memory,
  meshgrid: () => meshgrid,
  metrics: () => exports_metrics_exports,
  min: () => min,
  minimum: () => minimum,
  mirrorPad: () => mirrorPad,
  mod: () => mod,
  model: () => model,
  models: () => exports_models_exports,
  moments: () => moments,
  movingAverage: () => movingAverage,
  mul: () => mul,
  multiRNNCell: () => multiRNNCell,
  multinomial: () => multinomial,
  neg: () => neg,
  nextFrame: () => nextFrame,
  norm: () => norm,
  notEqual: () => notEqual,
  oneHot: () => oneHot,
  ones: () => ones2,
  onesLike: () => onesLike,
  op: () => op,
  outerProduct: () => outerProduct,
  pad: () => pad,
  pad1d: () => pad1d,
  pad2d: () => pad2d,
  pad3d: () => pad3d,
  pad4d: () => pad4d,
  pool: () => pool,
  pow: () => pow,
  prelu: () => prelu,
  print: () => print2,
  prod: () => prod,
  profile: () => profile,
  rand: () => rand,
  randomGamma: () => randomGamma,
  randomNormal: () => randomNormal,
  randomUniform: () => randomUniform,
  range: () => range,
  ready: () => ready,
  real: () => real,
  reciprocal: () => reciprocal,
  registerBackend: () => registerBackend,
  registerCallbackConstructor: () => registerCallbackConstructor,
  registerGradient: () => registerGradient,
  registerKernel: () => registerKernel,
  registerOp: () => registerOp,
  regularizers: () => exports_regularizers_exports,
  relu: () => relu,
  relu6: () => relu6,
  removeBackend: () => removeBackend,
  reshape: () => reshape,
  reverse: () => reverse,
  reverse1d: () => reverse1d,
  reverse2d: () => reverse2d,
  reverse3d: () => reverse3d,
  reverse4d: () => reverse4d,
  rfft: () => rfft,
  round: () => round2,
  rsqrt: () => rsqrt,
  scalar: () => scalar,
  scatterND: () => scatterND,
  scatter_util: () => scatter_nd_util_exports,
  selu: () => selu,
  separableConv2d: () => separableConv2d,
  sequential: () => sequential,
  serialization: () => serialization_exports,
  setBackend: () => setBackend,
  setPlatform: () => setPlatform,
  setWasmPath: () => setWasmPath,
  setWasmPaths: () => setWasmPaths,
  setWebGLContext: () => setWebGLContext,
  setdiff1dAsync: () => setdiff1dAsync,
  sigmoid: () => sigmoid,
  sign: () => sign2,
  signal: () => signal,
  sin: () => sin,
  sinh: () => sinh,
  slice: () => slice,
  slice1d: () => slice1d,
  slice2d: () => slice2d,
  slice3d: () => slice3d,
  slice4d: () => slice4d,
  slice_util: () => slice_util_exports,
  softmax: () => softmax,
  softplus: () => softplus,
  spaceToBatchND: () => spaceToBatchND,
  sparse: () => sparse,
  sparseToDense: () => sparseToDense,
  spectral: () => spectral,
  split: () => split,
  sqrt: () => sqrt,
  square: () => square,
  squaredDifference: () => squaredDifference,
  squeeze: () => squeeze,
  stack: () => stack,
  step: () => step,
  stridedSlice: () => stridedSlice,
  string: () => string,
  sub: () => sub,
  sum: () => sum2,
  sumOutType: () => sumOutType,
  tan: () => tan,
  tanh: () => tanh2,
  tensor: () => tensor,
  tensor1d: () => tensor1d,
  tensor2d: () => tensor2d,
  tensor3d: () => tensor3d,
  tensor4d: () => tensor4d,
  tensor5d: () => tensor5d,
  tensor6d: () => tensor6d,
  tensor_util: () => tensor_util_exports,
  test_util: () => test_util_exports,
  tidy: () => tidy,
  tile: () => tile,
  time: () => time,
  topk: () => topk,
  train: () => train,
  transpose: () => transpose,
  truncatedNormal: () => truncatedNormal,
  unique: () => unique,
  unregisterGradient: () => unregisterGradient,
  unregisterKernel: () => unregisterKernel,
  unsortedSegmentSum: () => unsortedSegmentSum,
  unstack: () => unstack,
  upcastType: () => upcastType,
  util: () => util_exports,
  valueAndGrad: () => valueAndGrad,
  valueAndGrads: () => valueAndGrads,
  variable: () => variable,
  variableGrads: () => variableGrads,
  version: () => version92,
  version_converter: () => version3,
  version_core: () => version,
  version_layers: () => version2,
  version_wasm: () => version8,
  version_webgl: () => version5,
  webgl: () => webgl,
  webgl_util: () => webgl_util_exports,
  webgpu: () => webgpu_exports,
  where: () => where,
  whereAsync: () => whereAsync,
  zeros: () => zeros,
  zerosLike: () => zerosLike
});
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
var __require22 = /* @__PURE__ */ ((x2) => typeof __require2 !== "undefined" ? __require2 : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a6, b2) => (typeof __require2 !== "undefined" ? __require2 : a6)[b2]
}) : x2)(function(x2) {
  if (typeof __require2 !== "undefined")
    return __require2.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS = (cb, mod4) => function __require222() {
  return mod4 || (0, cb[Object.keys(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export2 = (target, all52) => {
  __markAsModule2(target);
  for (var name in all52)
    __defProp2(target, name, { get: all52[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp2(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule2(__defProp2(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_long = __commonJS({
  "node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(exports, module) {
    module.exports = Long2;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e2) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache5;
      if (unsigned) {
        value >>>= 0;
        if (cache5 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache5)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache5 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache5)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long2.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p22;
      if ((p22 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p22 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i2 = 0; i2 < str.length; i2 += 8) {
        var size2 = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size2), radix);
        if (size2 < 8) {
          var power = fromNumber(pow_dbl(radix, size2));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long2.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long2.UZERO = UZERO;
    var ONE = fromInt(1);
    Long2.ONE = ONE;
    var UONE = fromInt(1, true);
    Long2.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long2.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long2.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div3 = this.div(radixLong), rem1 = div3.mul(radixLong).sub(this);
          return div3.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven2() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals2(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add5(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply4(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res2;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res2 = approx.add(rem.div(divisor));
              return res2;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res2 = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res2 = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res2 = res2.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res2;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le2) {
      return le2 ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.fromBytes = function fromBytes(bytes, unsigned, le2) {
      return le2 ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
  }
});
var require_browser = __commonJS({
  "(disabled):node_modules/.pnpm/node-fetch@2.6.5/node_modules/node-fetch/browser.js"() {
  }
});
var require_alea = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me2 = this, mash = Mash();
        me2.next = function() {
          var t2 = 2091639 * me2.s0 + me2.c * 23283064365386963e-26;
          me2.s0 = me2.s1;
          me2.s1 = me2.s2;
          return me2.s2 = t2 - (me2.c = t2 | 0);
        };
        me2.c = 1;
        me2.s0 = mash(" ");
        me2.s1 = mash(" ");
        me2.s2 = mash(" ");
        me2.s0 -= mash(seed);
        if (me2.s0 < 0) {
          me2.s0 += 1;
        }
        me2.s1 -= mash(seed);
        if (me2.s1 < 0) {
          me2.s1 += 1;
        }
        me2.s2 -= mash(seed);
        if (me2.s2 < 0) {
          me2.s2 += 1;
        }
        mash = null;
      }
      function copy2(f2, t2) {
        t2.c = f2.c;
        t2.s0 = f2.s0;
        t2.s1 = f2.s1;
        t2.s2 = f2.s2;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n2 = 4022871197;
        var mash = function(data) {
          data = data.toString();
          for (var i2 = 0; i2 < data.length; i2++) {
            n2 += data.charCodeAt(i2);
            var h2 = 0.02519603282416938 * n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            h2 *= n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            n2 += h2 * 4294967296;
          }
          return (n2 >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xor128 = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.next = function() {
          var t2 = me2.x ^ me2.x << 11;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          return me2.w ^= me2.w >>> 19 ^ t2 ^ t2 >>> 8;
        };
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me2.x ^= strseed.charCodeAt(k3) | 0;
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xorwow = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var t2 = me2.x ^ me2.x >>> 2;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          me2.w = me2.v;
          return (me2.d = me2.d + 362437 | 0) + (me2.v = me2.v ^ me2.v << 4 ^ (t2 ^ t2 << 1)) | 0;
        };
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.v = 0;
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me2.x ^= strseed.charCodeAt(k3) | 0;
          if (k3 == strseed.length) {
            me2.d = me2.x << 10 ^ me2.x >>> 4;
          }
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        t2.v = f2.v;
        t2.d = f2.d;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xorshift7 = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var X2 = me2.x, i2 = me2.i, t2, v2, w2;
          t2 = X2[i2];
          t2 ^= t2 >>> 7;
          v2 = t2 ^ t2 << 24;
          t2 = X2[i2 + 1 & 7];
          v2 ^= t2 ^ t2 >>> 10;
          t2 = X2[i2 + 3 & 7];
          v2 ^= t2 ^ t2 >>> 3;
          t2 = X2[i2 + 4 & 7];
          v2 ^= t2 ^ t2 << 7;
          t2 = X2[i2 + 7 & 7];
          t2 = t2 ^ t2 << 13;
          v2 ^= t2 ^ t2 << 9;
          X2[i2] = v2;
          me2.i = i2 + 1 & 7;
          return v2;
        };
        function init2(me22, seed2) {
          var j2, w2, X2 = [];
          if (seed2 === (seed2 | 0)) {
            w2 = X2[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X2[j2 & 7] = X2[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X2[j2 + 1 & 7] << 13;
            }
          }
          while (X2.length < 8)
            X2.push(0);
          for (j2 = 0; j2 < 8 && X2[j2] === 0; ++j2)
            ;
          if (j2 == 8)
            w2 = X2[7] = -1;
          else
            w2 = X2[j2];
          me22.x = X2;
          me22.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me22.next();
          }
        }
        init2(me2, seed);
      }
      function copy2(f2, t2) {
        t2.x = f2.x.slice();
        t2.i = f2.i;
        return t2;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xor4096 = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var w2 = me2.w, X2 = me2.X, i2 = me2.i, t2, v2;
          me2.w = w2 = w2 + 1640531527 | 0;
          v2 = X2[i2 + 34 & 127];
          t2 = X2[i2 = i2 + 1 & 127];
          v2 ^= v2 << 13;
          t2 ^= t2 << 17;
          v2 ^= v2 >>> 15;
          t2 ^= t2 >>> 12;
          v2 = X2[i2] = v2 ^ t2;
          me2.i = i2;
          return v2 + (w2 ^ w2 >>> 16) | 0;
        };
        function init2(me22, seed2) {
          var t2, v2, i2, j2, w2, X2 = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v2 = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v2 = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i2 = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2)
              v2 ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0)
              w2 = v2;
            v2 ^= v2 << 10;
            v2 ^= v2 >>> 15;
            v2 ^= v2 << 4;
            v2 ^= v2 >>> 13;
            if (j2 >= 0) {
              w2 = w2 + 1640531527 | 0;
              t2 = X2[j2 & 127] ^= v2 + w2;
              i2 = t2 == 0 ? i2 + 1 : 0;
            }
          }
          if (i2 >= 128) {
            X2[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i2 = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v2 = X2[i2 + 34 & 127];
            t2 = X2[i2 = i2 + 1 & 127];
            v2 ^= v2 << 13;
            t2 ^= t2 << 17;
            v2 ^= v2 >>> 15;
            t2 ^= t2 >>> 12;
            X2[i2] = v2 ^ t2;
          }
          me22.w = w2;
          me22.X = X2;
          me22.i = i2;
        }
        init2(me2, seed);
      }
      function copy2(f2, t2) {
        t2.i = f2.i;
        t2.w = f2.w;
        t2.X = f2.X.slice();
        return t2;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_tychei = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var b2 = me2.b, c2 = me2.c, d2 = me2.d, a6 = me2.a;
          b2 = b2 << 25 ^ b2 >>> 7 ^ c2;
          c2 = c2 - d2 | 0;
          d2 = d2 << 24 ^ d2 >>> 8 ^ a6;
          a6 = a6 - b2 | 0;
          me2.b = b2 = b2 << 20 ^ b2 >>> 12 ^ c2;
          me2.c = c2 = c2 - d2 | 0;
          me2.d = d2 << 16 ^ c2 >>> 16 ^ a6;
          return me2.a = a6 - b2 | 0;
        };
        me2.a = 0;
        me2.b = 0;
        me2.c = 2654435769 | 0;
        me2.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me2.a = seed / 4294967296 | 0;
          me2.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 20; k3++) {
          me2.b ^= strseed.charCodeAt(k3) | 0;
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.a = f2.a;
        t2.b = f2.b;
        t2.c = f2.c;
        t2.d = f2.d;
        return t2;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});
var require_seedrandom = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(pool3, math) {
      var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom5(seed, options3, callback) {
        var key = [];
        options3 = options3 == true ? { entropy: true } : options3 || {};
        var shortseed = mixkey(flatten4(options3.entropy ? [seed, tostring(pool3)] : seed == null ? autoseed() : seed, 3), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
          while (n2 < significance) {
            n2 = (n2 + x2) * width;
            d2 *= width;
            x2 = arc4.g(1);
          }
          while (n2 >= overflow) {
            n2 /= 2;
            d2 /= 2;
            x2 >>>= 1;
          }
          return (n2 + x2) / d2;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool3);
        return (options3.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy2(state, arc4);
            }
            prng2.state = function() {
              return copy2(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(prng, shortseed, "global" in options3 ? options3.global : this == math, options3.state);
      }
      math["seed" + rngname] = seedrandom5;
      function ARC4(key) {
        var t2, keylen = key.length, me2 = this, i2 = 0, j2 = me2.i = me2.j = 0, s2 = me2.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i2 < width) {
          s2[i2] = i2++;
        }
        for (i2 = 0; i2 < width; i2++) {
          s2[i2] = s2[j2 = mask & j2 + key[i2 % keylen] + (t2 = s2[i2])];
          s2[j2] = t2;
        }
        (me2.g = function(count22) {
          var t22, r2 = 0, i22 = me2.i, j22 = me2.j, s22 = me2.S;
          while (count22--) {
            t22 = s22[i22 = mask & i22 + 1];
            r2 = r2 * width + s22[mask & (s22[i22] = s22[j22 = mask & j22 + t22]) + (s22[j22] = t22)];
          }
          me2.i = i22;
          me2.j = j22;
          return r2;
        })(width);
      }
      function copy2(f2, t2) {
        t2.i = f2.i;
        t2.j = f2.j;
        t2.S = f2.S.slice();
        return t2;
      }
      ;
      function flatten4(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten4(obj[prop], depth - 1));
            } catch (e2) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e2) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool3)];
        }
      }
      function tostring(a6) {
        return String.fromCharCode.apply(0, a6);
      }
      mixkey(math.random(), pool3);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom5;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom5;
        });
      }
    })([], Math);
  }
});
var require_seedrandom2 = __commonJS({
  "node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/index.js"(exports, module) {
    var alea5 = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea5;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});
var require_alea2 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me2 = this, mash = Mash();
        me2.next = function() {
          var t2 = 2091639 * me2.s0 + me2.c * 23283064365386963e-26;
          me2.s0 = me2.s1;
          me2.s1 = me2.s2;
          return me2.s2 = t2 - (me2.c = t2 | 0);
        };
        me2.c = 1;
        me2.s0 = mash(" ");
        me2.s1 = mash(" ");
        me2.s2 = mash(" ");
        me2.s0 -= mash(seed);
        if (me2.s0 < 0) {
          me2.s0 += 1;
        }
        me2.s1 -= mash(seed);
        if (me2.s1 < 0) {
          me2.s1 += 1;
        }
        me2.s2 -= mash(seed);
        if (me2.s2 < 0) {
          me2.s2 += 1;
        }
        mash = null;
      }
      function copy2(f2, t2) {
        t2.c = f2.c;
        t2.s0 = f2.s0;
        t2.s1 = f2.s1;
        t2.s2 = f2.s2;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n2 = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i2 = 0; i2 < data.length; i2++) {
            n2 += data.charCodeAt(i2);
            var h2 = 0.02519603282416938 * n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            h2 *= n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            n2 += h2 * 4294967296;
          }
          return (n2 >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xor1282 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.next = function() {
          var t2 = me2.x ^ me2.x << 11;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          return me2.w ^= me2.w >>> 19 ^ t2 ^ t2 >>> 8;
        };
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me2.x ^= strseed.charCodeAt(k3) | 0;
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xorwow2 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var t2 = me2.x ^ me2.x >>> 2;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          me2.w = me2.v;
          return (me2.d = me2.d + 362437 | 0) + (me2.v = me2.v ^ me2.v << 4 ^ (t2 ^ t2 << 1)) | 0;
        };
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.v = 0;
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me2.x ^= strseed.charCodeAt(k3) | 0;
          if (k3 == strseed.length) {
            me2.d = me2.x << 10 ^ me2.x >>> 4;
          }
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        t2.v = f2.v;
        t2.d = f2.d;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xorshift72 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var X2 = me2.x, i2 = me2.i, t2, v2, w2;
          t2 = X2[i2];
          t2 ^= t2 >>> 7;
          v2 = t2 ^ t2 << 24;
          t2 = X2[i2 + 1 & 7];
          v2 ^= t2 ^ t2 >>> 10;
          t2 = X2[i2 + 3 & 7];
          v2 ^= t2 ^ t2 >>> 3;
          t2 = X2[i2 + 4 & 7];
          v2 ^= t2 ^ t2 << 7;
          t2 = X2[i2 + 7 & 7];
          t2 = t2 ^ t2 << 13;
          v2 ^= t2 ^ t2 << 9;
          X2[i2] = v2;
          me2.i = i2 + 1 & 7;
          return v2;
        };
        function init2(me22, seed2) {
          var j2, w2, X2 = [];
          if (seed2 === (seed2 | 0)) {
            w2 = X2[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X2[j2 & 7] = X2[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X2[j2 + 1 & 7] << 13;
            }
          }
          while (X2.length < 8)
            X2.push(0);
          for (j2 = 0; j2 < 8 && X2[j2] === 0; ++j2)
            ;
          if (j2 == 8)
            w2 = X2[7] = -1;
          else
            w2 = X2[j2];
          me22.x = X2;
          me22.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me22.next();
          }
        }
        init2(me2, seed);
      }
      function copy2(f2, t2) {
        t2.x = f2.x.slice();
        t2.i = f2.i;
        return t2;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_xor40962 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var w2 = me2.w, X2 = me2.X, i2 = me2.i, t2, v2;
          me2.w = w2 = w2 + 1640531527 | 0;
          v2 = X2[i2 + 34 & 127];
          t2 = X2[i2 = i2 + 1 & 127];
          v2 ^= v2 << 13;
          t2 ^= t2 << 17;
          v2 ^= v2 >>> 15;
          t2 ^= t2 >>> 12;
          v2 = X2[i2] = v2 ^ t2;
          me2.i = i2;
          return v2 + (w2 ^ w2 >>> 16) | 0;
        };
        function init2(me22, seed2) {
          var t2, v2, i2, j2, w2, X2 = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v2 = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v2 = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i2 = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2)
              v2 ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0)
              w2 = v2;
            v2 ^= v2 << 10;
            v2 ^= v2 >>> 15;
            v2 ^= v2 << 4;
            v2 ^= v2 >>> 13;
            if (j2 >= 0) {
              w2 = w2 + 1640531527 | 0;
              t2 = X2[j2 & 127] ^= v2 + w2;
              i2 = t2 == 0 ? i2 + 1 : 0;
            }
          }
          if (i2 >= 128) {
            X2[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i2 = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v2 = X2[i2 + 34 & 127];
            t2 = X2[i2 = i2 + 1 & 127];
            v2 ^= v2 << 13;
            t2 ^= t2 << 17;
            v2 ^= v2 >>> 15;
            t2 ^= t2 >>> 12;
            X2[i2] = v2 ^ t2;
          }
          me22.w = w2;
          me22.X = X2;
          me22.i = i2;
        }
        init2(me2, seed);
      }
      function copy2(f2, t2) {
        t2.i = f2.i;
        t2.w = f2.w;
        t2.X = f2.X.slice();
        return t2;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_tychei2 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var b2 = me2.b, c2 = me2.c, d2 = me2.d, a6 = me2.a;
          b2 = b2 << 25 ^ b2 >>> 7 ^ c2;
          c2 = c2 - d2 | 0;
          d2 = d2 << 24 ^ d2 >>> 8 ^ a6;
          a6 = a6 - b2 | 0;
          me2.b = b2 = b2 << 20 ^ b2 >>> 12 ^ c2;
          me2.c = c2 = c2 - d2 | 0;
          me2.d = d2 << 16 ^ c2 >>> 16 ^ a6;
          return me2.a = a6 - b2 | 0;
        };
        me2.a = 0;
        me2.b = 0;
        me2.c = 2654435769 | 0;
        me2.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me2.a = seed / 4294967296 | 0;
          me2.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 20; k3++) {
          me2.b ^= strseed.charCodeAt(k3) | 0;
          me2.next();
        }
      }
      function copy2(f2, t2) {
        t2.a = f2.a;
        t2.b = f2.b;
        t2.c = f2.c;
        t2.d = f2.d;
        return t2;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy2(state, xg);
          prng.state = function() {
            return copy2(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});
var require_seedrandom3 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(global2, pool3, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom5(seed, options3, callback) {
        var key = [];
        options3 = options3 == true ? { entropy: true } : options3 || {};
        var shortseed = mixkey(flatten4(options3.entropy ? [seed, tostring(pool3)] : seed == null ? autoseed() : seed, 3), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
          while (n2 < significance) {
            n2 = (n2 + x2) * width;
            d2 *= width;
            x2 = arc4.g(1);
          }
          while (n2 >= overflow) {
            n2 /= 2;
            d2 /= 2;
            x2 >>>= 1;
          }
          return (n2 + x2) / d2;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool3);
        return (options3.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy2(state, arc4);
            }
            prng2.state = function() {
              return copy2(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(prng, shortseed, "global" in options3 ? options3.global : this == math, options3.state);
      }
      function ARC4(key) {
        var t2, keylen = key.length, me2 = this, i2 = 0, j2 = me2.i = me2.j = 0, s2 = me2.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i2 < width) {
          s2[i2] = i2++;
        }
        for (i2 = 0; i2 < width; i2++) {
          s2[i2] = s2[j2 = mask & j2 + key[i2 % keylen] + (t2 = s2[i2])];
          s2[j2] = t2;
        }
        (me2.g = function(count22) {
          var t22, r2 = 0, i22 = me2.i, j22 = me2.j, s22 = me2.S;
          while (count22--) {
            t22 = s22[i22 = mask & i22 + 1];
            r2 = r2 * width + s22[mask & (s22[i22] = s22[j22 = mask & j22 + t22]) + (s22[j22] = t22)];
          }
          me2.i = i22;
          me2.j = j22;
          return r2;
        })(width);
      }
      function copy2(f2, t2) {
        t2.i = f2.i;
        t2.j = f2.j;
        t2.S = f2.S.slice();
        return t2;
      }
      ;
      function flatten4(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten4(obj[prop], depth - 1));
            } catch (e2) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e2) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool3)];
        }
      }
      function tostring(a6) {
        return String.fromCharCode.apply(0, a6);
      }
      mixkey(math.random(), pool3);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom5;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom5;
        });
      } else {
        math["seed" + rngname] = seedrandom5;
      }
    })(typeof self !== "undefined" ? self : exports, [], Math);
  }
});
var require_seedrandom4 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(exports, module) {
    var alea5 = require_alea2();
    var xor128 = require_xor1282();
    var xorwow = require_xorwow2();
    var xorshift7 = require_xorshift72();
    var xor4096 = require_xor40962();
    var tychei = require_tychei2();
    var sr = require_seedrandom3();
    sr.alea = alea5;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});
var require_string_decoder = __commonJS({
  "(disabled):node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js"() {
  }
});
var require_path = __commonJS({
  "(disabled):path"() {
  }
});
var require_worker_threads = __commonJS({
  "(disabled):worker_threads"() {
  }
});
var require_perf_hooks = __commonJS({
  "(disabled):perf_hooks"() {
  }
});
var require_tfjs_backend_wasm_threaded_simd = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.9.0_@tensorflow+tfjs-core@3.9.0/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(exports, module) {
    var WasmBackendModuleThreadedSimd = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WasmBackendModuleThreadedSimd2) {
        WasmBackendModuleThreadedSimd2 = WasmBackendModuleThreadedSimd2 || {};
        function GROWABLE_HEAP_I8() {
          if (wasmMemory.buffer != buffer2) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP8;
        }
        function GROWABLE_HEAP_U8() {
          if (wasmMemory.buffer != buffer2) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU8;
        }
        function GROWABLE_HEAP_I32() {
          if (wasmMemory.buffer != buffer2) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP32;
        }
        function GROWABLE_HEAP_U32() {
          if (wasmMemory.buffer != buffer2) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU32;
        }
        function GROWABLE_HEAP_F64() {
          if (wasmMemory.buffer != buffer2) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF64;
        }
        var Module = typeof WasmBackendModuleThreadedSimd2 !== "undefined" ? WasmBackendModuleThreadedSimd2 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = false;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
        if (ENVIRONMENT_IS_PTHREAD) {
          buffer2 = Module["buffer"];
        }
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = require_path().dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require22("fs");
            if (!nodePath)
              nodePath = require_path();
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert3(ret.buffer);
            return ret;
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status) {
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
          var nodeWorkerThreads;
          try {
            nodeWorkerThreads = require_worker_threads();
          } catch (e2) {
            console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
            throw e2;
          }
          global.Worker = nodeWorkerThreads.Worker;
        } else if (ENVIRONMENT_IS_SHELL) {
          if (typeof read != "undefined") {
            read_ = function shell_read(f2) {
              return read(f2);
            };
          }
          readBinary = function readBinary2(f2) {
            var data;
            if (typeof readbuffer === "function") {
              return new Uint8Array(readbuffer(f2));
            }
            data = read(f2, "binary");
            assert3(typeof data === "object");
            return data;
          };
          if (typeof scriptArgs != "undefined") {
            arguments_ = scriptArgs;
          } else if (typeof arguments != "undefined") {
            arguments_ = arguments;
          }
          if (typeof quit === "function") {
            quit_ = function(status) {
              quit(status);
            };
          }
          if (typeof print !== "undefined") {
            if (typeof console === "undefined")
              console = {};
            console.log = print;
            console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
          }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (typeof _scriptDir !== "undefined" && _scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          if (ENVIRONMENT_IS_NODE) {
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require22("fs");
              if (!nodePath)
                nodePath = require_path();
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert3(ret.buffer);
              return ret;
            };
          } else {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
          setWindowTitle = function(title) {
            document.title = title;
          };
        } else {
        }
        if (ENVIRONMENT_IS_NODE) {
          if (typeof performance === "undefined") {
            global.performance = require_perf_hooks().performance;
          }
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var Atomics_load = Atomics.load;
        var Atomics_store = Atomics.store;
        var Atomics_compareExchange = Atomics.compareExchange;
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var wasmModule;
        var ABORT = false;
        var EXITSTATUS;
        function assert3(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        function getCFunc(ident) {
          var func2 = Module["_" + ident];
          assert3(func2, "Cannot call unknown function " + ident + ", make sure it is exported");
          return func2;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
          var toC = { "string": function(str) {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              var len = (str.length << 2) + 1;
              ret2 = stackAlloc(len);
              stringToUTF8(str, ret2, len);
            }
            return ret2;
          }, "array": function(arr) {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          } };
          function convertReturnValue(ret2) {
            if (returnType === "string")
              return UTF8ToString(ret2);
            if (returnType === "boolean")
              return Boolean(ret2);
            return ret2;
          }
          var func2 = getCFunc(ident);
          var cArgs = [];
          var stack2 = 0;
          if (args) {
            for (var i2 = 0; i2 < args.length; i2++) {
              var converter = toC[argTypes[i2]];
              if (converter) {
                if (stack2 === 0)
                  stack2 = stackSave();
                cArgs[i2] = converter(args[i2]);
              } else {
                cArgs[i2] = args[i2];
              }
            }
          }
          var ret = func2.apply(null, cArgs);
          ret = convertReturnValue(ret);
          if (stack2 !== 0)
            stackRestore(stack2);
          return ret;
        }
        function cwrap(ident, returnType, argTypes, opts) {
          argTypes = argTypes || [];
          var numericArgs = argTypes.every(function(type) {
            return type === "number";
          });
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs && !opts) {
            return getCFunc(ident);
          }
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        }
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var str = "";
          while (!(idx >= endIdx)) {
            var u0 = heap[idx++];
            if (!u0)
              return str;
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heap[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heap[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var u2 = str.charCodeAt(i2);
            if (u2 >= 55296 && u2 <= 57343) {
              var u1 = str.charCodeAt(++i2);
              u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
            }
            if (u2 <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++] = u2;
            } else if (u2 <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++] = 192 | u2 >> 6;
              heap[outIdx++] = 128 | u2 & 63;
            } else if (u2 <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++] = 224 | u2 >> 12;
              heap[outIdx++] = 128 | u2 >> 6 & 63;
              heap[outIdx++] = 128 | u2 & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++] = 240 | u2 >> 18;
              heap[outIdx++] = 128 | u2 >> 12 & 63;
              heap[outIdx++] = 128 | u2 >> 6 & 63;
              heap[outIdx++] = 128 | u2 & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var u2 = str.charCodeAt(i2);
            if (u2 >= 55296 && u2 <= 57343)
              u2 = 65536 + ((u2 & 1023) << 10) | str.charCodeAt(++i2) & 1023;
            if (u2 <= 127)
              ++len;
            else if (u2 <= 2047)
              len += 2;
            else if (u2 <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        function writeArrayToMemory(array2, buffer3) {
          GROWABLE_HEAP_I8().set(array2, buffer3);
        }
        function alignUp(x2, multiple) {
          if (x2 % multiple > 0) {
            x2 += multiple - x2 % multiple;
          }
          return x2;
        }
        var buffer2, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer2 = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (ENVIRONMENT_IS_PTHREAD) {
          wasmMemory = Module["wasmMemory"];
          buffer2 = Module["buffer"];
        } else {
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 2147483648 / 65536, "shared": true });
            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
              err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
              if (ENVIRONMENT_IS_NODE) {
                console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
              }
              throw Error("bad memory");
            }
          }
        }
        if (wasmMemory) {
          buffer2 = wasmMemory.buffer;
        }
        INITIAL_MEMORY = buffer2.byteLength;
        updateGlobalBufferAndViews(buffer2);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        if (!ENVIRONMENT_IS_PTHREAD)
          __ATINIT__.push({ func: function() {
            ___wasm_call_ctors();
          } });
        function preRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          callRuntimeCallbacks(__ATMAIN__);
        }
        function exitRuntime() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          runtimeExited = true;
        }
        function postRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
          assert3(!ENVIRONMENT_IS_PTHREAD, "addRunDependency cannot be used in a pthread worker");
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          if (ENVIRONMENT_IS_PTHREAD)
            console.error("Pthread aborting at " + new Error().stack);
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e2 = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e2);
          throw e2;
        }
        function hasPrefix(str, prefix) {
          return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return hasPrefix(filename, dataURIPrefix);
        }
        var fileURIPrefix = "file://";
        function isFileURI(filename) {
          return hasPrefix(filename, fileURIPrefix);
        }
        var wasmBinaryFile = "tfjs-backend-wasm-threaded-simd.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmTable = Module["asm"]["F"];
            wasmModule = module2;
            if (!ENVIRONMENT_IS_PTHREAD) {
              var numWorkersToLoad = PThread.unusedWorkers.length;
              PThread.unusedWorkers.forEach(function(w2) {
                PThread.loadWasmModuleToWorker(w2, function() {
                  if (!--numWorkersToLoad)
                    removeRunDependency("wasm-instantiate");
                });
              });
            }
          }
          if (!ENVIRONMENT_IS_PTHREAD) {
            addRunDependency("wasm-instantiate");
          }
          function receiveInstantiatedSource(output) {
            receiveInstance(output["instance"], output["module"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              return WebAssembly.instantiate(binary, info);
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiatedSource, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiatedSource);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiatedSource);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e2) {
              err("Module.instantiateWasm callback failed with error: " + e2);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        var ASM_CONSTS = { 10024: function() {
          throw "Canceled!";
        }, 10042: function($0, $1) {
          setTimeout(function() {
            __emscripten_do_dispatch_to_thread($0, $1);
          }, 0);
        } };
        function initPthreadsJS() {
          PThread.initRuntime();
        }
        function callRuntimeCallbacks(callbacks2) {
          while (callbacks2.length > 0) {
            var callback = callbacks2.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func2 = callback.func;
            if (typeof func2 === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func2)();
              } else {
                wasmTable.get(func2)(callback.arg);
              }
            } else {
              func2(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function _emscripten_futex_wake(addr, count22) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count22 < 0)
            return -28;
          if (count22 == 0)
            return 0;
          if (count22 >= 2147483647)
            count22 = Infinity;
          var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2);
          var mainThreadWoken = 0;
          if (mainThreadWaitAddress == addr) {
            var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, mainThreadWaitAddress, 0);
            if (loadedAddr == mainThreadWaitAddress) {
              --count22;
              mainThreadWoken = 1;
              if (count22 <= 0)
                return 1;
            }
          }
          var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count22);
          if (ret >= 0)
            return ret + mainThreadWoken;
          throw "Atomics.notify returned an unexpected value " + ret;
        }
        Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
        function killThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! killThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in killThread!";
          GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.terminate();
          PThread.freeThreadData(pthread);
          PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
          pthread.worker.pthread = void 0;
        }
        function cancelThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cancelThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cancelThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.postMessage({ "cmd": "cancel" });
        }
        function cleanupThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cleanupThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          if (pthread) {
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
            var worker = pthread.worker;
            PThread.returnWorkerToPool(worker);
          }
        }
        var PThread = { unusedWorkers: [], runningWorkers: [], initMainThreadBlock: function() {
          var pthreadPoolSize = Math.min(4, Math.max(1, (navigator.hardwareConcurrency || 1) / 2));
          for (var i2 = 0; i2 < pthreadPoolSize; ++i2) {
            PThread.allocateUnusedWorker();
          }
        }, initRuntime: function() {
          var tb = _malloc(228);
          for (var i2 = 0; i2 < 228 / 4; ++i2)
            GROWABLE_HEAP_U32()[tb / 4 + i2] = 0;
          GROWABLE_HEAP_I32()[tb + 12 >> 2] = tb;
          var headPtr = tb + 152;
          GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
          var tlsMemory = _malloc(512);
          for (var i2 = 0; i2 < 128; ++i2)
            GROWABLE_HEAP_U32()[tlsMemory / 4 + i2] = 0;
          Atomics.store(GROWABLE_HEAP_U32(), tb + 100 >> 2, tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 40 >> 2, tb);
          __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1);
          _emscripten_register_main_browser_thread_id(tb);
        }, initWorker: function() {
        }, pthreads: {}, threadExitHandlers: [], setThreadStatus: function() {
        }, runExitHandlers: function() {
          while (PThread.threadExitHandlers.length > 0) {
            PThread.threadExitHandlers.pop()();
          }
          if (ENVIRONMENT_IS_PTHREAD && _pthread_self())
            ___pthread_tsd_run_dtors();
        }, runExitHandlersAndDeinitThread: function(tb, exitCode) {
          Atomics.store(GROWABLE_HEAP_U32(), tb + 56 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 0);
          PThread.runExitHandlers();
          Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
          _emscripten_futex_wake(tb + 0, 2147483647);
          __emscripten_thread_init(0, 0, 0);
        }, threadExit: function(exitCode) {
          var tb = _pthread_self();
          if (tb) {
            PThread.runExitHandlersAndDeinitThread(tb, exitCode);
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exit" });
            }
          }
        }, threadCancel: function() {
          PThread.runExitHandlersAndDeinitThread(_pthread_self(), -1);
          postMessage({ "cmd": "cancelDone" });
        }, terminateAllThreads: function() {
          for (var t2 in PThread.pthreads) {
            var pthread = PThread.pthreads[t2];
            if (pthread && pthread.worker) {
              PThread.returnWorkerToPool(pthread.worker);
            }
          }
          PThread.pthreads = {};
          for (var i2 = 0; i2 < PThread.unusedWorkers.length; ++i2) {
            var worker = PThread.unusedWorkers[i2];
            worker.terminate();
          }
          PThread.unusedWorkers = [];
          for (var i2 = 0; i2 < PThread.runningWorkers.length; ++i2) {
            var worker = PThread.runningWorkers[i2];
            var pthread = worker.pthread;
            PThread.freeThreadData(pthread);
            worker.terminate();
          }
          PThread.runningWorkers = [];
        }, freeThreadData: function(pthread) {
          if (!pthread)
            return;
          if (pthread.threadInfoStruct) {
            var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >> 2];
            GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >> 2] = 0;
            _free(tlsMemory);
            _free(pthread.threadInfoStruct);
          }
          pthread.threadInfoStruct = 0;
          if (pthread.allocatedOwnStack && pthread.stackBase)
            _free(pthread.stackBase);
          pthread.stackBase = 0;
          if (pthread.worker)
            pthread.worker.pthread = null;
        }, returnWorkerToPool: function(worker) {
          PThread.runWithoutMainThreadQueuedCalls(function() {
            delete PThread.pthreads[worker.pthread.threadInfoStruct];
            PThread.unusedWorkers.push(worker);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
            PThread.freeThreadData(worker.pthread);
            worker.pthread = void 0;
          });
        }, runWithoutMainThreadQueuedCalls: function(func2) {
          GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >> 2] = 0;
          try {
            func2();
          } finally {
            GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >> 2] = 1;
          }
        }, receiveObjectTransfer: function(data) {
        }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
          worker.onmessage = function(e2) {
            var d2 = e2["data"];
            var cmd = d2["cmd"];
            if (worker.pthread)
              PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
            if (d2["targetThread"] && d2["targetThread"] != _pthread_self()) {
              var thread = PThread.pthreads[d2.targetThread];
              if (thread) {
                thread.worker.postMessage(e2.data, d2["transferList"]);
              } else {
                console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d2["targetThread"] + ", but that thread no longer exists!");
              }
              PThread.currentProxiedOperationCallerThread = void 0;
              return;
            }
            if (cmd === "processQueuedMainThreadWork") {
              _emscripten_main_thread_process_queued_calls();
            } else if (cmd === "spawnThread") {
              spawnThread(e2.data);
            } else if (cmd === "cleanupThread") {
              cleanupThread(d2["thread"]);
            } else if (cmd === "killThread") {
              killThread(d2["thread"]);
            } else if (cmd === "cancelThread") {
              cancelThread(d2["thread"]);
            } else if (cmd === "loaded") {
              worker.loaded = true;
              if (onFinishedLoading)
                onFinishedLoading(worker);
              if (worker.runPthread) {
                worker.runPthread();
                delete worker.runPthread;
              }
            } else if (cmd === "print") {
              out("Thread " + d2["threadId"] + ": " + d2["text"]);
            } else if (cmd === "printErr") {
              err("Thread " + d2["threadId"] + ": " + d2["text"]);
            } else if (cmd === "alert") {
              alert("Thread " + d2["threadId"] + ": " + d2["text"]);
            } else if (cmd === "exit") {
              var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.threadInfoStruct + 64 >> 2);
              if (detached) {
                PThread.returnWorkerToPool(worker);
              }
            } else if (cmd === "exitProcess") {
              try {
                exit(d2["returnCode"]);
              } catch (e22) {
                if (e22 instanceof ExitStatus)
                  return;
                throw e22;
              }
            } else if (cmd === "cancelDone") {
              PThread.returnWorkerToPool(worker);
            } else if (cmd === "objectTransfer") {
              PThread.receiveObjectTransfer(e2.data);
            } else if (e2.data.target === "setimmediate") {
              worker.postMessage(e2.data);
            } else {
              err("worker sent an unknown command " + cmd);
            }
            PThread.currentProxiedOperationCallerThread = void 0;
          };
          worker.onerror = function(e2) {
            err("pthread sent an error! " + e2.filename + ":" + e2.lineno + ": " + e2.message);
          };
          if (ENVIRONMENT_IS_NODE) {
            worker.on("message", function(data) {
              worker.onmessage({ data });
            });
            worker.on("error", function(data) {
              worker.onerror(data);
            });
            worker.on("exit", function(data) {
            });
          }
          worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
        }, allocateUnusedWorker: function() {
          var pthreadMainJs = locateFile("tfjs-backend-wasm-threaded-simd.worker.js");
          PThread.unusedWorkers.push(new Worker(pthreadMainJs));
        }, getNewWorker: function() {
          if (PThread.unusedWorkers.length == 0) {
            PThread.allocateUnusedWorker();
            PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
          }
          if (PThread.unusedWorkers.length > 0)
            return PThread.unusedWorkers.pop();
          else
            return null;
        }, busySpinWait: function(msecs) {
          var t2 = performance.now() + msecs;
          while (performance.now() < t2) {
          }
        } };
        function establishStackSpace(stackTop, stackMax) {
          _emscripten_stack_set_limits(stackTop, stackMax);
          stackRestore(stackTop);
        }
        Module["establishStackSpace"] = establishStackSpace;
        function getNoExitRuntime() {
          return noExitRuntime;
        }
        Module["getNoExitRuntime"] = getNoExitRuntime;
        function invokeEntryPoint(ptr, arg) {
          return wasmTable.get(ptr)(arg);
        }
        Module["invokeEntryPoint"] = invokeEntryPoint;
        function ___assert_fail(condition, filename, line, func2) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
        }
        function ___call_main(argc, argv) {
          var returnCode = _main(argc, argv);
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = function() {
            var t2 = process["hrtime"]();
            return t2[0] * 1e3 + t2[1] / 1e6;
          };
        } else if (ENVIRONMENT_IS_PTHREAD) {
          _emscripten_get_now = function() {
            return performance.now() - Module["__performance_now_clock_drift"];
          };
        } else if (typeof dateNow !== "undefined") {
          _emscripten_get_now = dateNow;
        } else
          _emscripten_get_now = function() {
            return performance.now();
          };
        function setErrNo(value) {
          GROWABLE_HEAP_I32()[___errno_location() >> 2] = value;
          return value;
        }
        function _atexit(func2, arg) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(1, 1, func2, arg);
        }
        function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
          if (targetThreadId == mainThreadId) {
            postMessage({ "cmd": "processQueuedMainThreadWork" });
          } else if (ENVIRONMENT_IS_PTHREAD) {
            postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
          } else {
            var pthread = PThread.pthreads[targetThreadId];
            var worker = pthread && pthread.worker;
            if (!worker) {
              return;
            }
            worker.postMessage({ "cmd": "processThreadQueue" });
          }
          return 1;
        }
        function _abort() {
          abort();
        }
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          var args = readAsmConstArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args);
        }
        function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
        }
        function _emscripten_futex_wait(addr, val, timeout) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
            return -28;
          if (!ENVIRONMENT_IS_WEB) {
            var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
            if (ret === "timed-out")
              return -73;
            if (ret === "not-equal")
              return -6;
            if (ret === "ok")
              return 0;
            throw "Atomics.wait returned an unexpected value " + ret;
          } else {
            if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
              return -6;
            }
            var tNow = performance.now();
            var tEnd = tNow + timeout;
            var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            while (1) {
              tNow = performance.now();
              if (tNow > tEnd) {
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                return -73;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
              if (lastAddr == 0) {
                break;
              }
              _emscripten_main_thread_process_queued_calls();
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            }
            return 0;
          }
        }
        function _emscripten_memcpy_big(dest, src, num) {
          GROWABLE_HEAP_U8().copyWithin(dest, src, src + num);
        }
        function _emscripten_num_logical_cores() {
          if (ENVIRONMENT_IS_NODE)
            return __require22("os").cpus().length;
          return navigator["hardwareConcurrency"];
        }
        function _emscripten_proxy_to_main_thread_js(index, sync) {
          var numCallArgs = arguments.length - 2;
          var stack2 = stackSave();
          var serializedNumCallArgs = numCallArgs;
          var args = stackAlloc(serializedNumCallArgs * 8);
          var b2 = args >> 3;
          for (var i2 = 0; i2 < numCallArgs; i2++) {
            var arg = arguments[2 + i2];
            GROWABLE_HEAP_F64()[b2 + i2] = arg;
          }
          var ret = _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
          stackRestore(stack2);
          return ret;
        }
        var _emscripten_receive_on_main_thread_js_callArgs = [];
        var readAsmConstArgsArray = [];
        function readAsmConstArgs(sigPtr, buf) {
          readAsmConstArgsArray.length = 0;
          var ch;
          buf >>= 2;
          while (ch = GROWABLE_HEAP_U8()[sigPtr++]) {
            var double = ch < 105;
            if (double && buf & 1)
              buf++;
            readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >> 1] : GROWABLE_HEAP_I32()[buf]);
            ++buf;
          }
          return readAsmConstArgsArray;
        }
        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
          _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
          var b2 = args >> 3;
          for (var i2 = 0; i2 < numCallArgs; i2++) {
            _emscripten_receive_on_main_thread_js_callArgs[i2] = GROWABLE_HEAP_F64()[b2 + i2];
          }
          var isEmAsmConst = index < 0;
          var func2 = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
          return func2.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
        }
        function _emscripten_get_heap_size() {
          return GROWABLE_HEAP_U8().length;
        }
        function emscripten_realloc_buffer(size2) {
          try {
            wasmMemory.grow(size2 - buffer2.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e2) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = _emscripten_get_heap_size();
          if (requestedSize <= oldSize) {
            return false;
          }
          var maxHeapSize = 2147483648;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
          for (var i2 = JSEvents.eventHandlers.length - 1; i2 >= 0; --i2) {
            JSEvents._removeHandler(i2);
          }
          JSEvents.eventHandlers = [];
          JSEvents.deferredCalls = [];
        }, registerRemoveEventListeners: function() {
          if (!JSEvents.removeEventListenersRegistered) {
            __ATEXIT__.push(JSEvents.removeAllEventListeners);
            JSEvents.removeEventListenersRegistered = true;
          }
        }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
          function arraysHaveEqualContent(arrA, arrB) {
            if (arrA.length != arrB.length)
              return false;
            for (var i22 in arrA) {
              if (arrA[i22] != arrB[i22])
                return false;
            }
            return true;
          }
          for (var i2 in JSEvents.deferredCalls) {
            var call = JSEvents.deferredCalls[i2];
            if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
              return;
            }
          }
          JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
          JSEvents.deferredCalls.sort(function(x2, y2) {
            return x2.precedence < y2.precedence;
          });
        }, removeDeferredCalls: function(targetFunction) {
          for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
            if (JSEvents.deferredCalls[i2].targetFunction == targetFunction) {
              JSEvents.deferredCalls.splice(i2, 1);
              --i2;
            }
          }
        }, canPerformEventHandlerRequests: function() {
          return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
        }, runDeferredCalls: function() {
          if (!JSEvents.canPerformEventHandlerRequests()) {
            return;
          }
          for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
            var call = JSEvents.deferredCalls[i2];
            JSEvents.deferredCalls.splice(i2, 1);
            --i2;
            call.targetFunction.apply(null, call.argsList);
          }
        }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
          for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
            if (JSEvents.eventHandlers[i2].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i2].eventTypeString)) {
              JSEvents._removeHandler(i2--);
            }
          }
        }, _removeHandler: function(i2) {
          var h2 = JSEvents.eventHandlers[i2];
          h2.target.removeEventListener(h2.eventTypeString, h2.eventListenerFunc, h2.useCapture);
          JSEvents.eventHandlers.splice(i2, 1);
        }, registerOrRemoveHandler: function(eventHandler) {
          var jsEventHandler = function jsEventHandler2(event) {
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            JSEvents.runDeferredCalls();
            eventHandler.handlerFunc(event);
            JSEvents.runDeferredCalls();
            --JSEvents.inEventHandler;
          };
          if (eventHandler.callbackfunc) {
            eventHandler.eventListenerFunc = jsEventHandler;
            eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
            JSEvents.eventHandlers.push(eventHandler);
            JSEvents.registerRemoveEventListeners();
          } else {
            for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
              if (JSEvents.eventHandlers[i2].target == eventHandler.target && JSEvents.eventHandlers[i2].eventTypeString == eventHandler.eventTypeString) {
                JSEvents._removeHandler(i2--);
              }
            }
          }
        }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          GROWABLE_HEAP_I32()[varargs >> 2] = eventTypeId;
          GROWABLE_HEAP_I32()[varargs + 4 >> 2] = eventData;
          GROWABLE_HEAP_I32()[varargs + 8 >> 2] = userData;
          __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
          stackRestore(stackTop);
        }, getTargetThreadForEventCallback: function(targetThread) {
          switch (targetThread) {
            case 1:
              return 0;
            case 2:
              return PThread.currentProxiedOperationCallerThread;
            default:
              return targetThread;
          }
        }, getNodeNameForTarget: function(target) {
          if (!target)
            return "";
          if (target == window)
            return "#window";
          if (target == screen)
            return "#screen";
          return target && target.nodeName ? target.nodeName : "";
        }, fullscreenEnabled: function() {
          return document.fullscreenEnabled || document.webkitFullscreenEnabled;
        } };
        function stringToNewUTF8(jsString) {
          var length = lengthBytesUTF8(jsString) + 1;
          var cString = _malloc(length);
          stringToUTF8(jsString, cString, length);
          return cString;
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          var targetCanvasPtr = 0;
          if (targetCanvas) {
            targetCanvasPtr = stringToNewUTF8(targetCanvas);
          }
          GROWABLE_HEAP_I32()[varargs >> 2] = targetCanvasPtr;
          GROWABLE_HEAP_I32()[varargs + 4 >> 2] = width;
          GROWABLE_HEAP_I32()[varargs + 8 >> 2] = height;
          __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
          stackRestore(stackTop);
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
          targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
          _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
        }
        function maybeCStringToJsString(cString) {
          return cString > 2 ? UTF8ToString(cString) : cString;
        }
        var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
        function findEventTarget(target) {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        }
        function findCanvasEventTarget(target) {
          return findEventTarget(target);
        }
        function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
          var canvas3 = findCanvasEventTarget(target);
          if (!canvas3)
            return -4;
          if (canvas3.canvasSharedPtr) {
            GROWABLE_HEAP_I32()[canvas3.canvasSharedPtr >> 2] = width;
            GROWABLE_HEAP_I32()[canvas3.canvasSharedPtr + 4 >> 2] = height;
          }
          if (canvas3.offscreenCanvas || !canvas3.controlTransferredOffscreen) {
            if (canvas3.offscreenCanvas)
              canvas3 = canvas3.offscreenCanvas;
            var autoResizeViewport = false;
            if (canvas3.GLctxObject && canvas3.GLctxObject.GLctx) {
              var prevViewport = canvas3.GLctxObject.GLctx.getParameter(2978);
              autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas3.width && prevViewport[3] === canvas3.height;
            }
            canvas3.width = width;
            canvas3.height = height;
            if (autoResizeViewport) {
              canvas3.GLctxObject.GLctx.viewport(0, 0, width, height);
            }
          } else if (canvas3.canvasSharedPtr) {
            var targetThread = GROWABLE_HEAP_I32()[canvas3.canvasSharedPtr + 8 >> 2];
            _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
            return 1;
          } else {
            return -4;
          }
          return 0;
        }
        function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(2, 1, target, width, height);
          return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        }
        function _emscripten_set_canvas_element_size(target, width, height) {
          var canvas3 = findCanvasEventTarget(target);
          if (canvas3) {
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          } else {
            return _emscripten_set_canvas_element_size_main_thread(target, width, height);
          }
        }
        function _emscripten_set_current_thread_status(newStatus) {
        }
        function _emscripten_set_thread_name(threadId, name) {
        }
        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = function(index, divisor) {
              ext["vertexAttribDivisorANGLE"](index, divisor);
            };
            ctx["drawArraysInstanced"] = function(mode, first, count22, primcount) {
              ext["drawArraysInstancedANGLE"](mode, first, count22, primcount);
            };
            ctx["drawElementsInstanced"] = function(mode, count22, type, indices, primcount) {
              ext["drawElementsInstancedANGLE"](mode, count22, type, indices, primcount);
            };
            return 1;
          }
        }
        function __webgl_enable_OES_vertex_array_object(ctx) {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = function() {
              return ext["createVertexArrayOES"]();
            };
            ctx["deleteVertexArray"] = function(vao) {
              ext["deleteVertexArrayOES"](vao);
            };
            ctx["bindVertexArray"] = function(vao) {
              ext["bindVertexArrayOES"](vao);
            };
            ctx["isVertexArray"] = function(vao) {
              return ext["isVertexArrayOES"](vao);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_draw_buffers(ctx) {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = function(n2, bufs) {
              ext["drawBuffersWEBGL"](n2, bufs);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_multi_draw(ctx) {
          return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }
        var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], uniforms: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, timerQueriesEXT: [], programInfos: {}, stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
          if (!GL.lastError) {
            GL.lastError = errorCode;
          }
        }, getNewId: function(table) {
          var ret = GL.counter++;
          for (var i2 = table.length; i2 < ret; i2++) {
            table[i2] = null;
          }
          return ret;
        }, getSource: function(shader, count22, string3, length) {
          var source = "";
          for (var i2 = 0; i2 < count22; ++i2) {
            var len = length ? GROWABLE_HEAP_I32()[length + i2 * 4 >> 2] : -1;
            source += UTF8ToString(GROWABLE_HEAP_I32()[string3 + i2 * 4 >> 2], len < 0 ? void 0 : len);
          }
          return source;
        }, createContext: function(canvas3, webGLContextAttributes) {
          var ctx = canvas3.getContext("webgl", webGLContextAttributes);
          if (!ctx)
            return 0;
          var handle = GL.registerContext(ctx, webGLContextAttributes);
          return handle;
        }, registerContext: function(ctx, webGLContextAttributes) {
          var handle = _malloc(8);
          GROWABLE_HEAP_I32()[handle + 4 >> 2] = _pthread_self();
          var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
          if (ctx.canvas)
            ctx.canvas.GLctxObject = context;
          GL.contexts[handle] = context;
          if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
            GL.initExtensions(context);
          }
          return handle;
        }, makeContextCurrent: function(contextHandle) {
          GL.currentContext = GL.contexts[contextHandle];
          Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
          return !(contextHandle && !GLctx);
        }, getContext: function(contextHandle) {
          return GL.contexts[contextHandle];
        }, deleteContext: function(contextHandle) {
          if (GL.currentContext === GL.contexts[contextHandle])
            GL.currentContext = null;
          if (typeof JSEvents === "object")
            JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
          if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
            GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
          _free(GL.contexts[contextHandle].handle);
          GL.contexts[contextHandle] = null;
        }, initExtensions: function(context) {
          if (!context)
            context = GL.currentContext;
          if (context.initExtensionsDone)
            return;
          context.initExtensionsDone = true;
          var GLctx2 = context.GLctx;
          __webgl_enable_ANGLE_instanced_arrays(GLctx2);
          __webgl_enable_OES_vertex_array_object(GLctx2);
          __webgl_enable_WEBGL_draw_buffers(GLctx2);
          GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
          __webgl_enable_WEBGL_multi_draw(GLctx2);
          var exts = GLctx2.getSupportedExtensions() || [];
          exts.forEach(function(ext) {
            if (ext.indexOf("lose_context") < 0 && ext.indexOf("debug") < 0) {
              GLctx2.getExtension(ext);
            }
          });
        }, populateUniformTable: function(program) {
          var p22 = GL.programs[program];
          var ptable = GL.programInfos[program] = { uniforms: {}, maxUniformLength: 0, maxAttributeLength: -1, maxUniformBlockNameLength: -1 };
          var utable = ptable.uniforms;
          var numUniforms = GLctx.getProgramParameter(p22, 35718);
          for (var i2 = 0; i2 < numUniforms; ++i2) {
            var u2 = GLctx.getActiveUniform(p22, i2);
            var name = u2.name;
            ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length + 1);
            if (name.slice(-1) == "]") {
              name = name.slice(0, name.lastIndexOf("["));
            }
            var loc = GLctx.getUniformLocation(p22, name);
            if (loc) {
              var id = GL.getNewId(GL.uniforms);
              utable[name] = [u2.size, id];
              GL.uniforms[id] = loc;
              for (var j2 = 1; j2 < u2.size; ++j2) {
                var n2 = name + "[" + j2 + "]";
                loc = GLctx.getUniformLocation(p22, n2);
                id = GL.getNewId(GL.uniforms);
                GL.uniforms[id] = loc;
              }
            }
          }
        } };
        var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          var a6 = attributes >> 2;
          var powerPreference = GROWABLE_HEAP_I32()[a6 + (24 >> 2)];
          var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a6 + (0 >> 2)], "depth": !!GROWABLE_HEAP_I32()[a6 + (4 >> 2)], "stencil": !!GROWABLE_HEAP_I32()[a6 + (8 >> 2)], "antialias": !!GROWABLE_HEAP_I32()[a6 + (12 >> 2)], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a6 + (16 >> 2)], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a6 + (20 >> 2)], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a6 + (28 >> 2)], majorVersion: GROWABLE_HEAP_I32()[a6 + (32 >> 2)], minorVersion: GROWABLE_HEAP_I32()[a6 + (36 >> 2)], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a6 + (40 >> 2)], explicitSwapControl: GROWABLE_HEAP_I32()[a6 + (44 >> 2)], proxyContextToMainThread: GROWABLE_HEAP_I32()[a6 + (48 >> 2)], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a6 + (52 >> 2)] };
          var canvas3 = findCanvasEventTarget(target);
          if (!canvas3) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas3, contextAttributes);
          return contextHandle;
        }
        function _emscripten_webgl_create_context(a0, a12) {
          return _emscripten_webgl_do_create_context(a0, a12);
        }
        var SYSCALLS = { mappings: {}, buffers: [null, [], []], printChar: function(stream, curr) {
          var buffer3 = SYSCALLS.buffers[stream];
          if (curr === 0 || curr === 10) {
            (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
            buffer3.length = 0;
          } else {
            buffer3.push(curr);
          }
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, get64: function(low, high) {
          return low;
        } };
        function _fd_close(fd) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(3, 1, fd);
          return 0;
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(4, 1, fd, offset_low, offset_high, whence, newOffset);
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(5, 1, fd, iov, iovcnt, pnum);
          var num = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i2 * 8 >> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i2 * 8 + 4) >> 2];
            for (var j2 = 0; j2 < len; j2++) {
              SYSCALLS.printChar(fd, GROWABLE_HEAP_U8()[ptr + j2]);
            }
            num += len;
          }
          GROWABLE_HEAP_I32()[pnum >> 2] = num;
          return 0;
        }
        function _pthread_cleanup_pop(execute2) {
          var routine = PThread.threadExitHandlers.pop();
          if (execute2)
            routine();
        }
        function _pthread_cleanup_push(routine, arg) {
          PThread.threadExitHandlers.push(function() {
            wasmTable.get(routine)(arg);
          });
        }
        function spawnThread(threadParams) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! spawnThread() can only ever be called from main application thread!";
          var worker = PThread.getNewWorker();
          if (worker.pthread !== void 0)
            throw "Internal error!";
          if (!threadParams.pthread_ptr)
            throw "Internal error, no pthread ptr!";
          PThread.runningWorkers.push(worker);
          var tlsMemory = _malloc(128 * 4);
          for (var i2 = 0; i2 < 128; ++i2) {
            GROWABLE_HEAP_I32()[tlsMemory + i2 * 4 >> 2] = 0;
          }
          var stackHigh = threadParams.stackBase + threadParams.stackSize;
          var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, threadInfoStruct: threadParams.pthread_ptr };
          var tis = pthread.threadInfoStruct >> 2;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (64 >> 2), threadParams.detached);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (100 >> 2), tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (76 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 8 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 12 >> 2), threadParams.detached);
          var global_libc = _emscripten_get_global_libc();
          var global_locale = global_libc + 40;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (172 >> 2), global_locale);
          worker.pthread = pthread;
          var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
          worker.runPthread = function() {
            msg.time = performance.now();
            worker.postMessage(msg, threadParams.transferList);
          };
          if (worker.loaded) {
            worker.runPthread();
            delete worker.runPthread;
          }
        }
        function _pthread_create(pthread_ptr, attr, start_routine, arg) {
          if (typeof SharedArrayBuffer === "undefined") {
            err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
            return 6;
          }
          if (!pthread_ptr) {
            err("pthread_create called with a null thread pointer!");
            return 28;
          }
          var transferList = [];
          var error = 0;
          if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
            return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
          }
          if (error)
            return error;
          var stackSize = 0;
          var stackBase = 0;
          var detached = 0;
          if (attr && attr != -1) {
            stackSize = GROWABLE_HEAP_I32()[attr >> 2];
            stackSize += 81920;
            stackBase = GROWABLE_HEAP_I32()[attr + 8 >> 2];
            detached = GROWABLE_HEAP_I32()[attr + 12 >> 2] !== 0;
          } else {
            stackSize = 2097152;
          }
          var allocatedOwnStack = stackBase == 0;
          if (allocatedOwnStack) {
            stackBase = _memalign(16, stackSize);
          } else {
            stackBase -= stackSize;
            assert3(stackBase > 0);
          }
          var threadInfoStruct = _malloc(228);
          for (var i2 = 0; i2 < 228 >> 2; ++i2)
            GROWABLE_HEAP_U32()[(threadInfoStruct >> 2) + i2] = 0;
          GROWABLE_HEAP_I32()[pthread_ptr >> 2] = threadInfoStruct;
          GROWABLE_HEAP_I32()[threadInfoStruct + 12 >> 2] = threadInfoStruct;
          var headPtr = threadInfoStruct + 152;
          GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
          var threadParams = { stackBase, stackSize, allocatedOwnStack, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct, arg, transferList };
          if (ENVIRONMENT_IS_PTHREAD) {
            threadParams.cmd = "spawnThread";
            postMessage(threadParams, transferList);
          } else {
            spawnThread(threadParams);
          }
          return 0;
        }
        function _sysconf(name) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(6, 1, name);
          switch (name) {
            case 30:
              return 16384;
            case 85:
              var maxHeapSize = 2147483648;
              return maxHeapSize / 16384;
            case 132:
            case 133:
            case 12:
            case 137:
            case 138:
            case 15:
            case 235:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 149:
            case 13:
            case 10:
            case 236:
            case 153:
            case 9:
            case 21:
            case 22:
            case 159:
            case 154:
            case 14:
            case 77:
            case 78:
            case 139:
            case 82:
            case 68:
            case 67:
            case 164:
            case 11:
            case 29:
            case 47:
            case 48:
            case 95:
            case 52:
            case 51:
            case 46:
              return 200809;
            case 27:
            case 246:
            case 127:
            case 128:
            case 23:
            case 24:
            case 160:
            case 161:
            case 181:
            case 182:
            case 242:
            case 183:
            case 184:
            case 243:
            case 244:
            case 245:
            case 165:
            case 178:
            case 179:
            case 49:
            case 50:
            case 168:
            case 169:
            case 175:
            case 170:
            case 171:
            case 172:
            case 97:
            case 76:
            case 32:
            case 173:
            case 35:
            case 80:
            case 81:
            case 79:
              return -1;
            case 176:
            case 177:
            case 7:
            case 155:
            case 8:
            case 157:
            case 125:
            case 126:
            case 92:
            case 93:
            case 129:
            case 130:
            case 131:
            case 94:
            case 91:
              return 1;
            case 74:
            case 60:
            case 69:
            case 70:
            case 4:
              return 1024;
            case 31:
            case 42:
            case 72:
              return 32;
            case 87:
            case 26:
            case 33:
              return 2147483647;
            case 34:
            case 1:
              return 47839;
            case 38:
            case 36:
              return 99;
            case 43:
            case 37:
              return 2048;
            case 0:
              return 2097152;
            case 3:
              return 65536;
            case 28:
              return 32768;
            case 44:
              return 32767;
            case 75:
              return 16384;
            case 39:
              return 1e3;
            case 89:
              return 700;
            case 71:
              return 256;
            case 40:
              return 255;
            case 2:
              return 100;
            case 180:
              return 64;
            case 25:
              return 20;
            case 5:
              return 16;
            case 6:
              return 6;
            case 73:
              return 4;
            case 84: {
              if (typeof navigator === "object")
                return navigator["hardwareConcurrency"] || 1;
              return 1;
            }
          }
          setErrNo(28);
          return -1;
        }
        if (!ENVIRONMENT_IS_PTHREAD)
          PThread.initMainThreadBlock();
        var GLctx;
        var proxiedFunctionTable = [null, _atexit, _emscripten_set_canvas_element_size_main_thread, _fd_close, _fd_seek, _fd_write, _sysconf];
        var asmLibraryArg = { "e": ___assert_fail, "r": ___call_main, "x": __emscripten_notify_thread_queue, "b": _abort, "y": _emscripten_asm_const_int, "j": _emscripten_conditional_set_current_thread_status, "c": _emscripten_futex_wait, "d": _emscripten_futex_wake, "f": _emscripten_get_now, "p": _emscripten_memcpy_big, "z": _emscripten_num_logical_cores, "u": _emscripten_receive_on_main_thread_js, "q": _emscripten_resize_heap, "v": _emscripten_set_canvas_element_size, "i": _emscripten_set_current_thread_status, "t": _emscripten_set_thread_name, "w": _emscripten_webgl_create_context, "m": _fd_close, "n": _fd_seek, "g": _fd_write, "o": initPthreadsJS, "a": wasmMemory || Module["wasmMemory"], "k": _pthread_cleanup_pop, "l": _pthread_cleanup_push, "h": _pthread_create, "s": _sysconf };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["A"]).apply(null, arguments);
        };
        var _init = Module["_init"] = function() {
          return (_init = Module["_init"] = Module["asm"]["B"]).apply(null, arguments);
        };
        var _register_tensor = Module["_register_tensor"] = function() {
          return (_register_tensor = Module["_register_tensor"] = Module["asm"]["C"]).apply(null, arguments);
        };
        var _dispose_data = Module["_dispose_data"] = function() {
          return (_dispose_data = Module["_dispose_data"] = Module["asm"]["D"]).apply(null, arguments);
        };
        var _dispose = Module["_dispose"] = function() {
          return (_dispose = Module["_dispose"] = Module["asm"]["E"]).apply(null, arguments);
        };
        var _Abs = Module["_Abs"] = function() {
          return (_Abs = Module["_Abs"] = Module["asm"]["G"]).apply(null, arguments);
        };
        var _Add = Module["_Add"] = function() {
          return (_Add = Module["_Add"] = Module["asm"]["H"]).apply(null, arguments);
        };
        var _AddN = Module["_AddN"] = function() {
          return (_AddN = Module["_AddN"] = Module["asm"]["I"]).apply(null, arguments);
        };
        var _All = Module["_All"] = function() {
          return (_All = Module["_All"] = Module["asm"]["J"]).apply(null, arguments);
        };
        var _Any = Module["_Any"] = function() {
          return (_Any = Module["_Any"] = Module["asm"]["K"]).apply(null, arguments);
        };
        var _ArgMax = Module["_ArgMax"] = function() {
          return (_ArgMax = Module["_ArgMax"] = Module["asm"]["L"]).apply(null, arguments);
        };
        var _AvgPool = Module["_AvgPool"] = function() {
          return (_AvgPool = Module["_AvgPool"] = Module["asm"]["M"]).apply(null, arguments);
        };
        var _BatchMatMul = Module["_BatchMatMul"] = function() {
          return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["N"]).apply(null, arguments);
        };
        var _Ceil = Module["_Ceil"] = function() {
          return (_Ceil = Module["_Ceil"] = Module["asm"]["O"]).apply(null, arguments);
        };
        var _ClipByValue = Module["_ClipByValue"] = function() {
          return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["P"]).apply(null, arguments);
        };
        var _Conv2D = Module["_Conv2D"] = function() {
          return (_Conv2D = Module["_Conv2D"] = Module["asm"]["Q"]).apply(null, arguments);
        };
        var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
          return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["R"]).apply(null, arguments);
        };
        var _Cos = Module["_Cos"] = function() {
          return (_Cos = Module["_Cos"] = Module["asm"]["S"]).apply(null, arguments);
        };
        var _Cosh = Module["_Cosh"] = function() {
          return (_Cosh = Module["_Cosh"] = Module["asm"]["T"]).apply(null, arguments);
        };
        var _CropAndResize = Module["_CropAndResize"] = function() {
          return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["U"]).apply(null, arguments);
        };
        var _Cumsum = Module["_Cumsum"] = function() {
          return (_Cumsum = Module["_Cumsum"] = Module["asm"]["V"]).apply(null, arguments);
        };
        var _DepthToSpace = Module["_DepthToSpace"] = function() {
          return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["W"]).apply(null, arguments);
        };
        var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
          return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["X"]).apply(null, arguments);
        };
        var _Elu = Module["_Elu"] = function() {
          return (_Elu = Module["_Elu"] = Module["asm"]["Y"]).apply(null, arguments);
        };
        var _Equal = Module["_Equal"] = function() {
          return (_Equal = Module["_Equal"] = Module["asm"]["Z"]).apply(null, arguments);
        };
        var _Exp = Module["_Exp"] = function() {
          return (_Exp = Module["_Exp"] = Module["asm"]["_"]).apply(null, arguments);
        };
        var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
          return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["$"]).apply(null, arguments);
        };
        var _Floor = Module["_Floor"] = function() {
          return (_Floor = Module["_Floor"] = Module["asm"]["aa"]).apply(null, arguments);
        };
        var _FloorDiv = Module["_FloorDiv"] = function() {
          return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["ba"]).apply(null, arguments);
        };
        var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
          return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["ca"]).apply(null, arguments);
        };
        var _FusedConv2D = Module["_FusedConv2D"] = function() {
          return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["da"]).apply(null, arguments);
        };
        var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
          return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["ea"]).apply(null, arguments);
        };
        var _Gather = Module["_Gather"] = function() {
          return (_Gather = Module["_Gather"] = Module["asm"]["fa"]).apply(null, arguments);
        };
        var _GatherNd = Module["_GatherNd"] = function() {
          return (_GatherNd = Module["_GatherNd"] = Module["asm"]["ga"]).apply(null, arguments);
        };
        var _Greater = Module["_Greater"] = function() {
          return (_Greater = Module["_Greater"] = Module["asm"]["ha"]).apply(null, arguments);
        };
        var _GreaterEqual = Module["_GreaterEqual"] = function() {
          return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["ia"]).apply(null, arguments);
        };
        var _LeakyRelu = Module["_LeakyRelu"] = function() {
          return (_LeakyRelu = Module["_LeakyRelu"] = Module["asm"]["ja"]).apply(null, arguments);
        };
        var _Less = Module["_Less"] = function() {
          return (_Less = Module["_Less"] = Module["asm"]["ka"]).apply(null, arguments);
        };
        var _LessEqual = Module["_LessEqual"] = function() {
          return (_LessEqual = Module["_LessEqual"] = Module["asm"]["la"]).apply(null, arguments);
        };
        var _Log = Module["_Log"] = function() {
          return (_Log = Module["_Log"] = Module["asm"]["ma"]).apply(null, arguments);
        };
        var _LogicalAnd = Module["_LogicalAnd"] = function() {
          return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["na"]).apply(null, arguments);
        };
        var _Max = Module["_Max"] = function() {
          return (_Max = Module["_Max"] = Module["asm"]["oa"]).apply(null, arguments);
        };
        var _MaxPool = Module["_MaxPool"] = function() {
          return (_MaxPool = Module["_MaxPool"] = Module["asm"]["pa"]).apply(null, arguments);
        };
        var _Maximum = Module["_Maximum"] = function() {
          return (_Maximum = Module["_Maximum"] = Module["asm"]["qa"]).apply(null, arguments);
        };
        var _Mean = Module["_Mean"] = function() {
          return (_Mean = Module["_Mean"] = Module["asm"]["ra"]).apply(null, arguments);
        };
        var _Min = Module["_Min"] = function() {
          return (_Min = Module["_Min"] = Module["asm"]["sa"]).apply(null, arguments);
        };
        var _Minimum = Module["_Minimum"] = function() {
          return (_Minimum = Module["_Minimum"] = Module["asm"]["ta"]).apply(null, arguments);
        };
        var _MirrorPad = Module["_MirrorPad"] = function() {
          return (_MirrorPad = Module["_MirrorPad"] = Module["asm"]["ua"]).apply(null, arguments);
        };
        var _Multiply = Module["_Multiply"] = function() {
          return (_Multiply = Module["_Multiply"] = Module["asm"]["va"]).apply(null, arguments);
        };
        var _Neg = Module["_Neg"] = function() {
          return (_Neg = Module["_Neg"] = Module["asm"]["wa"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
          return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["xa"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
          return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["ya"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
          return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["za"]).apply(null, arguments);
        };
        var _NotEqual = Module["_NotEqual"] = function() {
          return (_NotEqual = Module["_NotEqual"] = Module["asm"]["Aa"]).apply(null, arguments);
        };
        var _OneHot = Module["_OneHot"] = function() {
          return (_OneHot = Module["_OneHot"] = Module["asm"]["Ba"]).apply(null, arguments);
        };
        var _PadV2 = Module["_PadV2"] = function() {
          return (_PadV2 = Module["_PadV2"] = Module["asm"]["Ca"]).apply(null, arguments);
        };
        var _Pow = Module["_Pow"] = function() {
          return (_Pow = Module["_Pow"] = Module["asm"]["Da"]).apply(null, arguments);
        };
        var _Prelu = Module["_Prelu"] = function() {
          return (_Prelu = Module["_Prelu"] = Module["asm"]["Ea"]).apply(null, arguments);
        };
        var _Prod = Module["_Prod"] = function() {
          return (_Prod = Module["_Prod"] = Module["asm"]["Fa"]).apply(null, arguments);
        };
        var _RealDiv = Module["_RealDiv"] = function() {
          return (_RealDiv = Module["_RealDiv"] = Module["asm"]["Ga"]).apply(null, arguments);
        };
        var _Relu = Module["_Relu"] = function() {
          return (_Relu = Module["_Relu"] = Module["asm"]["Ha"]).apply(null, arguments);
        };
        var _Relu6 = Module["_Relu6"] = function() {
          return (_Relu6 = Module["_Relu6"] = Module["asm"]["Ia"]).apply(null, arguments);
        };
        var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
          return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["Ja"]).apply(null, arguments);
        };
        var _Reverse = Module["_Reverse"] = function() {
          return (_Reverse = Module["_Reverse"] = Module["asm"]["Ka"]).apply(null, arguments);
        };
        var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
          return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["La"]).apply(null, arguments);
        };
        var _Round = Module["_Round"] = function() {
          return (_Round = Module["_Round"] = Module["asm"]["Ma"]).apply(null, arguments);
        };
        var _Rsqrt = Module["_Rsqrt"] = function() {
          return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["Na"]).apply(null, arguments);
        };
        var _ScatterNd = Module["_ScatterNd"] = function() {
          return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["Oa"]).apply(null, arguments);
        };
        var _SelectV2 = Module["_SelectV2"] = function() {
          return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["Pa"]).apply(null, arguments);
        };
        var _Sigmoid = Module["_Sigmoid"] = function() {
          return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["Qa"]).apply(null, arguments);
        };
        var _Sin = Module["_Sin"] = function() {
          return (_Sin = Module["_Sin"] = Module["asm"]["Ra"]).apply(null, arguments);
        };
        var _Softmax = Module["_Softmax"] = function() {
          return (_Softmax = Module["_Softmax"] = Module["asm"]["Sa"]).apply(null, arguments);
        };
        var _Sqrt = Module["_Sqrt"] = function() {
          return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Ta"]).apply(null, arguments);
        };
        var _Square = Module["_Square"] = function() {
          return (_Square = Module["_Square"] = Module["asm"]["Ua"]).apply(null, arguments);
        };
        var _SquaredDifference = Module["_SquaredDifference"] = function() {
          return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["Va"]).apply(null, arguments);
        };
        var _Step = Module["_Step"] = function() {
          return (_Step = Module["_Step"] = Module["asm"]["Wa"]).apply(null, arguments);
        };
        var _StridedSlice = Module["_StridedSlice"] = function() {
          return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["Xa"]).apply(null, arguments);
        };
        var _Sub = Module["_Sub"] = function() {
          return (_Sub = Module["_Sub"] = Module["asm"]["Ya"]).apply(null, arguments);
        };
        var _Sum = Module["_Sum"] = function() {
          return (_Sum = Module["_Sum"] = Module["asm"]["Za"]).apply(null, arguments);
        };
        var _Tan = Module["_Tan"] = function() {
          return (_Tan = Module["_Tan"] = Module["asm"]["_a"]).apply(null, arguments);
        };
        var _Tanh = Module["_Tanh"] = function() {
          return (_Tanh = Module["_Tanh"] = Module["asm"]["$a"]).apply(null, arguments);
        };
        var _Tile = Module["_Tile"] = function() {
          return (_Tile = Module["_Tile"] = Module["asm"]["ab"]).apply(null, arguments);
        };
        var _TopK = Module["_TopK"] = function() {
          return (_TopK = Module["_TopK"] = Module["asm"]["bb"]).apply(null, arguments);
        };
        var _Transform = Module["_Transform"] = function() {
          return (_Transform = Module["_Transform"] = Module["asm"]["cb"]).apply(null, arguments);
        };
        var _Transpose = Module["_Transpose"] = function() {
          return (_Transpose = Module["_Transpose"] = Module["asm"]["db"]).apply(null, arguments);
        };
        var __FusedMatMul = Module["__FusedMatMul"] = function() {
          return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["eb"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["fb"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["gb"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["hb"]).apply(null, arguments);
        };
        var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
          return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["ib"]).apply(null, arguments);
        };
        var _pthread_self = Module["_pthread_self"] = function() {
          return (_pthread_self = Module["_pthread_self"] = Module["asm"]["jb"]).apply(null, arguments);
        };
        var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
          return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["kb"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
          return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["lb"]).apply(null, arguments);
        };
        var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function() {
          return (_emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["mb"]).apply(null, arguments);
        };
        var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
          return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["nb"]).apply(null, arguments);
        };
        var __emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = function() {
          return (__emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = Module["asm"]["ob"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
          return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["pb"]).apply(null, arguments);
        };
        var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
          return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["qb"]).apply(null, arguments);
        };
        var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
          return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["rb"]).apply(null, arguments);
        };
        var _emscripten_tls_init = Module["_emscripten_tls_init"] = function() {
          return (_emscripten_tls_init = Module["_emscripten_tls_init"] = Module["asm"]["sb"]).apply(null, arguments);
        };
        var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
          return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["tb"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["ub"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["vb"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
          return (stackAlloc = Module["stackAlloc"] = Module["asm"]["wb"]).apply(null, arguments);
        };
        var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
          return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["xb"]).apply(null, arguments);
        };
        var _memalign = Module["_memalign"] = function() {
          return (_memalign = Module["_memalign"] = Module["asm"]["yb"]).apply(null, arguments);
        };
        var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 10016;
        var __emscripten_main_thread_futex = Module["__emscripten_main_thread_futex"] = 11652;
        Module["cwrap"] = cwrap;
        Module["PThread"] = PThread;
        Module["PThread"] = PThread;
        Module["wasmMemory"] = wasmMemory;
        Module["ExitStatus"] = ExitStatus;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          if (ENVIRONMENT_IS_PTHREAD) {
            readyPromiseResolve(Module);
            initRuntime();
            postMessage({ "cmd": "loaded" });
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        function exit(status, implicit) {
          if (implicit && noExitRuntime && status === 0) {
            return;
          }
          if (!implicit) {
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exitProcess", "returnCode": status });
              throw new ExitStatus(status);
            } else {
            }
          }
          if (noExitRuntime) {
          } else {
            PThread.terminateAllThreads();
            EXITSTATUS = status;
            exitRuntime();
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        if (ENVIRONMENT_IS_PTHREAD) {
          noExitRuntime = false;
          PThread.initWorker();
        }
        run();
        return WasmBackendModuleThreadedSimd2.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WasmBackendModuleThreadedSimd;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WasmBackendModuleThreadedSimd;
      });
    else if (typeof exports === "object")
      exports["WasmBackendModuleThreadedSimd"] = WasmBackendModuleThreadedSimd;
  }
});
var require_tfjs_backend_wasm = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.9.0_@tensorflow+tfjs-core@3.9.0/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(exports, module) {
    var WasmBackendModule = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WasmBackendModule2) {
        WasmBackendModule2 = WasmBackendModule2 || {};
        var Module = typeof WasmBackendModule2 !== "undefined" ? WasmBackendModule2 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = false;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = require_path().dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require22("fs");
            if (!nodePath)
              nodePath = require_path();
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert3(ret.buffer);
            return ret;
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status) {
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_SHELL) {
          if (typeof read != "undefined") {
            read_ = function shell_read(f2) {
              return read(f2);
            };
          }
          readBinary = function readBinary2(f2) {
            var data;
            if (typeof readbuffer === "function") {
              return new Uint8Array(readbuffer(f2));
            }
            data = read(f2, "binary");
            assert3(typeof data === "object");
            return data;
          };
          if (typeof scriptArgs != "undefined") {
            arguments_ = scriptArgs;
          } else if (typeof arguments != "undefined") {
            arguments_ = arguments;
          }
          if (typeof quit === "function") {
            quit_ = function(status) {
              quit(status);
            };
          }
          if (typeof print !== "undefined") {
            if (typeof console === "undefined")
              console = {};
            console.log = print;
            console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
          }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
          setWindowTitle = function(title) {
            document.title = title;
          };
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert3(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        function getCFunc(ident) {
          var func2 = Module["_" + ident];
          assert3(func2, "Cannot call unknown function " + ident + ", make sure it is exported");
          return func2;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
          var toC = { "string": function(str) {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              var len = (str.length << 2) + 1;
              ret2 = stackAlloc(len);
              stringToUTF8(str, ret2, len);
            }
            return ret2;
          }, "array": function(arr) {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          } };
          function convertReturnValue(ret2) {
            if (returnType === "string")
              return UTF8ToString(ret2);
            if (returnType === "boolean")
              return Boolean(ret2);
            return ret2;
          }
          var func2 = getCFunc(ident);
          var cArgs = [];
          var stack2 = 0;
          if (args) {
            for (var i2 = 0; i2 < args.length; i2++) {
              var converter = toC[argTypes[i2]];
              if (converter) {
                if (stack2 === 0)
                  stack2 = stackSave();
                cArgs[i2] = converter(args[i2]);
              } else {
                cArgs[i2] = args[i2];
              }
            }
          }
          var ret = func2.apply(null, cArgs);
          ret = convertReturnValue(ret);
          if (stack2 !== 0)
            stackRestore(stack2);
          return ret;
        }
        function cwrap(ident, returnType, argTypes, opts) {
          argTypes = argTypes || [];
          var numericArgs = argTypes.every(function(type) {
            return type === "number";
          });
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs && !opts) {
            return getCFunc(ident);
          }
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx, endPtr));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var u2 = str.charCodeAt(i2);
            if (u2 >= 55296 && u2 <= 57343) {
              var u1 = str.charCodeAt(++i2);
              u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
            }
            if (u2 <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++] = u2;
            } else if (u2 <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++] = 192 | u2 >> 6;
              heap[outIdx++] = 128 | u2 & 63;
            } else if (u2 <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++] = 224 | u2 >> 12;
              heap[outIdx++] = 128 | u2 >> 6 & 63;
              heap[outIdx++] = 128 | u2 & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++] = 240 | u2 >> 18;
              heap[outIdx++] = 128 | u2 >> 12 & 63;
              heap[outIdx++] = 128 | u2 >> 6 & 63;
              heap[outIdx++] = 128 | u2 & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function writeArrayToMemory(array2, buffer3) {
          HEAP8.set(array2, buffer3);
        }
        function alignUp(x2, multiple) {
          if (x2 % multiple > 0) {
            x2 += multiple - x2 % multiple;
          }
          return x2;
        }
        var buffer2, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer2 = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        __ATINIT__.push({ func: function() {
          ___wasm_call_ctors();
        } });
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e2 = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e2);
          throw e2;
        }
        function hasPrefix(str, prefix) {
          return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return hasPrefix(filename, dataURIPrefix);
        }
        var fileURIPrefix = "file://";
        function isFileURI(filename) {
          return hasPrefix(filename, fileURIPrefix);
        }
        var wasmBinaryFile = "tfjs-backend-wasm.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmMemory = Module["asm"]["i"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module["asm"]["o"];
            removeRunDependency("wasm-instantiate");
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiatedSource(output) {
            receiveInstance(output["instance"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              return WebAssembly.instantiate(binary, info);
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiatedSource, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiatedSource);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiatedSource);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e2) {
              err("Module.instantiateWasm callback failed with error: " + e2);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        function callRuntimeCallbacks(callbacks2) {
          while (callbacks2.length > 0) {
            var callback = callbacks2.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func2 = callback.func;
            if (typeof func2 === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func2)();
              } else {
                wasmTable.get(func2)(callback.arg);
              }
            } else {
              func2(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function _abort() {
          abort();
        }
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest, src, src + num);
        }
        function _emscripten_get_heap_size() {
          return HEAPU8.length;
        }
        function emscripten_realloc_buffer(size2) {
          try {
            wasmMemory.grow(size2 - buffer2.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e2) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = _emscripten_get_heap_size();
          var maxHeapSize = 2147483648;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var SYSCALLS = { mappings: {}, buffers: [null, [], []], printChar: function(stream, curr) {
          var buffer3 = SYSCALLS.buffers[stream];
          if (curr === 0 || curr === 10) {
            (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
            buffer3.length = 0;
          } else {
            buffer3.push(curr);
          }
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, get64: function(low, high) {
          return low;
        } };
        function _fd_close(fd) {
          return 0;
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          var num = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr = HEAP32[iov + i2 * 8 >> 2];
            var len = HEAP32[iov + (i2 * 8 + 4) >> 2];
            for (var j2 = 0; j2 < len; j2++) {
              SYSCALLS.printChar(fd, HEAPU8[ptr + j2]);
            }
            num += len;
          }
          HEAP32[pnum >> 2] = num;
          return 0;
        }
        function _pthread_create() {
          return 6;
        }
        function setErrNo(value) {
          HEAP32[___errno_location() >> 2] = value;
          return value;
        }
        function _sysconf(name) {
          switch (name) {
            case 30:
              return 16384;
            case 85:
              var maxHeapSize = 2147483648;
              return maxHeapSize / 16384;
            case 132:
            case 133:
            case 12:
            case 137:
            case 138:
            case 15:
            case 235:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 149:
            case 13:
            case 10:
            case 236:
            case 153:
            case 9:
            case 21:
            case 22:
            case 159:
            case 154:
            case 14:
            case 77:
            case 78:
            case 139:
            case 82:
            case 68:
            case 67:
            case 164:
            case 11:
            case 29:
            case 47:
            case 48:
            case 95:
            case 52:
            case 51:
            case 46:
              return 200809;
            case 27:
            case 246:
            case 127:
            case 128:
            case 23:
            case 24:
            case 160:
            case 161:
            case 181:
            case 182:
            case 242:
            case 183:
            case 184:
            case 243:
            case 244:
            case 245:
            case 165:
            case 178:
            case 179:
            case 49:
            case 50:
            case 168:
            case 169:
            case 175:
            case 170:
            case 171:
            case 172:
            case 97:
            case 76:
            case 32:
            case 173:
            case 35:
            case 80:
            case 81:
            case 79:
              return -1;
            case 176:
            case 177:
            case 7:
            case 155:
            case 8:
            case 157:
            case 125:
            case 126:
            case 92:
            case 93:
            case 129:
            case 130:
            case 131:
            case 94:
            case 91:
              return 1;
            case 74:
            case 60:
            case 69:
            case 70:
            case 4:
              return 1024;
            case 31:
            case 42:
            case 72:
              return 32;
            case 87:
            case 26:
            case 33:
              return 2147483647;
            case 34:
            case 1:
              return 47839;
            case 38:
            case 36:
              return 99;
            case 43:
            case 37:
              return 2048;
            case 0:
              return 2097152;
            case 3:
              return 65536;
            case 28:
              return 32768;
            case 44:
              return 32767;
            case 75:
              return 16384;
            case 39:
              return 1e3;
            case 89:
              return 700;
            case 71:
              return 256;
            case 40:
              return 255;
            case 2:
              return 100;
            case 180:
              return 64;
            case 25:
              return 20;
            case 5:
              return 16;
            case 6:
              return 6;
            case 73:
              return 4;
            case 84: {
              if (typeof navigator === "object")
                return navigator["hardwareConcurrency"] || 1;
              return 1;
            }
          }
          setErrNo(28);
          return -1;
        }
        var asmLibraryArg = { "a": _abort, "d": _emscripten_memcpy_big, "e": _emscripten_resize_heap, "f": _fd_close, "c": _fd_seek, "b": _fd_write, "g": _pthread_create, "h": _sysconf };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["j"]).apply(null, arguments);
        };
        var _init = Module["_init"] = function() {
          return (_init = Module["_init"] = Module["asm"]["k"]).apply(null, arguments);
        };
        var _register_tensor = Module["_register_tensor"] = function() {
          return (_register_tensor = Module["_register_tensor"] = Module["asm"]["l"]).apply(null, arguments);
        };
        var _dispose_data = Module["_dispose_data"] = function() {
          return (_dispose_data = Module["_dispose_data"] = Module["asm"]["m"]).apply(null, arguments);
        };
        var _dispose = Module["_dispose"] = function() {
          return (_dispose = Module["_dispose"] = Module["asm"]["n"]).apply(null, arguments);
        };
        var _Abs = Module["_Abs"] = function() {
          return (_Abs = Module["_Abs"] = Module["asm"]["p"]).apply(null, arguments);
        };
        var _Add = Module["_Add"] = function() {
          return (_Add = Module["_Add"] = Module["asm"]["q"]).apply(null, arguments);
        };
        var _AddN = Module["_AddN"] = function() {
          return (_AddN = Module["_AddN"] = Module["asm"]["r"]).apply(null, arguments);
        };
        var _All = Module["_All"] = function() {
          return (_All = Module["_All"] = Module["asm"]["s"]).apply(null, arguments);
        };
        var _Any = Module["_Any"] = function() {
          return (_Any = Module["_Any"] = Module["asm"]["t"]).apply(null, arguments);
        };
        var _ArgMax = Module["_ArgMax"] = function() {
          return (_ArgMax = Module["_ArgMax"] = Module["asm"]["u"]).apply(null, arguments);
        };
        var _AvgPool = Module["_AvgPool"] = function() {
          return (_AvgPool = Module["_AvgPool"] = Module["asm"]["v"]).apply(null, arguments);
        };
        var _BatchMatMul = Module["_BatchMatMul"] = function() {
          return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["w"]).apply(null, arguments);
        };
        var _Ceil = Module["_Ceil"] = function() {
          return (_Ceil = Module["_Ceil"] = Module["asm"]["x"]).apply(null, arguments);
        };
        var _ClipByValue = Module["_ClipByValue"] = function() {
          return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["y"]).apply(null, arguments);
        };
        var _Conv2D = Module["_Conv2D"] = function() {
          return (_Conv2D = Module["_Conv2D"] = Module["asm"]["z"]).apply(null, arguments);
        };
        var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
          return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["A"]).apply(null, arguments);
        };
        var _Cos = Module["_Cos"] = function() {
          return (_Cos = Module["_Cos"] = Module["asm"]["B"]).apply(null, arguments);
        };
        var _Cosh = Module["_Cosh"] = function() {
          return (_Cosh = Module["_Cosh"] = Module["asm"]["C"]).apply(null, arguments);
        };
        var _CropAndResize = Module["_CropAndResize"] = function() {
          return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["D"]).apply(null, arguments);
        };
        var _Cumsum = Module["_Cumsum"] = function() {
          return (_Cumsum = Module["_Cumsum"] = Module["asm"]["E"]).apply(null, arguments);
        };
        var _DepthToSpace = Module["_DepthToSpace"] = function() {
          return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["F"]).apply(null, arguments);
        };
        var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
          return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["G"]).apply(null, arguments);
        };
        var _Elu = Module["_Elu"] = function() {
          return (_Elu = Module["_Elu"] = Module["asm"]["H"]).apply(null, arguments);
        };
        var _Equal = Module["_Equal"] = function() {
          return (_Equal = Module["_Equal"] = Module["asm"]["I"]).apply(null, arguments);
        };
        var _Exp = Module["_Exp"] = function() {
          return (_Exp = Module["_Exp"] = Module["asm"]["J"]).apply(null, arguments);
        };
        var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
          return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["K"]).apply(null, arguments);
        };
        var _Floor = Module["_Floor"] = function() {
          return (_Floor = Module["_Floor"] = Module["asm"]["L"]).apply(null, arguments);
        };
        var _FloorDiv = Module["_FloorDiv"] = function() {
          return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["M"]).apply(null, arguments);
        };
        var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
          return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["N"]).apply(null, arguments);
        };
        var _FusedConv2D = Module["_FusedConv2D"] = function() {
          return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["O"]).apply(null, arguments);
        };
        var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
          return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["P"]).apply(null, arguments);
        };
        var _Gather = Module["_Gather"] = function() {
          return (_Gather = Module["_Gather"] = Module["asm"]["Q"]).apply(null, arguments);
        };
        var _GatherNd = Module["_GatherNd"] = function() {
          return (_GatherNd = Module["_GatherNd"] = Module["asm"]["R"]).apply(null, arguments);
        };
        var _Greater = Module["_Greater"] = function() {
          return (_Greater = Module["_Greater"] = Module["asm"]["S"]).apply(null, arguments);
        };
        var _GreaterEqual = Module["_GreaterEqual"] = function() {
          return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["T"]).apply(null, arguments);
        };
        var _LeakyRelu = Module["_LeakyRelu"] = function() {
          return (_LeakyRelu = Module["_LeakyRelu"] = Module["asm"]["U"]).apply(null, arguments);
        };
        var _Less = Module["_Less"] = function() {
          return (_Less = Module["_Less"] = Module["asm"]["V"]).apply(null, arguments);
        };
        var _LessEqual = Module["_LessEqual"] = function() {
          return (_LessEqual = Module["_LessEqual"] = Module["asm"]["W"]).apply(null, arguments);
        };
        var _Log = Module["_Log"] = function() {
          return (_Log = Module["_Log"] = Module["asm"]["X"]).apply(null, arguments);
        };
        var _LogicalAnd = Module["_LogicalAnd"] = function() {
          return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["Y"]).apply(null, arguments);
        };
        var _Max = Module["_Max"] = function() {
          return (_Max = Module["_Max"] = Module["asm"]["Z"]).apply(null, arguments);
        };
        var _MaxPool = Module["_MaxPool"] = function() {
          return (_MaxPool = Module["_MaxPool"] = Module["asm"]["_"]).apply(null, arguments);
        };
        var _Maximum = Module["_Maximum"] = function() {
          return (_Maximum = Module["_Maximum"] = Module["asm"]["$"]).apply(null, arguments);
        };
        var _Mean = Module["_Mean"] = function() {
          return (_Mean = Module["_Mean"] = Module["asm"]["aa"]).apply(null, arguments);
        };
        var _Min = Module["_Min"] = function() {
          return (_Min = Module["_Min"] = Module["asm"]["ba"]).apply(null, arguments);
        };
        var _Minimum = Module["_Minimum"] = function() {
          return (_Minimum = Module["_Minimum"] = Module["asm"]["ca"]).apply(null, arguments);
        };
        var _MirrorPad = Module["_MirrorPad"] = function() {
          return (_MirrorPad = Module["_MirrorPad"] = Module["asm"]["da"]).apply(null, arguments);
        };
        var _Multiply = Module["_Multiply"] = function() {
          return (_Multiply = Module["_Multiply"] = Module["asm"]["ea"]).apply(null, arguments);
        };
        var _Neg = Module["_Neg"] = function() {
          return (_Neg = Module["_Neg"] = Module["asm"]["fa"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
          return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["ga"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
          return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["ha"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
          return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["ia"]).apply(null, arguments);
        };
        var _NotEqual = Module["_NotEqual"] = function() {
          return (_NotEqual = Module["_NotEqual"] = Module["asm"]["ja"]).apply(null, arguments);
        };
        var _OneHot = Module["_OneHot"] = function() {
          return (_OneHot = Module["_OneHot"] = Module["asm"]["ka"]).apply(null, arguments);
        };
        var _PadV2 = Module["_PadV2"] = function() {
          return (_PadV2 = Module["_PadV2"] = Module["asm"]["la"]).apply(null, arguments);
        };
        var _Pow = Module["_Pow"] = function() {
          return (_Pow = Module["_Pow"] = Module["asm"]["ma"]).apply(null, arguments);
        };
        var _Prelu = Module["_Prelu"] = function() {
          return (_Prelu = Module["_Prelu"] = Module["asm"]["na"]).apply(null, arguments);
        };
        var _Prod = Module["_Prod"] = function() {
          return (_Prod = Module["_Prod"] = Module["asm"]["oa"]).apply(null, arguments);
        };
        var _RealDiv = Module["_RealDiv"] = function() {
          return (_RealDiv = Module["_RealDiv"] = Module["asm"]["pa"]).apply(null, arguments);
        };
        var _Relu = Module["_Relu"] = function() {
          return (_Relu = Module["_Relu"] = Module["asm"]["qa"]).apply(null, arguments);
        };
        var _Relu6 = Module["_Relu6"] = function() {
          return (_Relu6 = Module["_Relu6"] = Module["asm"]["ra"]).apply(null, arguments);
        };
        var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
          return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["sa"]).apply(null, arguments);
        };
        var _Reverse = Module["_Reverse"] = function() {
          return (_Reverse = Module["_Reverse"] = Module["asm"]["ta"]).apply(null, arguments);
        };
        var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
          return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["ua"]).apply(null, arguments);
        };
        var _Round = Module["_Round"] = function() {
          return (_Round = Module["_Round"] = Module["asm"]["va"]).apply(null, arguments);
        };
        var _Rsqrt = Module["_Rsqrt"] = function() {
          return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["wa"]).apply(null, arguments);
        };
        var _ScatterNd = Module["_ScatterNd"] = function() {
          return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["xa"]).apply(null, arguments);
        };
        var _SelectV2 = Module["_SelectV2"] = function() {
          return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["ya"]).apply(null, arguments);
        };
        var _Sigmoid = Module["_Sigmoid"] = function() {
          return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["za"]).apply(null, arguments);
        };
        var _Sin = Module["_Sin"] = function() {
          return (_Sin = Module["_Sin"] = Module["asm"]["Aa"]).apply(null, arguments);
        };
        var _Softmax = Module["_Softmax"] = function() {
          return (_Softmax = Module["_Softmax"] = Module["asm"]["Ba"]).apply(null, arguments);
        };
        var _Sqrt = Module["_Sqrt"] = function() {
          return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Ca"]).apply(null, arguments);
        };
        var _Square = Module["_Square"] = function() {
          return (_Square = Module["_Square"] = Module["asm"]["Da"]).apply(null, arguments);
        };
        var _SquaredDifference = Module["_SquaredDifference"] = function() {
          return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["Ea"]).apply(null, arguments);
        };
        var _Step = Module["_Step"] = function() {
          return (_Step = Module["_Step"] = Module["asm"]["Fa"]).apply(null, arguments);
        };
        var _StridedSlice = Module["_StridedSlice"] = function() {
          return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["Ga"]).apply(null, arguments);
        };
        var _Sub = Module["_Sub"] = function() {
          return (_Sub = Module["_Sub"] = Module["asm"]["Ha"]).apply(null, arguments);
        };
        var _Sum = Module["_Sum"] = function() {
          return (_Sum = Module["_Sum"] = Module["asm"]["Ia"]).apply(null, arguments);
        };
        var _Tan = Module["_Tan"] = function() {
          return (_Tan = Module["_Tan"] = Module["asm"]["Ja"]).apply(null, arguments);
        };
        var _Tanh = Module["_Tanh"] = function() {
          return (_Tanh = Module["_Tanh"] = Module["asm"]["Ka"]).apply(null, arguments);
        };
        var _Tile = Module["_Tile"] = function() {
          return (_Tile = Module["_Tile"] = Module["asm"]["La"]).apply(null, arguments);
        };
        var _TopK = Module["_TopK"] = function() {
          return (_TopK = Module["_TopK"] = Module["asm"]["Ma"]).apply(null, arguments);
        };
        var _Transform = Module["_Transform"] = function() {
          return (_Transform = Module["_Transform"] = Module["asm"]["Na"]).apply(null, arguments);
        };
        var _Transpose = Module["_Transpose"] = function() {
          return (_Transpose = Module["_Transpose"] = Module["asm"]["Oa"]).apply(null, arguments);
        };
        var __FusedMatMul = Module["__FusedMatMul"] = function() {
          return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["Pa"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["Qa"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["Ra"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["Sa"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["Ta"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["Ua"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
          return (stackAlloc = Module["stackAlloc"] = Module["asm"]["Va"]).apply(null, arguments);
        };
        Module["cwrap"] = cwrap;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        run();
        return WasmBackendModule2.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WasmBackendModule;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WasmBackendModule;
      });
    else if (typeof exports === "object")
      exports["WasmBackendModule"] = WasmBackendModule;
  }
});
var EPSILON_FLOAT32 = 1e-7;
var EPSILON_FLOAT16 = 1e-4;
var DataStorage = class {
  constructor(backend22, dataMover) {
    this.backend = backend22;
    this.dataMover = dataMover;
    this.data = new WeakMap();
    this.dataIdsCount = 0;
  }
  get(dataId) {
    if (!this.data.has(dataId)) {
      this.dataMover.moveData(this.backend, dataId);
    }
    return this.data.get(dataId);
  }
  set(dataId, value) {
    this.dataIdsCount++;
    this.data.set(dataId, value);
  }
  has(dataId) {
    return this.data.has(dataId);
  }
  delete(dataId) {
    this.dataIdsCount--;
    return this.data.delete(dataId);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
};
var KernelBackend = class {
  refCount(dataId) {
    return notYetImplemented("refCount");
  }
  incRef(dataId) {
    return notYetImplemented("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(f2) {
    return notYetImplemented("time");
  }
  read(dataId) {
    return notYetImplemented("read");
  }
  readSync(dataId) {
    return notYetImplemented("readSync");
  }
  numDataIds() {
    return notYetImplemented("numDataIds");
  }
  disposeData(dataId, force) {
    return notYetImplemented("disposeData");
  }
  write(values, shape, dtype) {
    return notYetImplemented("write");
  }
  move(dataId, values, shape, dtype, refCount) {
    return notYetImplemented("move");
  }
  memory() {
    return notYetImplemented("memory");
  }
  floatPrecision() {
    return notYetImplemented("floatPrecision");
  }
  epsilon() {
    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
  }
  dispose() {
    return notYetImplemented("dispose");
  }
};
function notYetImplemented(kernelName) {
  throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
function shuffle(array2) {
  let counter = array2.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array2, counter, index);
  }
}
function shuffleCombo(array2, array22) {
  if (array2.length !== array22.length) {
    throw new Error(`Array sizes must match to be shuffled together First array length was ${array2.length}Second array length was ${array22.length}`);
  }
  let counter = array2.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array2, counter, index);
    swap(array22, counter, index);
  }
}
function clamp2(min7, x2, max7) {
  return Math.max(min7, Math.min(x2, max7));
}
function nearestLargerEven(val) {
  return val % 2 === 0 ? val : val + 1;
}
function swap(object2, left, right) {
  const temp = object2[left];
  object2[left] = object2[right];
  object2[right] = temp;
}
function sum(arr) {
  let sum7 = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    sum7 += arr[i2];
  }
  return sum7;
}
function randUniform(a6, b2) {
  const r2 = Math.random();
  return b2 * r2 + (1 - r2) * a6;
}
function distSquared(a6, b2) {
  let result = 0;
  for (let i2 = 0; i2 < a6.length; i2++) {
    const diff = Number(a6[i2]) - Number(b2[i2]);
    result += diff * diff;
  }
  return result;
}
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
  assert(arraysEqual2(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function assertNonNull(a6) {
  assert(a6 != null, () => `The input to the tensor constructor must be a non-null value.`);
}
function flatten2(arr, result = [], skipTypedArray = false) {
  if (result == null) {
    result = [];
  }
  if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {
    for (let i2 = 0; i2 < arr.length; ++i2) {
      flatten2(arr[i2], result, skipTypedArray);
    }
  } else {
    result.push(arr);
  }
  return result;
}
function sizeFromShape(shape) {
  if (shape.length === 0) {
    return 1;
  }
  let size2 = shape[0];
  for (let i2 = 1; i2 < shape.length; i2++) {
    size2 *= shape[i2];
  }
  return size2;
}
function isScalarShape(shape) {
  return shape.length === 0;
}
function arraysEqual2(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i2 = 0; i2 < n1.length; i2++) {
    if (n1[i2] !== n2[i2]) {
      return false;
    }
  }
  return true;
}
function isInt(a6) {
  return a6 % 1 === 0;
}
function tanh(x2) {
  if (Math.tanh != null) {
    return Math.tanh(x2);
  }
  if (x2 === Infinity) {
    return 1;
  } else if (x2 === -Infinity) {
    return -1;
  } else {
    const e2x = Math.exp(2 * x2);
    return (e2x - 1) / (e2x + 1);
  }
}
function sizeToSquarishShape(size2) {
  const width = Math.ceil(Math.sqrt(size2));
  return [width, Math.ceil(size2 / width)];
}
function createShuffledIndices(n2) {
  const shuffledIndices = new Uint32Array(n2);
  for (let i2 = 0; i2 < n2; ++i2) {
    shuffledIndices[i2] = i2;
  }
  shuffle(shuffledIndices);
  return shuffledIndices;
}
function rightPad(a6, size2) {
  if (size2 <= a6.length) {
    return a6;
  }
  return a6 + " ".repeat(size2 - a6.length);
}
function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      setTimeout(tryFn, nextBackoff);
    };
    tryFn();
  });
}
function inferFromImplicitShape(shape, size2) {
  let shapeProd = 1;
  let implicitIdx = -1;
  for (let i2 = 0; i2 < shape.length; ++i2) {
    if (shape[i2] >= 0) {
      shapeProd *= shape[i2];
    } else if (shape[i2] === -1) {
      if (implicitIdx !== -1) {
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i2}`);
      }
      implicitIdx = i2;
    } else if (shape[i2] < 0) {
      throw Error(`Shapes can not be < 0. Found ${shape[i2]} at dim ${i2}`);
    }
  }
  if (implicitIdx === -1) {
    if (size2 > 0 && size2 !== shapeProd) {
      throw Error(`Size(${size2}) must match the product of shape ${shape}`);
    }
    return shape;
  }
  if (shapeProd === 0) {
    throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
  }
  if (size2 % shapeProd !== 0) {
    throw Error(`The implicit shape can't be a fractional number. Got ${size2} / ${shapeProd}`);
  }
  const newShape = shape.slice();
  newShape[implicitIdx] = size2 / shapeProd;
  return newShape;
}
function parseAxisParam(axis, shape) {
  const rank = shape.length;
  axis = axis == null ? shape.map((s2, i2) => i2) : [].concat(axis);
  assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
  assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
  return axis.map((a6) => a6 < 0 ? rank + a6 : a6);
}
function squeezeShape(shape, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
  let j2 = 0;
  for (let i2 = 0; i2 < shape.length; ++i2) {
    if (axes != null) {
      if (axes[j2] === i2 && shape[i2] !== 1) {
        throw new Error(`Can't squeeze axis ${i2} since its dim '${shape[i2]}' is not 1`);
      }
      if ((axes[j2] == null || axes[j2] > i2) && shape[i2] === 1) {
        newShape.push(shape[i2]);
        keptDims.push(i2);
      }
      if (axes[j2] <= i2) {
        j2++;
      }
    }
    if (shape[i2] !== 1) {
      newShape.push(shape[i2]);
      keptDims.push(i2);
    }
  }
  return { newShape, keptDims };
}
function getTypedArrayFromDType(dtype, size2) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size2);
  } else if (dtype === "int32") {
    values = new Int32Array(size2);
  } else if (dtype === "bool") {
    values = new Uint8Array(size2);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function getArrayFromDType(dtype, size2) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size2);
  } else if (dtype === "int32") {
    values = new Int32Array(size2);
  } else if (dtype === "bool") {
    values = new Uint8Array(size2);
  } else if (dtype === "string") {
    values = new Array(size2);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function checkConversionForErrors(vals, dtype) {
  for (let i2 = 0; i2 < vals.length; i2++) {
    const num = vals[i2];
    if (isNaN(num) || !isFinite(num)) {
      throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
    }
  }
}
function isValidDtype(dtype) {
  return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
}
function hasEncodingLoss(oldType, newType) {
  if (newType === "complex64") {
    return false;
  }
  if (newType === "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "bool" && oldType === "bool") {
    return false;
  }
  return true;
}
function isTypedArray(a6) {
  return a6 instanceof Float32Array || a6 instanceof Int32Array || a6 instanceof Uint8Array;
}
function bytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else if (dtype === "bool") {
    return 1;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function bytesFromStringArray(arr) {
  if (arr == null) {
    return 0;
  }
  let bytes = 0;
  arr.forEach((x2) => bytes += x2.length);
  return bytes;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isNumber(value) {
  return typeof value === "number";
}
function inferDtype(values) {
  if (Array.isArray(values)) {
    return inferDtype(values[0]);
  }
  if (values instanceof Float32Array) {
    return "float32";
  } else if (values instanceof Int32Array || values instanceof Uint8Array) {
    return "int32";
  } else if (isNumber(values)) {
    return "float32";
  } else if (isString(values)) {
    return "string";
  } else if (isBoolean(values)) {
    return "bool";
  }
  return "float32";
}
function isFunction(f2) {
  return !!(f2 && f2.constructor && f2.call && f2.apply);
}
function nearestDivisor(size2, start) {
  for (let i2 = start; i2 < size2; ++i2) {
    if (size2 % i2 === 0) {
      return i2;
    }
  }
  return size2;
}
function computeStrides(shape) {
  const rank = shape.length;
  if (rank < 2) {
    return [];
  }
  const strides = new Array(rank - 1);
  strides[rank - 2] = shape[rank - 1];
  for (let i2 = rank - 3; i2 >= 0; --i2) {
    strides[i2] = strides[i2 + 1] * shape[i2 + 1];
  }
  return strides;
}
function createNestedArray(offset, shape, a6, isComplex = false) {
  const ret = new Array();
  if (shape.length === 1) {
    const d2 = shape[0] * (isComplex ? 2 : 1);
    for (let i2 = 0; i2 < d2; i2++) {
      ret[i2] = a6[offset + i2];
    }
  } else {
    const d2 = shape[0];
    const rest = shape.slice(1);
    const len = rest.reduce((acc, c2) => acc * c2) * (isComplex ? 2 : 1);
    for (let i2 = 0; i2 < d2; i2++) {
      ret[i2] = createNestedArray(offset + i2 * len, rest, a6, isComplex);
    }
  }
  return ret;
}
function toNestedArray(shape, a6, isComplex = false) {
  if (shape.length === 0) {
    return a6[0];
  }
  const size2 = shape.reduce((acc, c2) => acc * c2) * (isComplex ? 2 : 1);
  if (size2 === 0) {
    return [];
  }
  if (size2 !== a6.length) {
    throw new Error(`[${shape}] does not match the input size ${a6.length}${isComplex ? " for a complex tensor" : ""}.`);
  }
  return createNestedArray(0, shape, a6, isComplex);
}
function makeOnesTypedArray(size2, dtype) {
  const array2 = makeZerosTypedArray(size2, dtype);
  for (let i2 = 0; i2 < array2.length; i2++) {
    array2[i2] = 1;
  }
  return array2;
}
function makeZerosTypedArray(size2, dtype) {
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(size2);
  } else if (dtype === "int32") {
    return new Int32Array(size2);
  } else if (dtype === "bool") {
    return new Uint8Array(size2);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function makeZerosNestedTypedArray(shape, dtype) {
  const size2 = shape.reduce((prev, curr) => prev * curr, 1);
  if (dtype == null || dtype === "float32") {
    return toNestedArray(shape, new Float32Array(size2));
  } else if (dtype === "int32") {
    return toNestedArray(shape, new Int32Array(size2));
  } else if (dtype === "bool") {
    return toNestedArray(shape, new Uint8Array(size2));
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function assertNonNegativeIntegerDimensions(shape) {
  shape.forEach((dimSize) => {
    assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
  });
}
function locToIndex(locs, rank, strides) {
  if (rank === 0) {
    return 0;
  } else if (rank === 1) {
    return locs[0];
  }
  let index = locs[locs.length - 1];
  for (let i2 = 0; i2 < locs.length - 1; ++i2) {
    index += strides[i2] * locs[i2];
  }
  return index;
}
function indexToLoc(index, rank, strides) {
  if (rank === 0) {
    return [];
  } else if (rank === 1) {
    return [index];
  }
  const locs = new Array(rank);
  for (let i2 = 0; i2 < locs.length - 1; ++i2) {
    locs[i2] = Math.floor(index / strides[i2]);
    index -= locs[i2] * strides[i2];
  }
  locs[locs.length - 1] = index;
  return locs;
}
function isPromise(object2) {
  return object2 && object2.then && typeof object2.then === "function";
}
function warn(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.warn(...msg);
  }
}
function log2(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.log(...msg);
  }
}
var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
var Environment = class {
  constructor(global2) {
    this.global = global2;
    this.flags = {};
    this.flagRegistry = {};
    this.urlFlags = {};
    this.getQueryParams = getQueryParams;
    this.populateURLFlags();
  }
  setPlatform(platformName, platform) {
    if (this.platform != null) {
      warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`);
    }
    this.platformName = platformName;
    this.platform = platform;
  }
  registerFlag(flagName, evaluationFn, setHook) {
    this.flagRegistry[flagName] = { evaluationFn, setHook };
    if (this.urlFlags[flagName] != null) {
      const flagValue = this.urlFlags[flagName];
      warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
      this.set(flagName, flagValue);
    }
  }
  async getAsync(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    this.flags[flagName] = await this.evaluateFlag(flagName);
    return this.flags[flagName];
  }
  get(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    const flagValue = this.evaluateFlag(flagName);
    if (isPromise(flagValue)) {
      throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
    }
    this.flags[flagName] = flagValue;
    return this.flags[flagName];
  }
  getNumber(flagName) {
    return this.get(flagName);
  }
  getBool(flagName) {
    return this.get(flagName);
  }
  getFlags() {
    return this.flags;
  }
  get features() {
    return this.flags;
  }
  set(flagName, value) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
    }
    this.flags[flagName] = value;
    if (this.flagRegistry[flagName].setHook != null) {
      this.flagRegistry[flagName].setHook(value);
    }
  }
  evaluateFlag(flagName) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
    }
    return this.flagRegistry[flagName].evaluationFn();
  }
  setFlags(flags) {
    this.flags = Object.assign({}, flags);
  }
  reset() {
    this.flags = {};
    this.urlFlags = {};
    this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
      return;
    }
    const urlParams = this.getQueryParams(this.global.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
      keyValues.forEach((keyValue) => {
        const [key, value] = keyValue.split(":");
        this.urlFlags[key] = parseValue(key, value);
      });
    }
  }
};
function getQueryParams(queryString) {
  const params = {};
  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s2, ...t2) => {
    decodeParam(params, t2[0], t2[1]);
    return t2.join("=");
  });
  return params;
}
function decodeParam(params, name, value) {
  params[decodeURIComponent(name)] = decodeURIComponent(value || "");
}
function parseValue(flagName, value) {
  value = value.toLowerCase();
  if (value === "true" || value === "false") {
    return value === "true";
  } else if (`${+value}` === value) {
    return +value;
  }
  throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
}
function env() {
  return ENV;
}
var ENV = null;
function setEnvironmentGlobal(environment) {
  ENV = environment;
}
var globalNameSpace;
function getGlobalNamespace() {
  if (globalNameSpace == null) {
    let ns;
    if (typeof window !== "undefined") {
      ns = window;
    } else if (typeof global !== "undefined") {
      ns = global;
    } else if (typeof process !== "undefined") {
      ns = process;
    } else if (typeof self !== "undefined") {
      ns = self;
    } else {
      throw new Error("Could not find a global object");
    }
    globalNameSpace = ns;
  }
  return globalNameSpace;
}
function getGlobalMap() {
  const ns = getGlobalNamespace();
  if (ns._tfGlobals == null) {
    ns._tfGlobals = new Map();
  }
  return ns._tfGlobals;
}
function getGlobal(key, init2) {
  const globalMap = getGlobalMap();
  if (globalMap.has(key)) {
    return globalMap.get(key);
  } else {
    const singleton = init2();
    globalMap.set(key, singleton);
    return globalMap.get(key);
  }
}
var Abs = "Abs";
var Acos = "Acos";
var Acosh = "Acosh";
var Add = "Add";
var AddN = "AddN";
var All = "All";
var Any = "Any";
var ArgMax = "ArgMax";
var ArgMin = "ArgMin";
var Asin = "Asin";
var Asinh = "Asinh";
var Atan = "Atan";
var Atanh = "Atanh";
var Atan2 = "Atan2";
var AvgPool = "AvgPool";
var AvgPoolGrad = "AvgPoolGrad";
var AvgPool3D = "AvgPool3D";
var AvgPool3DGrad = "AvgPool3DGrad";
var BatchMatMul = "BatchMatMul";
var BatchToSpaceND = "BatchToSpaceND";
var Bincount = "Bincount";
var BroadcastTo = "BroadcastTo";
var BroadcastArgs = "BroadcastArgs";
var Cast = "Cast";
var Ceil = "Ceil";
var ClipByValue = "ClipByValue";
var Complex = "Complex";
var ComplexAbs = "ComplexAbs";
var Concat = "Concat";
var Conv2D = "Conv2D";
var Conv2DBackpropFilter = "Conv2DBackpropFilter";
var Conv2DBackpropInput = "Conv2DBackpropInput";
var Conv3D = "Conv3D";
var Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
var Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
var Cos = "Cos";
var Cosh = "Cosh";
var Cumsum = "Cumsum";
var CropAndResize = "CropAndResize";
var DenseBincount = "DenseBincount";
var DepthToSpace = "DepthToSpace";
var DepthwiseConv2dNative = "DepthwiseConv2dNative";
var DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
var DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
var Diag = "Diag";
var Dilation2D = "Dilation2D";
var Dilation2DBackpropInput = "Dilation2DBackpropInput";
var Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
var RealDiv = "RealDiv";
var Einsum = "Einsum";
var Elu = "Elu";
var EluGrad = "EluGrad";
var Erf = "Erf";
var Equal = "Equal";
var Exp = "Exp";
var ExpandDims = "ExpandDims";
var Expm1 = "Expm1";
var FFT = "FFT";
var Fill = "Fill";
var FlipLeftRight = "FlipLeftRight";
var Floor = "Floor";
var FloorDiv = "FloorDiv";
var FusedBatchNorm = "FusedBatchNorm";
var GatherV2 = "GatherV2";
var GatherNd = "GatherNd";
var Greater = "Greater";
var GreaterEqual = "GreaterEqual";
var Identity = "Identity";
var IFFT = "IFFT";
var Imag = "Imag";
var IsFinite = "IsFinite";
var IsInf = "IsInf";
var IsNan = "IsNan";
var LeakyRelu = "LeakyRelu";
var Less = "Less";
var LessEqual = "LessEqual";
var LinSpace = "LinSpace";
var Log = "Log";
var Log1p = "Log1p";
var LogicalAnd = "LogicalAnd";
var LogicalNot = "LogicalNot";
var LogicalOr = "LogicalOr";
var LogSoftmax = "LogSoftmax";
var LRN = "LRN";
var LRNGrad = "LRNGrad";
var Max = "Max";
var Maximum = "Maximum";
var MaxPool = "MaxPool";
var MaxPoolGrad = "MaxPoolGrad";
var MaxPool3D = "MaxPool3D";
var MaxPool3DGrad = "MaxPool3DGrad";
var MaxPoolWithArgmax = "MaxPoolWithArgmax";
var Mean = "Mean";
var Min = "Min";
var Minimum = "Minimum";
var MirrorPad = "MirrorPad";
var Mod = "Mod";
var Multinomial = "Multinomial";
var Multiply = "Multiply";
var Neg = "Neg";
var NotEqual = "NotEqual";
var NonMaxSuppressionV3 = "NonMaxSuppressionV3";
var NonMaxSuppressionV4 = "NonMaxSuppressionV4";
var NonMaxSuppressionV5 = "NonMaxSuppressionV5";
var OnesLike = "OnesLike";
var OneHot = "OneHot";
var Pack = "Pack";
var PadV2 = "PadV2";
var Pool = "Pool";
var Pow = "Pow";
var Prelu = "Prelu";
var Prod = "Prod";
var Range = "Range";
var Real = "Real";
var Reciprocal = "Reciprocal";
var Relu = "Relu";
var Reshape = "Reshape";
var ResizeNearestNeighbor = "ResizeNearestNeighbor";
var ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
var ResizeBilinear = "ResizeBilinear";
var ResizeBilinearGrad = "ResizeBilinearGrad";
var Relu6 = "Relu6";
var Reverse = "Reverse";
var Round = "Round";
var Rsqrt = "Rsqrt";
var ScatterNd = "ScatterNd";
var Select = "Select";
var Selu = "Selu";
var Slice = "Slice";
var Sin = "Sin";
var Sinh = "Sinh";
var Sign = "Sign";
var Sigmoid = "Sigmoid";
var Softplus = "Softplus";
var Sqrt = "Sqrt";
var Sum = "Sum";
var SpaceToBatchND = "SpaceToBatchND";
var SplitV = "SplitV";
var Softmax = "Softmax";
var SparseFillEmptyRows = "SparseFillEmptyRows";
var SparseReshape = "SparseReshape";
var SparseSegmentMean = "SparseSegmentMean";
var SparseSegmentSum = "SparseSegmentSum";
var SparseToDense = "SparseToDense";
var SquaredDifference = "SquaredDifference";
var Square = "Square";
var StridedSlice = "StridedSlice";
var StringNGrams = "StringNGrams";
var StringSplit = "StringSplit";
var StringToHashBucketFast = "StringToHashBucketFast";
var Sub = "Sub";
var Tan = "Tan";
var Tanh = "Tanh";
var Tile = "Tile";
var TopK = "TopK";
var Transform = "Transform";
var Transpose = "Transpose";
var Unique = "Unique";
var Unpack = "Unpack";
var UnsortedSegmentSum = "UnsortedSegmentSum";
var ZerosLike = "ZerosLike";
var Step = "Step";
var FromPixels = "FromPixels";
var RotateWithOffset = "RotateWithOffset";
var _FusedMatMul = "_FusedMatMul";
var FusedConv2D = "FusedConv2D";
var FusedDepthwiseConv2D = "FusedDepthwiseConv2D";
var kernelRegistry = getGlobal("kernelRegistry", () => new Map());
var gradRegistry = getGlobal("gradRegistry", () => new Map());
function getKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  return kernelRegistry.get(key);
}
function getGradient(kernelName) {
  return gradRegistry.get(kernelName);
}
function getKernelsForBackend(backendName) {
  const it = kernelRegistry.entries();
  const result = [];
  while (true) {
    const { done, value } = it.next();
    if (done) {
      break;
    }
    const [key, config3] = value;
    const [backend22] = key.split("_");
    if (backend22 === backendName) {
      result.push(config3);
    }
  }
  return result;
}
function registerKernel(config3) {
  const { kernelName, backendName } = config3;
  const key = makeKey(kernelName, backendName);
  if (kernelRegistry.has(key)) {
    warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
  }
  kernelRegistry.set(key, config3);
}
function registerGradient(config3) {
  const { kernelName } = config3;
  if (gradRegistry.has(kernelName)) {
    if (env().getBool("DEBUG")) {
      warn(`Overriding the gradient for '${kernelName}'`);
    }
  }
  gradRegistry.set(kernelName, config3);
}
function unregisterKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  if (!kernelRegistry.has(key)) {
    throw new Error(`The kernel '${kernelName}' for backend '${backendName}' is not registered`);
  }
  kernelRegistry.delete(key);
}
function unregisterGradient(kernelName) {
  if (!gradRegistry.has(kernelName)) {
    throw new Error(`The gradient '${kernelName}' for backend is not registered`);
  }
  gradRegistry.delete(kernelName);
}
function copyRegisteredKernels(registeredBackendName, newBackendName) {
  const kernels = getKernelsForBackend(registeredBackendName);
  kernels.forEach((kernelConfig) => {
    const newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });
    registerKernel(newKernelConfig);
  });
}
function makeKey(kernelName, backendName) {
  return `${backendName}_${kernelName}`;
}
var util_exports = {};
__export2(util_exports, {
  arraysEqual: () => arraysEqual2,
  assert: () => assert,
  assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
  assertNonNull: () => assertNonNull,
  assertShapesMatch: () => assertShapesMatch,
  bytesFromStringArray: () => bytesFromStringArray,
  bytesPerElement: () => bytesPerElement,
  checkConversionForErrors: () => checkConversionForErrors,
  clamp: () => clamp2,
  computeStrides: () => computeStrides,
  createScalarValue: () => createScalarValue,
  createShuffledIndices: () => createShuffledIndices,
  decodeString: () => decodeString,
  distSquared: () => distSquared,
  encodeString: () => encodeString,
  fetch: () => fetch3,
  fingerPrint64: () => fingerPrint64,
  flatten: () => flatten2,
  getArrayFromDType: () => getArrayFromDType,
  getTypedArrayFromDType: () => getTypedArrayFromDType,
  hasEncodingLoss: () => hasEncodingLoss,
  hexToLong: () => hexToLong,
  indexToLoc: () => indexToLoc,
  inferDtype: () => inferDtype,
  inferFromImplicitShape: () => inferFromImplicitShape,
  isBoolean: () => isBoolean,
  isFunction: () => isFunction,
  isInt: () => isInt,
  isNumber: () => isNumber,
  isPromise: () => isPromise,
  isScalarShape: () => isScalarShape,
  isString: () => isString,
  isTypedArray: () => isTypedArray,
  isValidDtype: () => isValidDtype,
  locToIndex: () => locToIndex,
  makeOnesTypedArray: () => makeOnesTypedArray,
  makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
  makeZerosTypedArray: () => makeZerosTypedArray,
  nearestDivisor: () => nearestDivisor,
  nearestLargerEven: () => nearestLargerEven,
  now: () => now22,
  parseAxisParam: () => parseAxisParam,
  randUniform: () => randUniform,
  repeatedTry: () => repeatedTry,
  rightPad: () => rightPad,
  shuffle: () => shuffle,
  shuffleCombo: () => shuffleCombo,
  sizeFromShape: () => sizeFromShape,
  sizeToSquarishShape: () => sizeToSquarishShape,
  squeezeShape: () => squeezeShape,
  sum: () => sum,
  swap: () => swap,
  tanh: () => tanh,
  toNestedArray: () => toNestedArray,
  toTypedArray: () => toTypedArray
});
var LongExports = __toModule(require_long());
var Long = LongExports.default || LongExports;
function hexToLong(hex) {
  return Long.fromString(hex, true, 16);
}
var k0 = hexToLong("c3a5c85c97cb3127");
var k1 = hexToLong("b492b66fbe98f273");
var k2 = hexToLong("9ae16a3b2f90404f");
function shiftMix(val) {
  return val.xor(val.shru(47));
}
function fetch2(s2, offset, numBytes) {
  const bytes = s2.slice(offset, offset + numBytes);
  return Long.fromBytes(Array.from(bytes), true, true);
}
function fetch64(s2, offset) {
  return fetch2(s2, offset, 8);
}
function fetch32(s2, offset) {
  return fetch2(s2, offset, 4);
}
function rotate64(val, shift) {
  return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
}
function hashLen16(u2, v2, mul2 = hexToLong("9ddfea08eb382d69")) {
  let a6 = u2.xor(v2).mul(mul2);
  a6 = a6.xor(a6.shru(47));
  let b2 = v2.xor(a6).mul(mul2);
  b2 = b2.xor(b2.shru(47));
  b2 = b2.mul(mul2);
  return b2;
}
function weakHashLen32WithSeeds(w2, x2, y2, z2, a6, b2) {
  a6 = a6.add(w2);
  b2 = rotate64(b2.add(a6).add(z2), 21);
  const c2 = a6;
  a6 = a6.add(x2);
  a6 = a6.add(y2);
  b2 = b2.add(rotate64(a6, 44));
  return [a6.add(z2), b2.add(c2)];
}
function weakHashLen32WithSeedsStr(s2, offset, a6, b2) {
  return weakHashLen32WithSeeds(fetch64(s2, offset), fetch64(s2, offset + 8), fetch64(s2, offset + 16), fetch64(s2, offset + 24), a6, b2);
}
function hashLen0to16(s2, len = s2.length) {
  if (len >= 8) {
    const mul2 = k2.add(len * 2);
    const a6 = fetch64(s2, 0).add(k2);
    const b2 = fetch64(s2, len - 8);
    const c2 = rotate64(b2, 37).mul(mul2).add(a6);
    const d2 = rotate64(a6, 25).add(b2).mul(mul2);
    return hashLen16(c2, d2, mul2);
  }
  if (len >= 4) {
    const mul2 = k2.add(len * 2);
    const a6 = fetch32(s2, 0);
    return hashLen16(a6.shl(3).add(len), fetch32(s2, len - 4), mul2);
  }
  if (len > 0) {
    const a6 = s2[0];
    const b2 = s2[len >> 1];
    const c2 = s2[len - 1];
    const y2 = a6 + (b2 << 8);
    const z2 = len + (c2 << 2);
    return shiftMix(k2.mul(y2).xor(k0.mul(z2))).mul(k2);
  }
  return k2;
}
function hashLen17to32(s2, len = s2.length) {
  const mul2 = k2.add(len * 2);
  const a6 = fetch64(s2, 0).mul(k1);
  const b2 = fetch64(s2, 8);
  const c2 = fetch64(s2, len - 8).mul(mul2);
  const d2 = fetch64(s2, len - 16).mul(k2);
  return hashLen16(rotate64(a6.add(b2), 43).add(rotate64(c2, 30)).add(d2), a6.add(rotate64(b2.add(k2), 18)).add(c2), mul2);
}
function hashLen33to64(s2, len = s2.length) {
  const mul2 = k2.add(len * 2);
  const a6 = fetch64(s2, 0).mul(k2);
  const b2 = fetch64(s2, 8);
  const c2 = fetch64(s2, len - 8).mul(mul2);
  const d2 = fetch64(s2, len - 16).mul(k2);
  const y2 = rotate64(a6.add(b2), 43).add(rotate64(c2, 30)).add(d2);
  const z2 = hashLen16(y2, a6.add(rotate64(b2.add(k2), 18)).add(c2), mul2);
  const e2 = fetch64(s2, 16).mul(mul2);
  const f2 = fetch64(s2, 24);
  const g2 = y2.add(fetch64(s2, len - 32)).mul(mul2);
  const h2 = z2.add(fetch64(s2, len - 24)).mul(mul2);
  return hashLen16(rotate64(e2.add(f2), 43).add(rotate64(g2, 30)).add(h2), e2.add(rotate64(f2.add(a6), 18)).add(g2), mul2);
}
function fingerPrint64(s2, len = s2.length) {
  const seed = Long.fromNumber(81, true);
  if (len <= 32) {
    if (len <= 16) {
      return hashLen0to16(s2, len);
    } else {
      return hashLen17to32(s2, len);
    }
  } else if (len <= 64) {
    return hashLen33to64(s2, len);
  }
  let x2 = seed;
  let y2 = seed.mul(k1).add(113);
  let z2 = shiftMix(y2.mul(k2).add(113)).mul(k2);
  let v2 = [Long.UZERO, Long.UZERO];
  let w2 = [Long.UZERO, Long.UZERO];
  x2 = x2.mul(k2).add(fetch64(s2, 0));
  let offset = 0;
  const end = (len - 1 >> 6) * 64;
  const last64 = end + (len - 1 & 63) - 63;
  do {
    x2 = rotate64(x2.add(y2).add(v2[0]).add(fetch64(s2, offset + 8)), 37).mul(k1);
    y2 = rotate64(y2.add(v2[1]).add(fetch64(s2, offset + 48)), 42).mul(k1);
    x2 = x2.xor(w2[1]);
    y2 = y2.add(v2[0]).add(fetch64(s2, offset + 40));
    z2 = rotate64(z2.add(w2[0]), 33).mul(k1);
    v2 = weakHashLen32WithSeedsStr(s2, offset, v2[1].mul(k1), x2.add(w2[0]));
    w2 = weakHashLen32WithSeedsStr(s2, offset + 32, z2.add(w2[1]), y2.add(fetch64(s2, offset + 16)));
    [z2, x2] = [x2, z2];
    offset += 64;
  } while (offset !== end);
  const mul2 = k1.add(z2.and(255).shl(1));
  offset = last64;
  w2[0] = w2[0].add(len - 1 & 63);
  v2[0] = v2[0].add(w2[0]);
  w2[0] = w2[0].add(v2[0]);
  x2 = rotate64(x2.add(y2).add(v2[0]).add(fetch64(s2, offset + 8)), 37).mul(mul2);
  y2 = rotate64(y2.add(v2[1]).add(fetch64(s2, offset + 48)), 42).mul(mul2);
  x2 = x2.xor(w2[1].mul(9));
  y2 = y2.add(v2[0].mul(9).add(fetch64(s2, offset + 40)));
  z2 = rotate64(z2.add(w2[0]), 33).mul(mul2);
  v2 = weakHashLen32WithSeedsStr(s2, offset, v2[1].mul(mul2), x2.add(w2[0]));
  w2 = weakHashLen32WithSeedsStr(s2, offset + 32, z2.add(w2[1]), y2.add(fetch64(s2, offset + 16)));
  [z2, x2] = [x2, z2];
  return hashLen16(hashLen16(v2[0], w2[0], mul2).add(shiftMix(y2).mul(k0)).add(z2), hashLen16(v2[1], w2[1], mul2).add(x2), mul2);
}
function createScalarValue(value, dtype) {
  if (dtype === "string") {
    return encodeString(value);
  }
  return toTypedArray([value], dtype);
}
function noConversionNeeded(a6, dtype) {
  return a6 instanceof Float32Array && dtype === "float32" || a6 instanceof Int32Array && dtype === "int32" || a6 instanceof Uint8Array && dtype === "bool";
}
function toTypedArray(a6, dtype) {
  if (dtype === "string") {
    throw new Error("Cannot convert a string[] to a TypedArray");
  }
  if (Array.isArray(a6)) {
    a6 = flatten2(a6);
  }
  if (env().getBool("DEBUG")) {
    checkConversionForErrors(a6, dtype);
  }
  if (noConversionNeeded(a6, dtype)) {
    return a6;
  }
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(a6);
  } else if (dtype === "int32") {
    return new Int32Array(a6);
  } else if (dtype === "bool") {
    const bool = new Uint8Array(a6.length);
    for (let i2 = 0; i2 < bool.length; ++i2) {
      if (Math.round(a6[i2]) !== 0) {
        bool[i2] = 1;
      }
    }
    return bool;
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function now22() {
  return env().platform.now();
}
function fetch3(path, requestInits) {
  return env().platform.fetch(path, requestInits);
}
function encodeString(s2, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.encode(s2, encoding);
}
function decodeString(bytes, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.decode(bytes, encoding);
}
var Profiler = class {
  constructor(backendTimer, logger) {
    this.backendTimer = backendTimer;
    this.logger = logger;
    if (logger == null) {
      this.logger = new Logger();
    }
  }
  profileKernel(kernelName, inputs, f2) {
    let outputs;
    const holdResultWrapperFn = () => {
      outputs = f2();
    };
    let timer;
    const start = now22();
    if (this.backendTimer.timerAvailable()) {
      timer = this.backendTimer.time(holdResultWrapperFn);
    } else {
      holdResultWrapperFn();
      for (const output of outputs) {
        output.dataSync();
      }
      timer = Promise.resolve({ kernelMs: now22() - start });
    }
    if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
      for (let i2 = 0; i2 < outputs.length; i2++) {
        const output = outputs[i2];
        output.data().then((tensorVals) => {
          checkComputationForErrors(tensorVals, output.dtype, kernelName);
        });
      }
    }
    const kernelProfile = {
      kernelName,
      outputs,
      inputs,
      timeMs: timer.then((timing) => timing.kernelMs),
      extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
    };
    return kernelProfile;
  }
  logKernelProfile(kernelProfile) {
    const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
    outputs.forEach((result) => {
      Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
        this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
      });
    });
  }
};
function checkComputationForErrors(vals, dtype, kernelName) {
  if (dtype !== "float32") {
    return false;
  }
  for (let i2 = 0; i2 < vals.length; i2++) {
    const num = vals[i2];
    if (isNaN(num) || !isFinite(num)) {
      console.warn(`Found ${num} in the result of '${kernelName}'`);
      return true;
    }
  }
  return false;
}
var Logger = class {
  logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
    const time2 = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
    const paddedName = rightPad(name, 25);
    const rank = result.rank;
    const size2 = result.size;
    const shape = rightPad(result.shape.toString(), 14);
    let inputShapesDescription = "";
    for (const name2 in inputs) {
      const input2 = inputs[name2];
      if (input2 != null) {
        const inputShape = input2.shape || result.shape;
        const inputRank = inputShape.length;
        inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
      }
    }
    console.log(`%c${paddedName}	%c${time2}	%c${rank}D ${shape}	%c${size2}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
};
function getFilteredNodesXToY(tape, xs, y2) {
  const tensorsFromX = {};
  const nodesFromX = {};
  for (let i2 = 0; i2 < xs.length; i2++) {
    tensorsFromX[xs[i2].id] = true;
  }
  for (let i2 = 0; i2 < tape.length; i2++) {
    const node2 = tape[i2];
    const nodeInputs = node2.inputs;
    for (const inputName in nodeInputs) {
      const input2 = nodeInputs[inputName];
      let anyInputFromX = false;
      for (let j2 = 0; j2 < xs.length; j2++) {
        if (tensorsFromX[input2.id]) {
          node2.outputs.forEach((output) => tensorsFromX[output.id] = true);
          anyInputFromX = true;
          nodesFromX[node2.id] = true;
          break;
        }
      }
      if (anyInputFromX) {
        break;
      }
    }
  }
  const tensorsLeadToY = {};
  tensorsLeadToY[y2.id] = true;
  const nodesToY = {};
  for (let i2 = tape.length - 1; i2 >= 0; i2--) {
    const node2 = tape[i2];
    const nodeInputs = node2.inputs;
    for (let j2 = 0; j2 < node2.outputs.length; j2++) {
      if (tensorsLeadToY[node2.outputs[j2].id]) {
        for (const inputName in nodeInputs) {
          tensorsLeadToY[nodeInputs[inputName].id] = true;
          nodesToY[node2.id] = true;
        }
        break;
      }
    }
  }
  const filteredTape = [];
  for (let i2 = 0; i2 < tape.length; i2++) {
    const node2 = tape[i2];
    if (nodesFromX[node2.id] && nodesToY[node2.id]) {
      const prunedInputs = {};
      for (const inputName in node2.inputs) {
        const nodeInput = node2.inputs[inputName];
        if (tensorsFromX[nodeInput.id]) {
          prunedInputs[inputName] = nodeInput;
        }
      }
      const prunedNode = Object.assign({}, node2);
      prunedNode.inputs = prunedInputs;
      prunedNode.outputs = node2.outputs;
      filteredTape.push(prunedNode);
    }
  }
  return filteredTape;
}
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy2, add5) {
  for (let i2 = filteredTape.length - 1; i2 >= 0; i2--) {
    const node2 = filteredTape[i2];
    const dys = [];
    node2.outputs.forEach((o2) => {
      const gradTensor = tensorAccumulatedGradientMap[o2.id];
      if (gradTensor != null) {
        dys.push(gradTensor);
      } else {
        dys.push(null);
      }
    });
    if (node2.gradient == null) {
      throw new Error(`Cannot compute gradient: gradient function not found for ${node2.kernelName}.`);
    }
    const inputGradients = node2.gradient(dys);
    for (const inputName in node2.inputs) {
      if (!(inputName in inputGradients)) {
        throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
      }
      const dx = tidy2(() => inputGradients[inputName]());
      if (dx.dtype !== "float32") {
        throw new Error(`Error in gradient for op ${node2.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
      }
      const x2 = node2.inputs[inputName];
      if (!arraysEqual2(dx.shape, x2.shape)) {
        throw new Error(`Error in gradient for op ${node2.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x2.shape}'`);
      }
      if (tensorAccumulatedGradientMap[x2.id] == null) {
        tensorAccumulatedGradientMap[x2.id] = dx;
      } else {
        const curGradient = tensorAccumulatedGradientMap[x2.id];
        tensorAccumulatedGradientMap[x2.id] = add5(curGradient, dx);
        curGradient.dispose();
      }
    }
  }
}
var FORMAT_LIMIT_NUM_VALS = 20;
var FORMAT_NUM_FIRST_LAST_VALS = 3;
var FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(vals, shape, dtype, verbose) {
  const strides = computeStrides(shape);
  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
  const rank = shape.length;
  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
  const lines2 = ["Tensor"];
  if (verbose) {
    lines2.push(`  dtype: ${dtype}`);
    lines2.push(`  rank: ${rank}`);
    lines2.push(`  shape: [${shape}]`);
    lines2.push(`  values:`);
  }
  lines2.push(valsLines.map((l3) => "    " + l3).join("\n"));
  return lines2.join("\n");
}
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
  const n2 = sizeFromShape(shape);
  const numCols = strides[strides.length - 1];
  const padPerCol = new Array(numCols).fill(0);
  const rank = shape.length;
  const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
  if (rank > 1) {
    for (let row = 0; row < n2 / numCols; row++) {
      const offset = row * numCols;
      for (let j2 = 0; j2 < numCols; j2++) {
        padPerCol[j2] = Math.max(padPerCol[j2], valToString(valuesOrTuples[offset + j2], 0, dtype).length);
      }
    }
  }
  return padPerCol;
}
function valToString(val, pad3, dtype) {
  let valStr;
  if (Array.isArray(val)) {
    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
  } else if (isString(val)) {
    valStr = `'${val}'`;
  } else if (dtype === "bool") {
    valStr = boolNumToString(val);
  } else {
    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
  }
  return rightPad(valStr, pad3);
}
function boolNumToString(v2) {
  return v2 === 0 ? "false" : "true";
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
  const storagePerElement = dtype === "complex64" ? 2 : 1;
  const size2 = shape[0];
  const rank = shape.length;
  if (rank === 0) {
    if (dtype === "complex64") {
      const complexTuple = createComplexTuples(vals);
      return [valToString(complexTuple[0], 0, dtype)];
    }
    if (dtype === "bool") {
      return [boolNumToString(vals[0])];
    }
    return [vals[0].toString()];
  }
  if (rank === 1) {
    if (size2 > FORMAT_LIMIT_NUM_VALS) {
      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
      let firstVals = Array.from(vals.slice(0, firstValsSize));
      let lastVals = Array.from(vals.slice((size2 - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size2 * storagePerElement));
      if (dtype === "complex64") {
        firstVals = createComplexTuples(firstVals);
        lastVals = createComplexTuples(lastVals);
      }
      return [
        "[" + firstVals.map((x2, i2) => valToString(x2, padPerCol[i2], dtype)).join(", ") + ", ..., " + lastVals.map((x2, i2) => valToString(x2, padPerCol[size2 - FORMAT_NUM_FIRST_LAST_VALS + i2], dtype)).join(", ") + "]"
      ];
    }
    const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
    return [
      "[" + displayVals.map((x2, i2) => valToString(x2, padPerCol[i2], dtype)).join(", ") + "]"
    ];
  }
  const subshape = shape.slice(1);
  const substrides = strides.slice(1);
  const stride = strides[0] * storagePerElement;
  const lines2 = [];
  if (size2 > FORMAT_LIMIT_NUM_VALS) {
    for (let i2 = 0; i2 < FORMAT_NUM_FIRST_LAST_VALS; i2++) {
      const start = i2 * stride;
      const end = start + stride;
      lines2.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
    }
    lines2.push("...");
    for (let i2 = size2 - FORMAT_NUM_FIRST_LAST_VALS; i2 < size2; i2++) {
      const start = i2 * stride;
      const end = start + stride;
      lines2.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i2 === size2 - 1));
    }
  } else {
    for (let i2 = 0; i2 < size2; i2++) {
      const start = i2 * stride;
      const end = start + stride;
      lines2.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i2 === size2 - 1));
    }
  }
  const sep = rank === 2 ? "," : "";
  lines2[0] = "[" + lines2[0] + sep;
  for (let i2 = 1; i2 < lines2.length - 1; i2++) {
    lines2[i2] = " " + lines2[i2] + sep;
  }
  let newLineSep = ",\n";
  for (let i2 = 2; i2 < rank; i2++) {
    newLineSep += "\n";
  }
  lines2[lines2.length - 1] = " " + lines2[lines2.length - 1] + "]" + (isLast ? "" : newLineSep);
  return lines2;
}
function createComplexTuples(vals) {
  const complexTuples = [];
  for (let i2 = 0; i2 < vals.length; i2 += 2) {
    complexTuples.push([vals[i2], vals[i2 + 1]]);
  }
  return complexTuples;
}
var TensorBuffer = class {
  constructor(shape, dtype, values) {
    this.dtype = dtype;
    this.shape = shape.slice();
    this.size = sizeFromShape(shape);
    if (values != null) {
      const n2 = values.length;
      assert(n2 === this.size, () => `Length of values '${n2}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (dtype === "complex64") {
      throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
    }
    this.values = values || getArrayFromDType(dtype, this.size);
    this.strides = computeStrides(shape);
  }
  set(value, ...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
    const index = this.locToIndex(locs);
    this.values[index] = value;
  }
  get(...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    let i2 = 0;
    for (const loc of locs) {
      if (loc < 0 || loc >= this.shape[i2]) {
        const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
        throw new Error(msg);
      }
      i2++;
    }
    let index = locs[locs.length - 1];
    for (let i22 = 0; i22 < locs.length - 1; ++i22) {
      index += this.strides[i22] * locs[i22];
    }
    return this.values[index];
  }
  locToIndex(locs) {
    if (this.rank === 0) {
      return 0;
    } else if (this.rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      index += this.strides[i2] * locs[i2];
    }
    return index;
  }
  indexToLoc(index) {
    if (this.rank === 0) {
      return [];
    } else if (this.rank === 1) {
      return [index];
    }
    const locs = new Array(this.shape.length);
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      locs[i2] = Math.floor(index / this.strides[i2]);
      index -= locs[i2] * this.strides[i2];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  get rank() {
    return this.shape.length;
  }
  toTensor() {
    return trackerFn().makeTensor(this.values, this.shape, this.dtype);
  }
};
var trackerFn = null;
var opHandler = null;
var deprecationWarningFn = null;
function setTensorTracker(fn) {
  trackerFn = fn;
}
function setOpHandler(handler) {
  opHandler = handler;
}
function setDeprecationWarningFn(fn) {
  deprecationWarningFn = fn;
}
var Tensor = class {
  constructor(shape, dtype, dataId, id) {
    this.kept = false;
    this.isDisposedInternal = false;
    this.shape = shape.slice();
    this.dtype = dtype || "float32";
    this.size = sizeFromShape(shape);
    this.strides = computeStrides(shape);
    this.dataId = dataId;
    this.id = id;
    this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  async buffer() {
    const vals = await this.data();
    return opHandler.buffer(this.shape, this.dtype, vals);
  }
  bufferSync() {
    return opHandler.buffer(this.shape, this.dtype, this.dataSync());
  }
  async array() {
    const vals = await this.data();
    return toNestedArray(this.shape, vals, this.dtype === "complex64");
  }
  arraySync() {
    return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  async data() {
    this.throwIfDisposed();
    const data = trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      const bytes = await data;
      try {
        return bytes.map((b2) => decodeString(b2));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  dataSync() {
    this.throwIfDisposed();
    const data = trackerFn().readSync(this.dataId);
    if (this.dtype === "string") {
      try {
        return data.map((b2) => decodeString(b2));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  async bytes() {
    this.throwIfDisposed();
    const data = await trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      return data;
    } else {
      return new Uint8Array(data.buffer);
    }
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    trackerFn().disposeTensor(this);
    this.isDisposedInternal = true;
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed) {
      throw new Error(`Tensor is disposed.`);
    }
  }
  print(verbose = false) {
    return opHandler.print(this, verbose);
  }
  clone() {
    this.throwIfDisposed();
    return opHandler.clone(this);
  }
  toString(verbose = false) {
    const vals = this.dataSync();
    return tensorToString(vals, this.shape, this.dtype, verbose);
  }
  cast(dtype) {
    this.throwIfDisposed();
    return opHandler.cast(this, dtype);
  }
  variable(trainable = true, name, dtype) {
    this.throwIfDisposed();
    return trackerFn().makeVariable(this, trainable, name, dtype);
  }
};
Object.defineProperty(Tensor, Symbol.hasInstance, {
  value: (instance) => {
    return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
  }
});
function getGlobalTensorClass() {
  return getGlobal("Tensor", () => {
    return Tensor;
  });
}
getGlobalTensorClass();
var Variable = class extends Tensor {
  constructor(initialValue, trainable, name, tensorId) {
    super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
    this.trainable = trainable;
    this.name = name;
  }
  assign(newValue) {
    if (newValue.dtype !== this.dtype) {
      throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
    }
    if (!arraysEqual2(newValue.shape, this.shape)) {
      throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
    }
    trackerFn().disposeTensor(this);
    this.dataId = newValue.dataId;
    trackerFn().incRef(this, null);
  }
  dispose() {
    trackerFn().disposeVariable(this);
    this.isDisposedInternal = true;
  }
};
Object.defineProperty(Variable, Symbol.hasInstance, {
  value: (instance) => {
    return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
  }
});
var tensor_util_exports = {};
__export2(tensor_util_exports, {
  assertTypesMatch: () => assertTypesMatch,
  getTensorsInContainer: () => getTensorsInContainer,
  isTensorInList: () => isTensorInList,
  makeTypesMatch: () => makeTypesMatch
});
var Rank;
(function(Rank2) {
  Rank2["R0"] = "R0";
  Rank2["R1"] = "R1";
  Rank2["R2"] = "R2";
  Rank2["R3"] = "R3";
  Rank2["R4"] = "R4";
  Rank2["R5"] = "R5";
  Rank2["R6"] = "R6";
})(Rank || (Rank = {}));
var UpcastInt32AndMap;
(function(UpcastInt32AndMap2) {
  UpcastInt32AndMap2["float32"] = "float32";
  UpcastInt32AndMap2["int32"] = "int32";
  UpcastInt32AndMap2["bool"] = "int32";
  UpcastInt32AndMap2["complex64"] = "complex64";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function(UpcastBoolAndMap2) {
  UpcastBoolAndMap2["float32"] = "float32";
  UpcastBoolAndMap2["int32"] = "int32";
  UpcastBoolAndMap2["bool"] = "bool";
  UpcastBoolAndMap2["complex64"] = "complex64";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function(UpcastFloat32AndMap2) {
  UpcastFloat32AndMap2["float32"] = "float32";
  UpcastFloat32AndMap2["int32"] = "float32";
  UpcastFloat32AndMap2["bool"] = "float32";
  UpcastFloat32AndMap2["complex64"] = "complex64";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var UpcastComplex64AndMap;
(function(UpcastComplex64AndMap2) {
  UpcastComplex64AndMap2["float32"] = "complex64";
  UpcastComplex64AndMap2["int32"] = "complex64";
  UpcastComplex64AndMap2["bool"] = "complex64";
  UpcastComplex64AndMap2["complex64"] = "complex64";
})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
var upcastTypeMap = {
  "float32": UpcastFloat32AndMap,
  "int32": UpcastInt32AndMap,
  "bool": UpcastBoolAndMap,
  "complex64": UpcastComplex64AndMap
};
function upcastType(typeA, typeB) {
  if (typeA === "string" || typeB === "string") {
    if (typeA === "string" && typeB === "string") {
      return "string";
    }
    throw new Error(`Can not upcast ${typeA} with ${typeB}`);
  }
  return upcastTypeMap[typeA][typeB];
}
function sumOutType(type) {
  return upcastType(type, "int32");
}
function makeTypesMatch(a6, b2) {
  if (a6.dtype === b2.dtype) {
    return [a6, b2];
  }
  const dtype = upcastType(a6.dtype, b2.dtype);
  return [a6.cast(dtype), b2.cast(dtype)];
}
function assertTypesMatch(a6, b2) {
  assert(a6.dtype === b2.dtype, () => `The dtypes of the first(${a6.dtype}) and second(${b2.dtype}) input must match`);
}
function isTensorInList(tensor2, tensorList) {
  return tensorList.some((x2) => x2.id === tensor2.id);
}
function getTensorsInContainer(result) {
  const list = [];
  const seen = new Set();
  walkTensorContainer(result, list, seen);
  return list;
}
function walkTensorContainer(container, list, seen) {
  if (container == null) {
    return;
  }
  if (container instanceof Tensor) {
    list.push(container);
    return;
  }
  if (!isIterable(container)) {
    return;
  }
  const iterable = container;
  for (const k3 in iterable) {
    const val = iterable[k3];
    if (!seen.has(val)) {
      seen.add(val);
      walkTensorContainer(val, list, seen);
    }
  }
}
function isIterable(obj) {
  return Array.isArray(obj) || typeof obj === "object";
}
function isRegisteredKernelInvocation(kernelInvocation) {
  return kernelInvocation.kernelName != null;
}
var EngineState = class {
  constructor() {
    this.registeredVariables = {};
    this.nextTapeNodeId = 0;
    this.numBytes = 0;
    this.numTensors = 0;
    this.numStringTensors = 0;
    this.numDataBuffers = 0;
    this.gradientDepth = 0;
    this.kernelDepth = 0;
    this.scopeStack = [];
    this.numDataMovesStack = [];
    this.nextScopeId = 0;
    this.tensorInfo = new WeakMap();
    this.profiling = false;
    this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((k3) => k3.name)));
      }
    };
  }
  dispose() {
    for (const variableName in this.registeredVariables) {
      this.registeredVariables[variableName].dispose();
    }
  }
};
var Engine = class {
  constructor(ENV6) {
    this.ENV = ENV6;
    this.registry = {};
    this.registryFactory = {};
    this.pendingBackendInitId = 0;
    this.state = new EngineState();
  }
  async ready() {
    if (this.pendingBackendInit != null) {
      return this.pendingBackendInit.then(() => {
      });
    }
    if (this.backendInstance != null) {
      return;
    }
    const sortedBackends = this.getSortedBackends();
    for (let i2 = 0; i2 < sortedBackends.length; i2++) {
      const backendName = sortedBackends[i2];
      const success = await this.initializeBackend(backendName).success;
      if (success) {
        await this.setBackend(backendName);
        return;
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  get backend() {
    if (this.pendingBackendInit != null) {
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    }
    if (this.backendInstance == null) {
      const { name, asyncInit } = this.initializeBackendsAndReturnBest();
      if (asyncInit) {
        throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      this.setBackend(name);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(backendName) {
    if (!(backendName in this.registry)) {
      if (backendName in this.registryFactory) {
        const { asyncInit } = this.initializeBackend(backendName);
        if (asyncInit) {
          return null;
        }
      } else {
        return null;
      }
    }
    return this.registry[backendName];
  }
  findBackendFactory(backendName) {
    if (!(backendName in this.registryFactory)) {
      return null;
    }
    return this.registryFactory[backendName].factory;
  }
  registerBackend(backendName, factory, priority = 1) {
    if (backendName in this.registryFactory) {
      warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
      return false;
    }
    this.registryFactory[backendName] = { factory, priority };
    return true;
  }
  async setBackend(backendName) {
    if (this.registryFactory[backendName] == null) {
      throw new Error(`Backend name '${backendName}' not found in registry`);
    }
    this.backendName = backendName;
    if (this.registry[backendName] == null) {
      this.backendInstance = null;
      const { success, asyncInit } = this.initializeBackend(backendName);
      const result = asyncInit ? await success : success;
      if (!result) {
        return false;
      }
    }
    this.backendInstance = this.registry[backendName];
    this.setupRegisteredKernels();
    this.profiler = new Profiler(this.backendInstance);
    return true;
  }
  setupRegisteredKernels() {
    const kernels = getKernelsForBackend(this.backendName);
    kernels.forEach((kernel) => {
      if (kernel.setupFunc != null) {
        kernel.setupFunc(this.backendInstance);
      }
    });
  }
  disposeRegisteredKernels(backendName) {
    const kernels = getKernelsForBackend(backendName);
    kernels.forEach((kernel) => {
      if (kernel.disposeFunc != null) {
        kernel.disposeFunc(this.registry[backendName]);
      }
    });
  }
  initializeBackend(backendName) {
    const registryFactoryEntry = this.registryFactory[backendName];
    if (registryFactoryEntry == null) {
      throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
    }
    try {
      const backend22 = registryFactoryEntry.factory();
      if (backend22 && !(backend22 instanceof KernelBackend) && typeof backend22.then === "function") {
        const promiseId = ++this.pendingBackendInitId;
        const success = backend22.then((backendInstance) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.registry[backendName] = backendInstance;
          this.pendingBackendInit = null;
          return true;
        }).catch((err) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.pendingBackendInit = null;
          warn(`Initialization of backend ${backendName} failed`);
          warn(err.stack || err.message);
          return false;
        });
        this.pendingBackendInit = success;
        return { success, asyncInit: true };
      } else {
        this.registry[backendName] = backend22;
        return { success: true, asyncInit: false };
      }
    } catch (err) {
      warn(`Initialization of backend ${backendName} failed`);
      warn(err.stack || err.message);
      return { success: false, asyncInit: false };
    }
  }
  removeBackend(backendName) {
    if (!(backendName in this.registryFactory)) {
      throw new Error(`${backendName} backend not found in registry`);
    }
    if (this.backendName === backendName && this.pendingBackendInit != null) {
      this.pendingBackendInitId++;
    }
    if (backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    delete this.registryFactory[backendName];
    if (this.backendName === backendName) {
      this.pendingBackendInit = null;
      this.backendName = null;
      this.backendInstance = null;
    }
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0) {
      throw new Error("No backend found in registry.");
    }
    return Object.keys(this.registryFactory).sort((a6, b2) => {
      return this.registryFactory[b2].priority - this.registryFactory[a6].priority;
    });
  }
  initializeBackendsAndReturnBest() {
    const sortedBackends = this.getSortedBackends();
    for (let i2 = 0; i2 < sortedBackends.length; i2++) {
      const backendName = sortedBackends[i2];
      const { success, asyncInit } = this.initializeBackend(backendName);
      if (asyncInit || success) {
        return { name: backendName, asyncInit };
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  moveData(backend22, dataId) {
    const info = this.state.tensorInfo.get(dataId);
    const srcBackend = info.backend;
    const values = this.readSync(dataId);
    const refCount = srcBackend.refCount(dataId);
    srcBackend.disposeData(dataId, true);
    info.backend = backend22;
    backend22.move(dataId, values, info.shape, info.dtype, refCount);
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
  }
  tidy(nameOrFn, fn) {
    let name = null;
    if (fn == null) {
      if (typeof nameOrFn !== "function") {
        throw new Error("Please provide a function to tidy()");
      }
      fn = nameOrFn;
    } else {
      if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      }
      name = nameOrFn;
    }
    let result;
    return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
      result = fn();
      if (result instanceof Promise) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      return result;
    });
  }
  scopedRun(start, end, f2) {
    start();
    try {
      const res2 = f2();
      end();
      return res2;
    } catch (ex) {
      end();
      throw ex;
    }
  }
  nextTensorId() {
    return Engine.nextTensorId++;
  }
  nextVariableId() {
    return Engine.nextVariableId++;
  }
  clone(x2) {
    const y2 = ENGINE.runKernel(Identity, { x: x2 });
    const inputs = { x: x2 };
    const grad2 = (dy) => ({
      x: () => {
        const dtype = "float32";
        const gradInputs = { x: dy };
        const attrs = { dtype };
        return ENGINE.runKernel(Cast, gradInputs, attrs);
      }
    });
    const saved = [];
    this.addTapeNode(this.state.activeScope.name, inputs, [y2], grad2, saved, {});
    return y2;
  }
  runKernel(kernelName, inputs, attrs) {
    if (this.backendName == null) {
      this.backend;
    }
    const hasKernel = getKernel(kernelName, this.backendName) != null;
    if (!hasKernel) {
      throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
    }
    return this.runKernelFunc({ kernelName, inputs, attrs });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
    const numDataIdsAfter = this.backend.numDataIds();
    let numOutputDataIds = 0;
    outInfos.forEach((info) => {
      numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
    });
    const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
    if (dataIdsLeaked > 0) {
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
    }
  }
  runKernelFunc(kernelParams) {
    let outputs;
    let saved = [];
    const isTapeOn = this.isTapeOn();
    const startingBytecount = this.state.numBytes;
    const startingNumTensors = this.state.numTensors;
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack.push(0);
    }
    let kernelFunc3;
    if (this.backendName == null) {
      this.backend;
    }
    let out;
    const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (isRegisteredKernelInvocation(kernelParams)) {
      const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
      if (this.backendName == null) {
        this.backend;
      }
      const kernel = getKernel(kernelName, this.backendName);
      assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
      kernelFunc3 = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
        const outInfos = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
        }
        const outTensors = outInfos.map((outInfo) => {
          if (outInfo.rank != null) {
            return outInfo;
          }
          const { dataId, shape, dtype } = outInfo;
          return this.makeTensorFromDataId(dataId, shape, dtype);
        });
        if (isTapeOn) {
          const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
          saved = this.saveTensorsForBackwardMode(tensorsToSave);
        }
        return outTensors;
      };
    } else {
      const { forwardFunc } = kernelParams;
      const saveFunc = (tensors) => {
        if (!isTapeOn) {
          return;
        }
        saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
      };
      kernelFunc3 = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = this.tidy(() => forwardFunc(this.backend, saveFunc));
        const outs = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
        }
        return outs;
      };
    }
    const { inputs, attrs } = kernelParams;
    const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
    let kernelProfile;
    this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
        outputs = kernelFunc3();
      } else {
        kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc3());
        if (this.ENV.getBool("DEBUG")) {
          this.profiler.logKernelProfile(kernelProfile);
        }
        outputs = kernelProfile.outputs;
      }
    });
    if (isTapeOn) {
      this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
    }
    if (this.state.profiling) {
      this.state.activeProfile.kernels.push({
        name: kernelOrScopeName,
        bytesAdded: this.state.numBytes - startingBytecount,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - startingNumTensors,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
        outputShapes: outputs.map((item) => item.shape),
        kernelTimeMs: kernelProfile.timeMs,
        extraInfo: kernelProfile.extraInfo
      });
    }
    return Array.isArray(out) ? outputs : outputs[0];
  }
  saveTensorsForBackwardMode(tensors) {
    const saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
    return saved;
  }
  getTensorsForGradient(kernelName, inputs, outputs) {
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      const inputsToSave = gradConfig.inputsToSave || [];
      const outputsToSave = gradConfig.outputsToSave || [];
      let inputTensorsToSave;
      if (gradConfig.saveAllInputs) {
        assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
        inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
      } else {
        inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
      }
      const outputTensorsToSave = outputs.filter((_2, i2) => outputsToSave[i2]);
      return inputTensorsToSave.concat(outputTensorsToSave);
    }
    return [];
  }
  makeTensor(values, shape, dtype, backend22) {
    if (values == null) {
      throw new Error("Values passed to engine.makeTensor() are null");
    }
    dtype = dtype || "float32";
    backend22 = backend22 || this.backend;
    let backendVals = values;
    if (dtype === "string" && isString(values[0])) {
      backendVals = values.map((d2) => encodeString(d2));
    }
    const dataId = backend22.write(backendVals, shape, dtype);
    const t2 = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t2, backend22);
    if (dtype === "string") {
      const info = this.state.tensorInfo.get(dataId);
      const newBytes = bytesFromStringArray(backendVals);
      this.state.numBytes += newBytes - info.bytes;
      info.bytes = newBytes;
    }
    return t2;
  }
  makeTensorFromDataId(dataId, shape, dtype, backend22) {
    dtype = dtype || "float32";
    const t2 = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t2, backend22);
    return t2;
  }
  makeVariable(initialValue, trainable = true, name, dtype) {
    name = name || this.nextVariableId().toString();
    if (dtype != null && dtype !== initialValue.dtype) {
      initialValue = initialValue.cast(dtype);
    }
    const v2 = new Variable(initialValue, trainable, name, this.nextTensorId());
    if (this.state.registeredVariables[v2.name] != null) {
      throw new Error(`Variable with name ${v2.name} was already registered`);
    }
    this.state.registeredVariables[v2.name] = v2;
    this.incRef(v2, this.backend);
    return v2;
  }
  trackTensor(a6, backend22) {
    this.state.numTensors++;
    if (a6.dtype === "string") {
      this.state.numStringTensors++;
    }
    let bytes = 0;
    if (a6.dtype !== "complex64" && a6.dtype !== "string") {
      bytes = a6.size * bytesPerElement(a6.dtype);
    }
    this.state.numBytes += bytes;
    if (!this.state.tensorInfo.has(a6.dataId)) {
      this.state.numDataBuffers++;
      this.state.tensorInfo.set(a6.dataId, {
        backend: backend22 || this.backend,
        dtype: a6.dtype,
        shape: a6.shape,
        bytes
      });
    }
    if (!(a6 instanceof Variable)) {
      this.track(a6);
    }
  }
  incRef(a6, backend22) {
    this.trackTensor(a6, backend22);
    this.backend.incRef(a6.dataId);
  }
  removeDataId(dataId, backend22) {
    if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend22) {
      this.state.tensorInfo.delete(dataId);
      this.state.numDataBuffers--;
    }
  }
  disposeTensor(a6) {
    if (!this.state.tensorInfo.has(a6.dataId)) {
      return;
    }
    const info = this.state.tensorInfo.get(a6.dataId);
    this.state.numTensors--;
    if (a6.dtype === "string") {
      this.state.numStringTensors--;
      this.state.numBytes -= info.bytes;
    }
    if (a6.dtype !== "complex64" && a6.dtype !== "string") {
      const bytes = a6.size * bytesPerElement(a6.dtype);
      this.state.numBytes -= bytes;
    }
    if (info.backend.disposeData(a6.dataId)) {
      this.removeDataId(a6.dataId, info.backend);
    }
  }
  disposeVariables() {
    for (const varName in this.state.registeredVariables) {
      const v2 = this.state.registeredVariables[varName];
      this.disposeVariable(v2);
    }
  }
  disposeVariable(v2) {
    this.disposeTensor(v2);
    if (this.state.registeredVariables[v2.name] != null) {
      delete this.state.registeredVariables[v2.name];
    }
  }
  memory() {
    const info = this.backend.memory();
    info.numTensors = this.state.numTensors;
    info.numDataBuffers = this.state.numDataBuffers;
    info.numBytes = this.state.numBytes;
    if (this.state.numStringTensors > 0) {
      info.unreliable = true;
      if (info.reasons == null) {
        info.reasons = [];
      }
      info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
    }
    return info;
  }
  async profile(query) {
    this.state.profiling = true;
    const startBytes = this.state.numBytes;
    const startNumTensors = this.state.numTensors;
    this.state.activeProfile.kernels = [];
    this.state.activeProfile.result = await query();
    this.state.profiling = false;
    this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d2) => d2.totalBytesSnapshot));
    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
    this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
    for (const kernel of this.state.activeProfile.kernels) {
      kernel.kernelTimeMs = await kernel.kernelTimeMs;
      kernel.extraInfo = await kernel.extraInfo;
    }
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
    const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      gradientsFunc = gradConfig.gradFunc;
    }
    if (gradientsFunc != null) {
      tapeNode.gradient = (dys) => {
        dys = dys.map((dy, i2) => {
          if (dy == null) {
            const output = outputs[i2];
            const vals = makeZerosTypedArray(output.size, output.dtype);
            return this.makeTensor(vals, output.shape, output.dtype);
          }
          return dy;
        });
        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
      };
    }
    this.state.activeTape.push(tapeNode);
  }
  keep(result) {
    result.kept = true;
    return result;
  }
  startTape() {
    if (this.state.gradientDepth === 0) {
      this.state.activeTape = [];
    }
    this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  startScope(name) {
    const scopeInfo = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    if (name) {
      scopeInfo.name = name;
    }
    this.state.scopeStack.push(scopeInfo);
    this.state.activeScope = scopeInfo;
  }
  endScope(result) {
    const tensorsToTrackInParent = getTensorsInContainer(result);
    const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t2) => t2.id));
    for (let i2 = 0; i2 < this.state.activeScope.track.length; i2++) {
      const tensor2 = this.state.activeScope.track[i2];
      if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
        tensor2.dispose();
      }
    }
    const oldScope = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
    tensorsToTrackInParent.forEach((tensor2) => {
      if (!tensor2.kept && tensor2.scopeId === oldScope.id) {
        this.track(tensor2);
      }
    });
  }
  gradients(f2, xs, dy, allowNoGradients = false) {
    assert(xs.length > 0, () => "gradients() received an empty list of xs.");
    if (dy != null && dy.dtype !== "float32") {
      throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
    }
    const y2 = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f2));
    assert(y2 instanceof Tensor, () => "The result y returned by f() must be a tensor.");
    const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y2);
    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    }
    return this.tidy("backward", () => {
      const accumulatedGradientMap = {};
      accumulatedGradientMap[y2.id] = dy == null ? ones(y2.shape) : dy;
      backpropagateGradients(accumulatedGradientMap, filteredTape, (f22) => this.tidy(f22), add);
      const grads2 = xs.map((x2) => accumulatedGradientMap[x2.id]);
      if (this.state.gradientDepth === 0) {
        this.state.activeTape.forEach((node2) => {
          for (const tensor2 of node2.saved) {
            tensor2.dispose();
          }
        });
        this.state.activeTape = null;
      }
      return { value: y2, grads: grads2 };
    });
  }
  customGrad(f2) {
    assert(isFunction(f2), () => "The f passed in customGrad(f) must be a function.");
    return (...inputs) => {
      assert(inputs.every((t2) => t2 instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let res2;
      const inputMap = {};
      inputs.forEach((input2, i2) => {
        inputMap[i2] = input2;
      });
      const forwardFunc = (_2, save) => {
        res2 = f2(...[...inputs, save]);
        assert(res2.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
        assert(isFunction(res2.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
        return res2.value;
      };
      const backwardsFunc = (dy, saved) => {
        const gradRes = res2.gradFunc(dy, saved);
        const grads2 = Array.isArray(gradRes) ? gradRes : [gradRes];
        assert(grads2.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
        assert(grads2.every((t2) => t2 instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const gradMap = {};
        grads2.forEach((grad2, i2) => {
          gradMap[i2] = () => grad2;
        });
        return gradMap;
      };
      return this.runKernelFunc({
        forwardFunc,
        backwardsFunc,
        inputs: inputMap
      });
    };
  }
  readSync(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readSync(dataId);
  }
  read(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.read(dataId);
  }
  async time(query) {
    const start = now22();
    const timingInfo = await this.backend.time(query);
    timingInfo.wallMs = now22() - start;
    return timingInfo;
  }
  track(result) {
    if (this.state.activeScope != null) {
      result.scopeId = this.state.activeScope.id;
      this.state.activeScope.track.push(result);
    }
    return result;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  reset() {
    this.pendingBackendInitId++;
    this.state.dispose();
    this.ENV.reset();
    this.state = new EngineState();
    for (const backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    this.backendName = null;
    this.backendInstance = null;
    this.pendingBackendInit = null;
  }
};
Engine.nextTensorId = 0;
Engine.nextVariableId = 0;
function ones(shape) {
  const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
  return ENGINE.makeTensor(values, shape, "float32");
}
function getOrMakeEngine() {
  const ns = getGlobalNamespace();
  if (ns._tfengine == null) {
    const environment = new Environment(ns);
    ns._tfengine = new Engine(environment);
  }
  setEnvironmentGlobal(ns._tfengine.ENV);
  setTensorTracker(() => ns._tfengine);
  return ns._tfengine;
}
var ENGINE = getOrMakeEngine();
function add(a6, b2) {
  const inputs = { a: a6, b: b2 };
  return ENGINE.runKernel(Add, inputs);
}
var device_util_exports = {};
__export2(device_util_exports, {
  isBrowser: () => isBrowser,
  isMobile: () => isMobile
});
function _isNavigatorDefined() {
  return typeof navigator !== "undefined" && navigator != null;
}
function isMobile(nav) {
  if (nav || _isNavigatorDefined()) {
    if (!nav) {
      nav = navigator;
    }
    if (nav.product === "ReactNative") {
      return true;
    }
    const a6 = nav.userAgent || nav.vendor || (typeof window !== "undefined" ? window.opera : "");
    if (!a6) {
      const navAny = nav;
      return navAny.userAgentData && navAny.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a6) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a6.substr(0, 4));
  }
  return false;
}
function isBrowser() {
  return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
}
var ENV2 = env();
ENV2.registerFlag("DEBUG", () => false, (debugValue) => {
  if (debugValue) {
    console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  }
});
ENV2.registerFlag("IS_BROWSER", () => isBrowser());
ENV2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
ENV2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
ENV2.registerFlag("PROD", () => false);
ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV2.getBool("DEBUG"));
ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
ENV2.registerFlag("IS_TEST", () => false);
ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
ENV2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
function inferShape(val, dtype) {
  let firstElem = val;
  if (isTypedArray(val)) {
    return dtype === "string" ? [] : [val.length];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  const shape = [];
  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
    shape.push(firstElem.length);
    firstElem = firstElem[0];
  }
  if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
    deepAssertShapeConsistency(val, shape, []);
  }
  return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
  indices = indices || [];
  if (!Array.isArray(val) && !isTypedArray(val)) {
    assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
    return;
  }
  assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
  assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
  const subShape = shape.slice(1);
  for (let i2 = 0; i2 < val.length; ++i2) {
    deepAssertShapeConsistency(val[i2], subShape, indices.concat(i2));
  }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
  if (expectedDtype === "string_or_numeric") {
    return;
  }
  if (expectedDtype == null) {
    throw new Error(`Expected dtype cannot be null.`);
  }
  if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
  }
}
function convertToTensor(x2, argName, functionName, parseAsDtype = "numeric") {
  if (x2 instanceof Tensor) {
    assertDtype(parseAsDtype, x2.dtype, argName, functionName);
    return x2;
  }
  let inferredDtype = inferDtype(x2);
  if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
    inferredDtype = parseAsDtype;
  }
  assertDtype(parseAsDtype, inferredDtype, argName, functionName);
  if (x2 == null || !isTypedArray(x2) && !Array.isArray(x2) && typeof x2 !== "number" && typeof x2 !== "boolean" && typeof x2 !== "string") {
    const type = x2 == null ? "null" : x2.constructor.name;
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
  }
  const inferredShape = inferShape(x2, inferredDtype);
  if (!isTypedArray(x2) && !Array.isArray(x2)) {
    x2 = [x2];
  }
  const skipTypedArray = true;
  const values = inferredDtype !== "string" ? toTypedArray(x2, inferredDtype) : flatten2(x2, [], skipTypedArray);
  return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
  if (!Array.isArray(arg)) {
    throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
  }
  const tensors = arg;
  return tensors.map((t2, i2) => convertToTensor(t2, `${argName}[${i2}]`, functionName, parseAsDtype));
}
var OP_SCOPE_SUFFIX = "__op";
function op(f2) {
  const keys = Object.keys(f2);
  if (keys.length !== 1) {
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
  }
  let opName = keys[0];
  const fn = f2[opName];
  if (opName.endsWith("_")) {
    opName = opName.substring(0, opName.length - 1);
  }
  opName = opName + OP_SCOPE_SUFFIX;
  const f22 = (...args) => {
    ENGINE.startScope(opName);
    try {
      const result = fn(...args);
      if (isPromise(result)) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      ENGINE.endScope(result);
      return result;
    } catch (ex) {
      ENGINE.endScope(null);
      throw ex;
    }
  };
  Object.defineProperty(f22, "name", { value: opName, configurable: true });
  return f22;
}
function complex_(real5, imag5) {
  const $real = convertToTensor(real5, "real", "complex");
  const $imag = convertToTensor(imag5, "imag", "complex");
  assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
  const inputs = { real: $real, imag: $imag };
  return ENGINE.runKernel(Complex, inputs);
}
var complex = op({ complex_ });
function makeTensor(values, shape, inferredShape, dtype) {
  if (dtype == null) {
    dtype = inferDtype(values);
  }
  if (dtype === "complex64") {
    throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
  }
  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  }
  if (shape != null) {
    assertNonNegativeIntegerDimensions(shape);
    const providedSize = sizeFromShape(shape);
    const inferredSize = sizeFromShape(inferredShape);
    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
    for (let i2 = 0; i2 < inferredShape.length; ++i2) {
      const inferred = inferredShape[i2];
      const flatDimsDontMatch = i2 === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i2)) : true;
      assert(inferredShape[i2] === shape[i2] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
    }
  }
  if (!isTypedArray(values) && !Array.isArray(values)) {
    values = [values];
  }
  shape = shape || inferredShape;
  values = dtype !== "string" ? toTypedArray(values, dtype) : flatten2(values, [], true);
  return ENGINE.makeTensor(values, shape, dtype);
}
function tensor(values, shape, dtype) {
  const inferredShape = inferShape(values, dtype);
  return makeTensor(values, shape, inferredShape, dtype);
}
var DTYPE_VALUE_SIZE_MAP = {
  "float32": 4,
  "float16": 2,
  "int32": 4,
  "uint16": 2,
  "uint8": 1,
  "bool": 1,
  "complex64": 8
};
var NUM_BYTES_STRING_LENGTH = 4;
async function encodeWeights(tensors, group) {
  const specs = [];
  const dataPromises = [];
  const names = Array.isArray(tensors) ? tensors.map((tensor2) => tensor2.name) : Object.keys(tensors);
  for (let i2 = 0; i2 < names.length; ++i2) {
    const name = names[i2];
    const t2 = Array.isArray(tensors) ? tensors[i2].tensor : tensors[name];
    if (t2.dtype !== "float32" && t2.dtype !== "int32" && t2.dtype !== "bool" && t2.dtype !== "string" && t2.dtype !== "complex64") {
      throw new Error(`Unsupported dtype in weight '${name}': ${t2.dtype}`);
    }
    const spec = { name, shape: t2.shape, dtype: t2.dtype };
    if (t2.dtype === "string") {
      const utf8bytes = new Promise(async (resolve) => {
        const vals = await t2.bytes();
        const totalNumBytes = vals.reduce((p22, c2) => p22 + c2.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
        const bytes = new Uint8Array(totalNumBytes);
        let offset = 0;
        for (let i22 = 0; i22 < vals.length; i22++) {
          const val = vals[i22];
          const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
          bytes.set(bytesOfLength, offset);
          offset += NUM_BYTES_STRING_LENGTH;
          bytes.set(val, offset);
          offset += val.length;
        }
        resolve(bytes);
      });
      dataPromises.push(utf8bytes);
    } else {
      dataPromises.push(t2.data());
    }
    if (group != null) {
      spec.group = group;
    }
    specs.push(spec);
  }
  const tensorValues = await Promise.all(dataPromises);
  return { data: concatenateTypedArrays(tensorValues), specs };
}
function decodeWeights(buffer2, specs) {
  const out = {};
  let float16Decode;
  let offset = 0;
  for (const spec of specs) {
    const name = spec.name;
    const dtype = spec.dtype;
    const shape = spec.shape;
    const size2 = sizeFromShape(shape);
    let values;
    if ("quantization" in spec) {
      const quantization = spec.quantization;
      if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
        if (!("min" in quantization && "scale" in quantization)) {
          throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
        }
      } else if (quantization.dtype === "float16") {
        if (dtype !== "float32") {
          throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
        }
      } else {
        throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      }
      const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
      const byteBuffer = buffer2.slice(offset, offset + size2 * quantizationSizeFactor);
      const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
      if (dtype === "float32") {
        if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
          values = new Float32Array(quantizedArray.length);
          for (let i2 = 0; i2 < quantizedArray.length; i2++) {
            const v2 = quantizedArray[i2];
            values[i2] = v2 * quantization.scale + quantization.min;
          }
        } else if (quantization.dtype === "float16") {
          if (float16Decode === void 0) {
            float16Decode = getFloat16Decoder();
          }
          values = float16Decode(quantizedArray);
        } else {
          throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
        }
      } else if (dtype === "int32") {
        if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
          throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
        }
        values = new Int32Array(quantizedArray.length);
        for (let i2 = 0; i2 < quantizedArray.length; i2++) {
          const v2 = quantizedArray[i2];
          values[i2] = Math.round(v2 * quantization.scale + quantization.min);
        }
      } else {
        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
      }
      offset += size2 * quantizationSizeFactor;
    } else if (dtype === "string") {
      const size22 = sizeFromShape(spec.shape);
      values = [];
      for (let i2 = 0; i2 < size22; i2++) {
        const byteLength = new Uint32Array(buffer2.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
        offset += NUM_BYTES_STRING_LENGTH;
        const bytes = new Uint8Array(buffer2.slice(offset, offset + byteLength));
        values.push(bytes);
        offset += byteLength;
      }
    } else {
      const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
      const byteBuffer = buffer2.slice(offset, offset + size2 * dtypeFactor);
      if (dtype === "float32") {
        values = new Float32Array(byteBuffer);
      } else if (dtype === "int32") {
        values = new Int32Array(byteBuffer);
      } else if (dtype === "bool") {
        values = new Uint8Array(byteBuffer);
      } else if (dtype === "complex64") {
        values = new Float32Array(byteBuffer);
        const real5 = new Float32Array(values.length / 2);
        const image32 = new Float32Array(values.length / 2);
        for (let i2 = 0; i2 < real5.length; i2++) {
          real5[i2] = values[i2 * 2];
          image32[i2] = values[i2 * 2 + 1];
        }
        const realTensor = tensor(real5, shape, "float32");
        const imageTensor = tensor(image32, shape, "float32");
        out[name] = complex(realTensor, imageTensor);
        realTensor.dispose();
        imageTensor.dispose();
      } else {
        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
      }
      offset += size2 * dtypeFactor;
    }
    if (dtype !== "complex64") {
      out[name] = tensor(values, shape, dtype);
    }
  }
  return out;
}
function concatenateTypedArrays(xs) {
  if (xs === null) {
    throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
  }
  let totalByteLength = 0;
  const normalizedXs = [];
  xs.forEach((x2) => {
    totalByteLength += x2.byteLength;
    normalizedXs.push(x2.byteLength === x2.buffer.byteLength ? x2 : new x2.constructor(x2));
    if (!(x2 instanceof Float32Array || x2 instanceof Int32Array || x2 instanceof Uint8Array)) {
      throw new Error(`Unsupported TypedArray subtype: ${x2.constructor.name}`);
    }
  });
  const y2 = new Uint8Array(totalByteLength);
  let offset = 0;
  normalizedXs.forEach((x2) => {
    y2.set(new Uint8Array(x2.buffer), offset);
    offset += x2.byteLength;
  });
  return y2.buffer;
}
var useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
function stringByteLength(str) {
  if (useNodeBuffer) {
    return Buffer.byteLength(str);
  }
  return new Blob([str]).size;
}
function arrayBufferToBase64String(buffer2) {
  if (useNodeBuffer) {
    return Buffer.from(buffer2).toString("base64");
  }
  const buf = new Uint8Array(buffer2);
  let s2 = "";
  for (let i2 = 0, l3 = buf.length; i2 < l3; i2++) {
    s2 += String.fromCharCode(buf[i2]);
  }
  return btoa(s2);
}
function base64StringToArrayBuffer(str) {
  if (useNodeBuffer) {
    const buf = Buffer.from(str, "base64");
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  const s2 = atob(str);
  const buffer2 = new Uint8Array(s2.length);
  for (let i2 = 0; i2 < s2.length; ++i2) {
    buffer2.set([s2.charCodeAt(i2)], i2);
  }
  return buffer2.buffer;
}
function concatenateArrayBuffers(buffers) {
  if (buffers.length === 1) {
    return buffers[0];
  }
  let totalByteLength = 0;
  buffers.forEach((buffer2) => {
    totalByteLength += buffer2.byteLength;
  });
  const temp = new Uint8Array(totalByteLength);
  let offset = 0;
  buffers.forEach((buffer2) => {
    temp.set(new Uint8Array(buffer2), offset);
    offset += buffer2.byteLength;
  });
  return temp.buffer;
}
function basename(path) {
  const SEPARATOR = "/";
  path = path.trim();
  while (path.endsWith(SEPARATOR)) {
    path = path.slice(0, path.length - 1);
  }
  const items = path.split(SEPARATOR);
  return items[items.length - 1];
}
function getModelJSONForModelArtifacts(artifacts, manifest) {
  const result = {
    modelTopology: artifacts.modelTopology,
    format: artifacts.format,
    generatedBy: artifacts.generatedBy,
    convertedBy: artifacts.convertedBy,
    weightsManifest: manifest
  };
  if (artifacts.signature != null) {
    result.signature = artifacts.signature;
  }
  if (artifacts.userDefinedMetadata != null) {
    result.userDefinedMetadata = artifacts.userDefinedMetadata;
  }
  if (artifacts.modelInitializer != null) {
    result.modelInitializer = artifacts.modelInitializer;
  }
  if (artifacts.trainingConfig != null) {
    result.trainingConfig = artifacts.trainingConfig;
  }
  return result;
}
async function getModelArtifactsForJSON(modelJSON, loadWeights2) {
  const modelArtifacts = {
    modelTopology: modelJSON.modelTopology,
    format: modelJSON.format,
    generatedBy: modelJSON.generatedBy,
    convertedBy: modelJSON.convertedBy
  };
  if (modelJSON.trainingConfig != null) {
    modelArtifacts.trainingConfig = modelJSON.trainingConfig;
  }
  if (modelJSON.weightsManifest != null) {
    const [weightSpecs, weightData] = await loadWeights2(modelJSON.weightsManifest);
    modelArtifacts.weightSpecs = weightSpecs;
    modelArtifacts.weightData = weightData;
  }
  if (modelJSON.signature != null) {
    modelArtifacts.signature = modelJSON.signature;
  }
  if (modelJSON.userDefinedMetadata != null) {
    modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
  }
  if (modelJSON.modelInitializer != null) {
    modelArtifacts.modelInitializer = modelJSON.modelInitializer;
  }
  return modelArtifacts;
}
function getModelArtifactsInfoForJSON(modelArtifacts) {
  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  }
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
  };
}
function computeFloat16MantisaTable() {
  const convertMantissa = (i2) => {
    let m2 = i2 << 13;
    let e2 = 0;
    while ((m2 & 8388608) === 0) {
      e2 -= 8388608;
      m2 <<= 1;
    }
    m2 &= ~8388608;
    e2 += 947912704;
    return m2 | e2;
  };
  const mantisaTable = new Uint32Array(2048);
  mantisaTable[0] = 0;
  for (let i2 = 1; i2 < 1024; i2++) {
    mantisaTable[i2] = convertMantissa(i2);
  }
  for (let i2 = 1024; i2 < 2048; i2++) {
    mantisaTable[i2] = 939524096 + (i2 - 1024 << 13);
  }
  return mantisaTable;
}
function computeFloat16ExponentTable() {
  const exponentTable = new Uint32Array(64);
  exponentTable[0] = 0;
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  exponentTable[63] = 3347054592;
  for (let i2 = 1; i2 < 31; i2++) {
    exponentTable[i2] = i2 << 23;
  }
  for (let i2 = 33; i2 < 63; i2++) {
    exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
  }
  return exponentTable;
}
function computeFloat16OffsetTable() {
  const offsetTable = new Uint32Array(64);
  for (let i2 = 0; i2 < 64; i2++) {
    offsetTable[i2] = 1024;
  }
  offsetTable[0] = offsetTable[32] = 0;
  return offsetTable;
}
function getFloat16Decoder() {
  const mantisaTable = computeFloat16MantisaTable();
  const exponentTable = computeFloat16ExponentTable();
  const offsetTable = computeFloat16OffsetTable();
  return (quantizedArray) => {
    const buffer2 = new ArrayBuffer(4 * quantizedArray.length);
    const bufferUint32View = new Uint32Array(buffer2);
    for (let index = 0; index < quantizedArray.length; index++) {
      const float16Bits = quantizedArray[index];
      const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
      bufferUint32View[index] = float32Bits;
    }
    return new Float32Array(buffer2);
  };
}
var IORouterRegistry = class {
  constructor() {
    this.saveRouters = [];
    this.loadRouters = [];
  }
  static getInstance() {
    if (IORouterRegistry.instance == null) {
      IORouterRegistry.instance = new IORouterRegistry();
    }
    return IORouterRegistry.instance;
  }
  static registerSaveRouter(saveRouter) {
    IORouterRegistry.getInstance().saveRouters.push(saveRouter);
  }
  static registerLoadRouter(loadRouter) {
    IORouterRegistry.getInstance().loadRouters.push(loadRouter);
  }
  static getSaveHandlers(url) {
    return IORouterRegistry.getHandlers(url, "save");
  }
  static getLoadHandlers(url, loadOptions) {
    return IORouterRegistry.getHandlers(url, "load", loadOptions);
  }
  static getHandlers(url, handlerType, loadOptions) {
    const validHandlers = [];
    const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
    routers.forEach((router) => {
      const handler = router(url, loadOptions);
      if (handler !== null) {
        validHandlers.push(handler);
      }
    });
    return validHandlers;
  }
};
var registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
var registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
var getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
var getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);
var DATABASE_NAME = "tensorflowjs";
var DATABASE_VERSION = 1;
var MODEL_STORE_NAME = "models_store";
var INFO_STORE_NAME = "model_info_store";
function getIndexedDBFactory() {
  if (!env().getBool("IS_BROWSER")) {
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  }
  const theWindow = typeof window === "undefined" ? self : window;
  const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
  if (factory == null) {
    throw new Error("The current browser does not appear to support IndexedDB.");
  }
  return factory;
}
function setUpDatabase(openRequest) {
  const db = openRequest.result;
  db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
  db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
}
var BrowserIndexedDB = class {
  constructor(modelPath) {
    this.indexedDB = getIndexedDBFactory();
    if (modelPath == null || !modelPath) {
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    }
    return this.databaseAction(this.modelPath, modelArtifacts);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  databaseAction(modelPath, modelArtifacts) {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        if (modelArtifacts == null) {
          const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
          const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
          const getRequest = modelStore.get(this.modelPath);
          getRequest.onsuccess = () => {
            if (getRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            } else {
              resolve(getRequest.result.modelArtifacts);
            }
          };
          getRequest.onerror = (error) => {
            db.close();
            return reject(getRequest.error);
          };
          modelTx.oncomplete = () => db.close();
        } else {
          const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          let infoStore = infoTx.objectStore(INFO_STORE_NAME);
          const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
          let modelTx;
          putInfoRequest.onsuccess = () => {
            modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            const putModelRequest = modelStore.put({
              modelPath: this.modelPath,
              modelArtifacts,
              modelArtifactsInfo
            });
            putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
            putModelRequest.onerror = (error) => {
              infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const deleteInfoRequest = infoStore.delete(this.modelPath);
              deleteInfoRequest.onsuccess = () => {
                db.close();
                return reject(putModelRequest.error);
              };
              deleteInfoRequest.onerror = (error2) => {
                db.close();
                return reject(putModelRequest.error);
              };
            };
          };
          putInfoRequest.onerror = (error) => {
            db.close();
            return reject(putInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        }
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
};
BrowserIndexedDB.URL_SCHEME = "indexeddb://";
var indexedDBRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(indexedDBRouter);
IORouterRegistry.registerLoadRouter(indexedDBRouter);
function browserIndexedDB(modelPath) {
  return new BrowserIndexedDB(modelPath);
}
function maybeStripScheme(key) {
  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
}
var BrowserIndexedDBManager = class {
  constructor() {
    this.indexedDB = getIndexedDBFactory();
  }
  async listModels() {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const tx = db.transaction(INFO_STORE_NAME, "readonly");
        const store = tx.objectStore(INFO_STORE_NAME);
        const getAllInfoRequest = store.getAll();
        getAllInfoRequest.onsuccess = () => {
          const out = {};
          for (const item of getAllInfoRequest.result) {
            out[item.modelPath] = item.modelArtifactsInfo;
          }
          resolve(out);
        };
        getAllInfoRequest.onerror = (error) => {
          db.close();
          return reject(getAllInfoRequest.error);
        };
        tx.oncomplete = () => db.close();
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
  async removeModel(path) {
    path = maybeStripScheme(path);
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
        const infoStore = infoTx.objectStore(INFO_STORE_NAME);
        const getInfoRequest = infoStore.get(path);
        let modelTx;
        getInfoRequest.onsuccess = () => {
          if (getInfoRequest.result == null) {
            db.close();
            return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
          } else {
            const deleteInfoRequest = infoStore.delete(path);
            const deleteModelData = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const deleteModelRequest = modelStore.delete(path);
              deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
              deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
            };
            deleteInfoRequest.onsuccess = deleteModelData;
            deleteInfoRequest.onerror = (error) => {
              deleteModelData();
              db.close();
              return reject(getInfoRequest.error);
            };
          }
        };
        getInfoRequest.onerror = (error) => {
          db.close();
          return reject(getInfoRequest.error);
        };
        infoTx.oncomplete = () => {
          if (modelTx == null) {
            db.close();
          } else {
            modelTx.oncomplete = () => db.close();
          }
        };
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
};
var PATH_SEPARATOR = "/";
var PATH_PREFIX = "tensorflowjs_models";
var INFO_SUFFIX = "info";
var MODEL_TOPOLOGY_SUFFIX = "model_topology";
var WEIGHT_SPECS_SUFFIX = "weight_specs";
var WEIGHT_DATA_SUFFIX = "weight_data";
var MODEL_METADATA_SUFFIX = "model_metadata";
function getModelKeys(path) {
  return {
    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
    modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
  };
}
function removeItems(keys) {
  for (const key of Object.values(keys)) {
    window.localStorage.removeItem(key);
  }
}
function getModelPathFromKey(key) {
  const items = key.split(PATH_SEPARATOR);
  if (items.length < 3) {
    throw new Error(`Invalid key format: ${key}`);
  }
  return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme2(key) {
  return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
}
var BrowserLocalStorage = class {
  constructor(modelPath) {
    if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
      throw new Error("The current environment does not support local storage.");
    }
    this.LS = window.localStorage;
    if (modelPath == null || !modelPath) {
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
    this.keys = getModelKeys(this.modelPath);
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    } else {
      const topology = JSON.stringify(modelArtifacts.modelTopology);
      const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
      const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
        this.LS.setItem(this.keys.topology, topology);
        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
        this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));
        const metadata = {
          format: modelArtifacts.format,
          generatedBy: modelArtifacts.generatedBy,
          convertedBy: modelArtifacts.convertedBy,
          signature: modelArtifacts.signature != null ? modelArtifacts.signature : void 0,
          userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : void 0,
          modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : void 0,
          trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : void 0
        };
        this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
        return { modelArtifactsInfo };
      } catch (err) {
        removeItems(this.keys);
        throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
      }
    }
  }
  async load() {
    const info = JSON.parse(this.LS.getItem(this.keys.info));
    if (info == null) {
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    }
    if (info.modelTopologyType !== "JSON") {
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    }
    const out = {};
    const topology = JSON.parse(this.LS.getItem(this.keys.topology));
    if (topology == null) {
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    }
    out.modelTopology = topology;
    const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (weightSpecs == null) {
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    }
    out.weightSpecs = weightSpecs;
    const metadataString = this.LS.getItem(this.keys.modelMetadata);
    if (metadataString != null) {
      const metadata = JSON.parse(metadataString);
      out.format = metadata.format;
      out.generatedBy = metadata.generatedBy;
      out.convertedBy = metadata.convertedBy;
      if (metadata.signature != null) {
        out.signature = metadata.signature;
      }
      if (metadata.userDefinedMetadata != null) {
        out.userDefinedMetadata = metadata.userDefinedMetadata;
      }
      if (metadata.modelInitializer != null) {
        out.modelInitializer = metadata.modelInitializer;
      }
      if (metadata.trainingConfig != null) {
        out.trainingConfig = metadata.trainingConfig;
      }
    }
    const weightDataBase64 = this.LS.getItem(this.keys.weightData);
    if (weightDataBase64 == null) {
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    }
    out.weightData = base64StringToArrayBuffer(weightDataBase64);
    return out;
  }
};
BrowserLocalStorage.URL_SCHEME = "localstorage://";
var localStorageRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
      return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(localStorageRouter);
IORouterRegistry.registerLoadRouter(localStorageRouter);
function browserLocalStorage(modelPath) {
  return new BrowserLocalStorage(modelPath);
}
var BrowserLocalStorageManager = class {
  constructor() {
    assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
    assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
    this.LS = window.localStorage;
  }
  async listModels() {
    const out = {};
    const prefix = PATH_PREFIX + PATH_SEPARATOR;
    const suffix = PATH_SEPARATOR + INFO_SUFFIX;
    for (let i2 = 0; i2 < this.LS.length; ++i2) {
      const key = this.LS.key(i2);
      if (key.startsWith(prefix) && key.endsWith(suffix)) {
        const modelPath = getModelPathFromKey(key);
        out[modelPath] = JSON.parse(this.LS.getItem(key));
      }
    }
    return out;
  }
  async removeModel(path) {
    path = maybeStripScheme2(path);
    const keys = getModelKeys(path);
    if (this.LS.getItem(keys.info) == null) {
      throw new Error(`Cannot find model at path '${path}'`);
    }
    const info = JSON.parse(this.LS.getItem(keys.info));
    removeItems(keys);
    return info;
  }
};
var URL_SCHEME_SUFFIX = "://";
var ModelStoreManagerRegistry = class {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    if (ModelStoreManagerRegistry.instance == null) {
      ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
    }
    return ModelStoreManagerRegistry.instance;
  }
  static registerManager(scheme, manager) {
    assert(scheme != null, () => "scheme must not be undefined or null.");
    if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
      scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
    }
    assert(scheme.length > 0, () => "scheme must not be an empty string.");
    const registry = ModelStoreManagerRegistry.getInstance();
    assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
    registry.managers[scheme] = manager;
  }
  static getManager(scheme) {
    const manager = this.getInstance().managers[scheme];
    if (manager == null) {
      throw new Error(`Cannot find model manager for scheme '${scheme}'`);
    }
    return manager;
  }
  static getSchemes() {
    return Object.keys(this.getInstance().managers);
  }
};
function parseURL(url) {
  if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
  }
  return {
    scheme: url.split(URL_SCHEME_SUFFIX)[0],
    path: url.split(URL_SCHEME_SUFFIX)[1]
  };
}
async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
  assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
  const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
  assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
  assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
  const loadHandler = loadHandlers[0];
  const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
  assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
  assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
  const saveHandler = saveHandlers[0];
  const sourceScheme = parseURL(sourceURL).scheme;
  const sourcePath = parseURL(sourceURL).path;
  const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
  const modelArtifacts = await loadHandler.load();
  if (deleteSource && sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  const saveResult = await saveHandler.save(modelArtifacts);
  if (deleteSource && !sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  return saveResult.modelArtifactsInfo;
}
async function listModels() {
  const schemes = ModelStoreManagerRegistry.getSchemes();
  const out = {};
  for (const scheme of schemes) {
    const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
    for (const path in schemeOut) {
      const url = scheme + URL_SCHEME_SUFFIX + path;
      out[url] = schemeOut[path];
    }
  }
  return out;
}
async function removeModel(url) {
  const schemeAndPath = parseURL(url);
  const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
  return manager.removeModel(schemeAndPath.path);
}
async function copyModel(sourceURL, destURL) {
  const deleteSource = false;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}
async function moveModel(sourceURL, destURL) {
  const deleteSource = true;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}
var PlatformBrowser = class {
  fetch(path, init2) {
    return fetch(path, init2);
  }
  now() {
    return performance.now();
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
    }
    if (this.textEncoder == null) {
      this.textEncoder = new TextEncoder();
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    return new TextDecoder(encoding).decode(bytes);
  }
};
if (env().get("IS_BROWSER")) {
  env().setPlatform("browser", new PlatformBrowser());
  try {
    ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
  } catch (err) {
  }
  try {
    ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
  } catch (err) {
  }
}
var getNodeFetch = {
  importFetch: () => require_browser()
};
var systemFetch;
var PlatformNode = class {
  constructor() {
    this.util = __require22("util");
    this.textEncoder = new this.util.TextEncoder();
  }
  fetch(path, requestInits) {
    if (env().global.fetch != null) {
      return env().global.fetch(path, requestInits);
    }
    if (systemFetch == null) {
      systemFetch = getNodeFetch.importFetch();
    }
    return systemFetch(path, requestInits);
  }
  now() {
    const time2 = process.hrtime();
    return time2[0] * 1e3 + time2[1] / 1e6;
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    if (bytes.length === 0) {
      return "";
    }
    return new this.util.TextDecoder(encoding).decode(bytes);
  }
};
if (env().get("IS_NODE")) {
  env().setPlatform("node", new PlatformNode());
}
function buffer(shape, dtype = "float32", values) {
  dtype = dtype || "float32";
  assertNonNegativeIntegerDimensions(shape);
  return new TensorBuffer(shape, dtype, values);
}
function cast_(x2, dtype) {
  const $x = convertToTensor(x2, "x", "cast");
  if (!isValidDtype(dtype)) {
    throw new Error(`Failed to cast to unknown dtype ${dtype}`);
  }
  if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
    throw new Error("Only strings can be casted to strings");
  }
  const inputs = { x: $x };
  const attrs = { dtype };
  return ENGINE.runKernel(Cast, inputs, attrs);
}
var cast = op({ cast_ });
function clone_(x2) {
  const $x = convertToTensor(x2, "x", "clone", "string_or_numeric");
  const inputs = { x: $x };
  return ENGINE.runKernel(Identity, inputs);
}
var clone = op({ clone_ });
function print2(x2, verbose = false) {
  console.log(x2.toString(verbose));
}
getOrMakeEngine();
var opHandler2 = {
  buffer,
  cast,
  clone,
  print: print2
};
setOpHandler(opHandler2);
var io_exports = {};
__export2(io_exports, {
  browserFiles: () => browserFiles,
  browserHTTPRequest: () => browserHTTPRequest,
  concatenateArrayBuffers: () => concatenateArrayBuffers,
  copyModel: () => copyModel,
  decodeWeights: () => decodeWeights,
  encodeWeights: () => encodeWeights,
  fromMemory: () => fromMemory,
  getLoadHandlers: () => getLoadHandlers,
  getModelArtifactsForJSON: () => getModelArtifactsForJSON,
  getModelArtifactsInfoForJSON: () => getModelArtifactsInfoForJSON,
  getSaveHandlers: () => getSaveHandlers,
  http: () => http,
  isHTTPScheme: () => isHTTPScheme,
  listModels: () => listModels,
  loadWeights: () => loadWeights,
  moveModel: () => moveModel,
  registerLoadRouter: () => registerLoadRouter,
  registerSaveRouter: () => registerSaveRouter,
  removeModel: () => removeModel,
  weightsLoaderFactory: () => weightsLoaderFactory,
  withSaveHandler: () => withSaveHandler
});
var DEFAULT_FILE_NAME_PREFIX = "model";
var DEFAULT_JSON_EXTENSION_NAME = ".json";
var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
function defer(f2) {
  return new Promise((resolve) => setTimeout(resolve)).then(f2);
}
var BrowserDownloads = class {
  constructor(fileNamePrefix) {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    }
    if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
      fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
    }
    if (fileNamePrefix == null || fileNamePrefix.length === 0) {
      fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
    }
    this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
    this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
  }
  async save(modelArtifacts) {
    if (typeof document === "undefined") {
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    }
    const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: "application/octet-stream" }));
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    } else {
      const weightsManifest = [{
        paths: ["./" + this.weightDataFileName],
        weights: modelArtifacts.weightSpecs
      }];
      const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
      const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      jsonAnchor.download = this.modelJsonFileName;
      jsonAnchor.href = modelJsonURL;
      await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
      if (modelArtifacts.weightData != null) {
        const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        weightDataAnchor.download = this.weightDataFileName;
        weightDataAnchor.href = weightsURL;
        await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
    }
  }
};
BrowserDownloads.URL_SCHEME = "downloads://";
var BrowserFiles = class {
  constructor(files) {
    if (files == null || files.length < 1) {
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
    }
    this.jsonFile = files[0];
    this.weightsFiles = files.slice(1);
  }
  async load() {
    return new Promise((resolve, reject) => {
      const jsonReader = new FileReader();
      jsonReader.onload = (event) => {
        const modelJSON = JSON.parse(event.target.result);
        const modelTopology = modelJSON.modelTopology;
        if (modelTopology == null) {
          reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        const weightsManifest = modelJSON.weightsManifest;
        if (weightsManifest == null) {
          reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          resolve({ modelTopology });
          return;
        }
        const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
        resolve(modelArtifactsPromise);
      };
      jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
      jsonReader.readAsText(this.jsonFile);
    });
  }
  loadWeights(weightsManifest) {
    const weightSpecs = [];
    const paths = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
      paths.push(...entry.paths);
    }
    const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
    const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
    return Promise.all(promises).then((buffers) => [weightSpecs, concatenateArrayBuffers(buffers)]);
  }
  loadWeightsFile(path, file) {
    return new Promise((resolve, reject) => {
      const weightFileReader = new FileReader();
      weightFileReader.onload = (event) => {
        const weightData = event.target.result;
        resolve(weightData);
      };
      weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
      weightFileReader.readAsArrayBuffer(file);
    });
  }
  checkManifestAndWeightFiles(manifest) {
    const basenames = [];
    const fileNames = this.weightsFiles.map((file) => basename(file.name));
    const pathToFile = {};
    for (const group of manifest) {
      group.paths.forEach((path) => {
        const pathBasename = basename(path);
        if (basenames.indexOf(pathBasename) !== -1) {
          throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
        }
        basenames.push(pathBasename);
        if (fileNames.indexOf(pathBasename) === -1) {
          throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
        } else {
          pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
        }
      });
    }
    if (basenames.length !== this.weightsFiles.length) {
      throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    }
    return pathToFile;
  }
};
var browserDownloadsRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
      return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
function browserDownloads(fileNamePrefix = "model") {
  return new BrowserDownloads(fileNamePrefix);
}
function browserFiles(files) {
  return new BrowserFiles(files);
}
function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
  checkPromises(promises);
  startFraction = startFraction == null ? 0 : startFraction;
  endFraction = endFraction == null ? 1 : endFraction;
  checkFraction(startFraction, endFraction);
  let resolvedPromise = 0;
  const registerMonitor = (promise) => {
    promise.then((value) => {
      const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
      onProgress(fraction);
      return value;
    });
    return promise;
  };
  function checkPromises(promises2) {
    assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
  }
  function checkFraction(startFraction2, endFraction2) {
    assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
    assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
    assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
  }
  return Promise.all(promises.map(registerMonitor));
}
async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
  if (loadOptions == null) {
    loadOptions = {};
  }
  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
  const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
  const fetchStartFraction = 0;
  const fetchEndFraction = 0.5;
  const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
  const bufferPromises = responses.map((response) => response.arrayBuffer());
  const bufferStartFraction = 0.5;
  const bufferEndFraction = 1;
  const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
  return buffers;
}
async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
  const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
  const loadWeights2 = weightsLoaderFactory(fetchWeights);
  return loadWeights2(manifest, filePathPrefix, weightNames);
}
function weightsLoaderFactory(fetchWeightsFunction) {
  return async (manifest, filePathPrefix = "", weightNames) => {
    const groupIndicesToFetchMap = manifest.map(() => false);
    const groupWeightsToFetch = {};
    const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
    const allManifestWeightNames = [];
    manifest.forEach((manifestGroupConfig, groupIndex) => {
      let groupOffset = 0;
      manifestGroupConfig.weights.forEach((weightsEntry) => {
        const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
        const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
        const enqueueWeightsForFetchingFn = () => {
          groupIndicesToFetchMap[groupIndex] = true;
          if (groupWeightsToFetch[groupIndex] == null) {
            groupWeightsToFetch[groupIndex] = [];
          }
          groupWeightsToFetch[groupIndex].push({
            manifestEntry: weightsEntry,
            groupOffset,
            sizeBytes: weightsBytes
          });
        };
        if (weightNames != null) {
          weightNames.forEach((weightName, weightIndex) => {
            if (weightName === weightsEntry.name) {
              enqueueWeightsForFetchingFn();
              weightsFound[weightIndex] = true;
            }
          });
        } else {
          enqueueWeightsForFetchingFn();
        }
        allManifestWeightNames.push(weightsEntry.name);
        groupOffset += weightsBytes;
      });
    });
    if (!weightsFound.every((found) => found)) {
      const weightsNotFound = weightNames.filter((_2, i2) => !weightsFound[i2]);
      throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
    }
    const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i2) => {
      if (shouldFetch) {
        accumulator.push(i2);
      }
      return accumulator;
    }, []);
    const fetchUrls = [];
    groupIndicesToFetch.forEach((i2) => {
      manifest[i2].paths.forEach((filepath) => {
        const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
        fetchUrls.push(fetchUrl);
      });
    });
    const buffers = await fetchWeightsFunction(fetchUrls);
    const weightsTensorMap = {};
    let bufferIndexOffset = 0;
    groupIndicesToFetch.forEach((i2) => {
      const numBuffers = manifest[i2].paths.length;
      let groupBytes = 0;
      for (let i22 = 0; i22 < numBuffers; i22++) {
        groupBytes += buffers[bufferIndexOffset + i22].byteLength;
      }
      const groupBuffer = new ArrayBuffer(groupBytes);
      const groupByteBuffer = new Uint8Array(groupBuffer);
      let groupBufferOffset = 0;
      for (let i22 = 0; i22 < numBuffers; i22++) {
        const buffer2 = new Uint8Array(buffers[bufferIndexOffset + i22]);
        groupByteBuffer.set(buffer2, groupBufferOffset);
        groupBufferOffset += buffer2.byteLength;
      }
      const weightsEntries = groupWeightsToFetch[i2];
      weightsEntries.forEach((weightsEntry) => {
        const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
        const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
        for (const name in nameToTensorMap) {
          weightsTensorMap[name] = nameToTensorMap[name];
        }
      });
      bufferIndexOffset += numBuffers;
    });
    return weightsTensorMap;
  };
}
var OCTET_STREAM_MIME_TYPE = "application/octet-stream";
var JSON_TYPE = "application/json";
var HTTPRequest = class {
  constructor(path, loadOptions) {
    this.DEFAULT_METHOD = "POST";
    if (loadOptions == null) {
      loadOptions = {};
    }
    this.weightPathPrefix = loadOptions.weightPathPrefix;
    this.onProgress = loadOptions.onProgress;
    this.weightUrlConverter = loadOptions.weightUrlConverter;
    if (loadOptions.fetchFunc != null) {
      assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
      this.fetch = loadOptions.fetchFunc;
    } else {
      this.fetch = env().platform.fetch;
    }
    assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
    if (Array.isArray(path)) {
      assert(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
    }
    this.path = path;
    if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    }
    this.requestInit = loadOptions.requestInit || {};
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    }
    const init2 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    init2.body = new FormData();
    const weightsManifest = [{
      paths: ["./model.weights.bin"],
      weights: modelArtifacts.weightSpecs
    }];
    const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
    init2.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
    if (modelArtifacts.weightData != null) {
      init2.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
    }
    const response = await this.fetch(this.path, init2);
    if (response.ok) {
      return {
        modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
        responses: [response]
      };
    } else {
      throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
    }
  }
  async load() {
    const modelConfigRequest = await this.fetch(this.path, this.requestInit);
    if (!modelConfigRequest.ok) {
      throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
    }
    let modelJSON;
    try {
      modelJSON = await modelConfigRequest.json();
    } catch (e2) {
      let message = `Failed to parse model JSON of response from ${this.path}.`;
      if (this.path.endsWith(".pb")) {
        message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
      } else {
        message += " Please make sure the server is serving valid JSON for this request.";
      }
      throw new Error(message);
    }
    const modelTopology = modelJSON.modelTopology;
    const weightsManifest = modelJSON.weightsManifest;
    if (modelTopology == null && weightsManifest == null) {
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    }
    return getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
  }
  async loadWeights(weightsManifest) {
    const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
    const [prefix, suffix] = parseUrl(weightPath);
    const pathPrefix = this.weightPathPrefix || prefix;
    const weightSpecs = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
    }
    const fetchURLs = [];
    const urlPromises = [];
    for (const weightsGroup of weightsManifest) {
      for (const path of weightsGroup.paths) {
        if (this.weightUrlConverter != null) {
          urlPromises.push(this.weightUrlConverter(path));
        } else {
          fetchURLs.push(pathPrefix + path + suffix);
        }
      }
    }
    if (this.weightUrlConverter) {
      fetchURLs.push(...await Promise.all(urlPromises));
    }
    const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {
      requestInit: this.requestInit,
      fetchFunc: this.fetch,
      onProgress: this.onProgress
    });
    return [weightSpecs, concatenateArrayBuffers(buffers)];
  }
};
HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
function parseUrl(url) {
  const lastSlash = url.lastIndexOf("/");
  const lastSearchParam = url.lastIndexOf("?");
  const prefix = url.substring(0, lastSlash);
  const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
  return [prefix + "/", suffix];
}
function isHTTPScheme(url) {
  return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
}
var httpRouter = (url, loadOptions) => {
  if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
    return null;
  } else {
    let isHTTP = true;
    if (Array.isArray(url)) {
      isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
    } else {
      isHTTP = isHTTPScheme(url);
    }
    if (isHTTP) {
      return http(url, loadOptions);
    }
  }
  return null;
};
IORouterRegistry.registerSaveRouter(httpRouter);
IORouterRegistry.registerLoadRouter(httpRouter);
function http(path, loadOptions) {
  return new HTTPRequest(path, loadOptions);
}
function browserHTTPRequest(path, loadOptions) {
  return http(path, loadOptions);
}
var PassthroughLoader = class {
  constructor(modelArtifacts) {
    this.modelArtifacts = modelArtifacts;
  }
  async load() {
    return this.modelArtifacts;
  }
};
var PassthroughSaver = class {
  constructor(saveHandler) {
    this.saveHandler = saveHandler;
  }
  async save(modelArtifacts) {
    return this.saveHandler(modelArtifacts);
  }
};
function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
  if (arguments.length === 1) {
    const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
    if (isModelArtifacts) {
      return new PassthroughLoader(modelArtifacts);
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
      return new PassthroughLoader({ modelTopology: modelArtifacts });
    }
  } else {
    console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
    return new PassthroughLoader({
      modelTopology: modelArtifacts,
      weightSpecs,
      weightData,
      trainingConfig
    });
  }
}
function withSaveHandler(saveHandler) {
  return new PassthroughSaver(saveHandler);
}
var math_exports = {};
__export2(math_exports, {
  confusionMatrix: () => confusionMatrix
});
function matMul_(a6, b2, transposeA = false, transposeB = false) {
  let $a = convertToTensor(a6, "a", "matMul");
  let $b = convertToTensor(b2, "b", "matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  const attrs = { transposeA, transposeB };
  return ENGINE.runKernel(BatchMatMul, inputs, attrs);
}
var matMul = op({ matMul_ });
function oneHot_(indices, depth, onValue = 1, offValue = 0) {
  if (depth < 2) {
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
  }
  const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
  const inputs = { indices: $indices };
  const attrs = { depth, onValue, offValue };
  return ENGINE.runKernel(OneHot, inputs, attrs);
}
var oneHot = op({ oneHot_ });
function transpose_(x2, perm) {
  const $x = convertToTensor(x2, "x", "transpose");
  if (perm == null) {
    perm = $x.shape.map((s2, i2) => i2).reverse();
  }
  assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
  perm.forEach((axis) => {
    assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
  });
  if ($x.rank <= 1) {
    return $x.clone();
  }
  const inputs = { x: $x };
  const attrs = { perm };
  return ENGINE.runKernel(Transpose, inputs, attrs);
}
var transpose = op({ transpose_ });
function confusionMatrix_(labels2, predictions, numClasses) {
  const $labels = convertToTensor(labels2, "labels", "confusionMatrix");
  const $predictions = convertToTensor(predictions, "predictions", "confusionMatrix");
  assert(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), () => `If provided, numClasses must be a positive integer, but got ${numClasses}`);
  assert($labels.rank === 1, () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);
  assert($predictions.rank === 1, () => `Expected the rank of predictions to be 1, but got ${$predictions.rank}`);
  assert($labels.shape[0] === $predictions.shape[0], () => `Mismatch in the number of examples: ${$labels.shape[0]} vs. ${$predictions.shape[0]}. Labels and predictions should have the same number of elements.`);
  assert(numClasses > 0 && Number.isInteger(numClasses), () => `numClasses is required to be a positive integer, but got ${numClasses}`);
  const oneHotLabels = oneHot(cast($labels, "int32"), numClasses);
  const oneHotPredictions = oneHot(cast($predictions, "int32"), numClasses);
  const oneHotLabelsT = transpose(oneHotLabels);
  const product = matMul(oneHotLabelsT, oneHotPredictions);
  return cast(product, "int32");
}
var confusionMatrix = op({ confusionMatrix_ });
var browser_exports = {};
__export2(browser_exports, {
  fromPixels: () => fromPixels,
  fromPixelsAsync: () => fromPixelsAsync,
  toPixels: () => toPixels
});
function tensor3d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 3) {
    throw new Error("tensor3d() requires shape to have three numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 3 && inferredShape.length !== 1) {
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
var fromPixels2DContext;
function fromPixels_(pixels, numChannels = 3) {
  if (numChannels > 4) {
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  }
  if (pixels == null) {
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  }
  let isPixelData2 = false;
  let isImageData = false;
  let isVideo = false;
  let isImage = false;
  let isCanvasLike = false;
  let isImageBitmap = false;
  if (pixels.data instanceof Uint8Array) {
    isPixelData2 = true;
  } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
    isImageData = true;
  } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
    isVideo = true;
  } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
    isImage = true;
  } else if (pixels.getContext != null) {
    isCanvasLike = true;
  } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
    isImageBitmap = true;
  } else {
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);
  }
  if (isVideo) {
    const HAVE_CURRENT_DATA_READY_STATE = 2;
    if (isVideo && pixels.readyState < HAVE_CURRENT_DATA_READY_STATE) {
      throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
    }
  }
  const kernel = getKernel(FromPixels, ENGINE.backendName);
  if (kernel != null) {
    const inputs = { pixels };
    const attrs = { numChannels };
    return ENGINE.runKernel(FromPixels, inputs, attrs);
  }
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  let vals;
  if (isCanvasLike) {
    vals = pixels.getContext("2d").getImageData(0, 0, width, height).data;
  } else if (isImageData || isPixelData2) {
    vals = pixels.data;
  } else if (isImage || isVideo || isImageBitmap) {
    if (fromPixels2DContext == null) {
      fromPixels2DContext = document.createElement("canvas").getContext("2d");
    }
    fromPixels2DContext.canvas.width = width;
    fromPixels2DContext.canvas.height = height;
    fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
    vals = fromPixels2DContext.getImageData(0, 0, width, height).data;
  }
  let values;
  if (numChannels === 4) {
    values = new Int32Array(vals);
  } else {
    const numPixels = width * height;
    values = new Int32Array(numPixels * numChannels);
    for (let i2 = 0; i2 < numPixels; i2++) {
      for (let channel = 0; channel < numChannels; ++channel) {
        values[i2 * numChannels + channel] = vals[i2 * 4 + channel];
      }
    }
  }
  const outShape = [height, width, numChannels];
  return tensor3d(values, outShape, "int32");
}
function isPixelData(pixels) {
  return pixels != null && pixels.data instanceof Uint8Array;
}
function isImageBitmapFullySupported() {
  return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
}
function isNonEmptyPixels(pixels) {
  return pixels != null && pixels.width !== 0 && pixels.height !== 0;
}
function canWrapPixelsToImageBitmap(pixels) {
  return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
}
async function fromPixelsAsync(pixels, numChannels = 3) {
  let inputs = null;
  if (env().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)) {
    let imageBitmap;
    try {
      imageBitmap = await createImageBitmap(pixels, { premultiplyAlpha: "none" });
    } catch (e2) {
      imageBitmap = null;
    }
    if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
      inputs = imageBitmap;
    } else {
      inputs = pixels;
    }
  } else {
    inputs = pixels;
  }
  return fromPixels_(inputs, numChannels);
}
async function toPixels(img, canvas3) {
  let $img = convertToTensor(img, "img", "toPixels");
  if (!(img instanceof Tensor)) {
    const originalImgTensor = $img;
    $img = cast(originalImgTensor, "int32");
    originalImgTensor.dispose();
  }
  if ($img.rank !== 2 && $img.rank !== 3) {
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${$img.rank}.`);
  }
  const [height, width] = $img.shape.slice(0, 2);
  const depth = $img.rank === 2 ? 1 : $img.shape[2];
  if (depth > 4 || depth === 2) {
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);
  }
  if ($img.dtype !== "float32" && $img.dtype !== "int32") {
    throw new Error(`Unsupported type for toPixels: ${$img.dtype}. Please use float32 or int32 tensors.`);
  }
  const data = await $img.data();
  const multiplier = $img.dtype === "float32" ? 255 : 1;
  const bytes = new Uint8ClampedArray(width * height * 4);
  for (let i2 = 0; i2 < height * width; ++i2) {
    const rgba = [0, 0, 0, 255];
    for (let d2 = 0; d2 < depth; d2++) {
      const value = data[i2 * depth + d2];
      if ($img.dtype === "float32") {
        if (value < 0 || value > 1) {
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`);
        }
      } else if ($img.dtype === "int32") {
        if (value < 0 || value > 255) {
          throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);
        }
      }
      if (depth === 1) {
        rgba[0] = value * multiplier;
        rgba[1] = value * multiplier;
        rgba[2] = value * multiplier;
      } else {
        rgba[d2] = value * multiplier;
      }
    }
    const j2 = i2 * 4;
    bytes[j2 + 0] = Math.round(rgba[0]);
    bytes[j2 + 1] = Math.round(rgba[1]);
    bytes[j2 + 2] = Math.round(rgba[2]);
    bytes[j2 + 3] = Math.round(rgba[3]);
  }
  if (canvas3 != null) {
    canvas3.width = width;
    canvas3.height = height;
    const ctx = canvas3.getContext("2d");
    const imageData = new ImageData(bytes, width, height);
    ctx.putImageData(imageData, 0, 0);
  }
  if ($img !== img) {
    $img.dispose();
  }
  return bytes;
}
var fromPixels = op({ fromPixels_ });
var gather_nd_util_exports = {};
__export2(gather_nd_util_exports, {
  prepareAndValidate: () => prepareAndValidate
});
function prepareAndValidate(tensor2, indices) {
  const tensorRank = tensor2.shape.length;
  const indicesRank = indices.shape.length;
  if (tensorRank < 1) {
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
  }
  if (indicesRank < 1) {
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
  }
  if (indices.shape[indicesRank - 1] > tensorRank) {
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
  }
  if (sizeFromShape(tensor2.shape) === 0) {
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor2.shape}.`);
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  let nResult = 1;
  for (let i2 = 0; i2 < indicesShape.length - 1; ++i2) {
    nResult *= indicesShape[i2];
  }
  const inputShape = tensor2.shape;
  const resultShape = indicesShape.slice();
  resultShape.pop();
  let sliceSize = 1;
  for (let i2 = sliceRank; i2 < tensorRank; ++i2) {
    sliceSize *= inputShape[i2];
    resultShape.push(inputShape[i2]);
  }
  const strides = [
    ...computeStrides(tensor2.shape).map((stride) => stride / sliceSize),
    1
  ].slice(0, sliceRank);
  return [resultShape, nResult, sliceSize, strides];
}
var scatter_nd_util_exports = {};
__export2(scatter_nd_util_exports, {
  calculateShapes: () => calculateShapes,
  validateInput: () => validateInput,
  validateUpdateShape: () => validateUpdateShape
});
function validateUpdateShape(shape, indices, updates) {
  const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
  const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
  const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
  if (updates.rank < batchDim) {
    throw new Error(shapeError + ` update.rank < ${batchDim}. `);
  }
  if (shape.length < sliceDim + (updates.rank - batchDim)) {
    throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
  }
  if (updates.rank !== batchDim + shape.length - sliceDim) {
    throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
  }
  for (let d2 = 0; d2 < batchDim; ++d2) {
    if (updates.shape[d2] !== indices.shape[d2]) {
      throw new Error(shapeError + ` updates.shape[${d2}] (${updates.shape[d2]}) != indices.shape[${d2}] (${indices.shape[d2]}).`);
    }
  }
  for (let d2 = 0; d2 < updates.rank - batchDim; ++d2) {
    if (updates.shape[d2 + batchDim] !== shape[d2 + sliceDim]) {
      throw new Error(shapeError + ` updates.shape[${d2 + batchDim}] (${updates.shape[d2 + batchDim]}) != shape[${d2 + batchDim}] (${shape[d2 + batchDim]})`);
    }
  }
}
function validateInput(updates, indices, shape) {
  if (indices.rank < 1) {
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
  }
  if (updates.rank < 1) {
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
  }
  if (shape.length < 1) {
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
  }
  if (shape.length === 0) {
    if (indices.size === 0) {
      throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
    }
    if (updates.size === 0) {
      throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
    }
  }
  validateUpdateShape(shape, indices, updates);
}
function calculateShapes(updates, indices, shape) {
  const indicesRank = indices.shape.length;
  const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
  const totalNd = shape.length;
  let sliceSize = 1;
  for (let i2 = sliceRank; i2 < totalNd; ++i2) {
    sliceSize *= shape[i2];
  }
  const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
  const outputSize2 = sizeFromShape(shape);
  return { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 };
}
var slice_util_exports = {};
__export2(slice_util_exports, {
  assertParamsValid: () => assertParamsValid,
  computeFlatOffset: () => computeFlatOffset,
  computeOutShape: () => computeOutShape,
  getNormalizedAxes: () => getNormalizedAxes,
  isSliceContinous: () => isSliceContinous,
  maskToAxes: () => maskToAxes,
  parseSliceParams: () => parseSliceParams,
  sliceInfo: () => sliceInfo,
  startForAxis: () => startForAxis,
  startIndicesWithElidedDims: () => startIndicesWithElidedDims,
  stopForAxis: () => stopForAxis,
  stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
  stridesForAxis: () => stridesForAxis,
  stridesWithElidedDims: () => stridesWithElidedDims
});
function assertParamsValid(input2, begin, size2) {
  const inputRank = input2.shape.length;
  assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
  assert(inputRank === size2.length, () => `Error in slice${inputRank}D: Length of size ${size2} must match the rank of the array (${inputRank}).`);
  for (let i2 = 0; i2 < inputRank; ++i2) {
    assert(begin[i2] + size2[i2] <= input2.shape[i2], () => `Error in slice${inputRank}D: begin[${i2}] + size[${i2}] (${begin[i2] + size2[i2]}) would overflow input.shape[${i2}] (${input2.shape[i2]})`);
  }
}
function maskToAxes(mask) {
  const axes = [];
  let axis = 0;
  while (mask > 0) {
    if (mask & 1) {
      axes.push(axis);
    }
    mask /= 2;
    axis++;
  }
  return axes;
}
function computeOutShape(begin, end, strides) {
  const size2 = [];
  for (let axis = 0; axis < begin.length; axis++) {
    size2[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
  }
  return size2;
}
function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
  const newStrides = [...strides];
  for (let i2 = newStrides.length; i2 < inputShape.length; i2++) {
    newStrides.push(1);
  }
  for (let i2 = 0; i2 < numElidedAxes; i2++) {
    if (i2 === 0) {
      newStrides[ellipsisInsertionIndex] = 1;
    } else {
      newStrides.splice(ellipsisInsertionIndex, 0, 1);
      newStrides.pop();
    }
  }
  return newStrides;
}
function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
  if (normalizedAxis <= ellipsisInsertionIndex) {
    return normalizedAxis;
  }
  return normalizedAxis - (numElidedAxes - 1);
}
function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
  const elidedAxes = [];
  for (let i2 = 0; i2 < numElidedAxes; i2++) {
    elidedAxes.push(ellipsisInsertionIndex + i2);
  }
  return elidedAxes;
}
function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
  const inputRank = inputShape.length;
  let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
  if (ellipsisAxes.length && numInterpolatedAxes > 0) {
    const fullIndex = ellipsisAxes[0];
    const numElidedAxes = numInterpolatedAxes + 1;
    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
  } else {
    for (let axis = 0; axis < inputRank; axis++) {
      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
    }
  }
  return {
    begin: normalizedBegin,
    end: normalizedEnd,
    strides: normalizedStrides
  };
}
function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = 0;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalBegin[originalAxis];
      if (beginMask & 1 << originalAxis) {
        originalValue = 0;
      }
      newIndices[axis] = originalValue;
    }
  }
  return newIndices;
}
function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = Number.MAX_SAFE_INTEGER;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalEnd[originalAxis];
      if (endMask & 1 << originalAxis) {
        originalValue = Number.MAX_SAFE_INTEGER;
      }
      newIndices[axis] = originalValue;
    }
  }
  for (let i2 = 0; i2 < newIndices.length; i2++) {
    const axisSize = inputShape[i2];
    if (newIndices[i2] < 0) {
      newIndices[i2] += axisSize;
    }
    newIndices[i2] = clamp2(0, newIndices[i2], inputShape[i2]);
  }
  return newIndices;
}
function stridesForAxis(strides, axis, ellipsisMask) {
  let stride = strides[axis];
  if (ellipsisMask & 1 << axis || stride == null) {
    stride = 1;
  }
  return stride;
}
function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
  let start = startIndices[axis];
  const stride = strides[axis] || 1;
  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
    if (stride > 0) {
      start = Number.MIN_SAFE_INTEGER;
    } else {
      start = Number.MAX_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (start < 0) {
    start += axisSize;
  }
  start = clamp2(0, start, axisSize - 1);
  return start;
}
function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
  let stop = stopIndices[axis];
  const stride = strides[axis] || 1;
  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
    if (stride > 0) {
      stop = Number.MAX_SAFE_INTEGER;
    } else {
      stop = Number.MIN_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (stop < 0) {
    stop += axisSize;
  }
  if (stride > 0) {
    stop = clamp2(0, stop, axisSize);
  } else {
    stop = clamp2(-1, stop, axisSize - 1);
  }
  return stop;
}
function isSliceContinous(shape, begin, size2) {
  let firstNonOneAxis = size2.length;
  for (let i2 = 0; i2 < size2.length; i2++) {
    if (size2[i2] > 1) {
      firstNonOneAxis = i2;
      break;
    }
  }
  for (let i2 = firstNonOneAxis + 1; i2 < size2.length; i2++) {
    if (begin[i2] > 0 || size2[i2] !== shape[i2]) {
      return false;
    }
  }
  return true;
}
function computeFlatOffset(begin, strides) {
  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
  for (let i2 = 0; i2 < begin.length - 1; i2++) {
    flatOffset += begin[i2] * strides[i2];
  }
  return flatOffset;
}
function parseSliceParams(x2, begin, size2) {
  let begin_;
  const xRank = x2.shape.length;
  if (typeof begin === "number") {
    begin_ = [begin, ...new Array(xRank - 1).fill(0)];
  } else if (begin.length < xRank) {
    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
  } else {
    begin_ = begin.slice();
  }
  begin_.forEach((d2) => {
    assert(d2 !== -1, () => "slice() does not support negative begin indexing.");
  });
  let size_;
  if (size2 == null) {
    size_ = new Array(xRank).fill(-1);
  } else if (typeof size2 === "number") {
    size_ = [size2, ...new Array(xRank - 1).fill(-1)];
  } else if (size2.length < xRank) {
    size_ = size2.concat(new Array(xRank - size2.length).fill(-1));
  } else {
    size_ = size2;
  }
  size_ = size_.map((d2, i2) => {
    if (d2 >= 0) {
      return d2;
    } else {
      assert(d2 === -1, () => `Negative size values should be exactly -1 but got ${d2} for the slice() size at index ${i2}.`);
      return x2.shape[i2] - begin_[i2];
    }
  });
  return [begin_, size_];
}
function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
  let $begin = begin.slice();
  let $end = end.slice();
  let $strides = strides;
  if (strides == null) {
    $strides = new Array($begin.length);
  }
  const ellipsisAxes = maskToAxes(ellipsisMask);
  if (ellipsisAxes.length > 1) {
    throw new Error("Multiple ellipses in slice is not allowed.");
  }
  if (ellipsisMask !== 0 && newAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  }
  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  }
  const numInterpolatedAxes = xShape.length - $begin.length;
  const expandAxes = maskToAxes(newAxisMask);
  const newShape = xShape.slice();
  expandAxes.forEach((axis) => {
    $begin[axis] = 0;
    $end[axis] = 1;
    newShape.splice(axis, 0, 1);
  });
  const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);
  $begin = normalizedBegin;
  $end = normalizedEnd;
  $strides = normalizedStrides;
  const shrinkAxes = maskToAxes(shrinkAxisMask);
  shrinkAxes.forEach((axis) => {
    $end[axis] = $begin[axis] + 1;
    $strides[axis] = 1;
  });
  const size2 = computeOutShape($begin, $end, $strides);
  const outShape = size2.filter((_2, axis) => shrinkAxes.indexOf(axis) === -1);
  const nonStrided = $strides.every((v2) => v2 === 1);
  return { nonStrided, $begin, $end, $strides, size: size2, newShape, outShape };
}
var serialization_exports = {};
__export2(serialization_exports, {
  Serializable: () => Serializable,
  SerializationMap: () => SerializationMap,
  registerClass: () => registerClass
});
var Serializable = class {
  getClassName() {
    return this.constructor.className;
  }
  static fromConfig(cls, config3) {
    return new cls(config3);
  }
};
var SerializationMap = class {
  constructor() {
    this.classNameMap = {};
  }
  static getMap() {
    if (SerializationMap.instance == null) {
      SerializationMap.instance = new SerializationMap();
    }
    return SerializationMap.instance;
  }
  static register(cls) {
    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
  }
};
function registerClass(cls) {
  assert(cls.className != null, () => `Class being registered does not have the static className property defined.`);
  assert(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
  SerializationMap.register(cls);
}
var test_util_exports = {};
__export2(test_util_exports, {
  TEST_EPSILON_FLOAT16: () => TEST_EPSILON_FLOAT16,
  encodeStrings: () => encodeStrings,
  expectArrayBuffersEqual: () => expectArrayBuffersEqual,
  expectArraysClose: () => expectArraysClose,
  expectArraysEqual: () => expectArraysEqual,
  expectNumbersClose: () => expectNumbersClose,
  expectPromiseToFail: () => expectPromiseToFail,
  expectValuesInRange: () => expectValuesInRange,
  testEpsilon: () => testEpsilon
});
var TEST_EPSILON_FLOAT32 = 1e-3;
var TEST_EPSILON_FLOAT16 = 0.1;
function expectArraysClose(actual, expected, epsilon3) {
  if (epsilon3 == null) {
    epsilon3 = testEpsilon();
  }
  return expectArraysPredicate(actual, expected, (a6, b2) => areClose(a6, b2, epsilon3));
}
function testEpsilon() {
  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
}
function expectArraysPredicate(actual, expected, predicate) {
  let checkClassType = true;
  if (isTypedArray(actual) || isTypedArray(expected)) {
    checkClassType = false;
  }
  if (isTypedArray(actual) && isTypedArray(expected)) {
    checkClassType = true;
  }
  if (checkClassType) {
    const aType = actual.constructor.name;
    const bType = expected.constructor.name;
    if (aType !== bType) {
      throw new Error(`Arrays are of different type. Actual: ${aType}. Expected: ${bType}`);
    }
  }
  if (Array.isArray(actual) && Array.isArray(expected)) {
    const actualShape = inferShape(actual);
    const expectedShape = inferShape(expected);
    if (!arraysEqual2(actualShape, expectedShape)) {
      throw new Error(`Arrays have different shapes. Actual: [${actualShape}]. Expected: [${expectedShape}]`);
    }
  }
  const actualFlat = isTypedArray(actual) ? actual : flatten2(actual);
  const expectedFlat = isTypedArray(expected) ? expected : flatten2(expected);
  if (actualFlat.length !== expectedFlat.length) {
    throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs expected: ${expectedFlat.length}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
  }
  for (let i2 = 0; i2 < expectedFlat.length; ++i2) {
    const a6 = actualFlat[i2];
    const e2 = expectedFlat[i2];
    if (!predicate(a6, e2)) {
      throw new Error(`Arrays differ: actual[${i2}] = ${a6}, expected[${i2}] = ${e2}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
    }
  }
}
function expectPromiseToFail(fn, done) {
  fn().then(() => done.fail(), () => done());
}
function expectArraysEqual(actual, expected) {
  const exp5 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {
    return expectArraysPredicate(actual, exp5, (a6, b2) => a6 == b2);
  }
  return expectArraysPredicate(actual, expected, (a6, b2) => areClose(a6, b2, 0));
}
function expectNumbersClose(a6, e2, epsilon3) {
  if (epsilon3 == null) {
    epsilon3 = testEpsilon();
  }
  if (!areClose(a6, e2, epsilon3)) {
    throw new Error(`Numbers differ: actual === ${a6}, expected === ${e2}`);
  }
}
function areClose(a6, e2, epsilon3) {
  if (!isFinite(a6) && !isFinite(e2)) {
    return true;
  }
  if (isNaN(a6) || isNaN(e2) || Math.abs(a6 - e2) > epsilon3) {
    return false;
  }
  return true;
}
function expectValuesInRange(actual, low, high) {
  for (let i2 = 0; i2 < actual.length; i2++) {
    if (actual[i2] < low || actual[i2] > high) {
      throw new Error(`Value out of range:${actual[i2]} low: ${low}, high: ${high}`);
    }
  }
}
function expectArrayBuffersEqual(actual, expected) {
  expect(new Float32Array(actual)).toEqual(new Float32Array(expected));
}
function encodeStrings(a6) {
  for (let i2 = 0; i2 < a6.length; i2++) {
    const val = a6[i2];
    if (Array.isArray(val)) {
      encodeStrings(val);
    } else {
      a6[i2] = encodeString(val);
    }
  }
  return a6;
}
var version = "3.9.0";
function enableProdMode() {
  env().set("PROD", true);
}
function enableDebugMode() {
  env().set("DEBUG", true);
}
function disableDeprecationWarnings() {
  env().set("DEPRECATION_WARNINGS_ENABLED", false);
  console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
}
function deprecationWarn(msg) {
  if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
    console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
}
setDeprecationWarningFn(deprecationWarn);
function disposeVariables() {
  ENGINE.disposeVariables();
}
function engine() {
  return ENGINE;
}
function memory() {
  return ENGINE.memory();
}
function profile(f2) {
  return ENGINE.profile(f2);
}
function tidy(nameOrFn, fn) {
  return ENGINE.tidy(nameOrFn, fn);
}
function dispose(container) {
  const tensors = getTensorsInContainer(container);
  tensors.forEach((tensor2) => tensor2.dispose());
}
function keep(result) {
  return ENGINE.keep(result);
}
function time(f2) {
  return ENGINE.time(f2);
}
function setBackend(backendName) {
  return ENGINE.setBackend(backendName);
}
function ready() {
  return ENGINE.ready();
}
function getBackend() {
  return ENGINE.backendName;
}
function removeBackend(name) {
  ENGINE.removeBackend(name);
}
function findBackend(name) {
  return ENGINE.findBackend(name);
}
function findBackendFactory(name) {
  return ENGINE.findBackendFactory(name);
}
function registerBackend(name, factory, priority = 1) {
  return ENGINE.registerBackend(name, factory, priority);
}
function backend() {
  return ENGINE.backend;
}
function setPlatform(platformName, platform) {
  env().setPlatform(platformName, platform);
}
function add_(a6, b2) {
  let $a = convertToTensor(a6, "a", "add");
  let $b = convertToTensor(b2, "b", "add");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Add, inputs);
}
var add2 = op({ add_ });
function floorDiv_(a6, b2) {
  let $a = convertToTensor(a6, "a", "floorDiv");
  let $b = convertToTensor(b2, "b", "floorDiv");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(FloorDiv, inputs);
}
var floorDiv = op({ floorDiv_ });
function div_(a6, b2) {
  let $a = convertToTensor(a6, "a", "div");
  let $b = convertToTensor(b2, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "int32" && $b.dtype === "int32") {
    return floorDiv($a, $b);
  }
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(RealDiv, inputs, attrs);
}
var div = op({ div_ });
function mul_(a6, b2) {
  let $a = convertToTensor(a6, "a", "mul");
  let $b = convertToTensor(b2, "b", "mul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Multiply, inputs);
}
var mul = op({ mul_ });
function abs_(x2) {
  const $x = convertToTensor(x2, "x", "abs");
  if ($x.dtype === "complex64") {
    const inputs = { x: $x };
    return ENGINE.runKernel(ComplexAbs, inputs);
  } else {
    const inputs = { x: $x };
    return ENGINE.runKernel(Abs, inputs);
  }
}
var abs = op({ abs_ });
function acos_(x2) {
  const $x = convertToTensor(x2, "x", "acos");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acos, inputs);
}
var acos = op({ acos_ });
function acosh_(x2) {
  const $x = convertToTensor(x2, "x", "acosh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acosh, inputs);
}
var acosh = op({ acosh_ });
function addN_(tensors) {
  assert(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
  assert(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${tensors.length}`);
  const $tensors = tensors.map((t2, i2) => convertToTensor(t2, `tensors${i2}`, "addN"));
  const firstTensor = $tensors[0];
  $tensors.forEach((t2) => {
    if (t2.dtype !== firstTensor.dtype) {
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }
  });
  $tensors.forEach((t2) => {
    if (!arraysEqual2(t2.shape, firstTensor.shape)) {
      throw new Error("All tensors passed to tf.addN() must have the same shape");
    }
  });
  const inputs = $tensors;
  return ENGINE.runKernel(AddN, inputs);
}
var addN = op({ addN_ });
function all_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "all", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(All, inputs, attrs);
}
var all = op({ all_ });
function any_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "any", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Any, inputs, attrs);
}
var any = op({ any_ });
function argMax_(x2, axis = 0) {
  const $x = convertToTensor(x2, "x", "argMax");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMax, inputs, attrs);
}
var argMax = op({ argMax_ });
function argMin_(x2, axis = 0) {
  const $x = convertToTensor(x2, "x", "argMin");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMin, inputs, attrs);
}
var argMin = op({ argMin_ });
function asin_(x2) {
  const $x = convertToTensor(x2, "x", "asin");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asin, inputs);
}
var asin = op({ asin_ });
function asinh_(x2) {
  const $x = convertToTensor(x2, "x", "asinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asinh, inputs);
}
var asinh = op({ asinh_ });
function atan_(x2) {
  const $x = convertToTensor(x2, "x", "atan");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atan, inputs);
}
var atan = op({ atan_ });
function atan2_(a6, b2) {
  let $a = convertToTensor(a6, "a", "atan2");
  let $b = convertToTensor(b2, "b", "atan2");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Atan2, inputs);
}
var atan2 = op({ atan2_ });
function atanh_(x2) {
  const $x = convertToTensor(x2, "x", "atanh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atanh, inputs);
}
var atanh = op({ atanh_ });
function computeDilation2DInfo(inputShape, filterShape, strides, pad3, dataFormat = "NHWC", dilations) {
  const inputChannels = inputShape[3];
  const $filterShape = [...filterShape, inputChannels];
  const $dataFormat = convertConv2DDataFormat(dataFormat);
  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad3, null, null, $dataFormat);
}
function computePool2DInfo(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "channelsLast") {
  const [filterHeight, filterWidth] = parseTupleParam(filterSize);
  let filterShape;
  if (dataFormat === "channelsLast") {
    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
  } else if (dataFormat === "channelsFirst") {
    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad3, roundingMode, false, dataFormat);
}
function computePool3DInfo(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "NDHWC") {
  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
  let filterShape;
  let $dataFormat;
  if (dataFormat === "NDHWC") {
    $dataFormat = "channelsLast";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
  } else if (dataFormat === "NCDHW") {
    $dataFormat = "channelsFirst";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad3, false, $dataFormat, roundingMode);
}
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad3, roundingMode, depthwise = false, dataFormat = "channelsLast") {
  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideHeight, strideWidth] = parseTupleParam(strides);
  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad3, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inHeight,
    inWidth,
    inChannels,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideHeight,
    strideWidth,
    filterHeight,
    filterWidth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeConv3DInfo(inShape, filterShape, strides, dilations, pad3, depthwise = false, dataFormat = "channelsLast", roundingMode) {
  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inDepth,
    inHeight,
    inWidth,
    inChannels,
    outDepth,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideDepth,
    strideHeight,
    strideWidth,
    filterDepth,
    filterHeight,
    filterWidth,
    effectiveFilterDepth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationDepth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputRows = inShape[0];
  const inputCols = inShape[1];
  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  return [outputRows, outputCols];
}
function computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputDepth = inShape[0];
  const inputRows = inShape[1];
  const inputCols = inShape[2];
  const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  return [outputDepths, outputRows, outputCols, outChannels];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function parseTupleParam(param) {
  if (typeof param === "number") {
    return [param, param, param];
  }
  if (param.length === 2) {
    return [param[0], param[1], 1];
  }
  return param;
}
function parse3TupleParam(param) {
  return typeof param === "number" ? [param, param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
  if (dilation <= 1) {
    return filterSize;
  }
  return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad3, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
  let padInfo;
  let outHeight;
  let outWidth;
  if (typeof pad3 === "number") {
    const padType = pad3 === 0 ? "VALID" : "NUMBER";
    padInfo = { top: pad3, bottom: pad3, left: pad3, right: pad3, type: padType };
    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad3, roundingMode);
    outHeight = outShape[0];
    outWidth = outShape[1];
  } else if (pad3 === "same") {
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, type: "SAME" };
  } else if (pad3 === "valid") {
    padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else if (typeof pad3 === "object") {
    const top = dataFormat === "channelsLast" ? pad3[1][0] : pad3[2][0];
    const bottom = dataFormat === "channelsLast" ? pad3[1][1] : pad3[2][1];
    const left = dataFormat === "channelsLast" ? pad3[2][0] : pad3[3][0];
    const right = dataFormat === "channelsLast" ? pad3[2][1] : pad3[3][1];
    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
    padInfo = { top, bottom, left, right, type: padType };
    outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
    outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
  } else {
    throw Error(`Unknown padding parameter: ${pad3}`);
  }
  return { padInfo, outHeight, outWidth };
}
function get3DPadAndOutInfo(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
  let padInfo;
  let outDepth;
  let outHeight;
  let outWidth;
  if (typeof pad3 === "number") {
    const padType = pad3 === 0 ? "VALID" : "NUMBER";
    padInfo = {
      top: pad3,
      bottom: pad3,
      left: pad3,
      right: pad3,
      front: pad3,
      back: pad3,
      type: padType
    };
    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad3, roundingMode);
    outDepth = outShape[0];
    outHeight = outShape[1];
    outWidth = outShape[2];
  } else if (pad3 === "same") {
    outDepth = Math.ceil(inDepth / strideDepth);
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
    const front = Math.floor(padAlongDepth / 2);
    const back = padAlongDepth - front;
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, front, back, type: "SAME" };
  } else if (pad3 === "valid") {
    padInfo = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      front: 0,
      back: 0,
      type: "VALID"
    };
    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else {
    throw Error(`Unknown padding parameter: ${pad3}`);
  }
  return { padInfo, outDepth, outHeight, outWidth };
}
function round(value, roundingMode) {
  if (!roundingMode) {
    return Math.trunc(value);
  }
  switch (roundingMode) {
    case "round":
      return Math.round(value);
    case "ceil":
      return Math.ceil(value);
    case "floor":
      return Math.floor(value);
    default:
      throw new Error(`Unknown roundingMode ${roundingMode}`);
  }
}
function tupleValuesAreOne(param) {
  const [dimA, dimB, dimC] = parseTupleParam(param);
  return dimA === 1 && dimB === 1 && dimC === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function convertConv2DDataFormat(dataFormat) {
  if (dataFormat === "NHWC") {
    return "channelsLast";
  } else if (dataFormat === "NCHW") {
    return "channelsFirst";
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
}
function reshape_(x2, shape) {
  const $x = convertToTensor(x2, "x", "reshape", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = { shape };
  return ENGINE.runKernel(Reshape, inputs, attrs);
}
var reshape = op({ reshape_ });
function avgPool_(x2, filterSize, strides, pad3, dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "avgPool", "float32");
  const dilations = 1;
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in avgPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
  let res2 = ENGINE.runKernel(AvgPool, inputs, attrs);
  res2 = cast(res2, $x.dtype);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var avgPool = op({ avgPool_ });
function avgPool3d_(x2, filterSize, strides, pad3, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x2, "x", "avgPool3d", "float32");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat };
  let res2 = ENGINE.runKernel(AvgPool3D, inputs, attrs);
  res2 = cast(res2, x5D.dtype);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var avgPool3d = op({ avgPool3d_ });
function concat_(tensors, axis = 0) {
  assert(tensors.length >= 1, () => "Pass at least one tensor to concat");
  const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
  if ($tensors[0].dtype === "complex64") {
    $tensors.forEach((tensor2) => {
      if (tensor2.dtype !== "complex64") {
        throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor2.dtype}. `);
      }
    });
  }
  if ($tensors.length === 1) {
    return clone($tensors[0]);
  }
  const inputs = $tensors;
  const attr = { axis };
  return ENGINE.runKernel(Concat, inputs, attr);
}
var concat = op({ concat_ });
function sigmoid_(x2) {
  const $x = convertToTensor(x2, "x", "sigmoid");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sigmoid, inputs);
}
var sigmoid = op({ sigmoid_ });
function slice_(x2, begin, size2) {
  const $x = convertToTensor(x2, "x", "slice", "string_or_numeric");
  if ($x.rank === 0) {
    throw new Error("Slicing scalar is not possible");
  }
  const inputs = { x: $x };
  const attrs = { begin, size: size2 };
  return ENGINE.runKernel(Slice, inputs, attrs);
}
var slice = op({ slice_ });
function tanh_(x2) {
  const $x = convertToTensor(x2, "x", "tanh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tanh, inputs);
}
var tanh2 = op({ tanh_ });
function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c2, h2) {
  const $forgetBias = convertToTensor(forgetBias, "forgetBias", "basicLSTMCell");
  const $lstmKernel = convertToTensor(lstmKernel, "lstmKernel", "basicLSTMCell");
  const $lstmBias = convertToTensor(lstmBias, "lstmBias", "basicLSTMCell");
  const $data = convertToTensor(data, "data", "basicLSTMCell");
  const $c = convertToTensor(c2, "c", "basicLSTMCell");
  const $h = convertToTensor(h2, "h", "basicLSTMCell");
  const combined = concat([$data, $h], 1);
  const weighted = matMul(combined, $lstmKernel);
  const res2 = add2(weighted, $lstmBias);
  const batchSize = res2.shape[0];
  const sliceCols = res2.shape[1] / 4;
  const sliceSize = [batchSize, sliceCols];
  const i2 = slice(res2, [0, 0], sliceSize);
  const j2 = slice(res2, [0, sliceCols], sliceSize);
  const f2 = slice(res2, [0, sliceCols * 2], sliceSize);
  const o2 = slice(res2, [0, sliceCols * 3], sliceSize);
  const newC = add2(mul(sigmoid(i2), tanh2(j2)), mul($c, sigmoid(add2($forgetBias, f2))));
  const newH = mul(tanh2(newC), sigmoid(o2));
  return [newC, newH];
}
var basicLSTMCell = op({ basicLSTMCell_ });
function batchToSpaceND_(x2, blockShape, crops) {
  const $x = convertToTensor(x2, "x", "batchToSpaceND");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
  assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
  assert($x.shape[0] % prod6 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod6}`);
  const inputs = { x: $x };
  const attrs = { blockShape, crops };
  return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
}
var batchToSpaceND = op({ batchToSpaceND_ });
function xAs4D(x2) {
  let x4D;
  if (x2.rank === 0 || x2.rank === 1) {
    x4D = reshape(x2, [1, 1, 1, x2.size]);
  } else if (x2.rank === 2) {
    x4D = reshape(x2, [1, 1, x2.shape[0], x2.shape[1]]);
  } else if (x2.rank === 3) {
    x4D = reshape(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
  } else {
    x4D = x2;
  }
  return x4D;
}
function batchNorm_(x2, mean5, variance, offset, scale22, varianceEpsilon) {
  if (varianceEpsilon == null) {
    varianceEpsilon = 1e-3;
  }
  const $x = convertToTensor(x2, "x", "batchNorm");
  const $mean = convertToTensor(mean5, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale22 != null) {
    $scale = convertToTensor(scale22, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
  assert($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
  assert($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  const x4D = xAs4D($x);
  const inputs = {
    x: x4D,
    scale: $scale,
    offset: $offset,
    mean: $mean,
    variance: $variance
  };
  const attrs = { varianceEpsilon };
  const res2 = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
  return reshape(res2, $x.shape);
}
var batchNorm = op({ batchNorm_ });
function batchNorm2d_(x2, mean5, variance, offset, scale22, varianceEpsilon) {
  const $x = convertToTensor(x2, "x", "batchNorm");
  const $mean = convertToTensor(mean5, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale22 != null) {
    $scale = convertToTensor(scale22, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
  assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm2d = op({ batchNorm2d_ });
function batchNorm3d_(x2, mean5, variance, offset, scale22, varianceEpsilon) {
  const $x = convertToTensor(x2, "x", "batchNorm");
  const $mean = convertToTensor(mean5, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale22 != null) {
    $scale = convertToTensor(scale22, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
  assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm3d = op({ batchNorm3d_ });
function batchNorm4d_(x2, mean5, variance, offset, scale22, varianceEpsilon) {
  const $x = convertToTensor(x2, "x", "batchNorm");
  const $mean = convertToTensor(mean5, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale22 != null) {
    $scale = convertToTensor(scale22, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
  assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm4d = op({ batchNorm4d_ });
function bincount_(x2, weights, size2) {
  const $x = convertToTensor(x2, "x", "bincount");
  const $weights = convertToTensor(weights, "weights", "bincount");
  assert($x.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${$x.dtype}`);
  assert(size2 >= 0, () => `size must be non-negative, but got ${size2}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size: size2 };
  return ENGINE.runKernel(Bincount, inputs, attrs);
}
var bincount = op({ bincount_ });
function broadcastArgs_(s0, s1) {
  const shape1Input = convertToTensor(s0, "s0", "broadcastArgs", "int32");
  const shape2Input = convertToTensor(s1, "s1", "broadcastArgs", "int32");
  if (shape1Input.rank !== 1) {
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${shape1Input.rank}`);
  }
  if (shape2Input.rank !== 1) {
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${shape2Input.rank}`);
  }
  const inputs = { s0: shape1Input, s1: shape2Input };
  return ENGINE.runKernel(BroadcastArgs, inputs);
}
var broadcastArgs = op({ broadcastArgs_ });
function broadcastTo_(x2, shape) {
  let input2 = convertToTensor(x2, "broadcastTo", "x");
  const xShape = input2.shape;
  if (shape.some((d2) => !(d2 > 0) || d2 % 1 !== 0)) {
    throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);
  }
  if (shape.length < input2.rank) {
    throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input2.rank}.`);
  }
  if (shape.length > input2.rank) {
    const newShape = input2.shape.slice();
    while (newShape.length < shape.length) {
      newShape.unshift(1);
    }
    input2 = reshape(input2, newShape);
  }
  const inputShape = input2.shape;
  const reps = Array.from(shape);
  for (let i2 = shape.length - 1; i2 >= 0; i2--) {
    if (inputShape[i2] === shape[i2]) {
      reps[i2] = 1;
    } else if (input2.shape[i2] !== 1) {
      throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
    }
  }
  const axes = reps.map((n2, i2) => n2 > 1 ? i2 : -1).filter((i2) => i2 >= 0);
  if (axes.length === 0) {
    return clone(input2);
  }
  const inputs = { x: input2 };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
var broadcastTo = op({ broadcastTo_ });
function ceil_(x2) {
  const $x = convertToTensor(x2, "x", "ceil");
  const inputs = { x: $x };
  return ENGINE.runKernel(Ceil, inputs);
}
var ceil = op({ ceil_ });
function clipByValue_(x2, clipValueMin, clipValueMax) {
  const $x = convertToTensor(x2, "x", "clipByValue");
  assert(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
  const inputs = { x: $x };
  const attrs = { clipValueMin, clipValueMax };
  return ENGINE.runKernel(ClipByValue, inputs, attrs);
}
var clipByValue = op({ clipByValue_ });
function concat1d_(tensors) {
  return concat(tensors, 0);
}
var concat1d = op({ concat1d_ });
function concat2d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat2d = op({ concat2d_ });
function concat3d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat3d = op({ concat3d_ });
function concat4d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat4d = op({ concat4d_ });
function conv2d_(x2, filter, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "conv2d");
  const $filter = convertToTensor(filter, "filter", "conv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad3, dataFormat, dilations, dimRoundingMode };
  const res2 = ENGINE.runKernel(Conv2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var conv2d = op({ conv2d_ });
function conv1d_(x2, filter, stride, pad3, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "conv1d");
  const $filter = convertToTensor(filter, "filter", "conv1d");
  let x3D = $x;
  let reshapedTo3D = false;
  if ($x.rank === 2) {
    reshapedTo3D = true;
    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);
  }
  assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
  assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in conv1d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
  assert(eitherStridesOrDilationsAreOne(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
  assert(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
  const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
  const strides = [1, stride];
  const dilations = [1, dilation];
  const conv2dDataFormat = "NHWC";
  const res2 = conv2d(input4D, filter4D, strides, pad3, conv2dDataFormat, dilations, dimRoundingMode);
  if (reshapedTo3D) {
    return reshape(res2, [res2.shape[2], res2.shape[3]]);
  }
  return reshape(res2, [res2.shape[0], res2.shape[2], res2.shape[3]]);
}
var conv1d = op({ conv1d_ });
function conv2DBackpropInput_(xShape, dy, filter, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
  assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape4D = xShape;
  let dy4D = dy;
  let reshapedTo4D = false;
  if (dy.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    xShape4D = [1, xShape[0], xShape[1], xShape[2]];
  }
  assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
  assert(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`);
  const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[2]}.`);
  assert(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[3]}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { dy: dy4D, filter };
  const attrs = { strides, pad: pad3, dataFormat, dimRoundingMode, inputShape: xShape4D };
  const res2 = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var conv2DBackpropInput = op({ conv2DBackpropInput_ });
function conv2dTranspose_(x2, filter, outputShape, strides, pad3, dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "conv2dTranspose");
  const $filter = convertToTensor(filter, "filter", "conv2dTranspose");
  return conv2DBackpropInput(outputShape, $x, $filter, strides, pad3, "NHWC", dimRoundingMode);
}
var conv2dTranspose = op({ conv2dTranspose_ });
function conv3d_(x2, filter, strides, pad3, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
  const $x = convertToTensor(x2, "x", "conv3d");
  const $filter = convertToTensor(filter, "filter", "conv3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
  assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
  assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  assert(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
  const inputs = { x: x5D, filter: $filter };
  const attrs = { strides, pad: pad3, dataFormat, dilations };
  const res2 = ENGINE.runKernel(Conv3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var conv3d = op({ conv3d_ });
function conv3DBackpropInput_(xShape, dy, filter, strides, pad3) {
  assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape5D = xShape;
  let dy5D = dy;
  let reshapedTo5D = false;
  if (dy.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
    xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
  }
  const inDepth = xShape5D[4];
  const outDepth = dy5D.shape[4];
  assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
  assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
  assert(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`);
  assert(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[3]}.`);
  assert(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[4]}.`);
  const inputs = { dy: dy5D, filter };
  const attrs = { pad: pad3, strides, inputShape: xShape5D };
  const res2 = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var conv3DBackpropInput = op({ conv3DBackpropInput_ });
function conv3dTranspose_(x2, filter, outputShape, strides, pad3) {
  const $x = convertToTensor(x2, "x", "conv3dTranspose");
  const $filter = convertToTensor(filter, "filter", "conv3dTranspose");
  return conv3DBackpropInput(outputShape, $x, $filter, strides, pad3);
}
var conv3dTranspose = op({ conv3dTranspose_ });
function cos_(x2) {
  const $x = convertToTensor(x2, "x", "cos");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cos, inputs);
}
var cos = op({ cos_ });
function cosh_(x2) {
  const $x = convertToTensor(x2, "x", "cosh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cosh, inputs);
}
var cosh = op({ cosh_ });
function cumsum_(x2, axis = 0, exclusive = false, reverse5 = false) {
  const $x = convertToTensor(x2, "x", "cumsum");
  const inputs = { x: $x };
  const attrs = { axis, exclusive, reverse: reverse5 };
  return ENGINE.runKernel(Cumsum, inputs, attrs);
}
var cumsum = op({ cumsum_ });
function denseBincount_(x2, weights, size2, binaryOutput = false) {
  const $x = convertToTensor(x2, "x", "denseBincount");
  const $weights = convertToTensor(weights, "weights", "denseBincount");
  assert($x.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${$x.dtype}`);
  assert($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${$x.rank}.`);
  assert(size2 >= 0, () => `size must be non-negative, but got ${size2}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size: size2, binaryOutput };
  return ENGINE.runKernel(DenseBincount, inputs, attrs);
}
var denseBincount = op({ denseBincount_ });
function depthToSpace_(x2, blockSize, dataFormat = "NHWC") {
  const $x = convertToTensor(x2, "x", "depthToSpace");
  const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
  assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
  assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
  assert(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
  const inputs = { x: $x };
  const attrs = { blockSize, dataFormat };
  return ENGINE.runKernel(DepthToSpace, inputs, attrs);
}
var depthToSpace = op({ depthToSpace_ });
function depthwiseConv2d_(x2, filter, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "depthwiseConv2d");
  const $filter = convertToTensor(filter, "filter", "depthwiseConv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad3, dataFormat, dilations, dimRoundingMode };
  const res2 = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var depthwiseConv2d = op({ depthwiseConv2d_ });
function diag_(x2) {
  const $x = convertToTensor(x2, "x", "diag");
  const inputs = { x: $x };
  return ENGINE.runKernel(Diag, inputs);
}
var diag = op({ diag_ });
function dilation2d_(x2, filter, strides, pad3, dilations = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x2, "x", "dilation2d");
  const $filter = convertToTensor(filter, "filter", "dilation2d");
  assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
  assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
  assert(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    reshapedTo4D = true;
  }
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad3, dilations };
  const res2 = ENGINE.runKernel(Dilation2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var dilation2d = op({ dilation2d_ });
function getBroadcastDims(inShape, outShape) {
  const inRank = inShape.length;
  const dims = [];
  for (let i2 = 0; i2 < inRank; i2++) {
    const dim = inRank - 1 - i2;
    const a6 = inShape[dim] || 1;
    const b2 = outShape[outShape.length - 1 - i2] || 1;
    if (b2 > 1 && a6 === 1) {
      dims.unshift(dim);
    }
  }
  return dims;
}
function getReductionAxes(inShape, outShape) {
  const result = [];
  for (let i2 = 0; i2 < outShape.length; i2++) {
    const inDim = inShape[inShape.length - i2 - 1];
    const outAxis = outShape.length - i2 - 1;
    const outDim = outShape[outAxis];
    if (inDim == null || inDim === 1 && outDim > 1) {
      result.unshift(outAxis);
    }
  }
  return result;
}
function assertAndGetBroadcastShape(shapeA, shapeB) {
  const result = [];
  const l3 = Math.max(shapeA.length, shapeB.length);
  for (let i2 = 0; i2 < l3; i2++) {
    let a6 = shapeA[shapeA.length - i2 - 1];
    if (a6 == null) {
      a6 = 1;
    }
    let b2 = shapeB[shapeB.length - i2 - 1];
    if (b2 == null) {
      b2 = 1;
    }
    if (a6 === 1) {
      result.unshift(b2);
    } else if (b2 === 1) {
      result.unshift(a6);
    } else if (a6 !== b2) {
      const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
      throw Error(errMsg);
    } else {
      result.unshift(a6);
    }
  }
  return result;
}
function equal_(a6, b2) {
  let $a = convertToTensor(a6, "a", "equal", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "equal", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Equal, inputs);
}
var equal = op({ equal_ });
function where_(condition, a6, b2) {
  const $a = convertToTensor(a6, "a", "where");
  const $b = convertToTensor(b2, "b", "where");
  const $condition = convertToTensor(condition, "condition", "where", "bool");
  const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
  const $broadcastedCondition = broadcastTo($condition, broadcastShape);
  const $broadcastedA = broadcastTo($a, broadcastShape);
  const $broadcastedB = broadcastTo($b, broadcastShape);
  const inputs = {
    condition: $broadcastedCondition,
    t: $broadcastedA,
    e: $broadcastedB
  };
  return ENGINE.runKernel(Select, inputs);
}
var where = op({ where_ });
function zerosLike_(x2) {
  const $x = convertToTensor(x2, "x", "zerosLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(ZerosLike, inputs);
}
var zerosLike = op({ zerosLike_ });
function divNoNan_(a6, b2) {
  let $a = convertToTensor(a6, "a", "div");
  let $b = convertToTensor(b2, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  const divResult = div($a, $b);
  const zeros4 = zerosLike(divResult);
  const bEqualsZero = equal($b, zeros4);
  return where(bEqualsZero, zeros4, divResult);
}
var divNoNan = op({ divNoNan_ });
function dot_(t1, t2) {
  const $t1 = convertToTensor(t1, "t1", "dot");
  const $t2 = convertToTensor(t2, "t2", "dot");
  assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);
  const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
  const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
  assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
  if ($t1.rank === 1 && $t2.rank === 1) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul(t12D, t22D);
    return reshape(t1t2, []);
  } else if ($t1.rank === 1 && $t2.rank === 2) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul(t12D, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else if ($t1.rank === 2 && $t2.rank === 1) {
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul($t1, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else {
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul($t1, t22D);
    return t1t2;
  }
}
var dot = op({ dot_ });
function einsum_(equation, ...tensors) {
  const $tensors = tensors.map((t2, i2) => convertToTensor(t2, `tensors${i2}`, "einsum"));
  const attrs = { equation };
  return ENGINE.runKernel(Einsum, $tensors, attrs);
}
var einsum = op({ einsum_ });
function elu_(x2) {
  const $x = convertToTensor(x2, "x", "elu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Elu, inputs);
}
var elu = op({ elu_ });
function erf_(x2) {
  let $x = convertToTensor(x2, "x", "erf");
  assert($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
  if ($x.dtype === "int32") {
    $x = cast($x, "float32");
  }
  const inputs = { x: $x };
  return ENGINE.runKernel(Erf, inputs);
}
var erf = op({ erf_ });
function exp_(x2) {
  const $x = convertToTensor(x2, "x", "exp");
  const inputs = { x: $x };
  return ENGINE.runKernel(Exp, inputs);
}
var exp = op({ exp_ });
function expandDims_(x2, axis = 0) {
  const $x = convertToTensor(x2, "x", "expandDims", "string_or_numeric");
  assert(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
  const inputs = { input: $x };
  const attrs = { dim: axis };
  return ENGINE.runKernel(ExpandDims, inputs, attrs);
}
var expandDims = op({ expandDims_ });
function expm1_(x2) {
  const $x = convertToTensor(x2, "x", "expm1");
  const inputs = { x: $x };
  return ENGINE.runKernel(Expm1, inputs);
}
var expm1 = op({ expm1_ });
function tile_(x2, reps) {
  const $x = convertToTensor(x2, "x", "tile", "string_or_numeric");
  assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
  const inputs = { x: $x };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
var tile = op({ tile_ });
function eye_(numRows, numColumns, batchShape, dtype = "float32") {
  if (numColumns == null) {
    numColumns = numRows;
  }
  const buff = buffer([numRows, numColumns], dtype);
  const n2 = numRows <= numColumns ? numRows : numColumns;
  for (let i2 = 0; i2 < n2; ++i2) {
    buff.set(1, i2, i2);
  }
  const out = reshape(buff.toTensor(), [numRows, numColumns]);
  if (batchShape == null) {
    return out;
  } else {
    if (batchShape.length === 1) {
      return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
    } else if (batchShape.length === 2) {
      return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
    } else if (batchShape.length === 3) {
      return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
        batchShape[0],
        batchShape[1],
        batchShape[2],
        1,
        1
      ]);
    } else {
      throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
    }
  }
}
var eye = op({ eye_ });
function fill(shape, value, dtype) {
  const attrs = { shape, value, dtype };
  return ENGINE.runKernel(Fill, {}, attrs);
}
function floor_(x2) {
  const $x = convertToTensor(x2, "x", "floor");
  const inputs = { x: $x };
  return ENGINE.runKernel(Floor, inputs);
}
var floor = op({ floor_ });
function gather_(x2, indices, axis = 0, batchDims = 0) {
  const $x = convertToTensor(x2, "x", "gather");
  const $indices = convertToTensor(indices, "indices", "gather", "int32");
  const inputs = { x: $x, indices: $indices };
  const attrs = { axis, batchDims };
  return ENGINE.runKernel(GatherV2, inputs, attrs);
}
var gather = op({ gather_ });
function greater_(a6, b2) {
  let $a = convertToTensor(a6, "a", "greater", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "greater", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Greater, inputs);
}
var greater = op({ greater_ });
function greaterEqual_(a6, b2) {
  let $a = convertToTensor(a6, "a", "greaterEqual", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "greaterEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(GreaterEqual, inputs);
}
var greaterEqual = op({ greaterEqual_ });
function imag_(input2) {
  const $input = convertToTensor(input2, "input", "imag");
  const inputs = { input: $input };
  return ENGINE.runKernel(Imag, inputs);
}
var imag = op({ imag_ });
function isFinite_(x2) {
  const $x = convertToTensor(x2, "x", "isFinite");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsFinite, inputs);
}
var isFinite2 = op({ isFinite_ });
function isInf_(x2) {
  const $x = convertToTensor(x2, "x", "isInf");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsInf, inputs);
}
var isInf = op({ isInf_ });
function isNaN_(x2) {
  const $x = convertToTensor(x2, "x", "isNaN");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsNan, inputs);
}
var isNaN2 = op({ isNaN_ });
function leakyRelu_(x2, alpha = 0.2) {
  const $x = convertToTensor(x2, "x", "leakyRelu");
  const inputs = { x: $x };
  const attrs = { alpha };
  return ENGINE.runKernel(LeakyRelu, inputs, attrs);
}
var leakyRelu = op({ leakyRelu_ });
function less_(a6, b2) {
  let $a = convertToTensor(a6, "a", "less", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "less", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Less, inputs);
}
var less = op({ less_ });
function lessEqual_(a6, b2) {
  let $a = convertToTensor(a6, "a", "lessEqual", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "lessEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LessEqual, inputs);
}
var lessEqual = op({ lessEqual_ });
function linspace(start, stop, num) {
  if (num <= 0) {
    throw new Error("The number of values should be positive.");
  }
  const attrs = { start, stop, num };
  return ENGINE.runKernel(LinSpace, {}, attrs);
}
function localResponseNormalization_(x2, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
  const $x = convertToTensor(x2, "x", "localResponseNormalization");
  assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
  assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  const inputs = { x: x4D };
  const attrs = { depthRadius, bias, alpha, beta };
  const res2 = ENGINE.runKernel(LRN, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  } else {
    return res2;
  }
}
var localResponseNormalization = op({ localResponseNormalization_ });
function log_(x2) {
  const $x = convertToTensor(x2, "x", "log");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log, inputs);
}
var log5 = op({ log_ });
function log1p_(x2) {
  const $x = convertToTensor(x2, "x", "log1p");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log1p, inputs);
}
var log1p = op({ log1p_ });
function grad(f2) {
  assert(isFunction(f2), () => "The f passed in grad(f) must be a function");
  return (x2, dy) => {
    const $x = convertToTensor(x2, "x", "tf.grad", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grad") : null;
    return ENGINE.tidy(() => {
      const { value, grads: grads2 } = ENGINE.gradients(() => f2($x), [$x], $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
      }
      checkGrads(grads2);
      return grads2[0];
    });
  };
}
function grads(f2) {
  assert(isFunction(f2), () => "The f passed in grads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    const $args = convertToTensorArray(args, "args", "tf.grads", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grads") : null;
    return ENGINE.tidy(() => {
      const { value, grads: grads2 } = ENGINE.gradients(() => f2(...$args), $args, $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
      }
      checkGrads(grads2);
      return grads2;
    });
  };
}
function valueAndGrad(f2) {
  assert(isFunction(f2), () => "The f passed in valueAndGrad(f) must be a function");
  return (x2, dy) => {
    assert(x2 instanceof Tensor, () => "The x passed in valueAndGrad(f)(x) must be a tensor");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    const { grads: grads2, value } = ENGINE.gradients(() => f2(x2), [x2], dy);
    checkGrads(grads2);
    return { grad: grads2[0], value };
  };
}
function valueAndGrads(f2) {
  assert(isFunction(f2), () => "The f passed in valueAndGrads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args) && args.every((arg) => arg instanceof Tensor), () => "The args passed in valueAndGrads(f)(args) must be array of tensors");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    const res2 = ENGINE.gradients(() => f2(...args), args, dy);
    if (dy != null) {
      assertShapesMatch(res2.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
    }
    checkGrads(res2.grads);
    return res2;
  };
}
function variableGrads(f2, varList) {
  assert(isFunction(f2), () => "The f passed in variableGrads(f) must be a function");
  assert(varList == null || Array.isArray(varList) && varList.every((v2) => v2 instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  const specifiedVarList = varList != null;
  if (!specifiedVarList) {
    varList = [];
    for (const varName in ENGINE.registeredVariables) {
      varList.push(ENGINE.registeredVariables[varName]);
    }
  }
  const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
  const originalVarCount = varList.length;
  varList = varList.filter((variable2) => variable2.trainable);
  assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
  const allowNoGradients = true;
  const { value, grads: grads2 } = ENGINE.gradients(f2, varList, null, allowNoGradients);
  assert(grads2.some((g2) => g2 != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
  assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
  const namedGrads = {};
  varList.forEach((v2, i2) => {
    if (grads2[i2] != null) {
      namedGrads[v2.name] = grads2[i2];
    }
  });
  if (specifiedNonTrainable != null) {
    specifiedNonTrainable.forEach((v2) => namedGrads[v2.name] = null);
  }
  return { value, grads: namedGrads };
}
function customGrad(f2) {
  return ENGINE.customGrad(f2);
}
function checkGrads(grads2) {
  const numNullGradients = grads2.filter((g2) => g2 == null).length;
  if (numNullGradients > 0) {
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
  }
}
function neg_(x2) {
  const $x = convertToTensor(x2, "x", "neg");
  const inputs = { x: $x };
  return ENGINE.runKernel(Neg, inputs);
}
var neg = op({ neg_ });
function softplus_(x2) {
  const $x = convertToTensor(x2, "x", "softplus");
  const inputs = { x: $x };
  return ENGINE.runKernel(Softplus, inputs);
}
var softplus = op({ softplus_ });
function logSigmoid_(x2) {
  const $x = convertToTensor(x2, "x", "logSigmoid");
  const customOp = customGrad((x22) => {
    const value = neg(softplus(neg(x22)));
    const gradFunc = (dy) => {
      const derX = mul(dy, sigmoid(neg(x22)));
      return derX;
    };
    return { value, gradFunc };
  });
  return customOp($x);
}
var logSigmoid = op({ logSigmoid_ });
function max_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "max");
  const inputs = { x: $x };
  const attrs = { reductionIndices: axis, keepDims };
  return ENGINE.runKernel(Max, inputs, attrs);
}
var max = op({ max_ });
function sub_(a6, b2) {
  let $a = convertToTensor(a6, "a", "sub");
  let $b = convertToTensor(b2, "b", "sub");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Sub, inputs);
}
var sub = op({ sub_ });
function sum_(x2, axis = null, keepDims = false) {
  let $x = convertToTensor(x2, "x", "sum");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Sum, inputs, attrs);
}
var sum2 = op({ sum_ });
function logSoftmax_(logits, axis = -1) {
  const $logits = convertToTensor(logits, "logits", "logSoftmax");
  if (axis === -1) {
    axis = $logits.rank - 1;
  }
  if (axis !== $logits.rank - 1) {
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
  }
  const customOp = customGrad((logits2, save) => {
    const keepDims = true;
    const xMax = max(logits2, axis, true);
    const shifted = sub(logits2, xMax);
    const value = sub(cast(shifted, "float32"), log5(sum2(exp(shifted), axis, keepDims)));
    save([value]);
    const gradFunc = (dy, saved) => {
      const [value2] = saved;
      const keepDims2 = true;
      const softmax7 = exp(value2);
      return sub(dy, mul(sum2(dy, axis, keepDims2), softmax7));
    };
    return { value, gradFunc };
  });
  return customOp($logits);
}
var logSoftmax = op({ logSoftmax_ });
function axesAreInnerMostDims(axes, rank) {
  for (let i2 = 0; i2 < axes.length; ++i2) {
    if (axes[axes.length - i2 - 1] !== rank - 1 - i2) {
      return false;
    }
  }
  return true;
}
function combineLocations(outputLoc, reduceLoc, axes) {
  const rank = outputLoc.length + reduceLoc.length;
  const loc = [];
  let outIdx = 0;
  let reduceIdx = 0;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      loc.push(outputLoc[outIdx++]);
    } else {
      loc.push(reduceLoc[reduceIdx++]);
    }
  }
  return loc;
}
function computeOutAndReduceShapes(aShape, axes) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      outShape.push(aShape[dim]);
    }
  }
  const reduceShape = axes.map((dim) => aShape[dim]);
  return [outShape, reduceShape];
}
function expandShapeToKeepDim(shape, axes) {
  const reduceSubShape = axes.map((x2) => 1);
  return combineLocations(shape, reduceSubShape, axes);
}
function assertAxesAreInnerMostDims(msg, axes, rank) {
  assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
}
function getAxesPermutation(axes, rank) {
  if (axesAreInnerMostDims(axes, rank)) {
    return null;
  }
  const result = [];
  for (let i2 = 0; i2 < rank; ++i2) {
    if (axes.indexOf(i2) === -1) {
      result.push(i2);
    }
  }
  axes.forEach((axis) => result.push(axis));
  return result;
}
function getUndoAxesPermutation(axes) {
  return axes.map((axis, i2) => [i2, axis]).sort((a6, b2) => a6[1] - b2[1]).map((x2) => x2[0]);
}
function getInnerMostAxes(numAxes, rank) {
  const res2 = [];
  for (let i2 = rank - numAxes; i2 < rank; ++i2) {
    res2.push(i2);
  }
  return res2;
}
function logSumExp_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "logSumExp");
  const axes = parseAxisParam(axis, $x.shape);
  const xMax = max($x, axes, true);
  const a6 = sub($x, xMax);
  const b2 = exp(a6);
  const c2 = sum2(b2, axes);
  const d2 = log5(c2);
  const res2 = add2(reshape(xMax, d2.shape), d2);
  if (keepDims) {
    const newShape = expandShapeToKeepDim(res2.shape, axes);
    return reshape(res2, newShape);
  }
  return res2;
}
var logSumExp = op({ logSumExp_ });
function logicalAnd_(a6, b2) {
  const $a = convertToTensor(a6, "a", "logicalAnd", "bool");
  const $b = convertToTensor(b2, "b", "logicalAnd", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalAnd, inputs);
}
var logicalAnd = op({ logicalAnd_ });
function logicalNot_(x2) {
  const $x = convertToTensor(x2, "x", "logicalNot", "bool");
  const inputs = { x: $x };
  return ENGINE.runKernel(LogicalNot, inputs);
}
var logicalNot = op({ logicalNot_ });
function logicalOr_(a6, b2) {
  const $a = convertToTensor(a6, "a", "logicalOr", "bool");
  const $b = convertToTensor(b2, "b", "logicalOr", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalOr, inputs);
}
var logicalOr = op({ logicalOr_ });
function logicalXor_(a6, b2) {
  const $a = convertToTensor(a6, "a", "logicalXor", "bool");
  const $b = convertToTensor(b2, "b", "logicalXor", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  return logicalAnd(logicalOr(a6, b2), logicalNot(logicalAnd(a6, b2)));
}
var logicalXor = op({ logicalXor_ });
function maxPool_(x2, filterSize, strides, pad3, dimRoundingMode) {
  const $x = convertToTensor(x2, "x", "maxPool");
  const dilations = 1;
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in maxPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
  const res2 = ENGINE.runKernel(MaxPool, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var maxPool = op({ maxPool_ });
function maxPool3d_(x2, filterSize = [1, 1, 1], strides, pad3, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x2, "x", "maxPool3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat };
  const res2 = ENGINE.runKernel(MaxPool3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var maxPool3d = op({ maxPool3d_ });
function maxPoolWithArgmax_(x2, filterSize, strides, pad3, includeBatchInIndex = false) {
  const $x = convertToTensor(x2, "x", "maxPoolWithArgmax");
  const inputs = { x: $x };
  const attrs = { filterSize, strides, pad: pad3, includeBatchInIndex };
  const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
  return { result: result[0], indexes: result[1] };
}
var maxPoolWithArgmax = op({ maxPoolWithArgmax_ });
function maximum_(a6, b2) {
  let $a = convertToTensor(a6, "a", "maximum");
  let $b = convertToTensor(b2, "b", "maximum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Maximum, inputs);
}
var maximum = op({ maximum_ });
function mean_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "mean");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Mean, inputs, attrs);
}
var mean = op({ mean_ });
function zeros(shape, dtype = "float32") {
  if (dtype === "complex64") {
    const real5 = zeros(shape, "float32");
    const imag5 = zeros(shape, "float32");
    return complex(real5, imag5);
  }
  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
function ones2(shape, dtype = "float32") {
  if (dtype === "complex64") {
    const real5 = ones2(shape, "float32");
    const imag5 = zeros(shape, "float32");
    return complex(real5, imag5);
  }
  const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
function meshgrid(x2, y2, { indexing = "xy" } = {}) {
  if (indexing !== "xy" && indexing !== "ij") {
    throw new TypeError(`${indexing} is not a valid third argument to meshgrid`);
  }
  if (x2 === void 0) {
    return [];
  }
  let $x = convertToTensor(x2, "x", "meshgrid", x2 instanceof Tensor ? x2.dtype : "float32");
  if (y2 === void 0) {
    return [$x];
  }
  let $y = convertToTensor(y2, "y", "meshgrid", y2 instanceof Tensor ? y2.dtype : "float32");
  const w2 = sizeFromShape($x.shape);
  const h2 = sizeFromShape($y.shape);
  if (indexing === "xy") {
    $x = reshape($x, [1, -1]);
    $y = reshape($y, [-1, 1]);
    return [
      matMul(ones2([h2, 1], $x.dtype), $x),
      matMul($y, ones2([1, w2], $y.dtype))
    ];
  }
  $x = reshape($x, [-1, 1]);
  $y = reshape($y, [1, -1]);
  return [
    matMul($x, ones2([1, h2], $x.dtype)),
    matMul(ones2([w2, 1], $y.dtype), $y)
  ];
}
function min_(x2, axis = null, keepDims = false) {
  const $x = convertToTensor(x2, "x", "min");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Min, inputs, attrs);
}
var min = op({ min_ });
function minimum_(a6, b2) {
  let $a = convertToTensor(a6, "a", "minimum");
  let $b = convertToTensor(b2, "b", "minimum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Minimum, inputs);
}
var minimum = op({ minimum_ });
function mirrorPad_(x2, paddings, mode) {
  assert(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
  const $x = convertToTensor(x2, "x", "mirrorPad");
  if ($x.rank === 0) {
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  }
  assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
  const shapeOffset = mode === "reflect" ? 1 : 0;
  for (let i2 = 0; i2 < $x.rank; i2++) {
    assert(paddings[i2].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
    assert(paddings[i2][0] >= 0 && paddings[i2][0] <= $x.shape[i2] - shapeOffset && paddings[i2][1] >= 0 && paddings[i2][1] <= $x.shape[i2] - shapeOffset, () => `Padding in dimension ${i2} cannot be greater than or equal to ${$x.shape[i2] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
  }
  const attrs = { paddings, mode };
  const inputs = { x: $x };
  return ENGINE.runKernel(MirrorPad, inputs, attrs);
}
var mirrorPad = op({ mirrorPad_ });
function mod_(a6, b2) {
  let $a = convertToTensor(a6, "a", "mod");
  let $b = convertToTensor(b2, "b", "mod");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Mod, inputs);
}
var mod = op({ mod_ });
function square_(x2) {
  const $x = convertToTensor(x2, "x", "square");
  const attrs = {};
  return ENGINE.runKernel("Square", { x: $x }, attrs);
}
var square = op({ square_ });
function moments_(x2, axis = null, keepDims = false) {
  x2 = convertToTensor(x2, "x", "moments");
  const axes = parseAxisParam(axis, x2.shape);
  const xMean = mean(x2, axes, keepDims);
  let keepDimsShape = xMean.shape;
  if (!keepDims) {
    keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
  }
  const devSquared = square(sub(cast(x2, "float32"), reshape(xMean, keepDimsShape)));
  const variance = mean(devSquared, axes, keepDims);
  return { mean: xMean, variance };
}
var moments = op({ moments_ });
function multiRNNCell_(lstmCells, data, c2, h2) {
  const $data = convertToTensor(data, "data", "multiRNNCell");
  const $c = convertToTensorArray(c2, "c", "multiRNNCell");
  const $h = convertToTensorArray(h2, "h", "multiRNNCell");
  let input2 = $data;
  const newStates = [];
  for (let i2 = 0; i2 < lstmCells.length; i2++) {
    const output = lstmCells[i2](input2, $c[i2], $h[i2]);
    newStates.push(output[0]);
    newStates.push(output[1]);
    input2 = output[1];
  }
  const newC = [];
  const newH = [];
  for (let i2 = 0; i2 < newStates.length; i2 += 2) {
    newC.push(newStates[i2]);
    newH.push(newStates[i2 + 1]);
  }
  return [newC, newH];
}
var multiRNNCell = op({ multiRNNCell_ });
function multinomial_(logits, numSamples, seed, normalized = false) {
  const $logits = convertToTensor(logits, "logits", "multinomial");
  const numOutcomes = $logits.size;
  const origRank = $logits.rank;
  if (numOutcomes < 2) {
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${numOutcomes}.`);
  }
  if (origRank > 2) {
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
  }
  seed = seed || Math.random();
  const logits2D = origRank === 1 ? reshape($logits, [1, -1]) : $logits;
  const inputs = { logits: logits2D };
  const attrs = { numSamples, seed, normalized };
  const res2 = ENGINE.runKernel(Multinomial, inputs, attrs);
  return origRank === 1 ? reshape(res2, [res2.size]) : res2;
}
var multinomial = op({ multinomial_ });
function notEqual_(a6, b2) {
  let $a = convertToTensor(a6, "a", "notEqual", "string_or_numeric");
  let $b = convertToTensor(b2, "b", "notEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(NotEqual, inputs);
}
var notEqual = op({ notEqual_ });
function onesLike_(x2) {
  const $x = convertToTensor(x2, "x", "onesLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(OnesLike, inputs);
}
var onesLike = op({ onesLike_ });
function outerProduct_(v1, v2) {
  const $v1 = convertToTensor(v1, "v1", "outerProduct");
  const $v2 = convertToTensor(v2, "v2", "outerProduct");
  assert($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${$v1.rank} and ${$v2.rank}.`);
  const v12D = reshape($v1, [-1, 1]);
  const v22D = reshape($v2, [1, -1]);
  return matMul(v12D, v22D);
}
var outerProduct = op({ outerProduct_ });
function pad_(x2, paddings, constantValue = 0) {
  const $x = convertToTensor(x2, "x", "pad");
  if ($x.rank === 0) {
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  }
  const attrs = { paddings, constantValue };
  const inputs = { x: $x };
  return ENGINE.runKernel(PadV2, inputs, attrs);
}
var pad = op({ pad_ });
function pad1d_(x2, paddings, constantValue = 0) {
  assert(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
  return pad(x2, [paddings], constantValue);
}
var pad1d = op({ pad1d_ });
function pad2d_(x2, paddings, constantValue = 0) {
  assert(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x2, paddings, constantValue);
}
var pad2d = op({ pad2d_ });
function pad3d_(x2, paddings, constantValue = 0) {
  assert(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x2, paddings, constantValue);
}
var pad3d = op({ pad3d_ });
function pad4d_(x2, paddings, constantValue = 0) {
  assert(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x2, paddings, constantValue);
}
var pad4d = op({ pad4d_ });
function spaceToBatchND_(x2, blockShape, paddings) {
  const $x = convertToTensor(x2, "x", "spaceToBatchND");
  assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
  assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
  assert($x.shape.reduce((a6, b2, i2) => {
    if (i2 > 0 && i2 <= blockShape.length) {
      return a6 && (b2 + paddings[i2 - 1][0] + paddings[i2 - 1][1]) % blockShape[i2 - 1] === 0;
    }
    return a6;
  }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
  const inputs = { x: $x };
  const attrs = { blockShape, paddings };
  return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
}
var spaceToBatchND = op({ spaceToBatchND_ });
function pool_(input2, windowShape, poolingType, pad3, dilations, strides) {
  if (dilations == null) {
    dilations = [1, 1];
  }
  if (strides == null) {
    strides = 1;
  }
  if (pad3 === 0) {
    pad3 = "valid";
  }
  const $x = convertToTensor(input2, "x", "maxPool");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad3);
  const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
  let basePadding;
  if (pad3 === "same") {
    basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
  } else {
    basePadding = [[0, 0], [0, 0]];
  }
  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
  const convertedPad = isDilationOne ? pad3 : "valid";
  const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
  const forwardOp = poolingType === "avg" ? () => avgPool(convertedX, windowShape, strides, convertedPad) : () => maxPool(convertedX, windowShape, strides, convertedPad);
  const y2 = forwardOp();
  const res2 = isDilationOne ? y2 : batchToSpaceND(y2, dilation, adjustedCrops);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
  const padStart = basePadding.map((b2) => b2[0]);
  const origPadEnd = basePadding.map((b2) => b2[1]);
  const fullInputShape = inputShape.concat(padStart, origPadEnd);
  const padEndExtra = blockShape.map((b2, i2) => (b2 - fullInputShape[i2] % b2) % b2);
  const padEnd = origPadEnd.map((s2, i2) => s2 + padEndExtra[i2]);
  const paddings = blockShape.map((_2, i2) => [padStart[i2], padEnd[i2]]);
  const crops = blockShape.map((_2, i2) => [0, padEndExtra[i2]]);
  return [paddings, crops];
}
function withSpaceToBatchBasePaddings(filterShape, dilation) {
  const dilatedFilterShape = filterShape.map((s2, i2) => {
    return s2 + (s2 - 1) * (dilation[i2] - 1);
  });
  const padExtraShape = dilatedFilterShape.map((s2) => s2 - 1);
  const padExtraStart = padExtraShape.map((s2) => Math.floor(s2 / 2));
  const padExtraEnd = padExtraShape.map((s2, i2) => s2 - padExtraStart[i2]);
  return padExtraShape.map((_2, i2) => {
    return [padExtraStart[i2], padExtraEnd[i2]];
  });
}
var pool = op({ pool_ });
function pow_(base2, exp5) {
  let $base = convertToTensor(base2, "base", "pow");
  let $exp = convertToTensor(exp5, "exp", "pow");
  [$base, $exp] = makeTypesMatch($base, $exp);
  const inputs = { a: $base, b: $exp };
  return ENGINE.runKernel(Pow, inputs);
}
var pow = op({ pow_ });
function prelu_(x2, alpha) {
  const $x = convertToTensor(x2, "x", "prelu");
  const $alpha = convertToTensor(alpha, "alpha", "prelu");
  const inputs = { x: $x, alpha: $alpha };
  return ENGINE.runKernel(Prelu, inputs);
}
var prelu = op({ prelu_ });
function prod_(x2, axis = null, keepDims = false) {
  let $x = convertToTensor(x2, "x", "prod");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Prod, inputs, attrs);
}
var prod = op({ prod_ });
function rand_(shape, randFunction, dtype) {
  const size2 = sizeFromShape(shape);
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size2);
  } else if (dtype === "int32") {
    values = new Int32Array(size2);
  } else if (dtype === "bool") {
    values = new Uint8Array(size2);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  for (let i2 = 0; i2 < size2; i2++) {
    values[i2] = randFunction();
  }
  return ENGINE.makeTensor(values, shape, dtype);
}
var rand = op({ rand_ });
var seedrandom = __toModule(require_seedrandom2());
var MPRandGauss = class {
  constructor(mean5, stdDeviation, dtype, truncated, seed) {
    this.mean = mean5;
    this.stdDev = stdDeviation;
    this.dtype = dtype;
    this.nextVal = NaN;
    this.truncated = truncated;
    if (this.truncated) {
      this.upper = this.mean + this.stdDev * 2;
      this.lower = this.mean - this.stdDev * 2;
    }
    const seedValue = seed ? seed : Math.random();
    this.random = seedrandom.alea(seedValue.toString());
  }
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const value = this.nextVal;
      this.nextVal = NaN;
      return value;
    }
    let resultX, resultY;
    let isValid = false;
    while (!isValid) {
      let v1, v2, s2;
      do {
        v1 = 2 * this.random() - 1;
        v2 = 2 * this.random() - 1;
        s2 = v1 * v1 + v2 * v2;
      } while (s2 >= 1 || s2 === 0);
      const mul2 = Math.sqrt(-2 * Math.log(s2) / s2);
      resultX = this.mean + this.stdDev * v1 * mul2;
      resultY = this.mean + this.stdDev * v2 * mul2;
      if (!this.truncated || this.isValidTruncated(resultX)) {
        isValid = true;
      }
    }
    if (!this.truncated || this.isValidTruncated(resultY)) {
      this.nextVal = this.convertValue(resultY);
    }
    return this.convertValue(resultX);
  }
  convertValue(value) {
    if (this.dtype == null || this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
  isValidTruncated(value) {
    return value <= this.upper && value >= this.lower;
  }
};
var RandGamma = class {
  constructor(alpha, beta, dtype, seed) {
    this.alpha = alpha;
    this.beta = 1 / beta;
    this.dtype = dtype;
    const seedValue = seed ? seed : Math.random();
    this.randu = seedrandom.alea(seedValue.toString());
    this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
    if (alpha < 1) {
      this.d = alpha + 2 / 3;
    } else {
      this.d = alpha - 1 / 3;
    }
    this.c = 1 / Math.sqrt(9 * this.d);
  }
  nextValue() {
    let x2, v0, v1, x3, u2, v2;
    while (true) {
      do {
        x3 = this.randn.nextValue();
        v2 = 1 + this.c * x3;
      } while (v2 <= 0);
      v2 *= v2 * v2;
      x2 = x3 * x3;
      v0 = 1 - 0.331 * x2 * x2;
      v1 = 0.5 * x2 + this.d * (1 - v2 + Math.log(v2));
      u2 = this.randu();
      if (u2 < v0 || Math.log(u2) < v1) {
        break;
      }
    }
    v2 = 1 / this.beta * this.d * v2;
    if (this.alpha < 1) {
      v2 *= Math.pow(this.randu(), 1 / this.alpha);
    }
    return this.convertValue(v2);
  }
  convertValue(value) {
    if (this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
};
var UniformRandom = class {
  constructor(min7 = 0, max7 = 1, dtype, seed) {
    this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
    this.min = min7;
    this.range = max7 - min7;
    this.dtype = dtype;
    if (seed == null) {
      seed = Math.random();
    }
    if (typeof seed === "number") {
      seed = seed.toString();
    }
    if (!this.canReturnFloat() && this.range <= 1) {
      throw new Error(`The difference between ${min7} - ${max7} <= 1 and dtype is not float`);
    }
    this.random = seedrandom.alea(seed);
  }
  convertValue(value) {
    if (this.canReturnFloat()) {
      return value;
    }
    return Math.round(value);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
};
function randomGamma_(shape, alpha, beta = 1, dtype = "float32", seed) {
  if (beta == null) {
    beta = 1;
  }
  if (dtype == null) {
    dtype = "float32";
  }
  if (dtype !== "float32" && dtype !== "int32") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const rgamma = new RandGamma(alpha, beta, dtype, seed);
  const res2 = buffer(shape, dtype);
  for (let i2 = 0; i2 < res2.values.length; i2++) {
    res2.values[i2] = rgamma.nextValue();
  }
  return res2.toTensor();
}
var randomGamma = op({ randomGamma_ });
function randomNormal_(shape, mean5 = 0, stdDev = 1, dtype, seed) {
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const randGauss = new MPRandGauss(mean5, stdDev, dtype, false, seed);
  const res2 = buffer(shape, dtype);
  for (let i2 = 0; i2 < res2.values.length; i2++) {
    res2.values[i2] = randGauss.nextValue();
  }
  return res2.toTensor();
}
var randomNormal = op({ randomNormal_ });
function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
  const res2 = buffer(shape, dtype);
  const random = new UniformRandom(minval, maxval, null, seed);
  for (let i2 = 0; i2 < res2.values.length; i2++) {
    res2.values[i2] = random.nextValue();
  }
  return res2.toTensor();
}
var randomUniform = op({ randomUniform_ });
function range(start, stop, step5 = 1, dtype = "float32") {
  if (step5 === 0) {
    throw new Error("Cannot have a step of zero");
  }
  const attrs = { start, stop, step: step5, dtype };
  return ENGINE.runKernel(Range, {}, attrs);
}
function real_(input2) {
  const $input = convertToTensor(input2, "input", "real");
  const inputs = { input: $input };
  return ENGINE.runKernel(Real, inputs);
}
var real = op({ real_ });
function reciprocal_(x2) {
  const $x = convertToTensor(x2, "x", "reciprocal");
  const inputs = { x: $x };
  return ENGINE.runKernel(Reciprocal, inputs);
}
var reciprocal = op({ reciprocal_ });
function relu_(x2) {
  const $x = convertToTensor(x2, "x", "relu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu, inputs);
}
var relu = op({ relu_ });
function relu6_(x2) {
  const $x = convertToTensor(x2, "x", "relu6");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu6, inputs);
}
var relu6 = op({ relu6_ });
function reverse_(x2, axis) {
  const $x = convertToTensor(x2, "x", "reverse");
  const inputs = { x: $x };
  const attrs = { dims: axis };
  return ENGINE.runKernel(Reverse, inputs, attrs);
}
var reverse = op({ reverse_ });
function reverse1d_(x2) {
  const $x = convertToTensor(x2, "x", "reverse");
  assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
  return reverse($x, 0);
}
var reverse1d = op({ reverse1d_ });
function reverse2d_(x2, axis) {
  const $x = convertToTensor(x2, "x", "reverse");
  assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse2d = op({ reverse2d_ });
function reverse3d_(x2, axis) {
  const $x = convertToTensor(x2, "x", "reverse");
  assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse3d = op({ reverse3d_ });
function reverse4d_(x2, axis) {
  const $x = convertToTensor(x2, "x", "reverse");
  assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse4d = op({ reverse4d_ });
function round_(x2) {
  const $x = convertToTensor(x2, "x", "round");
  const inputs = { x: $x };
  return ENGINE.runKernel(Round, inputs);
}
var round2 = op({ round_ });
function rsqrt_(x2) {
  const $x = convertToTensor(x2, "x", "rsqrt");
  const inputs = { x: $x };
  return ENGINE.runKernel(Rsqrt, inputs);
}
var rsqrt = op({ rsqrt_ });
function scalar(value, dtype) {
  if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  }
  if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  }
  const shape = [];
  const inferredShape = [];
  return makeTensor(value, shape, inferredShape, dtype);
}
function selu_(x2) {
  const $x = convertToTensor(x2, "x", "selu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Selu, inputs);
}
var selu = op({ selu_ });
function separableConv2d_(x2, depthwiseFilter, pointwiseFilter, strides, pad3, dilation = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x2, "x", "separableConv2d");
  const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
  const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  if (dataFormat === "NCHW") {
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  }
  assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
  assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
  const inChannels = $depthwiseFilter.shape[2];
  const channelMultiplier = $depthwiseFilter.shape[3];
  assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
  const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad3, dataFormat, dilation);
  const pointwiseStride = 1;
  const res2 = conv2d(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var separableConv2d = op({ separableConv2d_ });
async function setdiff1dAsync_(x2, y2) {
  const $x = convertToTensor(x2, "x", "setdiff1d");
  const $y = convertToTensor(y2, "y", "setdiff1d");
  assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
  assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
  assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
  const xVals = await $x.data();
  const yVals = await $y.data();
  const ySet = new Set(yVals);
  let outputSize2 = 0;
  for (let i2 = 0; i2 < xVals.length; i2++) {
    if (!ySet.has(xVals[i2])) {
      outputSize2++;
    }
  }
  const buffer2 = new TensorBuffer([outputSize2], $x.dtype);
  const indices = new TensorBuffer([outputSize2], "int32");
  for (let i2 = 0, p22 = 0; i2 < xVals.length; i2++) {
    if (!ySet.has(xVals[i2])) {
      buffer2.values[p22] = xVals[i2];
      indices.values[p22] = i2;
      p22++;
    }
  }
  return [buffer2.toTensor(), indices.toTensor()];
}
var setdiff1dAsync = setdiff1dAsync_;
function sign_(x2) {
  const $x = convertToTensor(x2, "x", "sign");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sign, inputs);
}
var sign2 = op({ sign_ });
function sin_(x2) {
  const $x = convertToTensor(x2, "x", "sin");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sin, inputs);
}
var sin = op({ sin_ });
function sinh_(x2) {
  const $x = convertToTensor(x2, "x", "sinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sinh, inputs);
}
var sinh = op({ sinh_ });
function slice1d_(x2, begin, size2) {
  const $x = convertToTensor(x2, "x", "slice1d");
  assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, [begin], [size2]);
}
var slice1d = op({ slice1d_ });
function slice2d_(x2, begin, size2) {
  const $x = convertToTensor(x2, "x", "slice2d");
  assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size2);
}
var slice2d = op({ slice2d_ });
function slice3d_(x2, begin, size2) {
  const $x = convertToTensor(x2, "x", "slice3d");
  assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size2);
}
var slice3d = op({ slice3d_ });
function slice4d_(x2, begin, size2) {
  const $x = convertToTensor(x2, "x", "slice4d");
  assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size2);
}
var slice4d = op({ slice4d_ });
function softmax_(logits, dim = -1) {
  const $logits = convertToTensor(logits, "logits", "softmax", "float32");
  if (dim === -1) {
    dim = $logits.rank - 1;
  }
  if (dim !== $logits.rank - 1) {
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
  }
  const inputs = { logits: $logits };
  const attrs = { dim };
  return ENGINE.runKernel(Softmax, inputs, attrs);
}
var softmax = op({ softmax_ });
function fft_(input2) {
  assert(input2.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input2.dtype}.`);
  const inputs = { input: input2 };
  return ENGINE.runKernel(FFT, inputs);
}
var fft = op({ fft_ });
function ifft_(input2) {
  assert(input2.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input2.dtype}.`);
  const inputs = { input: input2 };
  return ENGINE.runKernel(IFFT, inputs);
}
var ifft = op({ ifft_ });
function irfft_(input2) {
  const innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = input2.size / innerDimensionSize;
  let ret;
  if (innerDimensionSize <= 2) {
    const complexInput = reshape(input2, [batch, innerDimensionSize]);
    ret = ifft(complexInput);
  } else {
    const outputShape = [batch, 2 * (innerDimensionSize - 1)];
    const realInput = reshape(real(input2), [batch, innerDimensionSize]);
    const imagInput = reshape(imag(input2), [batch, innerDimensionSize]);
    const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
    const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
    const r2 = concat([realInput, realConjugate], 1);
    const i2 = concat([imagInput, imagConjugate], 1);
    const complexInput = reshape(complex(r2, i2), [outputShape[0], outputShape[1]]);
    ret = ifft(complexInput);
  }
  ret = real(ret);
  if (input2.rank === 3 && input2.shape[0] !== 0) {
    const temp = ret;
    const batch2 = input2.shape[0];
    ret = reshape(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
    temp.dispose();
  }
  return ret;
}
var irfft = op({ irfft_ });
function split_(x2, numOrSizeSplits, axis = 0) {
  const $x = convertToTensor(x2, "x", "split");
  const inputs = { x: $x };
  const attr = { numOrSizeSplits, axis };
  return ENGINE.runKernel(SplitV, inputs, attr);
}
var split = op({ split_ });
function rfft_(input2, fftLength) {
  assert(input2.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input2.dtype}`);
  let innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = input2.size / innerDimensionSize;
  let adjustedInput;
  if (fftLength != null && fftLength < innerDimensionSize) {
    const begin = input2.shape.map((v2) => 0);
    const size2 = input2.shape.map((v2) => v2);
    size2[input2.shape.length - 1] = fftLength;
    adjustedInput = slice(input2, begin, size2);
    innerDimensionSize = fftLength;
  } else if (fftLength != null && fftLength > innerDimensionSize) {
    const zerosShape = input2.shape.map((v2) => v2);
    zerosShape[input2.shape.length - 1] = fftLength - innerDimensionSize;
    adjustedInput = concat([input2, zeros(zerosShape)], input2.shape.length - 1);
    innerDimensionSize = fftLength;
  } else {
    adjustedInput = input2;
  }
  const zerosInput = zerosLike(adjustedInput);
  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
  const ret = fft(complexInput);
  const half = Math.floor(innerDimensionSize / 2) + 1;
  const realValues = real(ret);
  const imagValues = imag(ret);
  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
  const outputShape = adjustedInput.shape.slice();
  outputShape[adjustedInput.shape.length - 1] = half;
  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
}
var rfft = op({ rfft_ });
function sqrt_(x2) {
  const $x = convertToTensor(x2, "x", "sqrt");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sqrt, inputs);
}
var sqrt = op({ sqrt_ });
function squaredDifference_(a6, b2) {
  let $a = convertToTensor(a6, "a", "squaredDifference");
  let $b = convertToTensor(b2, "b", "squaredDifference");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(SquaredDifference, inputs, attrs);
}
var squaredDifference = op({ squaredDifference_ });
function squeeze_(x2, axis) {
  const $x = convertToTensor(x2, "x", "squeeze");
  return reshape($x, squeezeShape($x.shape, axis).newShape);
}
var squeeze = op({ squeeze_ });
function stack_(tensors, axis = 0) {
  const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
  assert($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
  if ($tensors.length > 0) {
    assert(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
  }
  const inputs = $tensors;
  const attrs = { axis };
  return ENGINE.runKernel(Pack, inputs, attrs);
}
var stack = op({ stack_ });
function step_(x2, alpha = 0) {
  const $x = convertToTensor(x2, "x", "step");
  const inputs = { x: $x };
  const attrs = { alpha };
  return ENGINE.runKernel(Step, inputs, attrs);
}
var step = op({ step_ });
function stridedSlice_(x2, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
  const $x = convertToTensor(x2, "x", "stridedSlice", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = {
    begin,
    end,
    strides,
    beginMask,
    endMask,
    ellipsisMask,
    newAxisMask,
    shrinkAxisMask
  };
  return ENGINE.runKernel(StridedSlice, inputs, attrs);
}
var stridedSlice = op({ stridedSlice_ });
function tan_(x2) {
  const $x = convertToTensor(x2, "x", "tan");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tan, inputs);
}
var tan = op({ tan_ });
function tensor1d(values, dtype) {
  assertNonNull(values);
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 1) {
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  }
  const shape = null;
  return makeTensor(values, shape, inferredShape, dtype);
}
function tensor2d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 2) {
    throw new Error("tensor2d() requires shape to have two numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 2 && inferredShape.length !== 1) {
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
function tensor4d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 4) {
    throw new Error("tensor4d() requires shape to have four numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 4 && inferredShape.length !== 1) {
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
function tensor5d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 5) {
    throw new Error("tensor5d() requires shape to have five numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 5 && inferredShape.length !== 1) {
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
function tensor6d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 6) {
    throw new Error("tensor6d() requires shape to have six numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 6 && inferredShape.length !== 1) {
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  }
  shape = shape || inferredShape;
  return makeTensor(values, shape, inferredShape, dtype);
}
function topk_(x2, k3 = 1, sorted = true) {
  const $x = convertToTensor(x2, "x", "topk");
  if ($x.rank === 0) {
    throw new Error("topk() expects the input to be of rank 1 or higher");
  }
  const lastDim = $x.shape[$x.shape.length - 1];
  if (k3 < 0) {
    throw new Error(`'k' passed to topk() must be >= 0 but got ${k3}`);
  }
  if (k3 > lastDim) {
    throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k3}`);
  }
  const inputs = { x: $x };
  const attrs = { k: k3, sorted };
  const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
  return { values, indices };
}
var topk = op({ topk_ });
function truncatedNormal_(shape, mean5 = 0, stdDev = 1, dtype, seed) {
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type $ { dtype }`);
  }
  const randGauss = new MPRandGauss(mean5, stdDev, dtype, true, seed);
  const res2 = buffer(shape, dtype);
  for (let i2 = 0; i2 < res2.values.length; i2++) {
    res2.values[i2] = randGauss.nextValue();
  }
  return res2.toTensor();
}
var truncatedNormal = op({ truncatedNormal_ });
function unique_(x2, axis = 0) {
  const $x = convertToTensor(x2, "x", "unique", "string_or_numeric");
  assert($x.rank > 0, () => "The input tensor must be at least 1D");
  const inputs = { x: $x };
  const attrs = { axis };
  const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
  return { values, indices };
}
var unique = op({ unique_ });
function unsortedSegmentSum_(x2, segmentIds, numSegments) {
  const $x = convertToTensor(x2, "x", "unsortedSegmentSum");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
  assert(isInt(numSegments), () => "numSegments must be of dtype int");
  const inputs = { x: $x, segmentIds: $segmentIds };
  const attrs = { numSegments };
  return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
}
var unsortedSegmentSum = op({ unsortedSegmentSum_ });
function unstack_(x2, axis = 0) {
  const $x = convertToTensor(x2, "x", "unstack", "string_or_numeric");
  assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
  const inputs = { value: $x };
  const attrs = { axis };
  return ENGINE.runKernel(Unpack, inputs, attrs);
}
var unstack = op({ unstack_ });
function variable(initialValue, trainable = true, name, dtype) {
  return ENGINE.makeVariable(initialValue, trainable, name, dtype);
}
function whereImpl(condShape, condVals) {
  const indices = [];
  for (let i2 = 0; i2 < condVals.length; i2++) {
    if (condVals[i2]) {
      indices.push(i2);
    }
  }
  const inBuffer = buffer(condShape, "int32");
  const out = buffer([indices.length, condShape.length], "int32");
  for (let i2 = 0; i2 < indices.length; i2++) {
    const loc = inBuffer.indexToLoc(indices[i2]);
    const offset = i2 * condShape.length;
    out.values.set(loc, offset);
  }
  return out.toTensor();
}
async function whereAsync_(condition) {
  const $condition = convertToTensor(condition, "condition", "whereAsync", "bool");
  const vals = await $condition.data();
  const res2 = whereImpl($condition.shape, vals);
  if (condition !== $condition) {
    $condition.dispose();
  }
  return res2;
}
var whereAsync = whereAsync_;
async function booleanMaskAsync_(tensor2, mask, axis) {
  const $tensor = convertToTensor(tensor2, "tensor", "boolMask");
  const $mask = convertToTensor(mask, "mask", "boolMask", "bool");
  const axisFrom = axis == null ? 0 : axis;
  const maskDim = $mask.rank;
  const tensorShape = $tensor.shape;
  assert(maskDim > 0, () => "mask cannot be scalar");
  assertShapesMatch(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
  let leadingSize = 1;
  for (let i2 = axisFrom; i2 < axisFrom + maskDim; i2++) {
    leadingSize *= tensorShape[i2];
  }
  const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
  const reshapedTensor = reshape($tensor, targetTensorShape);
  const reshapedMask = reshape($mask, [-1]);
  const positivePositions = await whereAsync(reshapedMask);
  const indices = squeeze(positivePositions, [1]);
  const res2 = gather(reshapedTensor, indices, axisFrom);
  if (tensor2 !== $tensor) {
    $tensor.dispose();
  }
  if (mask !== $mask) {
    $mask.dispose();
  }
  indices.dispose();
  reshapedTensor.dispose();
  reshapedMask.dispose();
  positivePositions.dispose();
  return res2;
}
var booleanMaskAsync = booleanMaskAsync_;
function norm_(x2, ord = "euclidean", axis = null, keepDims = false) {
  x2 = convertToTensor(x2, "x", "norm");
  const norm2 = normImpl(x2, ord, axis);
  let keepDimsShape = norm2.shape;
  if (keepDims) {
    const axes = parseAxisParam(axis, x2.shape);
    keepDimsShape = expandShapeToKeepDim(norm2.shape, axes);
  }
  return reshape(norm2, keepDimsShape);
}
function normImpl(x2, p22, axis = null) {
  if (x2.rank === 0) {
    return abs(x2);
  }
  if (x2.rank !== 1 && axis === null) {
    return normImpl(reshape(x2, [-1]), p22, axis);
  }
  if (x2.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
    if (p22 === 1) {
      return sum2(abs(x2), axis);
    }
    if (p22 === Infinity) {
      return max(abs(x2), axis);
    }
    if (p22 === -Infinity) {
      return min(abs(x2), axis);
    }
    if (p22 === "euclidean" || p22 === 2) {
      return sqrt(sum2(pow(abs(x2), scalar(2, "int32")), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p22}`);
  }
  if (Array.isArray(axis) && axis.length === 2) {
    if (p22 === 1) {
      return max(sum2(abs(x2), axis[0]), axis[1] - 1);
    }
    if (p22 === Infinity) {
      return max(sum2(abs(x2), axis[1]), axis[0]);
    }
    if (p22 === -Infinity) {
      return min(sum2(abs(x2), axis[1]), axis[0]);
    }
    if (p22 === "fro" || p22 === "euclidean") {
      return sqrt(sum2(square(x2), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p22}`);
  }
  throw new Error(`Error in norm: invalid axis: ${axis}`);
}
var norm = op({ norm_ });
function movingAverage_(v2, x2, decay, step5, zeroDebias = true) {
  const $v = convertToTensor(v2, "v", "movingAverage");
  const $x = convertToTensor(x2, "x", "movingAverage");
  const $decay = convertToTensor(decay, "decay", "movingAverage");
  assertTypesMatch($v, $x);
  assert(arraysEqual2($v.shape, $x.shape), () => "Shape mismatch in v and x");
  const one = scalar(1);
  const oneMinusDecay = sub(one, $decay);
  let update2 = mul(sub($x, $v), oneMinusDecay);
  if (zeroDebias) {
    assert(step5 != null, () => "When using zeroDebias: true, step is required.");
    const $step = convertToTensor(step5, "step", "movingAverage");
    update2 = div(update2, sub(one, pow($decay, $step)));
  }
  return add2($v, update2);
}
var movingAverage = op({ movingAverage_ });
function scatterND_(indices, updates, shape) {
  const $indices = convertToTensor(indices, "indices", "scatterND", "int32");
  const $updates = convertToTensor(updates, "updates", "scatterND");
  validateInput($updates, $indices, shape);
  const inputs = { indices: $indices, updates: $updates };
  const attrs = { shape };
  return ENGINE.runKernel(ScatterNd, inputs, attrs);
}
var scatterND = op({ scatterND_ });
function validateInput2(sparseIndices, sparseValues, outputShape, defaultValues) {
  if (sparseIndices.dtype !== "int32") {
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${sparseIndices.dtype}.`);
  }
  if (sparseIndices.rank > 2) {
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${sparseIndices.shape}.`);
  }
  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
  if (outputShape.length !== numDims) {
    throw new Error(`outputShape has incorrect number of elements:, ${outputShape.length}, should be: ${numDims}.`);
  }
  const numValues = sparseValues.size;
  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
    throw new Error(`sparseValues has incorrect shape ${sparseValues.shape}, should be [] or [${numElems}]`);
  }
  if (sparseValues.dtype !== defaultValues.dtype) {
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }
}
function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
  const $sparseIndices = convertToTensor(sparseIndices, "sparseIndices", "sparseToDense", "int32");
  const $sparseValues = convertToTensor(sparseValues, "sparseValues", "sparseToDense");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
  validateInput2($sparseIndices, $sparseValues, outputShape, $defaultValue);
  const inputs = {
    sparseIndices: $sparseIndices,
    sparseValues: $sparseValues,
    defaultValue: $defaultValue
  };
  const attrs = { outputShape };
  return ENGINE.runKernel(SparseToDense, inputs, attrs);
}
var sparseToDense = op({ sparseToDense_ });
function gatherND_(x2, indices) {
  const $indices = convertToTensor(indices, "indices", "gatherND", "int32");
  const $x = convertToTensor(x2, "x", "gatherND", "string_or_numeric");
  const inputs = { params: $x, indices: $indices };
  return ENGINE.runKernel(GatherNd, inputs);
}
var gatherND = op({ gatherND_ });
function getNoiseShape(x2, noiseShape) {
  if (noiseShape == null) {
    return x2.shape.slice();
  }
  if (arraysEqual2(x2.shape, noiseShape)) {
    return noiseShape;
  }
  if (x2.shape.length === noiseShape.length) {
    const newDimension = [];
    for (let i2 = 0; i2 < x2.shape.length; i2++) {
      if (noiseShape[i2] == null && x2.shape[i2] != null) {
        newDimension.push(x2.shape[i2]);
      } else {
        newDimension.push(noiseShape[i2]);
      }
    }
    return newDimension;
  }
  return noiseShape;
}
function dropout_(x2, rate, noiseShape, seed) {
  const $x = convertToTensor(x2, "x", "dropout");
  assert($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
  assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
  if (rate === 0) {
    return x2 instanceof Tensor ? $x.clone() : $x;
  }
  const $noiseShape = getNoiseShape($x, noiseShape);
  const keepProb = 1 - rate;
  const multiplier = div(floor(add2(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
  return mul($x, multiplier);
}
var dropout = op({ dropout_ });
function enclosingPowerOfTwo(value) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
}
function cosineWindow(windowLength, a6, b2) {
  const even = 1 - windowLength % 2;
  const newValues = new Float32Array(windowLength);
  for (let i2 = 0; i2 < windowLength; ++i2) {
    const cosArg = 2 * Math.PI * i2 / (windowLength + even - 1);
    newValues[i2] = a6 - b2 * Math.cos(cosArg);
  }
  return tensor1d(newValues, "float32");
}
async function inTopKAsync_(predictions, targets, k3 = 1) {
  const $predictions = convertToTensor(predictions, "predictions", "inTopK");
  const $targets = convertToTensor(targets, "targets", "inTopK");
  assert($predictions.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${$predictions.rank}`);
  assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${$predictions.rank} and targets rank ${$targets.rank}`);
  assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, except the last dimension.`);
  const lastDim = $predictions.shape[$predictions.shape.length - 1];
  assert(k3 > 0 && k3 <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${lastDim}), but got ${k3}`);
  const predictionsVals = await $predictions.data();
  const targetsVals = await $targets.data();
  const [batch, size2] = [predictionsVals.length / lastDim, lastDim];
  const precision3 = getTypedArrayFromDType("bool", batch);
  for (let b2 = 0; b2 < batch; b2++) {
    const offset = b2 * size2;
    const vals = predictionsVals.subarray(offset, offset + size2);
    const valAndInd = [];
    for (let i2 = 0; i2 < vals.length; i2++) {
      valAndInd.push({ value: vals[i2], index: i2 });
    }
    valAndInd.sort((a6, b22) => b22.value - a6.value);
    precision3[b2] = 0;
    for (let i2 = 0; i2 < k3; i2++) {
      if (valAndInd[i2].index === targetsVals[b2]) {
        precision3[b2] = 1;
        break;
      }
    }
  }
  if (predictions !== $predictions) {
    $predictions.dispose();
  }
  if (targets !== $targets) {
    $targets.dispose();
  }
  return tensor(precision3, $targets.shape, "bool");
}
var inTopKAsync = inTopKAsync_;
var fused_ops_exports = {};
__export2(fused_ops_exports, {
  conv2d: () => conv2d2,
  depthwiseConv2d: () => depthwiseConv2d2,
  matMul: () => matMul2
});
function conv2DBackpropFilter_(x2, dy, filterShape, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
  let x4D = x2;
  if (x2.rank === 3) {
    x4D = reshape(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
  }
  let dy4D = dy;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
  assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
  assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape };
  return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
}
var conv2DBackpropFilter = op({ conv2DBackpropFilter_ });
function getFusedDyActivation(dy, y2, activation2) {
  if (activation2 == null || activation2 === "linear") {
    return dy;
  }
  if (activation2 === "relu") {
    return mul(dy, step(y2));
  }
  throw new Error(`Cannot compute gradient for fused activation ${activation2}.`);
}
function getFusedBiasGradient(bias, dyActivation) {
  let res2 = dyActivation;
  const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
  if (reduceAxes.length > 0) {
    res2 = sum2(res2, reduceAxes);
  }
  return reshape(res2, bias.shape);
}
function applyActivation(x2, activation2, preluActivationWeights, leakyreluAlpha) {
  if (activation2 === "linear") {
    return x2;
  } else if (activation2 === "relu") {
    return relu(x2);
  } else if (activation2 === "elu") {
    return elu(x2);
  } else if (activation2 === "relu6") {
    return relu6(x2);
  } else if (activation2 === "prelu") {
    return prelu(x2, preluActivationWeights);
  } else if (activation2 === "leakyrelu") {
    return leakyRelu(x2, leakyreluAlpha);
  } else if (activation2 === "sigmoid") {
    return sigmoid(x2);
  }
  throw new Error(`Unknown fused activation ${activation2}.`);
}
var shouldFuse = (gradientDepth, activation2) => {
  const gradientMode = gradientDepth > 0;
  return !gradientMode || activation2 === "linear";
};
function fusedConv2d_({ x: x2, filter, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha }) {
  activation2 = activation2 || "linear";
  if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
    let result = conv2d(x2, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x2, "x", "conv2d");
  const $filter = convertToTensor(filter, "filter", "conv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in conv2d: depth of input (${x4D.shape[3]}) must match input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  assert(dataFormat === "NHWC", () => `Error in conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
  const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
  }
  const grad2 = (dy, saved) => {
    const [$filter2, x4D2, y2, $bias2] = saved;
    const dyActivation = getFusedDyActivation(dy, y2, activation2);
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
    const xDer = conv2DBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad3);
    const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3);
    const der = [xDer, filterDer];
    if ($bias2 != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      der.push(biasDer);
    }
    return der;
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad3,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation: activation2,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter2, save) => {
      let res2 = ENGINE.runKernel(FusedConv2D, inputs, attrs);
      save([filter2, x4D2, res2]);
      if (reshapedTo4D) {
        res2 = reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
      }
      return { value: res2, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
      let res2 = ENGINE.runKernel(FusedConv2D, inputs, attrs);
      save([filter2, x4D2, res2, bias2]);
      if (reshapedTo4D) {
        res2 = reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
      }
      return { value: res2, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
var conv2d2 = op({ fusedConv2d_ });
function depthwiseConv2dNativeBackpropFilter_(x2, dy, filterShape, strides, pad3, dilations = [1, 1], dimRoundingMode) {
  let x4D = x2;
  if (x2.rank === 3) {
    x4D = reshape(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
  }
  let dy4D = dy;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad3, dimRoundingMode, dilations, filterShape };
  return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
}
var depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });
function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad3, dilations = [1, 1], dimRoundingMode) {
  let dy4D = dy;
  let reshapedTo4D = false;
  if (dy.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  const inputs = { dy: dy4D, filter };
  const attrs = { strides, pad: pad3, dimRoundingMode, dilations, inputShape: xShape };
  const res2 = ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });
function fusedDepthwiseConv2d_({ x: x2, filter, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
    let result = depthwiseConv2d(x2, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x2, "x", "depthwiseConv2d");
  const $filter = convertToTensor(filter, "filter", "depthwiseConv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
  if (dilations == null) {
    dilations = [1, 1];
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode, true);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
  }
  const grad2 = (dy, saved) => {
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
    const [$filter2, x4D2, y2, bias2] = saved;
    const dyActivation = getFusedDyActivation(dy, y2, activation2);
    const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad3, dilations, dimRoundingMode);
    const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3, dilations, dimRoundingMode);
    if (bias2 != null) {
      const biasDer = getFusedBiasGradient($bias, dyActivation);
      return [xDer, filterDer, biasDer];
    }
    return [xDer, filterDer];
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad3,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation: activation2,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter2, save) => {
      let res2 = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter2, x4D2, res2]);
      if (reshapedTo4D) {
        res2 = reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
      }
      return { value: res2, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
      let res2 = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter2, x4D2, res2, bias2]);
      if (reshapedTo4D) {
        res2 = reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
      }
      return { value: res2, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
var depthwiseConv2d2 = op({ fusedDepthwiseConv2d_ });
function fusedMatMul_({ a: a6, b: b2, transposeA = false, transposeB = false, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
    let result = matMul(a6, b2, transposeA, transposeB);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
  }
  let $a = convertToTensor(a6, "a", "fused matMul");
  let $b = convertToTensor(b2, "b", "fused matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
  const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
  const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
  const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
  const outerDimsA = $a.shape.slice(0, -2);
  const outerDimsB = $b.shape.slice(0, -2);
  const batchDimA = sizeFromShape(outerDimsA);
  const batchDimB = sizeFromShape(outerDimsB);
  assert($a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank, () => `Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${$a.rank} and ${$b.rank}.`);
  assert(arraysEqual2(outerDimsA, outerDimsB), () => `Error in fused matMul: outer dimensions (${outerDimsA}) and (${outerDimsB}) of Tensors with shapes ${$a.shape} and ${$b.shape} must match.`);
  assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);
  const a3D = transposeA ? reshape($a, [batchDimA, innerShapeA, outerShapeA]) : reshape($a, [batchDimA, outerShapeA, innerShapeA]);
  const b3D = transposeB ? reshape($b, [batchDimB, outerShapeB, innerShapeB]) : reshape($b, [batchDimB, innerShapeB, outerShapeB]);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused matMul");
    [$bias] = makeTypesMatch($bias, $a);
    assertAndGetBroadcastShape(outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
  }
  const grad2 = (dy, saved) => {
    const [a3D2, b3D2, y2, $bias2] = saved;
    const dyActivation = getFusedDyActivation(reshape(dy, y2.shape), y2, activation2);
    let aDer;
    let bDer;
    if (!transposeA && !transposeB) {
      aDer = matMul(dyActivation, b3D2, false, true);
      bDer = matMul(a3D2, dyActivation, true, false);
    } else if (!transposeA && transposeB) {
      aDer = matMul(dyActivation, b3D2, false, false);
      bDer = matMul(dyActivation, a3D2, true, false);
    } else if (transposeA && !transposeB) {
      aDer = matMul(b3D2, dyActivation, false, true);
      bDer = matMul(a3D2, dyActivation, false, false);
    } else {
      aDer = matMul(b3D2, dyActivation, true, true);
      bDer = matMul(dyActivation, a3D2, true, true);
    }
    if (bias != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      return [aDer, bDer, biasDer];
    } else {
      return [aDer, bDer];
    }
  };
  const inputs = {
    a: a3D,
    b: b3D,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = { transposeA, transposeB, activation: activation2, leakyreluAlpha };
  if (bias == null) {
    const customOp = customGrad((a3D2, b3D2, save) => {
      const res2 = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
      save([a3D2, b3D2, res2]);
      return { value: reshape(res2, outShape), gradFunc: grad2 };
    });
    return customOp(a3D, b3D);
  } else {
    const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
      const res2 = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
      save([a3D2, b3D2, res2, $bias2]);
      return { value: reshape(res2, outShape), gradFunc: grad2 };
    });
    return customOpWithBias(a3D, b3D, $bias);
  }
}
var matMul2 = op({ fusedMatMul_ });
function hammingWindow_(windowLength) {
  return cosineWindow(windowLength, 0.54, 0.46);
}
var hammingWindow = op({ hammingWindow_ });
function hannWindow_(windowLength) {
  return cosineWindow(windowLength, 0.5, 0.5);
}
var hannWindow = op({ hannWindow_ });
function frame_(signal2, frameLength, frameStep, padEnd = false, padValue = 0) {
  let start = 0;
  const output = [];
  while (start + frameLength <= signal2.size) {
    output.push(slice(signal2, start, frameLength));
    start += frameStep;
  }
  if (padEnd) {
    while (start < signal2.size) {
      const padLen = start + frameLength - signal2.size;
      const pad3 = concat([
        slice(signal2, start, frameLength - padLen),
        fill([padLen], padValue)
      ]);
      output.push(pad3);
      start += frameStep;
    }
  }
  if (output.length === 0) {
    return tensor2d([], [0, frameLength]);
  }
  return reshape(concat(output), [output.length, frameLength]);
}
var frame = op({ frame_ });
function stft_(signal2, frameLength, frameStep, fftLength, windowFn = hannWindow) {
  if (fftLength == null) {
    fftLength = enclosingPowerOfTwo(frameLength);
  }
  const framedSignal = frame(signal2, frameLength, frameStep);
  const windowedSignal = mul(framedSignal, windowFn(frameLength));
  return rfft(windowedSignal, fftLength);
}
var stft = op({ stft_ });
function cropAndResize_(image32, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
  const $image = convertToTensor(image32, "image", "cropAndResize");
  const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
  const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
  const numBoxes = $boxes.shape[0];
  assert($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
  assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
  assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
  assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
  assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
  assert(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
  const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
  const attrs = { method, extrapolationValue, cropSize };
  const res2 = ENGINE.runKernel(CropAndResize, inputs, attrs);
  return res2;
}
var cropAndResize = op({ cropAndResize_ });
function flipLeftRight_(image32) {
  const $image = convertToTensor(image32, "image", "flipLeftRight", "float32");
  assert($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const res2 = ENGINE.runKernel(FlipLeftRight, inputs, {});
  return res2;
}
var flipLeftRight = op({ flipLeftRight_ });
function grayscaleToRGB_(image32) {
  const $image = convertToTensor(image32, "image", "grayscaleToRGB");
  const lastDimsIdx = $image.rank - 1;
  const lastDims = $image.shape[lastDimsIdx];
  assert($image.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$image.rank}.`);
  assert(lastDims === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lastDims}.`);
  const reps = new Array($image.rank);
  reps.fill(1, 0, lastDimsIdx);
  reps[lastDimsIdx] = 3;
  return tile($image, reps);
}
var grayscaleToRGB = op({ grayscaleToRGB_ });
function rotateWithOffset_(image32, radians, fillValue = 0, center = 0.5) {
  const $image = convertToTensor(image32, "image", "rotateWithOffset", "float32");
  assert($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const attrs = { radians, fillValue, center };
  const res2 = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
  return res2;
}
var rotateWithOffset = op({ rotateWithOffset_ });
function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  if (iouThreshold == null) {
    iouThreshold = 0.5;
  }
  if (scoreThreshold == null) {
    scoreThreshold = Number.NEGATIVE_INFINITY;
  }
  if (softNmsSigma == null) {
    softNmsSigma = 0;
  }
  const numBoxes = boxes.shape[0];
  maxOutputSize = Math.min(maxOutputSize, numBoxes);
  assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
  assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
  assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
  assert(scores.rank === 1, () => "scores must be a 1D tensor");
  assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
  assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
  return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
}
function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
  return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
}
var nonMaxSuppression = op({ nonMaxSuppression_ });
function binaryInsert(arr, element, comparator) {
  const index = binarySearch(arr, element, comparator);
  const insertionPoint = index < 0 ? -(index + 1) : index;
  arr.splice(insertionPoint, 0, element);
}
function binarySearch(arr, target, comparator) {
  return binarySearch_(arr, target, comparator || defaultComparator);
}
function defaultComparator(a6, b2) {
  return a6 > b2 ? 1 : a6 < b2 ? -1 : 0;
}
function binarySearch_(arr, target, comparator) {
  let left = 0;
  let right = arr.length;
  let middle = 0;
  let found = false;
  while (left < right) {
    middle = left + (right - left >>> 1);
    const compareResult = comparator(target, arr[middle]);
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      found = !compareResult;
    }
  }
  return found ? left : -left - 1;
}
function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);
}
function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
}
function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
}
function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
  const candidates = [];
  for (let i2 = 0; i2 < scores.length; i2++) {
    if (scores[i2] > scoreThreshold) {
      candidates.push({ score: scores[i2], boxIndex: i2, suppressBeginIndex: 0 });
    }
  }
  candidates.sort(ascendingComparator);
  const scale22 = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
  const selectedIndices = [];
  const selectedScores = [];
  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
    const candidate = candidates.pop();
    const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
    if (originalScore < scoreThreshold) {
      break;
    }
    let ignoreCandidate = false;
    for (let j2 = selectedIndices.length - 1; j2 >= suppressBeginIndex; --j2) {
      const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j2]);
      if (iou >= iouThreshold) {
        ignoreCandidate = true;
        break;
      }
      candidate.score = candidate.score * suppressWeight(iouThreshold, scale22, iou);
      if (candidate.score <= scoreThreshold) {
        break;
      }
    }
    candidate.suppressBeginIndex = selectedIndices.length;
    if (!ignoreCandidate) {
      if (candidate.score === originalScore) {
        selectedIndices.push(boxIndex);
        selectedScores.push(candidate.score);
      } else if (candidate.score > scoreThreshold) {
        binaryInsert(candidates, candidate, ascendingComparator);
      }
    }
  }
  const validOutputs = selectedIndices.length;
  const elemsToPad = maxOutputSize - validOutputs;
  if (padToMaxOutputSize && elemsToPad > 0) {
    selectedIndices.push(...new Array(elemsToPad).fill(0));
    selectedScores.push(...new Array(elemsToPad).fill(0));
  }
  const result = { selectedIndices };
  if (returnScoresTensor) {
    result["selectedScores"] = selectedScores;
  }
  if (returnValidOutputs) {
    result["validOutputs"] = validOutputs;
  }
  return result;
}
function intersectionOverUnion(boxes, i2, j2) {
  const iCoord = boxes.subarray(i2 * 4, i2 * 4 + 4);
  const jCoord = boxes.subarray(j2 * 4, j2 * 4 + 4);
  const yminI = Math.min(iCoord[0], iCoord[2]);
  const xminI = Math.min(iCoord[1], iCoord[3]);
  const ymaxI = Math.max(iCoord[0], iCoord[2]);
  const xmaxI = Math.max(iCoord[1], iCoord[3]);
  const yminJ = Math.min(jCoord[0], jCoord[2]);
  const xminJ = Math.min(jCoord[1], jCoord[3]);
  const ymaxJ = Math.max(jCoord[0], jCoord[2]);
  const xmaxJ = Math.max(jCoord[1], jCoord[3]);
  const areaI = (ymaxI - yminI) * (xmaxI - xminI);
  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
  if (areaI <= 0 || areaJ <= 0) {
    return 0;
  }
  const intersectionYmin = Math.max(yminI, yminJ);
  const intersectionXmin = Math.max(xminI, xminJ);
  const intersectionYmax = Math.min(ymaxI, ymaxJ);
  const intersectionXmax = Math.min(xmaxI, xmaxJ);
  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
  return intersectionArea / (areaI + areaJ - intersectionArea);
}
function suppressWeight(iouThreshold, scale22, iou) {
  const weight = Math.exp(scale22 * iou * iou);
  return iou <= iouThreshold ? weight : 0;
}
function ascendingComparator(c1, c2) {
  return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
}
async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return tensor1d(selectedIndices, "int32");
}
var nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
  return { selectedIndices: result[0], selectedScores: result[1] };
}
var nonMaxSuppressionWithScore = op({ nonMaxSuppressionWithScore_ });
async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    selectedScores: tensor1d(selectedScores)
  };
}
var nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = {
    maxOutputSize: $maxOutputSize,
    iouThreshold: $iouThreshold,
    scoreThreshold: $scoreThreshold,
    padToMaxOutputSize
  };
  const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
  return { selectedIndices: result[0], validOutputs: result[1] };
}
var nonMaxSuppressionPadded = op({ nonMaxSuppressionPadded_ });
async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    validOutputs: scalar(validOutputs, "int32")
  };
}
var nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
function resizeBilinear_(images, size2, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeBilinear");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
  assert(size2.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size2}.`);
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const [] = size2;
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size: size2 };
  const res2 = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var resizeBilinear = op({ resizeBilinear_ });
function resizeNearestNeighbor_(images, size2, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
  assert(size2.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size2}.`);
  assert($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const [] = size2;
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size: size2 };
  const res2 = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var resizeNearestNeighbor = op({ resizeNearestNeighbor_ });
function threshold_(image32, method = "binary", inverted = false, threshValue = 0.5) {
  const $image = convertToTensor(image32, "image", "threshold");
  const RED_INTENCITY_COEF = 0.2989;
  const GREEN_INTENCITY_COEF = 0.587;
  const BLUE_INTENCITY_COEF = 0.114;
  const totalPixelsInImage = $image.shape[0] * $image.shape[1];
  let $threshold = mul(tensor1d([threshValue]), 255);
  let r2, g2, b2, grayscale;
  assert($image.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${$image.rank}.`);
  assert($image.shape[2] === 3 || $image.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${$image.shape[2]}.`);
  assert($image.dtype === "int32" || $image.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${$image.dtype}.`);
  assert(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
  if ($image.shape[2] === 3) {
    [r2, g2, b2] = split($image, [1, 1, 1], -1);
    const $r = mul(r2, RED_INTENCITY_COEF);
    const $g = mul(g2, GREEN_INTENCITY_COEF);
    const $b = mul(b2, BLUE_INTENCITY_COEF);
    grayscale = add2(add2($r, $g), $b);
  } else {
    grayscale = image32;
  }
  if (method === "otsu") {
    const $histogram = bincount(cast(round2(grayscale), "int32"), tensor([]), 256);
    $threshold = otsu($histogram, totalPixelsInImage);
  }
  const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
  const result = cast(mul(invCondition, 255), "int32");
  return result;
}
function otsu(histogram, total) {
  let bestThresh = tensor1d([-1]);
  let bestInBetVar = tensor1d([0]);
  let cInBetVar = tensor1d([0]);
  let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
  for (let index = 0; index < histogram.size - 1; index++) {
    classFirst = slice(histogram, 0, index + 1);
    classSecond = slice(histogram, index + 1);
    weightForeground = div(sum2(classFirst), total);
    weightBack = div(sum2(classSecond), total);
    const meanFirstDivA = sum2(mul(classFirst, range(0, classFirst.size)));
    meanFirst = div(meanFirstDivA, sum2(classFirst));
    const meanSecFill = fill(classSecond.shape, classFirst.size);
    const meanSecAdd = add2(range(0, classSecond.size), meanSecFill);
    const meanSecMul = mul(classSecond, meanSecAdd);
    meanSec = div(sum2(meanSecMul), sum2(classSecond));
    const cInBetVarSubA = sub(meanFirst, meanSec);
    const cInBetVarSubB = sub(meanFirst, meanSec);
    const cInBetVarMul = mul(weightForeground, weightBack);
    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
    const condition = greater(cInBetVar, bestInBetVar);
    bestInBetVar = where(condition, cInBetVar, bestInBetVar);
    bestThresh = where(condition, tensor1d([index]), bestThresh);
  }
  return bestThresh;
}
var threshold = op({ threshold_ });
function transform_(image32, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
  const $image = convertToTensor(image32, "image", "transform", "float32");
  const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
  assert($image.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${$image.rank}.`);
  assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
  assert(outputShape == null || outputShape.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${outputShape}.`);
  const inputs = { image: $image, transforms: $transforms };
  const attrs = { interpolation, fillMode, fillValue, outputShape };
  return ENGINE.runKernel(Transform, inputs, attrs);
}
var transform = op({ transform_ });
function bandPart_(a6, numLower, numUpper) {
  assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
  assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
  const $a = convertToTensor(a6, "a", "bandPart");
  assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
  const shape = $a.shape;
  const [M2, N2] = $a.shape.slice(-2);
  if (!(numLower <= M2)) {
    throw new Error(`bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M2}).`);
  }
  if (!(numUpper <= N2)) {
    throw new Error(`bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N2}).`);
  }
  if (numLower < 0) {
    numLower = M2;
  }
  if (numUpper < 0) {
    numUpper = N2;
  }
  const i2 = reshape(range(0, M2, 1, "int32"), [-1, 1]);
  const j2 = range(0, N2, 1, "int32");
  const ij = sub(i2, j2);
  const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, "int32")), greaterEqual(ij, scalar(-numUpper, "int32")));
  const zero = zeros([M2, N2], $a.dtype);
  return reshape(stack(unstack(reshape($a, [-1, M2, N2])).map((mat) => where(inBand, mat, zero))), shape);
}
var bandPart = op({ bandPart_ });
function gramSchmidt_(xs) {
  let inputIsTensor2D;
  if (Array.isArray(xs)) {
    inputIsTensor2D = false;
    assert(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    const dim = xs[0].shape[0];
    for (let i2 = 1; i2 < xs.length; ++i2) {
      assert(xs[i2].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i2].shape[0]} vs. ${dim})`);
    }
  } else {
    inputIsTensor2D = true;
    xs = split(xs, xs.shape[0], 0).map((x2) => squeeze(x2, [0]));
  }
  assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);
  const ys = [];
  const xs1d = xs;
  for (let i2 = 0; i2 < xs.length; ++i2) {
    ys.push(ENGINE.tidy(() => {
      let x2 = xs1d[i2];
      if (i2 > 0) {
        for (let j2 = 0; j2 < i2; ++j2) {
          const proj = mul(sum2(mul(ys[j2], x2)), ys[j2]);
          x2 = sub(x2, proj);
        }
      }
      return div(x2, norm(x2, "euclidean"));
    }));
  }
  if (inputIsTensor2D) {
    return stack(ys, 0);
  } else {
    return ys;
  }
}
var gramSchmidt = op({ gramSchmidt_ });
function qr_(x2, fullMatrices = false) {
  assert(x2.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x2.rank}`);
  if (x2.rank === 2) {
    return qr2d(x2, fullMatrices);
  } else {
    const outerDimsProd = x2.shape.slice(0, x2.shape.length - 2).reduce((value, prev) => value * prev);
    const x2ds = unstack(reshape(x2, [
      outerDimsProd,
      x2.shape[x2.shape.length - 2],
      x2.shape[x2.shape.length - 1]
    ]), 0);
    const q2ds = [];
    const r2ds = [];
    x2ds.forEach((x2d) => {
      const [q2d, r2d] = qr2d(x2d, fullMatrices);
      q2ds.push(q2d);
      r2ds.push(r2d);
    });
    const q2 = reshape(stack(q2ds, 0), x2.shape);
    const r2 = reshape(stack(r2ds, 0), x2.shape);
    return [q2, r2];
  }
}
function qr2d(x2, fullMatrices = false) {
  return ENGINE.tidy(() => {
    assert(x2.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x2.shape.length}D Tensor.`);
    const m2 = x2.shape[0];
    const n2 = x2.shape[1];
    let q2 = eye(m2);
    let r2 = clone(x2);
    const one2D = tensor2d([[1]], [1, 1]);
    let w2 = clone(one2D);
    const iters = m2 >= n2 ? n2 : m2;
    for (let j2 = 0; j2 < iters; ++j2) {
      const rTemp = r2;
      const wTemp = w2;
      const qTemp = q2;
      [w2, r2, q2] = ENGINE.tidy(() => {
        const rjEnd1 = slice(r2, [j2, j2], [m2 - j2, 1]);
        const normX = norm(rjEnd1);
        const rjj = slice(r2, [j2, j2], [1, 1]);
        const s2 = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
        const u1 = sub(rjj, mul(s2, normX));
        const wPre = div(rjEnd1, u1);
        if (wPre.shape[0] === 1) {
          w2 = clone(one2D);
        } else {
          w2 = concat([
            one2D,
            slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
          ], 0);
        }
        const tau = neg(div(matMul(s2, u1), normX));
        const rjEndAll = slice(r2, [j2, 0], [m2 - j2, n2]);
        const tauTimesW = mul(tau, w2);
        const wT = transpose(w2);
        if (j2 === 0) {
          r2 = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
        } else {
          const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
          r2 = concat([slice(r2, [0, 0], [j2, n2]), rTimesTau], 0);
        }
        const tawTimesWT = transpose(tauTimesW);
        const qAllJEnd = slice(q2, [0, j2], [m2, q2.shape[1] - j2]);
        if (j2 === 0) {
          q2 = sub(qAllJEnd, matMul(matMul(qAllJEnd, w2), tawTimesWT));
        } else {
          const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w2), tawTimesWT));
          q2 = concat([slice(q2, [0, 0], [m2, j2]), qTimesTau], 1);
        }
        return [w2, r2, q2];
      });
      dispose([rTemp, wTemp, qTemp]);
    }
    if (!fullMatrices && m2 > n2) {
      q2 = slice(q2, [0, 0], [m2, n2]);
      r2 = slice(r2, [0, 0], [n2, n2]);
    }
    return [q2, r2];
  });
}
var qr = op({ qr_ });
var Reduction;
(function(Reduction2) {
  Reduction2[Reduction2["NONE"] = 0] = "NONE";
  Reduction2[Reduction2["MEAN"] = 1] = "MEAN";
  Reduction2[Reduction2["SUM"] = 2] = "SUM";
  Reduction2[Reduction2["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction || (Reduction = {}));
function computeWeightedLoss_(losses4, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $losses = convertToTensor(losses4, "losses", "computeWeightedLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "computeWeightedLoss");
  }
  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);
  if (reduction2 === Reduction.NONE) {
    return weightedLoss;
  }
  if (reduction2 === Reduction.SUM) {
    return sum2(weightedLoss);
  }
  if (reduction2 === Reduction.MEAN) {
    if ($weights == null) {
      return mean(weightedLoss);
    } else {
      const broadcastFactor = $losses.size / $weights.size;
      const result = div(sum2(weightedLoss), sum2($weights));
      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;
    }
  }
  if (reduction2 === Reduction.SUM_BY_NONZERO_WEIGHTS) {
    if ($weights == null) {
      return div(sum2(weightedLoss), scalar($losses.size));
    } else {
      const broadcastedWeights = mul($weights, ones2($losses.shape));
      const numNonZeros = cast(sum2(notEqual(broadcastedWeights, scalar(0))), "float32");
      return div(sum2(weightedLoss), numNonZeros);
    }
  }
  throw Error(`Unknown reduction: ${reduction2}`);
}
var computeWeightedLoss = op({ computeWeightedLoss_ });
function absoluteDifference_(labels2, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels2, "labels", "absoluteDifference");
  const $predictions = convertToTensor(predictions, "predictions", "absoluteDifference");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "absoluteDifference");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
  const losses4 = abs(sub($labels, $predictions));
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var absoluteDifference = op({ absoluteDifference_ });
function cosineDistance_(labels2, predictions, axis, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels2, "labels", "cosineDistance");
  const $predictions = convertToTensor(predictions, "predictions", "cosineDistance");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "cosineDistance");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in cosineDistance: ");
  const one = scalar(1);
  const losses4 = sub(one, sum2(mul($labels, $predictions), axis, true));
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var cosineDistance = op({ cosineDistance_ });
function hingeLoss_(labels2, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $labels = convertToTensor(labels2, "labels", "hingeLoss");
  const $predictions = convertToTensor(predictions, "predictions", "hingeLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "hingeLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in hingeLoss: ");
  const one = scalar(1);
  $labels = sub(mul(scalar(2), $labels), one);
  const losses4 = relu(sub(one, mul($labels, $predictions)));
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var hingeLoss = op({ hingeLoss_ });
function huberLoss_(labels2, predictions, weights, delta = 1, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels2, "labels", "huberLoss");
  const $predictions = convertToTensor(predictions, "predictions", "huberLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "huberLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in huberLoss: ");
  const deltaScalar = scalar(delta);
  const error = abs(sub($predictions, $labels));
  const quadratic = minimum(error, deltaScalar);
  const linear = sub(error, quadratic);
  const losses4 = add2(mul(scalar(0.5), square(quadratic)), mul(deltaScalar, linear));
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var huberLoss = op({ huberLoss_ });
function logLoss_(labels2, predictions, weights, epsilon3 = 1e-7, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels2, "labels", "logLoss");
  const $predictions = convertToTensor(predictions, "predictions", "logLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "logLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in logLoss: ");
  const one = scalar(1);
  const epsilonScalar = scalar(epsilon3);
  const l13 = neg(mul($labels, log5(add2($predictions, epsilonScalar))));
  const l23 = mul(sub(one, $labels), log5(add2(sub(one, $predictions), epsilonScalar)));
  const losses4 = sub(l13, l23);
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var logLoss = op({ logLoss_ });
function meanSquaredError_(labels2, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels2, "labels", "meanSquaredError");
  const $predictions = convertToTensor(predictions, "predictions", "meanSquaredError");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "meanSquaredError");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
  const losses4 = squaredDifference($labels, $predictions);
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var meanSquaredError = op({ meanSquaredError_ });
function sigmoidCrossEntropyWithLogits_(labels2, logits) {
  const $labels = convertToTensor(labels2, "labels", "sigmoidCrossEntropyWithLogits");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropyWithLogits");
  assertShapesMatch($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const maxOutput = relu($logits);
  const outputXTarget = mul($logits, $labels);
  const sigmoidOutput = log1p(exp(neg(abs($logits))));
  return add2(sub(maxOutput, outputXTarget), sigmoidOutput);
}
function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $multiClassLabels = convertToTensor(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "sigmoidCrossEntropy");
  }
  assertShapesMatch($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const half = scalar(0.5);
    $multiClassLabels = add2(mul($multiClassLabels, sub(one, labelSmoothingScalar)), mul(half, labelSmoothingScalar));
  }
  const losses4 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var sigmoidCrossEntropy = op({ sigmoidCrossEntropy_ });
function softmaxCrossEntropyWithLogits_(labels2, logits, dim = -1) {
  if (dim === -1) {
    dim = logits.rank - 1;
  }
  if (dim !== logits.rank - 1) {
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);
  }
  const customOp = customGrad((labels22, logits2, save) => {
    const keepDims = true;
    const lse = logSumExp(logits2, [dim], keepDims);
    const logResult = sub(cast(logits2, "float32"), lse);
    save([labels22, logResult]);
    const costVector = neg(mul(logResult, labels22));
    const value = sum2(costVector, [dim]);
    const gradFunc = (dy, saved) => {
      const [labels3, logResult2] = saved;
      const dyShape = expandShapeToKeepDim(dy.shape, [dim]);
      return [
        mul(reshape(dy, dyShape), sub(cast(labels3, "float32"), exp(logResult2))),
        mul(reshape(dy, dyShape), sub(exp(logResult2), cast(labels3, "float32")))
      ];
    };
    return { value, gradFunc };
  });
  return customOp(labels2, logits);
}
function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $onehotLabels = convertToTensor(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "softmaxCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "softmaxCrossEntropy");
  }
  assertShapesMatch($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const numClasses = scalar($onehotLabels.shape[1]);
    $onehotLabels = add2(mul($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
  }
  const losses4 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
  return computeWeightedLoss(losses4, $weights, reduction2);
}
var softmaxCrossEntropy = op({ softmaxCrossEntropy_ });
function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
  const $indices = convertToTensor(indices, "indices", "sparseFillEmptyRows");
  const $values = convertToTensor(values, "values", "sparseFillEmptyRows");
  const $denseShape = convertToTensor(denseShape, "denseShape", "sparseFillEmptyRows");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
  if ($indices.rank !== 2) {
    throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
  }
  if ($values.rank !== 1) {
    throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
  }
  if ($denseShape.rank !== 1) {
    throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
  }
  if ($defaultValue.rank !== 0) {
    throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
  }
  const inputs = {
    indices: $indices,
    values: $values,
    denseShape: $denseShape,
    defaultValue: $defaultValue
  };
  const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
  return {
    outputIndices: result[0],
    outputValues: result[1],
    emptyRowIndicator: result[2],
    reverseIndexMap: result[3]
  };
}
var sparseFillEmptyRows = op({ sparseFillEmptyRows_ });
function sparseReshape_(inputIndices, inputShape, newShape) {
  const $inputIndices = convertToTensor(inputIndices, "inputIndices", "sparseReshape");
  const $inputShape = convertToTensor(inputShape, "inputShape", "sparseReshape");
  const $newShape = convertToTensor(newShape, "newShape", "sparseReshape");
  if ($inputIndices.rank !== 2) {
    throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
  }
  if ($inputShape.rank !== 1) {
    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
  }
  if ($newShape.rank !== 1) {
    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
  }
  const inputs = {
    inputIndices: $inputIndices,
    inputShape: $inputShape,
    newShape: $newShape
  };
  const result = ENGINE.runKernel(SparseReshape, inputs);
  return { outputIndices: result[0], outputShape: result[1] };
}
var sparseReshape = op({ sparseReshape_ });
function sparseSegmentMean_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentMean");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentMean");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentMean");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentMean, inputs);
}
var sparseSegmentMean = op({ sparseSegmentMean_ });
function sparseSegmentSum_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentSum");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentSum");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentSum");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentSum, inputs);
}
var sparseSegmentSum = op({ sparseSegmentSum_ });
function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
  const $data = convertToTensor(data, "data", "stringNGrams", "string");
  if ($data.dtype !== "string") {
    throw new Error("Data must be of datatype string");
  }
  if ($data.shape.length !== 1) {
    throw new Error(`Data must be a vector, saw: ${$data.shape}`);
  }
  const $dataSplits = convertToTensor(dataSplits, "dataSplits", "stringNGrams");
  if ($dataSplits.dtype !== "int32") {
    throw new Error("Data splits must be of datatype int32");
  }
  const attrs = {
    separator,
    nGramWidths,
    leftPad,
    rightPad: rightPad2,
    padWidth,
    preserveShortSequences
  };
  const inputs = { data: $data, dataSplits: $dataSplits };
  const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
  return { nGrams: result[0], nGramsSplits: result[1] };
}
var stringNGrams = op({ stringNGrams_ });
function stringSplit_(input2, delimiter, skipEmpty = true) {
  const $input = convertToTensor(input2, "input", "stringSplit", "string");
  const $delimiter = convertToTensor(delimiter, "delimiter", "stringSplit", "string");
  if ($input.rank !== 1) {
    throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
  }
  if ($delimiter.rank !== 0) {
    throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
  }
  const attrs = { skipEmpty };
  const inputs = { input: $input, delimiter: $delimiter };
  const result = ENGINE.runKernel(StringSplit, inputs, attrs);
  return { indices: result[0], values: result[1], shape: result[2] };
}
var stringSplit = op({ stringSplit_ });
function stringToHashBucketFast_(input2, numBuckets) {
  const $input = convertToTensor(input2, "input", "stringToHashBucketFast", "string");
  const attrs = { numBuckets };
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const inputs = { input: $input };
  return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
}
var stringToHashBucketFast = op({ stringToHashBucketFast_ });
var spectral = {
  fft,
  ifft,
  rfft,
  irfft
};
var signal = {
  hammingWindow,
  hannWindow,
  frame,
  stft
};
var image = {
  flipLeftRight,
  grayscaleToRGB,
  resizeNearestNeighbor,
  resizeBilinear,
  rotateWithOffset,
  cropAndResize,
  nonMaxSuppression,
  nonMaxSuppressionAsync,
  nonMaxSuppressionWithScore,
  nonMaxSuppressionWithScoreAsync,
  nonMaxSuppressionPadded,
  nonMaxSuppressionPaddedAsync,
  threshold,
  transform
};
var linalg = {
  bandPart,
  gramSchmidt,
  qr
};
var losses = {
  absoluteDifference,
  computeWeightedLoss,
  cosineDistance,
  hingeLoss,
  huberLoss,
  logLoss,
  meanSquaredError,
  sigmoidCrossEntropy,
  softmaxCrossEntropy
};
var sparse = {
  sparseFillEmptyRows,
  sparseReshape,
  sparseSegmentMean,
  sparseSegmentSum
};
var string = {
  stringNGrams,
  stringSplit,
  stringToHashBucketFast
};
var Optimizer = class extends Serializable {
  minimize(f2, returnCost = false, varList) {
    const { value, grads: grads2 } = this.computeGradients(f2, varList);
    if (varList != null) {
      const gradArray = varList.map((v2) => ({ name: v2.name, tensor: grads2[v2.name] }));
      this.applyGradients(gradArray);
    } else {
      this.applyGradients(grads2);
    }
    dispose(grads2);
    if (returnCost) {
      return value;
    } else {
      value.dispose();
      return null;
    }
  }
  get iterations() {
    if (this.iterations_ == null) {
      this.iterations_ = 0;
    }
    return this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  computeGradients(f2, varList) {
    return variableGrads(f2, varList);
  }
  dispose() {
    if (this.iterations_ != null) {
      dispose(this.iterations_);
    }
  }
  async saveIterations() {
    if (this.iterations_ == null) {
      this.iterations_ = 0;
    }
    return {
      name: "iter",
      tensor: scalar(this.iterations_, "int32")
    };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(weightValues) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  async extractIterations(weightValues) {
    this.iterations_ = (await weightValues[0].tensor.data())[0];
    return weightValues.slice(1);
  }
};
Object.defineProperty(Optimizer, Symbol.hasInstance, {
  value: (instance) => {
    return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
  }
});
var AdadeltaOptimizer = class extends Optimizer {
  constructor(learningRate, rho, epsilon3 = null) {
    super();
    this.learningRate = learningRate;
    this.rho = rho;
    this.epsilon = epsilon3;
    this.accumulatedGrads = [];
    this.accumulatedUpdates = [];
    if (epsilon3 == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i2) => {
      const value = ENGINE.registeredVariables[name];
      const trainable = false;
      if (this.accumulatedGrads[i2] == null) {
        this.accumulatedGrads[i2] = {
          originalName: `${name}/accum_grad`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedUpdates[i2] == null) {
        this.accumulatedUpdates[i2] = {
          originalName: `${name}/accum_var`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedGrad = this.accumulatedGrads[i2].variable;
      const accumulatedUpdate = this.accumulatedUpdates[i2].variable;
      tidy(() => {
        const newAccumulatedGrad = add2(mul(accumulatedGrad, this.rho), mul(square(gradient), 1 - this.rho));
        const updates = mul(div(sqrt(add2(accumulatedUpdate, this.epsilon)), sqrt(add2(accumulatedGrad, this.epsilon))), gradient);
        const newAccumulatedUpdate = add2(mul(accumulatedUpdate, this.rho), mul(square(updates), 1 - this.rho));
        accumulatedGrad.assign(newAccumulatedGrad);
        accumulatedUpdate.assign(newAccumulatedUpdate);
        const newValue = add2(mul(updates, -this.learningRate), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedUpdates != null) {
      dispose(this.accumulatedGrads.map((v2) => v2.variable));
      dispose(this.accumulatedUpdates.map((v2) => v2.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const variableCount = weightValues.length / 2;
    const trainable = false;
    this.accumulatedGrads = weightValues.slice(0, variableCount).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
    this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "rho": this.rho,
      "epsilon": this.epsilon
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["rho"], config3["epsilon"]);
  }
};
AdadeltaOptimizer.className = "Adadelta";
registerClass(AdadeltaOptimizer);
var AdagradOptimizer = class extends Optimizer {
  constructor(learningRate, initialAccumulatorValue = 0.1) {
    super();
    this.learningRate = learningRate;
    this.initialAccumulatorValue = initialAccumulatorValue;
    this.accumulatedGrads = [];
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i2) => {
      const value = ENGINE.registeredVariables[name];
      if (this.accumulatedGrads[i2] == null) {
        const trainable = false;
        this.accumulatedGrads[i2] = {
          originalName: `${name}/accumulator`,
          variable: tidy(() => fill(value.shape, this.initialAccumulatorValue).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedGrad = this.accumulatedGrads[i2].variable;
      tidy(() => {
        const newAccumulatedGrad = add2(accumulatedGrad, square(gradient));
        accumulatedGrad.assign(newAccumulatedGrad);
        const newValue = add2(mul(div(gradient, sqrt(add2(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedGrads != null) {
      dispose(this.accumulatedGrads.map((v2) => v2.variable));
    }
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const trainable = false;
    this.accumulatedGrads = weightValues.map((v2) => ({ originalName: v2.name, variable: v2.tensor.variable(trainable) }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "initialAccumulatorValue": this.initialAccumulatorValue
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["initialAccumulatorValue"]);
  }
};
AdagradOptimizer.className = "Adagrad";
registerClass(AdagradOptimizer);
var AdamOptimizer = class extends Optimizer {
  constructor(learningRate, beta1, beta2, epsilon3 = null) {
    super();
    this.learningRate = learningRate;
    this.beta1 = beta1;
    this.beta2 = beta2;
    this.epsilon = epsilon3;
    this.accumulatedFirstMoment = [];
    this.accumulatedSecondMoment = [];
    tidy(() => {
      this.accBeta1 = scalar(beta1).variable();
      this.accBeta2 = scalar(beta2).variable();
    });
    if (epsilon3 == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const varNames = Array.isArray(variableGradients) ? variableGradients.map((v2) => v2.name) : Object.keys(variableGradients);
    tidy(() => {
      const oneMinusAccBeta1 = sub(1, this.accBeta1);
      const oneMinusAccBeta2 = sub(1, this.accBeta2);
      varNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedFirstMoment[i2] == null) {
          this.accumulatedFirstMoment[i2] = {
            originalName: `${name}/m`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedSecondMoment[i2] == null) {
          this.accumulatedSecondMoment[i2] = {
            originalName: `${name}/v`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const firstMoment = this.accumulatedFirstMoment[i2].variable;
        const secondMoment = this.accumulatedSecondMoment[i2].variable;
        const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
        const newSecondMoment = add2(mul(secondMoment, this.beta2), mul(square(gradient), 1 - this.beta2));
        const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
        const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
        firstMoment.assign(newFirstMoment);
        secondMoment.assign(newSecondMoment);
        const newValue = add2(mul(div(biasCorrectedFirstMoment, add2(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
        value.assign(newValue);
      });
      this.accBeta1.assign(mul(this.accBeta1, this.beta1));
      this.accBeta2.assign(mul(this.accBeta2, this.beta2));
    });
    this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose();
    this.accBeta2.dispose();
    if (this.accumulatedFirstMoment != null) {
      dispose(this.accumulatedFirstMoment.map((v2) => v2.variable));
    }
    if (this.accumulatedSecondMoment != null) {
      dispose(this.accumulatedSecondMoment.map((v2) => v2.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    tidy(() => {
      this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
      this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
    });
    const variableCount = weightValues.length / 2;
    const trainable = false;
    this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
    this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "beta1": this.beta1,
      "beta2": this.beta2,
      "epsilon": this.epsilon
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["beta1"], config3["beta2"], config3["epsilon"]);
  }
};
AdamOptimizer.className = "Adam";
registerClass(AdamOptimizer);
var AdamaxOptimizer = class extends Optimizer {
  constructor(learningRate, beta1, beta2, epsilon3 = null, decay = 0) {
    super();
    this.learningRate = learningRate;
    this.beta1 = beta1;
    this.beta2 = beta2;
    this.epsilon = epsilon3;
    this.decay = decay;
    this.accumulatedFirstMoment = [];
    this.accumulatedWeightedInfNorm = [];
    tidy(() => {
      this.iteration = scalar(0).variable();
      this.accBeta1 = scalar(beta1).variable();
    });
    if (epsilon3 == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    tidy(() => {
      const oneMinusAccBeta1 = sub(1, this.accBeta1);
      const lr = div(-this.learningRate, add2(mul(this.iteration, this.decay), 1));
      variableNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedFirstMoment[i2] == null) {
          this.accumulatedFirstMoment[i2] = {
            originalName: `${name}/m`,
            variable: zerosLike(value).variable(trainable)
          };
        }
        if (this.accumulatedWeightedInfNorm[i2] == null) {
          this.accumulatedWeightedInfNorm[i2] = {
            originalName: `${name}/v`,
            variable: zerosLike(value).variable(trainable)
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const firstMoment = this.accumulatedFirstMoment[i2].variable;
        const weightedInfNorm = this.accumulatedWeightedInfNorm[i2].variable;
        const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
        const ut0 = mul(weightedInfNorm, this.beta2);
        const ut1 = abs(gradient);
        const newWeightedInfNorm = maximum(ut0, ut1);
        firstMoment.assign(newFirstMoment);
        weightedInfNorm.assign(newWeightedInfNorm);
        const newValue = add2(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add2(newWeightedInfNorm, this.epsilon))), value);
        value.assign(newValue);
      });
      this.iteration.assign(add2(this.iteration, 1));
      this.accBeta1.assign(mul(this.accBeta1, this.beta1));
    });
    this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose();
    this.iteration.dispose();
    if (this.accumulatedFirstMoment != null) {
      dispose(this.accumulatedFirstMoment.map((v2) => v2.variable));
    }
    if (this.accumulatedWeightedInfNorm != null) {
      dispose(this.accumulatedWeightedInfNorm.map((v2) => v2.variable));
    }
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(weightValues) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "beta1": this.beta1,
      "beta2": this.beta2,
      "epsilon": this.epsilon,
      "decay": this.decay
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["beta1"], config3["beta2"], config3["epsilon"], config3["decay"]);
  }
};
AdamaxOptimizer.className = "Adamax";
registerClass(AdamaxOptimizer);
var SGDOptimizer = class extends Optimizer {
  constructor(learningRate) {
    super();
    this.learningRate = learningRate;
    this.setLearningRate(learningRate);
  }
  applyGradients(variableGradients) {
    const varNames = Array.isArray(variableGradients) ? variableGradients.map((v2) => v2.name) : Object.keys(variableGradients);
    varNames.forEach((name, i2) => {
      const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const value = ENGINE.registeredVariables[name];
      tidy(() => {
        const newValue = add2(mul(this.c, gradient), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  setLearningRate(learningRate) {
    this.learningRate = learningRate;
    if (this.c != null) {
      this.c.dispose();
    }
    this.c = keep(scalar(-learningRate));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    if (weightValues.length !== 0) {
      throw new Error("SGD optimizer does not have settable weights.");
    }
  }
  getConfig() {
    return { "learningRate": this.learningRate };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"]);
  }
};
SGDOptimizer.className = "SGD";
registerClass(SGDOptimizer);
var MomentumOptimizer = class extends SGDOptimizer {
  constructor(learningRate, momentum, useNesterov = false) {
    super(learningRate);
    this.learningRate = learningRate;
    this.momentum = momentum;
    this.useNesterov = useNesterov;
    this.accumulations = [];
    this.m = scalar(this.momentum);
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i2) => {
      const value = ENGINE.registeredVariables[name];
      if (this.accumulations[i2] == null) {
        const trainable = false;
        this.accumulations[i2] = {
          originalName: `${name}/momentum`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const accumulation = this.accumulations[i2].variable;
      const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      tidy(() => {
        let newValue;
        const newAccumulation = add2(mul(this.m, accumulation), gradient);
        if (this.useNesterov) {
          newValue = add2(mul(this.c, add2(gradient, mul(newAccumulation, this.m))), value);
        } else {
          newValue = add2(mul(this.c, newAccumulation), value);
        }
        accumulation.assign(newAccumulation);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    this.m.dispose();
    if (this.accumulations != null) {
      dispose(this.accumulations.map((v2) => v2.variable));
    }
  }
  setMomentum(momentum) {
    this.momentum = momentum;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const trainable = false;
    this.accumulations = weightValues.map((v2) => ({ originalName: v2.name, variable: v2.tensor.variable(trainable) }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "momentum": this.momentum,
      "useNesterov": this.useNesterov
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["momentum"], config3["useNesterov"]);
  }
};
MomentumOptimizer.className = "Momentum";
registerClass(MomentumOptimizer);
var RMSPropOptimizer = class extends Optimizer {
  constructor(learningRate, decay = 0.9, momentum = 0, epsilon3 = null, centered = false) {
    super();
    this.learningRate = learningRate;
    this.decay = decay;
    this.momentum = momentum;
    this.epsilon = epsilon3;
    this.accumulatedMeanSquares = [];
    this.accumulatedMoments = [];
    this.accumulatedMeanGrads = [];
    this.centered = centered;
    if (epsilon3 == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
    if (learningRate == null) {
      throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i2) => {
      const value = ENGINE.registeredVariables[name];
      const trainable = false;
      if (this.accumulatedMeanSquares[i2] == null) {
        this.accumulatedMeanSquares[i2] = {
          originalName: `${name}/rms`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedMoments[i2] == null) {
        this.accumulatedMoments[i2] = {
          originalName: `${name}/momentum`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedMeanGrads[i2] == null && this.centered) {
        this.accumulatedMeanGrads[i2] = {
          originalName: `${name}/mg`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedMeanSquare = this.accumulatedMeanSquares[i2].variable;
      const accumulatedMoments = this.accumulatedMoments[i2].variable;
      tidy(() => {
        const newAccumulatedMeanSquare = add2(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
        if (this.centered) {
          const accumulatedMeanGrad = this.accumulatedMeanGrads[i2].variable;
          const newAccumulatedMeanGrad = add2(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
          const gradContribution = div(mul(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add2(square(newAccumulatedMeanGrad), this.epsilon))));
          const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), gradContribution);
          accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
          accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
          accumulatedMoments.assign(newAccumulatedMoments);
          const newValue = sub(value, newAccumulatedMoments);
          value.assign(newValue);
        } else {
          const newAccumulatedMeanSquare2 = add2(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
          const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt(add2(newAccumulatedMeanSquare2, this.epsilon))));
          accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
          accumulatedMoments.assign(newAccumulatedMoments);
          const newValue = sub(value, newAccumulatedMoments);
          value.assign(newValue);
        }
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedMeanSquares != null) {
      dispose(this.accumulatedMeanSquares.map((v2) => v2.variable));
    }
    if (this.accumulatedMeanGrads != null && this.centered) {
      dispose(this.accumulatedMeanGrads.map((v2) => v2.variable));
    }
    if (this.accumulatedMoments != null) {
      dispose(this.accumulatedMoments.map((v2) => v2.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    if (this.centered) {
      variables.push(...this.accumulatedMeanGrads);
    }
    return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
    const trainable = false;
    this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
    this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
      originalName: v2.name,
      variable: v2.tensor.variable(trainable)
    }));
    if (this.centered) {
      this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
    }
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "decay": this.decay,
      "momentum": this.momentum,
      "epsilon": this.epsilon,
      "centered": this.centered
    };
  }
  static fromConfig(cls, config3) {
    return new cls(config3["learningRate"], config3["decay"], config3["momentum"], config3["epsilon"], config3["centered"]);
  }
};
RMSPropOptimizer.className = "RMSProp";
registerClass(RMSPropOptimizer);
var OptimizerConstructors = class {
  static sgd(learningRate) {
    return new SGDOptimizer(learningRate);
  }
  static momentum(learningRate, momentum, useNesterov = false) {
    return new MomentumOptimizer(learningRate, momentum, useNesterov);
  }
  static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon3 = null, centered = false) {
    return new RMSPropOptimizer(learningRate, decay, momentum, epsilon3, centered);
  }
  static adam(learningRate = 1e-3, beta1 = 0.9, beta2 = 0.999, epsilon3 = null) {
    return new AdamOptimizer(learningRate, beta1, beta2, epsilon3);
  }
  static adadelta(learningRate = 1e-3, rho = 0.95, epsilon3 = null) {
    return new AdadeltaOptimizer(learningRate, rho, epsilon3);
  }
  static adamax(learningRate = 2e-3, beta1 = 0.9, beta2 = 0.999, epsilon3 = null, decay = 0) {
    return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon3, decay);
  }
  static adagrad(learningRate, initialAccumulatorValue = 0.1) {
    return new AdagradOptimizer(learningRate, initialAccumulatorValue);
  }
};
var train = {
  sgd: OptimizerConstructors.sgd,
  momentum: OptimizerConstructors.momentum,
  adadelta: OptimizerConstructors.adadelta,
  adagrad: OptimizerConstructors.adagrad,
  rmsprop: OptimizerConstructors.rmsprop,
  adamax: OptimizerConstructors.adamax,
  adam: OptimizerConstructors.adam
};
var delayCallback = (() => {
  if (typeof requestAnimationFrame !== "undefined") {
    return requestAnimationFrame;
  } else if (typeof setImmediate !== "undefined") {
    return setImmediate;
  }
  return (f2) => f2();
})();
function nextFrame() {
  return new Promise((resolve) => delayCallback(() => resolve()));
}
var backend_util_exports = {};
__export2(backend_util_exports, {
  ERF_A1: () => ERF_A1,
  ERF_A2: () => ERF_A2,
  ERF_A3: () => ERF_A3,
  ERF_A4: () => ERF_A4,
  ERF_A5: () => ERF_A5,
  ERF_P: () => ERF_P,
  PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
  SELU_SCALE: () => SELU_SCALE,
  SELU_SCALEALPHA: () => SELU_SCALEALPHA,
  applyActivation: () => applyActivation,
  assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
  assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
  assertParamsConsistent: () => assertParamsConsistent,
  assignToTypedArray: () => assignToTypedArray,
  axesAreInnerMostDims: () => axesAreInnerMostDims,
  calculateShapes: () => calculateShapes,
  checkEinsumDimSizes: () => checkEinsumDimSizes,
  combineLocations: () => combineLocations,
  complexWithEvenIndex: () => complexWithEvenIndex,
  complexWithOddIndex: () => complexWithOddIndex,
  computeConv2DInfo: () => computeConv2DInfo,
  computeConv3DInfo: () => computeConv3DInfo,
  computeDefaultPad: () => computeDefaultPad,
  computeDilation2DInfo: () => computeDilation2DInfo,
  computeOptimalWindowSize: () => computeOptimalWindowSize,
  computeOutAndReduceShapes: () => computeOutAndReduceShapes,
  computeOutShape: () => computeOutShape2,
  computePool2DInfo: () => computePool2DInfo,
  computePool3DInfo: () => computePool3DInfo,
  convertConv2DDataFormat: () => convertConv2DDataFormat,
  decodeEinsumEquation: () => decodeEinsumEquation,
  eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
  expandShapeToKeepDim: () => expandShapeToKeepDim,
  exponent: () => exponent,
  exponents: () => exponents,
  fromStringArrayToUint8: () => fromStringArrayToUint8,
  fromUint8ToStringArray: () => fromUint8ToStringArray,
  getAxesPermutation: () => getAxesPermutation,
  getBroadcastDims: () => getBroadcastDims,
  getComplexWithIndex: () => getComplexWithIndex,
  getEinsumComputePath: () => getEinsumComputePath,
  getEinsumPermutation: () => getEinsumPermutation,
  getFusedBiasGradient: () => getFusedBiasGradient,
  getFusedDyActivation: () => getFusedDyActivation,
  getImageCenter: () => getImageCenter,
  getInnerMostAxes: () => getInnerMostAxes,
  getPermuted: () => getPermuted,
  getReductionAxes: () => getReductionAxes,
  getReshaped: () => getReshaped,
  getReshapedPermuted: () => getReshapedPermuted,
  getSliceBeginCoords: () => getSliceBeginCoords,
  getSliceSize: () => getSliceSize,
  getUndoAxesPermutation: () => getUndoAxesPermutation,
  isIdentityPermutation: () => isIdentityPermutation,
  log: () => log2,
  mergeRealAndImagArrays: () => mergeRealAndImagArrays,
  prepareAndValidate: () => prepareAndValidate,
  prepareSplitSize: () => prepareSplitSize,
  segment_util: () => segment_util_exports,
  shouldFuse: () => shouldFuse,
  slice_util: () => slice_util_exports,
  splitRealAndImagArrays: () => splitRealAndImagArrays,
  tupleValuesAreOne: () => tupleValuesAreOne,
  upcastType: () => upcastType,
  validateInput: () => validateInput,
  validateUpdateShape: () => validateUpdateShape,
  warn: () => warn
});
function assertParamsConsistent(shapes, axis) {
  const rank = shapes[0].length;
  shapes.forEach((shape, i2) => {
    assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i2}] must be the same as the rank of the rest (${rank})`);
  });
  assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
  const firstShape = shapes[0];
  shapes.forEach((shape, i2) => {
    for (let r2 = 0; r2 < rank; r2++) {
      assert(r2 === axis || shape[r2] === firstShape[r2], () => `Error in concat${rank}D: Shape of tensors[${i2}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i2}.`);
    }
  });
}
function computeOutShape2(shapes, axis) {
  const outputShape = shapes[0].slice();
  for (let i2 = 1; i2 < shapes.length; i2++) {
    outputShape[axis] += shapes[i2][axis];
  }
  return outputShape;
}
var PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
  if (inSize <= PARALLELIZE_THRESHOLD) {
    return inSize;
  }
  return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
function getImageCenter(center, imageHeight, imageWidth) {
  const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
  const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
  return [centerX, centerY];
}
function getReshaped(inputShape, blockShape, prod6, batchToSpace = true) {
  let reshaped = [];
  if (batchToSpace) {
    reshaped = reshaped.concat(blockShape.slice(0));
    reshaped.push(inputShape[0] / prod6);
    reshaped = reshaped.concat(inputShape.slice(1));
  } else {
    reshaped = reshaped.concat(inputShape[0]);
    const spatialLength = blockShape.length;
    for (let i2 = 0; i2 < spatialLength; ++i2) {
      reshaped = reshaped.concat([inputShape[i2 + 1] / blockShape[i2], blockShape[i2]]);
    }
    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
  }
  return reshaped;
}
function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
  const permuted = [];
  if (batchToSpace) {
    permuted.push(blockShapeRank);
    for (let i2 = blockShapeRank + 1; i2 < reshapedRank; ++i2) {
      if (i2 <= 2 * blockShapeRank) {
        permuted.push(i2);
        permuted.push(i2 - (blockShapeRank + 1));
      } else {
        permuted.push(i2);
      }
    }
  } else {
    const permutedBeforeBatch = [];
    const permutedAfterBatch = [];
    for (let i2 = 1; i2 < reshapedRank; ++i2) {
      if (i2 >= blockShapeRank * 2 + 1 || i2 % 2 === 1) {
        permutedAfterBatch.push(i2);
      } else {
        permutedBeforeBatch.push(i2);
      }
    }
    permuted.push(...permutedBeforeBatch);
    permuted.push(0);
    permuted.push(...permutedAfterBatch);
  }
  return permuted;
}
function getReshapedPermuted(inputShape, blockShape, prod6, batchToSpace = true) {
  const reshapedPermuted = [];
  if (batchToSpace) {
    reshapedPermuted.push(inputShape[0] / prod6);
  } else {
    reshapedPermuted.push(inputShape[0] * prod6);
  }
  for (let i2 = 1; i2 < inputShape.length; ++i2) {
    if (i2 <= blockShape.length) {
      if (batchToSpace) {
        reshapedPermuted.push(blockShape[i2 - 1] * inputShape[i2]);
      } else {
        reshapedPermuted.push(inputShape[i2] / blockShape[i2 - 1]);
      }
    } else {
      reshapedPermuted.push(inputShape[i2]);
    }
  }
  return reshapedPermuted;
}
function getSliceBeginCoords(crops, blockShape) {
  const sliceBeginCoords = [0];
  for (let i2 = 0; i2 < blockShape; ++i2) {
    sliceBeginCoords.push(crops[i2][0]);
  }
  return sliceBeginCoords;
}
function getSliceSize(uncroppedShape, crops, blockShape) {
  const sliceSize = uncroppedShape.slice(0, 1);
  for (let i2 = 0; i2 < blockShape; ++i2) {
    sliceSize.push(uncroppedShape[i2 + 1] - crops[i2][0] - crops[i2][1]);
  }
  return sliceSize;
}
var SELU_SCALEALPHA = 1.7580993408473768;
var SELU_SCALE = 1.0507009873554805;
var ERF_P = 0.3275911;
var ERF_A1 = 0.254829592;
var ERF_A2 = -0.284496736;
var ERF_A3 = 1.421413741;
var ERF_A4 = -1.453152027;
var ERF_A5 = 1.061405429;
function mergeRealAndImagArrays(real5, imag5) {
  if (real5.length !== imag5.length) {
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real5.length}, imag: ${imag5.length}.`);
  }
  const result = new Float32Array(real5.length * 2);
  for (let i2 = 0; i2 < result.length; i2 += 2) {
    result[i2] = real5[i2 / 2];
    result[i2 + 1] = imag5[i2 / 2];
  }
  return result;
}
function splitRealAndImagArrays(complex5) {
  const real5 = new Float32Array(complex5.length / 2);
  const imag5 = new Float32Array(complex5.length / 2);
  for (let i2 = 0; i2 < complex5.length; i2 += 2) {
    real5[i2 / 2] = complex5[i2];
    imag5[i2 / 2] = complex5[i2 + 1];
  }
  return { real: real5, imag: imag5 };
}
function complexWithEvenIndex(complex5) {
  const len = Math.ceil(complex5.length / 4);
  const real5 = new Float32Array(len);
  const imag5 = new Float32Array(len);
  for (let i2 = 0; i2 < complex5.length; i2 += 4) {
    real5[Math.floor(i2 / 4)] = complex5[i2];
    imag5[Math.floor(i2 / 4)] = complex5[i2 + 1];
  }
  return { real: real5, imag: imag5 };
}
function complexWithOddIndex(complex5) {
  const len = Math.floor(complex5.length / 4);
  const real5 = new Float32Array(len);
  const imag5 = new Float32Array(len);
  for (let i2 = 2; i2 < complex5.length; i2 += 4) {
    real5[Math.floor(i2 / 4)] = complex5[i2];
    imag5[Math.floor(i2 / 4)] = complex5[i2 + 1];
  }
  return { real: real5, imag: imag5 };
}
function getComplexWithIndex(complex5, index) {
  const real5 = complex5[index * 2];
  const imag5 = complex5[index * 2 + 1];
  return { real: real5, imag: imag5 };
}
function assignToTypedArray(data, real5, imag5, index) {
  data[index * 2] = real5;
  data[index * 2 + 1] = imag5;
}
function exponents(n2, inverse) {
  const real5 = new Float32Array(n2 / 2);
  const imag5 = new Float32Array(n2 / 2);
  for (let i2 = 0; i2 < Math.ceil(n2 / 2); i2++) {
    const x2 = (inverse ? 2 : -2) * Math.PI * (i2 / n2);
    real5[i2] = Math.cos(x2);
    imag5[i2] = Math.sin(x2);
  }
  return { real: real5, imag: imag5 };
}
function exponent(k3, n2, inverse) {
  const x2 = (inverse ? 2 : -2) * Math.PI * (k3 / n2);
  const real5 = Math.cos(x2);
  const imag5 = Math.sin(x2);
  return { real: real5, imag: imag5 };
}
var ARROW = "->";
var ARROW_REGEX = /->/g;
var COMMA = ",";
var ELLIPSIS = "...";
function decodeEinsumEquation(equation, numTensors) {
  equation = equation.replace(/\s/g, "");
  const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
  if (numArrows < 1) {
    throw new Error("Equations without an arrow are not supported.");
  } else if (numArrows > 1) {
    throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
  }
  const [inputString, outputString] = equation.split(ARROW);
  assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
  const inputTerms = inputString.split(COMMA);
  const numInputs = inputTerms.length;
  if (numTensors !== numInputs) {
    throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
  }
  if (numInputs > 2) {
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  }
  const allDims = [];
  for (let i2 = 0; i2 < outputString.length; ++i2) {
    const dimName = outputString[i2];
    if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
      throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
    }
    if (allDims.indexOf(dimName) === -1) {
      allDims.push(dimName);
    }
  }
  for (let i2 = 0; i2 < inputString.length; ++i2) {
    const dimName = inputString[i2];
    if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
      allDims.push(dimName);
    }
  }
  const idDims = new Array(inputTerms.length);
  for (let i2 = 0; i2 < numInputs; ++i2) {
    if (new Set(inputTerms[i2].split("")).size !== inputTerms[i2].length) {
      throw new Error(`Found duplicate axes in input component ${inputTerms[i2]}. Support for duplicate axes in input is not implemented yet.`);
    }
    idDims[i2] = [];
    for (let j2 = 0; j2 < inputTerms[i2].length; ++j2) {
      idDims[i2].push(allDims.indexOf(inputTerms[i2][j2]));
    }
  }
  const numDims = allDims.length;
  const numOutDims = outputString.length;
  const summedDims = [];
  for (let i2 = numOutDims; i2 < numDims; ++i2) {
    summedDims.push(i2);
  }
  return { allDims, summedDims, idDims };
}
function getEinsumPermutation(nDims, idDims) {
  let permutationIndices = new Array(nDims);
  permutationIndices.fill(-1);
  for (let i2 = 0; i2 < idDims.length; ++i2) {
    permutationIndices[idDims[i2]] = i2;
  }
  const expandDims7 = [];
  for (let i2 = 0; i2 < nDims; ++i2) {
    if (permutationIndices[i2] === -1) {
      expandDims7.push(i2);
    }
  }
  permutationIndices = permutationIndices.filter((d2) => d2 !== -1);
  return { permutationIndices, expandDims: expandDims7 };
}
function checkEinsumDimSizes(nDims, idDims, tensors) {
  const dimSizes = new Array(nDims);
  for (let i2 = 0; i2 < tensors.length; ++i2) {
    const shape = tensors[i2].shape;
    for (let j2 = 0; j2 < idDims[i2].length; ++j2) {
      if (dimSizes[idDims[i2][j2]] === void 0) {
        dimSizes[idDims[i2][j2]] = shape[j2];
      } else {
        assert(dimSizes[idDims[i2][j2]] === shape[j2], () => `Expected dimension ${dimSizes[idDims[i2][j2]]} at axis ${j2} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j2]}`);
      }
    }
  }
}
function getEinsumComputePath(summedDims, idDims) {
  const path = summedDims;
  const steps = [];
  let nSteps = 0;
  if (summedDims.length === 0) {
    path.push(-1);
  }
  nSteps = summedDims.length + 1;
  for (let i2 = 0; i2 < nSteps; ++i2) {
    steps.push([]);
  }
  const computedTermIndices = [];
  for (let i2 = 0; i2 < path.length; ++i2) {
    const summedDim = path[i2];
    const termIndices = findTermsWithDim(idDims, summedDim);
    for (const termIndex of termIndices) {
      if (computedTermIndices.indexOf(termIndex) === -1) {
        steps[i2].push(termIndex);
        computedTermIndices.push(termIndex);
      }
    }
  }
  return { path, steps };
}
function isIdentityPermutation(perm) {
  return perm.every((dim, index) => dim === index);
}
function findTermsWithDim(idDims, dim) {
  const termIndices = [];
  for (let i2 = 0; i2 < idDims.length; ++i2) {
    if (idDims[i2].length === 0 || idDims[i2].indexOf(dim) !== -1 || dim === -1) {
      termIndices.push(i2);
    }
  }
  return termIndices;
}
function prepareSplitSize(x2, numOrSizeSplits, axis = 0) {
  let splitSizes = [];
  if (typeof numOrSizeSplits === "number") {
    assert(x2.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
    splitSizes = new Array(numOrSizeSplits).fill(x2.shape[axis] / numOrSizeSplits);
  } else {
    const numOfNegs = numOrSizeSplits.reduce((count22, value) => {
      if (value === -1) {
        count22 += 1;
      }
      return count22;
    }, 0);
    assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
    const negIndex = numOrSizeSplits.indexOf(-1);
    if (negIndex !== -1) {
      const total = numOrSizeSplits.reduce((a6, b2) => b2 > 0 ? a6 + b2 : a6);
      numOrSizeSplits[negIndex] = x2.shape[axis] - total;
    }
    assert(x2.shape[axis] === numOrSizeSplits.reduce((a6, b2) => a6 + b2), () => "The sum of sizes must match the size of the axis dimension.");
    splitSizes = numOrSizeSplits;
  }
  return splitSizes;
}
var segment_util_exports = {};
__export2(segment_util_exports, {
  collectGatherOpShapeInfo: () => collectGatherOpShapeInfo,
  computeOutShape: () => computeOutShape3,
  segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize
});
function segOpComputeOptimalWindowSize(inSize, numSegments) {
  let done = false;
  let res2;
  if (inSize <= PARALLELIZE_THRESHOLD) {
    res2 = inSize;
    done = true;
  } else {
    res2 = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }
  while (!done) {
    if (res2 > numSegments || res2 === inSize) {
      done = true;
    } else {
      res2 = nearestDivisor(inSize, res2 + 1);
    }
  }
  return res2;
}
function computeOutShape3(aShape, axis, numSegments) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (dim !== axis) {
      outShape.push(aShape[dim]);
    } else {
      outShape.push(numSegments);
    }
  }
  return outShape;
}
function collectGatherOpShapeInfo(x2, indices, axis, batchDims) {
  const indicesRank = indices.shape.length;
  const xRank = x2.shape.length;
  if (batchDims !== 0) {
    if (batchDims < -indicesRank || batchDims > indicesRank) {
      throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
    }
  }
  if (batchDims < 0) {
    batchDims += indicesRank;
  }
  if (batchDims > xRank) {
    throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
  }
  if (axis < batchDims) {
    throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
  }
  for (let i2 = 0; i2 < batchDims; ++i2) {
    if (x2.shape[i2] !== indices.shape[i2]) {
      throw new Error(`x.shape[${i2}]: ${x2.shape[i2]} should be equal to indices.shape[${i2}]: ${indices.shape[i2]}.`);
    }
  }
  const dimSize = x2.shape[axis];
  const outputShape = [];
  let batchSize = 1;
  let outerSize = 1;
  let sliceSize = 1;
  for (let i2 = 0; i2 < batchDims; ++i2) {
    outputShape.push(x2.shape[i2]);
    batchSize *= x2.shape[i2];
  }
  for (let i2 = batchDims; i2 < axis; i2++) {
    outputShape.push(x2.shape[i2]);
    outerSize *= x2.shape[i2];
  }
  for (let i2 = batchDims; i2 < indicesRank; i2++) {
    outputShape.push(indices.shape[i2]);
  }
  for (let i2 = axis + 1; i2 < xRank; i2++) {
    outputShape.push(x2.shape[i2]);
    sliceSize *= x2.shape[i2];
  }
  return { batchSize, sliceSize, outerSize, dimSize, outputShape };
}
function fromUint8ToStringArray(vals) {
  try {
    return vals.map((val) => decodeString(val));
  } catch (err) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
  }
}
function fromStringArrayToUint8(strings) {
  return strings.map((s2) => encodeString(s2));
}
var kernel_impls_exports = {};
__export2(kernel_impls_exports, {
  nonMaxSuppressionV3Impl: () => nonMaxSuppressionV3Impl,
  nonMaxSuppressionV4Impl: () => nonMaxSuppressionV4Impl,
  nonMaxSuppressionV5Impl: () => nonMaxSuppressionV5Impl,
  whereImpl: () => whereImpl
});
var absGradConfig = {
  kernelName: Abs,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(dy, step(cast(x2, "float32"), -1)) };
  }
};
var acosGradConfig = {
  kernelName: Acos,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return {
      x: () => {
        const a6 = square(cast(x2, "float32"));
        const b2 = sqrt(sub(scalar(1), a6));
        return neg(div(dy, b2));
      }
    };
  }
};
var acoshGradConfig = {
  kernelName: Acosh,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return {
      x: () => {
        const a6 = sqrt(sub(square(cast(x2, "float32")), 1));
        return div(dy, a6);
      }
    };
  }
};
var addGradConfig = {
  kernelName: Add,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      let res2 = dy;
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, a6.shape);
    };
    const derB = () => {
      let res2 = dy;
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, b2.shape);
    };
    return { a: derA, b: derB };
  }
};
var addNGradConfig = {
  kernelName: AddN,
  saveAllInputs: true,
  gradFunc: (dy, saved) => {
    const ders = {};
    saved.forEach((_2, i2) => {
      ders[i2] = () => dy.clone();
    });
    return ders;
  }
};
var argMaxGradConfig = {
  kernelName: ArgMax,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => zerosLike(x2) };
  }
};
var argMinGradConfig = {
  kernelName: ArgMin,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => zerosLike(x2) };
  }
};
var asinGradConfig = {
  kernelName: Asin,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, sqrt(sub(scalar(1), square(cast(x2, "float32"))))) };
  }
};
var asinhGradConfig = {
  kernelName: Asinh,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return {
      x: () => {
        const a6 = sqrt(add2(scalar(1), square(cast(x2, "float32"))));
        return div(dy, a6);
      }
    };
  }
};
var atan2GradConfig = {
  kernelName: Atan2,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      const d2 = add2(square(a6), square(b2));
      let res2 = mul(dy, div(b2, d2));
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, a6.shape);
    };
    const derB = () => {
      const d2 = add2(square(a6), square(b2));
      let res2 = neg(mul(dy, div(a6, d2)));
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, b2.shape);
    };
    return { a: derA, b: derB };
  }
};
var atanGradConfig = {
  kernelName: Atan,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, add2(square(cast(x2, "float32")), 1)) };
  }
};
var atanhGradConfig = {
  kernelName: Atanh,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, sub(scalar(1), square(cast(x2, "float32")))) };
  }
};
function avgPool3dGrad_(dy, input2, filterSize, strides, pad3, dimRoundingMode) {
  const $dy = convertToTensor(dy, "dy", "avgPool3dGrad");
  const $input = convertToTensor(input2, "input", "avgPool3dGrad");
  let dy5D = $dy;
  let input5D = $input;
  let reshapedTo5D = false;
  if ($input.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
    input5D = reshape($input, [
      1,
      $input.shape[0],
      $input.shape[1],
      $input.shape[2],
      $input.shape[3]
    ]);
  }
  assert(dy5D.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${dy5D.rank}.`);
  assert(input5D.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${input5D.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { dy: dy5D, input: input5D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
  const res2 = ENGINE.runKernel(AvgPool3DGrad, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var avgPool3dGrad = op({ avgPool3dGrad_ });
var avgPool3DGradConfig = {
  kernelName: AvgPool3D,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    return {
      x: () => avgPool3dGrad(dy, x2, filterSize, strides, pad3, dimRoundingMode)
    };
  }
};
function avgPoolGrad_(dy, input2, filterSize, strides, pad3) {
  const $dy = convertToTensor(dy, "dy", "avgPoolGrad");
  const $input = convertToTensor(input2, "input", "avgPoolGrad");
  assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
  let input4D = $input;
  let dy4D = $dy;
  let reshapedTo4D = false;
  if ($input.rank === 3) {
    reshapedTo4D = true;
    input4D = reshape($input, [1, $input.shape[0], $input.shape[1], $input.shape[2]]);
    dy4D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2]]);
  }
  assert(dy4D.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${dy4D.rank}.`);
  assert(input4D.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${input4D.rank}.`);
  const inputs = { dy: dy4D, input: input4D };
  const attrs = { filterSize, strides, pad: pad3 };
  const res2 = ENGINE.runKernel(AvgPoolGrad, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3]]);
  }
  return res2;
}
var avgPoolGrad = op({ avgPoolGrad_ });
var avgPoolGradConfig = {
  kernelName: AvgPool,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { filterSize, strides, pad: pad3 } = attrs;
    return { x: () => avgPoolGrad(dy, x2, filterSize, strides, pad3) };
  }
};
var batchMatMulGradConfig = {
  kernelName: BatchMatMul,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved, attrs) => {
    const [a6, b2] = saved;
    const { transposeA, transposeB } = attrs;
    if (!transposeA && !transposeB) {
      return {
        a: () => matMul(dy, b2, false, true),
        b: () => matMul(a6, dy, true, false)
      };
    } else if (!transposeA && transposeB) {
      return {
        a: () => matMul(dy, b2, false, false),
        b: () => matMul(dy, a6, true, false)
      };
    } else if (transposeA && !transposeB) {
      return {
        a: () => matMul(b2, dy, false, true),
        b: () => matMul(a6, dy, false, false)
      };
    } else {
      return {
        a: () => matMul(b2, dy, true, true),
        b: () => matMul(dy, a6, true, true)
      };
    }
  }
};
var batchToSpaceNDGradConfig = {
  kernelName: BatchToSpaceND,
  gradFunc: (dy, saved, attrs) => {
    const { blockShape, crops } = attrs;
    return { x: () => spaceToBatchND(dy, blockShape, crops) };
  }
};
var broadcastToGradConfig = {
  kernelName: BroadcastTo,
  gradFunc: (dy, saved, attrs) => {
    const broadCastToAttrs = attrs;
    const inputShape = broadCastToAttrs.inputShape;
    const outputShape = broadCastToAttrs.shape;
    const reps = Array.from(outputShape);
    for (let i2 = inputShape.length - 1; i2 >= 0; i2--) {
      if (inputShape[i2] === outputShape[i2]) {
        reps[i2] = 1;
      } else if (inputShape[i2] !== 1) {
        throw new Error(`broadcastTo(): [${inputShape}] cannot be broadcast to [${outputShape}].`);
      }
    }
    const axes = [];
    for (let i2 = 0; i2 < reps.length; i2++) {
      if (reps[i2] > 1) {
        axes.push(i2);
      }
    }
    return { x: () => sum2(dy, axes, true) };
  }
};
var castGradConfig = {
  kernelName: Cast,
  gradFunc: (dy) => {
    return { x: () => dy.clone() };
  }
};
var ceilGradConfig = {
  kernelName: Ceil,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var clipByValueGradConfig = {
  kernelName: ClipByValue,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { clipValueMin, clipValueMax } = attrs;
    return {
      x: () => where(logicalAnd(greaterEqual(x2, clipValueMin), lessEqual(x2, clipValueMax)), dy, zerosLike(dy))
    };
  }
};
var complexAbsGradConfig = {
  kernelName: ComplexAbs,
  inputsToSave: ["x"],
  gradFunc: absGradConfig.gradFunc
};
var concatGradConfig = {
  kernelName: Concat,
  saveAllInputs: true,
  gradFunc: (dy, saved, attrs) => {
    const shapes = saved.map((t2) => t2.shape);
    const { axis } = attrs;
    const $axis = parseAxisParam(axis, saved[0].shape)[0];
    const sizeSplits = shapes.map((s2) => s2[$axis]);
    const derTensors = split(dy, sizeSplits, $axis);
    return derTensors.map((t2) => () => t2);
  }
};
var conv2DGradConfig = {
  kernelName: Conv2D,
  inputsToSave: ["x", "filter"],
  gradFunc: (dy, saved, attrs) => {
    const [x4D, $filter] = saved;
    const { dilations, strides, pad: pad3, dataFormat } = attrs;
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
    return {
      x: () => conv2DBackpropInput(x4D.shape, dy, $filter, strides, pad3, dataFormat),
      filter: () => conv2DBackpropFilter(x4D, dy, $filter.shape, strides, pad3, dataFormat)
    };
  }
};
var conv2DBackpropInputGradConfig = {
  kernelName: Conv2DBackpropInput,
  inputsToSave: ["dy", "filter"],
  gradFunc: (ddx, saved, attrs) => {
    const [dy, filter] = saved;
    const { strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
    return {
      dy: () => conv2d(ddx, filter, strides, pad3, dataFormat, 1, dimRoundingMode),
      filter: () => conv2DBackpropFilter(ddx, dy, filter.shape, strides, pad3, dataFormat, dimRoundingMode)
    };
  }
};
function conv3DBackpropFilter_(x2, dy, filterShape, strides, pad3) {
  let x5D = x2;
  if (x2.rank === 4) {
    x5D = reshape(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2], x2.shape[3]]);
  }
  let dy5D = dy;
  if (dy5D.rank === 4) {
    dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${x5D.shape}.`);
  assert(dy5D.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${dy5D.shape}.`);
  assert(filterShape.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${filterShape}.`);
  assert(x5D.shape[4] === filterShape[3], () => `Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must match input depth in filter (${filterShape[3]}.`);
  assert(dy5D.shape[4] === filterShape[4], () => `Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must match output depth for filter (${filterShape[4]}).`);
  const inputs = { x: x5D, dy: dy5D };
  const attrs = { strides, pad: pad3, filterShape };
  return ENGINE.runKernel(Conv3DBackpropFilterV2, inputs, attrs);
}
var conv3DBackpropFilter = op({ conv3DBackpropFilter_ });
var conv3DGradConfig = {
  kernelName: Conv3D,
  inputsToSave: ["x", "filter"],
  gradFunc: (dy, saved, attrs) => {
    const { dilations, strides, pad: pad3 } = attrs;
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
    const [x5D, $filter] = saved;
    return {
      x: () => conv3DBackpropInput(x5D.shape, dy, $filter, strides, pad3),
      filter: () => conv3DBackpropFilter(x5D, dy, $filter.shape, strides, pad3)
    };
  }
};
var cosGradConfig = {
  kernelName: Cos,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(neg(sin(cast(x2, "float32"))), dy) };
  }
};
var coshGradConfig = {
  kernelName: Cosh,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(sinh(cast(x2, "float32")), dy) };
  }
};
var cumsumGradConfig = {
  kernelName: Cumsum,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { axis, exclusive, reverse: reverse5 } = attrs;
    return {
      x: () => {
        const permutation = getAxesPermutation([axis], x2.rank);
        let out = cumsum(dy, axis, exclusive, !reverse5);
        if (permutation != null) {
          out = transpose(out, permutation);
        }
        return out;
      }
    };
  }
};
var depthwiseConv2dNativeGradConfig = {
  kernelName: DepthwiseConv2dNative,
  inputsToSave: ["x", "filter"],
  gradFunc: (dy, saved, attrs) => {
    const { dilations, strides, pad: pad3, dimRoundingMode } = attrs;
    const $dilations = dilations == null ? [1, 1] : dilations;
    assert(tupleValuesAreOne($dilations), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${$dilations}'`);
    const [x2, filter] = saved;
    assert(x2.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${x2.rank}.`);
    assert(filter.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${filter.rank}.`);
    assert(x2.shape[3] === filter.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${x2.shape[3]}) must match the inChannels dimension in filter ${filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${strides} and dilations '${$dilations}'.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    return {
      x: () => depthwiseConv2dNativeBackpropInput(x2.shape, dy, filter, strides, pad3, $dilations, dimRoundingMode),
      filter: () => depthwiseConv2dNativeBackpropFilter(x2, dy, filter.shape, strides, pad3, $dilations, dimRoundingMode)
    };
  }
};
var dilation2dGradConfig = {
  kernelName: Dilation2D,
  inputsToSave: ["x", "filter"],
  gradFunc: (dy, saved, attrs) => {
    const [x2, filter] = saved;
    const inputInputs = { x: x2, filter, dy };
    const filterInputs = { x: x2, filter, dy };
    return {
      x: () => ENGINE.runKernel(Dilation2DBackpropInput, inputInputs, attrs),
      filter: () => ENGINE.runKernel(Dilation2DBackpropFilter, filterInputs, attrs)
    };
  }
};
var eluGradConfig = {
  kernelName: Elu,
  outputsToSave: [true],
  gradFunc: (dy, saved) => {
    const [y2] = saved;
    const inputs = { dy, y: y2 };
    return { x: () => ENGINE.runKernel(EluGrad, inputs) };
  }
};
var erfGradConfig = {
  kernelName: Erf,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    const a6 = mul(exp(neg(square(x2))), 2 / Math.sqrt(Math.PI));
    return { x: () => mul(dy, a6) };
  }
};
var expGradConfig = {
  kernelName: Exp,
  outputsToSave: [true],
  gradFunc: (dy, saved) => {
    const [y2] = saved;
    return { x: () => mul(dy, y2) };
  }
};
var expandDimsGradConfig = {
  kernelName: ExpandDims,
  inputsToSave: ["input"],
  gradFunc: (dy, saved) => {
    const [input2] = saved;
    return { input: () => reshape(dy, input2.shape) };
  }
};
var expm1GradConfig = {
  kernelName: Expm1,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(dy, exp(x2)) };
  }
};
var floorGradConfig = {
  kernelName: Floor,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var floorDivGradConfig = {
  kernelName: FloorDiv,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      const res2 = div(dy, cast(b2, "float32"));
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(res2, reduceAxes), a6.shape);
      }
      return res2;
    };
    const derB = () => {
      let res2 = mul(dy, cast(a6, "float32"));
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = reshape(sum2(res2, reduceAxes), b2.shape);
      }
      const tmp2 = square(b2);
      return neg(div(res2, cast(tmp2, "float32")));
    };
    return { a: derA, b: derB };
  }
};
var fusedBatchNormGradConfig = {
  kernelName: FusedBatchNorm,
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: (dy, saved, attrs) => {
    const { varianceEpsilon } = attrs;
    const [x2, mean5, variance, scale22] = saved;
    const scaleValue = scale22 == null ? scalar(1) : scale22;
    const reductionAxes = getReductionAxes(mean5.shape, x2.shape);
    const tileShape = [];
    if (mean5.rank === 1) {
      for (let i2 = 0; i2 < x2.shape.length - 1; ++i2) {
        tileShape.push(x2.shape[i2]);
      }
      tileShape.push(1);
    }
    const xMinusMean = sub(x2, mean5);
    const dyTimesScaleValue = mul(dy, scaleValue);
    const oneOverSqrtVariance = rsqrt(add2(variance, scalar(varianceEpsilon)));
    const minusHalfRCube = mul(mul(mul(oneOverSqrtVariance, oneOverSqrtVariance), oneOverSqrtVariance), scalar(-0.5));
    const derX = () => {
      if (mean5.rank === 1) {
        return reshape(mul(mul(dy, tile(reshape(oneOverSqrtVariance, [1, 1, 1, mean5.shape[0]]), tileShape)), scaleValue), x2.shape);
      } else {
        return reshape(mul(mul(dy, oneOverSqrtVariance), scaleValue), x2.shape);
      }
    };
    const derMean = () => {
      let meanDer = mul(mul(oneOverSqrtVariance, scalar(-1)), dyTimesScaleValue);
      if (mean5.rank === 1) {
        meanDer = sum2(meanDer, reductionAxes);
      }
      return reshape(meanDer, mean5.shape);
    };
    const derVariance = () => {
      let varianceDer = mul(mul(minusHalfRCube, xMinusMean), dyTimesScaleValue);
      if (mean5.rank === 1) {
        varianceDer = sum2(varianceDer, reductionAxes);
      }
      return reshape(varianceDer, mean5.shape);
    };
    const derScale = () => {
      const xMinusMean2TimesRsqrt = mul(xMinusMean, oneOverSqrtVariance);
      let scaleDer = mul(dy, xMinusMean2TimesRsqrt);
      if (mean5.rank === 1) {
        scaleDer = sum2(scaleDer, reductionAxes);
      }
      return reshape(scaleDer, mean5.shape);
    };
    const derOffset = () => {
      let offsetDer = dy;
      if (mean5.rank === 1) {
        offsetDer = sum2(offsetDer, reductionAxes);
      }
      return reshape(offsetDer, mean5.shape);
    };
    return {
      x: derX,
      mean: derMean,
      variance: derVariance,
      scale: derScale,
      offset: derOffset
    };
  }
};
var gatherGradConfig = {
  kernelName: GatherV2,
  inputsToSave: ["x", "indices"],
  gradFunc: (dy, saved, attrs) => {
    const [x2, indices] = saved;
    const { axis } = attrs;
    const parsedAxis = parseAxisParam(axis, x2.shape)[0];
    const derX = () => {
      const paramsShape = x2.shape;
      const indicesSize = indices.size;
      const outerShape = paramsShape.slice(0, parsedAxis);
      const outerDims = outerShape.length;
      const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
      const innerDims = innerShape.length;
      const outerAxesIndices = arrayRange(0, outerDims);
      const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
      const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);
      const values = reshape(dy, valuesShape);
      const reshapedIndices = reshape(indices, [indicesSize]);
      const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
      const valuesTranspose = transpose(values, transposeDims);
      let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, x2.shape[parsedAxis]);
      const invertTransposeDims = getUndoAxesPermutation(transposeDims);
      paramsGrad = transpose(paramsGrad, invertTransposeDims);
      return paramsGrad;
    };
    return { x: derX, indices: () => indices };
  }
};
function arrayRange(start, stop) {
  const result = [];
  for (let i2 = start; i2 < stop; ++i2) {
    result.push(i2);
  }
  return result;
}
function arrayConcat(arrays) {
  const result = [];
  for (let i2 = 0; i2 < arrays.length; ++i2) {
    for (let j2 = 0; j2 < arrays[i2].length; ++j2) {
      result.push(arrays[i2][j2]);
    }
  }
  return result;
}
var greaterEqualGradConfig = {
  kernelName: GreaterEqual,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    return { a: () => zerosLike(a6), b: () => zerosLike(b2) };
  }
};
var identityGradConfig = {
  kernelName: Identity,
  gradFunc: (dy) => {
    return { x: () => cast(dy, "float32") };
  }
};
var isFiniteGradConfig = {
  kernelName: IsFinite,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var isInfGradConfig = {
  kernelName: IsInf,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var isNanGradConfig = {
  kernelName: IsNan,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var leakyReluGradConfig = {
  kernelName: LeakyRelu,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { alpha } = attrs;
    const mask = greater(x2, 0);
    return { x: () => where(mask, dy, mul(dy, alpha)) };
  }
};
var log1pGradConfig = {
  kernelName: Log1p,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, add2(x2, 1)) };
  }
};
var logGradConfig = {
  kernelName: Log,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, cast(x2, "float32")) };
  }
};
var logSoftmaxGradConfig = {
  kernelName: LogSoftmax,
  inputsToSave: [],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const [value] = saved;
    const { axis } = attrs;
    return {
      logits: () => {
        const keepDims = true;
        const softmax7 = exp(value);
        return sub(dy, mul(sum2(dy, axis, keepDims), softmax7));
      }
    };
  }
};
function localResponseNormalizationBackprop_(x2, y2, dy, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
  const inputs = { x: x2, y: y2, dy };
  const attrs = { depthRadius, bias, alpha, beta };
  return ENGINE.runKernel(LRNGrad, inputs, attrs);
}
var localResponseNormalizationBackprop = op({ localResponseNormalizationBackprop_ });
var lrnGradConfig = {
  kernelName: LRN,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const [x2, y2] = saved;
    const { depthRadius, bias, alpha, beta } = attrs;
    return {
      x: () => localResponseNormalizationBackprop(x2, y2, dy, depthRadius, bias, alpha, beta)
    };
  }
};
function gradForMinAndMax(dy, y2, xOrig, origAxes) {
  if (y2.rank < xOrig.rank) {
    y2 = reshape(y2, expandShapeToKeepDim(y2.shape, origAxes));
  }
  if (dy.rank < xOrig.rank) {
    dy = reshape(dy, expandShapeToKeepDim(dy.shape, origAxes));
  }
  return {
    x: () => {
      const dx = mul(dy, cast(equal(xOrig, y2), dy.dtype));
      return dx;
    }
  };
}
var maxGradConfig = {
  kernelName: Max,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const maxAttrs = attrs;
    const { reductionIndices } = maxAttrs;
    const x2 = saved[0];
    const y2 = saved[1];
    const origAxes = parseAxisParam(reductionIndices, x2.shape);
    const maxGrad = gradForMinAndMax(dy, y2, x2, origAxes);
    return {
      x: () => {
        return maxGrad["x"]();
      }
    };
  }
};
var maximumGradConfig = {
  kernelName: Maximum,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const derA = () => mul(dy, cast(greaterEqual(a6, b2), "float32"));
    const derB = () => mul(dy, cast(less(a6, b2), "float32"));
    return { a: derA, b: derB };
  }
};
function maxPool3dGrad_(dy, input2, output, filterSize, strides, pad3, dimRoundingMode) {
  const $dy = convertToTensor(dy, "dy", "maxPool3dGrad");
  const $input = convertToTensor(input2, "input", "maxPool3dGrad");
  const $output = convertToTensor(output, "output", "maxPool3dGrad");
  let dy5D = $dy;
  let input5D = $input;
  let output5D = $output;
  let reshapedTo5D = false;
  if ($input.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
    input5D = reshape($input, [
      1,
      $input.shape[0],
      $input.shape[1],
      $input.shape[2],
      $input.shape[3]
    ]);
    output5D = reshape($output, [
      1,
      $output.shape[0],
      $output.shape[1],
      $output.shape[2],
      $output.shape[3]
    ]);
  }
  assert(dy5D.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${dy5D.rank}.`);
  assert(input5D.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${input5D.rank}.`);
  assert(output5D.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${output5D.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { dy: dy5D, input: input5D, output: output5D };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
  const res2 = ENGINE.runKernel(MaxPool3DGrad, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res2, [res2.shape[1], res2.shape[2], res2.shape[3], res2.shape[4]]);
  }
  return res2;
}
var maxPool3dGrad = op({ maxPool3dGrad_ });
var maxPool3DGradConfig = {
  kernelName: MaxPool3D,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const [x2, y2] = saved;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    return {
      x: () => maxPool3dGrad(dy, x2, y2, filterSize, strides, pad3, dimRoundingMode)
    };
  }
};
function maxPoolGrad_(dy, input2, output, filterSize, strides, pad3, dimRoundingMode) {
  const $dy = convertToTensor(dy, "dy", "maxPoolGrad");
  const $input = convertToTensor(input2, "input", "maxPoolGrad");
  const $output = convertToTensor(output, "output", "maxPoolGrad");
  assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
  assert($dy.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${$dy.rank}.`);
  assert($input.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${$input.rank}.`);
  if (dimRoundingMode != null) {
    assert(isInt(pad3), () => `Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
  }
  const inputs = { dy: $dy, input: $input, output: $output };
  const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
  return ENGINE.runKernel(MaxPoolGrad, inputs, attrs);
}
var maxPoolGrad = op({ maxPoolGrad_ });
var maxPoolGradConfig = {
  kernelName: MaxPool,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const [x2, y2] = saved;
    const { filterSize, strides, pad: pad3 } = attrs;
    return {
      x: () => maxPoolGrad(dy, x2, y2, filterSize, strides, pad3)
    };
  }
};
var meanGradConfig = {
  kernelName: Mean,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { axis } = attrs;
    const axes = parseAxisParam(axis, x2.shape);
    const shapes = computeOutAndReduceShapes(x2.shape, axes);
    const reduceShape = shapes[1];
    const reduceSize = sizeFromShape(reduceShape);
    const derX = () => {
      const expandedDyShape = x2.shape.slice();
      axes.forEach((axis2) => {
        expandedDyShape[axis2] = 1;
      });
      const expandedDy = reshape(dy, expandedDyShape);
      const res2 = div(mul(expandedDy, ones2(x2.shape, "float32")), reduceSize);
      return res2;
    };
    return { x: derX };
  }
};
var minGradConfig = {
  kernelName: Min,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const minAttrs = attrs;
    const { axis } = minAttrs;
    const [x2, y2] = saved;
    const origAxes = parseAxisParam(axis, x2.shape);
    const minGrad = gradForMinAndMax(dy, y2, x2, origAxes);
    return {
      x: () => {
        return minGrad["x"]();
      }
    };
  }
};
var minimumGradConfig = {
  kernelName: Minimum,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const derA = () => mul(dy, cast(lessEqual(a6, b2), "float32"));
    const derB = () => mul(dy, cast(greater(a6, b2), "float32"));
    return { a: derA, b: derB };
  }
};
var mirrorPadGradConfig = {
  kernelName: MirrorPad,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const x2 = saved[0];
    const { paddings } = attrs;
    const begin = paddings.map((p22) => p22[0]);
    return { x: () => slice(dy, begin, x2.shape) };
  }
};
var modGradConfig = {
  kernelName: Mod,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(dy, reduceAxes), a6.shape);
      }
      return dy;
    };
    const derB = () => {
      const res2 = mul(dy, neg(floor(div(a6, b2))));
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(res2, reduceAxes), b2.shape);
      }
      return res2;
    };
    return { a: derA, b: derB };
  }
};
var multiplyGradConfig = {
  kernelName: Multiply,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      const res2 = mul(dy, cast(b2, "float32"));
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(res2, reduceAxes), a6.shape);
      }
      return res2;
    };
    const derB = () => {
      const res2 = mul(dy, cast(a6, "float32"));
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(res2, reduceAxes), b2.shape);
      }
      return res2;
    };
    return { a: derA, b: derB };
  }
};
var negGradConfig = {
  kernelName: Neg,
  gradFunc: (dy) => {
    return { x: () => neg(dy) };
  }
};
var oneHotGradConfig = {
  kernelName: OneHot,
  inputsToSave: ["indices"],
  gradFunc: (dy, saved) => {
    const indices = saved[0];
    return { indices: () => zeros(indices.shape, "float32") };
  }
};
var onesLikeGradConfig = {
  kernelName: OnesLike,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var packGradConfig = {
  kernelName: Pack,
  saveAllInputs: true,
  gradFunc: (dy, saved, attrs) => {
    const { axis } = attrs;
    const derTensors = unstack(dy, axis);
    return derTensors.map((t2) => () => t2);
  }
};
var padV2GradConfig = {
  kernelName: PadV2,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const x2 = saved[0];
    const { paddings } = attrs;
    const begin = paddings.map((p22) => p22[0]);
    return { x: () => slice(dy, begin, x2.shape) };
  }
};
var powGradConfig = {
  kernelName: Pow,
  inputsToSave: ["a", "b"],
  outputsToSave: [true],
  gradFunc: (dy, saved) => {
    const [a6, b2, y2] = saved;
    const base2 = a6;
    const exp5 = b2;
    const outShape = assertAndGetBroadcastShape(base2.shape, exp5.shape);
    const derBase = () => {
      const expFloat = cast(exp5, "float32");
      let res2 = mul(dy, mul(expFloat, pow(base2, sub(expFloat, scalar(1)))));
      const reduceAxes = getReductionAxes(base2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, base2.shape);
    };
    const derExp = () => {
      const condition = greater(base2, 0);
      const logBase = where(condition, log5(base2), zerosLike(base2));
      let res2 = mul(dy, mul(y2, logBase));
      const reduceAxes = getReductionAxes(exp5.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, exp5.shape);
    };
    return { a: derBase, b: derExp };
  }
};
var preluGradConfig = {
  kernelName: Prelu,
  inputsToSave: ["x", "alpha"],
  gradFunc: (dy, saved) => {
    const [x2, alpha] = saved;
    const mask = greater(x2, 0);
    return {
      x: () => where(mask, dy, mul(dy, alpha)),
      alpha: () => {
        let res2 = where(mask, zerosLike(dy), mul(dy, x2));
        const reduceAxes = getReductionAxes(alpha.shape, dy.shape);
        if (reduceAxes.length > 0) {
          res2 = sum2(res2, reduceAxes);
        }
        return reshape(res2, alpha.shape);
      }
    };
  }
};
var divGradConfig = {
  kernelName: RealDiv,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      const res2 = div(dy, cast(b2, "float32"));
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        return reshape(sum2(res2, reduceAxes), a6.shape);
      }
      return res2;
    };
    const derB = () => {
      let res2 = mul(dy, cast(a6, "float32"));
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = reshape(sum2(res2, reduceAxes), b2.shape);
      }
      const tmp2 = square(b2);
      return neg(div(res2, cast(tmp2, "float32")));
    };
    return { a: derA, b: derB };
  }
};
var reciprocalGradConfig = {
  kernelName: Reciprocal,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, neg(square(x2))) };
  }
};
var relu6GradConfig = {
  kernelName: Relu6,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    const mask = mul(lessEqual(x2, 6), step(x2));
    return { x: () => mul(dy, cast(mask, "float32")) };
  }
};
var reluGradConfig = {
  kernelName: Relu,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(dy, cast(step(x2), "float32")) };
  }
};
var reshapeGradConfig = {
  kernelName: Reshape,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => reshape(dy, x2.shape) };
  }
};
var resizeBilinearGradConfig = {
  kernelName: ResizeBilinear,
  inputsToSave: ["images"],
  gradFunc: (dy, saved, attrs) => {
    const [images] = saved;
    const inputs = { dy, images };
    const imagesDer = () => ENGINE.runKernel(ResizeBilinearGrad, inputs, attrs);
    return { images: imagesDer };
  }
};
var resizeNearestNeighborGradConfig = {
  kernelName: ResizeNearestNeighbor,
  inputsToSave: ["images"],
  gradFunc: (dy, saved, attrs) => {
    const [images] = saved;
    const inputs = { dy, images };
    const imagesDer = () => ENGINE.runKernel(ResizeNearestNeighborGrad, inputs, attrs);
    return { images: imagesDer };
  }
};
var reverseGradConfig = {
  kernelName: Reverse,
  gradFunc: (dy, saved, attrs) => {
    const { dims } = attrs;
    const axes = parseAxisParam(dims, dy.shape);
    return { x: () => reverse(dy, axes) };
  }
};
var roundGradConfig = {
  kernelName: Round,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var rsqrtGradConfig = {
  kernelName: Rsqrt,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => neg(div(dy, mul(pow(x2, 1.5), 2))) };
  }
};
var selectGradConfig = {
  kernelName: Select,
  inputsToSave: ["condition"],
  gradFunc: (dy, saved) => {
    const [condition] = saved;
    return {
      condition: () => cast(zerosLike(condition), "float32"),
      t: () => mul(dy, cast(condition, dy.dtype)),
      e: () => mul(dy, cast(logicalNot(condition), dy.dtype))
    };
  }
};
var seluGradConfig = {
  kernelName: Selu,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return {
      x: () => {
        const mask = greater(x2, scalar(0));
        const scaleAlpha2 = scalar(SELU_SCALEALPHA);
        const scale22 = scalar(SELU_SCALE);
        const greaterThanZeroDer = mul(dy, scale22);
        const lessEqualZeroDer = mul(mul(dy, scaleAlpha2), exp(cast(x2, "float32")));
        return where(mask, greaterThanZeroDer, lessEqualZeroDer);
      }
    };
  }
};
var sigmoidGradConfig = {
  kernelName: Sigmoid,
  outputsToSave: [true],
  gradFunc: (dy, saved) => {
    const [y2] = saved;
    return { x: () => mul(dy, mul(y2, sub(scalar(1), y2))) };
  }
};
var signGradConfig = {
  kernelName: Sign,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var sinGradConfig = {
  kernelName: Sin,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(cos(cast(x2, "float32")), dy) };
  }
};
var sinhGradConfig = {
  kernelName: Sinh,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(cosh(cast(x2, "float32")), dy) };
  }
};
var sliceGradConfig = {
  kernelName: Slice,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { begin, size: size2 } = attrs;
    const inputShape = x2.shape;
    const [begin_, size_] = parseSliceParams(x2, begin, size2);
    const paddings = [];
    for (let i2 = 0; i2 < dy.rank; i2++) {
      paddings.push([begin_[i2], inputShape[i2] - begin_[i2] - size_[i2]]);
    }
    return { x: () => pad(dy, paddings) };
  }
};
var softmaxGradConfig = {
  kernelName: Softmax,
  outputsToSave: [true],
  gradFunc: (dy, saved, attrs) => {
    const [y2] = saved;
    const { dim } = attrs;
    const keepDims = true;
    const dyTimesY = mul(dy, y2);
    return {
      logits: () => sub(dyTimesY, mul(sum2(dyTimesY, [dim], keepDims), y2))
    };
  }
};
var softplusGradConfig = {
  kernelName: Softplus,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(dy, sigmoid(x2)) };
  }
};
var spaceToBatchNDGradConfig = {
  kernelName: SpaceToBatchND,
  gradFunc: (dy, saved, attrs) => {
    const { blockShape, paddings } = attrs;
    return { x: () => batchToSpaceND(dy, blockShape, paddings) };
  }
};
var splitVGradConfig = {
  kernelName: SplitV,
  gradFunc: (dy, saved, attrs) => {
    const { axis } = attrs;
    return { x: () => concat(dy, axis) };
  }
};
var sqrtGradConfig = {
  kernelName: Sqrt,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, mul(sqrt(cast(x2, "float32")), 2)) };
  }
};
var squareGradConfig = {
  kernelName: Square,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => mul(dy, mul(cast(x2, "float32"), 2)) };
  }
};
var squaredDifferenceGradConfig = {
  kernelName: SquaredDifference,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const two = scalar(2);
    const derA = () => mul(dy, mul(two, sub(a6, b2)));
    const derB = () => mul(dy, mul(two, sub(b2, a6)));
    return { a: derA, b: derB };
  }
};
var stepGradConfig = {
  kernelName: Step,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var subGradConfig = {
  kernelName: Sub,
  inputsToSave: ["a", "b"],
  gradFunc: (dy, saved) => {
    const [a6, b2] = saved;
    const outShape = assertAndGetBroadcastShape(a6.shape, b2.shape);
    const derA = () => {
      let res2 = dy;
      const reduceAxes = getReductionAxes(a6.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(res2, a6.shape);
    };
    const derB = () => {
      let res2 = dy;
      const reduceAxes = getReductionAxes(b2.shape, outShape);
      if (reduceAxes.length > 0) {
        res2 = sum2(res2, reduceAxes);
      }
      return reshape(neg(res2), b2.shape);
    };
    return { a: derA, b: derB };
  }
};
var sumGradConfig = {
  kernelName: Sum,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const expandedDyShape = x2.shape.slice();
    const { axis } = attrs;
    const axes = parseAxisParam(axis, x2.shape);
    axes.forEach((axis2) => {
      expandedDyShape[axis2] = 1;
    });
    const expandedDy = reshape(dy, expandedDyShape);
    const derX = mul(expandedDy, ones2(x2.shape, "float32"));
    return { x: () => derX };
  }
};
var tanGradConfig = {
  kernelName: Tan,
  inputsToSave: ["x"],
  gradFunc: (dy, saved) => {
    const [x2] = saved;
    return { x: () => div(dy, square(cos(x2))) };
  }
};
var tanhGradConfig = {
  kernelName: Tanh,
  outputsToSave: [true],
  gradFunc: (dy, saved) => {
    const [y2] = saved;
    return { x: () => mul(sub(scalar(1), square(y2)), dy) };
  }
};
var tileGradConfig = {
  kernelName: Tile,
  inputsToSave: ["x"],
  gradFunc: (dy, saved, attrs) => {
    const [x2] = saved;
    const { reps } = attrs;
    const derX = () => {
      let xGrad = zerosLike(x2);
      if (x2.rank === 1) {
        for (let i2 = 0; i2 < reps[0]; ++i2) {
          xGrad = add2(xGrad, slice(dy, [i2 * x2.shape[0]], [x2.shape[0]]));
        }
      } else if (x2.rank === 2) {
        for (let i2 = 0; i2 < reps[0]; ++i2) {
          for (let j2 = 0; j2 < reps[1]; ++j2) {
            xGrad = add2(xGrad, slice(dy, [i2 * x2.shape[0], j2 * x2.shape[1]], [
              x2.shape[0],
              x2.shape[1]
            ]));
          }
        }
      } else if (x2.rank === 3) {
        for (let i2 = 0; i2 < reps[0]; ++i2) {
          for (let j2 = 0; j2 < reps[1]; ++j2) {
            for (let k3 = 0; k3 < reps[2]; ++k3) {
              xGrad = add2(xGrad, slice(dy, [i2 * x2.shape[0], j2 * x2.shape[1], k3 * x2.shape[2]], [x2.shape[0], x2.shape[1], x2.shape[2]]));
            }
          }
        }
      } else if (x2.rank === 4) {
        for (let i2 = 0; i2 < reps[0]; ++i2) {
          for (let j2 = 0; j2 < reps[1]; ++j2) {
            for (let k3 = 0; k3 < reps[2]; ++k3) {
              for (let l3 = 0; l3 < reps[3]; ++l3) {
                xGrad = add2(xGrad, slice(dy, [
                  i2 * x2.shape[0],
                  j2 * x2.shape[1],
                  k3 * x2.shape[2],
                  l3 * x2.shape[3]
                ], [x2.shape[0], x2.shape[1], x2.shape[2], x2.shape[3]]));
              }
            }
          }
        }
      } else {
        throw new Error(`Gradient for tile operation is not implemented for rank-${x2.rank} tensors yet.`);
      }
      return xGrad;
    };
    return { x: derX };
  }
};
var transposeGradConfig = {
  kernelName: Transpose,
  gradFunc: (dy, saved, attrs) => {
    const transposeAttrs = attrs;
    const { perm } = transposeAttrs;
    const undoPerm = getUndoAxesPermutation(perm);
    return { x: () => transpose(dy, undoPerm) };
  }
};
var unpackGradConfig = {
  kernelName: Unpack,
  gradFunc: (dy, saved, attrs) => {
    const unpackAttrs = attrs;
    const { axis } = unpackAttrs;
    return { value: () => stack(dy, axis) };
  }
};
var unsortedSegmentSumGradConfig = {
  kernelName: UnsortedSegmentSum,
  inputsToSave: ["segmentIds"],
  gradFunc: (dy, saved) => {
    const [segmentIds] = saved;
    const derX = () => {
      return gatherDropNegatives(dy, segmentIds);
    };
    return { x: derX };
  }
};
function gatherDropNegatives(x2, indices) {
  const zeroClippedIndices = maximum(indices, zerosLike(indices));
  const gathered = gather(x2, zeroClippedIndices);
  let isPositive = greaterEqual(indices, scalar(0, "int32"));
  const numIters = gathered.rank - isPositive.rank;
  for (let i2 = 0; i2 < numIters; ++i2) {
    isPositive = expandDims(isPositive, i2 + 1);
  }
  isPositive = logicalAnd(isPositive, ones2(gathered.shape, "bool"));
  const zeroSlice = zerosLike(gathered);
  return where(isPositive, gathered, zeroSlice);
}
var zerosLikeGradConfig = {
  kernelName: ZerosLike,
  gradFunc: (dy) => {
    return { x: () => zerosLike(dy) };
  }
};
var gradConfigs = [
  absGradConfig,
  acosGradConfig,
  acoshGradConfig,
  addGradConfig,
  addNGradConfig,
  argMaxGradConfig,
  argMinGradConfig,
  asinGradConfig,
  asinhGradConfig,
  atan2GradConfig,
  atanGradConfig,
  atanhGradConfig,
  avgPool3DGradConfig,
  avgPoolGradConfig,
  batchMatMulGradConfig,
  batchToSpaceNDGradConfig,
  broadcastToGradConfig,
  castGradConfig,
  ceilGradConfig,
  clipByValueGradConfig,
  complexAbsGradConfig,
  concatGradConfig,
  conv2DBackpropInputGradConfig,
  conv2DGradConfig,
  conv3DGradConfig,
  cosGradConfig,
  coshGradConfig,
  cumsumGradConfig,
  depthwiseConv2dNativeGradConfig,
  dilation2dGradConfig,
  divGradConfig,
  eluGradConfig,
  erfGradConfig,
  expGradConfig,
  expandDimsGradConfig,
  expm1GradConfig,
  floorDivGradConfig,
  floorGradConfig,
  fusedBatchNormGradConfig,
  gatherGradConfig,
  greaterEqualGradConfig,
  identityGradConfig,
  isFiniteGradConfig,
  isInfGradConfig,
  isNanGradConfig,
  leakyReluGradConfig,
  log1pGradConfig,
  logGradConfig,
  logSoftmaxGradConfig,
  lrnGradConfig,
  maxGradConfig,
  maxGradConfig,
  maximumGradConfig,
  maxPool3DGradConfig,
  maxPoolGradConfig,
  meanGradConfig,
  minGradConfig,
  minimumGradConfig,
  mirrorPadGradConfig,
  modGradConfig,
  multiplyGradConfig,
  negGradConfig,
  oneHotGradConfig,
  onesLikeGradConfig,
  packGradConfig,
  padV2GradConfig,
  padV2GradConfig,
  powGradConfig,
  preluGradConfig,
  reciprocalGradConfig,
  relu6GradConfig,
  reluGradConfig,
  reshapeGradConfig,
  resizeBilinearGradConfig,
  resizeNearestNeighborGradConfig,
  reverseGradConfig,
  roundGradConfig,
  rsqrtGradConfig,
  selectGradConfig,
  seluGradConfig,
  sigmoidGradConfig,
  signGradConfig,
  sinGradConfig,
  sinhGradConfig,
  sliceGradConfig,
  softmaxGradConfig,
  softplusGradConfig,
  spaceToBatchNDGradConfig,
  spaceToBatchNDGradConfig,
  splitVGradConfig,
  splitVGradConfig,
  sqrtGradConfig,
  squaredDifferenceGradConfig,
  squareGradConfig,
  stepGradConfig,
  subGradConfig,
  sumGradConfig,
  tanGradConfig,
  tanhGradConfig,
  tileGradConfig,
  transposeGradConfig,
  unpackGradConfig,
  unsortedSegmentSumGradConfig,
  zerosLikeGradConfig
];
for (const gradientConfig of gradConfigs) {
  registerGradient(gradientConfig);
}
getGlobalTensorClass().prototype.abs = function() {
  this.throwIfDisposed();
  return abs(this);
};
getGlobalTensorClass().prototype.acos = function() {
  this.throwIfDisposed();
  return acos(this);
};
getGlobalTensorClass().prototype.acosh = function() {
  this.throwIfDisposed();
  return acosh(this);
};
getGlobalTensorClass().prototype.add = function(b2) {
  this.throwIfDisposed();
  return add2(this, b2);
};
getGlobalTensorClass().prototype.all = function(axis, keepDims) {
  this.throwIfDisposed();
  return all(this, axis, keepDims);
};
getGlobalTensorClass().prototype.any = function(axis, keepDims) {
  this.throwIfDisposed();
  return any(this, axis, keepDims);
};
getGlobalTensorClass().prototype.argMax = function(axis) {
  this.throwIfDisposed();
  return argMax(this, axis);
};
getGlobalTensorClass().prototype.argMin = function(axis) {
  this.throwIfDisposed();
  return argMin(this, axis);
};
getGlobalTensorClass().prototype.asScalar = function() {
  this.throwIfDisposed();
  assert(this.size === 1, () => "The array must have only 1 element.");
  return reshape(this, []);
};
getGlobalTensorClass().prototype.asType = function(dtype) {
  this.throwIfDisposed();
  return cast(this, dtype);
};
getGlobalTensorClass().prototype.as1D = function() {
  this.throwIfDisposed();
  return reshape(this, [this.size]);
};
getGlobalTensorClass().prototype.as2D = function(rows, columns) {
  this.throwIfDisposed();
  return reshape(this, [rows, columns]);
};
getGlobalTensorClass().prototype.as3D = function(rows, columns, depth) {
  this.throwIfDisposed();
  return reshape(this, [rows, columns, depth]);
};
getGlobalTensorClass().prototype.as4D = function(rows, columns, depth, depth2) {
  this.throwIfDisposed();
  return reshape(this, [rows, columns, depth, depth2]);
};
getGlobalTensorClass().prototype.as5D = function(rows, columns, depth, depth2, depth3) {
  this.throwIfDisposed();
  return reshape(this, [rows, columns, depth, depth2, depth3]);
};
getGlobalTensorClass().prototype.asin = function() {
  this.throwIfDisposed();
  return asin(this);
};
getGlobalTensorClass().prototype.asinh = function() {
  this.throwIfDisposed();
  return asinh(this);
};
getGlobalTensorClass().prototype.atan = function() {
  this.throwIfDisposed();
  return atan(this);
};
getGlobalTensorClass().prototype.atan2 = function(b2) {
  this.throwIfDisposed();
  return atan2(this, b2);
};
getGlobalTensorClass().prototype.atanh = function() {
  this.throwIfDisposed();
  return atanh(this);
};
getGlobalTensorClass().prototype.avgPool = function(filterSize, strides, pad3, dimRoundingMode) {
  this.throwIfDisposed();
  return avgPool(this, filterSize, strides, pad3, dimRoundingMode);
};
getGlobalTensorClass().prototype.batchToSpaceND = function(blockShape, crops) {
  this.throwIfDisposed();
  return batchToSpaceND(this, blockShape, crops);
};
getGlobalTensorClass().prototype.batchNorm = function(mean5, variance, offset, scale22, varianceEpsilon) {
  this.throwIfDisposed();
  return batchNorm(this, mean5, variance, offset, scale22, varianceEpsilon);
};
getGlobalTensorClass().prototype.broadcastTo = function(shape) {
  this.throwIfDisposed();
  return broadcastTo(this, shape);
};
getGlobalTensorClass().prototype.cast = function(dtype) {
  this.throwIfDisposed();
  return cast(this, dtype);
};
getGlobalTensorClass().prototype.ceil = function() {
  this.throwIfDisposed();
  return ceil(this);
};
getGlobalTensorClass().prototype.clipByValue = function(min7, max7) {
  this.throwIfDisposed();
  return clipByValue(this, min7, max7);
};
getGlobalTensorClass().prototype.concat = function(x2, axis) {
  this.throwIfDisposed();
  if (x2 instanceof Tensor) {
    x2 = [x2];
  }
  return concat([this, ...x2], axis);
};
getGlobalTensorClass().prototype.conv1d = function(filter, stride, pad3, dataFormat, dilation, dimRoundingMode) {
  this.throwIfDisposed();
  return conv1d(this, filter, stride, pad3, dataFormat, dilation, dimRoundingMode);
};
getGlobalTensorClass().prototype.conv2dTranspose = function(filter, outputShape, strides, pad3, dimRoundingMode) {
  this.throwIfDisposed();
  return conv2dTranspose(this, filter, outputShape, strides, pad3, dimRoundingMode);
};
getGlobalTensorClass().prototype.conv2d = function(filter, strides, pad3, dataFormat, dilations, dimRoundingMode) {
  this.throwIfDisposed();
  return conv2d(this, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
};
getGlobalTensorClass().prototype.cos = function() {
  this.throwIfDisposed();
  return cos(this);
};
getGlobalTensorClass().prototype.cosh = function() {
  this.throwIfDisposed();
  return cosh(this);
};
getGlobalTensorClass().prototype.cumsum = function(axis, exclusive, reverse5) {
  this.throwIfDisposed();
  return cumsum(this, axis, exclusive, reverse5);
};
getGlobalTensorClass().prototype.depthToSpace = function(blockSize, dataFormat) {
  this.throwIfDisposed();
  return depthToSpace(this, blockSize, dataFormat);
};
getGlobalTensorClass().prototype.depthwiseConv2d = function(filter, strides, pad3, dataFormat, dilations, dimRoundingMode) {
  this.throwIfDisposed();
  return depthwiseConv2d(this, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
};
getGlobalTensorClass().prototype.dilation2d = function(filter, strides, pad3, dilations, dataFormat) {
  this.throwIfDisposed();
  return dilation2d(this, filter, strides, pad3, dilations, dataFormat);
};
getGlobalTensorClass().prototype.divNoNan = function(b2) {
  this.throwIfDisposed();
  return divNoNan(this, b2);
};
getGlobalTensorClass().prototype.div = function(b2) {
  this.throwIfDisposed();
  return div(this, b2);
};
getGlobalTensorClass().prototype.dot = function(b2) {
  this.throwIfDisposed();
  return dot(this, b2);
};
getGlobalTensorClass().prototype.elu = function() {
  this.throwIfDisposed();
  return elu(this);
};
getGlobalTensorClass().prototype.equal = function(b2) {
  this.throwIfDisposed();
  return equal(this, b2);
};
getGlobalTensorClass().prototype.erf = function() {
  this.throwIfDisposed();
  return erf(this);
};
getGlobalTensorClass().prototype.exp = function() {
  this.throwIfDisposed();
  return exp(this);
};
getGlobalTensorClass().prototype.expandDims = function(axis) {
  this.throwIfDisposed();
  return expandDims(this, axis);
};
getGlobalTensorClass().prototype.expm1 = function() {
  this.throwIfDisposed();
  return expm1(this);
};
getGlobalTensorClass().prototype.fft = function() {
  this.throwIfDisposed();
  return fft(this);
};
getGlobalTensorClass().prototype.flatten = function() {
  this.throwIfDisposed();
  return reshape(this, [this.size]);
};
getGlobalTensorClass().prototype.floor = function() {
  this.throwIfDisposed();
  return floor(this);
};
getGlobalTensorClass().prototype.floorDiv = function(b2) {
  this.throwIfDisposed();
  return floorDiv(this, b2);
};
getGlobalTensorClass().prototype.gather = function(indices, axis) {
  this.throwIfDisposed();
  return gather(this, indices, axis);
};
getGlobalTensorClass().prototype.greaterEqual = function(b2) {
  this.throwIfDisposed();
  return greaterEqual(this, b2);
};
getGlobalTensorClass().prototype.greater = function(b2) {
  this.throwIfDisposed();
  return greater(this, b2);
};
getGlobalTensorClass().prototype.ifft = function() {
  this.throwIfDisposed();
  return ifft(this);
};
getGlobalTensorClass().prototype.irfft = function() {
  this.throwIfDisposed();
  return irfft(this);
};
getGlobalTensorClass().prototype.isFinite = function() {
  this.throwIfDisposed();
  return isFinite2(this);
};
getGlobalTensorClass().prototype.isInf = function() {
  this.throwIfDisposed();
  return isInf(this);
};
getGlobalTensorClass().prototype.isNaN = function() {
  this.throwIfDisposed();
  return isNaN2(this);
};
getGlobalTensorClass().prototype.leakyRelu = function(alpha) {
  this.throwIfDisposed();
  return leakyRelu(this, alpha);
};
getGlobalTensorClass().prototype.lessEqual = function(b2) {
  this.throwIfDisposed();
  return lessEqual(this, b2);
};
getGlobalTensorClass().prototype.less = function(b2) {
  this.throwIfDisposed();
  return less(this, b2);
};
getGlobalTensorClass().prototype.localResponseNormalization = function(depthRadius, bias, alpha, beta) {
  this.throwIfDisposed();
  return localResponseNormalization(this, depthRadius, bias, alpha, beta);
};
getGlobalTensorClass().prototype.logSigmoid = function() {
  this.throwIfDisposed();
  return logSigmoid(this);
};
getGlobalTensorClass().prototype.logSoftmax = function(axis) {
  this.throwIfDisposed();
  return logSoftmax(this, axis);
};
getGlobalTensorClass().prototype.logSumExp = function(axis, keepDims) {
  this.throwIfDisposed();
  return logSumExp(this, axis, keepDims);
};
getGlobalTensorClass().prototype.log = function() {
  this.throwIfDisposed();
  return log5(this);
};
getGlobalTensorClass().prototype.log1p = function() {
  this.throwIfDisposed();
  return log1p(this);
};
getGlobalTensorClass().prototype.logicalAnd = function(b2) {
  this.throwIfDisposed();
  return logicalAnd(this, b2);
};
getGlobalTensorClass().prototype.logicalNot = function() {
  this.throwIfDisposed();
  return logicalNot(this);
};
getGlobalTensorClass().prototype.logicalOr = function(b2) {
  this.throwIfDisposed();
  return logicalOr(this, b2);
};
getGlobalTensorClass().prototype.logicalXor = function(b2) {
  this.throwIfDisposed();
  return logicalXor(this, b2);
};
getGlobalTensorClass().prototype.matMul = function(b2, transposeA, transposeB) {
  this.throwIfDisposed();
  return matMul(this, b2, transposeA, transposeB);
};
getGlobalTensorClass().prototype.maxPool = function(filterSize, strides, pad3, dimRoundingMode) {
  this.throwIfDisposed();
  return maxPool(this, filterSize, strides, pad3, dimRoundingMode);
};
getGlobalTensorClass().prototype.max = function(axis, keepDims) {
  this.throwIfDisposed();
  return max(this, axis, keepDims);
};
getGlobalTensorClass().prototype.maximum = function(b2) {
  this.throwIfDisposed();
  return maximum(this, b2);
};
getGlobalTensorClass().prototype.mean = function(axis, keepDims) {
  this.throwIfDisposed();
  return mean(this, axis, keepDims);
};
getGlobalTensorClass().prototype.min = function(axis, keepDims) {
  this.throwIfDisposed();
  return min(this, axis, keepDims);
};
getGlobalTensorClass().prototype.minimum = function(b2) {
  this.throwIfDisposed();
  return minimum(this, b2);
};
getGlobalTensorClass().prototype.mirrorPad = function(paddings, mode) {
  this.throwIfDisposed();
  return mirrorPad(this, paddings, mode);
};
getGlobalTensorClass().prototype.mod = function(b2) {
  this.throwIfDisposed();
  return mod(this, b2);
};
getGlobalTensorClass().prototype.mul = function(b2) {
  this.throwIfDisposed();
  return mul(this, b2);
};
getGlobalTensorClass().prototype.neg = function() {
  this.throwIfDisposed();
  return neg(this);
};
getGlobalTensorClass().prototype.norm = function(ord, axis, keepDims) {
  this.throwIfDisposed();
  return norm(this, ord, axis, keepDims);
};
getGlobalTensorClass().prototype.notEqual = function(b2) {
  this.throwIfDisposed();
  return notEqual(this, b2);
};
getGlobalTensorClass().prototype.oneHot = function(depth, onValue = 1, offValue = 0) {
  this.throwIfDisposed();
  return oneHot(this, depth, onValue, offValue);
};
getGlobalTensorClass().prototype.onesLike = function() {
  this.throwIfDisposed();
  return onesLike(this);
};
getGlobalTensorClass().prototype.pad = function(paddings, constantValue) {
  this.throwIfDisposed();
  return pad(this, paddings, constantValue);
};
getGlobalTensorClass().prototype.pool = function(windowShape, poolingType, padding2, dilationRate, strides) {
  this.throwIfDisposed();
  return pool(this, windowShape, poolingType, padding2, dilationRate, strides);
};
getGlobalTensorClass().prototype.pow = function(exp5) {
  this.throwIfDisposed();
  return pow(this, exp5);
};
getGlobalTensorClass().prototype.prelu = function(alpha) {
  this.throwIfDisposed();
  return prelu(this, alpha);
};
getGlobalTensorClass().prototype.prod = function(axis, keepDims) {
  this.throwIfDisposed();
  return prod(this, axis, keepDims);
};
getGlobalTensorClass().prototype.reciprocal = function() {
  this.throwIfDisposed();
  return reciprocal(this);
};
getGlobalTensorClass().prototype.relu = function() {
  this.throwIfDisposed();
  return relu(this);
};
getGlobalTensorClass().prototype.relu6 = function() {
  this.throwIfDisposed();
  return relu6(this);
};
getGlobalTensorClass().prototype.reshapeAs = function(x2) {
  this.throwIfDisposed();
  return reshape(this, x2.shape);
};
getGlobalTensorClass().prototype.reshape = function(shape) {
  this.throwIfDisposed();
  return reshape(this, shape);
};
getGlobalTensorClass().prototype.resizeBilinear = function(newShape2D, alignCorners, halfPixelCenters) {
  this.throwIfDisposed();
  return resizeBilinear(this, newShape2D, alignCorners, halfPixelCenters);
};
getGlobalTensorClass().prototype.resizeNearestNeighbor = function(newShape2D, alignCorners, halfFloatCenters) {
  this.throwIfDisposed();
  return resizeNearestNeighbor(this, newShape2D, alignCorners, halfFloatCenters);
};
getGlobalTensorClass().prototype.reverse = function(axis) {
  this.throwIfDisposed();
  return reverse(this, axis);
};
getGlobalTensorClass().prototype.rfft = function() {
  this.throwIfDisposed();
  return rfft(this);
};
getGlobalTensorClass().prototype.round = function() {
  this.throwIfDisposed();
  return round2(this);
};
getGlobalTensorClass().prototype.rsqrt = function() {
  this.throwIfDisposed();
  return rsqrt(this);
};
getGlobalTensorClass().prototype.selu = function() {
  this.throwIfDisposed();
  return selu(this);
};
getGlobalTensorClass().prototype.separableConv2d = function(depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat) {
  this.throwIfDisposed();
  return separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat);
};
getGlobalTensorClass().prototype.sigmoid = function() {
  this.throwIfDisposed();
  return sigmoid(this);
};
getGlobalTensorClass().prototype.sign = function() {
  this.throwIfDisposed();
  return sign2(this);
};
getGlobalTensorClass().prototype.sin = function() {
  this.throwIfDisposed();
  return sin(this);
};
getGlobalTensorClass().prototype.sinh = function() {
  this.throwIfDisposed();
  return sinh(this);
};
getGlobalTensorClass().prototype.slice = function(begin, size2) {
  this.throwIfDisposed();
  return slice(this, begin, size2);
};
getGlobalTensorClass().prototype.softmax = function(dim) {
  this.throwIfDisposed();
  return softmax(this, dim);
};
getGlobalTensorClass().prototype.softplus = function() {
  this.throwIfDisposed();
  return softplus(this);
};
getGlobalTensorClass().prototype.spaceToBatchND = function(blockShape, paddings) {
  this.throwIfDisposed();
  return spaceToBatchND(this, blockShape, paddings);
};
getGlobalTensorClass().prototype.split = function(numOrSizeSplits, axis) {
  this.throwIfDisposed();
  return split(this, numOrSizeSplits, axis);
};
getGlobalTensorClass().prototype.sqrt = function() {
  this.throwIfDisposed();
  return sqrt(this);
};
getGlobalTensorClass().prototype.square = function() {
  this.throwIfDisposed();
  return square(this);
};
getGlobalTensorClass().prototype.squaredDifference = function(b2) {
  this.throwIfDisposed();
  return squaredDifference(this, b2);
};
getGlobalTensorClass().prototype.squeeze = function(axis) {
  this.throwIfDisposed();
  return squeeze(this, axis);
};
getGlobalTensorClass().prototype.stack = function(x2, axis) {
  this.throwIfDisposed();
  const tensorsToBeStacked = x2 instanceof Tensor ? [this, x2] : [this, ...x2];
  return stack(tensorsToBeStacked, axis);
};
getGlobalTensorClass().prototype.step = function(alpha) {
  this.throwIfDisposed();
  return step(this, alpha);
};
getGlobalTensorClass().prototype.stridedSlice = function(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
  this.throwIfDisposed();
  return stridedSlice(this, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
};
getGlobalTensorClass().prototype.sub = function(b2) {
  this.throwIfDisposed();
  return sub(this, b2);
};
getGlobalTensorClass().prototype.sum = function(axis, keepDims) {
  this.throwIfDisposed();
  return sum2(this, axis, keepDims);
};
getGlobalTensorClass().prototype.tan = function() {
  this.throwIfDisposed();
  return tan(this);
};
getGlobalTensorClass().prototype.tanh = function() {
  this.throwIfDisposed();
  return tanh2(this);
};
getGlobalTensorClass().prototype.tile = function(reps) {
  this.throwIfDisposed();
  return tile(this, reps);
};
getGlobalTensorClass().prototype.toBool = function() {
  this.throwIfDisposed();
  return cast(this, "bool");
};
getGlobalTensorClass().prototype.toFloat = function() {
  this.throwIfDisposed();
  return cast(this, "float32");
};
getGlobalTensorClass().prototype.toInt = function() {
  this.throwIfDisposed();
  return cast(this, "int32");
};
getGlobalTensorClass().prototype.topk = function(k3, sorted) {
  this.throwIfDisposed();
  return topk(this, k3, sorted);
};
getGlobalTensorClass().prototype.transpose = function(perm) {
  this.throwIfDisposed();
  return transpose(this, perm);
};
getGlobalTensorClass().prototype.unique = function(axis) {
  this.throwIfDisposed();
  return unique(this, axis);
};
getGlobalTensorClass().prototype.unsortedSegmentSum = function(segmentIds, numSegments) {
  this.throwIfDisposed();
  return unsortedSegmentSum(this, segmentIds, numSegments);
};
getGlobalTensorClass().prototype.unstack = function(axis) {
  this.throwIfDisposed();
  return unstack(this, axis);
};
getGlobalTensorClass().prototype.where = function(condition, x2) {
  this.throwIfDisposed();
  return where(condition, this, x2);
};
getGlobalTensorClass().prototype.zerosLike = function() {
  this.throwIfDisposed();
  return zerosLike(this);
};
var exports_constraints_exports = {};
__export2(exports_constraints_exports, {
  maxNorm: () => maxNorm,
  minMaxNorm: () => minMaxNorm,
  nonNeg: () => nonNeg,
  unitNorm: () => unitNorm
});
var _epsilon;
function epsilon() {
  if (_epsilon == null) {
    _epsilon = backend().epsilon();
  }
  return _epsilon;
}
function imageDataFormat() {
  return "channelsLast";
}
var AttributeError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, AttributeError.prototype);
  }
};
var RuntimeError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, RuntimeError.prototype);
  }
};
var ValueError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, ValueError.prototype);
  }
};
var NotImplementedError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, NotImplementedError.prototype);
  }
};
var AssertionError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, AssertionError.prototype);
  }
};
function pyListRepeat(value, numValues) {
  if (Array.isArray(value)) {
    let newArray = [];
    for (let i2 = 0; i2 < numValues; i2++) {
      newArray = newArray.concat(value);
    }
    return newArray;
  } else {
    const newArray = new Array(numValues);
    newArray.fill(value);
    return newArray;
  }
}
function assert2(val, message) {
  if (!val) {
    throw new AssertionError(message);
  }
}
function count(array2, refernce) {
  let counter = 0;
  for (const item of array2) {
    if (item === refernce) {
      counter++;
    }
  }
  return counter;
}
function singletonOrArray(xs) {
  if (xs.length === 1) {
    return xs[0];
  }
  return xs;
}
function toList(x2) {
  if (Array.isArray(x2)) {
    return x2;
  }
  return [x2];
}
function toSnakeCase(name) {
  const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2");
  const insecure = intermediate.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  if (insecure[0] !== "_") {
    return insecure;
  }
  return "private" + insecure;
}
function toCamelCase(identifier) {
  if (identifier.length <= 1) {
    return identifier;
  }
  if (identifier.indexOf("_") === -1) {
    return identifier;
  }
  return identifier.replace(/[_]+(\w|$)/g, (m2, p1) => p1.toUpperCase());
}
var _GLOBAL_CUSTOM_OBJECTS = {};
function serializeKerasObject(instance) {
  if (instance === null || instance === void 0) {
    return null;
  }
  const dict = {};
  dict["className"] = instance.getClassName();
  dict["config"] = instance.getConfig();
  return dict;
}
function convertNDArrayScalarsInConfig(config3) {
  if (config3 == null || typeof config3 !== "object") {
    return;
  } else if (Array.isArray(config3)) {
    config3.forEach((configItem) => convertNDArrayScalarsInConfig(configItem));
  } else {
    const fields = Object.keys(config3);
    for (const field of fields) {
      const value = config3[field];
      if (value != null && typeof value === "object") {
        if (!Array.isArray(value) && value["type"] === "ndarray" && typeof value["value"] === "number") {
          config3[field] = value["value"];
        } else {
          convertNDArrayScalarsInConfig(value);
        }
      }
    }
  }
}
function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = "object", fastWeightInit = false) {
  if (typeof identifier === "string") {
    const functionName = identifier;
    let fn;
    if (functionName in customObjects) {
      fn = customObjects[functionName];
    } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
      fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
    } else {
      fn = moduleObjects[functionName];
      if (fn == null) {
        throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      }
    }
    return fn;
  } else {
    const config3 = identifier;
    if (config3["className"] == null || config3["config"] == null) {
      throw new ValueError(`${printableModuleName}: Improper config format: ${JSON.stringify(config3)}.
'className' and 'config' must set.`);
    }
    const className = config3["className"];
    let cls, fromConfig;
    if (className in customObjects) {
      [cls, fromConfig] = customObjects[className];
    } else if (className in _GLOBAL_CUSTOM_OBJECTS) {
      [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS["className"];
    } else if (className in moduleObjects) {
      [cls, fromConfig] = moduleObjects[className];
    }
    if (cls == null) {
      throw new ValueError(`Unknown ${printableModuleName}: ${className}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    }
    if (fromConfig != null) {
      const customObjectsCombined = {};
      for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {
        customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
      }
      for (const key of Object.keys(customObjects)) {
        customObjectsCombined[key] = customObjects[key];
      }
      const nestedConfig = config3["config"];
      nestedConfig["customObjects"] = customObjectsCombined;
      const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
      for (const key of Object.keys(customObjects)) {
        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
      }
      convertNDArrayScalarsInConfig(config3["config"]);
      const returnObj = fromConfig(cls, config3["config"], customObjects, fastWeightInit);
      _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
      return returnObj;
    } else {
      const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
      for (const key of Object.keys(customObjects)) {
        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
      }
      const returnObj = new cls(config3["config"]);
      _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
      return returnObj;
    }
  }
}
function numberCompare(a6, b2) {
  return a6 < b2 ? -1 : a6 > b2 ? 1 : 0;
}
function reverseNumberCompare(a6, b2) {
  return -1 * numberCompare(a6, b2);
}
function unique2(xs) {
  if (xs == null) {
    return xs;
  }
  const out = [];
  for (const x2 of xs) {
    if (out.indexOf(x2) === -1) {
      out.push(x2);
    }
  }
  return out;
}
function isObjectEmpty(obj) {
  if (obj == null) {
    throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function checkStringTypeUnionValue(values, label, value) {
  if (value == null) {
    return;
  }
  if (values.indexOf(value) < 0) {
    throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`);
  }
}
function checkArrayTypeAndLength(x2, expectedType, minLength = 0, maxLength = Infinity) {
  assert2(minLength >= 0);
  assert2(maxLength >= minLength);
  return Array.isArray(x2) && x2.length >= minLength && x2.length <= maxLength && x2.every((e2) => typeof e2 === expectedType);
}
function assertPositiveInteger(value, name) {
  if (Array.isArray(value)) {
    util_exports.assert(value.length > 0, () => `${name} is unexpectedly an empty array.`);
    value.forEach((v2, i2) => assertPositiveInteger(v2, `element ${i2 + 1} of ${name}`));
  } else {
    util_exports.assert(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ${formatAsFriendlyString(value)}.`);
  }
}
function formatAsFriendlyString(value) {
  if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "[" + value.map((v2) => formatAsFriendlyString(v2)).join(",") + "]";
  } else if (typeof value === "string") {
    return `"${value}"`;
  } else {
    return `${value}`;
  }
}
function debounce(f2, waitMs) {
  let lastTime = util_exports.now();
  let lastResult;
  const f22 = (...args) => {
    const now222 = util_exports.now();
    if (now222 - lastTime < waitMs) {
      return lastResult;
    }
    lastTime = now222;
    lastResult = f2(...args);
    return lastResult;
  };
  return f22;
}
function mapActivationToFusedKernel(activationName) {
  if (activationName === "relu") {
    return "relu";
  }
  if (activationName === "linear") {
    return "linear";
  }
  if (activationName === "elu") {
    return "elu";
  }
  return null;
}
function calcL2Norms(w2, axis) {
  return tidy(() => sqrt(sum2(mul(w2, w2), axis, true)));
}
var Constraint = class extends serialization_exports.Serializable {
  getConfig() {
    return {};
  }
};
var MaxNorm = class extends Constraint {
  constructor(args) {
    super();
    this.defaultMaxValue = 2;
    this.defaultAxis = 0;
    this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
    this.axis = args.axis != null ? args.axis : this.defaultAxis;
  }
  apply(w2) {
    return tidy(() => {
      const norms = calcL2Norms(w2, this.axis);
      const desired = clipByValue(norms, 0, this.maxValue);
      return mul(w2, div(desired, add2(epsilon(), norms)));
    });
  }
  getConfig() {
    return { maxValue: this.maxValue, axis: this.axis };
  }
};
MaxNorm.className = "MaxNorm";
serialization_exports.registerClass(MaxNorm);
var UnitNorm = class extends Constraint {
  constructor(args) {
    super();
    this.defaultAxis = 0;
    this.axis = args.axis != null ? args.axis : this.defaultAxis;
  }
  apply(w2) {
    return tidy(() => div(w2, add2(epsilon(), calcL2Norms(w2, this.axis))));
  }
  getConfig() {
    return { axis: this.axis };
  }
};
UnitNorm.className = "UnitNorm";
serialization_exports.registerClass(UnitNorm);
var NonNeg = class extends Constraint {
  apply(w2) {
    return relu(w2);
  }
};
NonNeg.className = "NonNeg";
serialization_exports.registerClass(NonNeg);
var MinMaxNorm = class extends Constraint {
  constructor(args) {
    super();
    this.defaultMinValue = 0;
    this.defaultMaxValue = 1;
    this.defaultRate = 1;
    this.defaultAxis = 0;
    this.minValue = args.minValue != null ? args.minValue : this.defaultMinValue;
    this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
    this.rate = args.rate != null ? args.rate : this.defaultRate;
    this.axis = args.axis != null ? args.axis : this.defaultAxis;
  }
  apply(w2) {
    return tidy(() => {
      const norms = calcL2Norms(w2, this.axis);
      const desired = add2(mul(this.rate, clipByValue(norms, this.minValue, this.maxValue)), mul(1 - this.rate, norms));
      return mul(w2, div(desired, add2(epsilon(), norms)));
    });
  }
  getConfig() {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }
};
MinMaxNorm.className = "MinMaxNorm";
serialization_exports.registerClass(MinMaxNorm);
var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  "maxNorm": "MaxNorm",
  "minMaxNorm": "MinMaxNorm",
  "nonNeg": "NonNeg",
  "unitNorm": "UnitNorm"
};
function serializeConstraint(constraint) {
  return serializeKerasObject(constraint);
}
function deserializeConstraint(config3, customObjects = {}) {
  return deserializeKerasObject(config3, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "constraint");
}
function getConstraint(identifier) {
  if (identifier == null) {
    return null;
  }
  if (typeof identifier === "string") {
    const className = identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    const config3 = { className, config: {} };
    return deserializeConstraint(config3);
  } else if (identifier instanceof Constraint) {
    return identifier;
  } else {
    return deserializeConstraint(identifier);
  }
}
function maxNorm(args) {
  return new MaxNorm(args);
}
function unitNorm(args) {
  return new UnitNorm(args);
}
function nonNeg() {
  return new NonNeg();
}
function minMaxNorm(config3) {
  return new MinMaxNorm(config3);
}
var exports_initializers_exports = {};
__export2(exports_initializers_exports, {
  constant: () => constant,
  glorotNormal: () => glorotNormal,
  glorotUniform: () => glorotUniform,
  heNormal: () => heNormal,
  heUniform: () => heUniform,
  identity: () => identity,
  leCunNormal: () => leCunNormal,
  leCunUniform: () => leCunUniform,
  ones: () => ones3,
  orthogonal: () => orthogonal,
  randomNormal: () => randomNormal3,
  randomUniform: () => randomUniform2,
  truncatedNormal: () => truncatedNormal2,
  varianceScaling: () => varianceScaling,
  zeros: () => zeros2
});
var VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];
var VALID_INTERPOLATION_FORMAT_VALUES = ["nearest", "bilinear"];
var VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];
var VALID_POOL_MODE_VALUES = ["max", "avg"];
var VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];
var nameMap = new Map();
function checkDataFormat(value) {
  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", value);
}
function checkInterpolationFormat(value) {
  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, "InterpolationFormat", value);
}
function checkPaddingMode(value) {
  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", value);
}
function checkPoolMode(value) {
  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", value);
}
var _nameScopeStack = [];
var _nameScopeDivider = "/";
function nameScope(name, fn) {
  _nameScopeStack.push(name);
  try {
    const val = fn();
    _nameScopeStack.pop();
    return val;
  } catch (e2) {
    _nameScopeStack.pop();
    throw e2;
  }
}
function currentNameScopePrefix() {
  if (_nameScopeStack.length === 0) {
    return "";
  } else {
    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
  }
}
function getScopedTensorName(tensorName) {
  if (!isValidTensorName(tensorName)) {
    throw new Error("Not a valid tensor name: '" + tensorName + "'");
  }
  return currentNameScopePrefix() + tensorName;
}
function getUniqueTensorName(scopedName) {
  if (!isValidTensorName(scopedName)) {
    throw new Error("Not a valid tensor name: '" + scopedName + "'");
  }
  if (!nameMap.has(scopedName)) {
    nameMap.set(scopedName, 0);
  }
  const index = nameMap.get(scopedName);
  nameMap.set(scopedName, nameMap.get(scopedName) + 1);
  if (index > 0) {
    const result = `${scopedName}_${index}`;
    nameMap.set(result, 1);
    return result;
  } else {
    return scopedName;
  }
}
var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
function isValidTensorName(name) {
  return !!name.match(tensorNameRegex);
}
function isInteger(x2) {
  return x2 === parseInt(x2.toString(), 10);
}
function arrayProd(array2, begin, end) {
  if (begin == null) {
    begin = 0;
  }
  if (end == null) {
    end = array2.length;
  }
  let prod6 = 1;
  for (let i2 = begin; i2 < end; ++i2) {
    prod6 *= array2[i2];
  }
  return prod6;
}
function min2(array2) {
  if (array2.length === 0) {
    return Number.NaN;
  }
  let min7 = Number.POSITIVE_INFINITY;
  for (let i2 = 0; i2 < array2.length; i2++) {
    const value = array2[i2];
    if (value < min7) {
      min7 = value;
    }
  }
  return min7;
}
function max2(array2) {
  if (array2.length === 0) {
    return Number.NaN;
  }
  let max7 = Number.NEGATIVE_INFINITY;
  for (let i2 = 0; i2 < array2.length; i2++) {
    const value = array2[i2];
    if (value > max7) {
      max7 = value;
    }
  }
  return max7;
}
function range2(begin, end) {
  if (end < begin) {
    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);
  }
  const out = [];
  for (let i2 = begin; i2 < end; ++i2) {
    out.push(i2);
  }
  return out;
}
function cast2(x2, dtype) {
  return cast(x2, dtype);
}
function expandDims2(x2, axis = -1) {
  const outShape = x2.shape.slice();
  if (axis < 0) {
    axis = outShape.length + axis + 1;
  }
  outShape.splice(axis, 0, 1);
  return reshape(x2, outShape);
}
function repeat(x2, n2) {
  return tidy(() => {
    if (x2.shape.length !== 2) {
      throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${x2.shape.length} tensor.`);
    }
    const y2 = expandDims2(x2, 1);
    return tile2(y2, [1, n2, 1]);
  });
}
function flatten22(x2) {
  const newShape = [arrayProd(x2.shape)];
  return reshape(x2, newShape);
}
function batchFlatten(x2) {
  if (x2.rank <= 1) {
    throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x2.rank}.`);
  }
  const newShape = [x2.shape[0], arrayProd(x2.shape, 1)];
  return reshape(x2, newShape);
}
function sliceAlongFirstAxis(array2, start, size2) {
  return tidy(() => {
    switch (array2.rank) {
      case 1:
        return slice1d(array2, start, size2);
      case 2:
        return slice2d(array2, [start, 0], [size2, array2.shape[1]]);
      case 3:
        return slice3d(array2, [start, 0, 0], [size2, array2.shape[1], array2.shape[2]]);
      case 4:
        return slice4d(array2, [start, 0, 0, 0], [size2, array2.shape[1], array2.shape[2], array2.shape[3]]);
      case 5:
        return slice(array2, [start, 0, 0, 0, 0], [
          size2,
          array2.shape[1],
          array2.shape[2],
          array2.shape[3],
          array2.shape[4]
        ]);
      case 6:
        return slice(array2, [start, 0, 0, 0, 0, 0], [
          size2,
          array2.shape[1],
          array2.shape[2],
          array2.shape[3],
          array2.shape[4],
          array2.shape[5]
        ]);
      default:
        throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${array2.rank}`);
    }
  });
}
function sliceAlongLastAxis(array2, start, size2) {
  return tidy(() => {
    switch (array2.rank) {
      case 1:
        return slice1d(array2, start, size2);
      case 2:
        return slice2d(array2, [0, start], [array2.shape[0], size2]);
      case 3:
        return slice3d(array2, [0, 0, start], [array2.shape[0], array2.shape[1], size2]);
      case 4:
        return slice4d(array2, [0, 0, 0, start], [array2.shape[0], array2.shape[1], array2.shape[2], size2]);
      default:
        throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
    }
  });
}
function sliceAlongAxis(array2, start, size2, axis) {
  return tidy(() => {
    switch (array2.rank) {
      case 1:
        return slice1d(array2, start, size2);
      case 2:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array2, start, size2);
          case 2:
            return sliceAlongLastAxis(array2, start, size2);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
        }
      case 3:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array2, start, size2);
          case 2:
            return slice3d(array2, [0, start, 0], [array2.shape[0], size2, array2.shape[2]]);
          case 3:
            return sliceAlongLastAxis(array2, start, size2);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
        }
      case 4:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array2, start, size2);
          case 2:
            return slice4d(array2, [0, start, 0, 0], [array2.shape[0], size2, array2.shape[2], array2.shape[3]]);
          case 3:
            return slice4d(array2, [0, 0, start, 0], [array2.shape[0], array2.shape[1], size2, array2.shape[3]]);
          case 4:
            return sliceAlongLastAxis(array2, start, size2);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
        }
      default:
        throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
    }
  });
}
function concatenate(tensors, axis = -1) {
  let rank;
  if (axis < 0) {
    rank = tensors[0].rank;
    if (rank !== 0) {
      axis = rank;
    } else {
      axis = 0;
    }
  }
  if (axis === tensors[0].rank) {
    axis = -1;
  }
  return concat(tensors, axis);
}
function concatAlongFirstAxis(a6, b2) {
  switch (a6.rank) {
    case 1:
      return concat1d([a6, b2]);
    case 2:
      return concat2d([a6, b2], 0);
    case 3:
      return concat3d([a6, b2], 0);
    case 4:
      return concat4d([a6, b2], 0);
    default:
      throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${a6.rank}`);
  }
}
function tile2(x2, n2) {
  if (!Array.isArray(n2)) {
    n2 = [n2];
  }
  if (x2.rank !== n2.length) {
    throw new ValueError(`The length of input n (${n2.length}) does not match the number of dimensions in input x (${x2.rank})`);
  }
  return tile(x2, n2);
}
function randomNormal2(shape, mean5 = 0, stddev = 1, dtype, seed) {
  return randomNormal(shape, mean5, stddev, dtype, seed);
}
function dot2(a6, b2, activation2, bias) {
  if (a6.rank < 2 || b2.rank < 2) {
    throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${a6.shape} and y shape = ${b2.shape}`);
  }
  if (b2.rank >= 3) {
    const xLastDim = a6.shape.slice(-1)[0];
    const ySecondLastDim = b2.shape.slice(-2)[0];
    if (xLastDim !== ySecondLastDim) {
      throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a6.shape} and  y shape = ${b2.shape}`);
    }
  }
  if (a6.rank === 2 && b2.rank === 2) {
    const transposeA = false;
    const transposeB = false;
    return fused_ops_exports.matMul({
      a: a6,
      b: b2,
      transposeA,
      transposeB,
      bias: bias ? reshapeBias(a6.rank, bias, imageDataFormat()) : null,
      activation: activation2
    });
  } else {
    const aFirstDims = a6.shape.slice();
    const aLastDim = aFirstDims.pop();
    a6 = reshape(a6, [-1, aLastDim]);
    const bShape = b2.shape.slice();
    const bLastDim = bShape.pop();
    const ySecondLastDim = bShape.pop();
    const yOtherDims = [...bShape, bLastDim];
    const perm = Array.from({ length: b2.rank }, (_2, i2) => {
      if (i2 === 0) {
        return b2.rank - 2;
      } else if (i2 <= b2.rank - 2) {
        return i2 - 1;
      }
      return i2;
    });
    b2 = reshape(transpose(b2, perm), [ySecondLastDim, -1]);
    const outputShape = [...aFirstDims, ...yOtherDims];
    const transposeA = false;
    const transposeB = false;
    return reshape(fused_ops_exports.matMul({
      a: a6,
      b: b2,
      transposeA,
      transposeB,
      bias: bias ? reshapeBias(a6.rank, bias, imageDataFormat()) : null,
      activation: activation2
    }), outputShape);
  }
}
function gather2(reference, indices, axis) {
  return tidy(() => {
    if (Array.isArray(indices)) {
      indices = tensor1d(indices, "int32");
    } else {
      indices = cast(indices, "int32");
    }
    return gather(reference, indices, axis);
  });
}
function square2(x2) {
  return mul(x2, x2);
}
function reshapeBias(xRank, bias, dataFormat) {
  const biasShape = bias.shape;
  if (bias.rank !== 1 && bias.rank !== xRank) {
    throw new ValueError(`Unexpected bias dimensions: ${bias.rank}; expected it to be 1 or ${xRank}`);
  }
  if (xRank === 5) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1, 1, 1]);
      } else {
        return reshape(bias, [1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, 1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank === 4) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1, 1]);
      } else {
        return reshape(bias, [1, biasShape[2], biasShape[0], biasShape[1]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank === 3) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1]);
      } else {
        return reshape(bias, [1, biasShape[1], biasShape[0]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank < 3) {
    return bias;
  }
  throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);
}
function biasAdd(x2, bias, dataFormat) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    return add2(x2, reshapeBias(x2.rank, bias, dataFormat));
  });
}
function elu2(x2, alpha = 1) {
  if (alpha !== 1) {
    throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented yet.`);
  }
  return elu(x2);
}
function softsign(x2) {
  return tidy(() => div(x2, add2(abs(x2), 1)));
}
function dropout2(x2, level, noiseShape, seed) {
  return tidy(() => dropout(x2, level, noiseShape, seed));
}
function hardSigmoid(x2) {
  return tidy(() => {
    const y2 = add2(0.5, mul(0.2, x2));
    return clipByValue(y2, 0, 1);
  });
}
function inTrainPhase(x2, alt, training = false) {
  return training ? x2() : alt();
}
var VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];
var VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];
function checkFanMode(value) {
  checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", value);
}
function checkDistribution(value) {
  checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", value);
}
var Initializer = class extends serialization_exports.Serializable {
  fromConfigUsesCustomObjects() {
    return false;
  }
  getConfig() {
    return {};
  }
};
var Zeros = class extends Initializer {
  apply(shape, dtype) {
    return zeros(shape, dtype);
  }
};
Zeros.className = "Zeros";
serialization_exports.registerClass(Zeros);
var Ones = class extends Initializer {
  apply(shape, dtype) {
    return ones2(shape, dtype);
  }
};
Ones.className = "Ones";
serialization_exports.registerClass(Ones);
var Constant = class extends Initializer {
  constructor(args) {
    super();
    if (typeof args !== "object") {
      throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);
    }
    if (args.value === void 0) {
      throw new ValueError(`config must have value set but got ${args}`);
    }
    this.value = args.value;
  }
  apply(shape, dtype) {
    return tidy(() => mul(scalar(this.value), ones2(shape, dtype)));
  }
  getConfig() {
    return {
      value: this.value
    };
  }
};
Constant.className = "Constant";
serialization_exports.registerClass(Constant);
var RandomUniform = class extends Initializer {
  constructor(args) {
    super();
    this.DEFAULT_MINVAL = -0.05;
    this.DEFAULT_MAXVAL = 0.05;
    this.minval = args.minval || this.DEFAULT_MINVAL;
    this.maxval = args.maxval || this.DEFAULT_MAXVAL;
    this.seed = args.seed;
  }
  apply(shape, dtype) {
    return randomUniform(shape, this.minval, this.maxval, dtype);
  }
  getConfig() {
    return { minval: this.minval, maxval: this.maxval, seed: this.seed };
  }
};
RandomUniform.className = "RandomUniform";
serialization_exports.registerClass(RandomUniform);
var RandomNormal = class extends Initializer {
  constructor(args) {
    super();
    this.DEFAULT_MEAN = 0;
    this.DEFAULT_STDDEV = 0.05;
    this.mean = args.mean || this.DEFAULT_MEAN;
    this.stddev = args.stddev || this.DEFAULT_STDDEV;
    this.seed = args.seed;
  }
  apply(shape, dtype) {
    dtype = dtype || "float32";
    if (dtype !== "float32" && dtype !== "int32") {
      throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);
    }
    return randomNormal2(shape, this.mean, this.stddev, dtype, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
};
RandomNormal.className = "RandomNormal";
serialization_exports.registerClass(RandomNormal);
var TruncatedNormal = class extends Initializer {
  constructor(args) {
    super();
    this.DEFAULT_MEAN = 0;
    this.DEFAULT_STDDEV = 0.05;
    this.mean = args.mean || this.DEFAULT_MEAN;
    this.stddev = args.stddev || this.DEFAULT_STDDEV;
    this.seed = args.seed;
  }
  apply(shape, dtype) {
    dtype = dtype || "float32";
    if (dtype !== "float32" && dtype !== "int32") {
      throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);
    }
    return truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
};
TruncatedNormal.className = "TruncatedNormal";
serialization_exports.registerClass(TruncatedNormal);
var Identity2 = class extends Initializer {
  constructor(args) {
    super();
    this.gain = args.gain != null ? args.gain : 1;
  }
  apply(shape, dtype) {
    return tidy(() => {
      if (shape.length !== 2 || shape[0] !== shape[1]) {
        throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
      } else {
        return mul(this.gain, eye(shape[0]));
      }
    });
  }
  getConfig() {
    return { gain: this.gain };
  }
};
Identity2.className = "Identity";
serialization_exports.registerClass(Identity2);
function computeFans(shape, dataFormat = "channelsLast") {
  let fanIn;
  let fanOut;
  checkDataFormat(dataFormat);
  if (shape.length === 2) {
    fanIn = shape[0];
    fanOut = shape[1];
  } else if ([3, 4, 5].indexOf(shape.length) !== -1) {
    if (dataFormat === "channelsFirst") {
      const receptiveFieldSize = arrayProd(shape, 2);
      fanIn = shape[1] * receptiveFieldSize;
      fanOut = shape[0] * receptiveFieldSize;
    } else if (dataFormat === "channelsLast") {
      const receptiveFieldSize = arrayProd(shape, 0, shape.length - 2);
      fanIn = shape[shape.length - 2] * receptiveFieldSize;
      fanOut = shape[shape.length - 1] * receptiveFieldSize;
    }
  } else {
    const shapeProd = arrayProd(shape);
    fanIn = Math.sqrt(shapeProd);
    fanOut = Math.sqrt(shapeProd);
  }
  return [fanIn, fanOut];
}
var VarianceScaling = class extends Initializer {
  constructor(args) {
    super();
    if (args.scale < 0) {
      throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);
    }
    this.scale = args.scale == null ? 1 : args.scale;
    this.mode = args.mode == null ? "fanIn" : args.mode;
    checkFanMode(this.mode);
    this.distribution = args.distribution == null ? "normal" : args.distribution;
    checkDistribution(this.distribution);
    this.seed = args.seed;
  }
  apply(shape, dtype) {
    const fans = computeFans(shape);
    const fanIn = fans[0];
    const fanOut = fans[1];
    let scale22 = this.scale;
    if (this.mode === "fanIn") {
      scale22 /= Math.max(1, fanIn);
    } else if (this.mode === "fanOut") {
      scale22 /= Math.max(1, fanOut);
    } else {
      scale22 /= Math.max(1, (fanIn + fanOut) / 2);
    }
    if (this.distribution === "normal") {
      const stddev = Math.sqrt(scale22);
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);
      }
      return truncatedNormal(shape, 0, stddev, dtype, this.seed);
    } else {
      const limit = Math.sqrt(3 * scale22);
      return randomUniform(shape, -limit, limit, dtype);
    }
  }
  getConfig() {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }
};
VarianceScaling.className = "VarianceScaling";
serialization_exports.registerClass(VarianceScaling);
var GlorotUniform = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
GlorotUniform.className = "GlorotUniform";
serialization_exports.registerClass(GlorotUniform);
var GlorotNormal = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
GlorotNormal.className = "GlorotNormal";
serialization_exports.registerClass(GlorotNormal);
var HeNormal = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
HeNormal.className = "HeNormal";
serialization_exports.registerClass(HeNormal);
var HeUniform = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
HeUniform.className = "HeUniform";
serialization_exports.registerClass(HeUniform);
var LeCunNormal = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
LeCunNormal.className = "LeCunNormal";
serialization_exports.registerClass(LeCunNormal);
var LeCunUniform = class extends VarianceScaling {
  constructor(args) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: args == null ? null : args.seed
    });
  }
  getClassName() {
    return VarianceScaling.className;
  }
};
LeCunUniform.className = "LeCunNormal";
serialization_exports.registerClass(LeCunUniform);
var Orthogonal = class extends Initializer {
  constructor(args) {
    super();
    this.DEFAULT_GAIN = 1;
    this.gain = args.gain == null ? this.DEFAULT_GAIN : args.gain;
    this.seed = args.seed;
    if (this.seed != null) {
      throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
    }
  }
  apply(shape, dtype) {
    return tidy(() => {
      if (shape.length < 2) {
        throw new NotImplementedError("Shape must be at least 2D.");
      }
      if (shape[0] * shape[1] > 2e3) {
        console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${shape[0] * shape[1]}) elements: Slowness may result.`);
      }
      const normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
      const a6 = randomNormal2(normalizedShape, 0, 1, "float32");
      let q2 = linalg.gramSchmidt(a6);
      if (shape[0] > shape[1]) {
        q2 = transpose(q2);
      }
      return mul(this.gain, q2);
    });
  }
  getConfig() {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }
};
Orthogonal.className = "Orthogonal";
serialization_exports.registerClass(Orthogonal);
var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  "constant": "Constant",
  "glorotNormal": "GlorotNormal",
  "glorotUniform": "GlorotUniform",
  "heNormal": "HeNormal",
  "heUniform": "HeUniform",
  "identity": "Identity",
  "leCunNormal": "LeCunNormal",
  "leCunUniform": "LeCunUniform",
  "ones": "Ones",
  "orthogonal": "Orthogonal",
  "randomNormal": "RandomNormal",
  "randomUniform": "RandomUniform",
  "truncatedNormal": "TruncatedNormal",
  "varianceScaling": "VarianceScaling",
  "zeros": "Zeros"
};
function deserializeInitializer(config3, customObjects = {}) {
  return deserializeKerasObject(config3, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "initializer");
}
function serializeInitializer(initializer) {
  return serializeKerasObject(initializer);
}
function getInitializer(identifier) {
  if (typeof identifier === "string") {
    const className = identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    if (className === "GlorotNormal") {
      return new GlorotNormal();
    } else if (className === "GlorotUniform") {
      return new GlorotUniform();
    } else if (className === "HeNormal") {
      return new HeNormal();
    } else if (className === "HeUniform") {
      return new HeUniform();
    } else if (className === "LeCunNormal") {
      return new LeCunNormal();
    } else if (className === "LeCunUniform") {
      return new LeCunUniform();
    } else {
      const config3 = {};
      config3["className"] = className;
      config3["config"] = {};
      return deserializeInitializer(config3);
    }
  } else if (identifier instanceof Initializer) {
    return identifier;
  } else {
    return deserializeInitializer(identifier);
  }
}
function zeros2() {
  return new Zeros();
}
function ones3() {
  return new Ones();
}
function constant(args) {
  return new Constant(args);
}
function randomUniform2(args) {
  return new RandomUniform(args);
}
function randomNormal3(args) {
  return new RandomNormal(args);
}
function truncatedNormal2(args) {
  return new TruncatedNormal(args);
}
function identity(args) {
  return new Identity2(args);
}
function varianceScaling(config3) {
  return new VarianceScaling(config3);
}
function glorotUniform(args) {
  return new GlorotUniform(args);
}
function glorotNormal(args) {
  return new GlorotNormal(args);
}
function heNormal(args) {
  return new HeNormal(args);
}
function heUniform(args) {
  return new HeUniform(args);
}
function leCunNormal(args) {
  return new LeCunNormal(args);
}
function leCunUniform(args) {
  return new LeCunUniform(args);
}
function orthogonal(args) {
  return new Orthogonal(args);
}
var exports_layers_exports = {};
__export2(exports_layers_exports, {
  Layer: () => Layer,
  RNN: () => RNN,
  RNNCell: () => RNNCell,
  activation: () => activation,
  add: () => add3,
  alphaDropout: () => alphaDropout,
  average: () => average,
  averagePooling1d: () => averagePooling1d,
  averagePooling2d: () => averagePooling2d,
  averagePooling3d: () => averagePooling3d,
  avgPool1d: () => avgPool1d,
  avgPool2d: () => avgPool2d,
  avgPool3d: () => avgPool3d2,
  avgPooling1d: () => avgPooling1d,
  avgPooling2d: () => avgPooling2d,
  avgPooling3d: () => avgPooling3d,
  batchNormalization: () => batchNormalization2,
  bidirectional: () => bidirectional,
  concatenate: () => concatenate2,
  conv1d: () => conv1d2,
  conv2d: () => conv2d3,
  conv2dTranspose: () => conv2dTranspose2,
  conv3d: () => conv3d2,
  conv3dTranspose: () => conv3dTranspose2,
  convLstm2d: () => convLstm2d,
  convLstm2dCell: () => convLstm2dCell,
  cropping2D: () => cropping2D,
  dense: () => dense,
  depthwiseConv2d: () => depthwiseConv2d4,
  dot: () => dot3,
  dropout: () => dropout3,
  elu: () => elu3,
  embedding: () => embedding,
  flatten: () => flatten3,
  gaussianDropout: () => gaussianDropout,
  gaussianNoise: () => gaussianNoise,
  globalAveragePooling1d: () => globalAveragePooling1d,
  globalAveragePooling2d: () => globalAveragePooling2d,
  globalMaxPool1d: () => globalMaxPool1d,
  globalMaxPool2d: () => globalMaxPool2d,
  globalMaxPooling1d: () => globalMaxPooling1d,
  globalMaxPooling2d: () => globalMaxPooling2d,
  gru: () => gru,
  gruCell: () => gruCell,
  input: () => input,
  inputLayer: () => inputLayer,
  layerNormalization: () => layerNormalization,
  leakyReLU: () => leakyReLU,
  lstm: () => lstm,
  lstmCell: () => lstmCell,
  masking: () => masking,
  maxPool1d: () => maxPool1d,
  maxPool2d: () => maxPool2d,
  maxPooling1d: () => maxPooling1d,
  maxPooling2d: () => maxPooling2d,
  maxPooling3d: () => maxPooling3d,
  maximum: () => maximum2,
  minimum: () => minimum2,
  multiply: () => multiply,
  permute: () => permute,
  prelu: () => prelu2,
  reLU: () => reLU,
  repeatVector: () => repeatVector,
  reshape: () => reshape2,
  rnn: () => rnn2,
  separableConv2d: () => separableConv2d2,
  simpleRNN: () => simpleRNN,
  simpleRNNCell: () => simpleRNNCell,
  softmax: () => softmax2,
  spatialDropout1d: () => spatialDropout1d,
  stackedRNNCells: () => stackedRNNCells,
  thresholdedReLU: () => thresholdedReLU,
  timeDistributed: () => timeDistributed,
  upSampling2d: () => upSampling2d,
  zeroPadding2d: () => zeroPadding2d
});
var _nextUniqueTensorId = 0;
function getNextUniqueTensorId() {
  return _nextUniqueTensorId++;
}
var _uidPrefixes = {};
function getUid(prefix = "") {
  if (!(prefix in _uidPrefixes)) {
    _uidPrefixes[prefix] = 0;
  }
  _uidPrefixes[prefix] += 1;
  return prefix + _uidPrefixes[prefix].toString();
}
function isArrayOfShapes(x2) {
  return Array.isArray(x2) && Array.isArray(x2[0]);
}
function normalizeShapeList(x2) {
  if (x2.length === 0) {
    return [];
  }
  if (!Array.isArray(x2[0])) {
    return [x2];
  }
  return x2;
}
function getExactlyOneTensor(xs) {
  let x2;
  if (Array.isArray(xs)) {
    if (xs.length !== 1) {
      throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);
    }
    x2 = xs[0];
  } else {
    x2 = xs;
  }
  return x2;
}
function getExactlyOneShape(shapes) {
  if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
    if (shapes.length === 1) {
      shapes = shapes;
      return shapes[0];
    } else {
      throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);
    }
  } else {
    return shapes;
  }
}
function countParamsInWeights(weights) {
  let count22 = 0;
  for (const weight of weights) {
    if (weight.shape.length === 0) {
      count22 += 1;
    } else {
      count22 += weight.shape.reduce((a6, b2) => a6 * b2);
    }
  }
  return count22;
}
var DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
var LayerVariable = class {
  constructor(val, dtype = "float32", name = DEFAULT_VARIABLE_NAME_PREFIX, trainable = true, constraint = null) {
    this.dtype = dtype == null ? "float32" : dtype;
    this.shape = val.shape;
    this.id = getNextUniqueTensorId();
    name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
    this.originalName = getScopedTensorName(name);
    this.name = getUniqueTensorName(this.originalName);
    this.trainable_ = trainable;
    this.constraint = constraint;
    this.val = variable(val, this.trainable_, this.name, this.dtype);
  }
  read() {
    this.assertNotDisposed();
    return this.val;
  }
  write(newVal) {
    this.assertNotDisposed();
    checkShapesMatch(this.val, newVal);
    if (this.val.id !== newVal.id) {
      this.val.assign(newVal);
      if (this.constraint != null) {
        this.val.assign(this.constraint.apply(this.val));
      }
    }
    return this;
  }
  dispose() {
    this.assertNotDisposed();
    this.val.dispose();
  }
  assertNotDisposed() {
    if (this.val.isDisposed) {
      throw new Error(`LayersVariable ${this.name} is already disposed.`);
    }
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(trainable) {
    this.trainable_ = trainable;
    this.val.trainable = trainable;
  }
};
function checkShapesMatch(x2, y2) {
  if (x2.shape.toString() !== y2.shape.toString()) {
    throw new Error("Shape mismatch: " + JSON.stringify(x2.shape) + " vs. " + JSON.stringify(y2.shape));
  }
}
function batchGetValue(xs) {
  return xs.map((x2) => x2.read());
}
function batchSetValue(variablesAndValues) {
  variablesAndValues.forEach((variableAndValue) => {
    const variable2 = variableAndValue[0];
    variable2.write(variableAndValue[1]);
  });
}
var InputSpec = class {
  constructor(args) {
    this.dtype = args.dtype;
    this.shape = args.shape;
    if (args.shape != null) {
      this.ndim = args.shape.length;
    } else {
      this.ndim = args.ndim;
    }
    this.maxNDim = args.maxNDim;
    this.minNDim = args.minNDim;
    this.axes = args.axes || {};
  }
};
var SymbolicTensor = class {
  constructor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
    this.dtype = dtype;
    this.shape = shape;
    this.sourceLayer = sourceLayer;
    this.inputs = inputs;
    this.callArgs = callArgs;
    this.outputTensorIndex = outputTensorIndex;
    this.id = getNextUniqueTensorId();
    if (name != null) {
      this.originalName = getScopedTensorName(name);
      this.name = getUniqueTensorName(this.originalName);
    }
    this.rank = shape.length;
  }
};
var _nextNodeID = 0;
var Node2 = class {
  constructor(args, callArgs) {
    this.callArgs = callArgs;
    this.id = _nextNodeID++;
    this.outboundLayer = args.outboundLayer;
    this.inboundLayers = args.inboundLayers;
    this.nodeIndices = args.nodeIndices;
    this.tensorIndices = args.tensorIndices;
    this.inputTensors = args.inputTensors;
    this.outputTensors = args.outputTensors;
    this.inputMasks = args.inputMasks;
    this.outputMasks = args.outputMasks;
    this.inputShapes = args.inputShapes;
    this.outputShapes = args.outputShapes;
    for (const layer of args.inboundLayers) {
      if (layer != null) {
        layer.outboundNodes.push(this);
      }
    }
    args.outboundLayer.inboundNodes.push(this);
  }
  getConfig() {
    const inboundNames = [];
    for (const layer of this.inboundLayers) {
      if (layer != null) {
        inboundNames.push(layer.name);
      } else {
        inboundNames.push(null);
      }
    }
    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: inboundNames,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }
};
var _nextLayerID = 0;
var Layer = class extends serialization_exports.Serializable {
  constructor(args = {}) {
    super();
    this._callHook = null;
    this._addedWeightNames = [];
    this._stateful = false;
    this.id = _nextLayerID++;
    this.activityRegularizer = null;
    this.inputSpec = null;
    this.supportsMasking = false;
    this._trainableWeights = [];
    this._nonTrainableWeights = [];
    this._losses = [];
    this._updates = [];
    this._built = false;
    this.inboundNodes = [];
    this.outboundNodes = [];
    let name = args.name;
    if (!name) {
      const prefix = this.getClassName();
      name = toSnakeCase(prefix) + "_" + getUid(prefix);
    }
    this.name = name;
    this.trainable_ = args.trainable == null ? true : args.trainable;
    if (args.inputShape != null || args.batchInputShape != null) {
      let batchInputShape;
      if (args.batchInputShape != null) {
        batchInputShape = args.batchInputShape;
      } else if (args.inputShape != null) {
        let batchSize = null;
        if (args.batchSize != null) {
          batchSize = args.batchSize;
        }
        batchInputShape = [batchSize].concat(args.inputShape);
      }
      this.batchInputShape = batchInputShape;
      let dtype = args.dtype;
      if (dtype == null) {
        dtype = args.inputDType;
      }
      if (dtype == null) {
        dtype = "float32";
      }
      this.dtype = dtype;
    }
    if (args.weights != null) {
      this.initialWeights = args.weights;
    } else {
      this.initialWeights = null;
    }
    this._refCount = null;
    this.fastWeightInitDuringBuild = false;
  }
  static nodeKey(layer, nodeIndex) {
    return layer.name + "_ib-" + nodeIndex.toString();
  }
  getNodeAtIndex(nodeIndex, attrName) {
    if (this.inboundNodes.length === 0) {
      throw new RuntimeError(`The layer has never been called and thus has no defined ${attrName}.`);
    }
    if (this.inboundNodes.length <= nodeIndex) {
      throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
    }
    return this.inboundNodes[nodeIndex];
  }
  getInputAt(nodeIndex) {
    return singletonOrArray(this.getNodeAtIndex(nodeIndex, "input").inputTensors);
  }
  getOutputAt(nodeIndex) {
    return singletonOrArray(this.getNodeAtIndex(nodeIndex, "output").outputTensors);
  }
  get input() {
    if (this.inboundNodes.length > 1) {
      throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
    } else if (this.inboundNodes.length === 0) {
      throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);
    }
    return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
  }
  get output() {
    if (this.inboundNodes.length === 0) {
      throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);
    }
    if (this.inboundNodes.length > 1) {
      throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
    }
    return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
  }
  get losses() {
    return this._losses;
  }
  calculateLosses() {
    return this.losses.map((lossFn) => lossFn());
  }
  get updates() {
    return this._updates;
  }
  get built() {
    return this._built;
  }
  set built(built) {
    this._built = built;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(trainable) {
    this._trainableWeights.forEach((w2) => w2.trainable = trainable);
    this.trainable_ = trainable;
  }
  get trainableWeights() {
    if (this.trainable_) {
      return this._trainableWeights.filter((w2) => w2.trainable);
    } else {
      return [];
    }
  }
  set trainableWeights(weights) {
    this._trainableWeights = weights;
  }
  get nonTrainableWeights() {
    if (this.trainable) {
      return this._trainableWeights.filter((w2) => !w2.trainable).concat(this._nonTrainableWeights);
    } else {
      return this._trainableWeights.concat(this._nonTrainableWeights);
    }
  }
  set nonTrainableWeights(weights) {
    this._nonTrainableWeights = weights;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  get stateful() {
    return this._stateful;
  }
  resetStates() {
    if (!this.stateful) {
      throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }
  }
  assertInputCompatibility(inputs) {
    inputs = toList(inputs);
    if (this.inputSpec == null || this.inputSpec.length === 0) {
      return;
    }
    const inputSpec = toList(this.inputSpec);
    if (inputs.length !== inputSpec.length) {
      throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, but it received ${inputs.length} input tensors. Input received: ${inputs}`);
    }
    for (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
      const x2 = inputs[inputIndex];
      const spec = inputSpec[inputIndex];
      if (spec == null) {
        continue;
      }
      const ndim = x2.rank;
      if (spec.ndim != null) {
        if (ndim !== spec.ndim) {
          throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected ndim=${spec.ndim}, found ndim=${ndim}`);
        }
      }
      if (spec.maxNDim != null) {
        if (ndim > spec.maxNDim) {
          throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);
        }
      }
      if (spec.minNDim != null) {
        if (ndim < spec.minNDim) {
          throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);
        }
      }
      if (spec.dtype != null) {
        if (x2.dtype !== spec.dtype) {
          throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} : expected dtype=${spec.dtype}, found dtype=${x2.dtype}.`);
        }
      }
      if (spec.axes) {
        const xShape = x2.shape;
        for (const key in spec.axes) {
          const axis = Number(key);
          const value = spec.axes[key];
          const xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
          if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected axis ${axis} of input shape to have value ${value} but got shape ${xShape}.`);
          }
        }
      }
      if (spec.shape != null) {
        for (let i2 = 0; i2 < spec.shape.length; ++i2) {
          const specDim = spec.shape[i2];
          const dim = x2.shape[i2];
          if (specDim != null && dim != null) {
            if (specDim !== dim) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected shape=${spec.shape}, found shape=${x2.shape}.`);
            }
          }
        }
      }
    }
  }
  call(inputs, kwargs) {
    return inputs;
  }
  invokeCallHook(inputs, kwargs) {
    if (this._callHook != null) {
      this._callHook(inputs, kwargs);
    }
  }
  setCallHook(callHook) {
    this._callHook = callHook;
  }
  clearCallHook() {
    this._callHook = null;
  }
  apply(inputs, kwargs) {
    kwargs = kwargs || {};
    this.assertNotDisposed();
    const inputsList = toList(inputs);
    let allAreSymbolic = true;
    for (const input2 of inputsList) {
      if (!(input2 instanceof SymbolicTensor)) {
        allAreSymbolic = false;
        break;
      }
    }
    let noneAreSymbolic = true;
    for (const input2 of inputsList) {
      if (input2 instanceof SymbolicTensor) {
        noneAreSymbolic = false;
        break;
      }
    }
    if (allAreSymbolic === noneAreSymbolic) {
      throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
    }
    return nameScope(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(inputs);
        const inputShapes = [];
        for (const xElem of toList(inputs)) {
          inputShapes.push(xElem.shape);
        }
        this.build(singletonOrArray(inputShapes));
        this.built = true;
        if (this.initialWeights) {
          this.setWeights(this.initialWeights);
        }
        if (this._refCount === null && noneAreSymbolic) {
          this._refCount = 1;
        }
      }
      this.assertInputCompatibility(inputs);
      if (noneAreSymbolic) {
        let output = this.call(inputs, kwargs);
        const outputList = toList(output);
        const outputListCopy = [];
        for (let x2 of outputList) {
          if (inputsList.indexOf(x2) !== -1) {
            x2 = x2.clone();
          }
          outputListCopy.push(x2);
        }
        output = singletonOrArray(outputListCopy);
        if (this.activityRegularizer != null) {
          throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        }
        return output;
      } else {
        const inputShape = collectInputShape(inputs);
        const outputShape = this.computeOutputShape(inputShape);
        let output;
        const outputDType = guessOutputDType(inputs);
        this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] : inputShape);
        if (outputShape != null && outputShape.length > 0 && Array.isArray(outputShape[0])) {
          output = outputShape.map((shape, index) => new SymbolicTensor(outputDType, shape, this, toList(inputs), kwargs, this.name, index));
        } else {
          output = new SymbolicTensor(outputDType, outputShape, this, toList(inputs), kwargs, this.name);
        }
        this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
        this._refCount++;
        if (this.activityRegularizer != null) {
          throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        }
        return output;
      }
    });
  }
  warnOnIncompatibleInputShape(inputShape) {
    if (this.batchInputShape == null) {
      return;
    } else if (inputShape.length !== this.batchInputShape.length) {
      console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(inputShape)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
    } else {
      let dimMismatch = false;
      this.batchInputShape.forEach((dimension, i2) => {
        if (dimension != null && inputShape[i2] != null && inputShape[i2] !== dimension) {
          dimMismatch = true;
        }
      });
      if (dimMismatch) {
        console.warn(`The shape of the input tensor (${JSON.stringify(inputShape)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
    }
  }
  get outputShape() {
    if (this.inboundNodes == null || this.inboundNodes.length === 0) {
      throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);
    }
    const allOutputShapes = [];
    for (const node2 of this.inboundNodes) {
      const shapeString = JSON.stringify(node2.outputShapes);
      if (allOutputShapes.indexOf(shapeString) === -1) {
        allOutputShapes.push(shapeString);
      }
    }
    if (allOutputShapes.length === 1) {
      const outputShapes = this.inboundNodes[0].outputShapes;
      if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) && outputShapes.length === 1) {
        return outputShapes[0];
      } else {
        return outputShapes;
      }
    } else {
      throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
    }
  }
  countParams() {
    if (!this.built) {
      throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
    }
    return countParamsInWeights(this.weights);
  }
  build(inputShape) {
    this.built = true;
  }
  getWeights(trainableOnly = false) {
    return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
  }
  setWeights(weights) {
    tidy(() => {
      const params = this.weights;
      if (params.length !== weights.length) {
        throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${weights.length}, but the layer was expecting ${params.length} weights. Provided weights: ${weights}...`);
      }
      if (params.length === 0) {
        return;
      }
      const weightValueTuples = [];
      const paramValues = batchGetValue(params);
      for (let i2 = 0; i2 < paramValues.length; ++i2) {
        const pv = paramValues[i2];
        const p22 = params[i2];
        const w2 = weights[i2];
        if (!util_exports.arraysEqual(pv.shape, w2.shape)) {
          throw new ValueError(`Layer weight shape ${pv.shape} not compatible with provided weight shape ${w2.shape}`);
        }
        weightValueTuples.push([p22, w2]);
      }
      batchSetValue(weightValueTuples);
    });
  }
  addWeight(name, shape, dtype, initializer, regularizer, trainable, constraint) {
    if (this._addedWeightNames.indexOf(name) !== -1) {
      throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);
    }
    this._addedWeightNames.push(name);
    if (dtype == null) {
      dtype = "float32";
    }
    if (this.fastWeightInitDuringBuild) {
      initializer = getInitializer("zeros");
    }
    const initValue = initializer.apply(shape, dtype);
    const weight = new LayerVariable(initValue, dtype, name, trainable, constraint);
    initValue.dispose();
    if (regularizer != null) {
      this.addLoss(() => regularizer.apply(weight.read()));
    }
    if (trainable == null) {
      trainable = true;
    }
    if (trainable) {
      this._trainableWeights.push(weight);
    } else {
      this._nonTrainableWeights.push(weight);
    }
    return weight;
  }
  setFastWeightInitDuringBuild(value) {
    this.fastWeightInitDuringBuild = value;
  }
  addLoss(losses4) {
    if (losses4 == null || Array.isArray(losses4) && losses4.length === 0) {
      return;
    }
    losses4 = toList(losses4);
    if (this._losses !== void 0 && this._losses !== null) {
      this.losses.push(...losses4);
    }
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  computeMask(inputs, mask) {
    if (!this.supportsMasking) {
      if (mask != null) {
        if (Array.isArray(mask)) {
          mask.forEach((maskElement) => {
            if (maskElement != null) {
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
            }
          });
        } else {
          throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        }
      }
      return null;
    }
    return mask;
  }
  addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs = null) {
    const inputTensorList = toList(inputTensors);
    outputTensors = toList(outputTensors);
    inputMasks = toList(inputMasks);
    outputMasks = toList(outputMasks);
    inputShapes = normalizeShapeList(inputShapes);
    outputShapes = normalizeShapeList(outputShapes);
    const inboundLayers = [];
    const nodeIndices = [];
    const tensorIndices = [];
    for (const x2 of inputTensorList) {
      inboundLayers.push(x2.sourceLayer);
      nodeIndices.push(x2.nodeIndex);
      tensorIndices.push(x2.tensorIndex);
    }
    new Node2({
      outboundLayer: this,
      inboundLayers,
      nodeIndices,
      tensorIndices,
      inputTensors: inputTensorList,
      outputTensors,
      inputMasks,
      outputMasks,
      inputShapes,
      outputShapes
    }, kwargs);
    for (let i2 = 0; i2 < outputTensors.length; i2++) {
      outputTensors[i2].sourceLayer = this;
      outputTensors[i2].nodeIndex = this.inboundNodes.length - 1;
      outputTensors[i2].tensorIndex = i2;
    }
  }
  getConfig() {
    const config3 = { name: this.name, trainable: this.trainable };
    if (this.batchInputShape != null) {
      config3["batchInputShape"] = this.batchInputShape;
    }
    if (this.dtype != null) {
      config3["dtype"] = this.dtype;
    }
    return config3;
  }
  disposeWeights() {
    this.weights.forEach((weight) => weight.dispose());
    return this.weights.length;
  }
  assertNotDisposed() {
    if (this._refCount === 0) {
      throw new Error(`Layer '${this.name}' is already disposed.`);
    }
  }
  dispose() {
    if (!this.built) {
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
    }
    if (this._refCount === null) {
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
    }
    this.assertNotDisposed();
    let numDisposedVariables = 0;
    if (--this._refCount === 0) {
      numDisposedVariables = this.disposeWeights();
    }
    return { refCountAfterDispose: this._refCount, numDisposedVariables };
  }
};
function collectInputShape(inputTensors) {
  inputTensors = toList(inputTensors);
  const shapes = [];
  for (const x2 of inputTensors) {
    shapes.push(x2.shape);
  }
  return singletonOrArray(shapes);
}
function guessOutputDType(inputTensors) {
  return "float32";
}
function getSourceInputs(tensor2, layer, nodeIndex) {
  if (layer == null || nodeIndex != null && nodeIndex > 0) {
    layer = tensor2.sourceLayer;
    nodeIndex = tensor2.nodeIndex;
  }
  if (layer.inboundNodes.length === 0) {
    return [tensor2];
  } else {
    const node2 = layer.inboundNodes[nodeIndex];
    if (node2.inboundLayers.length === 0) {
      return node2.inputTensors;
    } else {
      const sourceTensors = [];
      for (let i2 = 0; i2 < node2.inboundLayers.length; i2++) {
        const x2 = node2.inputTensors[i2];
        const layer2 = node2.inboundLayers[i2];
        const nodeIndex2 = node2.nodeIndices[i2];
        const previousSources = getSourceInputs(x2, layer2, nodeIndex2);
        for (const x22 of previousSources) {
          if (sourceTensors.indexOf(x22) === -1) {
            sourceTensors.push(x22);
          }
        }
      }
      return sourceTensors;
    }
  }
}
var InputLayer = class extends Layer {
  constructor(args) {
    super({
      dtype: args.dtype,
      name: args.name != null ? args.name : getUid("input").toString()
    });
    if (args.batchSize == null) {
      args.batchSize = null;
    }
    if (args.sparse == null) {
      args.sparse = false;
    }
    this.trainable = false;
    this.built = true;
    this.sparse = args.sparse;
    if (args.inputShape != null && args.batchInputShape != null) {
      throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    }
    let batchInputShape = args.batchInputShape;
    if (batchInputShape == null) {
      if (args.inputShape == null) {
        throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      } else {
        batchInputShape = [args.batchSize].concat(args.inputShape);
      }
    } else {
      if (args.batchSize != null) {
        throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      }
    }
    const dtype = args.dtype || "float32";
    this.batchInputShape = batchInputShape;
    this.dtype = dtype;
    this.inputSpec = [{ shape: batchInputShape }];
    const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);
    inputTensor.nodeIndex = 0;
    inputTensor.tensorIndex = 0;
    new Node2({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [inputTensor],
      outputTensors: [inputTensor],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [batchInputShape],
      outputShapes: [batchInputShape]
    });
  }
  apply(inputs, kwargs) {
    throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
  }
  dispose() {
    return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
  }
  getConfig() {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }
};
InputLayer.className = "InputLayer";
serialization_exports.registerClass(InputLayer);
function Input(config3) {
  if (config3.batchShape == null && config3.shape == null) {
    throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  }
  if (config3.batchShape != null && config3.shape != null) {
    throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  }
  let batchShape = config3.batchShape;
  if (config3.shape != null && batchShape == null) {
    batchShape = [null].concat(config3.shape);
  }
  let dtype = config3.dtype;
  if (dtype == null) {
    dtype = "float32";
  }
  const inputLayer2 = new InputLayer({
    batchInputShape: batchShape,
    name: config3.name,
    dtype,
    sparse: config3.sparse
  });
  const outputs = inputLayer2.inboundNodes[0].outputTensors;
  return outputs[0];
}
async function resolveScalarsInLogs(logs) {
  if (logs == null) {
    return;
  }
  const promises = [];
  const keys = [];
  const scalarsToDispose = [];
  for (const key in logs) {
    const value = logs[key];
    if (typeof value !== "number") {
      const valueScalar = value;
      promises.push(valueScalar.data());
      keys.push(key);
      scalarsToDispose.push(valueScalar);
    }
  }
  if (promises.length > 0) {
    const values = await Promise.all(promises);
    for (let i2 = 0; i2 < values.length; ++i2) {
      logs[keys[i2]] = values[i2][0];
    }
    dispose(scalarsToDispose);
  }
}
function disposeTensorsInLogs(logs) {
  if (logs == null) {
    return;
  }
  for (const key in logs) {
    const value = logs[key];
    if (typeof value !== "number") {
      value.dispose();
    }
  }
}
var ModelLoggingVerbosity;
(function(ModelLoggingVerbosity2) {
  ModelLoggingVerbosity2[ModelLoggingVerbosity2["SILENT"] = 0] = "SILENT";
  ModelLoggingVerbosity2[ModelLoggingVerbosity2["VERBOSE"] = 1] = "VERBOSE";
})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));
var DEFAULT_YIELD_EVERY_MS = 125;
var BaseCallback = class {
  constructor() {
    this.validationData = null;
  }
  setParams(params) {
    this.params = params;
  }
  async onEpochBegin(epoch, logs) {
  }
  async onEpochEnd(epoch, logs) {
  }
  async onBatchBegin(batch, logs) {
  }
  async onBatchEnd(batch, logs) {
  }
  async onTrainBegin(logs) {
  }
  async onTrainEnd(logs) {
  }
  setModel(model22) {
  }
};
var CallbackList = class {
  constructor(callbacks2, queueLength = 10) {
    if (callbacks2 == null) {
      callbacks2 = [];
    }
    this.callbacks = callbacks2;
    this.queueLength = queueLength;
  }
  append(callback) {
    this.callbacks.push(callback);
  }
  setParams(params) {
    for (const callback of this.callbacks) {
      callback.setParams(params);
    }
  }
  setModel(model22) {
    for (const callback of this.callbacks) {
      callback.setModel(model22);
    }
  }
  async onEpochBegin(epoch, logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onEpochBegin(epoch, logs);
    }
  }
  async onEpochEnd(epoch, logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onEpochEnd(epoch, logs);
    }
  }
  async onBatchBegin(batch, logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onBatchBegin(batch, logs);
    }
  }
  async onBatchEnd(batch, logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onBatchEnd(batch, logs);
    }
  }
  async onTrainBegin(logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onTrainBegin(logs);
    }
  }
  async onTrainEnd(logs) {
    if (logs == null) {
      logs = {};
    }
    for (const callback of this.callbacks) {
      await callback.onTrainEnd(logs);
    }
  }
};
var BaseLogger = class extends BaseCallback {
  constructor() {
    super();
  }
  async onEpochBegin(epoch) {
    this.seen = 0;
    this.totals = {};
  }
  async onBatchEnd(batch, logs) {
    if (logs == null) {
      logs = {};
    }
    const batchSize = logs["size"] == null ? 0 : logs["size"];
    this.seen += batchSize;
    for (const key in logs) {
      const value = logs[key];
      if (typeof value === "number") {
        if (!this.totals.hasOwnProperty(key)) {
          this.totals[key] = 0;
        }
        this.totals[key] = this.totals[key] + value * batchSize;
      } else {
        let oldTotalsToDispose;
        if (key in this.totals) {
          oldTotalsToDispose = this.totals[key];
        } else {
          this.totals[key] = 0;
        }
        const total = tidy(() => add2(this.totals[key], mul(value, batchSize)));
        this.totals[key] = total;
        if (oldTotalsToDispose != null) {
          oldTotalsToDispose.dispose();
        }
      }
    }
  }
  async onEpochEnd(epoch, logs) {
    if (logs != null) {
      for (const key of this.params["metrics"]) {
        if (this.totals[key] == null) {
          continue;
        }
        if (typeof this.totals[key] === "number") {
          logs[key] = this.totals[key] / this.seen;
        } else {
          tidy(() => {
            const log9 = mul(div(1, this.seen), this.totals[key]);
            logs[key] = log9;
            this.totals[key].dispose();
            keep(logs[key]);
          });
        }
      }
    }
  }
};
var History = class extends BaseCallback {
  async onTrainBegin(logs) {
    this.epoch = [];
    this.history = {};
  }
  async onEpochEnd(epoch, logs) {
    if (logs == null) {
      logs = {};
    }
    this.epoch.push(epoch);
    for (const key in logs) {
      if (this.history[key] == null) {
        this.history[key] = [];
      }
      this.history[key].push(logs[key]);
    }
  }
  async syncData() {
    const promises = [];
    const keys = [];
    const indices = [];
    for (const key in this.history) {
      const valueArray = this.history[key];
      for (let i2 = 0; i2 < valueArray.length; ++i2) {
        if (typeof valueArray[i2] !== "number") {
          const valueScalar = valueArray[i2];
          promises.push(valueScalar.data());
          keys.push(key);
          indices.push(i2);
        }
      }
    }
    const values = await Promise.all(promises);
    for (let n2 = 0; n2 < values.length; ++n2) {
      const tensorToDispose = this.history[keys[n2]][indices[n2]];
      tensorToDispose.dispose();
      this.history[keys[n2]][indices[n2]] = values[n2][0];
    }
  }
};
var CustomCallback = class extends BaseCallback {
  constructor(args, yieldEvery) {
    super();
    this.currentEpoch = 0;
    this.yieldEvery = yieldEvery || "auto";
    if (this.yieldEvery === "auto") {
      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;
    }
    if (this.yieldEvery === "never" && args.onYield != null) {
      throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    }
    if (util_exports.isNumber(this.yieldEvery)) {
      this.maybeWait = debounce(this.maybeWait.bind(this), this.yieldEvery);
    }
    this.trainBegin = args.onTrainBegin;
    this.trainEnd = args.onTrainEnd;
    this.epochBegin = args.onEpochBegin;
    this.epochEnd = args.onEpochEnd;
    this.batchBegin = args.onBatchBegin;
    this.batchEnd = args.onBatchEnd;
    this.yield = args.onYield;
  }
  async maybeWait(epoch, batch, logs) {
    const ps = [];
    if (this.yield != null) {
      await resolveScalarsInLogs(logs);
      ps.push(this.yield(epoch, batch, logs));
    }
    ps.push(nextFrame());
    await Promise.all(ps);
  }
  async onEpochBegin(epoch, logs) {
    this.currentEpoch = epoch;
    if (this.epochBegin != null) {
      await resolveScalarsInLogs(logs);
      await this.epochBegin(epoch, logs);
    }
  }
  async onEpochEnd(epoch, logs) {
    const ps = [];
    if (this.epochEnd != null) {
      await resolveScalarsInLogs(logs);
      ps.push(this.epochEnd(epoch, logs));
    }
    if (this.yieldEvery === "epoch") {
      ps.push(nextFrame());
    }
    await Promise.all(ps);
  }
  async onBatchBegin(batch, logs) {
    if (this.batchBegin != null) {
      await resolveScalarsInLogs(logs);
      await this.batchBegin(batch, logs);
    }
  }
  async onBatchEnd(batch, logs) {
    const ps = [];
    if (this.batchEnd != null) {
      await resolveScalarsInLogs(logs);
      ps.push(this.batchEnd(batch, logs));
    }
    if (this.yieldEvery === "batch") {
      ps.push(nextFrame());
    } else if (util_exports.isNumber(this.yieldEvery)) {
      ps.push(this.maybeWait(this.currentEpoch, batch, logs));
    }
    await Promise.all(ps);
  }
  async onTrainBegin(logs) {
    if (this.trainBegin != null) {
      await resolveScalarsInLogs(logs);
      await this.trainBegin(logs);
    }
  }
  async onTrainEnd(logs) {
    if (this.trainEnd != null) {
      await resolveScalarsInLogs(logs);
      await this.trainEnd(logs);
    }
  }
};
function standardizeCallbacks(callbacks2, yieldEvery) {
  if (callbacks2 == null) {
    callbacks2 = {};
  }
  if (callbacks2 instanceof BaseCallback) {
    return [callbacks2];
  }
  if (Array.isArray(callbacks2) && callbacks2[0] instanceof BaseCallback) {
    return callbacks2;
  }
  const callbackConfigs = toList(callbacks2);
  return callbackConfigs.map((callbackConfig) => new CustomCallback(callbackConfig, yieldEvery));
}
var CallbackConstructorRegistry = class {
  constructor() {
  }
  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {
    util_exports.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, but got ${verbosityLevel}`);
    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);
    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {
      CallbackConstructorRegistry.constructors[verbosityLevel] = [];
    }
    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);
  }
  static checkForDuplicate(callbackConstructor) {
    for (const levelName in CallbackConstructorRegistry.constructors) {
      const constructors = CallbackConstructorRegistry.constructors[+levelName];
      constructors.forEach((ctor) => {
        if (ctor === callbackConstructor) {
          throw new ValueError("Duplicate callback constructor.");
        }
      });
    }
  }
  static clear() {
    CallbackConstructorRegistry.constructors = {};
  }
  static createCallbacks(verbosityLevel) {
    const constructors = [];
    for (const levelName in CallbackConstructorRegistry.constructors) {
      const level = +levelName;
      if (verbosityLevel >= level) {
        constructors.push(...CallbackConstructorRegistry.constructors[level]);
      }
    }
    return constructors.map((ctor) => new ctor());
  }
};
CallbackConstructorRegistry.constructors = {};
function configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {
  const history = new History();
  const actualCallbacks = [
    new BaseLogger(),
    ...CallbackConstructorRegistry.createCallbacks(verbose)
  ];
  if (callbacks2 != null) {
    actualCallbacks.push(...callbacks2);
  }
  actualCallbacks.push(history);
  const callbackList = new CallbackList(actualCallbacks);
  callbackList.setParams({
    epochs,
    initialEpoch,
    samples: numTrainSamples,
    steps: stepsPerEpoch,
    batchSize,
    verbose,
    doValidation,
    metrics: callbackMetrics
  });
  return { callbackList, history };
}
function deserialize(config3, customObjects = {}, fastWeightInit = false) {
  return deserializeKerasObject(config3, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "layer", fastWeightInit);
}
function l2Normalize(x2, axis) {
  return tidy(() => {
    if (x2.dtype !== "float32") {
      x2 = cast(x2, "float32");
    }
    const squareSum = sum2(square2(x2), axis, true);
    const epsilonTensor = fill(squareSum.shape, epsilon());
    const norm2 = sqrt(maximum(squareSum, epsilonTensor));
    return div(x2, norm2);
  });
}
function meanSquaredError2(yTrue, yPred) {
  return tidy(() => mean(square2(sub(yPred, yTrue)), -1));
}
function meanAbsoluteError(yTrue, yPred) {
  return tidy(() => mean(abs(sub(yPred, yTrue)), -1));
}
function meanAbsolutePercentageError(yTrue, yPred) {
  return tidy(() => {
    const diff = sub(yTrue, yPred);
    const clippedTrue = clipByValue(abs(yTrue), epsilon(), Number.MAX_VALUE);
    const absResult = abs(div(diff, clippedTrue));
    return mul(100, mean(absResult, -1));
  });
}
function meanSquaredLogarithmicError(yTrue, yPred) {
  return tidy(() => {
    const clippedPred = clipByValue(yPred, epsilon(), Number.MAX_VALUE);
    const firstLog = log5(add2(1, clippedPred));
    const clippedTrue = clipByValue(yTrue, epsilon(), Number.MAX_VALUE);
    const secondLog = log5(add2(1, clippedTrue));
    return mean(square2(sub(firstLog, secondLog)), -1);
  });
}
function squaredHinge(yTrue, yPred) {
  return tidy(() => {
    const maxResult = maximum(0, sub(1, mul(yTrue, yPred)));
    return mean(square2(maxResult), -1);
  });
}
function hinge(yTrue, yPred) {
  return tidy(() => {
    const maxResult = maximum(0, sub(1, mul(yTrue, yPred)));
    return mean(maxResult, -1);
  });
}
function categoricalHinge(yTrue, yPred) {
  return tidy(() => {
    const pos = sum2(mul(yTrue, yPred), -1);
    const neg5 = max(mul(sub(1, yTrue), yPred), -1);
    return maximum(0, add2(1, sub(neg5, pos)));
  });
}
function logcosh(yTrue, yPred) {
  return tidy(() => {
    const log22 = Math.log(2);
    const predictionDiff = sub(yPred, yTrue);
    const logcoshResult = sub(add2(predictionDiff, softplus(mul(-2, predictionDiff))), log22);
    return mean(logcoshResult, -1);
  });
}
function categoricalCrossentropy(target, output, fromLogits = false) {
  return tidy(() => {
    if (fromLogits) {
      output = softmax(output);
    } else {
      const outputSum = sum2(output, output.shape.length - 1, true);
      output = div(output, outputSum);
    }
    output = clipByValue(output, epsilon(), 1 - epsilon());
    return neg(sum2(mul(cast(target, "float32"), log5(output)), output.shape.length - 1));
  });
}
function sparseCategoricalCrossentropy(target, output, fromLogits = false) {
  return tidy(() => {
    const flatTarget = cast(floor(flatten22(target)), "int32");
    output = clipByValue(output, epsilon(), 1 - epsilon());
    const outputShape = output.shape;
    const oneHotTarget = reshape(oneHot(flatTarget, outputShape[outputShape.length - 1]), outputShape);
    return categoricalCrossentropy(oneHotTarget, output, fromLogits);
  });
}
function sigmoidCrossEntropyWithLogits(labels2, logits) {
  if (!util_exports.arraysEqual(labels2.shape, logits.shape)) {
    throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(labels2.shape)} and ${JSON.stringify(logits.shape)}`);
  }
  return tidy(() => {
    const reluLogits = relu(logits);
    const negAbsLogits = neg(abs(logits));
    return add2(sub(reluLogits, mul(logits, labels2)), log1p(exp(negAbsLogits)));
  });
}
function binaryCrossentropy(yTrue, yPred) {
  return tidy(() => {
    let y2;
    y2 = clipByValue(yPred, epsilon(), 1 - epsilon());
    y2 = log5(div(y2, sub(1, y2)));
    return mean(sigmoidCrossEntropyWithLogits(yTrue, y2), -1);
  });
}
function kullbackLeiblerDivergence(yTrue, yPred) {
  return tidy(() => {
    const clippedTrue = clipByValue(yTrue, epsilon(), 1);
    const clippedPred = clipByValue(yPred, epsilon(), 1);
    return sum2(mul(yTrue, log5(div(clippedTrue, clippedPred))), -1);
  });
}
function poisson(yTrue, yPred) {
  return tidy(() => {
    const logPred = log5(add2(epsilon(), yPred));
    return mean(sub(yPred, mul(yTrue, logPred)), -1);
  });
}
function cosineProximity(yTrue, yPred) {
  return tidy(() => {
    const trueNormalized = l2Normalize(yTrue, -1);
    const predNormalized = l2Normalize(yPred, -1);
    const trueXPred = mul(trueNormalized, predNormalized);
    return neg(sum2(trueXPred, -1));
  });
}
var lossesMap = {
  meanSquaredError: meanSquaredError2,
  meanAbsoluteError,
  meanAbsolutePercentageError,
  meanSquaredLogarithmicError,
  squaredHinge,
  hinge,
  categoricalHinge,
  logcosh,
  categoricalCrossentropy,
  sparseCategoricalCrossentropy,
  binaryCrossentropy,
  kullbackLeiblerDivergence,
  poisson,
  cosineProximity
};
function get(identifierOrFn) {
  if (typeof identifierOrFn === "string") {
    if (identifierOrFn in lossesMap) {
      return lossesMap[identifierOrFn];
    }
    let errMsg = `Unknown loss ${identifierOrFn}`;
    if (identifierOrFn.toLowerCase().includes("softmaxcrossentropy")) {
      errMsg = `Unknown loss ${identifierOrFn}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`;
    }
    throw new ValueError(errMsg);
  } else {
    return identifierOrFn;
  }
}
function binaryAccuracy(yTrue, yPred) {
  return tidy(() => {
    const threshold3 = mul(0.5, onesLike(yPred));
    const yPredThresholded = cast2(greater(yPred, threshold3), yTrue.dtype);
    return mean(equal(yTrue, yPredThresholded), -1);
  });
}
function categoricalAccuracy(yTrue, yPred) {
  return tidy(() => cast2(equal(argMax(yTrue, -1), argMax(yPred, -1)), "float32"));
}
function truePositives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 1), equal(yPred, 1))), "float32");
  });
}
function falseNegatives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 1), equal(yPred, 0))), "float32");
  });
}
function falsePositives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 0), equal(yPred, 1))), "float32");
  });
}
function precision(yTrue, yPred) {
  return tidy(() => {
    const tp = truePositives(yTrue, yPred);
    const fp = falsePositives(yTrue, yPred);
    const denominator = add2(tp, fp);
    return cast(where(greater(denominator, 0), div(tp, denominator), 0), "float32");
  });
}
function recall(yTrue, yPred) {
  return tidy(() => {
    const tp = truePositives(yTrue, yPred);
    const fn = falseNegatives(yTrue, yPred);
    const denominator = add2(tp, fn);
    return cast(where(greater(denominator, 0), div(tp, denominator), 0), "float32");
  });
}
function binaryCrossentropy2(yTrue, yPred) {
  return binaryCrossentropy(yTrue, yPred);
}
function sparseCategoricalAccuracy(yTrue, yPred) {
  if (yTrue.rank === yPred.rank) {
    yTrue = squeeze(yTrue, [yTrue.rank - 1]);
  }
  yPred = argMax(yPred, -1);
  if (yPred.dtype !== yTrue.dtype) {
    yPred = cast(yPred, yTrue.dtype);
  }
  return cast(equal(yTrue, yPred), "float32");
}
var mse = meanSquaredError2;
var MSE = meanSquaredError2;
var mae = meanAbsoluteError;
var MAE = meanAbsoluteError;
var mape = meanAbsolutePercentageError;
var MAPE = meanAbsolutePercentageError;
var categoricalCrossentropy2 = categoricalCrossentropy;
var cosine = cosineProximity;
var sparseCategoricalCrossentropy2 = sparseCategoricalCrossentropy;
var metricsMap = {
  binaryAccuracy,
  categoricalAccuracy,
  precision,
  categoricalCrossentropy: categoricalCrossentropy2,
  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy2,
  mse,
  MSE,
  mae,
  MAE,
  mape,
  MAPE,
  cosine
};
function get2(identifier) {
  if (typeof identifier === "string" && identifier in metricsMap) {
    return metricsMap[identifier];
  } else if (typeof identifier !== "string" && identifier != null) {
    return identifier;
  } else {
    throw new ValueError(`Unknown metric ${identifier}`);
  }
}
function getLossOrMetricName(fn) {
  assert2(fn !== null, `Unknown LossOrMetricFn ${fn}`);
  if (typeof fn === "string") {
    return fn;
  } else {
    let fnName;
    for (const key of Object.keys(lossesMap)) {
      if (lossesMap[key] === fn) {
        fnName = key;
        break;
      }
    }
    if (fnName !== void 0) {
      return fnName;
    }
    for (const key of Object.keys(metricsMap)) {
      if (metricsMap[key] === fn) {
        fnName = key;
        break;
      }
    }
    if (fnName !== void 0) {
      return fnName;
    }
    return fn.name;
  }
}
function getOptimizer(identifier) {
  const optimizerMap = {
    "Adagrad": () => train.adagrad(0.01),
    "Adadelta": () => train.adadelta(1, 0.95, epsilon()),
    "Adam": () => train.adam(1e-3, 0.9, 0.999, epsilon()),
    "Adamax": () => train.adamax(2e-3, 0.9, 0.999, epsilon(), 0),
    "RMSProp": () => train.rmsprop(1e-3, 0.9, 0, epsilon()),
    "SGD": () => train.sgd(0.01)
  };
  optimizerMap["adagrad"] = optimizerMap["Adagrad"];
  optimizerMap["adadelta"] = optimizerMap["Adadelta"];
  optimizerMap["adam"] = optimizerMap["Adam"];
  optimizerMap["adamax"] = optimizerMap["Adamax"];
  optimizerMap["rmsprop"] = optimizerMap["RMSProp"];
  optimizerMap["sgd"] = optimizerMap["SGD"];
  if (identifier in optimizerMap) {
    return optimizerMap[identifier]();
  }
  throw new ValueError(`Unknown Optimizer ${identifier}`);
}
var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;
function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {
  if (userDefinedMetadata == null || typeof userDefinedMetadata !== "object" || Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype || !plainObjectCheck(userDefinedMetadata)) {
    throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
  }
  if (checkSize) {
    const out = JSON.stringify(userDefinedMetadata);
    if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {
      console.warn(`User-defined metadata of model "${modelName}" is too large in size (length=${out.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);
    }
  }
}
function plainObjectCheck(x2) {
  if (x2 === null) {
    return true;
  } else if (typeof x2 === "object") {
    if (Object.getPrototypeOf(x2) === Object.prototype) {
      const keys = Object.keys(x2);
      for (const key of keys) {
        if (typeof key !== "string") {
          return false;
        }
        if (!plainObjectCheck(x2[key])) {
          return false;
        }
      }
      return true;
    } else {
      if (Array.isArray(x2)) {
        for (const item of x2) {
          if (!plainObjectCheck(item)) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
  } else {
    const xType = typeof x2;
    return xType === "string" || xType === "number" || xType === "boolean";
  }
}
function printSummary(model22, lineLength, positions, printFn = console.log) {
  const sequentialLike = isModelSequentialLike(model22);
  const toDisplay = ["Layer (type)", "Output shape", "Param #"];
  if (sequentialLike) {
    lineLength = lineLength || 65;
    positions = positions || [0.45, 0.85, 1];
  } else {
    lineLength = lineLength || 98;
    positions = positions || [0.33, 0.55, 0.67, 1];
  }
  if (positions[positions.length - 1] <= 1) {
    positions = positions.map((p22) => Math.floor(lineLength * p22));
  }
  let relevantNodes;
  if (!sequentialLike) {
    toDisplay.push("Receives inputs");
    relevantNodes = [];
    for (const depth in model22.nodesByDepth) {
      relevantNodes.push(...model22.nodesByDepth[depth]);
    }
  }
  printFn("_".repeat(lineLength));
  printRow(toDisplay, positions, printFn);
  printFn("=".repeat(lineLength));
  const layers = model22.layers;
  for (let i2 = 0; i2 < layers.length; ++i2) {
    if (sequentialLike) {
      printLayerSummary(layers[i2], positions, printFn);
    } else {
      printLayerSummaryWithConnections(layers[i2], positions, relevantNodes, printFn);
    }
    printFn((i2 === layers.length - 1 ? "=" : "_").repeat(lineLength));
  }
  model22.checkTrainableWeightsConsistency();
  const trainableCount = countTrainableParams(model22);
  const nonTrainableCount = countParamsInWeights(model22.nonTrainableWeights);
  printFn(`Total params: ${trainableCount + nonTrainableCount}`);
  printFn(`Trainable params: ${trainableCount}`);
  printFn(`Non-trainable params: ${nonTrainableCount}`);
  printFn("_".repeat(lineLength));
}
function countTrainableParams(model22) {
  let trainableCount;
  if (model22.collectedTrainableWeights != null) {
    trainableCount = countParamsInWeights(model22.collectedTrainableWeights);
  } else {
    trainableCount = countParamsInWeights(model22.trainableWeights);
  }
  return trainableCount;
}
function isModelSequentialLike(model22) {
  let sequentialLike = true;
  const nodesByDepth = [];
  const nodes = [];
  for (const depth in model22.nodesByDepth) {
    nodesByDepth.push(model22.nodesByDepth[depth]);
  }
  for (const depthNodes of nodesByDepth) {
    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {
      sequentialLike = false;
      break;
    }
    nodes.push(...depthNodes);
  }
  if (sequentialLike) {
    for (const layer of model22.layers) {
      let flag = false;
      for (const node2 of layer.inboundNodes) {
        if (nodes.indexOf(node2) !== -1) {
          if (flag) {
            sequentialLike = false;
            break;
          } else {
            flag = true;
          }
        }
      }
      if (!sequentialLike) {
        break;
      }
    }
  }
  return sequentialLike;
}
function printRow(fields, positions, printFn = console.log) {
  let line = "";
  for (let i2 = 0; i2 < fields.length; ++i2) {
    if (i2 > 0) {
      line = line.slice(0, line.length - 1) + " ";
    }
    line += fields[i2];
    line = line.slice(0, positions[i2]);
    line += " ".repeat(positions[i2] - line.length);
  }
  printFn(line);
}
function printLayerSummary(layer, positions, printFn) {
  let outputShape;
  try {
    outputShape = JSON.stringify(layer.outputShape);
  } catch (err) {
    outputShape = "multiple";
  }
  const name = layer.name;
  const className = layer.getClassName();
  const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];
  printRow(fields, positions, printFn);
}
function printLayerSummaryWithConnections(layer, positions, relevantNodes, printFn) {
  let outputShape;
  try {
    outputShape = JSON.stringify(layer.outputShape);
  } catch (err) {
    outputShape = "multiple";
  }
  const connections = [];
  for (const node2 of layer.inboundNodes) {
    if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node2) === -1) {
      continue;
    }
    for (let i2 = 0; i2 < node2.inboundLayers.length; ++i2) {
      const inboundLayer = node2.inboundLayers[i2].name;
      const inboundLayerIndex = node2.nodeIndices[i2];
      const inboundTensorIndex = node2.tensorIndices[i2];
      connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);
    }
  }
  const name = layer.name;
  const className = layer.getClassName();
  const firstConnection = connections.length === 0 ? "" : connections[0];
  const fields = [
    `${name} (${className})`,
    outputShape,
    layer.countParams().toString(),
    firstConnection
  ];
  printRow(fields, positions, printFn);
  for (let i2 = 1; i2 < connections.length; ++i2) {
    printRow(["", "", "", connections[i2]], positions, printFn);
  }
}
function isArrayItemInputOrOutputName(key, index, value) {
  return (key === "inboundNodes" || key === "outputLayers" || key === "inputLayers") && index === 0 && typeof value === "string";
}
function convertPythonicToTs(pythonicConfig, key) {
  if (pythonicConfig === null) {
    return null;
  } else if (typeof pythonicConfig === "string") {
    return toCamelCase(pythonicConfig);
  } else if (typeof pythonicConfig === "number" || typeof pythonicConfig === "boolean") {
    return pythonicConfig;
  } else if (pythonicConfig instanceof Array) {
    const tsArray = [];
    const arrayLength = pythonicConfig.length;
    for (let i2 = 0; i2 < arrayLength; ++i2) {
      const item = pythonicConfig[i2];
      if (isArrayItemInputOrOutputName(key, i2, item)) {
        tsArray.push(item);
      } else {
        tsArray.push(convertPythonicToTs(item, key));
      }
    }
    return tsArray;
  } else {
    const tsDict = {};
    for (const pythonicKey of Object.keys(pythonicConfig)) {
      const pythonicValue = pythonicConfig[pythonicKey];
      if (pythonicKey === "name" && typeof pythonicValue === "string") {
        tsDict[pythonicKey] = pythonicValue;
      } else {
        const tsKey = toCamelCase(pythonicKey);
        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
      }
    }
    return tsDict;
  }
}
function convertTsToPythonic(tsConfig, key) {
  if (tsConfig === null || tsConfig === void 0) {
    return null;
  } else if (typeof tsConfig === "string") {
    return toSnakeCase(tsConfig);
  } else if (typeof tsConfig === "number" || typeof tsConfig === "boolean") {
    return tsConfig;
  } else if (tsConfig instanceof Array) {
    const pyArray = [];
    const arrayLength = tsConfig.length;
    for (let i2 = 0; i2 < arrayLength; ++i2) {
      const item = tsConfig[i2];
      if (isArrayItemInputOrOutputName(key, i2, item)) {
        pyArray.push(item);
      } else {
        pyArray.push(convertTsToPythonic(item, key));
      }
    }
    return pyArray;
  } else {
    const pyDict = {};
    for (const tsKey of Object.keys(tsConfig)) {
      const tsValue = tsConfig[tsKey];
      const pyKey = toSnakeCase(tsKey);
      if ((tsKey === "name" || tsKey === "className") && typeof tsValue === "string") {
        pyDict[pyKey] = tsValue;
      } else {
        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
      }
    }
    return pyDict;
  }
}
var version2 = "3.9.0";
function assertFeedCompatibility(key, val) {
  if (key.dtype == null || key.dtype === val.dtype) {
    return val;
  }
  try {
    return cast(val, key.dtype);
  } catch (err) {
    throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype of the key '${key.name}' (${key.dtype}).`);
  }
}
var FeedDict = class {
  constructor(feeds) {
    this.id2Value = {};
    this.id2Mask = {};
    this.name2Id = {};
    if (feeds instanceof FeedDict) {
      for (const id in feeds.id2Value) {
        this.id2Value[id] = feeds.id2Value[id];
        if (id in feeds.id2Mask) {
          this.id2Mask[id] = feeds.id2Mask[id];
        }
      }
    } else {
      if (feeds == null) {
        return;
      }
      for (const feed of feeds) {
        this.add(feed.key, feed.value);
      }
    }
  }
  add(key, value, mask) {
    if (this.id2Value[key.id] == null) {
      this.id2Value[key.id] = assertFeedCompatibility(key, value);
      this.name2Id[key.name] = key.id;
      if (mask != null) {
        this.id2Mask[key.id] = mask;
      }
    } else {
      throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);
    }
    return this;
  }
  addFeed(feed) {
    this.add(feed.key, feed.value);
  }
  hasKey(key) {
    return this.id2Value[key.id] != null;
  }
  names() {
    return Object.keys(this.name2Id);
  }
  getValue(key) {
    if (key instanceof SymbolicTensor) {
      if (this.id2Value[key.id] == null) {
        throw new ValueError(`Nonexistent key: ${key.name}`);
      } else {
        return this.id2Value[key.id];
      }
    } else {
      const id = this.name2Id[key];
      if (id == null) {
        throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
      }
      return this.id2Value[id];
    }
  }
  getMask(key) {
    if (key instanceof SymbolicTensor) {
      if (this.id2Value[key.id] == null) {
        throw new ValueError(`Nonexistent key: ${key.name}`);
      } else {
        return this.id2Mask[key.id];
      }
    } else {
      const id = this.name2Id[key];
      if (id == null) {
        throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
      }
      return this.id2Mask[id];
    }
  }
  disposeMasks() {
    if (this.id2Mask != null) {
      dispose(this.id2Mask);
    }
  }
};
var cachedSorted = {};
var cachedRecipientCounts = {};
function execute(fetches, feedDict, kwargs, probe) {
  const training = kwargs == null ? false : kwargs["training"];
  const arrayFetches = Array.isArray(fetches);
  const fetchArray = arrayFetches ? fetches : [fetches];
  const outputNames = fetchArray.map((t2) => t2.name);
  const finalOutputs = [];
  const feedNames = feedDict.names();
  for (const outputName of outputNames) {
    if (feedNames.indexOf(outputName) !== -1) {
      finalOutputs.push(feedDict.getValue(outputName));
    } else {
      finalOutputs.push(null);
    }
  }
  if (probe != null) {
    probe.maxNumTensors = -Infinity;
    probe.minNumTensors = Infinity;
  }
  const fetchAndFeedKey = outputNames.join(",") + "|" + feedDict.names().join(",");
  let sorted;
  let recipientCounts;
  if (cachedSorted[fetchAndFeedKey] == null) {
    const out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);
    sorted = out.sorted;
    recipientCounts = out.recipientCounts;
    cachedSorted[fetchAndFeedKey] = sorted;
    cachedRecipientCounts[fetchAndFeedKey] = recipientCounts;
  }
  sorted = cachedSorted[fetchAndFeedKey];
  recipientCounts = {};
  if (!training) {
    Object.assign(recipientCounts, cachedRecipientCounts[fetchAndFeedKey]);
  }
  const internalFeedDict = new FeedDict(feedDict);
  for (let i2 = 0; i2 < sorted.length; ++i2) {
    if (probe != null) {
      const numTensors = memory().numTensors;
      if (numTensors > probe.maxNumTensors) {
        probe.maxNumTensors = numTensors;
      }
      if (numTensors < probe.minNumTensors) {
        probe.minNumTensors = numTensors;
      }
    }
    const symbolic = sorted[i2];
    const srcLayer = symbolic.sourceLayer;
    if (srcLayer instanceof InputLayer) {
      continue;
    }
    const inputValues = [];
    const inputMasks = [];
    const tensorsToDispose = [];
    let maskExists = false;
    for (const input2 of symbolic.inputs) {
      const value = internalFeedDict.getValue(input2);
      const mask = internalFeedDict.getMask(input2);
      inputValues.push(value);
      inputMasks.push(mask);
      if (mask != null) {
        maskExists = true;
      }
      if (!training) {
        recipientCounts[input2.name]--;
        if (recipientCounts[input2.name] === 0 && !feedDict.hasKey(input2) && outputNames.indexOf(input2.name) === -1 && !value.isDisposed && input2.sourceLayer.stateful !== true) {
          tensorsToDispose.push(value);
        }
      }
    }
    if (maskExists) {
      kwargs = kwargs || {};
      kwargs["mask"] = inputMasks[0];
    }
    const outputTensors = toList(srcLayer.apply(inputValues, kwargs));
    let outputMask = null;
    if (srcLayer.supportsMasking) {
      outputMask = srcLayer.computeMask(inputValues, inputMasks);
    }
    const layerOutputs = getNodeOutputs(symbolic);
    const outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
    for (let i22 = 0; i22 < outputSymbolicTensors.length; ++i22) {
      if (!internalFeedDict.hasKey(outputSymbolicTensors[i22])) {
        internalFeedDict.add(outputSymbolicTensors[i22], outputTensors[i22], Array.isArray(outputMask) ? outputMask[0] : outputMask);
      }
      const index = outputNames.indexOf(outputSymbolicTensors[i22].name);
      if (index !== -1) {
        finalOutputs[index] = outputTensors[i22];
      }
    }
    if (!training) {
      dispose(tensorsToDispose);
    }
  }
  internalFeedDict.disposeMasks();
  return arrayFetches ? finalOutputs : finalOutputs[0];
}
function getTopologicalSortAndRecipientCounts(fetches, feedDict) {
  util_exports.assert(fetches != null && fetches.length > 0, () => `Expected at least one fetch, got none`);
  let finalSorted = [];
  let finalRecipientMap = {};
  if (fetches.length === 1) {
    const out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);
    finalSorted = out.sorted;
    finalRecipientMap = out.recipientMap;
  } else {
    const visited = new Set();
    for (const fetch4 of fetches) {
      const { sorted, recipientMap } = getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict);
      for (const symbolicTensor of sorted) {
        if (!visited.has(symbolicTensor.name)) {
          finalSorted.push(symbolicTensor);
          visited.add(symbolicTensor.name);
        }
      }
      for (const name in recipientMap) {
        if (finalRecipientMap[name] == null) {
          finalRecipientMap[name] = new Set();
        }
        recipientMap[name].forEach((recipient) => finalRecipientMap[name].add(recipient));
      }
    }
  }
  return {
    sorted: finalSorted,
    recipientCounts: recipientMap2Counts(finalRecipientMap)
  };
}
function recipientMap2Counts(recipientMap) {
  const recipientCounts = {};
  for (const name in recipientMap) {
    recipientCounts[name] = recipientMap[name].size;
  }
  return recipientCounts;
}
function getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict) {
  const visited = new Set();
  const sorted = [];
  const recipientMap = {};
  for (const key of feedDict.names()) {
    visited.add(key);
  }
  const stack2 = [];
  const marks = [];
  stack2.push(fetch4);
  while (stack2.length > 0) {
    const top = stack2[stack2.length - 1];
    if (visited.has(top.name)) {
      stack2.pop();
      continue;
    }
    const topIsMarked = marks[marks.length - 1] === stack2.length - 1;
    if (top.inputs.length === 0 || topIsMarked) {
      stack2.pop();
      sorted.push(top);
      visited.add(top.name);
      if (topIsMarked) {
        marks.pop();
      }
    } else {
      marks.push(stack2.length - 1);
      for (const input2 of top.inputs) {
        if (recipientMap[input2.name] == null) {
          recipientMap[input2.name] = new Set();
        }
        recipientMap[input2.name].add(top.name);
        if (visited.has(input2.name)) {
          continue;
        }
        stack2.push(input2);
      }
    }
  }
  return { sorted, recipientMap };
}
function getNodeOutputs(fetch4) {
  let layerOutputs;
  if (fetch4.sourceLayer.inboundNodes.length === 1) {
    layerOutputs = fetch4.sourceLayer.output;
  } else {
    let nodeIndex = null;
    for (let i2 = 0; i2 < fetch4.sourceLayer.inboundNodes.length; ++i2) {
      for (const outputTensor of fetch4.sourceLayer.inboundNodes[i2].outputTensors) {
        if (outputTensor.id === fetch4.id) {
          nodeIndex = i2;
          break;
        }
      }
    }
    layerOutputs = fetch4.sourceLayer.getOutputAt(nodeIndex);
  }
  return layerOutputs;
}
var Container = class extends Layer {
  constructor(args) {
    super({});
    this.containerNodes = new Set();
    this.name = args.name;
    if (this.name == null) {
      const prefix = this.getClassName().toLowerCase();
      this.name = getUid(prefix);
    }
    this.supportsMasking = false;
    this.trainable_ = true;
    if (Array.isArray(args.inputs)) {
      this.inputs = args.inputs.slice();
    } else {
      this.inputs = [args.inputs];
    }
    if (Array.isArray(args.outputs)) {
      this.outputs = args.outputs.slice();
    } else {
      this.outputs = [args.outputs];
    }
    if (unique2(this.inputs).length !== this.inputs.length) {
      throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x2) => x2.name)}`);
    }
    if (unique2(this.outputs).length !== this.outputs.length) {
      console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x2) => x2.name)}`);
    }
    this.inputLayers = [];
    this.inputLayersNodeIndices = [];
    this.inputLayersTensorIndices = [];
    this.outputLayers = [];
    this.outputLayersNodeIndices = [];
    this.outputLayersTensorIndices = [];
    this.layers = [];
    this.internalContainerRefs = [];
    for (const x2 of this.outputs) {
      const layer = x2.sourceLayer;
      const nodeIndex = x2.nodeIndex;
      const tensorIndex = x2.tensorIndex;
      this.outputLayers.push(layer);
      this.outputLayersNodeIndices.push(nodeIndex);
      this.outputLayersTensorIndices.push(tensorIndex);
    }
    for (const x2 of this.inputs) {
      const layer = x2.sourceLayer;
      const nodeIndex = x2.nodeIndex;
      const tensorIndex = x2.tensorIndex;
      assert2(nodeIndex === 0, "input layer has >1 nodes");
      assert2(tensorIndex === 0, "input layer has >1 tensors");
      this.inputLayers.push(layer);
      this.inputLayersNodeIndices.push(nodeIndex);
      this.inputLayersTensorIndices.push(tensorIndex);
    }
    this.inputNames = [];
    this.outputNames = [];
    this.feedInputShapes = [];
    this.feedInputNames = [];
    this.feedOutputNames = [];
    for (let i2 = 0; i2 < this.inputLayers.length; i2++) {
      const layer = this.inputLayers[i2];
      if (!(layer instanceof InputLayer)) {
        throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${args.inputs}. Input ${i2} (0-based) originates from layer type ${layer.getClassName()}.`);
      }
      this.inputNames.push(layer.name);
      this.feedInputShapes.push(layer.batchInputShape);
      this.feedInputNames.push(layer.name);
    }
    for (const layer of this.outputLayers) {
      this.outputNames.push(layer.name);
    }
    this.internalInputShapes = this.inputs.map((x2) => x2.shape);
    this.internalOutputShapes = this.outputs.map((x2) => x2.shape);
    const nodesDepths = {};
    const nodeIDToNode = {};
    const layersDepths = {};
    const layerIDToLayer = {};
    const layerIndices = {};
    const nodesInDecreasingDepth = [];
    const buildMapOfGraph = (tensor2, finishedNodes2, nodesInProgress2, layer, nodeIndex, tensorIndex) => {
      if (layer == null || nodeIndex == null || tensorIndex == null) {
        layer = tensor2.sourceLayer;
        nodeIndex = tensor2.nodeIndex;
        tensorIndex = tensor2.tensorIndex;
      }
      const node2 = layer.inboundNodes[nodeIndex];
      if (nodesInProgress2.indexOf(node2) !== -1) {
        throw new RuntimeError(`The tensor ${tensor2.name} at layer "${layer.name}" is part of a cycle.`);
      }
      if (finishedNodes2.indexOf(node2) !== -1) {
        return;
      }
      this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
      if (!(layer.id in layerIndices)) {
        layerIndices[layer.id] = Object.keys(layerIndices).length;
      }
      if (nodesInProgress2.indexOf(node2) === -1) {
        nodesInProgress2.push(node2);
      }
      const numInboundLayers = node2.inboundLayers.length;
      for (let i2 = 0; i2 < numInboundLayers; i2++) {
        const x2 = node2.inputTensors[i2];
        const layer2 = node2.inboundLayers[i2];
        const nodeIndex2 = node2.nodeIndices[i2];
        const tensorIndex2 = node2.tensorIndices[i2];
        buildMapOfGraph(x2, finishedNodes2, nodesInProgress2, layer2, nodeIndex2, tensorIndex2);
      }
      finishedNodes2.push(node2);
      while (nodesInProgress2.indexOf(node2) >= 0) {
        nodesInProgress2.splice(nodesInProgress2.indexOf(node2), 1);
      }
      nodesInDecreasingDepth.push(node2);
    };
    const finishedNodes = [];
    const nodesInProgress = [];
    for (const x2 of this.outputs) {
      buildMapOfGraph(x2, finishedNodes, nodesInProgress);
    }
    const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
    for (const node2 of reversedNodesInDecreasingDepth) {
      nodeIDToNode[node2.id] = node2;
      if (!(node2.id in nodesDepths)) {
        nodesDepths[node2.id] = 0;
      }
      let depth = nodesDepths[node2.id];
      const previousDepth = layersDepths[node2.outboundLayer.id] == null ? 0 : layersDepths[node2.outboundLayer.id];
      depth = Math.max(depth, previousDepth);
      layersDepths[node2.outboundLayer.id] = depth;
      layerIDToLayer[node2.outboundLayer.id] = node2.outboundLayer;
      nodesDepths[node2.id] = depth;
      for (let i2 = 0; i2 < node2.inboundLayers.length; i2++) {
        const inboundLayer = node2.inboundLayers[i2];
        const nodeIndex = node2.nodeIndices[i2];
        const inboundNode = inboundLayer.inboundNodes[nodeIndex];
        const previousDepth2 = nodesDepths[inboundNode.id] == null ? 0 : nodesDepths[inboundNode.id];
        nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth2);
        nodeIDToNode[inboundNode.id] = inboundNode;
      }
    }
    const nodesByDepth = {};
    for (const nodeID in nodesDepths) {
      const depth = nodesDepths[nodeID];
      if (!(depth in nodesByDepth)) {
        nodesByDepth[depth] = [];
      }
      nodesByDepth[depth].push(nodeIDToNode[nodeID]);
    }
    const layersByDepth = {};
    for (const layerID in layersDepths) {
      const depth = layersDepths[layerID];
      if (!(depth in layersByDepth)) {
        layersByDepth[depth] = [];
      }
      layersByDepth[depth].push(layerIDToLayer[layerID]);
    }
    let depthKeys = Object.keys(layersByDepth).map((x2) => parseInt(x2, 10)).sort(reverseNumberCompare);
    this.layers = [];
    for (const depth of depthKeys) {
      const layersForDepth = layersByDepth[depth];
      layersForDepth.sort((a6, b2) => {
        const aIndex = layerIndices[a6.id];
        const bIndex = layerIndices[b2.id];
        if (aIndex < bIndex) {
          return -1;
        }
        if (aIndex > bIndex) {
          return 1;
        }
        return 0;
      });
      for (const layer of layersForDepth) {
        if (layer instanceof Container) {
          this.internalContainerRefs.push(layer);
        }
        this.layers.push(layer);
      }
    }
    this.layersByDepth = layersByDepth;
    depthKeys = Object.keys(nodesByDepth).map((x2) => parseInt(x2, 10)).sort(reverseNumberCompare);
    const computableTensors = this.inputs.slice();
    const layersWithCompleteInput = [];
    for (const depth of depthKeys) {
      for (const node2 of nodesByDepth[depth]) {
        const layer = node2.outboundLayer;
        if (layer != null) {
          for (const x2 of node2.inputTensors) {
            if (computableTensors.indexOf(x2) === -1) {
              throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x2} at layer "${layer.name}". The following previous layers were accessed without issue: ${layersWithCompleteInput}`);
            }
          }
          for (const x2 of node2.outputTensors) {
            computableTensors.push(x2);
          }
          layersWithCompleteInput.push(layer.name);
        }
      }
    }
    this.nodesByDepth = nodesByDepth;
    const allNames = this.layers.map((x2) => x2.name);
    for (const name of allNames) {
      const numOccurrences = allNames.filter((x2) => x2 === name).length;
      if (numOccurrences !== 1) {
        throw new RuntimeError(`The name "${name}" is used ${numOccurrences} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(allNames));
      }
    }
    this.outboundNodes = [];
    this.inboundNodes = [];
    new Node2({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: this.inputs,
      outputTensors: this.outputs,
      inputMasks: this.inputs.map((x2) => null),
      outputMasks: this.outputs.map((x2) => null),
      inputShapes: this.inputs.map((x2) => x2.shape),
      outputShapes: this.outputs.map((x2) => x2.shape)
    });
    this.built = true;
    this._refCount = 1;
  }
  assertNotDisposed() {
    if (this._refCount === 0) {
      throw new Error(`Container '${this.name}' is already disposed.`);
    }
  }
  dispose() {
    this.assertNotDisposed();
    const result = { refCountAfterDispose: null, numDisposedVariables: 0 };
    if (--this._refCount === 0) {
      for (const layer of this.layers) {
        result.numDisposedVariables += layer.dispose().numDisposedVariables;
      }
      for (const container of this.internalContainerRefs) {
        result.numDisposedVariables += container.dispose().numDisposedVariables;
      }
    }
    result.refCountAfterDispose = this._refCount;
    return result;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(trainable) {
    this.layers.forEach((layer) => {
      layer._trainableWeights.forEach((w2) => w2.trainable = trainable);
    });
    this.trainable_ = trainable;
  }
  get trainableWeights() {
    if (this._trainableWeights.length > 0) {
      throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    }
    if (!this.trainable) {
      return [];
    }
    let weights = [];
    for (const layer of this.layers) {
      weights = weights.concat(layer.trainableWeights);
    }
    return weights;
  }
  get nonTrainableWeights() {
    const weights = [];
    for (const layer of this.layers) {
      weights.push(...layer.nonTrainableWeights);
    }
    if (!this.trainable) {
      const trainableWeights = [];
      for (const layer of this.layers) {
        trainableWeights.push(...layer.trainableWeights);
      }
      return trainableWeights.concat(weights);
    }
    return weights;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  loadWeights(weights, strict = true) {
    const nameToWeight = {};
    let totalWeightsCount = 0;
    for (const layer of this.layers) {
      for (const weight of layer.weights) {
        if (nameToWeight[weight.originalName] != null) {
          throw new ValueError(`Duplicate weight name: ${weight.originalName}`);
        }
        nameToWeight[weight.originalName] = weight;
        totalWeightsCount++;
      }
    }
    const weightValueTuples = [];
    for (const name in weights) {
      let validatedName = name;
      if (nameToWeight[name] == null) {
        const tokens = name.split("/");
        const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);
        validatedName = shortenNameArray.join("/");
      }
      if (nameToWeight[validatedName] != null) {
        weightValueTuples.push([nameToWeight[validatedName], weights[name]]);
      } else if (strict) {
        throw new ValueError(`Provided weight data has no target variable: ${name}`);
      }
      delete nameToWeight[validatedName];
    }
    if (strict) {
      const unsetNames = [];
      for (const name in nameToWeight) {
        unsetNames.push(name);
      }
      if (unsetNames.length > 0) {
        throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ${unsetNames}`);
      }
    }
    batchSetValue(weightValueTuples);
  }
  updatedConfig() {
    const theConfig = this.getConfig();
    const modelConfig = {};
    modelConfig["className"] = this.getClassName();
    modelConfig["config"] = theConfig;
    modelConfig["kerasVersion"] = `tfjs-layers ${version2}`;
    modelConfig["backend"] = "TensorFlow.js";
    return modelConfig;
  }
  toJSON(unused, returnString = true) {
    const modelConfig = convertTsToPythonic(this.updatedConfig());
    return returnString ? JSON.stringify(modelConfig) : modelConfig;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = toList(inputs);
      const feedDict = new FeedDict();
      for (let i2 = 0; i2 < this.inputs.length; ++i2) {
        feedDict.add(this.inputs[i2], inputs[i2]);
      }
      return execute(this.outputs, feedDict, kwargs);
    });
  }
  computeMask(inputs, mask) {
    return tidy(() => {
      inputs = toList(inputs);
      let masks;
      if (mask == null) {
        masks = pyListRepeat(null, inputs.length);
      } else {
        masks = toList(mask);
      }
      return this.runInternalGraph(inputs, masks)[1];
    });
  }
  computeOutputShape(inputShape) {
    const inputShapes = normalizeShapeList(inputShape);
    if (inputShapes.length !== this.inputLayers.length) {
      throw new ValueError(`Invalid inputShape argument ${inputShape}: model has ${this.inputLayers.length} tensor inputs.`);
    }
    const layersToOutputShapes = {};
    for (let i2 = 0; i2 < inputShapes.length; i2++) {
      const layer = this.inputLayers[i2];
      const inputShape2 = inputShapes[i2];
      const shapeKey = layer.name + "_0_0";
      layersToOutputShapes[shapeKey] = inputShape2;
    }
    const depthKeys = Object.keys(this.nodesByDepth).map((x2) => parseInt(x2, 10)).sort(reverseNumberCompare);
    if (depthKeys.length > 1) {
      for (const depth of depthKeys) {
        const nodes = this.nodesByDepth[depth];
        for (const node2 of nodes) {
          const layer = node2.outboundLayer;
          if (this.inputLayers.map((x2) => x2.id).indexOf(layer.id) !== -1) {
            continue;
          }
          const inputShapes2 = [];
          for (let j2 = 0; j2 < node2.inboundLayers.length; j2++) {
            const inboundLayer = node2.inboundLayers[j2];
            const nodeIndex2 = node2.nodeIndices[j2];
            const tensorIndex = node2.tensorIndices[j2];
            const shapeKey = `${inboundLayer.name}_${nodeIndex2}_${tensorIndex}`;
            const inputShape2 = layersToOutputShapes[shapeKey];
            inputShapes2.push(inputShape2);
          }
          const outputShape = layer.computeOutputShape(singletonOrArray(inputShapes2));
          const outputShapes2 = normalizeShapeList(outputShape);
          const nodeIndex = layer.inboundNodes.indexOf(node2);
          for (let j2 = 0; j2 < outputShapes2.length; j2++) {
            const shapeKey = `${layer.name}_${nodeIndex}_${j2}`;
            layersToOutputShapes[shapeKey] = outputShapes2[j2];
          }
        }
      }
    }
    const outputShapes = [];
    const outputShapeKeys = [];
    for (let i2 = 0; i2 < this.outputLayers.length; i2++) {
      const layer = this.outputLayers[i2];
      const nodeIndex = this.outputLayersNodeIndices[i2];
      const tensorIndex = this.outputLayersTensorIndices[i2];
      const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;
      outputShapeKeys.push(shapeKey);
    }
    for (let i2 = 0; i2 < outputShapeKeys.length; i2++) {
      const key = outputShapeKeys[i2];
      assert2(key in layersToOutputShapes);
      outputShapes.push(layersToOutputShapes[key]);
    }
    return singletonOrArray(outputShapes);
  }
  runInternalGraph(inputs, masks) {
    if (masks == null) {
      masks = pyListRepeat(null, inputs.length);
    }
    const tensorMap = {};
    for (let i2 = 0; i2 < this.inputs.length; ++i2) {
      const x2 = this.inputs[i2];
      const y2 = inputs[i2];
      const mask = masks[i2];
      tensorMap[x2.id] = [y2, mask];
    }
    const depthKeys = Object.keys(this.nodesByDepth).map((x2) => parseInt(x2, 10)).sort(reverseNumberCompare);
    for (const depth of depthKeys) {
      const nodes = this.nodesByDepth[depth];
      for (const node2 of nodes) {
        const layer = node2.outboundLayer;
        const referenceInputTensors = node2.inputTensors;
        const referenceOutputTensors = node2.outputTensors;
        const computedData = new Array();
        for (const x2 of referenceInputTensors) {
          if (x2.id in tensorMap) {
            computedData.push(tensorMap[x2.id]);
          }
        }
        if (computedData.length === referenceInputTensors.length) {
          let kwargs = {};
          let computedTensors;
          let computedMasks;
          let outputTensors2;
          let outputMasks2;
          if (node2.callArgs != null) {
            kwargs = node2.callArgs;
          }
          if (computedData.length === 1) {
            const [computedTensor, computedMask] = computedData[0];
            if (kwargs["mask"] == null) {
              kwargs["mask"] = computedMask;
            }
            outputTensors2 = toList(layer.call(computedTensor, kwargs));
            outputMasks2 = toList(layer.computeMask(computedTensor, computedMask));
            computedTensors = [computedTensor];
            computedMasks = [computedMask];
          } else {
            computedTensors = computedData.map((x2) => x2[0]);
            computedMasks = computedData.map((x2) => x2[1]);
            if (kwargs["mask"] == null) {
              kwargs["mask"] = computedMasks;
            }
            outputTensors2 = toList(layer.call(computedTensors, kwargs));
            outputMasks2 = toList(layer.computeMask(computedTensors, computedMasks));
          }
          if (layer.activityRegularizer) {
            throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
          }
          for (let i2 = 0; i2 < referenceOutputTensors.length; ++i2) {
            const x2 = referenceOutputTensors[i2];
            const y2 = outputTensors2[i2];
            const mask = outputMasks2[i2];
            tensorMap[x2.id] = [y2, mask];
          }
        }
      }
    }
    const outputTensors = [];
    const outputMasks = [];
    const outputShapes = [];
    for (const x2 of this.outputs) {
      assert2(x2.id in tensorMap, `Could not compute output ${x2.name} : ${x2.id}`);
      const [tensor2, mask] = tensorMap[x2.id];
      outputShapes.push(tensor2.shape);
      outputTensors.push(tensor2);
      outputMasks.push(mask);
    }
    return [outputTensors, outputMasks, outputShapes];
  }
  buildNodeConversionMap(layers) {
    const nodeConversionMap = {};
    let keptNodes;
    for (const layer of this.layers) {
      keptNodes = layer instanceof Container ? 1 : 0;
      for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
        const nodeKey = Container.nodeKey(layer, originalNodeIndex);
        if (this.containerNodes.has(nodeKey)) {
          nodeConversionMap[nodeKey] = keptNodes;
          keptNodes += 1;
        }
      }
    }
    return nodeConversionMap;
  }
  getLayer(name, index) {
    if (index != null) {
      if (this.layers.length <= index) {
        throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only has ${this.layers.length} layer(s).`);
      } else {
        return this.layers[index];
      }
    } else {
      if (name == null) {
        throw new ValueError("Provide either a layer name or layer index");
      }
    }
    for (const layer of this.layers) {
      if (layer.name === name) {
        return layer;
      }
    }
    throw new ValueError(`No such layer: ${name}`);
  }
  calculateLosses() {
    return tidy(() => {
      const losses4 = [];
      for (const layer of this.layers) {
        for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
          const nodeKey = Container.nodeKey(layer, nodeIndex);
          if (this.containerNodes.has(nodeKey)) {
            losses4.push(...layer.calculateLosses());
          }
        }
      }
      return losses4;
    });
  }
  getConfig() {
    const config3 = { name: this.name };
    const nodeConversionMap = this.buildNodeConversionMap(this.layers);
    const layerConfigs = [];
    for (const layer of this.layers) {
      const layerClassName = layer.getClassName();
      const layerConfig = layer.getConfig();
      const filteredInboundNodes = [];
      for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
        const node2 = layer.inboundNodes[originalNodeIndex];
        const nodeKey = Container.nodeKey(layer, originalNodeIndex);
        let kwargs = {};
        if (this.containerNodes.has(nodeKey)) {
          if (node2.callArgs) {
            try {
              JSON.stringify(node2.callArgs);
              kwargs = node2.callArgs;
            } catch (err) {
              console.warn(`Layer ${layer.name} was passed non-serializable keyword arguments: ${node2.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`);
              kwargs = {};
            }
          }
          if (node2.inboundLayers.length > 0) {
            const nodeData = [];
            for (let i2 = 0; i2 < node2.inboundLayers.length; i2++) {
              const inboundLayer = node2.inboundLayers[i2];
              const nodeIndex = node2.nodeIndices[i2];
              const tensorIndex = node2.tensorIndices[i2];
              const nodeKey2 = Container.nodeKey(inboundLayer, nodeIndex);
              let newNodeIndex = nodeConversionMap[nodeKey2];
              if (newNodeIndex == null) {
                newNodeIndex = 0;
              }
              nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
            }
            filteredInboundNodes.push(nodeData);
          }
        }
      }
      const dict = {};
      dict["name"] = layer.name;
      dict["className"] = layerClassName;
      dict["config"] = layerConfig;
      dict["inboundNodes"] = filteredInboundNodes;
      layerConfigs.push(dict);
    }
    config3["layers"] = layerConfigs;
    const modelInputs = [];
    for (let i2 = 0; i2 < this.inputLayers.length; i2++) {
      const layer = this.inputLayers[i2];
      const nodeIndex = this.inputLayersNodeIndices[i2];
      const nodeKey = Container.nodeKey(layer, nodeIndex);
      if (!this.containerNodes.has(nodeKey)) {
        continue;
      }
      let newNodeIndex = nodeConversionMap[nodeKey];
      if (newNodeIndex === null || newNodeIndex === void 0) {
        newNodeIndex = 0;
      }
      const tensorIndex = this.inputLayersTensorIndices[i2];
      modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
    }
    config3["inputLayers"] = modelInputs;
    const modelOutputs = [];
    for (let i2 = 0; i2 < this.outputLayers.length; i2++) {
      const layer = this.outputLayers[i2];
      const nodeIndex = this.outputLayersNodeIndices[i2];
      const nodeKey = Container.nodeKey(layer, nodeIndex);
      if (!this.containerNodes.has(nodeKey)) {
        continue;
      }
      let newNodeIndex = nodeConversionMap[nodeKey];
      if (newNodeIndex === null || newNodeIndex === void 0) {
        newNodeIndex = 0;
      }
      const tensorIndex = this.outputLayersTensorIndices[i2];
      modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
    }
    config3["outputLayers"] = modelOutputs;
    return config3;
  }
  static fromConfig(cls, config3, customObjects = {}, fastWeightInit = false) {
    const createdLayers = {};
    const unprocessedNodes = {};
    function addUnprocessedNode(layer, nodeData) {
      if (!(layer.name in unprocessedNodes)) {
        unprocessedNodes[layer.name] = [nodeData];
      } else {
        unprocessedNodes[layer.name].push(nodeData);
      }
    }
    function processNode(layer, nodeData) {
      const inputTensors2 = [];
      let kwargs;
      for (const inputData of nodeData) {
        const inboundLayerName = inputData[0];
        const inboundNodeIndex = inputData[1];
        const inboundTensorIndex = inputData[2];
        kwargs = inputData[3] == null ? {} : inputData[3];
        if (!(inboundLayerName in createdLayers)) {
          addUnprocessedNode(layer, nodeData);
          return;
        }
        const inboundLayer = createdLayers[inboundLayerName];
        if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
          addUnprocessedNode(layer, nodeData);
          return;
        }
        const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
        inputTensors2.push(inboundNode.outputTensors[inboundTensorIndex]);
      }
      if (inputTensors2.length > 0) {
        layer.apply(singletonOrArray(inputTensors2), kwargs);
      }
    }
    function processLayer(layerData) {
      const layerName = layerData["name"];
      const layer = deserialize(layerData, config3["customObjects"] != null ? config3["customObjects"] : {});
      layer.setFastWeightInitDuringBuild(fastWeightInit);
      createdLayers[layerName] = layer;
      const inboundNodesData = layerData["inboundNodes"];
      inboundNodesData.forEach((nodeData) => {
        if (!(nodeData instanceof Array)) {
          throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);
        }
        addUnprocessedNode(layer, nodeData);
      });
    }
    const name = config3["name"];
    const layersFromConfig = config3["layers"];
    for (const layerData of layersFromConfig) {
      processLayer(layerData);
    }
    while (!isObjectEmpty(unprocessedNodes)) {
      for (const layerData of layersFromConfig) {
        const layer = createdLayers[layerData["name"]];
        if (layer.name in unprocessedNodes) {
          const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];
          delete unprocessedNodes[layer.name];
          for (const nodeData of currentUnprocessedNodesForLayer) {
            processNode(layer, nodeData);
          }
        }
      }
    }
    const inputTensors = [];
    const outputTensors = [];
    const inputLayersFromConfig = config3["inputLayers"];
    for (const layerData of inputLayersFromConfig) {
      const layerName = layerData[0];
      const nodeIndex = layerData[1];
      const tensorIndex = layerData[2];
      assert2(layerName in createdLayers);
      const layer = createdLayers[layerName];
      const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
      inputTensors.push(layerOutputTensors[tensorIndex]);
    }
    const outputLayersFromConfig = config3["outputLayers"];
    for (const layerData of outputLayersFromConfig) {
      const layerName = layerData[0];
      const nodeIndex = layerData[1];
      const tensorIndex = layerData[2];
      assert2(layerName in createdLayers);
      const layer = createdLayers[layerName];
      const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
      outputTensors.push(layerOutputTensors[tensorIndex]);
    }
    return new cls({ inputs: inputTensors, outputs: outputTensors, name });
  }
  get stateful() {
    if (this._stateful) {
      throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
    }
    for (const layer of this.layers) {
      if (layer.stateful) {
        return true;
      }
    }
    return false;
  }
  resetStates() {
    tidy(() => {
      this.layers.forEach((layer) => {
        if (layer.stateful) {
          layer.resetStates();
        }
      });
    });
  }
};
function standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {
  const numOutputs = outputNames.length;
  if (xWeight == null || Array.isArray(xWeight) && xWeight.length === 0) {
    return outputNames.map((name) => null);
  }
  if (numOutputs === 1) {
    if (Array.isArray(xWeight) && xWeight.length === 1) {
      return xWeight;
    } else if (typeof xWeight === "object" && outputNames[0] in xWeight) {
      return [xWeight[outputNames[0]]];
    } else {
      return [xWeight];
    }
  }
  if (Array.isArray(xWeight)) {
    if (xWeight.length !== numOutputs) {
      throw new Error(`Provided ${weightType} is an array of ${xWeight.length} element(s), but the model has ${numOutputs} outputs. Make sure a set of weights is provided for each model output.`);
    }
    return xWeight;
  } else if (typeof xWeight === "object" && Object.keys(xWeight).length > 0 && typeof xWeight[Object.keys(xWeight)[0]] === "object") {
    const output = [];
    outputNames.forEach((outputName) => {
      if (outputName in xWeight) {
        output.push(xWeight[outputName]);
      } else {
        output.push(null);
      }
    });
    return output;
  } else {
    throw new Error(`The model has multiple (${numOutputs}) outputs, so ${weightType} must be either an array with ${numOutputs} elements or an object with ${outputNames} keys. Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);
  }
}
function standardizeClassWeights(classWeight, outputNames) {
  return standardizeSampleOrClassWeights(classWeight, outputNames, "classWeight");
}
async function standardizeWeights(y2, sampleWeight, classWeight, sampleWeightMode) {
  if (sampleWeight != null || sampleWeightMode != null) {
    throw new Error("Support sampleWeight is not implemented yet");
  }
  if (classWeight != null) {
    const yClasses = tidy(() => {
      if (y2.shape.length === 1) {
        return clone(y2);
      } else if (y2.shape.length === 2) {
        if (y2.shape[1] > 1) {
          const axis = 1;
          return argMax(y2, axis);
        } else if (y2.shape[1] === 1) {
          return reshape(y2, [y2.shape[0]]);
        } else {
          throw new Error(`Encountered unexpected last-dimension size (${y2.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
        }
      } else {
        throw new Error(`Unexpected rank of target (y) tensor (${y2.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
      }
    });
    const yClassIndices = Array.from(await yClasses.data());
    dispose(yClasses);
    const classSampleWeight = [];
    yClassIndices.forEach((classIndex) => {
      if (classWeight[classIndex] == null) {
        throw new Error(`classWeight must contain all classes in the training data. The class ${classIndex} exists in the data but not in classWeight`);
      } else {
        classSampleWeight.push(classWeight[classIndex]);
      }
    });
    return tensor1d(classSampleWeight, "float32");
  } else {
    return null;
  }
}
function computeWeightedLoss2(losses4, sampleWeights) {
  return mul(losses4, sampleWeights);
}
var DEFAULT_VALIDATION_BATCH_SIZE = 32;
function standardizeDataIteratorOutput(model22, iteratorOut) {
  let xs;
  let ys;
  const iteratorOutObj = iteratorOut;
  xs = iteratorOutObj["xs"];
  ys = iteratorOutObj["ys"];
  util_exports.assert(xs != null && ys != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${iteratorOut}`);
  const flattenedXs = flattenTensorOrArrayOrMap("input", model22.inputNames, xs);
  const flattenedYs = flattenTensorOrArrayOrMap("output", model22.outputNames, ys);
  const batchSize = flattenedXs[0].shape[0];
  util_exports.assert(flattenedXs.length === model22.inputs.length, () => `LayersModel has ${model22.inputs.length} inputs, but the dataset provides ${flattenedXs.length} inputs.  (Expected input keys: ${JSON.stringify(model22.inputNames)})`);
  util_exports.assert(flattenedYs.length === model22.outputs.length, () => `LayersModel has ${model22.outputs.length} outputs, but the dataset provides ${flattenedYs.length} outputs.  (Expected output keys: ${JSON.stringify(model22.outputNames)})`);
  for (let xIndex = 0; xIndex < flattenedXs.length; xIndex++) {
    util_exports.assert(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ${model22.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; expected  ${batchSize} based on input ${model22.inputNames[0]}.`);
  }
  for (let yIndex = 0; yIndex < flattenedYs.length; yIndex++) {
    util_exports.assert(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ${model22.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; expected  ${batchSize} based on input ${model22.inputNames[0]}.`);
  }
  return { xs: flattenedXs, ys: flattenedYs };
}
function flattenTensorOrArrayOrMap(inputOrOutput, names, values) {
  if (values instanceof Tensor) {
    return [values];
  } else if (Array.isArray(values)) {
    util_exports.assert(values.length === names.length, () => `Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);
    return values;
  } else {
    const result = [];
    for (const name of names) {
      if (values[name] == null) {
        throw new ValueError(`The feature data generated by the dataset lacks the required ${inputOrOutput} key '${name}'.`);
      }
      result.push(values[name]);
    }
    return result;
  }
}
function standardizeTensorValidationData(data) {
  if (data.length === 3) {
    throw new NotImplementedError("Validation with sample weights is not implemented yet.");
  }
  return { xs: data[0], ys: data[1] };
}
async function fitDataset(model22, dataset, args) {
  const hasBatchesPerEpoch = args.batchesPerEpoch != null;
  util_exports.assert(model22.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).");
  util_exports.assert(args != null, () => `For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.`);
  util_exports.assert(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${args.epochs}`);
  util_exports.assert(!hasBatchesPerEpoch || args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${args.batchesPerEpoch}`);
  util_exports.assert(args["validationSplit"] == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.");
  if (model22.isTraining) {
    throw new Error("Cannot start training because another fit() call is ongoing.");
  }
  model22.isTraining = true;
  try {
    const doValidation = args.validationData != null;
    let valXs;
    let valYs;
    if (doValidation) {
      if (isDatasetObject(args.validationData)) {
        util_exports.assert(args.validationBatches == null || args.validationBatches > 0 && Number.isInteger(args.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${args.validationBatches}`);
      } else {
        const validationData = standardizeTensorValidationData(args.validationData);
        valXs = validationData.xs;
        valYs = validationData.ys;
      }
    }
    const trainFunction = model22.makeTrainFunction();
    const outLabels = model22.getDedupedMetricsNames();
    let callbackMetrics;
    if (doValidation) {
      callbackMetrics = outLabels.slice().concat(outLabels.map((n2) => "val_" + n2));
    } else {
      callbackMetrics = outLabels.slice();
    }
    const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
    const verbose = args.verbose == null ? 1 : args.verbose;
    const { callbackList, history } = configureCallbacks(callbacks2, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, doValidation, callbackMetrics);
    callbackList.setModel(model22);
    model22.history = history;
    await callbackList.onTrainBegin();
    model22.stopTraining_ = false;
    let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;
    let dataIterator = await dataset.iterator();
    while (epoch < args.epochs) {
      const epochLogs = {};
      await callbackList.onEpochBegin(epoch);
      let stepsDone = 0;
      let batchIndex = 0;
      if (!hasBatchesPerEpoch) {
        dataIterator = await dataset.iterator();
      }
      while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {
        const iteratorOut = await dataIterator.next();
        if (hasBatchesPerEpoch && iteratorOut.done) {
          console.warn(`You provided \`batchesPerEpoch\` as ${args.batchesPerEpoch}, but your dataset iterator ran out of data after ${stepsDone} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${args.batchesPerEpoch * args.epochs} batches). You may need to use the repeat() function when building your dataset.`);
          break;
        }
        if (iteratorOut.value != null) {
          const { xs, ys } = standardizeDataIteratorOutput(model22, iteratorOut.value);
          const batchLogs = {};
          batchLogs["batch"] = batchIndex;
          batchLogs["size"] = xs[0].shape[0];
          await callbackList.onBatchBegin(batchIndex, batchLogs);
          const sampleWeights = [];
          if (args.classWeight != null) {
            const standardClassWeights = standardizeClassWeights(args.classWeight, model22.outputNames);
            for (let i2 = 0; i2 < standardClassWeights.length; ++i2) {
              sampleWeights.push(await standardizeWeights(ys[i2], null, standardClassWeights[i2]));
            }
          }
          const ins = xs.concat(ys).concat(sampleWeights);
          const outs = trainFunction(ins);
          dispose(ins);
          for (let i2 = 0; i2 < outLabels.length; ++i2) {
            const label = outLabels[i2];
            const out = outs[i2];
            batchLogs[label] = out;
            keep(out);
          }
          await callbackList.onBatchEnd(batchIndex, batchLogs);
          disposeTensorsInLogs(batchLogs);
          batchIndex++;
          stepsDone++;
        }
        if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch : iteratorOut.done) {
          if (doValidation) {
            let valOuts;
            if (isDatasetObject(args.validationData)) {
              valOuts = toList(await model22.evaluateDataset(args.validationData, { batches: args.validationBatches }));
            } else {
              valOuts = toList(model22.evaluate(valXs, valYs, {
                batchSize: args.validationBatchSize == null ? DEFAULT_VALIDATION_BATCH_SIZE : args.validationBatchSize,
                verbose: 0
              }));
            }
            for (let i2 = 0; i2 < model22.metricsNames.length; ++i2) {
              epochLogs[`val_${model22.metricsNames[i2]}`] = valOuts[i2];
            }
          }
          break;
        }
        if (model22.stopTraining_) {
          break;
        }
      }
      await callbackList.onEpochEnd(epoch, epochLogs);
      epoch++;
      if (model22.stopTraining_) {
        break;
      }
    }
    await callbackList.onTrainEnd();
    await model22.history.syncData();
    return model22.history;
  } finally {
    model22.isTraining = false;
  }
}
function getStepsPerEpoch(dataset, args) {
  let stepsPerEpoch = null;
  if (args.batchesPerEpoch != null) {
    stepsPerEpoch = args.batchesPerEpoch;
  } else if (Number.isFinite(dataset.size)) {
    stepsPerEpoch = dataset.size;
  }
  return stepsPerEpoch;
}
function isDatasetObject(dataset) {
  return typeof dataset.iterator === "function";
}
function isLazyIteratorObject(iterator) {
  return typeof iterator.next === "function";
}
async function evaluateDataset(model22, dataset, args) {
  args = args || {};
  const hasBatches = args.batches != null;
  const f2 = model22.testFunction;
  let outs = [];
  if (args.verbose > 0) {
    throw new NotImplementedError("Verbose mode is not implemented yet.");
  }
  util_exports.assert(!hasBatches || args.batches > 0 && Number.isInteger(args.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(args.batches)}`);
  const dataIterator = isLazyIteratorObject(dataset) ? dataset : await dataset.iterator();
  let numExamples = 0;
  let batch = 0;
  while (hasBatches ? batch < args.batches : true) {
    const iteratorOut = await dataIterator.next();
    outs = tidy(() => {
      if (iteratorOut.value) {
        const { xs, ys } = standardizeDataIteratorOutput(model22, iteratorOut.value);
        const xsAndYs = xs.concat(ys);
        const batchOuts = tidy(() => f2(xsAndYs));
        dispose(xsAndYs);
        if (batch === 0) {
          for (let i2 = 0; i2 < batchOuts.length; ++i2) {
            outs.push(scalar(0));
          }
        }
        const batchSize = xsAndYs[0].shape[0];
        for (let i2 = 0; i2 < batchOuts.length; ++i2) {
          const batchOut = batchOuts[i2];
          const oldScalar = outs[i2];
          outs[i2] = tidy(() => add2(outs[i2], mul(batchSize, batchOut)));
          if (batch > 0) {
            dispose(oldScalar);
          }
        }
        dispose(batchOuts);
        numExamples += batchSize;
        ++batch;
      }
      return outs;
    });
    if (iteratorOut.done) {
      if (hasBatches) {
        console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${args.batches} batches). You may need to use the repeat() function when building your dataset.`);
      }
      break;
    }
  }
  for (let i2 = 0; i2 < outs.length; ++i2) {
    const oldScalar = outs[i2];
    outs[i2] = div(outs[i2], numExamples);
    dispose(oldScalar);
  }
  return singletonOrArray(outs);
}
function checkBatchSize(batchSize) {
  util_exports.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
}
function sliceArrays(arrays, start, stop) {
  if (arrays == null) {
    return [null];
  } else if (Array.isArray(arrays)) {
    return arrays.map((array2) => sliceAlongFirstAxis(array2, start, stop - start));
  } else {
    return sliceAlongFirstAxis(arrays, start, stop - start);
  }
}
function sliceArraysByIndices(arrays, indices) {
  return tidy(() => {
    if (arrays == null) {
      return null;
    } else if (Array.isArray(arrays)) {
      return arrays.map((array2) => sliceArraysByIndices(array2, indices));
    } else {
      return gather2(arrays, indices.dtype === "int32" ? indices : cast(indices, "int32"));
    }
  });
}
function makeBatches(size2, batchSize) {
  const output = [];
  let batchStart = 0;
  let batchEnd = null;
  while (batchStart < size2) {
    batchEnd = batchStart + batchSize;
    if (batchEnd >= size2) {
      batchEnd = size2;
    }
    output.push([batchStart, batchEnd]);
    batchStart = batchEnd;
  }
  return output;
}
async function fitLoop(model22, f2, ins, outLabels, batchSize, epochs, verbose, callbacks2, valF, valIns, shuffle2, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
  if (batchSize == null) {
    batchSize = 32;
  }
  if (epochs == null) {
    epochs = 1;
  }
  if (shuffle2 == null) {
    shuffle2 = true;
  }
  if (initialEpoch == null) {
    initialEpoch = 0;
  }
  let doValidation = false;
  if (valF != null && valIns != null) {
    doValidation = true;
  }
  if (validationSteps != null) {
    doValidation = true;
    if (stepsPerEpoch == null) {
      throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
    }
  }
  const numTrainSamples = model22.checkNumSamples(ins, batchSize, stepsPerEpoch, "steps_per_epoch");
  let indexArray;
  if (numTrainSamples != null) {
    indexArray = range2(0, numTrainSamples);
  }
  if (verbose == null) {
    verbose = 1;
  }
  const { callbackList, history } = configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);
  callbackList.setModel(model22);
  model22.history = history;
  await callbackList.onTrainBegin();
  model22.stopTraining_ = false;
  for (let epoch = initialEpoch; epoch < epochs; ++epoch) {
    await callbackList.onEpochBegin(epoch);
    const epochLogs = {};
    if (stepsPerEpoch != null) {
      throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
    } else {
      if (shuffle2 === "batch") {
        throw new NotImplementedError("batch shuffling is not implemneted yet");
      } else if (shuffle2) {
        util_exports.shuffle(indexArray);
      }
      const epochIndexArray1D = tensor1d(indexArray);
      const batches = makeBatches(numTrainSamples, batchSize);
      for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
        const batchLogs = {};
        await callbackList.onBatchBegin(batchIndex, batchLogs);
        tidy(() => {
          const batchStart = batches[batchIndex][0];
          const batchEnd = batches[batchIndex][1];
          const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);
          batchLogs["batch"] = batchIndex;
          batchLogs["size"] = batchEnd - batchStart;
          const insBatch = sliceArraysByIndices(ins, batchIds);
          const outs = f2(insBatch);
          for (let i2 = 0; i2 < outLabels.length; ++i2) {
            const label = outLabels[i2];
            const out = outs[i2];
            batchLogs[label] = out;
            keep(out);
          }
          if (batchIndex === batches.length - 1) {
            if (doValidation) {
              const valOuts = model22.testLoop(valF, valIns, batchSize);
              for (let i2 = 0; i2 < outLabels.length; ++i2) {
                const label = outLabels[i2];
                const out = valOuts[i2];
                keep(out);
                epochLogs["val_" + label] = out;
              }
            }
          }
        });
        await callbackList.onBatchEnd(batchIndex, batchLogs);
        disposeTensorsInLogs(batchLogs);
        if (model22.stopTraining_) {
          break;
        }
      }
      epochIndexArray1D.dispose();
    }
    await callbackList.onEpochEnd(epoch, epochLogs);
    if (model22.stopTraining_) {
      break;
    }
  }
  await callbackList.onTrainEnd();
  await model22.history.syncData();
  return model22.history;
}
async function fitTensors(model22, x2, y2, args = {}) {
  if (model22.isTraining) {
    throw new Error("Cannot start training because another fit() call is ongoing.");
  }
  model22.isTraining = true;
  let inputs;
  let targets;
  let inputValX;
  let inputValY;
  let valX;
  let valY;
  let sampleWeights;
  try {
    const batchSize = args.batchSize == null ? 32 : args.batchSize;
    checkBatchSize(batchSize);
    const checkBatchAxis = false;
    const standardizedOuts = await model22.standardizeUserData(x2, y2, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);
    inputs = standardizedOuts[0];
    targets = standardizedOuts[1];
    sampleWeights = standardizedOuts[2];
    let doValidation = false;
    let valIns;
    if (args.validationData != null && args.validationData.length > 0) {
      doValidation = true;
      if (args.validationData.length === 2) {
        inputValX = args.validationData[0];
        inputValY = args.validationData[1];
      } else if (args.validationData.length === 3) {
        throw new NotImplementedError("validationData including sample weights is not supported yet.");
      } else {
        throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${args.validationData} is invalid.`);
      }
      const checkBatchAxis2 = true;
      const valStandardized = await model22.standardizeUserData(inputValX, inputValY, null, null, checkBatchAxis2, batchSize);
      valX = valStandardized[0];
      valY = valStandardized[1];
      valIns = valX.concat(valY);
    } else if (args.validationSplit != null && args.validationSplit > 0 && args.validationSplit < 1) {
      doValidation = true;
      const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));
      const originalBatchSize = inputs[0].shape[0];
      valX = sliceArrays(inputs, splitAt, originalBatchSize);
      inputs = sliceArrays(inputs, 0, splitAt);
      valY = sliceArrays(targets, splitAt, originalBatchSize);
      targets = sliceArrays(targets, 0, splitAt);
      valIns = valX.concat(valY);
    } else if (args.validationSteps != null) {
      doValidation = true;
    }
    const ins = inputs.concat(targets).concat(sampleWeights);
    model22.checkTrainableWeightsConsistency();
    const trainFunction = model22.makeTrainFunction();
    const outLabels = model22.getDedupedMetricsNames();
    let valFunction;
    let callbackMetrics;
    if (doValidation) {
      model22.makeTestFunction();
      valFunction = model22.testFunction;
      callbackMetrics = outLabels.slice().concat(outLabels.map((n2) => "val_" + n2));
    } else {
      valFunction = null;
      valIns = [];
      callbackMetrics = outLabels.slice();
    }
    const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
    const out = await fitLoop(model22, trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks2, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);
    return out;
  } finally {
    model22.isTraining = false;
    disposeNewTensors(inputs, x2);
    disposeNewTensors(targets, y2);
    disposeNewTensors(valX, inputValX);
    disposeNewTensors(valY, inputValY);
    if (sampleWeights != null) {
      dispose(sampleWeights);
    }
  }
}
function ensureTensorsRank2OrHigher(tensors) {
  const outs = [];
  if (tensors instanceof Tensor) {
    tensors = [tensors];
  }
  for (let i2 = 0; i2 < tensors.length; ++i2) {
    const tensor2 = tensors[i2];
    if (tensor2.rank === 1) {
      outs.push(expandDims2(tensor2, 1));
    } else if (tensor2.rank === 0) {
      throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
    } else {
      outs.push(tensor2);
    }
  }
  return outs;
}
function disposeNewTensors(tensors, refTensors) {
  if (tensors == null) {
    return;
  }
  const oldTensorIds = [];
  if (refTensors instanceof Tensor) {
    oldTensorIds.push(refTensors.id);
  } else if (Array.isArray(refTensors)) {
    refTensors.forEach((t2) => oldTensorIds.push(t2.id));
  } else if (refTensors != null) {
    for (const name in refTensors) {
      const oldTensor = refTensors[name];
      oldTensorIds.push(oldTensor.id);
    }
  }
  const tensorsToDispose = [];
  if (tensors instanceof Tensor) {
    if (oldTensorIds.indexOf(tensors.id) === -1) {
      tensorsToDispose.push(tensors);
    }
  } else if (Array.isArray(tensors)) {
    tensors.forEach((t2) => {
      if (oldTensorIds.indexOf(t2.id) === -1) {
        tensorsToDispose.push(t2);
      }
    });
  } else if (tensors != null) {
    for (const name in tensors) {
      const tensor2 = tensors[name];
      if (oldTensorIds.indexOf(tensor2.id) === -1) {
        tensorsToDispose.push(tensor2);
      }
    }
  }
  tensorsToDispose.forEach((t2) => {
    if (!t2.isDisposed) {
      t2.dispose();
    }
  });
}
function isDataTensor(x2) {
  return x2 instanceof Tensor;
}
function isDataArray(x2) {
  return Array.isArray(x2);
}
function isDataDict(x2) {
  return !isDataTensor(x2) && !isDataArray(x2);
}
function standardizeInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
  if (names == null || names.length === 0) {
    if (data != null) {
      let gotUnexpectedData = false;
      if (isDataArray(data) && data.length > 0) {
        gotUnexpectedData = true;
      } else if (isDataDict(data)) {
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            gotUnexpectedData = true;
            break;
          }
        }
      } else {
        gotUnexpectedData = true;
      }
      if (gotUnexpectedData) {
        throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, but got ${data}`);
      }
    }
    return [];
  }
  if (data == null) {
    return names.map((name) => null);
  }
  let arrays;
  if (isDataDict(data)) {
    data = data;
    arrays = [];
    for (const name of names) {
      if (data[name] == null) {
        throw new ValueError(`No data provided for "${name}". Need data for each key in: ${names}`);
      }
      arrays.push(data[name]);
    }
  } else if (isDataArray(data)) {
    data = data;
    if (data.length !== names.length) {
      throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${names.length} Tensor(s), but instead got the following list of Tensor(s): ${data}`);
    }
    arrays = data;
  } else {
    data = data;
    if (names.length > 1) {
      throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${data.shape}`);
    }
    arrays = [data];
  }
  arrays = ensureTensorsRank2OrHigher(arrays);
  if (shapes != null) {
    for (let i2 = 0; i2 < names.length; ++i2) {
      if (shapes[i2] == null) {
        continue;
      }
      const array2 = arrays[i2];
      if (array2.shape.length !== shapes[i2].length) {
        throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i2]} to have ${shapes[i2].length} dimension(s). but got array with shape ${array2.shape}`);
      }
      for (let j2 = 0; j2 < shapes[i2].length; ++j2) {
        if (j2 === 0 && !checkBatchAxis) {
          continue;
        }
        const dim = array2.shape[j2];
        const refDim = shapes[i2][j2];
        if (refDim != null && refDim >= 0 && dim !== refDim) {
          throw new ValueError(`${exceptionPrefix} expected a batch of elements where each example has shape [${shapes[i2].slice(1, shapes[i2].length)}] (i.e.,tensor shape [*,${shapes[i2].slice(1, shapes[i2].length)}]) but the ${exceptionPrefix} received an input with ${array2.shape[0]} examples, each with shape [${array2.shape.slice(1, array2.shape.length)}] (tensor shape [${array2.shape}])`);
        }
      }
    }
  }
  return arrays;
}
function checkArrayLengths(inputs, targets, weights) {
  const setX = unique2(inputs.map((input2) => input2.shape[0]));
  setX.sort();
  const setY = unique2(targets.map((target) => target.shape[0]));
  setY.sort();
  if (setX.length > 1) {
    throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(inputs.map((input2) => input2.shape))}`);
  }
  if (setY.length > 1) {
    throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(targets.map((target) => target.shape))}`);
  }
  if (setX.length > 0 && setY.length > 0 && !util_exports.arraysEqual(setX, setY)) {
    throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target sample(s).`);
  }
}
function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
  const keyLosses = [
    meanSquaredError2,
    binaryCrossentropy,
    categoricalCrossentropy
  ];
  for (let i2 = 0; i2 < targets.length; ++i2) {
    const y2 = targets[i2];
    const loss = lossFns[i2];
    const shape = outputShapes[i2];
    if (loss == null) {
      continue;
    }
    if (loss === categoricalCrossentropy) {
      if (y2.shape[y2.shape.length - 1] === 1) {
        throw new ValueError(`You are passing a target array of shape ${y2.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
      }
    }
    if (keyLosses.indexOf(loss) !== -1) {
      const slicedYShape = y2.shape.slice(1);
      const slicedShape = shape.slice(1);
      for (let j2 = 0; j2 < slicedYShape.length; ++j2) {
        const targetDim = slicedYShape[j2];
        const outDim = slicedShape[j2];
        if (outDim != null && targetDim !== outDim) {
          throw new ValueError(`A target Tensor with shape ${y2.shape} was passed for an output of shape ${shape}, while using a loss function that expects targets to have the same shape as the output.`);
        }
      }
    }
  }
}
function checkInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
  let arrays;
  if (Array.isArray(data)) {
    if (data.length !== names.length) {
      throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${names.length} Tensor(s), but instead got ${data.length} Tensors(s).`);
    }
    arrays = data;
  } else {
    if (names.length > 1) {
      throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(data.shape)}.`);
    }
    arrays = [data];
  }
  if (shapes != null) {
    for (let i2 = 0; i2 < names.length; ++i2) {
      if (shapes[i2] == null) {
        continue;
      }
      const array2 = arrays[i2];
      if (array2.shape.length !== shapes[i2].length) {
        throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i2]} to have ${shapes[i2].length} dimension(s), but got array with shape ${JSON.stringify(array2.shape)}`);
      }
      for (let j2 = 0; j2 < shapes[i2].length; ++j2) {
        if (j2 === 0 && !checkBatchAxis) {
          continue;
        }
        const dim = array2.shape[j2];
        const refDim = shapes[i2][j2];
        if (refDim != null) {
          if (refDim !== dim) {
            throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i2]} to have shape ${JSON.stringify(shapes[i2])} but got array with shape ${JSON.stringify(array2.shape)}.`);
          }
        }
      }
    }
  }
}
function collectMetrics(metrics2, outputNames) {
  if (metrics2 == null || Array.isArray(metrics2) && metrics2.length === 0) {
    return outputNames.map((name) => []);
  }
  let wrappedMetrics;
  if (typeof metrics2 === "string" || typeof metrics2 === "function") {
    wrappedMetrics = [metrics2];
  } else if (Array.isArray(metrics2) || typeof metrics2 === "object") {
    wrappedMetrics = metrics2;
  } else {
    throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${metrics2}`);
  }
  if (Array.isArray(wrappedMetrics)) {
    return outputNames.map((name) => wrappedMetrics);
  } else {
    const nestedMetrics = [];
    for (const name of outputNames) {
      let outputMetrics = wrappedMetrics.hasOwnProperty(name) ? wrappedMetrics[name] : [];
      if (!Array.isArray(outputMetrics)) {
        outputMetrics = [outputMetrics];
      }
      nestedMetrics.push(outputMetrics);
    }
    return nestedMetrics;
  }
}
var LAYERS_MODEL_FORMAT_NAME = "layers-model";
var LayersModel = class extends Container {
  constructor(args) {
    super(args);
    this.isTraining = false;
  }
  summary(lineLength, positions, printFn = console.log) {
    if (!this.built) {
      throw new ValueError(`This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).`);
    }
    printSummary(this, lineLength, positions, printFn);
  }
  compile(args) {
    if (args.loss == null) {
      args.loss = [];
    }
    this.loss = args.loss;
    if (typeof args.optimizer === "string") {
      this.optimizer_ = getOptimizer(args.optimizer);
      this.isOptimizerOwned = true;
    } else {
      if (!(args.optimizer instanceof Optimizer)) {
        throw new ValueError(`User-defined optimizer must be an instance of tf.Optimizer.`);
      }
      this.optimizer_ = args.optimizer;
      this.isOptimizerOwned = false;
    }
    let lossFunctions = [];
    if (!Array.isArray(args.loss) && typeof args.loss !== "string" && typeof args.loss !== "function") {
      args.loss = args.loss;
      for (const name in args.loss) {
        if (this.outputNames.indexOf(name) === -1) {
          throw new ValueError(`Unknown entry in loss dictionary: "${name}". Only expected the following keys: ${this.outputNames}`);
        }
      }
      for (const name of this.outputNames) {
        if (args.loss[name] == null) {
          console.warn(`Output "${name}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${name} during training`);
        }
        lossFunctions.push(get(args.loss[name]));
      }
    } else if (Array.isArray(args.loss)) {
      if (args.loss.length !== this.outputs.length) {
        throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${args.loss}.`);
      }
      const theLosses = args.loss;
      lossFunctions = theLosses.map((l3) => get(l3));
    } else {
      const lossFunction = get(args.loss);
      this.outputs.forEach((_2) => {
        lossFunctions.push(lossFunction);
      });
    }
    this.lossFunctions = lossFunctions;
    this.feedOutputNames = [];
    this.feedOutputShapes = [];
    this.feedLossFns = [];
    for (let i2 = 0; i2 < this.outputs.length; ++i2) {
      const shape = this.internalOutputShapes[i2];
      const name = this.outputNames[i2];
      this.feedOutputNames.push(name);
      this.feedOutputShapes.push(shape);
      this.feedLossFns.push(this.lossFunctions[i2]);
    }
    const skipTargetIndices = [];
    this.metrics = args.metrics;
    this.metricsNames = ["loss"];
    this.metricsTensors = [];
    nameScope("loss", () => {
      for (let i2 = 0; i2 < this.outputs.length; ++i2) {
        if (skipTargetIndices.indexOf(i2) !== -1) {
          continue;
        }
        const weightedLoss = this.lossFunctions[i2];
        if (this.outputs.length > 1) {
          this.metricsTensors.push([weightedLoss, i2]);
          this.metricsNames.push(this.outputNames[i2] + "_loss");
        }
      }
    });
    const nestedMetrics = collectMetrics(args.metrics, this.outputNames);
    const appendMetric = (outputIndex, metricName, metricTensor) => {
      if (this.outputNames.length > 1) {
        metricName = this.outputNames[outputIndex] + "_" + metricName;
      }
      this.metricsNames.push(metricName);
      this.metricsTensors.push([metricTensor, outputIndex]);
    };
    nameScope("metric", () => {
      for (let i2 = 0; i2 < this.outputs.length; ++i2) {
        if (skipTargetIndices.indexOf(i2) !== -1) {
          continue;
        }
        const outputMetrics = nestedMetrics[i2];
        const handleMetrics = (metrics2) => {
          const metricNamePrefix = "";
          let metricName;
          let accFn;
          let weightedMetricFn;
          for (const metric of metrics2) {
            if (typeof metric === "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(metric) !== -1) {
              const outputShape = this.internalOutputShapes[i2];
              if (outputShape[outputShape.length - 1] === 1 || this.lossFunctions[i2] === binaryCrossentropy) {
                if (["accuracy", "acc"].indexOf(metric) !== -1) {
                  accFn = binaryAccuracy;
                } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                  accFn = binaryCrossentropy2;
                }
              } else if (this.lossFunctions[i2] === sparseCategoricalCrossentropy) {
                if (["accuracy", "acc"].indexOf(metric) !== -1) {
                  accFn = sparseCategoricalAccuracy;
                } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                  accFn = sparseCategoricalCrossentropy2;
                }
              } else {
                if (["accuracy", "acc"].indexOf(metric) !== -1) {
                  accFn = categoricalAccuracy;
                } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                  accFn = categoricalCrossentropy2;
                }
              }
              let suffix;
              if (["accuracy", "acc"].indexOf(metric) !== -1) {
                suffix = "acc";
              } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                suffix = "ce";
              }
              weightedMetricFn = accFn;
              metricName = metricNamePrefix + suffix;
            } else {
              const metricFn = get2(metric);
              weightedMetricFn = metricFn;
              metricName = metricNamePrefix + getLossOrMetricName(metric);
            }
            let metricResult;
            nameScope(metricName, () => {
              metricResult = weightedMetricFn;
            });
            appendMetric(i2, metricName, metricResult);
          }
        };
        handleMetrics(outputMetrics);
      }
    });
    this.collectedTrainableWeights = this.trainableWeights;
  }
  checkTrainableWeightsConsistency() {
    if (this.collectedTrainableWeights == null) {
      return;
    }
    if (this.trainableWeights.length !== this.collectedTrainableWeights.length) {
      console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }
  }
  evaluate(x2, y2, args = {}) {
    const batchSize = args.batchSize == null ? 32 : args.batchSize;
    checkBatchSize(batchSize);
    const checkBatchAxis = true;
    const standardizedOuts = this.standardizeUserDataXY(x2, y2, checkBatchAxis, batchSize);
    try {
      const ins = standardizedOuts[0].concat(standardizedOuts[1]);
      this.makeTestFunction();
      const f2 = this.testFunction;
      const testOuts = this.testLoop(f2, ins, batchSize, args.verbose, args.steps);
      return singletonOrArray(testOuts);
    } finally {
      disposeNewTensors(standardizedOuts[0], x2);
      disposeNewTensors(standardizedOuts[1], y2);
    }
  }
  async evaluateDataset(dataset, args) {
    this.makeTestFunction();
    return evaluateDataset(this, dataset, args);
  }
  checkNumSamples(ins, batchSize, steps, stepsName = "steps") {
    let numSamples;
    if (steps != null) {
      numSamples = null;
      if (batchSize != null) {
        throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.Got batchSize = ${batchSize}`);
      }
    } else if (ins != null) {
      if (Array.isArray(ins)) {
        numSamples = ins[0].shape[0];
      } else {
        numSamples = ins.shape[0];
      }
    } else {
      throw new ValueError(`Either the input data should have a defined shape, or ${stepsName} shoud be specified.`);
    }
    return numSamples;
  }
  execute(inputs, outputs) {
    if (Array.isArray(outputs) && outputs.length === 0) {
      throw new ValueError("`outputs` is an empty Array, which is not allowed.");
    }
    const outputsIsArray = Array.isArray(outputs);
    const outputNames = outputsIsArray ? outputs : [outputs];
    const outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);
    const feedDict = new FeedDict();
    if (inputs instanceof Tensor) {
      inputs = [inputs];
    }
    if (Array.isArray(inputs)) {
      if (inputs.length !== this.inputs.length) {
        throw new ValueError(`The number of inputs provided (${inputs.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
      }
      for (let i2 = 0; i2 < this.inputs.length; ++i2) {
        feedDict.add(this.inputs[i2], inputs[i2]);
      }
    } else {
      for (const input2 of this.inputs) {
        const tensorValue = inputs[input2.name];
        if (tensorValue == null) {
          throw new ValueError(`No value is provided for the model's input ${input2.name}`);
        }
        feedDict.add(input2, tensorValue);
      }
    }
    const executeOutputs = execute(outputSymbolicTensors, feedDict);
    return outputsIsArray ? executeOutputs : executeOutputs[0];
  }
  retrieveSymbolicTensors(symbolicTensorNames) {
    const outputSymbolicTensors = pyListRepeat(null, symbolicTensorNames.length);
    let outputsRemaining = symbolicTensorNames.length;
    for (const layer of this.layers) {
      const layerOutputs = Array.isArray(layer.output) ? layer.output : [layer.output];
      const layerOutputNames = layerOutputs.map((output) => output.name);
      for (let i2 = 0; i2 < symbolicTensorNames.length; ++i2) {
        const index = layerOutputNames.indexOf(symbolicTensorNames[i2]);
        if (index !== -1) {
          outputSymbolicTensors[i2] = layerOutputs[index];
          outputsRemaining--;
        }
        if (outputsRemaining === 0) {
          break;
        }
      }
      if (outputsRemaining === 0) {
        break;
      }
    }
    if (outputsRemaining > 0) {
      const remainingNames = [];
      outputSymbolicTensors.forEach((tensor2, i2) => {
        if (tensor2 == null) {
          remainingNames.push(symbolicTensorNames[i2]);
        }
      });
      throw new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(remainingNames)}`);
    }
    return outputSymbolicTensors;
  }
  predictLoop(ins, batchSize = 32, verbose = false) {
    return tidy(() => {
      const numSamples = this.checkNumSamples(ins);
      if (verbose) {
        throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
      }
      const batches = makeBatches(numSamples, batchSize);
      const outsBatches = this.outputs.map((output) => []);
      for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
        const batchOuts = tidy(() => {
          const batchStart = batches[batchIndex][0];
          const batchEnd = batches[batchIndex][1];
          const insBatch = sliceArrays(ins, batchStart, batchEnd);
          const feeds = [];
          if (Array.isArray(insBatch)) {
            for (let i2 = 0; i2 < insBatch.length; ++i2) {
              feeds.push({ key: this.inputs[i2], value: insBatch[i2] });
            }
          } else {
            feeds.push({ key: this.inputs[0], value: insBatch });
          }
          const feedDict = new FeedDict(feeds);
          return execute(this.outputs, feedDict);
        });
        batchOuts.forEach((batchOut, i2) => outsBatches[i2].push(batchOut));
      }
      return singletonOrArray(outsBatches.map((batches2) => concat(batches2, 0)));
    });
  }
  predict(x2, args = {}) {
    const xsRank2OrHigher = ensureTensorsRank2OrHigher(x2);
    checkInputData(xsRank2OrHigher, this.inputNames, this.feedInputShapes, false);
    try {
      const batchSize = args.batchSize == null ? 32 : args.batchSize;
      checkBatchSize(batchSize);
      return this.predictLoop(xsRank2OrHigher, batchSize);
    } finally {
      disposeNewTensors(xsRank2OrHigher, x2);
    }
  }
  predictOnBatch(x2) {
    checkInputData(x2, this.inputNames, this.feedInputShapes, true);
    const batchSize = (Array.isArray(x2) ? x2[0] : x2).shape[0];
    return this.predictLoop(x2, batchSize);
  }
  standardizeUserDataXY(x2, y2, checkBatchAxis = true, batchSize) {
    if (this.optimizer_ == null) {
      throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    }
    const outputShapes = [];
    for (let i2 = 0; i2 < this.feedOutputShapes.length; ++i2) {
      const outputShape = this.feedOutputShapes[i2];
      const lossFn = this.feedLossFns[i2];
      if (lossFn === sparseCategoricalCrossentropy) {
        outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
      } else {
        outputShapes.push(outputShape);
      }
    }
    x2 = standardizeInputData(x2, this.feedInputNames, this.feedInputShapes, false, "input");
    y2 = standardizeInputData(y2, this.feedOutputNames, outputShapes, false, "target");
    checkArrayLengths(x2, y2, null);
    checkLossAndTargetCompatibility(y2, this.feedLossFns, this.feedOutputShapes);
    if (this.stateful && batchSize != null && batchSize > 0) {
      if (x2[0].shape[0] % batchSize !== 0) {
        throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${batchSize}. Found: ${x2[0].shape[0]} sample(s).`);
      }
    }
    return [x2, y2];
  }
  async standardizeUserData(x2, y2, sampleWeight, classWeight, checkBatchAxis = true, batchSize) {
    const [standardXs, standardYs] = this.standardizeUserDataXY(x2, y2, checkBatchAxis, batchSize);
    if (sampleWeight != null) {
      throw new Error("sample weight is not supported yet.");
    }
    let standardSampleWeights = null;
    if (classWeight != null) {
      const classWeights = standardizeClassWeights(classWeight, this.outputNames);
      standardSampleWeights = [];
      for (let i2 = 0; i2 < classWeights.length; ++i2) {
        standardSampleWeights.push(await standardizeWeights(standardYs[i2], null, classWeights[i2]));
      }
    }
    return [standardXs, standardYs, standardSampleWeights];
  }
  testLoop(f2, ins, batchSize, verbose = 0, steps) {
    return tidy(() => {
      const numSamples = this.checkNumSamples(ins, batchSize, steps, "steps");
      const outs = [];
      if (verbose > 0) {
        throw new NotImplementedError("Verbose mode is not implemented yet.");
      }
      if (steps != null) {
        throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
      } else {
        const batches = makeBatches(numSamples, batchSize);
        const indexArray = tensor1d(range2(0, numSamples));
        for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
          const batchStart = batches[batchIndex][0];
          const batchEnd = batches[batchIndex][1];
          const batchIds = sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
          const insBatch = sliceArraysByIndices(ins, batchIds);
          const batchOuts = f2(insBatch);
          if (batchIndex === 0) {
            for (let i2 = 0; i2 < batchOuts.length; ++i2) {
              outs.push(scalar(0));
            }
          }
          for (let i2 = 0; i2 < batchOuts.length; ++i2) {
            const batchOut = batchOuts[i2];
            outs[i2] = add2(outs[i2], mul(batchEnd - batchStart, batchOut));
          }
        }
        for (let i2 = 0; i2 < outs.length; ++i2) {
          outs[i2] = div(outs[i2], numSamples);
        }
      }
      return outs;
    });
  }
  getDedupedMetricsNames() {
    const outLabels = this.metricsNames;
    const dedupedOutLabels = [];
    for (let i2 = 0; i2 < outLabels.length; ++i2) {
      const label = outLabels[i2];
      let newLabel = label;
      if (count(outLabels, label) > 1) {
        const dupIndex = count(outLabels.slice(0, i2), label);
        newLabel += `_${dupIndex}`;
      }
      dedupedOutLabels.push(newLabel);
    }
    return dedupedOutLabels;
  }
  makeTrainFunction() {
    return (data) => {
      const lossValues = [];
      const inputs = data.slice(0, this.inputs.length);
      const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
      const sampleWeights = data.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2);
      const metricsValues = [];
      const totalLossFunction = () => {
        const feeds = [];
        for (let i2 = 0; i2 < this.inputs.length; ++i2) {
          feeds.push({ key: this.inputs[i2], value: inputs[i2] });
        }
        const feedDict = new FeedDict(feeds);
        const outputs = execute(this.outputs, feedDict, { "training": true });
        let totalLoss;
        for (let i2 = 0; i2 < this.lossFunctions.length; ++i2) {
          const lossFunction = this.lossFunctions[i2];
          let loss = lossFunction(targets[i2], outputs[i2]);
          if (sampleWeights[i2] != null) {
            loss = computeWeightedLoss2(loss, sampleWeights[i2]);
          }
          const meanLoss = mean(loss);
          lossValues.push(meanLoss);
          if (i2 === 0) {
            totalLoss = loss;
          } else {
            totalLoss = add2(totalLoss, loss);
          }
        }
        for (let i2 = 0; i2 < this.metricsTensors.length; ++i2) {
          let weightedMetric;
          if (this.outputs.length > 1 && i2 < this.outputs.length) {
            weightedMetric = lossValues[i2];
          } else {
            const metric = this.metricsTensors[i2][0];
            const outputIndex = this.metricsTensors[i2][1];
            weightedMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
          }
          keep(weightedMetric);
          metricsValues.push(weightedMetric);
        }
        totalLoss = mean(totalLoss);
        this.calculateLosses().forEach((regularizerLoss) => {
          totalLoss = add2(totalLoss, regularizerLoss);
        });
        return totalLoss;
      };
      const variables = this.collectedTrainableWeights.map((param) => param.read());
      const returnCost = true;
      const totalLossValue = this.optimizer_.minimize(totalLossFunction, returnCost, variables);
      return [totalLossValue].concat(metricsValues);
    };
  }
  makeTestFunction() {
    this.testFunction = (data) => {
      return tidy(() => {
        const valOutputs = [];
        let totalLoss;
        const inputs = data.slice(0, this.inputs.length);
        const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
        const feeds = [];
        for (let i2 = 0; i2 < this.inputs.length; ++i2) {
          feeds.push({ key: this.inputs[i2], value: inputs[i2] });
        }
        const feedDict = new FeedDict(feeds);
        const outputs = execute(this.outputs, feedDict);
        for (let i2 = 0; i2 < this.lossFunctions.length; ++i2) {
          const lossFunction = this.lossFunctions[i2];
          const loss = mean(lossFunction(targets[i2], outputs[i2]));
          if (i2 === 0) {
            totalLoss = loss;
          } else {
            totalLoss = add2(totalLoss, loss);
          }
          valOutputs.push(totalLoss);
        }
        for (let i2 = 0; i2 < this.metricsTensors.length; ++i2) {
          const metric = this.metricsTensors[i2][0];
          const outputIndex = this.metricsTensors[i2][1];
          const meanMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
          valOutputs.push(meanMetric);
        }
        return valOutputs;
      });
    };
  }
  async fit(x2, y2, args = {}) {
    return fitTensors(this, x2, y2, args);
  }
  async fitDataset(dataset, args) {
    return fitDataset(this, dataset, args);
  }
  async trainOnBatch(x2, y2) {
    const standardizeOut = await this.standardizeUserData(x2, y2);
    const inputs = standardizeOut[0];
    const targets = standardizeOut[1];
    const trainFunction = this.makeTrainFunction();
    const losses4 = trainFunction(inputs.concat(targets));
    const lossValues = [];
    for (const loss of losses4) {
      const v2 = await loss.data();
      lossValues.push(v2[0]);
    }
    dispose(losses4);
    return singletonOrArray(lossValues);
  }
  getNamedWeights(config3) {
    const namedWeights = [];
    const trainableOnly = config3 != null && config3.trainableOnly;
    const weights = trainableOnly ? this.trainableWeights : this.weights;
    const weightValues = this.getWeights(trainableOnly);
    for (let i2 = 0; i2 < weights.length; ++i2) {
      if (trainableOnly && !weights[i2].trainable) {
        continue;
      }
      namedWeights.push({ name: weights[i2].originalName, tensor: weightValues[i2] });
    }
    return namedWeights;
  }
  set stopTraining(stop) {
    this.stopTraining_ = stop;
  }
  get stopTraining() {
    return this.stopTraining_;
  }
  get optimizer() {
    return this.optimizer_;
  }
  set optimizer(optimizer) {
    if (this.optimizer_ !== optimizer) {
      this.optimizer_ = optimizer;
      this.isOptimizerOwned = false;
    }
  }
  dispose() {
    const result = super.dispose();
    if (result.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
      const numTensorsBeforeOptmizerDisposal = memory().numTensors;
      this.optimizer_.dispose();
      result.numDisposedVariables += numTensorsBeforeOptmizerDisposal - memory().numTensors;
    }
    return result;
  }
  getLossIdentifiers() {
    let lossNames;
    if (typeof this.loss === "string") {
      lossNames = toSnakeCase(this.loss);
    } else if (Array.isArray(this.loss)) {
      for (const loss of this.loss) {
        if (typeof loss !== "string") {
          throw new Error("Serialization of non-string loss is not supported.");
        }
      }
      lossNames = this.loss.map((name) => toSnakeCase(name));
    } else {
      const outputNames = Object.keys(this.loss);
      lossNames = {};
      const losses4 = this.loss;
      for (const outputName of outputNames) {
        if (typeof losses4[outputName] === "string") {
          lossNames[outputName] = toSnakeCase(losses4[outputName]);
        } else {
          throw new Error("Serialization of non-string loss is not supported.");
        }
      }
    }
    return lossNames;
  }
  getMetricIdentifiers() {
    if (typeof this.metrics === "string" || typeof this.metrics === "function") {
      return [toSnakeCase(getLossOrMetricName(this.metrics))];
    } else if (Array.isArray(this.metrics)) {
      return this.metrics.map((metric) => toSnakeCase(getLossOrMetricName(metric)));
    } else {
      const metricsIdentifiers = {};
      for (const key in this.metrics) {
        metricsIdentifiers[key] = toSnakeCase(getLossOrMetricName(this.metrics[key]));
      }
      return metricsIdentifiers;
    }
  }
  getTrainingConfig() {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }
  loadTrainingConfig(trainingConfig) {
    if (trainingConfig.weighted_metrics != null) {
      throw new Error("Loading weight_metrics is not supported yet.");
    }
    if (trainingConfig.loss_weights != null) {
      throw new Error("Loading loss_weights is not supported yet.");
    }
    if (trainingConfig.sample_weight_mode != null) {
      throw new Error("Loading sample_weight_mode is not supported yet.");
    }
    const tsConfig = convertPythonicToTs(trainingConfig.optimizer_config);
    const optimizer = deserialize(tsConfig);
    let loss;
    if (typeof trainingConfig.loss === "string") {
      loss = toCamelCase(trainingConfig.loss);
    } else if (Array.isArray(trainingConfig.loss)) {
      loss = trainingConfig.loss.map((lossEntry) => toCamelCase(lossEntry));
    } else if (trainingConfig.loss != null) {
      loss = {};
      for (const key in trainingConfig.loss) {
        loss[key] = toCamelCase(trainingConfig.loss[key]);
      }
    }
    let metrics2;
    if (Array.isArray(trainingConfig.metrics)) {
      metrics2 = trainingConfig.metrics.map((metric) => toCamelCase(metric));
    } else if (trainingConfig.metrics != null) {
      metrics2 = {};
      for (const key in trainingConfig.metrics) {
        metrics2[key] = toCamelCase(trainingConfig.metrics[key]);
      }
    }
    this.compile({ loss, metrics: metrics2, optimizer });
  }
  async save(handlerOrURL, config3) {
    if (typeof handlerOrURL === "string") {
      const handlers = io_exports.getSaveHandlers(handlerOrURL);
      if (handlers.length === 0) {
        throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);
      } else if (handlers.length > 1) {
        throw new ValueError(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
      }
      handlerOrURL = handlers[0];
    }
    if (handlerOrURL.save == null) {
      throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    }
    const weightDataAndSpecs = await io_exports.encodeWeights(this.getNamedWeights(config3));
    const returnString = false;
    const unusedArg = null;
    const modelConfig = this.toJSON(unusedArg, returnString);
    const modelArtifacts = {
      modelTopology: modelConfig,
      format: LAYERS_MODEL_FORMAT_NAME,
      generatedBy: `TensorFlow.js tfjs-layers v${version2}`,
      convertedBy: null
    };
    const includeOptimizer = config3 == null ? false : config3.includeOptimizer;
    if (includeOptimizer && this.optimizer != null) {
      modelArtifacts.trainingConfig = this.getTrainingConfig();
      const weightType = "optimizer";
      const { data: optimizerWeightData, specs: optimizerWeightSpecs } = await io_exports.encodeWeights(await this.optimizer.getWeights(), weightType);
      weightDataAndSpecs.specs.push(...optimizerWeightSpecs);
      weightDataAndSpecs.data = io_exports.concatenateArrayBuffers([weightDataAndSpecs.data, optimizerWeightData]);
    }
    if (this.userDefinedMetadata != null) {
      const checkSize = true;
      checkUserDefinedMetadata(this.userDefinedMetadata, this.name, checkSize);
      modelArtifacts.userDefinedMetadata = this.userDefinedMetadata;
    }
    modelArtifacts.weightData = weightDataAndSpecs.data;
    modelArtifacts.weightSpecs = weightDataAndSpecs.specs;
    return handlerOrURL.save(modelArtifacts);
  }
  setUserDefinedMetadata(userDefinedMetadata) {
    checkUserDefinedMetadata(userDefinedMetadata, this.name);
    this.userDefinedMetadata = userDefinedMetadata;
  }
  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }
};
LayersModel.className = "Model";
serialization_exports.registerClass(LayersModel);
var Functional = class extends LayersModel {
};
Functional.className = "Functional";
serialization_exports.registerClass(Functional);
async function modelFromJSON(modelAndWeightsConfig, customObjects) {
  if (!("modelTopology" in modelAndWeightsConfig)) {
    modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };
  }
  modelAndWeightsConfig = modelAndWeightsConfig;
  let modelTopology = modelAndWeightsConfig.modelTopology;
  if (modelTopology["model_config"] != null) {
    modelTopology = modelTopology["model_config"];
  }
  const tsConfig = convertPythonicToTs(modelTopology);
  const model22 = deserialize(tsConfig, customObjects);
  if (modelAndWeightsConfig.weightsManifest != null) {
    const weightValues = await io_exports.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model22.weights.map((weight) => weight.originalName));
    const uniqueWeightValues = {};
    for (const weight of model22.weights) {
      uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];
    }
    model22.loadWeights(uniqueWeightValues);
    dispose(weightValues);
  }
  return model22;
}
async function loadLayersModelInternal(pathOrIOHandler, options3) {
  if (options3 == null) {
    options3 = {};
  }
  if (typeof pathOrIOHandler === "string") {
    const handlers = io_exports.getLoadHandlers(pathOrIOHandler, options3);
    if (handlers.length === 0) {
      handlers.push(io_exports.browserHTTPRequest(pathOrIOHandler, options3));
    } else if (handlers.length > 1) {
      throw new ValueError(`Found more than one (${handlers.length}) load handlers for URL '${pathOrIOHandler}'`);
    }
    pathOrIOHandler = handlers[0];
  }
  return loadLayersModelFromIOHandler(pathOrIOHandler, void 0, options3);
}
async function loadLayersModelFromIOHandler(handler, customObjects, options3) {
  if (options3 == null) {
    options3 = {};
  }
  if (handler.load == null) {
    throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
  }
  const artifacts = await handler.load();
  let modelTopology = artifacts.modelTopology;
  if (modelTopology["model_config"] != null) {
    modelTopology = modelTopology["model_config"];
  }
  const strict = options3.strict == null ? true : options3.strict;
  const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;
  const model22 = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);
  const trainingConfig = artifacts.trainingConfig;
  if (trainingConfig != null) {
    model22.loadTrainingConfig(trainingConfig);
  }
  if (artifacts.userDefinedMetadata != null) {
    model22.setUserDefinedMetadata(artifacts.userDefinedMetadata);
  }
  if (artifacts.weightData != null) {
    if (artifacts.weightSpecs == null) {
      throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
    }
    const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);
    model22.loadWeights(modelWeights, strict);
    if (model22.optimizer != null && optimizerWeights.length > 0) {
      await model22.optimizer.setWeights(optimizerWeights);
    }
    dispose(modelWeights);
    dispose(optimizerWeights.map((w2) => w2.tensor));
  }
  return model22;
}
function decodeModelAndOptimizerWeights(buffer2, specs) {
  const name2Tensor = io_exports.decodeWeights(buffer2, specs);
  const modelWeights = {};
  const optimizerWeights = [];
  specs.forEach((spec) => {
    if (spec.group === "optimizer") {
      optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });
    } else {
      modelWeights[spec.name] = name2Tensor[spec.name];
    }
  });
  return { modelWeights, optimizerWeights };
}
var Sequential = class extends LayersModel {
  constructor(args) {
    super({ inputs: [], outputs: [] });
    args = args || {};
    this.trainable = true;
    this.built = false;
    this.name = args.name != null ? args.name : getUid("sequential_");
    if (args.layers != null) {
      for (const layer of args.layers) {
        this.add(layer);
      }
    }
  }
  checkShape(layer) {
    const shape = layer.inboundNodes[0].outputTensors[0].shape;
    if (shape.some((x2) => x2 < 0)) {
      throw new ValueError(`Negative dimension size caused by adding layer ${layer.name} with input shape [${layer.inboundNodes[0].inputTensors[0].shape}]`);
    }
  }
  add(layer) {
    const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;
    let modelLayer;
    if (isLayerModelInstance) {
      modelLayer = layer;
      if (modelLayer.outputs.length !== 1) {
        throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      }
      if (modelLayer.inputs.length !== 1) {
        throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }
    }
    if (this.outputs.length === 0) {
      if (layer.inboundNodes.length === 0) {
        if (layer.batchInputShape == null) {
          throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        }
        const x2 = Input({
          batchShape: layer.batchInputShape,
          dtype: layer.dtype,
          name: layer.name + "_input"
        });
        layer.apply(x2);
      }
      if (isLayerModelInstance) {
        this.outputs = modelLayer.outputs;
        this.inputs = modelLayer.inputs;
      } else {
        if (layer.inboundNodes.length !== 1) {
          throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${layer.name} which has ${layer.inboundNodes.length} pre-existing inbound connections.`);
        }
        if (layer.inboundNodes[0].outputTensors.length !== 1) {
          throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        }
        this.checkShape(layer);
        this.outputs = [layer.inboundNodes[0].outputTensors[0]];
        this.inputs = getSourceInputs(this.outputs[0]);
      }
      this.inboundNodes = [];
      new Node2({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: pyListRepeat(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map((x2) => x2.shape),
        outputShapes: this.outputs[0].shape
      });
    } else {
      const outputTensor = layer.apply(this.outputs[0]);
      if (Array.isArray(outputTensor)) {
        throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      }
      this.checkShape(layer);
      this.outputs = [outputTensor];
      this.inboundNodes[0].outputTensors = this.outputs;
      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
    this.layers.push(layer);
    this.built = false;
  }
  pop() {
    if (this.layers.length === 0) {
      throw new TypeError("There are no layers in the model.");
    }
    this.layers.pop();
    if (this.layers.length === 0) {
      this.outputs = [];
      this.inboundNodes = [];
      this.outboundNodes = [];
    } else {
      const lastLayerIndex = this.layers.length - 1;
      this.layers[lastLayerIndex].outboundNodes = [];
      this.outputs = [this.layers[lastLayerIndex].output];
      this.inboundNodes[0].outputTensors = this.outputs;
      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }
  call(inputs, kwargs) {
    if (this.model == null) {
      this.build();
    }
    return this.model.call(inputs, kwargs);
  }
  build(inputShape) {
    getExactlyOneShape(inputShape);
    if (this.inputs.length === 0 || this.outputs.length === 0) {
      throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    }
    this.model = new LayersModel({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    });
    this.model.trainable = this.trainable;
    this.supportsMasking = this.model.supportsMasking;
    this.inputLayers = this.model.inputLayers;
    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
    this.outputLayers = this.model.outputLayers;
    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
    this.nodesByDepth = this.model.nodesByDepth;
    this.containerNodes = this.model.containerNodes;
    this.outputNames = this.model.outputNames;
    this.inputNames = this.model.inputNames;
    this.built = true;
  }
  countParams() {
    if (!this.built) {
      this.build();
    }
    return super.countParams();
  }
  summary(lineLength, positions, printFn = console.log) {
    if (!this.built) {
      this.build();
    }
    super.summary(lineLength, positions, printFn);
  }
  setWeights(weights) {
    if (this.model == null) {
      this.build();
    }
    this.model.setWeights(weights);
  }
  evaluate(x2, y2, args = {}) {
    if (!this.built) {
      throw new RuntimeError("The model needs to be compiled before being used.");
    }
    return this.model.evaluate(x2, y2, args);
  }
  async evaluateDataset(dataset, args) {
    if (!this.built) {
      throw new RuntimeError("The model needs to be compiled before being used.");
    }
    return this.model.evaluateDataset(dataset, args);
  }
  predict(x2, args = {}) {
    if (this.model == null) {
      this.build();
    }
    return this.model.predict(x2, args);
  }
  predictOnBatch(x2) {
    if (this.model == null) {
      this.build();
    }
    return this.model.predictOnBatch(x2);
  }
  compile(args) {
    this.build();
    this.model.compile(args);
    this.optimizer_ = this.model.optimizer;
    this.isOptimizerOwned = this.model.isOptimizerOwned;
    this.loss = this.model.loss;
    this.metrics = this.model.metrics;
    this.metricsTensors = this.model.metricsTensors;
    this.metricsNames = this.model.metricsNames;
  }
  get optimizer() {
    return this.model == null ? void 0 : this.model.optimizer;
  }
  set optimizer(optimizer) {
    this.model.optimizer = optimizer;
  }
  async fit(x2, y2, args = {}) {
    if (!this.built) {
      throw new RuntimeError("The model needs to be compiled before being used.");
    }
    return this.model.fit(x2, y2, args);
  }
  async fitDataset(dataset, args) {
    if (!this.built) {
      throw new RuntimeError("The model needs to be compiled before being used.");
    }
    return this.model.fitDataset(dataset, args);
  }
  async trainOnBatch(x2, y2) {
    return this.model.trainOnBatch(x2, y2);
  }
  static fromConfig(cls, config3, customObjects = {}, fastWeightInit = false) {
    let configArray;
    let extraModelConfig = {};
    if (config3 instanceof Array) {
      if (!(config3[0].className != null) || config3[0]["className"] === "Merge") {
        throw new ValueError("Legacy serialization format not supported yet.");
      }
      configArray = config3;
    } else {
      util_exports.assert(config3["layers"] != null, () => `When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.`);
      configArray = config3["layers"];
      delete config3["layers"];
      extraModelConfig = config3;
    }
    const model22 = new cls(extraModelConfig);
    if (!(model22 instanceof Sequential)) {
      throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model22}`);
    }
    for (const conf of configArray) {
      const customObjects2 = void 0;
      const layer = deserialize(conf, customObjects2, fastWeightInit);
      if (fastWeightInit) {
        layer.setFastWeightInitDuringBuild(true);
      }
      model22.add(layer);
    }
    return model22;
  }
  set stopTraining(stop) {
    if (this.model == null) {
      throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
    }
    this.model.stopTraining = stop;
  }
  get stopTraining() {
    if (this.model == null) {
      throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
    }
    return this.model.stopTraining;
  }
  getConfig() {
    const layers = [];
    for (const layer of this.layers) {
      const dict = {};
      dict["className"] = layer.getClassName();
      dict["config"] = layer.getConfig();
      layers.push(dict);
    }
    return { name: this.name, layers };
  }
};
Sequential.className = "Sequential";
serialization_exports.registerClass(Sequential);
function model(args) {
  return new LayersModel(args);
}
function sequential(config3) {
  return new Sequential(config3);
}
function loadLayersModel(pathOrIOHandler, options3) {
  if (options3 == null) {
    options3 = {};
  }
  return loadLayersModelInternal(pathOrIOHandler, options3);
}
function input(config3) {
  return Input(config3);
}
function registerCallbackConstructor(verbosityLevel, callbackConstructor) {
  CallbackConstructorRegistry.registerCallbackConstructor(verbosityLevel, callbackConstructor);
}
var Activation = class extends serialization_exports.Serializable {
  getConfig() {
    return {};
  }
};
var Elu2 = class extends Activation {
  apply(x2, alpha = 1) {
    return elu2(x2, alpha);
  }
};
Elu2.className = "elu";
serialization_exports.registerClass(Elu2);
var Selu2 = class extends Activation {
  apply(x2) {
    return selu(x2);
  }
};
Selu2.className = "selu";
serialization_exports.registerClass(Selu2);
var Relu2 = class extends Activation {
  apply(x2) {
    return relu(x2);
  }
};
Relu2.className = "relu";
serialization_exports.registerClass(Relu2);
var Relu62 = class extends Activation {
  apply(x2) {
    return tidy(() => minimum(6, relu(x2)));
  }
};
Relu62.className = "relu6";
serialization_exports.registerClass(Relu62);
var Linear = class extends Activation {
  apply(x2) {
    return x2;
  }
};
Linear.className = "linear";
serialization_exports.registerClass(Linear);
var Sigmoid2 = class extends Activation {
  apply(x2) {
    return sigmoid(x2);
  }
};
Sigmoid2.className = "sigmoid";
serialization_exports.registerClass(Sigmoid2);
var HardSigmoid = class extends Activation {
  apply(x2) {
    return hardSigmoid(x2);
  }
};
HardSigmoid.className = "hardSigmoid";
serialization_exports.registerClass(HardSigmoid);
var Softplus2 = class extends Activation {
  apply(x2) {
    return softplus(x2);
  }
};
Softplus2.className = "softplus";
serialization_exports.registerClass(Softplus2);
var Softsign = class extends Activation {
  apply(x2) {
    return softsign(x2);
  }
};
Softsign.className = "softsign";
serialization_exports.registerClass(Softsign);
var Tanh2 = class extends Activation {
  apply(x2) {
    return tanh2(x2);
  }
};
Tanh2.className = "tanh";
serialization_exports.registerClass(Tanh2);
var Softmax2 = class extends Activation {
  apply(x2, axis = -1) {
    return softmax(x2, axis);
  }
};
Softmax2.className = "softmax";
serialization_exports.registerClass(Softmax2);
var LogSoftmax2 = class extends Activation {
  apply(x2, axis = -1) {
    return logSoftmax(x2, axis);
  }
};
LogSoftmax2.className = "logSoftmax";
serialization_exports.registerClass(LogSoftmax2);
var Swish = class extends Activation {
  apply(x2, alpha = 1) {
    return tidy(() => mul(sigmoid(mul(x2, alpha)), x2));
  }
};
Swish.className = "swish";
serialization_exports.registerClass(Swish);
var Mish = class extends Activation {
  apply(x2) {
    return tidy(() => mul(x2, tanh2(softplus(x2))));
  }
};
Mish.className = "mish";
serialization_exports.registerClass(Mish);
function serializeActivation(activation2) {
  return activation2.getClassName();
}
function deserializeActivation(config3, customObjects = {}) {
  return deserializeKerasObject(config3, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "activation");
}
function getActivation(identifier) {
  if (identifier == null) {
    const config3 = {};
    config3["className"] = "linear";
    config3["config"] = {};
    return deserializeActivation(config3);
  }
  if (typeof identifier === "string") {
    const config3 = {};
    config3["className"] = identifier;
    config3["config"] = {};
    return deserializeActivation(config3);
  } else if (identifier instanceof Activation) {
    return identifier;
  } else {
    return deserializeActivation(identifier);
  }
}
function assertObjectArgs(args) {
  if (args != null && typeof args !== "object") {
    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${args}`);
  }
}
var Regularizer = class extends serialization_exports.Serializable {
};
var L1L2 = class extends Regularizer {
  constructor(args) {
    super();
    assertObjectArgs(args);
    this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;
    this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;
    this.hasL1 = this.l1 !== 0;
    this.hasL2 = this.l2 !== 0;
  }
  apply(x2) {
    return tidy(() => {
      let regularization = zeros([1]);
      if (this.hasL1) {
        regularization = add2(regularization, sum2(mul(this.l1, abs(x2))));
      }
      if (this.hasL2) {
        regularization = add2(regularization, sum2(mul(this.l2, square2(x2))));
      }
      return reshape(regularization, []);
    });
  }
  getConfig() {
    return { "l1": this.l1, "l2": this.l2 };
  }
  static fromConfig(cls, config3) {
    return new cls({ l1: config3["l1"], l2: config3["l2"] });
  }
};
L1L2.className = "L1L2";
serialization_exports.registerClass(L1L2);
function l1(args) {
  assertObjectArgs(args);
  return new L1L2({ l1: args != null ? args.l1 : null, l2: 0 });
}
function l2(args) {
  assertObjectArgs(args);
  return new L1L2({ l2: args != null ? args.l2 : null, l1: 0 });
}
var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  "l1l2": "L1L2"
};
function serializeRegularizer(constraint) {
  return serializeKerasObject(constraint);
}
function deserializeRegularizer(config3, customObjects = {}) {
  return deserializeKerasObject(config3, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "regularizer");
}
function getRegularizer(identifier) {
  if (identifier == null) {
    return null;
  }
  if (typeof identifier === "string") {
    const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    const config3 = { className, config: {} };
    return deserializeRegularizer(config3);
  } else if (identifier instanceof Regularizer) {
    return identifier;
  } else {
    return deserializeRegularizer(identifier);
  }
}
var ReLU = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.supportsMasking = true;
    if (args != null) {
      this.maxValue = args.maxValue;
    }
  }
  call(inputs, kwargs) {
    inputs = getExactlyOneTensor(inputs);
    let output = relu(inputs);
    if (this.maxValue != null) {
      output = clipByValue(output, 0, this.maxValue);
    }
    return output;
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const config3 = { maxValue: this.maxValue };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
ReLU.className = "ReLU";
serialization_exports.registerClass(ReLU);
var LeakyReLU = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.DEFAULT_ALPHA = 0.3;
    if (args == null) {
      args = {};
    }
    this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
  }
  call(inputs, kwargs) {
    const x2 = getExactlyOneTensor(inputs);
    return leakyRelu(x2, this.alpha);
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const config3 = { alpha: this.alpha };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
LeakyReLU.className = "LeakyReLU";
serialization_exports.registerClass(LeakyReLU);
var PReLU = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.DEFAULT_ALPHA_INITIALIZER = "zeros";
    if (args == null) {
      args = {};
    }
    this.supportsMasking = true;
    this.alphaInitializer = getInitializer(args.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER);
    this.alphaRegularizer = getRegularizer(args.alphaRegularizer);
    this.alphaConstraint = getConstraint(args.alphaConstraint);
    if (args.sharedAxes == null) {
      this.sharedAxes = null;
    } else if (Array.isArray(args.sharedAxes)) {
      this.sharedAxes = args.sharedAxes;
    } else if (typeof args.sharedAxes === "number") {
      this.sharedAxes = [args.sharedAxes];
    } else {
      throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${args.sharedAxes}`);
    }
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const paramShape = inputShape.slice(1);
    if (this.sharedAxes != null) {
      for (const i2 of this.sharedAxes) {
        paramShape[i2 - 1] = 1;
      }
    }
    this.alpha = this.addWeight("alpha", paramShape, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
    const axes = {};
    if (this.sharedAxes != null) {
      for (let i2 = 1; i2 < inputShape.length; ++i2) {
        axes[i2] = inputShape[i2];
      }
    }
    this.inputSpec = [new InputSpec({
      ndim: inputShape.length,
      axes
    })];
    this.built = true;
  }
  call(inputs, kwargs) {
    inputs = getExactlyOneTensor(inputs);
    return prelu(inputs, this.alpha.read());
  }
  getConfig() {
    const config3 = {
      alphaInitializer: serializeInitializer(this.alphaInitializer),
      alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
      alphaConstraint: serializeConstraint(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
PReLU.className = "PReLU";
serialization_exports.registerClass(PReLU);
var ELU = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.DEFAULT_ALPHA = 1;
    if (args == null) {
      args = {};
    }
    if (args.alpha != null && args.alpha !== this.DEFAULT_ALPHA) {
      throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ELU layer yet.`);
    }
    this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
  }
  call(inputs, kwargs) {
    const x2 = getExactlyOneTensor(inputs);
    return elu(x2);
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const config3 = { alpha: this.alpha };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
ELU.className = "ELU";
serialization_exports.registerClass(ELU);
var ThresholdedReLU = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.DEFAULT_THETA = 1;
    if (args == null) {
      args = {};
    }
    this.theta = args.theta == null ? this.DEFAULT_THETA : args.theta;
  }
  call(inputs, kwargs) {
    const x2 = getExactlyOneTensor(inputs);
    return mul(x2, cast(greater(x2, this.theta), "float32"));
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const config3 = { theta: this.theta };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
ThresholdedReLU.className = "ThresholdedReLU";
serialization_exports.registerClass(ThresholdedReLU);
var Softmax3 = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.DEFAULT_AXIS = 1;
    if (args == null) {
      args = {};
    }
    this.softmax = new Softmax2().apply;
    this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
  }
  call(inputs, kwargs) {
    const x2 = getExactlyOneTensor(inputs);
    return this.softmax(x2, this.axis);
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const config3 = { axis: this.axis };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Softmax3.className = "Softmax";
serialization_exports.registerClass(Softmax3);
function normalizeArray(value, n2, name) {
  if (typeof value === "number") {
    return pyListRepeat(value, n2);
  } else {
    if (value.length !== n2) {
      throw new ValueError(`The ${name} argument must be an integer or tuple of ${n2} integers. Received: ${value.length} elements.`);
    }
    for (let i2 = 0; i2 < n2; ++i2) {
      const singleValue = value[i2];
      if (!isInteger(singleValue)) {
        throw new ValueError(`The ${name} argument must be an integer or tuple of ${n2} integers. Received: ${JSON.stringify(value)} including a non-integer number ${singleValue}`);
      }
    }
    return value;
  }
}
function convOutputLength(inputLength, filterSize, padding2, stride, dilation = 1) {
  if (inputLength == null) {
    return inputLength;
  }
  const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
  let outputLength;
  if (padding2 === "same") {
    outputLength = inputLength;
  } else {
    outputLength = inputLength - dilatedFilterSize + 1;
  }
  return Math.floor((outputLength + stride - 1) / stride);
}
function deconvLength(dimSize, strideSize, kernelSize, padding2) {
  if (dimSize == null) {
    return null;
  }
  if (padding2 === "valid") {
    dimSize = dimSize * strideSize + max2([kernelSize - strideSize, 0]);
  } else if (padding2 === "same") {
    dimSize = dimSize * strideSize;
  } else {
    throw new ValueError(`Unsupport padding mode: ${padding2}.`);
  }
  return dimSize;
}
function preprocessConv2DInput(x2, dataFormat) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    if (dataFormat === "channelsFirst") {
      return transpose(x2, [0, 2, 3, 1]);
    } else {
      return x2;
    }
  });
}
function preprocessConv3DInput(x2, dataFormat) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    if (dataFormat === "channelsFirst") {
      return transpose(x2, [0, 2, 3, 4, 1]);
    } else {
      return x2;
    }
  });
}
function conv1dWithBias(x2, kernel, bias, strides = 1, padding2 = "valid", dataFormat, dilationRate = 1) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x2.shape.length !== 3) {
      throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${x2.shape.length} instead.`);
    }
    if (kernel.shape.length !== 3) {
      throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${kernel.shape.length} instead`);
    }
    if (bias != null && bias.shape.length !== 1) {
      throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${kernel.shape.length} instead`);
    }
    if (dataFormat === "channelsFirst") {
      x2 = transpose(x2, [0, 2, 1]);
    }
    if (padding2 === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    }
    let y2 = conv1d(x2, kernel, strides, padding2 === "same" ? "same" : "valid", "NWC", dilationRate);
    if (bias != null) {
      y2 = biasAdd(y2, bias);
    }
    return y2;
  });
}
function conv2dWithBiasActivation(x2, kernel, bias, strides = [1, 1], padding2 = "valid", dataFormat, dilationRate, activation2 = null) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x2.rank !== 3 && x2.rank !== 4) {
      throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${x2.rank}.`);
    }
    if (kernel.rank !== 3 && kernel.rank !== 4) {
      throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${x2.rank}.`);
    }
    let y2 = preprocessConv2DInput(x2, dataFormat);
    if (padding2 === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    }
    y2 = fused_ops_exports.conv2d({
      x: y2,
      filter: kernel,
      strides,
      pad: padding2 === "same" ? "same" : "valid",
      dilations: dilationRate,
      dataFormat: "NHWC",
      bias,
      activation: activation2
    });
    if (dataFormat === "channelsFirst") {
      y2 = transpose(y2, [0, 3, 1, 2]);
    }
    return y2;
  });
}
function conv3dWithBias(x2, kernel, bias, strides = [1, 1, 1], padding2 = "valid", dataFormat, dilationRate) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x2.rank !== 4 && x2.rank !== 5) {
      throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${x2.rank}.`);
    }
    if (kernel.rank !== 4 && kernel.rank !== 5) {
      throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${x2.rank}.`);
    }
    let y2 = preprocessConv3DInput(x2, dataFormat);
    if (padding2 === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    }
    y2 = conv3d(y2, kernel, strides, padding2 === "same" ? "same" : "valid", "NDHWC", dilationRate);
    if (bias != null) {
      y2 = biasAdd(y2, bias);
    }
    if (dataFormat === "channelsFirst") {
      y2 = transpose(y2, [0, 4, 1, 2, 3]);
    }
    return y2;
  });
}
var BaseConv = class extends Layer {
  constructor(rank, args) {
    super(args);
    this.bias = null;
    this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
    this.DEFAULT_BIAS_INITIALIZER = "zeros";
    BaseConv.verifyArgs(args);
    this.rank = rank;
    assertPositiveInteger(this.rank, "rank");
    if (this.rank !== 1 && this.rank !== 2 && this.rank !== 3) {
      throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
    }
    this.kernelSize = normalizeArray(args.kernelSize, rank, "kernelSize");
    this.strides = normalizeArray(args.strides == null ? 1 : args.strides, rank, "strides");
    this.padding = args.padding == null ? "valid" : args.padding;
    checkPaddingMode(this.padding);
    this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
    checkDataFormat(this.dataFormat);
    this.activation = getActivation(args.activation);
    this.useBias = args.useBias == null ? true : args.useBias;
    this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
    this.biasConstraint = getConstraint(args.biasConstraint);
    this.biasRegularizer = getRegularizer(args.biasRegularizer);
    this.activityRegularizer = getRegularizer(args.activityRegularizer);
    this.dilationRate = normalizeArray(args.dilationRate == null ? 1 : args.dilationRate, rank, "dilationRate");
    if (this.rank === 1 && (Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)) {
      throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    } else if (this.rank === 2) {
      if (typeof this.dilationRate === "number") {
        this.dilationRate = [this.dilationRate, this.dilationRate];
      } else if (this.dilationRate.length !== 2) {
        throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      }
    } else if (this.rank === 3) {
      if (typeof this.dilationRate === "number") {
        this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
      } else if (this.dilationRate.length !== 3) {
        throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      }
    }
  }
  static verifyArgs(args) {
    assert2("kernelSize" in args, `required key 'kernelSize' not in config`);
    if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 3)) {
      throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`);
    }
  }
  getConfig() {
    const config3 = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      biasInitializer: serializeInitializer(this.biasInitializer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      biasConstraint: serializeConstraint(this.biasConstraint)
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
var Conv = class extends BaseConv {
  constructor(rank, args) {
    super(rank, args);
    this.kernel = null;
    Conv.verifyArgs(args);
    this.filters = args.filters;
    assertPositiveInteger(this.filters, "filters");
    this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.kernelConstraint = getConstraint(args.kernelConstraint);
    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
    if (inputShape[channelAxis] == null) {
      throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
    }
    const inputDim = inputShape[channelAxis];
    const kernelShape = this.kernelSize.concat([inputDim, this.filters]);
    this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    }
    this.inputSpec = [{ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } }];
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      let outputs;
      const biasValue = this.bias == null ? null : this.bias.read();
      const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
      if (fusedActivationName != null && this.rank === 2) {
        outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate, fusedActivationName);
      } else {
        if (this.rank === 1) {
          outputs = conv1dWithBias(inputs, this.kernel.read(), biasValue, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
        } else if (this.rank === 2) {
          outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
        } else if (this.rank === 3) {
          outputs = conv3dWithBias(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
        } else {
          throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
        }
        if (this.activation != null) {
          outputs = this.activation.apply(outputs);
        }
      }
      return outputs;
    });
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const newSpace = [];
    const space = this.dataFormat === "channelsLast" ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);
    for (let i2 = 0; i2 < space.length; ++i2) {
      const newDim = convOutputLength(space[i2], this.kernelSize[i2], this.padding, this.strides[i2], typeof this.dilationRate === "number" ? this.dilationRate : this.dilationRate[i2]);
      newSpace.push(newDim);
    }
    let outputShape = [inputShape[0]];
    if (this.dataFormat === "channelsLast") {
      outputShape = outputShape.concat(newSpace);
      outputShape.push(this.filters);
    } else {
      outputShape.push(this.filters);
      outputShape = outputShape.concat(newSpace);
    }
    return outputShape;
  }
  getConfig() {
    const config3 = {
      filters: this.filters,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint)
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
  static verifyArgs(args) {
    if (!("filters" in args) || typeof args.filters !== "number" || args.filters < 1) {
      throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(args.filters)}`);
    }
  }
};
var Conv2D2 = class extends Conv {
  constructor(args) {
    super(2, args);
    Conv2D2.verifyArgs(args);
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["rank"];
    return config3;
  }
  static verifyArgs(args) {
    if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 2)) {
      throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`);
    }
  }
};
Conv2D2.className = "Conv2D";
serialization_exports.registerClass(Conv2D2);
var Conv3D2 = class extends Conv {
  constructor(args) {
    super(3, args);
    Conv3D2.verifyArgs(args);
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["rank"];
    return config3;
  }
  static verifyArgs(args) {
    if (typeof args.kernelSize !== "number") {
      if (!(Array.isArray(args.kernelSize) && (args.kernelSize.length === 1 || args.kernelSize.length === 3))) {
        throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
  }
};
Conv3D2.className = "Conv3D";
serialization_exports.registerClass(Conv3D2);
var Conv2DTranspose = class extends Conv2D2 {
  constructor(args) {
    super(args);
    this.inputSpec = [new InputSpec({ ndim: 4 })];
    if (this.padding !== "same" && this.padding !== "valid") {
      throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (inputShape.length !== 4) {
      throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(inputShape));
    }
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
    if (inputShape[channelAxis] == null) {
      throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
    }
    const inputDim = inputShape[channelAxis];
    const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
    this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    }
    this.inputSpec = [new InputSpec({ ndim: 4, axes: { [channelAxis]: inputDim } })];
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      let input2 = getExactlyOneTensor(inputs);
      if (input2.shape.length !== 4) {
        throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);
      }
      const inputShape = input2.shape;
      const batchSize = inputShape[0];
      let hAxis;
      let wAxis;
      if (this.dataFormat === "channelsFirst") {
        hAxis = 2;
        wAxis = 3;
      } else {
        hAxis = 1;
        wAxis = 2;
      }
      const height = inputShape[hAxis];
      const width = inputShape[wAxis];
      const kernelH = this.kernelSize[0];
      const kernelW = this.kernelSize[1];
      const strideH = this.strides[0];
      const strideW = this.strides[1];
      const outHeight = deconvLength(height, strideH, kernelH, this.padding);
      const outWidth = deconvLength(width, strideW, kernelW, this.padding);
      const outputShape = [batchSize, outHeight, outWidth, this.filters];
      if (this.dataFormat !== "channelsLast") {
        input2 = transpose(input2, [0, 2, 3, 1]);
      }
      let outputs = conv2dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
      if (this.dataFormat !== "channelsLast") {
        outputs = transpose(outputs, [0, 3, 1, 2]);
      }
      if (this.bias != null) {
        outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
      }
      if (this.activation != null) {
        outputs = this.activation.apply(outputs);
      }
      return outputs;
    });
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const outputShape = inputShape.slice();
    let channelAxis;
    let heightAxis;
    let widthAxis;
    if (this.dataFormat === "channelsFirst") {
      channelAxis = 1;
      heightAxis = 2;
      widthAxis = 3;
    } else {
      channelAxis = 3;
      heightAxis = 1;
      widthAxis = 2;
    }
    const kernelH = this.kernelSize[0];
    const kernelW = this.kernelSize[1];
    const strideH = this.strides[0];
    const strideW = this.strides[1];
    outputShape[channelAxis] = this.filters;
    outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
    outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
    return outputShape;
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["dilationRate"];
    return config3;
  }
};
Conv2DTranspose.className = "Conv2DTranspose";
serialization_exports.registerClass(Conv2DTranspose);
var Conv3DTranspose = class extends Conv3D2 {
  constructor(args) {
    super(args);
    this.inputSpec = [new InputSpec({ ndim: 5 })];
    if (this.padding !== "same" && this.padding !== "valid") {
      throw new ValueError(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (inputShape.length !== 5) {
      throw new ValueError("Input should have rank 5; Received input shape: " + JSON.stringify(inputShape));
    }
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
    if (inputShape[channelAxis] == null) {
      throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
    }
    const inputDim = inputShape[channelAxis];
    const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
    this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    }
    this.inputSpec = [new InputSpec({ ndim: 5, axes: { [channelAxis]: inputDim } })];
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      let input2 = getExactlyOneTensor(inputs);
      if (input2.shape.length !== 5) {
        throw new ValueError(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);
      }
      const inputShape = input2.shape;
      const batchSize = inputShape[0];
      let hAxis;
      let wAxis;
      let dAxis;
      if (this.dataFormat === "channelsFirst") {
        dAxis = 2;
        hAxis = 3;
        wAxis = 4;
      } else {
        dAxis = 1;
        hAxis = 2;
        wAxis = 3;
      }
      const depth = inputShape[dAxis];
      const height = inputShape[hAxis];
      const width = inputShape[wAxis];
      const kernelD = this.kernelSize[0];
      const kernelH = this.kernelSize[1];
      const kernelW = this.kernelSize[2];
      const strideD = this.strides[0];
      const strideH = this.strides[1];
      const strideW = this.strides[2];
      const outDepth = deconvLength(depth, strideD, kernelD, this.padding);
      const outHeight = deconvLength(height, strideH, kernelH, this.padding);
      const outWidth = deconvLength(width, strideW, kernelW, this.padding);
      const outputShape = [batchSize, outDepth, outHeight, outWidth, this.filters];
      if (this.dataFormat !== "channelsLast") {
        input2 = transpose(input2, [0, 2, 3, 4, 1]);
      }
      let outputs = conv3dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
      if (this.dataFormat !== "channelsLast") {
        outputs = transpose(outputs, [0, 4, 1, 2, 3]);
      }
      if (this.bias !== null) {
        outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
      }
      if (this.activation !== null) {
        outputs = this.activation.apply(outputs);
      }
      return outputs;
    });
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const outputShape = inputShape.slice();
    let channelAxis;
    let depthAxis;
    let heightAxis;
    let widthAxis;
    if (this.dataFormat === "channelsFirst") {
      channelAxis = 1;
      depthAxis = 2;
      heightAxis = 3;
      widthAxis = 4;
    } else {
      channelAxis = 4;
      depthAxis = 1;
      heightAxis = 2;
      widthAxis = 3;
    }
    const kernelD = this.kernelSize[0];
    const kernelH = this.kernelSize[1];
    const kernelW = this.kernelSize[2];
    const strideD = this.strides[0];
    const strideH = this.strides[1];
    const strideW = this.strides[2];
    outputShape[channelAxis] = this.filters;
    outputShape[depthAxis] = deconvLength(outputShape[depthAxis], strideD, kernelD, this.padding);
    outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
    outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
    return outputShape;
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["dilationRate"];
    return config3;
  }
};
Conv3DTranspose.className = "Conv3DTranspose";
serialization_exports.registerClass(Conv3DTranspose);
var SeparableConv = class extends Conv {
  constructor(rank, config3) {
    super(rank, config3);
    this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
    this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
    this.depthwiseKernel = null;
    this.pointwiseKernel = null;
    if (config3.filters == null) {
      throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    }
    if (config3.kernelInitializer != null || config3.kernelRegularizer != null || config3.kernelConstraint != null) {
      throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    }
    if (config3.padding != null && config3.padding !== "same" && config3.padding !== "valid") {
      throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(config3.padding)}`);
    }
    this.depthMultiplier = config3.depthMultiplier == null ? 1 : config3.depthMultiplier;
    this.depthwiseInitializer = getInitializer(config3.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER);
    this.depthwiseRegularizer = getRegularizer(config3.depthwiseRegularizer);
    this.depthwiseConstraint = getConstraint(config3.depthwiseConstraint);
    this.pointwiseInitializer = getInitializer(config3.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER);
    this.pointwiseRegularizer = getRegularizer(config3.pointwiseRegularizer);
    this.pointwiseConstraint = getConstraint(config3.pointwiseConstraint);
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (inputShape.length < this.rank + 2) {
      throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(inputShape)}`);
    }
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
    if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
      throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(inputShape[channelAxis])}`);
    }
    const inputDim = inputShape[channelAxis];
    const depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
    const pointwiseKernelShape = [];
    for (let i2 = 0; i2 < this.rank; ++i2) {
      pointwiseKernelShape.push(1);
    }
    pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
    const trainable = true;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
    this.pointwiseKernel = this.addWeight("pointwise_kernel", pointwiseKernelShape, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
    } else {
      this.bias = null;
    }
    this.inputSpec = [new InputSpec({ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } })];
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      let output;
      if (this.rank === 1) {
        throw new NotImplementedError("1D separable convolution is not implemented yet.");
      } else if (this.rank === 2) {
        if (this.dataFormat === "channelsFirst") {
          inputs = transpose(inputs, [0, 2, 3, 1]);
        }
        output = separableConv2d(inputs, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC");
      }
      if (this.useBias) {
        output = biasAdd(output, this.bias.read(), this.dataFormat);
      }
      if (this.activation != null) {
        output = this.activation.apply(output);
      }
      if (this.dataFormat === "channelsFirst") {
        output = transpose(output, [0, 3, 1, 2]);
      }
      return output;
    });
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["rank"];
    delete config3["kernelInitializer"];
    delete config3["kernelRegularizer"];
    delete config3["kernelConstraint"];
    config3["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
    config3["pointwiseInitializer"] = serializeInitializer(this.pointwiseInitializer);
    config3["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
    config3["pointwiseRegularizer"] = serializeRegularizer(this.pointwiseRegularizer);
    config3["depthwiseConstraint"] = serializeConstraint(this.depthwiseConstraint);
    config3["pointwiseConstraint"] = serializeConstraint(this.pointwiseConstraint);
    return config3;
  }
};
SeparableConv.className = "SeparableConv";
var SeparableConv2D = class extends SeparableConv {
  constructor(args) {
    super(2, args);
  }
};
SeparableConv2D.className = "SeparableConv2D";
serialization_exports.registerClass(SeparableConv2D);
var Conv1D = class extends Conv {
  constructor(args) {
    super(1, args);
    Conv1D.verifyArgs(args);
    this.inputSpec = [{ ndim: 3 }];
  }
  getConfig() {
    const config3 = super.getConfig();
    delete config3["rank"];
    delete config3["dataFormat"];
    return config3;
  }
  static verifyArgs(args) {
    if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 1)) {
      throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(args.kernelSize)}.`);
    }
  }
};
Conv1D.className = "Conv1D";
serialization_exports.registerClass(Conv1D);
var Cropping2D = class extends Layer {
  constructor(args) {
    super(args);
    if (typeof args.cropping === "number") {
      this.cropping = [[args.cropping, args.cropping], [args.cropping, args.cropping]];
    } else if (typeof args.cropping[0] === "number") {
      this.cropping = [
        [args.cropping[0], args.cropping[0]],
        [args.cropping[1], args.cropping[1]]
      ];
    } else {
      this.cropping = args.cropping;
    }
    this.dataFormat = args.dataFormat === void 0 ? "channelsLast" : args.dataFormat;
    this.inputSpec = [{ ndim: 4 }];
  }
  computeOutputShape(inputShape) {
    if (this.dataFormat === "channelsFirst") {
      return [
        inputShape[0],
        inputShape[1],
        inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
        inputShape[3] - this.cropping[1][0] - this.cropping[1][1]
      ];
    } else {
      return [
        inputShape[0],
        inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
        inputShape[2] - this.cropping[1][0] - this.cropping[1][1],
        inputShape[3]
      ];
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      if (this.dataFormat === "channelsLast") {
        const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
        return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      } else {
        const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
        return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }
  getConfig() {
    const config3 = { cropping: this.cropping, dataFormat: this.dataFormat };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Cropping2D.className = "Cropping2D";
serialization_exports.registerClass(Cropping2D);
var UpSampling2D = class extends Layer {
  constructor(args) {
    super(args);
    this.DEFAULT_SIZE = [2, 2];
    this.inputSpec = [{ ndim: 4 }];
    this.size = args.size == null ? this.DEFAULT_SIZE : args.size;
    this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
    checkDataFormat(this.dataFormat);
    this.interpolation = args.interpolation == null ? "nearest" : args.interpolation;
    checkInterpolationFormat(this.interpolation);
  }
  computeOutputShape(inputShape) {
    if (this.dataFormat === "channelsFirst") {
      const height = inputShape[2] == null ? null : this.size[0] * inputShape[2];
      const width = inputShape[3] == null ? null : this.size[1] * inputShape[3];
      return [inputShape[0], inputShape[1], height, width];
    } else {
      const height = inputShape[1] == null ? null : this.size[0] * inputShape[1];
      const width = inputShape[2] == null ? null : this.size[1] * inputShape[2];
      return [inputShape[0], height, width, inputShape[3]];
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      let input2 = getExactlyOneTensor(inputs);
      const inputShape = input2.shape;
      if (this.dataFormat === "channelsFirst") {
        input2 = transpose(input2, [0, 2, 3, 1]);
        const height = this.size[0] * inputShape[2];
        const width = this.size[1] * inputShape[3];
        const resized = this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
        return transpose(resized, [0, 3, 1, 2]);
      } else {
        const height = this.size[0] * inputShape[1];
        const width = this.size[1] * inputShape[2];
        return this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
      }
    });
  }
  getConfig() {
    const config3 = { size: this.size, dataFormat: this.dataFormat };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
UpSampling2D.className = "UpSampling2D";
serialization_exports.registerClass(UpSampling2D);
function depthwiseConv2d3(x2, depthwiseKernel, strides = [1, 1], padding2 = "valid", dataFormat, dilationRate) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    let y2 = preprocessConv2DInput(x2, dataFormat);
    if (x2.rank !== 4) {
      throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${x2.rank}-D`);
    }
    if (depthwiseKernel.rank !== 4) {
      throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${depthwiseKernel.rank}-D`);
    }
    y2 = depthwiseConv2d(y2, depthwiseKernel, strides, padding2 === "same" ? "same" : "valid", "NHWC", dilationRate);
    if (dataFormat === "channelsFirst") {
      y2 = transpose(y2, [0, 3, 1, 2]);
    }
    return y2;
  });
}
var DepthwiseConv2D = class extends BaseConv {
  constructor(args) {
    super(2, args);
    this.depthwiseKernel = null;
    this.depthMultiplier = args.depthMultiplier == null ? 1 : args.depthMultiplier;
    this.depthwiseInitializer = getInitializer(args.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.depthwiseConstraint = getConstraint(args.depthwiseConstraint);
    this.depthwiseRegularizer = getRegularizer(args.depthwiseRegularizer);
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (inputShape.length < 4) {
      throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(inputShape)}.`);
    }
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : 3;
    if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
      throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${inputShape[channelAxis]}).`);
    }
    const inputDim = inputShape[channelAxis];
    const depthwiseKernelShape = [
      this.kernelSize[0],
      this.kernelSize[1],
      inputDim,
      this.depthMultiplier
    ];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    } else {
      this.bias = null;
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      let outputs = depthwiseConv2d3(inputs, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
      if (this.useBias) {
        outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
      }
      if (this.activation != null) {
        outputs = this.activation.apply(outputs);
      }
      return outputs;
    });
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
    const cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
    const outFilters = this.dataFormat === "channelsFirst" ? inputShape[1] * this.depthMultiplier : inputShape[3] * this.depthMultiplier;
    const outRows = convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
    const outCols = convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
    if (this.dataFormat === "channelsFirst") {
      return [inputShape[0], outFilters, outRows, outCols];
    } else {
      return [inputShape[0], outRows, outCols, outFilters];
    }
  }
  getConfig() {
    const config3 = super.getConfig();
    config3["depthMultiplier"] = this.depthMultiplier;
    config3["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
    config3["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
    config3["depthwiseConstraint"] = serializeConstraint(this.depthwiseRegularizer);
    return config3;
  }
};
DepthwiseConv2D.className = "DepthwiseConv2D";
serialization_exports.registerClass(DepthwiseConv2D);
function standardizeArgs(inputs, initialState, constants, numConstants) {
  if (Array.isArray(inputs)) {
    if (initialState != null || constants != null) {
      throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
    }
    if (numConstants != null) {
      constants = inputs.slice(inputs.length - numConstants, inputs.length);
      inputs = inputs.slice(0, inputs.length - numConstants);
    }
    if (inputs.length > 1) {
      initialState = inputs.slice(1, inputs.length);
    }
    inputs = inputs[0];
  }
  function toListOrNull(x2) {
    if (x2 == null || Array.isArray(x2)) {
      return x2;
    } else {
      return [x2];
    }
  }
  initialState = toListOrNull(initialState);
  constants = toListOrNull(constants);
  return { inputs, initialState, constants };
}
function rnn(stepFunction, inputs, initialStates, goBackwards = false, mask, constants, unroll = false, needPerStepOutputs = false) {
  return tidy(() => {
    const ndim = inputs.shape.length;
    if (ndim < 3) {
      throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);
    }
    const axes = [1, 0].concat(range2(2, ndim));
    inputs = transpose(inputs, axes);
    if (constants != null) {
      throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    }
    if (unroll) {
      console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.");
    }
    if (mask != null) {
      mask = cast(cast(mask, "bool"), "float32");
      if (mask.rank === ndim - 1) {
        mask = expandDims(mask, -1);
      }
      mask = transpose(mask, axes);
    }
    if (goBackwards) {
      inputs = reverse(inputs, 0);
      if (mask != null) {
        mask = reverse(mask, 0);
      }
    }
    const perStepOutputs = [];
    let lastOutput;
    let states = initialStates;
    const timeSteps = inputs.shape[0];
    const perStepInputs = unstack(inputs);
    let perStepMasks;
    if (mask != null) {
      perStepMasks = unstack(mask);
    }
    for (let t2 = 0; t2 < timeSteps; ++t2) {
      const currentInput = perStepInputs[t2];
      const stepOutputs = tidy(() => stepFunction(currentInput, states));
      if (mask == null) {
        lastOutput = stepOutputs[0];
        states = stepOutputs[1];
      } else {
        const maskedOutputs = tidy(() => {
          const stepMask = perStepMasks[t2];
          const negStepMask = sub(onesLike(stepMask), stepMask);
          const output = add2(mul(stepOutputs[0], stepMask), mul(states[0], negStepMask));
          const newStates = states.map((state, i2) => {
            return add2(mul(stepOutputs[1][i2], stepMask), mul(state, negStepMask));
          });
          return { output, newStates };
        });
        lastOutput = maskedOutputs.output;
        states = maskedOutputs.newStates;
      }
      if (needPerStepOutputs) {
        perStepOutputs.push(lastOutput);
      }
    }
    let outputs;
    if (needPerStepOutputs) {
      const axis = 1;
      outputs = stack(perStepOutputs, axis);
    }
    return [lastOutput, outputs, states];
  });
}
var RNN = class extends Layer {
  constructor(args) {
    super(args);
    let cell;
    if (args.cell == null) {
      throw new ValueError("cell property is missing for the constructor of RNN.");
    } else if (Array.isArray(args.cell)) {
      cell = new StackedRNNCells({ cells: args.cell });
    } else {
      cell = args.cell;
    }
    if (cell.stateSize == null) {
      throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    }
    this.cell = cell;
    this.returnSequences = args.returnSequences == null ? false : args.returnSequences;
    this.returnState = args.returnState == null ? false : args.returnState;
    this.goBackwards = args.goBackwards == null ? false : args.goBackwards;
    this._stateful = args.stateful == null ? false : args.stateful;
    this.unroll = args.unroll == null ? false : args.unroll;
    this.supportsMasking = true;
    this.inputSpec = [new InputSpec({ ndim: 3 })];
    this.stateSpec = null;
    this.states_ = null;
    this.numConstants = null;
    this.keptStates = [];
  }
  getStates() {
    if (this.states_ == null) {
      const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      return range2(0, numStates).map((x2) => null);
    } else {
      return this.states_;
    }
  }
  setStates(states) {
    this.states_ = states;
  }
  computeOutputShape(inputShape) {
    if (isArrayOfShapes(inputShape)) {
      inputShape = inputShape[0];
    }
    inputShape = inputShape;
    let stateSize = this.cell.stateSize;
    if (!Array.isArray(stateSize)) {
      stateSize = [stateSize];
    }
    const outputDim = stateSize[0];
    let outputShape;
    if (this.returnSequences) {
      outputShape = [inputShape[0], inputShape[1], outputDim];
    } else {
      outputShape = [inputShape[0], outputDim];
    }
    if (this.returnState) {
      const stateShape = [];
      for (const dim of stateSize) {
        stateShape.push([inputShape[0], dim]);
      }
      return [outputShape].concat(stateShape);
    } else {
      return outputShape;
    }
  }
  computeMask(inputs, mask) {
    return tidy(() => {
      if (Array.isArray(mask)) {
        mask = mask[0];
      }
      const outputMask = this.returnSequences ? mask : null;
      if (this.returnState) {
        const stateMask = this.states.map((s2) => null);
        return [outputMask].concat(stateMask);
      } else {
        return outputMask;
      }
    });
  }
  get states() {
    if (this.states_ == null) {
      const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      const output = [];
      for (let i2 = 0; i2 < numStates; ++i2) {
        output.push(null);
      }
      return output;
    } else {
      return this.states_;
    }
  }
  set states(s2) {
    this.states_ = s2;
  }
  build(inputShape) {
    const constantShape = null;
    if (this.numConstants != null) {
      throw new NotImplementedError("Constants support is not implemented in RNN yet.");
    }
    if (isArrayOfShapes(inputShape)) {
      inputShape = inputShape[0];
    }
    inputShape = inputShape;
    const batchSize = this.stateful ? inputShape[0] : null;
    const inputDim = inputShape.slice(2);
    this.inputSpec[0] = new InputSpec({ shape: [batchSize, null, ...inputDim] });
    const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
    if (constantShape != null) {
      throw new NotImplementedError("Constants support is not implemented in RNN yet.");
    } else {
      this.cell.build(stepInputShape);
    }
    let stateSize;
    if (Array.isArray(this.cell.stateSize)) {
      stateSize = this.cell.stateSize;
    } else {
      stateSize = [this.cell.stateSize];
    }
    if (this.stateSpec != null) {
      if (!util_exports.arraysEqual(this.stateSpec.map((spec) => spec.shape[spec.shape.length - 1]), stateSize)) {
        throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
      }
    } else {
      this.stateSpec = stateSize.map((dim) => new InputSpec({ shape: [null, dim] }));
    }
    if (this.stateful) {
      this.resetStates();
    }
  }
  resetStates(states, training = false) {
    tidy(() => {
      if (!this.stateful) {
        throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
      }
      const batchSize = this.inputSpec[0].shape[0];
      if (batchSize == null) {
        throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      }
      if (this.states_ == null) {
        if (Array.isArray(this.cell.stateSize)) {
          this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
        } else {
          this.states_ = [zeros([batchSize, this.cell.stateSize])];
        }
      } else if (states == null) {
        dispose(this.states_);
        if (this.keptStates != null) {
          dispose(this.keptStates);
          this.keptStates = [];
        }
        if (Array.isArray(this.cell.stateSize)) {
          this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
        } else {
          this.states_[0] = zeros([batchSize, this.cell.stateSize]);
        }
      } else {
        if (!Array.isArray(states)) {
          states = [states];
        }
        if (states.length !== this.states_.length) {
          throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
        }
        if (training === true) {
          this.keptStates.push(this.states_.slice());
        } else {
          dispose(this.states_);
        }
        for (let index = 0; index < this.states_.length; ++index) {
          const value = states[index];
          const dim = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[index] : this.cell.stateSize;
          const expectedShape = [batchSize, dim];
          if (!util_exports.arraysEqual(value.shape, expectedShape)) {
            throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
          }
          this.states_[index] = value;
        }
      }
      this.states_ = this.states_.map((state) => keep(state.clone()));
    });
  }
  apply(inputs, kwargs) {
    let initialState = kwargs == null ? null : kwargs["initialState"];
    let constants = kwargs == null ? null : kwargs["constants"];
    if (kwargs == null) {
      kwargs = {};
    }
    const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
    inputs = standardized.inputs;
    initialState = standardized.initialState;
    constants = standardized.constants;
    let additionalInputs = [];
    let additionalSpecs = [];
    if (initialState != null) {
      kwargs["initialState"] = initialState;
      additionalInputs = additionalInputs.concat(initialState);
      this.stateSpec = [];
      for (const state of initialState) {
        this.stateSpec.push(new InputSpec({ shape: state.shape }));
      }
      additionalSpecs = additionalSpecs.concat(this.stateSpec);
    }
    if (constants != null) {
      kwargs["constants"] = constants;
      additionalInputs = additionalInputs.concat(constants);
      this.numConstants = constants.length;
    }
    const isTensor = additionalInputs[0] instanceof SymbolicTensor;
    if (isTensor) {
      const fullInput = [inputs].concat(additionalInputs);
      const fullInputSpec = this.inputSpec.concat(additionalSpecs);
      const originalInputSpec = this.inputSpec;
      this.inputSpec = fullInputSpec;
      const output = super.apply(fullInput, kwargs);
      this.inputSpec = originalInputSpec;
      return output;
    } else {
      return super.apply(inputs, kwargs);
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const mask = kwargs == null ? null : kwargs["mask"];
      const training = kwargs == null ? null : kwargs["training"];
      let initialState = kwargs == null ? null : kwargs["initialState"];
      inputs = getExactlyOneTensor(inputs);
      if (initialState == null) {
        if (this.stateful) {
          initialState = this.states_;
        } else {
          initialState = this.getInitialState(inputs);
        }
      }
      const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (initialState.length !== numStates) {
        throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ${initialState.length} initial state(s).`);
      }
      if (this.unroll) {
        console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      }
      const cellCallKwargs = { training };
      const step5 = (inputs2, states2) => {
        const outputs2 = this.cell.call([inputs2].concat(states2), cellCallKwargs);
        return [outputs2[0], outputs2.slice(1)];
      };
      const rnnOutputs = rnn(step5, inputs, initialState, this.goBackwards, mask, null, this.unroll, this.returnSequences);
      const lastOutput = rnnOutputs[0];
      const outputs = rnnOutputs[1];
      const states = rnnOutputs[2];
      if (this.stateful) {
        this.resetStates(states, training);
      }
      const output = this.returnSequences ? outputs : lastOutput;
      if (this.returnState) {
        return [output].concat(states);
      } else {
        return output;
      }
    });
  }
  getInitialState(inputs) {
    return tidy(() => {
      let initialState = zeros(inputs.shape);
      initialState = sum2(initialState, [1, 2]);
      initialState = expandDims2(initialState);
      if (Array.isArray(this.cell.stateSize)) {
        return this.cell.stateSize.map((dim) => dim > 1 ? tile2(initialState, [1, dim]) : initialState);
      } else {
        return this.cell.stateSize > 1 ? [tile2(initialState, [1, this.cell.stateSize])] : [initialState];
      }
    });
  }
  get trainableWeights() {
    if (!this.trainable) {
      return [];
    }
    return this.cell.trainableWeights;
  }
  get nonTrainableWeights() {
    if (!this.trainable) {
      return this.cell.weights;
    }
    return this.cell.nonTrainableWeights;
  }
  setFastWeightInitDuringBuild(value) {
    super.setFastWeightInitDuringBuild(value);
    if (this.cell != null) {
      this.cell.setFastWeightInitDuringBuild(value);
    }
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    if (this.numConstants != null) {
      config3["numConstants"] = this.numConstants;
    }
    const cellConfig = this.cell.getConfig();
    if (this.getClassName() === RNN.className) {
      config3["cell"] = {
        "className": this.cell.getClassName(),
        "config": cellConfig
      };
    }
    return Object.assign({}, cellConfig, baseConfig, config3);
  }
  static fromConfig(cls, config3, customObjects = {}) {
    const cellConfig = config3["cell"];
    const cell = deserialize(cellConfig, customObjects);
    return new cls(Object.assign(config3, { cell }));
  }
};
RNN.className = "RNN";
serialization_exports.registerClass(RNN);
var RNNCell = class extends Layer {
};
var SimpleRNNCell = class extends RNNCell {
  constructor(args) {
    super(args);
    this.DEFAULT_ACTIVATION = "tanh";
    this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
    this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
    this.DEFAULT_BIAS_INITIALIZER = "zeros";
    this.units = args.units;
    assertPositiveInteger(this.units, `units`);
    this.activation = getActivation(args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);
    this.useBias = args.useBias == null ? true : args.useBias;
    this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
    this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
    this.biasRegularizer = getRegularizer(args.biasRegularizer);
    this.kernelConstraint = getConstraint(args.kernelConstraint);
    this.recurrentConstraint = getConstraint(args.recurrentConstraint);
    this.biasConstraint = getConstraint(args.biasConstraint);
    this.dropout = min2([1, max2([0, args.dropout == null ? 0 : args.dropout])]);
    this.recurrentDropout = min2([
      1,
      max2([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
    ]);
    this.stateSize = this.units;
    this.dropoutMask = null;
    this.recurrentDropoutMask = null;
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    this.kernel = this.addWeight("kernel", [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    } else {
      this.bias = null;
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = inputs;
      if (inputs.length !== 2) {
        throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);
      }
      let prevOutput = inputs[1];
      inputs = inputs[0];
      const training = kwargs["training"] == null ? false : kwargs["training"];
      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
        this.dropoutMask = generateDropoutMask({
          ones: () => onesLike(inputs),
          rate: this.dropout,
          training
        });
      }
      if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
        this.recurrentDropoutMask = generateDropoutMask({
          ones: () => onesLike(prevOutput),
          rate: this.recurrentDropout,
          training
        });
      }
      let h2;
      const dpMask = this.dropoutMask;
      const recDpMask = this.recurrentDropoutMask;
      if (dpMask != null) {
        h2 = dot2(mul(inputs, dpMask), this.kernel.read());
      } else {
        h2 = dot2(inputs, this.kernel.read());
      }
      if (this.bias != null) {
        h2 = biasAdd(h2, this.bias.read());
      }
      if (recDpMask != null) {
        prevOutput = mul(prevOutput, recDpMask);
      }
      let output = add2(h2, dot2(prevOutput, this.recurrentKernel.read()));
      if (this.activation != null) {
        output = this.activation.apply(output);
      }
      return [output, output];
    });
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    };
    return Object.assign({}, baseConfig, config3);
  }
};
SimpleRNNCell.className = "SimpleRNNCell";
serialization_exports.registerClass(SimpleRNNCell);
var SimpleRNN = class extends RNN {
  constructor(args) {
    args.cell = new SimpleRNNCell(args);
    super(args);
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (this.cell.dropoutMask != null) {
        dispose(this.cell.dropoutMask);
        this.cell.dropoutMask = null;
      }
      if (this.cell.recurrentDropoutMask != null) {
        dispose(this.cell.recurrentDropoutMask);
        this.cell.recurrentDropoutMask = null;
      }
      const mask = kwargs == null ? null : kwargs["mask"];
      const training = kwargs == null ? null : kwargs["training"];
      const initialState = kwargs == null ? null : kwargs["initialState"];
      return super.call(inputs, { mask, training, initialState });
    });
  }
  static fromConfig(cls, config3) {
    return new cls(config3);
  }
};
SimpleRNN.className = "SimpleRNN";
serialization_exports.registerClass(SimpleRNN);
var GRUCell = class extends RNNCell {
  constructor(args) {
    super(args);
    this.DEFAULT_ACTIVATION = "tanh";
    this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
    this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
    this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
    this.DEFAULT_BIAS_INITIALIZER = "zeros";
    if (args.resetAfter) {
      throw new ValueError(`GRUCell does not support reset_after parameter set to true.`);
    }
    this.units = args.units;
    assertPositiveInteger(this.units, "units");
    this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
    this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
    this.useBias = args.useBias == null ? true : args.useBias;
    this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
    this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
    this.biasRegularizer = getRegularizer(args.biasRegularizer);
    this.kernelConstraint = getConstraint(args.kernelConstraint);
    this.recurrentConstraint = getConstraint(args.recurrentConstraint);
    this.biasConstraint = getConstraint(args.biasConstraint);
    this.dropout = min2([1, max2([0, args.dropout == null ? 0 : args.dropout])]);
    this.recurrentDropout = min2([
      1,
      max2([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
    ]);
    this.implementation = args.implementation;
    this.stateSize = this.units;
    this.dropoutMask = null;
    this.recurrentDropoutMask = null;
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const inputDim = inputShape[inputShape.length - 1];
    this.kernel = this.addWeight("kernel", [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    if (this.useBias) {
      this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    } else {
      this.bias = null;
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = inputs;
      if (inputs.length !== 2) {
        throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${inputs.length}.`);
      }
      const training = kwargs["training"] == null ? false : kwargs["training"];
      let hTMinus1 = inputs[1];
      inputs = inputs[0];
      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
        this.dropoutMask = generateDropoutMask({
          ones: () => onesLike(inputs),
          rate: this.dropout,
          training,
          count: 3
        });
      }
      if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
        this.recurrentDropoutMask = generateDropoutMask({
          ones: () => onesLike(hTMinus1),
          rate: this.recurrentDropout,
          training,
          count: 3
        });
      }
      const dpMask = this.dropoutMask;
      const recDpMask = this.recurrentDropoutMask;
      let z2;
      let r2;
      let hh;
      if (0 < this.dropout && this.dropout < 1) {
        inputs = mul(inputs, dpMask[0]);
      }
      let matrixX = dot2(inputs, this.kernel.read());
      if (this.useBias) {
        matrixX = biasAdd(matrixX, this.bias.read());
      }
      if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
        hTMinus1 = mul(hTMinus1, recDpMask[0]);
      }
      const recurrentKernelValue = this.recurrentKernel.read();
      const [rk1, rk2] = split(recurrentKernelValue, [2 * this.units, this.units], recurrentKernelValue.rank - 1);
      const matrixInner = dot2(hTMinus1, rk1);
      const [xZ, xR, xH] = split(matrixX, 3, matrixX.rank - 1);
      const [recurrentZ, recurrentR] = split(matrixInner, 2, matrixInner.rank - 1);
      z2 = this.recurrentActivation.apply(add2(xZ, recurrentZ));
      r2 = this.recurrentActivation.apply(add2(xR, recurrentR));
      const recurrentH = dot2(mul(r2, hTMinus1), rk2);
      hh = this.activation.apply(add2(xH, recurrentH));
      const h2 = add2(mul(z2, hTMinus1), mul(add2(1, neg(z2)), hh));
      return [h2, h2];
    });
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation,
      resetAfter: false
    };
    return Object.assign({}, baseConfig, config3);
  }
};
GRUCell.className = "GRUCell";
serialization_exports.registerClass(GRUCell);
var GRU = class extends RNN {
  constructor(args) {
    if (args.implementation === 0) {
      console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
    }
    args.cell = new GRUCell(args);
    super(args);
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (this.cell.dropoutMask != null) {
        dispose(this.cell.dropoutMask);
        this.cell.dropoutMask = null;
      }
      if (this.cell.recurrentDropoutMask != null) {
        dispose(this.cell.recurrentDropoutMask);
        this.cell.recurrentDropoutMask = null;
      }
      const mask = kwargs == null ? null : kwargs["mask"];
      const training = kwargs == null ? null : kwargs["training"];
      const initialState = kwargs == null ? null : kwargs["initialState"];
      return super.call(inputs, { mask, training, initialState });
    });
  }
  static fromConfig(cls, config3) {
    if (config3["implmentation"] === 0) {
      config3["implementation"] = 1;
    }
    return new cls(config3);
  }
};
GRU.className = "GRU";
serialization_exports.registerClass(GRU);
var LSTMCell = class extends RNNCell {
  constructor(args) {
    super(args);
    this.DEFAULT_ACTIVATION = "tanh";
    this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
    this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
    this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
    this.DEFAULT_BIAS_INITIALIZER = "zeros";
    this.units = args.units;
    assertPositiveInteger(this.units, "units");
    this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
    this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
    this.useBias = args.useBias == null ? true : args.useBias;
    this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
    this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
    this.unitForgetBias = args.unitForgetBias;
    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
    this.biasRegularizer = getRegularizer(args.biasRegularizer);
    this.kernelConstraint = getConstraint(args.kernelConstraint);
    this.recurrentConstraint = getConstraint(args.recurrentConstraint);
    this.biasConstraint = getConstraint(args.biasConstraint);
    this.dropout = min2([1, max2([0, args.dropout == null ? 0 : args.dropout])]);
    this.recurrentDropout = min2([
      1,
      max2([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
    ]);
    this.implementation = args.implementation;
    this.stateSize = [this.units, this.units];
    this.dropoutMask = null;
    this.recurrentDropoutMask = null;
  }
  build(inputShape) {
    var _a;
    inputShape = getExactlyOneShape(inputShape);
    const inputDim = inputShape[inputShape.length - 1];
    this.kernel = this.addWeight("kernel", [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    let biasInitializer;
    if (this.useBias) {
      if (this.unitForgetBias) {
        const capturedBiasInit = this.biasInitializer;
        const capturedUnits = this.units;
        biasInitializer = new (_a = class CustomInit extends Initializer {
          apply(shape, dtype) {
            const bI = capturedBiasInit.apply([capturedUnits]);
            const bF = new Ones().apply([capturedUnits]);
            const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);
            return concatAlongFirstAxis(concatAlongFirstAxis(bI, bF), bCAndH);
          }
        }, _a.className = "CustomInit", _a)();
      } else {
        biasInitializer = this.biasInitializer;
      }
      this.bias = this.addWeight("bias", [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    } else {
      this.bias = null;
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const training = kwargs["training"] == null ? false : kwargs["training"];
      inputs = inputs;
      if (inputs.length !== 3) {
        throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
      }
      let hTMinus1 = inputs[1];
      const cTMinus1 = inputs[2];
      inputs = inputs[0];
      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
        this.dropoutMask = generateDropoutMask({
          ones: () => onesLike(inputs),
          rate: this.dropout,
          training,
          count: 4
        });
      }
      if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
        this.recurrentDropoutMask = generateDropoutMask({
          ones: () => onesLike(hTMinus1),
          rate: this.recurrentDropout,
          training,
          count: 4
        });
      }
      const dpMask = this.dropoutMask;
      const recDpMask = this.recurrentDropoutMask;
      let i2;
      let f2;
      let c2;
      let o2;
      if (0 < this.dropout && this.dropout < 1) {
        inputs = mul(inputs, dpMask[0]);
      }
      let z2 = dot2(inputs, this.kernel.read());
      if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
        hTMinus1 = mul(hTMinus1, recDpMask[0]);
      }
      z2 = add2(z2, dot2(hTMinus1, this.recurrentKernel.read()));
      if (this.useBias) {
        z2 = biasAdd(z2, this.bias.read());
      }
      const [z0, z1, z22, z3] = split(z2, 4, z2.rank - 1);
      i2 = this.recurrentActivation.apply(z0);
      f2 = this.recurrentActivation.apply(z1);
      c2 = add2(mul(f2, cTMinus1), mul(i2, this.activation.apply(z22)));
      o2 = this.recurrentActivation.apply(z3);
      const h2 = mul(o2, this.activation.apply(c2));
      return [h2, h2, c2];
    });
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    };
    return Object.assign({}, baseConfig, config3);
  }
};
LSTMCell.className = "LSTMCell";
serialization_exports.registerClass(LSTMCell);
var LSTM = class extends RNN {
  constructor(args) {
    if (args.implementation === 0) {
      console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
    }
    args.cell = new LSTMCell(args);
    super(args);
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (this.cell.dropoutMask != null) {
        dispose(this.cell.dropoutMask);
        this.cell.dropoutMask = null;
      }
      if (this.cell.recurrentDropoutMask != null) {
        dispose(this.cell.recurrentDropoutMask);
        this.cell.recurrentDropoutMask = null;
      }
      const mask = kwargs == null ? null : kwargs["mask"];
      const training = kwargs == null ? null : kwargs["training"];
      const initialState = kwargs == null ? null : kwargs["initialState"];
      return super.call(inputs, { mask, training, initialState });
    });
  }
  static fromConfig(cls, config3) {
    if (config3["implmentation"] === 0) {
      config3["implementation"] = 1;
    }
    return new cls(config3);
  }
};
LSTM.className = "LSTM";
serialization_exports.registerClass(LSTM);
var StackedRNNCells = class extends RNNCell {
  constructor(args) {
    super(args);
    this.cells = args.cells;
  }
  get stateSize() {
    const stateSize = [];
    for (const cell of this.cells.slice().reverse()) {
      if (Array.isArray(cell.stateSize)) {
        stateSize.push(...cell.stateSize);
      } else {
        stateSize.push(cell.stateSize);
      }
    }
    return stateSize;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = inputs;
      let states = inputs.slice(1);
      const nestedStates = [];
      for (const cell of this.cells.slice().reverse()) {
        if (Array.isArray(cell.stateSize)) {
          nestedStates.push(states.splice(0, cell.stateSize.length));
        } else {
          nestedStates.push(states.splice(0, 1));
        }
      }
      nestedStates.reverse();
      const newNestedStates = [];
      let callInputs;
      for (let i2 = 0; i2 < this.cells.length; ++i2) {
        const cell = this.cells[i2];
        states = nestedStates[i2];
        if (i2 === 0) {
          callInputs = [inputs[0]].concat(states);
        } else {
          callInputs = [callInputs[0]].concat(states);
        }
        callInputs = cell.call(callInputs, kwargs);
        newNestedStates.push(callInputs.slice(1));
      }
      states = [];
      for (const cellStates of newNestedStates.slice().reverse()) {
        states.push(...cellStates);
      }
      return [callInputs[0]].concat(states);
    });
  }
  build(inputShape) {
    if (isArrayOfShapes(inputShape)) {
      inputShape = inputShape[0];
    }
    inputShape = inputShape;
    let outputDim;
    this.cells.forEach((cell, i2) => {
      nameScope(`RNNCell_${i2}`, () => {
        cell.build(inputShape);
        if (Array.isArray(cell.stateSize)) {
          outputDim = cell.stateSize[0];
        } else {
          outputDim = cell.stateSize;
        }
        inputShape = [inputShape[0], outputDim];
      });
    });
    this.built = true;
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const getCellConfig = (cell) => {
      return {
        "className": cell.getClassName(),
        "config": cell.getConfig()
      };
    };
    const cellConfigs = this.cells.map(getCellConfig);
    const config3 = { "cells": cellConfigs };
    return Object.assign({}, baseConfig, config3);
  }
  static fromConfig(cls, config3, customObjects = {}) {
    const cells = [];
    for (const cellConfig of config3["cells"]) {
      cells.push(deserialize(cellConfig, customObjects));
    }
    return new cls({ cells });
  }
  get trainableWeights() {
    if (!this.trainable) {
      return [];
    }
    const weights = [];
    for (const cell of this.cells) {
      weights.push(...cell.trainableWeights);
    }
    return weights;
  }
  get nonTrainableWeights() {
    const weights = [];
    for (const cell of this.cells) {
      weights.push(...cell.nonTrainableWeights);
    }
    if (!this.trainable) {
      const trainableWeights = [];
      for (const cell of this.cells) {
        trainableWeights.push(...cell.trainableWeights);
      }
      return trainableWeights.concat(weights);
    }
    return weights;
  }
  getWeights() {
    const weights = [];
    for (const cell of this.cells) {
      weights.push(...cell.weights);
    }
    return batchGetValue(weights);
  }
  setWeights(weights) {
    const tuples = [];
    for (const cell of this.cells) {
      const numParams = cell.weights.length;
      const inputWeights = weights.splice(numParams);
      for (let i2 = 0; i2 < cell.weights.length; ++i2) {
        tuples.push([cell.weights[i2], inputWeights[i2]]);
      }
    }
    batchSetValue(tuples);
  }
};
StackedRNNCells.className = "StackedRNNCells";
serialization_exports.registerClass(StackedRNNCells);
function generateDropoutMask(args) {
  const { ones: ones4, rate, training = false, count: count22 = 1 } = args;
  const droppedInputs = () => dropout2(ones4(), rate);
  const createMask = () => inTrainPhase(droppedInputs, ones4, training);
  if (!count22 || count22 <= 1) {
    return keep(createMask().clone());
  }
  const masks = Array(count22).fill(void 0).map(createMask);
  return masks.map((m2) => keep(m2.clone()));
}
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p22 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p22) && e2.indexOf(p22) < 0)
      t2[p22] = s2[p22];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p22 = Object.getOwnPropertySymbols(s2); i2 < p22.length; i2++) {
      if (e2.indexOf(p22[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p22[i2]))
        t2[p22[i2]] = s2[p22[i2]];
    }
  return t2;
};
var ConvRNN2D = class extends RNN {
  constructor(args) {
    if (args.unroll) {
      throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");
    }
    if (Array.isArray(args.cell)) {
      throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");
    }
    super(args);
    this.inputSpec = [new InputSpec({ ndim: 5 })];
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (this.cell.dropoutMask != null) {
        dispose(this.cell.dropoutMask);
        this.cell.dropoutMask = null;
      }
      if (this.cell.recurrentDropoutMask != null) {
        dispose(this.cell.recurrentDropoutMask);
        this.cell.recurrentDropoutMask = null;
      }
      if (kwargs && kwargs["constants"]) {
        throw new ValueError("ConvRNN2D cell does not support constants");
      }
      const mask = kwargs == null ? null : kwargs["mask"];
      const training = kwargs == null ? null : kwargs["training"];
      const initialState = kwargs == null ? null : kwargs["initialState"];
      return super.call(inputs, { mask, training, initialState });
    });
  }
  computeOutputShape(inputShape) {
    let outShape = this.computeSingleOutputShape(inputShape);
    if (!this.returnSequences) {
      outShape = [outShape[0], ...outShape.slice(2)];
    }
    if (this.returnState) {
      outShape = [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];
    }
    return outShape;
  }
  getInitialState(inputs) {
    return tidy(() => {
      const { stateSize } = this.cell;
      const inputShape = inputs.shape;
      const outputShape = this.computeSingleOutputShape(inputShape);
      const stateShape = [outputShape[0], ...outputShape.slice(2)];
      const initialState = zeros(stateShape);
      if (Array.isArray(stateSize)) {
        return Array(stateSize.length).fill(initialState);
      }
      return [initialState];
    });
  }
  resetStates(states, training = false) {
    tidy(() => {
      if (!this.stateful) {
        throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
      }
      const inputShape = this.inputSpec[0].shape;
      const outputShape = this.computeSingleOutputShape(inputShape);
      const stateShape = [outputShape[0], ...outputShape.slice(2)];
      const batchSize = inputShape[0];
      if (batchSize == null) {
        throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      }
      if (this.getStates() == null) {
        if (Array.isArray(this.cell.stateSize)) {
          this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
        } else {
          this.states_ = [zeros(stateShape)];
        }
      } else if (states == null) {
        dispose(this.states_);
        if (this.keptStates != null) {
          dispose(this.keptStates);
          this.keptStates = [];
        }
        if (Array.isArray(this.cell.stateSize)) {
          this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
        } else {
          this.states_[0] = zeros(stateShape);
        }
      } else {
        if (!Array.isArray(states)) {
          states = [states];
        }
        if (states.length !== this.states_.length) {
          throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
        }
        if (training) {
          this.keptStates.push(this.states_.slice());
        } else {
          dispose(this.states_);
        }
        for (let index = 0; index < this.states_.length; ++index) {
          const value = states[index];
          const expectedShape = stateShape;
          if (!util_exports.arraysEqual(value.shape, expectedShape)) {
            throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
          }
          this.states_[index] = value;
        }
      }
      this.states_ = this.states_.map((state) => keep(state.clone()));
    });
  }
  computeSingleOutputShape(inputShape) {
    const { dataFormat, filters, kernelSize, padding: padding2, strides, dilationRate } = this.cell;
    const isChannelsFirst = dataFormat === "channelsFirst";
    const h2 = inputShape[isChannelsFirst ? 3 : 2];
    const w2 = inputShape[isChannelsFirst ? 4 : 3];
    const hOut = convOutputLength(h2, kernelSize[0], padding2, strides[0], dilationRate[0]);
    const wOut = convOutputLength(w2, kernelSize[1], padding2, strides[1], dilationRate[1]);
    const outShape = [
      ...inputShape.slice(0, 2),
      ...isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters]
    ];
    return outShape;
  }
};
ConvRNN2D.className = "ConvRNN2D";
var ConvLSTM2DCell = class extends LSTMCell {
  constructor(args) {
    const { filters, kernelSize, strides, padding: padding2, dataFormat, dilationRate } = args;
    super(Object.assign({}, args, { units: filters }));
    this.filters = filters;
    assertPositiveInteger(this.filters, "filters");
    this.kernelSize = normalizeArray(kernelSize, 2, "kernelSize");
    this.kernelSize.forEach((size2) => assertPositiveInteger(size2, "kernelSize"));
    this.strides = normalizeArray(strides || 1, 2, "strides");
    this.strides.forEach((stride) => assertPositiveInteger(stride, "strides"));
    this.padding = padding2 || "valid";
    checkPaddingMode(this.padding);
    this.dataFormat = dataFormat || "channelsLast";
    checkDataFormat(this.dataFormat);
    this.dilationRate = normalizeArray(dilationRate || 1, 2, "dilationRate");
    this.dilationRate.forEach((rate) => assertPositiveInteger(rate, "dilationRate"));
  }
  build(inputShape) {
    var _a;
    inputShape = getExactlyOneShape(inputShape);
    const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
    if (inputShape[channelAxis] == null) {
      throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
    }
    const inputDim = inputShape[channelAxis];
    const numOfKernels = 4;
    const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);
    this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);
    this.recurrentKernel = this.addWeight("recurrent_kernel", recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    if (this.useBias) {
      let biasInitializer;
      if (this.unitForgetBias) {
        const init2 = this.biasInitializer;
        const filters = this.filters;
        biasInitializer = new (_a = class CustomInit extends Initializer {
          apply(shape, dtype) {
            const biasI = init2.apply([filters]);
            const biasF = ones2([filters]);
            const biasCAndO = init2.apply([filters * 2]);
            return concatenate([biasI, biasF, biasCAndO]);
          }
        }, _a.className = "CustomInit", _a)();
      } else {
        biasInitializer = this.biasInitializer;
      }
      this.bias = this.addWeight("bias", [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (inputs.length !== 3) {
        throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
      }
      const training = kwargs["training"] || false;
      const x2 = inputs[0];
      const hTMinus1 = inputs[1];
      const cTMinus1 = inputs[2];
      const numOfKernels = 4;
      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
        this.dropoutMask = generateDropoutMask({
          ones: () => onesLike(x2),
          rate: this.dropout,
          training,
          count: numOfKernels
        });
      }
      const dropoutMask = this.dropoutMask;
      const applyDropout = (x22, mask, index) => {
        if (!mask || !mask[index]) {
          return x22;
        }
        return mul(mask[index], x22);
      };
      let xI = applyDropout(x2, dropoutMask, 0);
      let xF = applyDropout(x2, dropoutMask, 1);
      let xC = applyDropout(x2, dropoutMask, 2);
      let xO = applyDropout(x2, dropoutMask, 3);
      if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
        this.recurrentDropoutMask = generateDropoutMask({
          ones: () => onesLike(hTMinus1),
          rate: this.recurrentDropout,
          training,
          count: numOfKernels
        });
      }
      const recDropoutMask = this.recurrentDropoutMask;
      let hI = applyDropout(hTMinus1, recDropoutMask, 0);
      let hF = applyDropout(hTMinus1, recDropoutMask, 1);
      let hC = applyDropout(hTMinus1, recDropoutMask, 2);
      let hO = applyDropout(hTMinus1, recDropoutMask, 3);
      const kernelChannelAxis = 3;
      const [kernelI, kernelF, kernelC, kernelO] = split(this.kernel.read(), numOfKernels, kernelChannelAxis);
      const [biasI, biasF, biasC, biasO] = this.useBias ? split(this.bias.read(), numOfKernels) : [null, null, null, null];
      xI = this.inputConv(xI, kernelI, biasI, this.padding);
      xF = this.inputConv(xF, kernelF, biasF, this.padding);
      xC = this.inputConv(xC, kernelC, biasC, this.padding);
      xO = this.inputConv(xO, kernelO, biasO, this.padding);
      const [recKernelI, recKernelF, recKernelC, recKernelO] = split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);
      hI = this.recurrentConv(hI, recKernelI);
      hF = this.recurrentConv(hF, recKernelF);
      hC = this.recurrentConv(hC, recKernelC);
      hO = this.recurrentConv(hO, recKernelO);
      const i2 = this.recurrentActivation.apply(add2(xI, hI));
      const f2 = this.recurrentActivation.apply(add2(xF, hF));
      const c2 = add2(mul(f2, cTMinus1), mul(i2, this.activation.apply(add2(xC, hC))));
      const h2 = mul(this.recurrentActivation.apply(add2(xO, hO)), this.activation.apply(c2));
      return [h2, h2, c2];
    });
  }
  getConfig() {
    const _a = super.getConfig(), { "units": _2 } = _a, baseConfig = __rest(_a, ["units"]);
    const config3 = {
      filters: this.filters,
      kernelSize: this.kernelSize,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      strides: this.strides
    };
    return Object.assign({}, baseConfig, config3);
  }
  inputConv(x2, w2, b2, padding2) {
    const out = conv2d(x2, w2, this.strides, padding2 || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
    if (b2) {
      return biasAdd(out, b2, this.dataFormat);
    }
    return out;
  }
  recurrentConv(x2, w2) {
    const strides = 1;
    return conv2d(x2, w2, strides, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
  }
};
ConvLSTM2DCell.className = "ConvLSTM2DCell";
serialization_exports.registerClass(ConvLSTM2DCell);
var ConvLSTM2D = class extends ConvRNN2D {
  constructor(args) {
    const cell = new ConvLSTM2DCell(args);
    super(Object.assign({}, args, { cell }));
  }
  static fromConfig(cls, config3) {
    return new cls(config3);
  }
};
ConvLSTM2D.className = "ConvLSTM2D";
serialization_exports.registerClass(ConvLSTM2D);
var Dropout = class extends Layer {
  constructor(args) {
    super(args);
    this.rate = Math.max(Math.min(args.rate, 1), 0);
    this.noiseShape = args.noiseShape;
    this.seed = args.seed;
    this.supportsMasking = true;
  }
  getNoiseShape(input2) {
    if (this.noiseShape == null) {
      return this.noiseShape;
    }
    const inputShape = input2.shape;
    const noiseShape = [];
    for (let i2 = 0; i2 < this.noiseShape.length; ++i2) {
      noiseShape.push(this.noiseShape[i2] == null ? inputShape[i2] : this.noiseShape[i2]);
    }
    return noiseShape;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      if (0 < this.rate && this.rate < 1) {
        const training = kwargs["training"] == null ? false : kwargs["training"];
        const noiseShape = this.getNoiseShape(input2);
        const output = inTrainPhase(() => dropout2(input2, this.rate, noiseShape, this.seed), () => input2, training);
        return output;
      }
      return inputs;
    });
  }
  getConfig() {
    const config3 = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
  dispose() {
    return super.dispose();
  }
};
Dropout.className = "Dropout";
serialization_exports.registerClass(Dropout);
var SpatialDropout1D = class extends Dropout {
  constructor(args) {
    super(args);
    this.inputSpec = [{ ndim: 3 }];
  }
  getNoiseShape(input2) {
    const inputShape = input2.shape;
    return [inputShape[0], 1, inputShape[2]];
  }
};
SpatialDropout1D.className = "SpatialDropout1D";
serialization_exports.registerClass(SpatialDropout1D);
var Dense = class extends Layer {
  constructor(args) {
    super(args);
    this.activation = null;
    this.useBias = true;
    this.kernel = null;
    this.bias = null;
    this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
    this.DEFAULT_BIAS_INITIALIZER = "zeros";
    if (args.batchInputShape == null && args.inputShape == null && args.inputDim != null) {
      let batchSize = null;
      if (args.batchSize != null) {
        batchSize = args.batchSize;
      }
      this.batchInputShape = [batchSize, args.inputDim];
    }
    this.units = args.units;
    assertPositiveInteger(this.units, "units");
    this.activation = getActivation(args.activation);
    if (args.useBias != null) {
      this.useBias = args.useBias;
    }
    this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
    this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
    this.kernelConstraint = getConstraint(args.kernelConstraint);
    this.biasConstraint = getConstraint(args.biasConstraint);
    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    this.biasRegularizer = getRegularizer(args.biasRegularizer);
    this.activityRegularizer = getRegularizer(args.activityRegularizer);
    this.supportsMasking = true;
    this.inputSpec = [{ minNDim: 2 }];
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const inputLastDim = inputShape[inputShape.length - 1];
    if (this.kernel == null) {
      this.kernel = this.addWeight("kernel", [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
    }
    this.inputSpec = [{ minNDim: 2, axes: { [-1]: inputLastDim } }];
    this.built = true;
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const outputShape = inputShape.slice();
    outputShape[outputShape.length - 1] = this.units;
    return outputShape;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
      let output;
      if (fusedActivationName != null) {
        output = dot2(input2, this.kernel.read(), fusedActivationName, this.bias ? this.bias.read() : null);
      } else {
        output = dot2(input2, this.kernel.read());
        if (this.bias != null) {
          output = biasAdd(output, this.bias.read());
        }
        if (this.activation != null) {
          output = this.activation.apply(output);
        }
      }
      return output;
    });
  }
  getConfig() {
    const config3 = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint)
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Dense.className = "Dense";
serialization_exports.registerClass(Dense);
var Flatten = class extends Layer {
  constructor(args) {
    args = args || {};
    super(args);
    this.inputSpec = [{ minNDim: 3 }];
    this.dataFormat = args.dataFormat;
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    for (const dim of inputShape.slice(1)) {
      if (dim == null) {
        throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${inputShape.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
      }
    }
    return [inputShape[0], arrayProd(inputShape, 1)];
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      let input2 = getExactlyOneTensor(inputs);
      if (this.dataFormat === "channelsFirst" && input2.rank > 1) {
        const permutation = [0];
        for (let i2 = 2; i2 < input2.rank; ++i2) {
          permutation.push(i2);
        }
        permutation.push(1);
        input2 = transpose(input2, permutation);
      }
      return batchFlatten(input2);
    });
  }
  getConfig() {
    const config3 = {};
    if (this.dataFormat != null) {
      config3["dataFormat"] = this.dataFormat;
    }
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Flatten.className = "Flatten";
serialization_exports.registerClass(Flatten);
var Activation2 = class extends Layer {
  constructor(args) {
    super(args);
    this.supportsMasking = true;
    this.activation = getActivation(args.activation);
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      return this.activation.apply(input2);
    });
  }
  getConfig() {
    const config3 = { activation: serializeActivation(this.activation) };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Activation2.className = "Activation";
serialization_exports.registerClass(Activation2);
var RepeatVector = class extends Layer {
  constructor(args) {
    super(args);
    this.n = args.n;
    this.inputSpec = [{ ndim: 2 }];
  }
  computeOutputShape(inputShape) {
    return [inputShape[0], this.n, inputShape[1]];
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      return repeat(inputs, this.n);
    });
  }
  getConfig() {
    const config3 = {
      n: this.n
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
RepeatVector.className = "RepeatVector";
serialization_exports.registerClass(RepeatVector);
var Reshape2 = class extends Layer {
  constructor(args) {
    super(args);
    this.targetShape = args.targetShape;
    for (let i2 = 0; i2 < this.targetShape.length; ++i2) {
      if (this.isUnknown(this.targetShape[i2])) {
        this.targetShape[i2] = null;
      }
    }
  }
  isUnknown(dim) {
    return dim < 0 || dim == null;
  }
  fixUnknownDimension(inputShape, outputShape) {
    const errorMsg = "Total size of new array must be unchanged.";
    const finalShape = outputShape.slice();
    let known = 1;
    let unknown = null;
    for (let i2 = 0; i2 < finalShape.length; ++i2) {
      const dim = finalShape[i2];
      if (this.isUnknown(dim)) {
        if (unknown === null) {
          unknown = i2;
        } else {
          throw new ValueError("Can only specifiy one unknown dimension.");
        }
      } else {
        known *= dim;
      }
    }
    const originalSize = arrayProd(inputShape);
    if (unknown !== null) {
      if (known === 0 || originalSize % known !== 0) {
        throw new ValueError(errorMsg);
      }
      finalShape[unknown] = originalSize / known;
    } else if (originalSize !== known) {
      throw new ValueError(errorMsg);
    }
    return finalShape;
  }
  computeOutputShape(inputShape) {
    let anyUnknownDims = false;
    for (let i2 = 0; i2 < inputShape.length; ++i2) {
      if (this.isUnknown(inputShape[i2])) {
        anyUnknownDims = true;
        break;
      }
    }
    if (anyUnknownDims) {
      return inputShape.slice(0, 1).concat(this.targetShape);
    } else {
      return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      const inputShape = input2.shape;
      const outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
      return reshape(input2, outputShape);
    });
  }
  getConfig() {
    const config3 = {
      targetShape: this.targetShape
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Reshape2.className = "Reshape";
serialization_exports.registerClass(Reshape2);
var Permute = class extends Layer {
  constructor(args) {
    super(args);
    if (args.dims == null) {
      throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    }
    if (!Array.isArray(args.dims)) {
      throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${args.dims} instead.`);
    }
    const expectedSortedIndices = range2(1, args.dims.length + 1);
    if (!util_exports.arraysEqual(args.dims.slice().sort(), expectedSortedIndices)) {
      throw new Error("Invalid permutation `dims`: " + JSON.stringify(args.dims) + " `dims` must contain consecutive integers starting from 1.");
    }
    this.dims = args.dims;
    this.dimsIncludingBatch = [0].concat(this.dims);
    this.inputSpec = [new InputSpec({ ndim: this.dims.length + 1 })];
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const outputShape = inputShape.slice();
    this.dims.forEach((dim, i2) => {
      outputShape[i2 + 1] = inputShape[dim];
    });
    return outputShape;
  }
  call(inputs, kwargs) {
    return transpose(getExactlyOneTensor(inputs), this.dimsIncludingBatch);
  }
  getConfig() {
    const config3 = {
      dims: this.dims
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Permute.className = "Permute";
serialization_exports.registerClass(Permute);
var Masking = class extends Layer {
  constructor(args) {
    super(args == null ? {} : args);
    this.supportsMasking = true;
    if (args != null) {
      this.maskValue = args.maskValue == null ? 0 : args.maskValue;
    } else {
      this.maskValue = 0;
    }
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = { maskValue: this.maskValue };
    Object.assign(config3, baseConfig);
    return config3;
  }
  computeMask(inputs, mask) {
    const input2 = getExactlyOneTensor(inputs);
    const axis = -1;
    return any(notEqual(input2, this.maskValue), axis);
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      const axis = -1;
      const keepDims = true;
      const booleanMask = any(notEqual(input2, this.maskValue), axis, keepDims);
      const output = mul(input2, cast(booleanMask, input2.dtype));
      return output;
    });
  }
};
Masking.className = "Masking";
serialization_exports.registerClass(Masking);
var Embedding = class extends Layer {
  constructor(args) {
    super(args);
    this.embeddings = null;
    this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
    if (args.batchInputShape == null && args.inputShape == null) {
      let batchSize = null;
      if (args.batchSize != null) {
        batchSize = args.batchSize;
      }
      if (args.inputLength == null) {
        this.batchInputShape = [batchSize, null];
      } else {
        this.batchInputShape = [batchSize].concat(toList(args.inputLength));
      }
    }
    this.inputDim = args.inputDim;
    assertPositiveInteger(this.inputDim, "inputDim");
    this.outputDim = args.outputDim;
    assertPositiveInteger(this.outputDim, "outputDim");
    this.embeddingsInitializer = getInitializer(args.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER);
    this.embeddingsRegularizer = getRegularizer(args.embeddingsRegularizer);
    this.activityRegularizer = getRegularizer(args.activityRegularizer);
    this.embeddingsConstraint = getConstraint(args.embeddingsConstraint);
    this.maskZero = args.maskZero;
    this.supportsMasking = args.maskZero;
    this.inputLength = args.inputLength;
  }
  build(inputShape) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
    this.built = true;
  }
  warnOnIncompatibleInputShape(inputShape) {
  }
  computeMask(inputs, mask) {
    return tidy(() => {
      if (!this.maskZero) {
        return null;
      } else {
        inputs = getExactlyOneTensor(inputs);
        return notEqual(inputs, zerosLike(inputs));
      }
    });
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (this.inputLength == null) {
      return [...inputShape, this.outputDim];
    }
    const inLens = toList(this.inputLength);
    if (inLens.length !== inputShape.length - 1) {
      throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
    } else {
      let i2 = 0;
      for (let k3 = 0; k3 < inLens.length; ++k3) {
        const s1 = inLens[k3];
        const s2 = inputShape[k3 + 1];
        if (s1 != null && s2 != null && s1 !== s2) {
          throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
        } else if (s1 == null) {
          inLens[i2] = s2;
        }
        i2++;
      }
    }
    return [inputShape[0], ...inLens, this.outputDim];
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      let input2 = getExactlyOneTensor(inputs);
      if (input2.dtype !== "int32") {
        input2 = cast2(input2, "int32");
      }
      const output = gather2(this.embeddings.read(), reshape(input2, [input2.size]));
      return reshape(output, getExactlyOneShape(this.computeOutputShape(input2.shape)));
    });
  }
  getConfig() {
    const config3 = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
      embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Embedding.className = "Embedding";
serialization_exports.registerClass(Embedding);
var Merge = class extends Layer {
  constructor(args) {
    super(args || {});
    this.supportsMasking = true;
  }
  mergeFunction(inputs) {
    throw new NotImplementedError();
  }
  computeElementwiseOpOutputShape(shape1, shape2) {
    if (shape1 == null || shape2 == null) {
      return null;
    } else if (shape1.length < shape2.length) {
      return this.computeElementwiseOpOutputShape(shape2, shape1);
    } else if (shape2.length === 0) {
      return shape1;
    }
    const outputShape = shape1.slice(0, shape1.length - shape2.length);
    for (let k3 = 0; k3 < shape2.length; ++k3) {
      const i2 = shape1[shape1.length - shape2.length + k3];
      const j2 = shape2[k3];
      if (i2 == null || j2 == null || i2 < 0 || j2 < 0) {
        outputShape.push(null);
      } else if (i2 === 1) {
        outputShape.push(j2);
      } else if (j2 === 1) {
        outputShape.push(i2);
      } else {
        if (i2 !== j2) {
          throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(shape1) + " " + JSON.stringify(shape2));
        }
        outputShape.push(i2);
      }
    }
    return outputShape;
  }
  build(inputShape) {
    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
      inputShape = [getExactlyOneShape(inputShape)];
    }
    inputShape = inputShape;
    if (inputShape.length < 2) {
      throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${inputShape.length} input(s).`);
    }
    let batchSizes = [];
    for (const shape of inputShape) {
      if (shape != null && shape[0] !== null) {
        batchSizes.push(shape[0]);
      }
    }
    batchSizes = unique2(batchSizes);
    if (batchSizes.length > 1) {
      throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(inputShape)}.`);
    }
    let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
    for (let i2 = 1; i2 < inputShape.length; ++i2) {
      const shape = inputShape[i2] == null ? null : inputShape[i2].slice(1);
      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
    }
    const allRanks = inputShape.map((shape) => shape.length);
    if (inputShape.indexOf(null) === -1 && unique2(allRanks).length === 1) {
      this.reshapeRequired = false;
    } else {
      this.reshapeRequired = true;
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = inputs;
      if (this.reshapeRequired) {
        const reshapedInputs = [];
        const inputDims = inputs.map((input2) => input2.rank);
        if (inputDims.indexOf(null) === -1) {
          const maxNDim = max2(inputDims);
          for (let x2 of inputs) {
            const xNDim = x2.rank;
            for (let k3 = 0; k3 < maxNDim - xNDim; ++k3) {
              x2 = expandDims2(x2, 1);
            }
            reshapedInputs.push(x2);
          }
          return this.mergeFunction(reshapedInputs);
        } else {
          let transposed = false;
          for (const x2 of inputs) {
            const xNDim = x2.rank;
            if (xNDim == null) {
              const xShape = x2.shape;
              const batchSize = xShape[0];
              const newShape = xShape.slice(1).concat([batchSize]);
              let xTransposed = reshape(x2, [batchSize].concat(arrayProd(xShape.slice(1))));
              xTransposed = transpose(xTransposed, [1, 0]);
              xTransposed = reshape(xTransposed, newShape);
              reshapedInputs.push(xTransposed);
              transposed = true;
            } else if (xNDim > 1) {
              const dims = range2(1, xNDim).concat([0]);
              reshapedInputs.push(transpose(x2, dims));
              transposed = true;
            } else {
              reshapedInputs.push(x2);
            }
          }
          let y2 = this.mergeFunction(reshapedInputs);
          const yNDim = y2.rank;
          if (transposed) {
            if (yNDim == null) {
              const yShape = y2.shape;
              const yNDim2 = yShape.length;
              const batchSize = yShape[yNDim2 - 1];
              const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
              y2 = reshape(transpose(reshape(y2, [-1, batchSize]), [1, 0]), newShape);
            } else if (yNDim > 1) {
              const dims = [yNDim - 1].concat(range2(0, yNDim - 1));
              y2 = transpose(y2, dims);
            }
          }
          return y2;
        }
      } else {
        return this.mergeFunction(inputs);
      }
    });
  }
  computeOutputShape(inputShape) {
    inputShape = inputShape;
    let outputShape;
    if (inputShape[0] == null) {
      outputShape = null;
    } else {
      outputShape = inputShape[0].slice(1);
    }
    for (let i2 = 1; i2 < inputShape.length; ++i2) {
      const shape = inputShape[i2] == null ? null : inputShape[i2].slice(1);
      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
    }
    let batchSizes = [];
    for (const shape of inputShape) {
      if (shape != null && shape[0] !== null) {
        batchSizes.push(shape[0]);
      }
    }
    batchSizes = unique2(batchSizes);
    if (batchSizes.length === 1) {
      outputShape = batchSizes.concat(outputShape);
    } else {
      outputShape = [null].concat(outputShape);
    }
    return outputShape;
  }
  computeMask(inputs, mask) {
    return tidy(() => {
      if (mask == null) {
        return null;
      }
      if (!Array.isArray(mask)) {
        throw new ValueError("`mask` should be an Array");
      }
      if (!Array.isArray(inputs)) {
        throw new ValueError("`inputs` should be an Array");
      }
      if (mask.length !== inputs.length) {
        throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${inputs.length} vs ${mask.length})`);
      }
      if (mask.every((m2) => m2 == null)) {
        return null;
      }
      mask = mask.map((m2) => m2 == null ? m2 : expandDims(m2, 0));
      let output = mask[0];
      for (let i2 = 1; i2 < mask.length - 1; ++i2) {
        output = logicalAnd(output, mask[i2]);
      }
      return output;
    });
  }
};
var Add2 = class extends Merge {
  constructor(args) {
    super(args);
  }
  mergeFunction(inputs) {
    return tidy(() => {
      let output = inputs[0].clone();
      for (let i2 = 1; i2 < inputs.length; ++i2) {
        output = add2(output, inputs[i2]);
      }
      return output;
    });
  }
};
Add2.className = "Add";
serialization_exports.registerClass(Add2);
var Multiply2 = class extends Merge {
  constructor(args) {
    super(args);
  }
  mergeFunction(inputs) {
    return tidy(() => {
      let output = inputs[0].clone();
      for (let i2 = 1; i2 < inputs.length; ++i2) {
        output = mul(output, inputs[i2]);
      }
      return output;
    });
  }
};
Multiply2.className = "Multiply";
serialization_exports.registerClass(Multiply2);
var Average = class extends Merge {
  constructor(args) {
    super(args);
  }
  mergeFunction(inputs) {
    return tidy(() => {
      let output = inputs[0].clone();
      for (let i2 = 1; i2 < inputs.length; ++i2) {
        output = add2(output, inputs[i2]);
      }
      return mul(1 / inputs.length, output);
    });
  }
};
Average.className = "Average";
serialization_exports.registerClass(Average);
var Maximum2 = class extends Merge {
  constructor(args) {
    super(args);
  }
  mergeFunction(inputs) {
    return tidy(() => {
      let output = inputs[0];
      for (let i2 = 1; i2 < inputs.length; ++i2) {
        output = maximum(output, inputs[i2]);
      }
      return output;
    });
  }
};
Maximum2.className = "Maximum";
serialization_exports.registerClass(Maximum2);
var Minimum2 = class extends Merge {
  constructor(args) {
    super(args);
  }
  mergeFunction(inputs) {
    return tidy(() => {
      let output = inputs[0];
      for (let i2 = 1; i2 < inputs.length; ++i2) {
        output = minimum(output, inputs[i2]);
      }
      return output;
    });
  }
};
Minimum2.className = "Minimum";
serialization_exports.registerClass(Minimum2);
var Concatenate = class extends Merge {
  constructor(args) {
    super(args);
    this.DEFAULT_AXIS = -1;
    if (args == null) {
      args = {};
    }
    this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
    this.supportsMasking = true;
    this.reshapeRequired = false;
  }
  build(inputShape) {
    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {
      throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");
    }
    inputShape = inputShape;
    let allNoneShape = true;
    for (const shape of inputShape) {
      if (shape != null) {
        allNoneShape = false;
        break;
      }
    }
    if (allNoneShape) {
      return;
    }
    const shapeSet = [];
    for (let i2 = 0; i2 < inputShape.length; ++i2) {
      const shapeWithoutConcatAxis = inputShape[i2].slice();
      shapeWithoutConcatAxis.splice(this.axis, 1);
      let exists = false;
      for (const shape of shapeSet) {
        if (util_exports.arraysEqual(shape, shapeWithoutConcatAxis)) {
          exists = true;
          break;
        }
      }
      if (!exists) {
        shapeSet.push(shapeWithoutConcatAxis);
      }
    }
    if (shapeSet.length > 1) {
      throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(inputShape));
    }
  }
  mergeFunction(inputs) {
    return tidy(() => {
      return concatenate(inputs, this.axis);
    });
  }
  computeOutputShape(inputShape) {
    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
      throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
    }
    const inputShapes = inputShape;
    const outputShape = inputShapes[0].slice();
    const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
    for (const shape of inputShapes.slice(1)) {
      if (outputShape[axis] == null || shape[axis] == null) {
        outputShape[axis] = null;
        break;
      }
      outputShape[axis] += shape[axis];
    }
    return outputShape;
  }
  computeMask(inputs, mask) {
    if (mask == null) {
      return null;
    }
    if (!Array.isArray(mask)) {
      throw new ValueError("`mask` should be an array for Concatenate");
    }
    if (!Array.isArray(inputs)) {
      throw new ValueError("`inputs` should be an array for Concatenate");
    }
    if (mask.length !== inputs.length) {
      throw new ValueError(`Mismatch in the length of mask (${mask.length}) and the legnth of inputs (${inputs.length})`);
    }
    return tidy(() => {
      let allNullMasks = true;
      mask.forEach((m2) => {
        if (m2 != null) {
          allNullMasks = false;
          return;
        }
      });
      if (allNullMasks) {
        return null;
      }
      const outputMasks = [];
      for (let i2 = 0; i2 < inputs.length; ++i2) {
        if (mask[i2] == null) {
          outputMasks.push(cast(onesLike(inputs[i2]), "bool"));
        } else if (mask[i2].rank < inputs[i2].rank) {
          outputMasks.push(expandDims(mask[i2], -1));
        } else {
          outputMasks.push(mask[i2]);
        }
      }
      const concatenatedMasks = concat(outputMasks, this.axis);
      return all(concatenatedMasks, -1, false);
    });
  }
  getConfig() {
    const config3 = {
      "axis": this.axis
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Concatenate.className = "Concatenate";
serialization_exports.registerClass(Concatenate);
function interpretAxis(axis, dim) {
  while (axis < 0) {
    axis += dim;
  }
  return axis;
}
function batchDot(x2, y2, axes) {
  if (x2.shape.length > 3 || y2.shape.length > 3) {
    throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
  }
  util_exports.assert(x2.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${x2.shape.length}`);
  util_exports.assert(x2.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${y2.shape.length}`);
  if (typeof axes === "number") {
    axes = [axes, axes];
  }
  if (x2.dtype === "complex64" || y2.dtype === "complex64") {
    throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
  }
  const xNDim = x2.shape.length;
  const yNDim = y2.shape.length;
  if (axes == null) {
    axes = [xNDim - 1, yNDim - 2];
  }
  const axesArray = axes;
  return tidy(() => {
    let diff;
    if (xNDim > yNDim) {
      diff = xNDim - yNDim;
      const diffShape = [];
      for (let i2 = 0; i2 < diff; ++i2) {
        diffShape.push(1);
      }
      y2 = reshape(y2, y2.shape.concat(diffShape));
    } else if (yNDim > xNDim) {
      diff = yNDim - xNDim;
      const diffShape = [];
      for (let i2 = 0; i2 < diff; ++i2) {
        diffShape.push(1);
      }
      x2 = reshape(x2, x2.shape.concat(diffShape));
    } else {
      diff = 0;
    }
    let out;
    if (x2.shape.length === 2 && y2.shape.length === 2) {
      if (axesArray[0] === axesArray[1]) {
        out = sum2(mul(x2, y2), axesArray[0]);
      } else {
        out = sum2(mul(transpose(x2, [1, 0]), y2), axesArray[1]);
      }
    } else {
      const adjX = axesArray[0] !== x2.shape.length - 1;
      const adjY = axesArray[1] === y2.shape.length - 1;
      out = matMul(x2, y2, adjX, adjY);
    }
    if (diff > 0) {
      let idx;
      if (xNDim > yNDim) {
        idx = xNDim + yNDim - 3;
      } else {
        idx = xNDim - 1;
      }
      const squeezeAxes = [];
      for (let i2 = idx; i2 < idx + diff; ++i2) {
        squeezeAxes.push(i2);
      }
      out = squeeze(out, squeezeAxes);
    }
    if (out.shape.length === 1) {
      out = expandDims(out, 1);
    }
    return out;
  });
}
var Dot = class extends Merge {
  constructor(args) {
    super(args);
    this.axes = args.axes;
    this.normalize = args.normalize == null ? false : args.normalize;
    this.supportsMasking = true;
    this.reshapeRequired = false;
  }
  build(inputShape) {
    util_exports.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const shape1 = inputShape[0];
    const shape2 = inputShape[1];
    if (shape1.length > 3 || shape2.length > 3) {
      throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    }
    const axes = this.interpretAxes(shape1, shape2);
    if (shape1[axes[0]] !== shape2[axes[1]]) {
      throw new ValueError(`Dimension incompatibility: ${shape1[axes[0]]} !== ${shape2[axes[1]]}`);
    }
  }
  mergeFunction(inputs) {
    if (inputs.length !== 2) {
      throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${inputs.length} input(s).`);
    }
    let x1 = inputs[0];
    let x2 = inputs[1];
    let axes;
    if (!Array.isArray(this.axes)) {
      axes = [
        interpretAxis(this.axes, x1.shape.length),
        interpretAxis(this.axes, x2.shape.length)
      ];
    } else {
      axes = this.axes.map((axis, i2) => interpretAxis(axis, inputs[i2].shape.length));
    }
    if (this.normalize) {
      x1 = l2Normalize(x1, axes[0]);
      x2 = l2Normalize(x2, axes[1]);
    }
    return batchDot(x1, x2, axes);
  }
  interpretAxes(shape1, shape2) {
    let axes;
    if (!Array.isArray(this.axes)) {
      axes = [
        interpretAxis(this.axes, shape1.length),
        interpretAxis(this.axes, shape2.length)
      ];
    } else {
      axes = this.axes;
    }
    return axes;
  }
  computeOutputShape(inputShape) {
    util_exports.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const shape1 = inputShape[0].slice();
    const shape2 = inputShape[1].slice();
    if (shape1.length > 3 || shape2.length > 3) {
      throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    }
    const axes = this.interpretAxes(shape1, shape2);
    shape1.splice(axes[0], 1);
    shape2.splice(axes[1], 1);
    shape2.splice(0, 1);
    const outputShape = shape1.concat(shape2);
    if (outputShape.length === 1) {
      outputShape.push(1);
    }
    return outputShape;
  }
  computeMask(inputs, mask) {
    return null;
  }
  getConfig() {
    const config3 = {
      "axes": this.axes,
      "normalize": this.normalize
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
Dot.className = "Dot";
serialization_exports.registerClass(Dot);
var GaussianNoise = class extends Layer {
  constructor(args) {
    super(args);
    this.supportsMasking = true;
    this.stddev = args.stddev;
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = { stddev: this.stddev };
    Object.assign(config3, baseConfig);
    return config3;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      const noised = () => add2(randomNormal2(input2.shape, 0, this.stddev), input2);
      const output = inTrainPhase(noised, () => input2, kwargs["training"] || false);
      return output;
    });
  }
};
GaussianNoise.className = "GaussianNoise";
serialization_exports.registerClass(GaussianNoise);
var GaussianDropout = class extends Layer {
  constructor(args) {
    super(args);
    this.supportsMasking = true;
    this.rate = args.rate;
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = { rate: this.rate };
    Object.assign(config3, baseConfig);
    return config3;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      const input2 = getExactlyOneTensor(inputs);
      if (this.rate > 0 && this.rate < 1) {
        const noised = () => {
          const stddev = Math.sqrt(this.rate / (1 - this.rate));
          return mul(input2, randomNormal2(input2.shape, 1, stddev));
        };
        return inTrainPhase(noised, () => input2, kwargs["training"] || false);
      }
      return input2;
    });
  }
};
GaussianDropout.className = "GaussianDropout";
serialization_exports.registerClass(GaussianDropout);
var AlphaDropout = class extends Layer {
  constructor(args) {
    super(args);
    this.supportsMasking = true;
    this.rate = args.rate;
    this.noiseShape = args.noiseShape;
  }
  _getNoiseShape(inputs) {
    return this.noiseShape || getExactlyOneTensor(inputs).shape;
  }
  computeOutputShape(inputShape) {
    return inputShape;
  }
  getConfig() {
    const baseConfig = super.getConfig();
    const config3 = { rate: this.rate };
    Object.assign(config3, baseConfig);
    return config3;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      if (this.rate < 1 && this.rate > 0) {
        const noiseShape = this._getNoiseShape(inputs);
        const droppedInputs = () => {
          const input2 = getExactlyOneTensor(inputs);
          const alpha = 1.6732632423543772;
          const scale22 = 1.0507009873554805;
          const alphaP = -alpha * scale22;
          let keptIdx = greaterEqual(randomUniform(noiseShape), this.rate);
          keptIdx = cast2(keptIdx, "float32");
          const a6 = ((1 - this.rate) * (1 + this.rate * alphaP ** 2)) ** -0.5;
          const b2 = -a6 * alphaP * this.rate;
          const x2 = add2(mul(input2, keptIdx), mul(add2(keptIdx, -1), alphaP));
          return add2(mul(x2, a6), b2);
        };
        return inTrainPhase(droppedInputs, () => getExactlyOneTensor(inputs), kwargs["training"] || false);
      }
      return inputs;
    });
  }
};
AlphaDropout.className = "AlphaDropout";
serialization_exports.registerClass(AlphaDropout);
function batchNormalization(x2, mean5, variance, beta, gamma, epsilon3 = 1e-3) {
  let out;
  if (x2.rank === 2) {
    out = batchNorm2d(x2, mean5, variance, beta, gamma, epsilon3);
  } else if (x2.rank === 3) {
    out = batchNorm3d(x2, mean5, variance, beta, gamma, epsilon3);
  } else if (x2.rank === 4) {
    out = batchNorm4d(x2, mean5, variance, beta, gamma, epsilon3);
  } else {
    throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x2.rank} yet`);
  }
  return out;
}
function regularNormalizeBatchInTraining(x2, gamma, beta, reductionAxes, epsilon3 = 1e-3) {
  return tidy(() => {
    const meanAndVariance = moments(x2, reductionAxes);
    const mean5 = meanAndVariance.mean;
    const variance = meanAndVariance.variance;
    const normed = batchNormalization(x2, mean5, variance, beta, gamma, epsilon3);
    return [normed, mean5, variance];
  });
}
function broadcastNormalizeBatchInTraining(x2, gamma, beta, reductionAxes, epsilon3 = 1e-3) {
  return tidy(() => {
    const meanAndVariance = moments(x2, reductionAxes);
    const mean5 = meanAndVariance.mean;
    const variance = meanAndVariance.variance;
    const targetShape = [];
    for (const axis of range2(0, x2.rank)) {
      if (reductionAxes.indexOf(axis) !== -1) {
        targetShape.push(1);
      } else {
        targetShape.push(x2.shape[axis]);
      }
    }
    const broadcastMean = reshape(mean5, targetShape);
    const broadcastVariance = reshape(variance, targetShape);
    const broadcastGamma = gamma == null ? null : reshape(gamma, targetShape);
    const broadcastBeta = beta == null ? null : reshape(beta, targetShape);
    const normed = batchNormalization(x2, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon3);
    return [normed, mean5, variance];
  });
}
function normalizeBatchInTraining(x2, gamma, beta, reductionAxes, epsilon3 = 1e-3) {
  if (util_exports.arraysEqual(reductionAxes.slice().sort(), range2(0, x2.rank - 1))) {
    return regularNormalizeBatchInTraining(x2, gamma, beta, reductionAxes, epsilon3);
  } else {
    return broadcastNormalizeBatchInTraining(x2, gamma, beta, reductionAxes, epsilon3);
  }
}
var BatchNormalization = class extends Layer {
  constructor(args) {
    if (args == null) {
      args = {};
    }
    super(args);
    this.supportsMasking = true;
    this.axis = args.axis == null ? -1 : args.axis;
    this.momentum = args.momentum == null ? 0.99 : args.momentum;
    this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
    this.center = args.center == null ? true : args.center;
    this.scale = args.scale == null ? true : args.scale;
    this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
    this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
    this.movingMeanInitializer = getInitializer(args.movingMeanInitializer || "zeros");
    this.movingVarianceInitializer = getInitializer(args.movingVarianceInitializer || "ones");
    this.betaConstraint = getConstraint(args.betaConstraint);
    this.gammaConstraint = getConstraint(args.gammaConstraint);
    this.betaRegularizer = getRegularizer(args.betaRegularizer);
    this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const axis = this.axis >= 0 ? this.axis : this.axis + inputShape.length;
    const dim = inputShape[axis];
    if (dim == null) {
      throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(inputShape)}.`);
    }
    this.inputSpec = [new InputSpec({ ndim: inputShape.length, axes: { [axis]: dim } })];
    const shape = [dim];
    if (this.scale) {
      this.gamma = this.addWeight("gamma", shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
    }
    if (this.center) {
      this.beta = this.addWeight("beta", shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
    }
    this.movingMean = this.addWeight("moving_mean", shape, null, this.movingMeanInitializer, null, false);
    this.movingVariance = this.addWeight("moving_variance", shape, null, this.movingVarianceInitializer, null, false);
    this.built = true;
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const training = kwargs["training"] == null ? false : kwargs["training"];
      const input2 = getExactlyOneTensor(inputs);
      const inputShape = input2.shape;
      const ndim = inputShape.length;
      const reductionAxes = range2(0, ndim);
      const axis = this.axis >= 0 ? this.axis : this.axis + ndim;
      reductionAxes.splice(axis, 1);
      const broadcastShape = pyListRepeat(1, ndim);
      broadcastShape[axis] = inputShape[axis];
      const sortedReductionAxes = reductionAxes.slice();
      sortedReductionAxes.sort();
      const needsBroadcasting = !util_exports.arraysEqual(sortedReductionAxes, range2(0, ndim).slice(0, ndim - 1));
      const normalizeInference = () => {
        if (needsBroadcasting) {
          const broadcastMovingMean = reshape(this.movingMean.read(), broadcastShape);
          const broadcastMovingVariance = reshape(this.movingVariance.read(), broadcastShape);
          const broadcastBeta = this.center ? reshape(this.beta.read(), broadcastShape) : null;
          const broadcastGamma = this.scale ? reshape(this.gamma.read(), broadcastShape) : null;
          return batchNormalization(input2, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, this.epsilon);
        } else {
          return batchNormalization(input2, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
        }
      };
      if (!training) {
        return normalizeInference();
      }
      const [normedTraining, mean5, variance] = normalizeBatchInTraining(input2, this.gamma.read(), this.beta.read(), reductionAxes, this.epsilon);
      const doMovingAverage = (variable2, value, momentum) => {
        tidy(() => {
          const decay = 1 - momentum;
          const origValue = variable2.read();
          const updateDelta = mul(sub(origValue, value), decay);
          variable2.write(sub(origValue, updateDelta));
        });
      };
      const updateMovingMeanAndVariance = () => {
        doMovingAverage(this.movingMean, mean5, this.momentum);
        doMovingAverage(this.movingVariance, variance, this.momentum);
      };
      updateMovingMeanAndVariance();
      return normedTraining;
    });
  }
  getConfig() {
    const config3 = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
      movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
      betaConstraint: serializeConstraint(this.betaConstraint),
      gammaConstraint: serializeConstraint(this.gammaConstraint)
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
BatchNormalization.className = "BatchNormalization";
serialization_exports.registerClass(BatchNormalization);
var LayerNormalization = class extends Layer {
  constructor(args) {
    if (args == null) {
      args = {};
    }
    super(args);
    this.axis = args.axis == null ? -1 : args.axis;
    if (typeof this.axis === "number") {
      if (!Number.isInteger(this.axis)) {
        throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
      }
    } else if (Array.isArray(this.axis)) {
      for (const axis of this.axis) {
        if (!Number.isInteger(axis)) {
          throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
        }
      }
    } else {
      throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
    }
    this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
    this.center = args.center == null ? true : args.center;
    this.scale = args.scale == null ? true : args.scale;
    this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
    this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
    this.betaRegularizer = getRegularizer(args.betaRegularizer);
    this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
    this.supportsMasking = true;
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const nDims = inputShape.length;
    if (typeof this.axis === "number") {
      this.axis = [this.axis];
    }
    for (let i2 = 0; i2 < this.axis.length; ++i2) {
      if (this.axis[i2] < 0) {
        this.axis[i2] += nDims;
      }
    }
    for (const axis of this.axis) {
      if (axis < 0 || axis >= nDims) {
        throw new Error(`Invalid axis: ${axis}`);
      }
    }
    if (this.axis.length !== unique2(this.axis).length) {
      throw new Error(`Found duplicate axes in: ${this.axis}`);
    }
    const paramShape = this.axis.map((axis) => inputShape[axis]);
    const trainable = true;
    if (this.scale) {
      this.gamma = this.addWeight("gamma", paramShape, "float32", this.gammaInitializer, this.gammaRegularizer, trainable);
    } else {
      this.gamma = null;
    }
    if (this.center) {
      this.beta = this.addWeight("beta", paramShape, "float32", this.betaInitializer, this.betaRegularizer, trainable);
    } else {
      this.beta = null;
    }
    this.built = true;
  }
  call(inputs, kwargs) {
    const input2 = getExactlyOneTensor(inputs);
    const inputShape = input2.shape;
    const nDims = inputShape.length;
    return tidy(() => {
      const keepDims = true;
      let { mean: mean5, variance } = moments(input2, this.axis, keepDims);
      const broadcastShape = pyListRepeat(1, nDims);
      for (const dim of this.axis) {
        broadcastShape[dim] = inputShape[dim];
      }
      const broadcast = (v2) => {
        if (v2 != null && v2.shape.length !== nDims && this.axis !== [nDims - 1]) {
          return reshape(v2, broadcastShape);
        } else {
          return v2;
        }
      };
      let scale22 = broadcast(this.gamma.read());
      let offset = broadcast(this.beta.read());
      const momentsTiling = [];
      const scaleOffsetTiling = [];
      for (let i2 = 0; i2 < nDims; ++i2) {
        if (this.axis.indexOf(i2) !== -1) {
          momentsTiling.push(inputShape[i2]);
          scaleOffsetTiling.push(1);
        } else {
          momentsTiling.push(1);
          scaleOffsetTiling.push(inputShape[i2]);
        }
      }
      mean5 = tile(mean5, momentsTiling);
      variance = tile(variance, momentsTiling);
      scale22 = tile(scale22, scaleOffsetTiling);
      offset = tile(offset, scaleOffsetTiling);
      return batchNormalization(input2, mean5, variance, offset, scale22, this.epsilon);
    });
  }
  getConfig() {
    const config3 = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
LayerNormalization.className = "LayerNormalization";
serialization_exports.registerClass(LayerNormalization);
function spatial2dPadding(x2, padding2, dataFormat) {
  return tidy(() => {
    if (x2.rank !== 4) {
      throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${x2.rank}-D tensor.`);
    }
    if (padding2 == null) {
      padding2 = [[1, 1], [1, 1]];
    }
    if (padding2.length !== 2 || padding2[0].length !== 2 || padding2[1].length !== 2) {
      throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (dataFormat !== "channelsLast" && dataFormat !== "channelsFirst") {
      throw new ValueError(`Unknown data format: ${dataFormat}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
    }
    let pattern;
    if (dataFormat === "channelsFirst") {
      pattern = [[0, 0], [0, 0], padding2[0], padding2[1]];
    } else {
      pattern = [[0, 0], padding2[0], padding2[1], [0, 0]];
    }
    return pad(x2, pattern);
  });
}
var ZeroPadding2D = class extends Layer {
  constructor(args) {
    if (args == null) {
      args = {};
    }
    super(args);
    this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;
    if (args.padding == null) {
      this.padding = [[1, 1], [1, 1]];
    } else if (typeof args.padding === "number") {
      this.padding = [[args.padding, args.padding], [args.padding, args.padding]];
    } else {
      args.padding = args.padding;
      if (args.padding.length !== 2) {
        throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${args.padding.length} array.`);
      }
      let heightPadding;
      let widthPadding;
      if (typeof args.padding[0] === "number") {
        heightPadding = [args.padding[0], args.padding[0]];
        widthPadding = [args.padding[1], args.padding[1]];
      } else {
        args.padding = args.padding;
        if (args.padding[0].length !== 2) {
          throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${args.padding[0].length} array.`);
        }
        heightPadding = args.padding[0];
        if (args.padding[1].length !== 2) {
          throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${args.padding[1].length} array.`);
        }
        widthPadding = args.padding[1];
      }
      this.padding = [heightPadding, widthPadding];
    }
    this.inputSpec = [new InputSpec({ ndim: 4 })];
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    let rows;
    let cols;
    if (this.dataFormat === "channelsFirst") {
      if (inputShape[2] != null && inputShape[2] >= 0) {
        rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
      } else {
        rows = null;
      }
      if (inputShape[3] != null && inputShape[3] >= 0) {
        cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
      } else {
        cols = null;
      }
      return [inputShape[0], inputShape[1], rows, cols];
    } else {
      if (inputShape[1] != null && inputShape[1] >= 0) {
        rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
      } else {
        rows = null;
      }
      if (inputShape[2] != null && inputShape[2] >= 0) {
        cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
      } else {
        cols = null;
      }
      return [inputShape[0], rows, cols, inputShape[3]];
    }
  }
  call(inputs, kwargs) {
    return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));
  }
  getConfig() {
    const config3 = {
      padding: this.padding,
      dataFormat: this.dataFormat
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
ZeroPadding2D.className = "ZeroPadding2D";
serialization_exports.registerClass(ZeroPadding2D);
function pool2d(x2, poolSize, strides, padding2, dataFormat, poolMode) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    checkPoolMode(poolMode);
    checkPaddingMode(padding2);
    if (strides == null) {
      strides = [1, 1];
    }
    if (padding2 == null) {
      padding2 = "valid";
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (poolMode == null) {
      poolMode = "max";
    }
    x2 = preprocessConv2DInput(x2, dataFormat);
    let y2;
    const paddingString = padding2 === "same" ? "same" : "valid";
    if (poolMode === "max") {
      y2 = maxPool(x2, poolSize, strides, paddingString);
    } else {
      y2 = avgPool(x2, poolSize, strides, paddingString);
    }
    if (dataFormat === "channelsFirst") {
      y2 = transpose(y2, [0, 3, 1, 2]);
    }
    return y2;
  });
}
function pool3d(x2, poolSize, strides, padding2, dataFormat, poolMode) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    checkPoolMode(poolMode);
    checkPaddingMode(padding2);
    if (strides == null) {
      strides = [1, 1, 1];
    }
    if (padding2 == null) {
      padding2 = "valid";
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (poolMode == null) {
      poolMode = "max";
    }
    x2 = preprocessConv3DInput(x2, dataFormat);
    let y2;
    const paddingString = padding2 === "same" ? "same" : "valid";
    if (poolMode === "max") {
      y2 = maxPool3d(x2, poolSize, strides, paddingString);
    } else {
      y2 = avgPool3d(x2, poolSize, strides, paddingString);
    }
    if (dataFormat === "channelsFirst") {
      y2 = transpose(y2, [0, 4, 1, 2, 3]);
    }
    return y2;
  });
}
var Pooling1D = class extends Layer {
  constructor(args) {
    if (args.poolSize == null) {
      args.poolSize = 2;
    }
    super(args);
    if (typeof args.poolSize === "number") {
      this.poolSize = [args.poolSize];
    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === "number") {
      this.poolSize = args.poolSize;
    } else {
      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.poolSize)}`);
    }
    assertPositiveInteger(this.poolSize, "poolSize");
    if (args.strides == null) {
      this.strides = this.poolSize;
    } else {
      if (typeof args.strides === "number") {
        this.strides = [args.strides];
      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === "number") {
        this.strides = args.strides;
      } else {
        throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.strides)}`);
      }
    }
    assertPositiveInteger(this.strides, "strides");
    this.padding = args.padding == null ? "valid" : args.padding;
    checkPaddingMode(this.padding);
    this.inputSpec = [new InputSpec({ ndim: 3 })];
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
    return [inputShape[0], length, inputShape[2]];
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      inputs = expandDims2(getExactlyOneTensor(inputs), 2);
      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return squeeze(output, [2]);
    });
  }
  getConfig() {
    const config3 = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
var MaxPooling1D = class extends Pooling1D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool2d(inputs, poolSize, strides, padding2, dataFormat, "max");
  }
};
MaxPooling1D.className = "MaxPooling1D";
serialization_exports.registerClass(MaxPooling1D);
var AveragePooling1D = class extends Pooling1D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool2d(inputs, poolSize, strides, padding2, dataFormat, "avg");
  }
};
AveragePooling1D.className = "AveragePooling1D";
serialization_exports.registerClass(AveragePooling1D);
var Pooling2D = class extends Layer {
  constructor(args) {
    if (args.poolSize == null) {
      args.poolSize = [2, 2];
    }
    super(args);
    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];
    if (args.strides == null) {
      this.strides = this.poolSize;
    } else if (Array.isArray(args.strides)) {
      if (args.strides.length !== 2) {
        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${args.strides.length}.`);
      }
      this.strides = args.strides;
    } else {
      this.strides = [args.strides, args.strides];
    }
    assertPositiveInteger(this.poolSize, "poolSize");
    assertPositiveInteger(this.strides, "strides");
    this.padding = args.padding == null ? "valid" : args.padding;
    this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
    checkDataFormat(this.dataFormat);
    checkPaddingMode(this.padding);
    this.inputSpec = [new InputSpec({ ndim: 4 })];
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    let rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
    let cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
    if (this.dataFormat === "channelsFirst") {
      return [inputShape[0], inputShape[1], rows, cols];
    } else {
      return [inputShape[0], rows, cols, inputShape[3]];
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
    });
  }
  getConfig() {
    const config3 = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
var MaxPooling2D = class extends Pooling2D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool2d(inputs, poolSize, strides, padding2, dataFormat, "max");
  }
};
MaxPooling2D.className = "MaxPooling2D";
serialization_exports.registerClass(MaxPooling2D);
var AveragePooling2D = class extends Pooling2D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool2d(inputs, poolSize, strides, padding2, dataFormat, "avg");
  }
};
AveragePooling2D.className = "AveragePooling2D";
serialization_exports.registerClass(AveragePooling2D);
var Pooling3D = class extends Layer {
  constructor(args) {
    if (args.poolSize == null) {
      args.poolSize = [2, 2, 2];
    }
    super(args);
    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];
    if (args.strides == null) {
      this.strides = this.poolSize;
    } else if (Array.isArray(args.strides)) {
      if (args.strides.length !== 3) {
        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${args.strides.length}.`);
      }
      this.strides = args.strides;
    } else {
      this.strides = [args.strides, args.strides, args.strides];
    }
    assertPositiveInteger(this.poolSize, "poolSize");
    assertPositiveInteger(this.strides, "strides");
    this.padding = args.padding == null ? "valid" : args.padding;
    this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
    checkDataFormat(this.dataFormat);
    checkPaddingMode(this.padding);
    this.inputSpec = [new InputSpec({ ndim: 5 })];
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    let depths = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
    let rows = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
    let cols = this.dataFormat === "channelsFirst" ? inputShape[4] : inputShape[3];
    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);
    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);
    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);
    if (this.dataFormat === "channelsFirst") {
      return [inputShape[0], inputShape[1], depths, rows, cols];
    } else {
      return [inputShape[0], depths, rows, cols, inputShape[4]];
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      this.invokeCallHook(inputs, kwargs);
      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
    });
  }
  getConfig() {
    const config3 = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
var MaxPooling3D = class extends Pooling3D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool3d(inputs, poolSize, strides, padding2, dataFormat, "max");
  }
};
MaxPooling3D.className = "MaxPooling3D";
serialization_exports.registerClass(MaxPooling3D);
var AveragePooling3D = class extends Pooling3D {
  constructor(args) {
    super(args);
  }
  poolingFunction(inputs, poolSize, strides, padding2, dataFormat) {
    checkDataFormat(dataFormat);
    checkPaddingMode(padding2);
    return pool3d(inputs, poolSize, strides, padding2, dataFormat, "avg");
  }
};
AveragePooling3D.className = "AveragePooling3D";
serialization_exports.registerClass(AveragePooling3D);
var GlobalPooling1D = class extends Layer {
  constructor(args) {
    super(args);
    this.inputSpec = [new InputSpec({ ndim: 3 })];
  }
  computeOutputShape(inputShape) {
    return [inputShape[0], inputShape[2]];
  }
  call(inputs, kwargs) {
    throw new NotImplementedError();
  }
};
var GlobalAveragePooling1D = class extends GlobalPooling1D {
  constructor(args) {
    super(args || {});
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const input2 = getExactlyOneTensor(inputs);
      return mean(input2, 1);
    });
  }
};
GlobalAveragePooling1D.className = "GlobalAveragePooling1D";
serialization_exports.registerClass(GlobalAveragePooling1D);
var GlobalMaxPooling1D = class extends GlobalPooling1D {
  constructor(args) {
    super(args || {});
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const input2 = getExactlyOneTensor(inputs);
      return max(input2, 1);
    });
  }
};
GlobalMaxPooling1D.className = "GlobalMaxPooling1D";
serialization_exports.registerClass(GlobalMaxPooling1D);
var GlobalPooling2D = class extends Layer {
  constructor(args) {
    super(args);
    this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
    checkDataFormat(this.dataFormat);
    this.inputSpec = [new InputSpec({ ndim: 4 })];
  }
  computeOutputShape(inputShape) {
    inputShape = inputShape;
    if (this.dataFormat === "channelsLast") {
      return [inputShape[0], inputShape[3]];
    } else {
      return [inputShape[0], inputShape[1]];
    }
  }
  call(inputs, kwargs) {
    throw new NotImplementedError();
  }
  getConfig() {
    const config3 = { dataFormat: this.dataFormat };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
};
var GlobalAveragePooling2D = class extends GlobalPooling2D {
  call(inputs, kwargs) {
    return tidy(() => {
      const input2 = getExactlyOneTensor(inputs);
      if (this.dataFormat === "channelsLast") {
        return mean(input2, [1, 2]);
      } else {
        return mean(input2, [2, 3]);
      }
    });
  }
};
GlobalAveragePooling2D.className = "GlobalAveragePooling2D";
serialization_exports.registerClass(GlobalAveragePooling2D);
var GlobalMaxPooling2D = class extends GlobalPooling2D {
  call(inputs, kwargs) {
    return tidy(() => {
      const input2 = getExactlyOneTensor(inputs);
      if (this.dataFormat === "channelsLast") {
        return max(input2, [1, 2]);
      } else {
        return max(input2, [2, 3]);
      }
    });
  }
};
GlobalMaxPooling2D.className = "GlobalMaxPooling2D";
serialization_exports.registerClass(GlobalMaxPooling2D);
var Wrapper = class extends Layer {
  constructor(args) {
    super(args);
    this.layer = args.layer;
  }
  build(inputShape) {
    this.built = true;
  }
  get trainable() {
    if (this.layer != null) {
      return this.layer.trainable;
    } else {
      return false;
    }
  }
  set trainable(value) {
    if (this.layer != null) {
      this.layer.trainable = value;
    }
  }
  get trainableWeights() {
    return this.layer.trainableWeights;
  }
  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }
  get updates() {
    return this.layer._updates;
  }
  get losses() {
    return this.layer.losses;
  }
  getWeights() {
    return this.layer.getWeights();
  }
  setWeights(weights) {
    this.layer.setWeights(weights);
  }
  getConfig() {
    const config3 = {
      "layer": {
        "className": this.layer.getClassName(),
        "config": this.layer.getConfig()
      }
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
  setFastWeightInitDuringBuild(value) {
    super.setFastWeightInitDuringBuild(value);
    if (this.layer != null) {
      this.layer.setFastWeightInitDuringBuild(value);
    }
  }
  static fromConfig(cls, config3, customObjects = {}) {
    const layerConfig = config3["layer"];
    const layer = deserialize(layerConfig, customObjects);
    delete config3["layer"];
    const newConfig = { layer };
    Object.assign(newConfig, config3);
    return new cls(newConfig);
  }
};
var TimeDistributed = class extends Wrapper {
  constructor(args) {
    super(args);
    this.supportsMasking = true;
  }
  build(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    if (inputShape.length < 3) {
      throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(inputShape)}`);
    }
    this.inputSpec = [{ shape: inputShape }];
    const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
    if (!this.layer.built) {
      this.layer.build(childInputShape);
      this.layer.built = true;
    }
    super.build(inputShape);
  }
  computeOutputShape(inputShape) {
    inputShape = getExactlyOneShape(inputShape);
    const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
    const childOutputShape = this.layer.computeOutputShape(childInputShape);
    const timesteps = inputShape[1];
    return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
  }
  call(inputs, kwargs) {
    return tidy(() => {
      inputs = getExactlyOneTensor(inputs);
      const step5 = (inputs2, states) => {
        const output = getExactlyOneTensor(this.layer.call(inputs2, kwargs));
        return [output, []];
      };
      const rnnOutputs = rnn(step5, inputs, [], false, null, null, false, true);
      const y2 = rnnOutputs[1];
      return y2;
    });
  }
};
TimeDistributed.className = "TimeDistributed";
serialization_exports.registerClass(TimeDistributed);
function checkBidirectionalMergeMode(value) {
  checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", value);
}
var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat";
var Bidirectional = class extends Wrapper {
  constructor(args) {
    super(args);
    const layerConfig = args.layer.getConfig();
    const forwDict = {};
    forwDict["className"] = args.layer.getClassName();
    forwDict["config"] = layerConfig;
    this.forwardLayer = deserialize(forwDict);
    layerConfig["goBackwards"] = layerConfig["goBackwards"] === true ? false : true;
    const backDict = {};
    backDict["className"] = args.layer.getClassName();
    backDict["config"] = layerConfig;
    this.backwardLayer = deserialize(backDict);
    this.forwardLayer.name = "forward_" + this.forwardLayer.name;
    this.backwardLayer.name = "backward_" + this.backwardLayer.name;
    this.mergeMode = args.mergeMode === void 0 ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : args.mergeMode;
    checkBidirectionalMergeMode(this.mergeMode);
    if (args.weights) {
      throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
    }
    this._stateful = args.layer.stateful;
    this.returnSequences = args.layer.returnSequences;
    this.returnState = args.layer.returnState;
    this.supportsMasking = true;
    this._trainable = true;
    this.inputSpec = args.layer.inputSpec;
    this.numConstants = null;
  }
  get trainable() {
    return this._trainable;
  }
  set trainable(value) {
    this._trainable = value;
    if (this.forwardLayer != null) {
      this.forwardLayer.trainable = value;
    }
    if (this.backwardLayer != null) {
      this.backwardLayer.trainable = value;
    }
  }
  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }
  setWeights(weights) {
    const numWeights = weights.length;
    const numeightsOver2 = Math.floor(numWeights / 2);
    this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
    this.backwardLayer.setWeights(weights.slice(numeightsOver2));
  }
  computeOutputShape(inputShape) {
    let layerShapes = this.forwardLayer.computeOutputShape(inputShape);
    if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
      layerShapes = [layerShapes];
    }
    layerShapes = layerShapes;
    let outputShape;
    let outputShapes;
    let stateShape;
    if (this.returnState) {
      stateShape = layerShapes.slice(1);
      outputShape = layerShapes[0];
    } else {
      outputShape = layerShapes[0];
    }
    outputShape = outputShape;
    if (this.mergeMode === "concat") {
      outputShape[outputShape.length - 1] *= 2;
      outputShapes = [outputShape];
    } else if (this.mergeMode == null) {
      outputShapes = [outputShape, outputShape.slice()];
    } else {
      outputShapes = [outputShape];
    }
    if (this.returnState) {
      if (this.mergeMode == null) {
        return outputShapes.concat(stateShape).concat(stateShape.slice());
      }
      return [outputShape].concat(stateShape).concat(stateShape.slice());
    }
    return singletonOrArray(outputShapes);
  }
  apply(inputs, kwargs) {
    let initialState = kwargs == null ? null : kwargs["initialState"];
    let constants = kwargs == null ? null : kwargs["constants"];
    if (kwargs == null) {
      kwargs = {};
    }
    const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
    inputs = standardized.inputs;
    initialState = standardized.initialState;
    constants = standardized.constants;
    if (Array.isArray(inputs)) {
      initialState = inputs.slice(1);
      inputs = inputs[0];
    }
    if ((initialState == null || initialState.length === 0) && constants == null) {
      return super.apply(inputs, kwargs);
    }
    const additionalInputs = [];
    const additionalSpecs = [];
    if (initialState != null) {
      const numStates = initialState.length;
      if (numStates % 2 > 0) {
        throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      }
      kwargs["initialState"] = initialState;
      additionalInputs.push(...initialState);
      const stateSpecs = initialState.map((state) => new InputSpec({ shape: state.shape }));
      this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);
      this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);
      additionalSpecs.push(...stateSpecs);
    }
    if (constants != null) {
      throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");
    }
    const isSymbolicTensor = additionalInputs[0] instanceof SymbolicTensor;
    for (const tensor2 of additionalInputs) {
      if (tensor2 instanceof SymbolicTensor !== isSymbolicTensor) {
        throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      }
    }
    if (isSymbolicTensor) {
      const fullInput = [inputs].concat(additionalInputs);
      const fullInputSpec = this.inputSpec.concat(additionalSpecs);
      const originalInputSpec = this.inputSpec;
      this.inputSpec = fullInputSpec;
      const output = super.apply(fullInput, kwargs);
      this.inputSpec = originalInputSpec;
      return output;
    } else {
      return super.apply(inputs, kwargs);
    }
  }
  call(inputs, kwargs) {
    return tidy(() => {
      const initialState = kwargs["initialState"];
      let y2;
      let yRev;
      if (initialState == null) {
        y2 = this.forwardLayer.call(inputs, kwargs);
        yRev = this.backwardLayer.call(inputs, kwargs);
      } else {
        const forwardState = initialState.slice(0, initialState.length / 2);
        const backwardState = initialState.slice(initialState.length / 2);
        y2 = this.forwardLayer.call(inputs, Object.assign(kwargs, { initialState: forwardState }));
        yRev = this.backwardLayer.call(inputs, Object.assign(kwargs, { initialState: backwardState }));
      }
      let states;
      if (this.returnState) {
        if (Array.isArray(y2)) {
          states = y2.slice(1).concat(yRev.slice(1));
        } else {
        }
        y2 = y2[0];
        yRev = yRev[0];
      }
      if (this.returnSequences) {
        yRev = reverse(yRev, 1);
      }
      let output;
      if (this.mergeMode === "concat") {
        output = concatenate([y2, yRev]);
      } else if (this.mergeMode === "sum") {
        output = add2(y2, yRev);
      } else if (this.mergeMode === "ave") {
        output = mul(0.5, add2(y2, yRev));
      } else if (this.mergeMode === "mul") {
        output = mul(y2, yRev);
      } else if (this.mergeMode == null) {
        output = [y2, yRev];
      }
      if (this.returnState) {
        if (this.mergeMode == null) {
          return output.concat(states);
        }
        return [output].concat(states);
      }
      return output;
    });
  }
  resetStates(states) {
    this.forwardLayer.resetStates();
    this.backwardLayer.resetStates();
  }
  build(inputShape) {
    nameScope(this.forwardLayer.name, () => {
      this.forwardLayer.build(inputShape);
    });
    nameScope(this.backwardLayer.name, () => {
      this.backwardLayer.build(inputShape);
    });
    this.built = true;
  }
  computeMask(inputs, mask) {
    if (Array.isArray(mask)) {
      mask = mask[0];
    }
    let outputMask;
    if (this.returnSequences) {
      if (this.mergeMode == null) {
        outputMask = [mask, mask];
      } else {
        outputMask = mask;
      }
    } else {
      if (this.mergeMode == null) {
        outputMask = [null, null];
      } else {
        outputMask = null;
      }
    }
    if (this.returnState) {
      const states = this.forwardLayer.states;
      const stateMask = states.map((state) => null);
      if (Array.isArray(outputMask)) {
        return outputMask.concat(stateMask).concat(stateMask);
      } else {
        return [outputMask].concat(stateMask).concat(stateMask);
      }
    } else {
      return outputMask;
    }
  }
  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }
  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }
  setFastWeightInitDuringBuild(value) {
    super.setFastWeightInitDuringBuild(value);
    if (this.forwardLayer != null) {
      this.forwardLayer.setFastWeightInitDuringBuild(value);
    }
    if (this.backwardLayer != null) {
      this.backwardLayer.setFastWeightInitDuringBuild(value);
    }
  }
  getConfig() {
    const config3 = {
      "mergeMode": this.mergeMode
    };
    const baseConfig = super.getConfig();
    Object.assign(config3, baseConfig);
    return config3;
  }
  static fromConfig(cls, config3) {
    const rnnLayer = deserialize(config3["layer"]);
    delete config3["layer"];
    if (config3["numConstants"] != null) {
      throw new NotImplementedError(`Deserialization of a Bidirectional layer with numConstants present is not supported yet.`);
    }
    const newConfig = config3;
    newConfig["layer"] = rnnLayer;
    return new cls(newConfig);
  }
};
Bidirectional.className = "Bidirectional";
serialization_exports.registerClass(Bidirectional);
function inputLayer(args) {
  return new InputLayer(args);
}
function elu3(args) {
  return new ELU(args);
}
function reLU(args) {
  return new ReLU(args);
}
function leakyReLU(args) {
  return new LeakyReLU(args);
}
function prelu2(args) {
  return new PReLU(args);
}
function softmax2(args) {
  return new Softmax3(args);
}
function thresholdedReLU(args) {
  return new ThresholdedReLU(args);
}
function conv1d2(args) {
  return new Conv1D(args);
}
function conv2d3(args) {
  return new Conv2D2(args);
}
function conv2dTranspose2(args) {
  return new Conv2DTranspose(args);
}
function conv3d2(args) {
  return new Conv3D2(args);
}
function conv3dTranspose2(args) {
  return new Conv3DTranspose(args);
}
function separableConv2d2(args) {
  return new SeparableConv2D(args);
}
function cropping2D(args) {
  return new Cropping2D(args);
}
function upSampling2d(args) {
  return new UpSampling2D(args);
}
function depthwiseConv2d4(args) {
  return new DepthwiseConv2D(args);
}
function activation(args) {
  return new Activation2(args);
}
function dense(args) {
  return new Dense(args);
}
function dropout3(args) {
  return new Dropout(args);
}
function spatialDropout1d(args) {
  return new SpatialDropout1D(args);
}
function flatten3(args) {
  return new Flatten(args);
}
function repeatVector(args) {
  return new RepeatVector(args);
}
function reshape2(args) {
  return new Reshape2(args);
}
function permute(args) {
  return new Permute(args);
}
function embedding(args) {
  return new Embedding(args);
}
function add3(args) {
  return new Add2(args);
}
function average(args) {
  return new Average(args);
}
function concatenate2(args) {
  return new Concatenate(args);
}
function maximum2(args) {
  return new Maximum2(args);
}
function minimum2(args) {
  return new Minimum2(args);
}
function multiply(args) {
  return new Multiply2(args);
}
function dot3(args) {
  return new Dot(args);
}
function batchNormalization2(args) {
  return new BatchNormalization(args);
}
function layerNormalization(args) {
  return new LayerNormalization(args);
}
function zeroPadding2d(args) {
  return new ZeroPadding2D(args);
}
function averagePooling1d(args) {
  return new AveragePooling1D(args);
}
function avgPool1d(args) {
  return averagePooling1d(args);
}
function avgPooling1d(args) {
  return averagePooling1d(args);
}
function averagePooling2d(args) {
  return new AveragePooling2D(args);
}
function avgPool2d(args) {
  return averagePooling2d(args);
}
function avgPooling2d(args) {
  return averagePooling2d(args);
}
function averagePooling3d(args) {
  return new AveragePooling3D(args);
}
function avgPool3d2(args) {
  return averagePooling3d(args);
}
function avgPooling3d(args) {
  return averagePooling3d(args);
}
function globalAveragePooling1d(args) {
  return new GlobalAveragePooling1D(args);
}
function globalAveragePooling2d(args) {
  return new GlobalAveragePooling2D(args);
}
function globalMaxPooling1d(args) {
  return new GlobalMaxPooling1D(args);
}
function globalMaxPooling2d(args) {
  return new GlobalMaxPooling2D(args);
}
function maxPooling1d(args) {
  return new MaxPooling1D(args);
}
function maxPooling2d(args) {
  return new MaxPooling2D(args);
}
function maxPooling3d(args) {
  return new MaxPooling3D(args);
}
function gru(args) {
  return new GRU(args);
}
function gruCell(args) {
  return new GRUCell(args);
}
function lstm(args) {
  return new LSTM(args);
}
function lstmCell(args) {
  return new LSTMCell(args);
}
function simpleRNN(args) {
  return new SimpleRNN(args);
}
function simpleRNNCell(args) {
  return new SimpleRNNCell(args);
}
function convLstm2d(args) {
  return new ConvLSTM2D(args);
}
function convLstm2dCell(args) {
  return new ConvLSTM2DCell(args);
}
function rnn2(args) {
  return new RNN(args);
}
function stackedRNNCells(args) {
  return new StackedRNNCells(args);
}
function bidirectional(args) {
  return new Bidirectional(args);
}
function timeDistributed(args) {
  return new TimeDistributed(args);
}
var globalMaxPool1d = globalMaxPooling1d;
var globalMaxPool2d = globalMaxPooling2d;
var maxPool1d = maxPooling1d;
var maxPool2d = maxPooling2d;
function gaussianNoise(args) {
  return new GaussianNoise(args);
}
function gaussianDropout(args) {
  return new GaussianDropout(args);
}
function alphaDropout(args) {
  return new AlphaDropout(args);
}
function masking(args) {
  return new Masking(args);
}
var exports_metrics_exports = {};
__export2(exports_metrics_exports, {
  MAPE: () => MAPE2,
  MSE: () => MSE2,
  binaryAccuracy: () => binaryAccuracy2,
  binaryCrossentropy: () => binaryCrossentropy3,
  categoricalAccuracy: () => categoricalAccuracy2,
  categoricalCrossentropy: () => categoricalCrossentropy3,
  cosineProximity: () => cosineProximity2,
  mape: () => mape2,
  meanAbsoluteError: () => meanAbsoluteError2,
  meanAbsolutePercentageError: () => meanAbsolutePercentageError2,
  meanSquaredError: () => meanSquaredError3,
  mse: () => mse2,
  precision: () => precision2,
  recall: () => recall2,
  sparseCategoricalAccuracy: () => sparseCategoricalAccuracy2
});
function binaryAccuracy2(yTrue, yPred) {
  return binaryAccuracy(yTrue, yPred);
}
function binaryCrossentropy3(yTrue, yPred) {
  return binaryCrossentropy2(yTrue, yPred);
}
function sparseCategoricalAccuracy2(yTrue, yPred) {
  return sparseCategoricalAccuracy(yTrue, yPred);
}
function categoricalAccuracy2(yTrue, yPred) {
  return categoricalAccuracy(yTrue, yPred);
}
function categoricalCrossentropy3(yTrue, yPred) {
  return categoricalCrossentropy2(yTrue, yPred);
}
function precision2(yTrue, yPred) {
  return precision(yTrue, yPred);
}
function recall2(yTrue, yPred) {
  return recall(yTrue, yPred);
}
function cosineProximity2(yTrue, yPred) {
  return cosineProximity(yTrue, yPred);
}
function meanAbsoluteError2(yTrue, yPred) {
  return meanAbsoluteError(yTrue, yPred);
}
function meanAbsolutePercentageError2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function MAPE2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function mape2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function meanSquaredError3(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
function MSE2(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
function mse2(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
var exports_models_exports = {};
__export2(exports_models_exports, {
  modelFromJSON: () => modelFromJSON
});
var exports_regularizers_exports = {};
__export2(exports_regularizers_exports, {
  l1: () => l12,
  l1l2: () => l1l2,
  l2: () => l22
});
function l1l2(config3) {
  return new L1L2(config3);
}
function l12(config3) {
  return l1(config3);
}
function l22(config3) {
  return l2(config3);
}
var Callback = class extends BaseCallback {
  constructor() {
    super(...arguments);
    this.model = null;
  }
  setModel(model22) {
    if (!(model22 instanceof LayersModel)) {
      throw new Error("model must be a LayersModel, not some other Container");
    }
    this.model = model22;
  }
};
function less2(currVal, prevVal) {
  return currVal < prevVal;
}
function greater2(currVal, prevVal) {
  return currVal > prevVal;
}
var EarlyStopping = class extends Callback {
  constructor(args) {
    super();
    if (args == null) {
      args = {};
    }
    if (args.restoreBestWeights) {
      throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
    }
    this.monitor = args.monitor || "val_loss";
    this.minDelta = Math.abs(args.minDelta || 0);
    this.patience = args.patience || 0;
    this.verbose = args.verbose || 0;
    this.mode = args.mode || "auto";
    this.baseline = args.baseline;
    if (["auto", "min", "max"].indexOf(this.mode) === -1) {
      console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`);
      this.mode = "auto";
    }
    if (this.mode === "min") {
      this.monitorFunc = less2;
    } else if (this.mode === "max") {
      this.monitorFunc = greater2;
    } else {
      if (this.monitor.indexOf("acc") !== -1) {
        this.monitorFunc = greater2;
      } else {
        this.monitorFunc = less2;
      }
    }
    if (this.monitorFunc === less2) {
      this.minDelta *= -1;
    }
  }
  async onTrainBegin(logs) {
    this.wait = 0;
    this.stoppedEpoch = 0;
    if (this.baseline != null) {
      this.best = this.baseline;
    } else {
      this.best = this.monitorFunc === less2 ? Infinity : -Infinity;
    }
  }
  async onEpochEnd(epoch, logs) {
    await resolveScalarsInLogs(logs);
    const current = this.getMonitorValue(logs);
    if (current == null) {
      return;
    }
    if (this.monitorFunc(current - this.minDelta, this.best)) {
      this.best = current;
      this.wait = 0;
    } else {
      this.wait++;
      if (this.wait >= this.patience) {
        this.stoppedEpoch = epoch;
        this.model.stopTraining = true;
      }
    }
  }
  async onTrainEnd(logs) {
    if (this.stoppedEpoch > 0 && this.verbose) {
      console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
    }
  }
  getMonitorValue(logs) {
    if (logs == null) {
      logs = {};
    }
    const monitorValue = logs[this.monitor];
    if (monitorValue == null) {
      console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(logs)}`);
    }
    return monitorValue;
  }
};
function earlyStopping(args) {
  return new EarlyStopping(args);
}
var callbacks = { earlyStopping };
var DataType;
(function(DataType2) {
  DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
  DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
  DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
  DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
  DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
  DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
  DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
  DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
  DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
  DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
  DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
  DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
  DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
  DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
  DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
  DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
  DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
  DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
  DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
  DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
  DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
  DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
  DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
  DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
  DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
  DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
  DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
  DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
  DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
})(DataType || (DataType = {}));
var SaverDef;
(function(SaverDef2) {
  let CheckpointFormatVersion;
  (function(CheckpointFormatVersion2) {
    CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
    CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
    CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
  })(CheckpointFormatVersion = SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
})(SaverDef || (SaverDef = {}));
var CUSTOM_OPS = {};
function registerOp(name, opFunc) {
  const opMapper = {
    tfOpName: name,
    category: "custom",
    inputs: [],
    attrs: [],
    customExecutor: opFunc
  };
  CUSTOM_OPS[name] = opMapper;
}
function getRegisteredOp(name) {
  return CUSTOM_OPS[name];
}
function deregisterOp(name) {
  delete CUSTOM_OPS[name];
}
function getParamValue(paramName, node2, tensorMap, context, resourceManager) {
  const inputParam = node2.inputParams[paramName];
  if (inputParam && inputParam.inputIndexStart !== void 0) {
    const start = inputParam.inputIndexStart;
    const end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start + 1 : inputParam.inputIndexEnd;
    if (inputParam.type === "tensor") {
      return getTensor(node2.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);
    }
    if (inputParam.type === "tensors") {
      const inputs = node2.inputNames.slice(start, end);
      return inputs.map((name) => getTensor(name, tensorMap, context, resourceManager));
    }
    const tensor2 = getTensor(node2.inputNames.slice(start)[0], tensorMap, context, resourceManager);
    const data = tensor2.dataSync();
    return inputParam.type === "number" ? data[0] : util_exports.toNestedArray(tensor2.shape, data);
  }
  const attrParam = node2.attrParams[paramName];
  return attrParam && attrParam.value;
}
function getTensor(name, tensorsMap, context, resourceManager) {
  const [nodeName, index] = parseNodeName(name);
  if (resourceManager != null) {
    const tensor2 = resourceManager.getHashTableHandleByName(nodeName);
    if (tensor2 != null) {
      return tensor2;
    }
  }
  const contextId = context.currentContextIds.find((contextId2) => {
    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
  });
  return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : void 0;
}
function getTensorsForCurrentContenxt(name, tensorsMap, context) {
  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];
}
function getNodeNameAndIndex(inputName, context) {
  const [nodeName, index, outputName] = parseNodeName(inputName);
  return [
    getNodeNameWithContextId(nodeName, context && context.currentContextId),
    index,
    outputName
  ];
}
function getNodeNameWithContextId(name, contextId) {
  return !!contextId ? `${name}-${contextId}` : name;
}
function parseNodeName(name) {
  const parts = name.split(":");
  if (parts.length === 1) {
    return [name, 0, void 0];
  }
  const nodeName = parts[0];
  const outputName = parts.length === 3 ? parts[1] : void 0;
  const index = Number(parts[parts.length - 1]);
  return [nodeName, index, outputName];
}
function getPadding(node2, tensorMap, context) {
  let pad3 = getParamValue("pad", node2, tensorMap, context);
  if (pad3 === "explicit") {
    pad3 = getParamValue("explicitPaddings", node2, tensorMap, context);
    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let i2 = 0; i2 < 4; i2++) {
      explicitPadding[i2][0] = pad3[i2 * 2];
      explicitPadding[i2][1] = pad3[i2 * 2 + 1];
    }
    return explicitPadding;
  }
  return pad3;
}
function cloneTensor(tensor2) {
  return tensor2.kept ? tensor2 : clone(tensor2);
}
var arithmetic_exports = {};
__export2(arithmetic_exports, {
  json: () => json
});
var json = [
  {
    "tfOpName": "Add",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "AddV2",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "AddN",
    "category": "arithmetic",
    "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }]
  },
  {
    "tfOpName": "BiasAdd",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sub",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "RealDiv",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Div",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "DivNoNan",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "FloorDiv",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Mul",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Maximum",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Minimum",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Pow",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "SquaredDifference",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Mod",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "FloorMod",
    "category": "arithmetic",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "T",
      "name": "dtype",
      "type": "dtype",
      "notSupported": true
    }]
  }
];
var basic_math_exports = {};
__export2(basic_math_exports, {
  json: () => json2
});
var json2 = [
  {
    "tfOpName": "Abs",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Acos",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Asin",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Atan",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Atan2",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "y", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Ceil",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "ClipByValue",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "clipValueMin", "type": "number" },
      { "start": 2, "name": "clipValueMax", "type": "number" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Complex",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "real", "type": "tensor" },
      { "start": 1, "name": "imag", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "ComplexAbs",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Cos",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Cosh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Elu",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Exp",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Floor",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Log",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Imag",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "outputType",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Neg",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Real",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "outputType",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Prelu",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "alpha", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Relu",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Relu6",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Selu",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Sigmoid",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Sin",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Sinh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Sqrt",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Rsqrt",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Square",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Tan",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Tanh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Sign",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Round",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Expm1",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Log1p",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Softplus",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Asinh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Acosh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Atanh",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Erf",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Prod",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axes", "type": "number[]" }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool",
        "notSupported": true
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "LeakyRelu",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "alpha",
        "name": "alpha",
        "type": "number",
        "defaultValue": 0.2
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "IsNan",
    "category": "basic_math",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "T",
      "name": "dtype",
      "type": "dtype",
      "notSupported": true
    }]
  }
];
var control_exports = {};
__export2(control_exports, {
  json: () => json3
});
var json3 = [
  {
    "tfOpName": "EmptyTensorList",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "elementShape", "type": "shape" },
      { "start": 1, "name": "maxNumElements", "type": "number" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "LoopCond",
    "category": "control",
    "inputs": [{ "start": 0, "name": "pred", "type": "tensor" }]
  },
  {
    "tfOpName": "Switch",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "data", "type": "tensor" },
      { "start": 1, "name": "pred", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "Merge",
    "category": "control",
    "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }]
  },
  {
    "tfOpName": "Enter",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      { "tfName": "frame_name", "name": "frameName", "type": "string" },
      { "tfName": "is_constant", "name": "isConstant", "type": "bool" }
    ]
  },
  {
    "tfOpName": "Exit",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "NextIteration",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "TensorArrayV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "size", "type": "number" }
    ],
    "attrs": [
      { "tfName": "dtype", "name": "dtype", "type": "dtype" },
      { "tfName": "element_shape", "name": "elementShape", "type": "shape" },
      { "tfName": "dynamic_size", "name": "dynamicSize", "type": "bool" },
      { "tfName": "clear_after_read", "name": "clearAfterRead", "type": "bool" },
      {
        "tfName": "identical_element_shapes",
        "name": "identicalElementShapes",
        "type": "bool"
      },
      { "tfName": "tensor_array_name", "name": "name", "type": "string" }
    ]
  },
  {
    "tfOpName": "TensorArrayWriteV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "index", "type": "number" },
      { "start": 2, "name": "tensor", "type": "tensor" },
      { "start": 3, "name": "flowIn", "type": "number" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "TensorArrayReadV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "index", "type": "number" },
      { "start": 2, "name": "flowIn", "type": "number" }
    ],
    "attrs": [{
      "tfName": "dtype",
      "name": "dtype",
      "type": "dtype",
      "notSupported": true
    }]
  },
  {
    "tfOpName": "TensorArrayGatherV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "number[]" },
      { "start": 2, "name": "flowIn", "type": "number" }
    ],
    "attrs": [
      { "tfName": "dtype", "name": "dtype", "type": "dtype" },
      { "tfName": "element_shape", "name": "elementShape", "type": "shape" }
    ]
  },
  {
    "tfOpName": "TensorArrayScatterV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "number[]" },
      { "start": 2, "name": "tensor", "type": "tensor" },
      { "start": 3, "name": "flowIn", "type": "number" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorArrayConcatV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "flowIn", "type": "number" }
    ],
    "attrs": [
      { "tfName": "dtype", "name": "dtype", "type": "dtype" },
      {
        "tfName": "element_shape_except0",
        "name": "elementShapeExcept0",
        "type": "shape",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorArraySplitV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "tensor", "type": "tensor" },
      { "start": 2, "name": "lengths", "type": "number[]" },
      { "start": 3, "name": "flowIn", "type": "number" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorArraySizeV3",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorArrayId", "type": "tensor" },
      { "start": 1, "name": "flowIn", "type": "number" }
    ]
  },
  {
    "tfOpName": "TensorArrayCloseV3",
    "category": "control",
    "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }]
  },
  {
    "tfOpName": "StatelessIf",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "cond", "type": "tensor" },
      { "start": 1, "end": 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "then_branch", "name": "thenBranch", "type": "func" },
      { "tfName": "else_branch", "name": "elseBranch", "type": "func" }
    ]
  },
  {
    "tfOpName": "If",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "cond", "type": "tensor" },
      { "start": 1, "end": 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "then_branch", "name": "thenBranch", "type": "func" },
      { "tfName": "else_branch", "name": "elseBranch", "type": "func" }
    ]
  },
  {
    "tfOpName": "StatelessWhile",
    "category": "control",
    "inputs": [
      { "start": 0, "end": 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "cond", "name": "cond", "type": "func" },
      { "tfName": "body", "name": "body", "type": "func" }
    ]
  },
  {
    "tfOpName": "While",
    "category": "control",
    "inputs": [
      { "start": 0, "end": 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "cond", "name": "cond", "type": "func" },
      { "tfName": "body", "name": "body", "type": "func" }
    ]
  },
  {
    "tfOpName": "TensorListScatter",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "number[]" },
      { "start": 2, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListScatterV2",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "number[]" },
      { "start": 2, "name": "elementShape", "type": "shape" },
      { "start": 3, "name": "numElements", "type": "number" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListGather",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "number[]" },
      { "start": 2, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListGetItem",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "index", "type": "number" },
      { "start": 2, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListSetItem",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "index", "type": "number" },
      { "start": 2, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListReserve",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "elementShape", "type": "shape" },
      { "start": 1, "name": "numElements", "type": "number" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListFromTensor",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" },
      { "start": 1, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListStack",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [
      { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" },
      { "tfName": "num_elements", "name": "numElements", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "TensorListSplit",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" },
      { "start": 1, "name": "elementShape", "type": "shape" },
      { "start": 2, "name": "lengths", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListConcat",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "element_shape", "name": "elementShape", "type": "shape" },
      { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "TensorListPopBack",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "elementShape", "type": "shape" }
    ],
    "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
  },
  {
    "tfOpName": "TensorListPushBack",
    "category": "control",
    "inputs": [
      { "start": 0, "name": "tensorListId", "type": "tensor" },
      { "start": 1, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }
    ]
  }
];
var convolution_exports = {};
__export2(convolution_exports, {
  json: () => json4
});
var json4 = [
  {
    "tfOpName": "AvgPool",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "MaxPool",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": [],
        "notSupported": true
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "MaxPoolWithArgmax",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
      {
        "tfName": "include_batch_in_index",
        "name": "includeBatchInIndex",
        "type": "bool"
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "AvgPool3D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "MaxPool3D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Conv1D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "stride", "name": "stride", "type": "number" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NWC"
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      {
        "tfName": "dilation",
        "name": "dilation",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "Conv2D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      { "tfName": "useCudnnOnGpu", "name": "useCudnnOnGpu", "type": "bool" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      { "tfName": "dilations", "name": "dilations", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "_FusedConv2D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" },
      { "start": 2, end: 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "num_args", "name": "numArgs", "type": "number" },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "use_cudnn_on_gpu",
        "name": "useCudnnOnGpu",
        "type": "bool",
        "defaultValue": true
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "defaultValue": [1, 1, 1, 1]
      },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-4
      },
      {
        "tfName": "leakyrelu_alpha",
        "name": "leakyreluAlpha",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Conv2DBackpropInput",
    "category": "convolution",
    "inputs": [
      { "start": 2, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" },
      { "start": 0, "name": "outputShape", "type": "number[]" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2d",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "input", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      { "tfName": "dilations", "name": "dilations", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2dNative",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "input", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      { "tfName": "dilations", "name": "dilations", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "FusedDepthwiseConv2dNative",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" },
      { "start": 2, end: 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "num_args", "name": "numArgs", "type": "number" },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "defaultValue": [1, 1, 1, 1]
      },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      }
    ]
  },
  {
    "tfOpName": "Conv3D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      { "tfName": "dilations", "name": "dilations", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "Dilation2D",
    "category": "convolution",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "filter", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "strides", "name": "strides", "type": "number[]" },
      { "tfName": "rates", "name": "dilations", "type": "number[]" },
      { "tfName": "padding", "name": "pad", "type": "string" }
    ]
  }
];
var creation_exports = {};
__export2(creation_exports, {
  json: () => json5
});
var json5 = [
  {
    "tfOpName": "Fill",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "shape", "type": "number[]" },
      { "start": 1, "name": "value", "type": "number" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "LinSpace",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "start", "type": "number" },
      { "start": 1, "name": "stop", "type": "number" },
      { "start": 2, "name": "num", "type": "number" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "OneHot",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "indices", "type": "tensor" },
      { "start": 1, "name": "depth", "type": "number" },
      { "start": 2, "name": "onValue", "type": "number", "defaultValue": 1 },
      { "start": 3, "name": "offValue", "type": "number", "defaultValue": 0 }
    ],
    "attrs": [
      {
        "tfName": "axis",
        "name": "axis",
        "type": "number",
        "notSupported": true
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Ones",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "shape", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "OnesLike",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "RandomUniform",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "shape", "type": "number[]" }
    ],
    "attrs": [
      {
        "tfName": "minval",
        "name": "minval",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "maxval",
        "name": "maxval",
        "type": "number",
        "defaultValue": 1
      },
      { "tfName": "dtype", "name": "dtype", "type": "dtype" },
      { "tfName": "seed", "name": "seed", "type": "number", "defaultValue": 0 },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      { "tfName": "T", "name": "T", "type": "number", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Range",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "start", "type": "number" },
      { "start": 1, "name": "stop", "type": "number" },
      { "start": 2, "name": "step", "type": "number", "defaultValue": 0 }
    ],
    "attrs": [{ "tfName": "Tidx", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "TruncatedNormal",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "shape", "type": "number[]" }
    ],
    "attrs": [
      {
        "tfName": "means",
        "name": "mean",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "stddev",
        "name": "stdDev",
        "type": "number",
        "defaultValue": 1
      },
      { "tfName": "seed", "name": "seed", "type": "number" },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      { "tfName": "dtype", "name": "dtype", "type": "dtype" },
      { "tfName": "T", "name": "T", "type": "number", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Zeros",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "shape", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "ZerosLike",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
  },
  {
    "tfOpName": "Multinomial",
    "category": "creation",
    "inputs": [
      { "start": 0, "name": "logits", "type": "tensor" },
      { "start": 1, "name": "numSamples", "type": "number" }
    ],
    "attrs": [
      { "tfName": "seed", "name": "seed", "type": "number" },
      { "tfName": "seed2", "name": "seed2", "type": "number" },
      { "tfName": "T", "name": "dtype", "type": "dtype" },
      { "tfName": "output_dtype", "name": "output_dtype", "type": "dtype" }
    ]
  }
];
var dynamic_exports = {};
__export2(dynamic_exports, {
  json: () => json6
});
var json6 = [
  {
    "tfOpName": "NonMaxSuppressionV2",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "boxes", "type": "tensor" },
      { "start": 1, "name": "scores", "type": "tensor" },
      { "start": 2, "name": "maxOutputSize", "type": "number" },
      { "start": 3, "name": "iouThreshold", "type": "number" }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV3",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "boxes", "type": "tensor" },
      { "start": 1, "name": "scores", "type": "tensor" },
      { "start": 2, "name": "maxOutputSize", "type": "number" },
      { "start": 3, "name": "iouThreshold", "type": "number" },
      { "start": 4, "name": "scoreThreshold", "type": "number" }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV4",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "boxes", "type": "tensor" },
      { "start": 1, "name": "scores", "type": "tensor" },
      { "start": 2, "name": "maxOutputSize", "type": "number" },
      { "start": 3, "name": "iouThreshold", "type": "number" },
      { "start": 4, "name": "scoreThreshold", "type": "number" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
      {
        "tfName": "T_threshold",
        "name": "threshold",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "pad_to_max_output_size",
        "name": "padToMaxOutputSize",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV5",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "boxes", "type": "tensor" },
      { "start": 1, "name": "scores", "type": "tensor" },
      { "start": 2, "name": "maxOutputSize", "type": "number" },
      { "start": 3, "name": "iouThreshold", "type": "number" },
      { "start": 4, "name": "scoreThreshold", "type": "number" },
      { "start": 5, "name": "softNmsSigma", "type": "number" }
    ]
  },
  {
    "tfOpName": "Where",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "condition", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "ListDiff",
    "category": "dynamic",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "y", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "T",
      "name": "dtype",
      "type": "dtype",
      "notSupported": true
    }]
  }
];
var evaluation_exports = {};
__export2(evaluation_exports, {
  json: () => json7
});
var json7 = [
  {
    "tfOpName": "TopKV2",
    "category": "evaluation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "k", "type": "number" }
    ],
    "attrs": [{ "tfName": "sorted", "name": "sorted", "type": "bool" }]
  },
  {
    "tfOpName": "Unique",
    "category": "evaluation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "UniqueV2",
    "category": "evaluation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number" }
    ]
  }
];
var graph_exports = {};
__export2(graph_exports, {
  json: () => json8
});
var json8 = [
  {
    "tfOpName": "PlaceholderWithDefault",
    "category": "graph",
    "inputs": [
      { "start": 0, "name": "default", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "shape", "name": "shape", "type": "shape" },
      { "tfName": "dtype", "name": "dtype", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "Placeholder",
    "category": "graph",
    "attrs": [
      { "tfName": "shape", "name": "shape", "type": "shape" },
      { "tfName": "dtype", "name": "dtype", "type": "dtype" }
    ]
  },
  { "tfOpName": "Const", "category": "graph" },
  {
    "tfOpName": "Identity",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "IdentityN",
    "category": "graph",
    "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }]
  },
  {
    "tfOpName": "Snapshot",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "Rank",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "Size",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "Shape",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "ShapeN",
    "category": "graph",
    "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }]
  },
  {
    "tfOpName": "Print",
    "category": "graph",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "data", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "message", "name": "message", "type": "string" },
      {
        "tfName": "first_n",
        "name": "firstN",
        "type": "number",
        "notSupported": true
      },
      {
        "tfName": "summarize",
        "name": "summarize",
        "type": "number",
        "defaultValue": 3
      }
    ]
  },
  { "tfOpName": "NoOp", "category": "graph", "inputs": [] },
  {
    "tfOpName": "StopGradient",
    "category": "graph",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "FakeQuantWithMinMaxVars",
    "category": "graph",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "min", "name": "min", "type": "number" },
      { "tfName": "max", "name": "max", "type": "number" }
    ]
  }
];
var hash_table_exports = {};
__export2(hash_table_exports, {
  json: () => json9
});
var json9 = [
  {
    "tfOpName": "HashTable",
    "category": "hash_table",
    "inputs": [],
    "attrs": [
      { "tfName": "shared_name", "name": "sharedName", "type": "string" },
      {
        "tfName": "use_node_name_sharing",
        "name": "useNodeNameSharing",
        "type": "bool"
      },
      { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" },
      { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "HashTableV2",
    "category": "hash_table",
    "inputs": [],
    "attrs": [
      { "tfName": "shared_name", "name": "sharedName", "type": "string" },
      {
        "tfName": "use_node_name_sharing",
        "name": "useNodeNameSharing",
        "type": "bool"
      },
      { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" },
      { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "LookupTableImport",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" },
      { "start": 1, "name": "keys", "type": "tensor" },
      { "start": 2, "name": "values", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableImportV2",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" },
      { "start": 1, "name": "keys", "type": "tensor" },
      { "start": 2, "name": "values", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableFind",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" },
      { "start": 1, "name": "keys", "type": "tensor" },
      { "start": 2, "name": "defaultValue", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableFindV2",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" },
      { "start": 1, "name": "keys", "type": "tensor" },
      { "start": 2, "name": "defaultValue", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableSize",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "LookupTableSizeV2",
    "category": "hash_table",
    "inputs": [
      { "start": 0, "name": "tableHandle", "type": "tensor" }
    ]
  }
];
var image_exports = {};
__export2(image_exports, {
  json: () => json10
});
var json10 = [
  {
    "tfOpName": "ResizeBilinear",
    "category": "image",
    "inputs": [
      { "start": 0, "name": "images", "type": "tensor" },
      { "start": 1, "name": "size", "type": "number[]" }
    ],
    "attrs": [
      { "tfName": "align_corners", "name": "alignCorners", "type": "bool" },
      {
        "tfName": "half_pixel_centers",
        "name": "halfPixelCenters",
        "type": "bool"
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "ResizeNearestNeighbor",
    "category": "image",
    "inputs": [
      { "start": 0, "name": "images", "type": "tensor" },
      { "start": 1, "name": "size", "type": "number[]" }
    ],
    "attrs": [
      { "tfName": "align_corners", "name": "alignCorners", "type": "bool" },
      {
        "tfName": "half_pixel_centers",
        "name": "halfPixelCenters",
        "type": "bool"
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "CropAndResize",
    "category": "image",
    "inputs": [
      { "start": 0, "name": "image", "type": "tensor" },
      { "start": 1, "name": "boxes", "type": "tensor" },
      { "start": 2, "name": "boxInd", "type": "tensor" },
      { "start": 3, "name": "cropSize", "type": "number[]" }
    ],
    "attrs": [
      { "tfName": "method", "name": "method", "type": "string" },
      {
        "tfName": "extrapolation_value",
        "name": "extrapolationValue",
        "type": "number"
      }
    ]
  }
];
var logical_exports = {};
__export2(logical_exports, {
  json: () => json11
});
var json11 = [
  {
    "tfOpName": "Equal",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "NotEqual",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Greater",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "GreaterEqual",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Less",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "LessEqual",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "LogicalAnd",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "LogicalNot",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "LogicalOr",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Select",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "condition", "type": "tensor" },
      { "start": 1, "name": "a", "type": "tensor" },
      { "start": 2, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "SelectV2",
    "category": "logical",
    "inputs": [
      { "start": 0, "name": "condition", "type": "tensor" },
      { "start": 1, "name": "a", "type": "tensor" },
      { "start": 2, "name": "b", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "T",
      "name": "dtype",
      "type": "dtype",
      "notSupported": true
    }]
  }
];
var matrices_exports = {};
__export2(matrices_exports, {
  json: () => json12
});
var json12 = [
  {
    "tfOpName": "_FusedMatMul",
    "category": "matrices",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" },
      { "start": 2, end: 0, "name": "args", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "num_args", "name": "numArgs", "type": "number" },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-4
      },
      {
        "tfName": "transpose_a",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "transpose_b",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "MatMul",
    "category": "matrices",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "transpose_a",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "transpose_b",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "BatchMatMul",
    "category": "matrices",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "adj_x",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "adj_y",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "BatchMatMulV2",
    "category": "matrices",
    "inputs": [
      { "start": 0, "name": "a", "type": "tensor" },
      { "start": 1, "name": "b", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "adj_x",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "adj_y",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Transpose",
    "category": "matrices",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "perm", "type": "number[]" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "Einsum",
    "category": "matrices",
    "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }],
    "attrs": [
      { "tfName": "equation", "name": "equation", "type": "string" },
      { "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 },
      { "tfName": "T", "name": "dtype", "type": "dtype" }
    ]
  }
];
var normalization_exports = {};
__export2(normalization_exports, {
  json: () => json13
});
var json13 = [
  {
    "tfOpName": "FusedBatchNorm",
    "category": "normalization",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "scale", "type": "tensor" },
      { "start": 2, "name": "offset", "type": "tensor" },
      { "start": 3, "name": "mean", "type": "tensor" },
      { "start": 4, "name": "variance", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV2",
    "category": "normalization",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "scale", "type": "tensor" },
      { "start": 2, "name": "offset", "type": "tensor" },
      { "start": 3, "name": "mean", "type": "tensor" },
      { "start": 4, "name": "variance", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV3",
    "category": "normalization",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "scale", "type": "tensor" },
      { "start": 2, "name": "offset", "type": "tensor" },
      { "start": 3, "name": "mean", "type": "tensor" },
      { "start": 4, "name": "variance", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LRN",
    "category": "normalization",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "depth_radius",
        "name": "radius",
        "type": "number",
        "defaultValue": 5
      },
      { "tfName": "bias", "name": "bias", "type": "number", "defaultValue": 1 },
      {
        "tfName": "alpha",
        "name": "alpha",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfName": "beta",
        "name": "beta",
        "type": "number",
        "defaultValue": 0.5
      }
    ]
  },
  {
    "tfOpName": "Softmax",
    "category": "normalization",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "LogSoftmax",
    "category": "normalization",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "SparseToDense",
    "category": "normalization",
    "inputs": [
      { "start": 0, "name": "sparseIndices", "type": "tensor" },
      { "start": 1, "name": "outputShape", "type": "number[]" },
      { "start": 2, "name": "sparseValues", "type": "tensor" },
      { "start": 3, "name": "defaultValue", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "validate_indices",
      "name": "validateIndices",
      "type": "bool",
      "defaultValue": true,
      "notSupported": true
    }]
  }
];
var reduction_exports = {};
__export2(reduction_exports, {
  json: () => json14
});
var json14 = [
  {
    "tfOpName": "Bincount",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "size", "type": "number" },
      { "start": 2, "name": "weights", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "DenseBincount",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "size", "type": "number" },
      { "start": 2, "name": "weights", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "binary_output", "name": "binaryOutput", "type": "bool" }]
  },
  {
    "tfOpName": "Max",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "Mean",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "Min",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "Sum",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "All",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "Any",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "ArgMax",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number" }
    ]
  },
  {
    "tfOpName": "ArgMin",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number" }
    ]
  },
  {
    "tfOpName": "Prod",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
  },
  {
    "tfOpName": "Cumsum",
    "category": "reduction",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number" }
    ],
    "attrs": [
      { "tfName": "exclusive", "name": "exclusive", "type": "bool" },
      { "tfName": "reverse", "name": "reverse", "type": "bool" }
    ]
  }
];
var slice_join_exports = {};
__export2(slice_join_exports, {
  json: () => json15
});
var json15 = [
  {
    "tfOpName": "ConcatV2",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "end": -1, "name": "tensors", "type": "tensors" },
      { "start": -1, "name": "axis", "type": "number" }
    ],
    "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }]
  },
  {
    "tfOpName": "Concat",
    "category": "slice_join",
    "inputs": [
      { "start": 1, "end": 0, "name": "tensors", "type": "tensors" },
      { "start": 0, "name": "axis", "type": "number" }
    ],
    "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }]
  },
  {
    "tfOpName": "GatherV2",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "tensor" },
      { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }
    ],
    "attrs": [{
      "tfName": "batch_dims",
      "name": "batchDims",
      "type": "number",
      "defaultValue": 0
    }]
  },
  {
    "tfOpName": "Gather",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "validate_indices",
      "name": "validateIndices",
      "type": "bool",
      "notSupported": true
    }]
  },
  {
    "tfOpName": "Reverse",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "dims", "type": "bool[]" }
    ]
  },
  {
    "tfOpName": "ReverseV2",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "Slice",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "begin", "type": "number[]" },
      { "start": 2, "name": "size", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "StridedSlice",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "begin", "type": "number[]" },
      { "start": 2, "name": "end", "type": "number[]" },
      { "start": 3, "name": "strides", "type": "number[]" }
    ],
    "attrs": [
      {
        "tfName": "begin_mask",
        "name": "beginMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "end_mask",
        "name": "endMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "new_axis_mask",
        "name": "newAxisMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "ellipsis_mask",
        "name": "ellipsisMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "shrink_axis_mask",
        "name": "shrinkAxisMask",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Pack",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "end": 0, "name": "tensors", "type": "tensors" }
    ],
    "attrs": [
      { "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 }
    ]
  },
  {
    "tfOpName": "Unpack",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "tensor", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 },
      {
        "tfName": "num",
        "name": "num",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tile",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "reps", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "Split",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "axis", "type": "number", "defaultValue": 0 },
      { "start": 1, "name": "x", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "num_split",
      "name": "numOrSizeSplits",
      "type": "number",
      "defaultValue": 1
    }]
  },
  {
    "tfOpName": "SplitV",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "numOrSizeSplits", "type": "number[]" },
      { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }
    ]
  },
  {
    "tfOpName": "ScatterNd",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "indices", "type": "tensor" },
      { "start": 1, "name": "values", "type": "tensor" },
      { "start": 2, "name": "shape", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "GatherNd",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "SparseToDense",
    "category": "slice_join",
    "inputs": [
      { "start": 0, "name": "sparseIndices", "type": "tensor" },
      { "start": 1, "name": "outputShape", "type": "number[]" },
      { "start": 2, "name": "sparseValues", "type": "tensor" },
      { "start": 3, "name": "defaultValue", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "validate_indices",
      "name": "validateIndices",
      "type": "bool",
      "defaultValue": false,
      "notSupported": true
    }]
  }
];
var sparse_exports = {};
__export2(sparse_exports, {
  json: () => json16
});
var json16 = [
  {
    "tfOpName": "SparseFillEmptyRows",
    "category": "sparse",
    "inputs": [
      { "start": 0, "name": "indices", "type": "tensor" },
      { "start": 1, "name": "values", "type": "tensor" },
      { "start": 2, "name": "denseShape", "type": "tensor" },
      { "start": 3, "name": "defaultValue", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "SparseReshape",
    "category": "sparse",
    "inputs": [
      { "start": 0, "name": "inputIndices", "type": "tensor" },
      { "start": 1, "name": "inputShape", "type": "tensor" },
      { "start": 2, "name": "newShape", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
    ]
  },
  {
    "tfOpName": "SparseSegmentMean",
    "category": "sparse",
    "inputs": [
      { "start": 0, "name": "data", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "tensor" },
      { "start": 2, "name": "segmentIds", "type": "tensor" }
    ]
  },
  {
    "tfOpName": "SparseSegmentSum",
    "category": "sparse",
    "inputs": [
      { "start": 0, "name": "data", "type": "tensor" },
      { "start": 1, "name": "indices", "type": "tensor" },
      { "start": 2, "name": "segmentIds", "type": "tensor" }
    ]
  }
];
var spectral_exports = {};
__export2(spectral_exports, {
  json: () => json17
});
var json17 = [
  {
    "tfOpName": "FFT",
    "category": "spectral",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "IFFT",
    "category": "spectral",
    "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
  },
  {
    "tfOpName": "RFFT",
    "category": "spectral",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      {
        "start": 1,
        "name": "fft_length",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "IRFFT",
    "category": "spectral",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      {
        "start": 1,
        "name": "fft_length",
        "type": "number",
        "notSupported": true
      }
    ]
  }
];
var string_exports = {};
__export2(string_exports, {
  json: () => json18
});
var json18 = [
  {
    "tfOpName": "StringNGrams",
    "category": "string",
    "inputs": [
      { "start": 0, "name": "data", "type": "tensor" },
      { "start": 1, "name": "dataSplits", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "separator", "name": "separator", "type": "string" },
      { "tfName": "ngram_widths", "name": "nGramWidths", "type": "number[]" },
      { "tfName": "left_pad", "name": "leftPad", "type": "string" },
      { "tfName": "right_pad", "name": "rightPad", "type": "string" },
      { "tfName": "pad_width", "name": "padWidth", "type": "number" },
      {
        "tfName": "preserve_short_sequences",
        "name": "preserveShortSequences",
        "type": "bool"
      }
    ],
    "outputs": ["ngrams", "ngrams_splits"]
  },
  {
    "tfOpName": "StringSplit",
    "category": "string",
    "inputs": [
      { "start": 0, "name": "input", "type": "tensor" },
      { "start": 1, "name": "delimiter", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "skip_empty", "name": "skipEmpty", "type": "bool" }],
    "outputs": ["indices", "values", "shape"]
  },
  {
    "tfOpName": "StringToHashBucketFast",
    "category": "string",
    "inputs": [
      { "start": 0, "name": "input", "type": "tensor" }
    ],
    "attrs": [{ "tfName": "num_buckets", "name": "numBuckets", "type": "number" }]
  }
];
var transformation_exports = {};
__export2(transformation_exports, {
  json: () => json19
});
var json19 = [
  {
    "tfOpName": "Cast",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      {
        "tfName": "SrcT",
        "name": "sdtype",
        "type": "dtype",
        "notSupported": true
      },
      { "tfName": "DstT", "name": "dtype", "type": "dtype" }
    ]
  },
  {
    "tfOpName": "ExpandDims",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "axis", "type": "number" }
    ]
  },
  {
    "tfOpName": "MirrorPad",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "padding", "type": "number[]" }
    ],
    "attrs": [{ "tfName": "mode", "name": "mode", "type": "string" }]
  },
  {
    "tfOpName": "Pad",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "padding", "type": "number[]" }
    ],
    "attrs": [{
      "tfName": "constant_value",
      "name": "constantValue",
      "type": "number",
      "defaultValue": 0
    }]
  },
  {
    "tfOpName": "PadV2",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "padding", "type": "number[]" },
      {
        "start": 2,
        "name": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Reshape",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "shape", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "Squeeze",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [{
      "tfName": "axis",
      "tfDeprecatedName": "squeeze_dims",
      "name": "axis",
      "type": "number[]"
    }]
  },
  {
    "tfOpName": "SpaceToBatchND",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "blockShape", "type": "number[]" },
      { "start": 2, "name": "paddings", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "BatchToSpaceND",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "blockShape", "type": "number[]" },
      { "start": 2, "name": "crops", "type": "number[]" }
    ]
  },
  {
    "tfOpName": "DepthToSpace",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" }
    ],
    "attrs": [
      { "tfName": "block_size", "name": "blockSize", "type": "number" },
      { "tfName": "data_format", "name": "dataFormat", "type": "string" }
    ]
  },
  {
    "tfOpName": "BroadcastTo",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "x", "type": "tensor" },
      { "start": 1, "name": "shape", "type": "number[]" }
    ],
    "attrs": []
  },
  {
    "tfOpName": "BroadcastArgs",
    "category": "transformation",
    "inputs": [
      { "start": 0, "name": "s0", "type": "tensor" },
      { "start": 1, "name": "s1", "type": "tensor" }
    ],
    "attrs": []
  }
];
var OperationMapper = class {
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  constructor() {
    const ops = [
      arithmetic_exports,
      basic_math_exports,
      control_exports,
      convolution_exports,
      creation_exports,
      dynamic_exports,
      evaluation_exports,
      graph_exports,
      hash_table_exports,
      image_exports,
      logical_exports,
      matrices_exports,
      normalization_exports,
      reduction_exports,
      slice_join_exports,
      sparse_exports,
      spectral_exports,
      string_exports,
      transformation_exports
    ];
    const mappersJson = [].concat(...ops.map((op2) => op2.json));
    this.opMappers = mappersJson.reduce((map, mapper) => {
      map[mapper.tfOpName] = mapper;
      return map;
    }, {});
  }
  transformGraph(graph2, signature = {}) {
    const tfNodes = graph2.node;
    const placeholders = [];
    const weights = [];
    const initNodes = [];
    const nodes = tfNodes.reduce((map, node2) => {
      map[node2.name] = this.mapNode(node2);
      if (node2.op.startsWith("Placeholder")) {
        placeholders.push(map[node2.name]);
      } else if (node2.op === "Const") {
        weights.push(map[node2.name]);
      } else if (node2.input == null || node2.input.length === 0) {
        initNodes.push(map[node2.name]);
      }
      return map;
    }, {});
    let inputs = [];
    const outputs = [];
    let inputNodeNameToKey = {};
    let outputNodeNameToKey = {};
    if (signature != null) {
      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
    }
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node2 = nodes[key];
      node2.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node2.inputNames[index] = inputName;
          }
        }
        node2.inputs.push(inputNode);
        inputNode.children.push(node2);
      });
    });
    if (Object.keys(outputNodeNameToKey).length === 0) {
      allNodes.forEach((key) => {
        const node2 = nodes[key];
        if (node2.children.length === 0) {
          outputs.push(node2);
        }
      });
    } else {
      Object.keys(outputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node2 = nodes[nodeName];
        if (node2 != null) {
          node2.signatureKey = outputNodeNameToKey[name];
          outputs.push(node2);
        }
      });
    }
    if (Object.keys(inputNodeNameToKey).length > 0) {
      Object.keys(inputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node2 = nodes[nodeName];
        if (node2) {
          node2.signatureKey = inputNodeNameToKey[name];
          inputs.push(node2);
        }
      });
    } else {
      inputs = placeholders;
    }
    let functions = {};
    if (graph2.library != null && graph2.library.function != null) {
      functions = graph2.library.function.reduce((functions2, func2) => {
        functions2[func2.signature.name] = this.mapFunction(func2);
        return functions2;
      }, {});
    }
    const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };
    if (initNodes.length > 0) {
      result.initNodes = initNodes;
    }
    return result;
  }
  mapSignatureEntries(entries) {
    return Object.keys(entries || {}).reduce((prev, curr) => {
      prev[entries[curr].name] = curr;
      return prev;
    }, {});
  }
  mapNode(node2) {
    const mapper = getRegisteredOp(node2.op) || this.opMappers[node2.op] || {};
    if (node2.attr == null) {
      node2.attr = {};
    }
    const newNode = {
      name: node2.name,
      op: node2.op,
      category: mapper.category,
      inputNames: (node2.input || []).map((input2) => input2.startsWith("^") ? input2.substr(1) : input2),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: node2.attr,
      outputs: mapper.outputs
    };
    if (mapper.inputs != null) {
      newNode.inputParams = mapper.inputs.reduce((map, param) => {
        map[param.name] = {
          type: param.type,
          inputIndexStart: param.start,
          inputIndexEnd: param.end
        };
        return map;
      }, {});
    }
    if (mapper.attrs != null) {
      newNode.attrParams = mapper.attrs.reduce((map, param) => {
        const type = param.type;
        let value = void 0;
        switch (param.type) {
          case "string":
            value = getStringParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getStringParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "string[]":
            value = getStringArrayParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getStringArrayParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number":
            value = getNumberParam(node2.attr, param.tfName, param.defaultValue || 0);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getNumberParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number[]":
            value = getNumericArrayParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getNumericArrayParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool":
            value = getBoolParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getBoolParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool[]":
            value = getBoolArrayParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getBoolArrayParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape":
            value = getTensorShapeParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getTensorShapeParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape[]":
            value = getTensorShapeArrayParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getTensorShapeArrayParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype":
            value = getDtypeParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getDtypeParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype[]":
            value = getDtypeArrayParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getDtypeArrayParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "func":
            value = getFuncParam(node2.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getFuncParam(node2.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "tensor":
          case "tensors":
            break;
          default:
            throw new Error(`Unsupported param type: ${param.type} for op: ${node2.op}`);
        }
        map[param.name] = { value, type };
        return map;
      }, {});
    }
    return newNode;
  }
  mapFunction(functionDef) {
    const tfNodes = functionDef.nodeDef;
    const placeholders = [];
    const weights = [];
    let nodes = {};
    if (tfNodes != null) {
      nodes = tfNodes.reduce((map, node2) => {
        map[node2.name] = this.mapNode(node2);
        if (node2.op === "Const") {
          weights.push(map[node2.name]);
        }
        return map;
      }, {});
    }
    const inputs = [];
    const outputs = [];
    functionDef.signature.inputArg.forEach((arg) => {
      const [nodeName] = getNodeNameAndIndex(arg.name);
      const node2 = {
        name: nodeName,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: parseDtypeParam(arg.type), type: "dtype" } },
        children: []
      };
      node2.signatureKey = arg.name;
      inputs.push(node2);
      nodes[nodeName] = node2;
    });
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node2 = nodes[key];
      node2.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node2.inputNames[index] = inputName;
          }
        }
        node2.inputs.push(inputNode);
        inputNode.children.push(node2);
      });
    });
    const returnNodeMap = functionDef.ret;
    functionDef.signature.outputArg.forEach((output) => {
      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);
      const node2 = nodes[nodeName];
      if (node2 != null) {
        node2.defaultOutput = index;
        outputs.push(node2);
      }
    });
    const signature = this.mapArgsToSignature(functionDef);
    return { nodes, inputs, outputs, weights, placeholders, signature };
  }
  mapArgsToSignature(functionDef) {
    return {
      methodName: functionDef.signature.name,
      inputs: functionDef.signature.inputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg);
        return map;
      }, {}),
      outputs: functionDef.signature.outputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
        return map;
      }, {})
    };
  }
  mapArgToTensorInfo(arg, nameMap2) {
    let name = arg.name;
    if (nameMap2 != null) {
      name = nameMap2[name];
    }
    return { name, dtype: arg.type };
  }
};
function decodeBase64(text) {
  const global2 = env().global;
  if (typeof global2.atob !== "undefined") {
    return global2.atob(text);
  } else if (typeof Buffer !== "undefined") {
    return new Buffer(text, "base64").toString();
  } else {
    throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
  }
}
function parseStringParam(s2, keepCase) {
  const value = Array.isArray(s2) ? String.fromCharCode.apply(null, s2) : decodeBase64(s2);
  return keepCase ? value : value.toLowerCase();
}
function getStringParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param != null) {
    return parseStringParam(param.s, keepCase);
  }
  return def;
}
function getBoolParam(attrs, name, def) {
  const param = attrs[name];
  return param ? param.b : def;
}
function getNumberParam(attrs, name, def) {
  const param = attrs[name] || {};
  const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
  return typeof value === "number" ? value : parseInt(value, 10);
}
function parseDtypeParam(value) {
  if (typeof value === "string") {
    value = DataType[value];
  }
  switch (value) {
    case DataType.DT_FLOAT:
      return "float32";
    case DataType.DT_INT32:
    case DataType.DT_INT64:
    case DataType.DT_INT8:
    case DataType.DT_UINT8:
      return "int32";
    case DataType.DT_BOOL:
      return "bool";
    case DataType.DT_DOUBLE:
      return "float32";
    case DataType.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function getFuncParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.func) {
    return param.func.name;
  }
  return def;
}
function getDtypeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.type) {
    return parseDtypeParam(param.type);
  }
  return def;
}
function getDtypeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.type) {
    return param.list.type.map((v2) => parseDtypeParam(v2));
  }
  return def;
}
function parseTensorShapeParam(shape) {
  if (shape.unknownRank) {
    return void 0;
  }
  if (shape.dim != null) {
    return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
  }
  return [];
}
function getTensorShapeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.shape) {
    return parseTensorShapeParam(param.shape);
  }
  return def;
}
function getNumericArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param) {
    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v2) => typeof v2 === "number" ? v2 : parseInt(v2, 10));
  }
  return def;
}
function getStringArrayParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param && param.list && param.list.s) {
    return param.list.s.map((v2) => {
      return parseStringParam(v2, keepCase);
    });
  }
  return def;
}
function getTensorShapeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.shape) {
    return param.list.shape.map((v2) => {
      return parseTensorShapeParam(v2);
    });
  }
  return def;
}
function getBoolArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.b) {
    return param.list.b;
  }
  return def;
}
var NodeValueImpl = class {
  constructor(node2, tensorMap, context) {
    this.node = node2;
    this.tensorMap = tensorMap;
    this.context = context;
    this.inputs = [];
    this.attrs = {};
    this.inputs = node2.inputNames.map((name) => this.getInput(name));
    if (node2.rawAttrs != null) {
      this.attrs = Object.keys(node2.rawAttrs).reduce((attrs, key) => {
        attrs[key] = this.getAttr(key);
        return attrs;
      }, {});
    }
  }
  getInput(name) {
    return getTensor(name, this.tensorMap, this.context);
  }
  getAttr(name, defaultValue) {
    const value = this.node.rawAttrs[name];
    if (value.tensor != null) {
      return getTensor(name, this.tensorMap, this.context);
    }
    if (value.i != null || value.f != null) {
      return getNumberParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.s != null) {
      return getStringParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.b != null) {
      return getBoolParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.shape != null) {
      return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.type != null) {
      return getDtypeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.list != null) {
      if (value.list.i != null || value.list.f != null) {
        return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.s != null) {
        return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.shape != null) {
        return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.b != null) {
        return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.type != null) {
        return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
    }
    return defaultValue;
  }
};
var executeOp = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add": {
      return [add2(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "AddN": {
      return [addN(getParamValue("tensors", node2, tensorMap, context))];
    }
    case "FloorMod":
    case "Mod":
      return [mod(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    case "Mul":
      return [mul(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    case "RealDiv":
    case "Div": {
      return [div(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "DivNoNan": {
      return [divNoNan(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "FloorDiv": {
      return [floorDiv(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Sub": {
      return [sub(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Minimum": {
      return [minimum(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Maximum": {
      return [maximum(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Pow": {
      return [pow(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "SquaredDifference": {
      return [squaredDifference(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp2 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Abs":
    case "ComplexAbs":
      return [abs(getParamValue("x", node2, tensorMap, context))];
    case "Acos":
      return [acos(getParamValue("x", node2, tensorMap, context))];
    case "Acosh":
      return [acosh(getParamValue("x", node2, tensorMap, context))];
    case "Asin":
      return [asin(getParamValue("x", node2, tensorMap, context))];
    case "Asinh":
      return [asinh(getParamValue("x", node2, tensorMap, context))];
    case "Atan":
      return [atan(getParamValue("x", node2, tensorMap, context))];
    case "Atan2":
      return [atan2(getParamValue("x", node2, tensorMap, context), getParamValue("y", node2, tensorMap, context))];
    case "Atanh":
      return [atanh(getParamValue("x", node2, tensorMap, context))];
    case "Ceil":
      return [ceil(getParamValue("x", node2, tensorMap, context))];
    case "Complex":
      return [complex(getParamValue("real", node2, tensorMap, context), getParamValue("imag", node2, tensorMap, context))];
    case "Cos":
      return [cos(getParamValue("x", node2, tensorMap, context))];
    case "Cosh":
      return [cosh(getParamValue("x", node2, tensorMap, context))];
    case "Elu":
      return [elu(getParamValue("x", node2, tensorMap, context))];
    case "Erf":
      return [erf(getParamValue("x", node2, tensorMap, context))];
    case "Exp":
      return [exp(getParamValue("x", node2, tensorMap, context))];
    case "Expm1": {
      return [expm1(getParamValue("x", node2, tensorMap, context))];
    }
    case "Floor":
      return [floor(getParamValue("x", node2, tensorMap, context))];
    case "Log":
      return [log5(getParamValue("x", node2, tensorMap, context))];
    case "Log1p": {
      return [log1p(getParamValue("x", node2, tensorMap, context))];
    }
    case "Imag":
      return [imag(getParamValue("x", node2, tensorMap, context))];
    case "Neg":
      return [neg(getParamValue("x", node2, tensorMap, context))];
    case "Reciprocal": {
      return [reciprocal(getParamValue("x", node2, tensorMap, context))];
    }
    case "Real":
      return [real(getParamValue("x", node2, tensorMap, context))];
    case "Relu":
      return [relu(getParamValue("x", node2, tensorMap, context))];
    case "Round": {
      return [round2(getParamValue("x", node2, tensorMap, context))];
    }
    case "Selu":
      return [selu(getParamValue("x", node2, tensorMap, context))];
    case "Sigmoid":
      return [sigmoid(getParamValue("x", node2, tensorMap, context))];
    case "Sin":
      return [sin(getParamValue("x", node2, tensorMap, context))];
    case "Sign": {
      return [sign2(getParamValue("x", node2, tensorMap, context))];
    }
    case "Sinh": {
      return [sinh(getParamValue("x", node2, tensorMap, context))];
    }
    case "Softplus": {
      return [softplus(getParamValue("x", node2, tensorMap, context))];
    }
    case "Sqrt": {
      return [sqrt(getParamValue("x", node2, tensorMap, context))];
    }
    case "Square": {
      return [square(getParamValue("x", node2, tensorMap, context))];
    }
    case "Tanh": {
      return [tanh2(getParamValue("x", node2, tensorMap, context))];
    }
    case "Tan":
      return [tan(getParamValue("x", node2, tensorMap, context))];
    case "ClipByValue":
      return [clipByValue(getParamValue("x", node2, tensorMap, context), getParamValue("clipValueMin", node2, tensorMap, context), getParamValue("clipValueMax", node2, tensorMap, context))];
    case "Relu6":
      return [relu6(getParamValue("x", node2, tensorMap, context))];
    case "Rsqrt":
      return [rsqrt(getTensor(node2.inputNames[0], tensorMap, context))];
    case "Prod":
      return [prod(getParamValue("x", node2, tensorMap, context), getParamValue("axes", node2, tensorMap, context))];
    case "LeakyRelu":
      return [leakyRelu(getParamValue("x", node2, tensorMap, context), getParamValue("alpha", node2, tensorMap, context))];
    case "Prelu":
      return [prelu(getParamValue("x", node2, tensorMap, context), getParamValue("alpha", node2, tensorMap, context))];
    case "IsNan":
      return [isNaN2(getTensor(node2.inputNames[0], tensorMap, context))];
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
  if (typeof shapeA === "number" || typeof shapeB === "number") {
    return;
  }
  util_exports.assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  for (let i2 = 0; i2 < shapeA.length; i2++) {
    const dim0 = shapeA[i2];
    const dim1 = shapeB[i2];
    util_exports.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
}
function fullDefinedShape(elementShape) {
  if (typeof elementShape === "number" || elementShape.some((dim) => dim < 0)) {
    return false;
  }
  return true;
}
function inferElementShape(listElementShape, tensors, elementShape) {
  let partialShape = mergeElementShape(listElementShape, elementShape);
  const notfullDefinedShape = !fullDefinedShape(partialShape);
  if (notfullDefinedShape && tensors.length === 0) {
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${partialShape}`);
  }
  if (notfullDefinedShape) {
    tensors.forEach((tensor2) => {
      partialShape = mergeElementShape(tensor2.shape, partialShape);
    });
  }
  if (!fullDefinedShape(partialShape)) {
    throw new Error(`Non-fully-defined elementShape: ${partialShape}`);
  }
  return partialShape;
}
function mergeElementShape(elementShapeA, elementShapeB) {
  if (typeof elementShapeA === "number") {
    return elementShapeB;
  }
  if (typeof elementShapeB === "number") {
    return elementShapeA;
  }
  if (elementShapeA.length !== elementShapeB.length) {
    throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);
  }
  const result = [];
  for (let i2 = 0; i2 < elementShapeA.length; ++i2) {
    const dim0 = elementShapeA[i2];
    const dim1 = elementShapeB[i2];
    if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
      throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);
    }
    result[i2] = dim0 >= 0 ? dim0 : dim1;
  }
  return result;
}
var TensorArray = class {
  constructor(name, dtype, maxSize2, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
    this.name = name;
    this.dtype = dtype;
    this.maxSize = maxSize2;
    this.elementShape = elementShape;
    this.identicalElementShapes = identicalElementShapes;
    this.dynamicSize = dynamicSize;
    this.clearAfterRead = clearAfterRead;
    this.tensors = [];
    this.closed_ = false;
    this.idTensor = scalar(0);
    keep(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor2) => {
      if (keepIds == null || !keepIds.has(tensor2.tensor.id)) {
        tensor2.tensor.dispose();
      }
    });
    this.tensors = [];
    this.closed_ = true;
    this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  read(index) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || index >= this.size()) {
      throw new Error(`Tried to read from index ${index}, but array size is: ${this.size()}`);
    }
    const tensorWithState = this.tensors[index];
    if (tensorWithState.cleared) {
      throw new Error(`TensorArray ${this.name}: Could not read index ${index} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    }
    if (this.clearAfterRead) {
      tensorWithState.cleared = true;
    }
    tensorWithState.read = true;
    return tensorWithState.tensor;
  }
  readMany(indices) {
    return indices.map((index) => this.read(index));
  }
  write(index, tensor2) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || !this.dynamicSize && index >= this.maxSize) {
      throw new Error(`Tried to write to index ${index}, but array is not resizeable and size is: ${this.maxSize}`);
    }
    const t2 = this.tensors[index] || {};
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index},
          because the value dtype is ${tensor2.dtype}, but TensorArray dtype is ${this.dtype}.`);
    }
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
      this.elementShape = tensor2.shape;
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index}.`);
    if (t2.read) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been read.`);
    }
    if (t2.written) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been written.`);
    }
    t2.tensor = tensor2;
    keep(tensor2);
    t2.written = true;
    this.tensors[index] = t2;
  }
  writeMany(indices, tensors) {
    if (indices.length !== tensors.length) {
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
    }
    indices.forEach((i2, index) => this.write(i2, tensors[index]));
  }
  gather(indices, dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
    }
    if (!indices) {
      indices = [];
      for (let i2 = 0; i2 < this.size(); i2++) {
        indices.push(i2);
      }
    } else {
      indices = indices.slice(0, this.size());
    }
    if (indices.length === 0) {
      return tensor([], [0].concat(this.elementShape));
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
    return stack(tensors, 0);
  }
  concat(dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
    }
    if (this.size() === 0) {
      return tensor([], [0].concat(this.elementShape));
    }
    const indices = [];
    for (let i2 = 0; i2 < this.size(); i2++) {
      indices.push(i2);
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
    return concat(tensors, 0);
  }
  scatter(indices, tensor2) {
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
    }
    if (indices.length !== tensor2.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
    }
    const maxIndex = Math.max(...indices);
    if (!this.dynamicSize && maxIndex >= this.maxSize) {
      throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
    }
    this.writeMany(indices, unstack(tensor2, 0));
  }
  split(length, tensor2) {
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
    }
    let totalLength = 0;
    const cumulativeLengths = length.map((len) => {
      totalLength += len;
      return totalLength;
    });
    if (totalLength !== tensor2.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
    }
    if (!this.dynamicSize && length.length !== this.maxSize) {
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), and the TensorArray is not marked as dynamically resizeable`);
    }
    const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
    const tensors = [];
    tidy(() => {
      tensor2 = reshape(tensor2, [1, totalLength, elementPerRow]);
      for (let i2 = 0; i2 < length.length; ++i2) {
        const previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
        const indices2 = [0, previousLength, 0];
        const sizes = [1, length[i2], elementPerRow];
        tensors[i2] = reshape(slice(tensor2, indices2, sizes), this.elementShape);
      }
      return tensors;
    });
    const indices = [];
    for (let i2 = 0; i2 < length.length; i2++) {
      indices[i2] = i2;
    }
    this.writeMany(indices, tensors);
  }
};
var TensorList = class {
  constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
    this.tensors = tensors;
    this.elementShape = elementShape;
    this.elementDtype = elementDtype;
    if (tensors != null) {
      tensors.forEach((tensor2) => {
        if (elementDtype !== tensor2.dtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor2.dtype}`);
        }
        assertShapesMatchAllowUndefinedSize(elementShape, tensor2.shape, "TensorList shape mismatch: ");
        keep(tensor2);
      });
    }
    this.idTensor = scalar(0);
    this.maxNumElements = maxNumElements;
    keep(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  copy() {
    return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
  }
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor2) => {
      if (keepIds == null || !keepIds.has(tensor2.id)) {
        tensor2.dispose();
      }
    });
    this.tensors.length = 0;
    this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  stack(elementShape, elementDtype, numElements = -1) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (numElements !== -1 && this.tensors.length !== numElements) {
      throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return tidy(() => {
      const reshapedTensors = this.tensors.map((tensor2) => reshape(tensor2, outputElementShape));
      return stack(reshapedTensors, 0);
    });
  }
  popBack(elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (this.size() === 0) {
      throw new Error("Trying to pop from an empty list.");
    }
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    const tensor2 = this.tensors.pop();
    assertShapesMatchAllowUndefinedSize(tensor2.shape, elementShape, "TensorList shape mismatch: ");
    return reshape(tensor2, outputElementShape);
  }
  pushBack(tensor2) {
    if (tensor2.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(tensor2.shape, this.elementShape, "TensorList shape mismatch: ");
    if (this.maxNumElements === this.size()) {
      throw new Error(`Trying to push element into a full list.`);
    }
    keep(tensor2);
    this.tensors.push(tensor2);
  }
  resize(size2) {
    if (size2 < 0) {
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${size2}`);
    }
    if (this.maxNumElements !== -1 && size2 > this.maxNumElements) {
      throw new Error(`TensorListResize input size ${size2} is greater maxNumElement ${this.maxNumElements}.`);
    }
    this.tensors.length = size2;
  }
  getItem(elementIndex, elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || elementIndex > this.tensors.length) {
      throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
    }
    if (this.tensors[elementIndex] == null) {
      throw new Error(`element at index ${elementIndex} is null.`);
    }
    assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return reshape(this.tensors[elementIndex], outputElementShape);
  }
  setItem(elementIndex, tensor2) {
    if (tensor2.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
      throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, "TensorList shape mismatch: ");
    keep(tensor2);
    this.tensors[elementIndex] = tensor2;
  }
  gather(indices, elementDtype, elementShape) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    indices = indices.slice(0, this.size());
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (indices.length === 0) {
      return tensor([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = indices.map((i2) => reshape(this.tensors[i2], outputElementShape));
      return stack(tensors, 0);
    });
  }
  concat(elementDtype, elementShape) {
    if (!!elementDtype && elementDtype !== this.elementDtype) {
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (this.size() === 0) {
      return tensor([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = this.tensors.map((t2) => reshape(t2, outputElementShape));
      return concat(tensors, 0);
    });
  }
};
function fromTensor(tensor2, elementShape, elementDtype) {
  const dtype = tensor2.dtype;
  if (tensor2.shape.length < 1) {
    throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor2.shape}`);
  }
  if (tensor2.dtype !== elementDtype) {
    throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${elementDtype}`);
  }
  const tensorElementShape = tensor2.shape.slice(1);
  assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
  const tensorList = unstack(tensor2);
  return new TensorList(tensorList, elementShape, dtype);
}
function reserve(elementShape, elementDtype, numElements) {
  return new TensorList([], elementShape, elementDtype, numElements);
}
function scatter(tensor2, indices, elementShape, numElements) {
  if (indices.length !== tensor2.shape[0]) {
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
  }
  const maxIndex = Math.max(...indices);
  if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
    throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
  }
  const list = new TensorList([], elementShape, tensor2.dtype, numElements);
  const tensors = unstack(tensor2, 0);
  indices.forEach((value, index) => {
    list.setItem(value, tensors[index]);
  });
  return list;
}
function split2(tensor2, length, elementShape) {
  let totalLength = 0;
  const cumulativeLengths = length.map((len) => {
    totalLength += len;
    return totalLength;
  });
  if (totalLength !== tensor2.shape[0]) {
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
  }
  const shapeWithoutFirstDim = tensor2.shape.slice(1);
  const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
  const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
  const tensors = tidy(() => {
    const tensors2 = [];
    tensor2 = reshape(tensor2, [1, totalLength, elementPerRow]);
    for (let i2 = 0; i2 < length.length; ++i2) {
      const previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
      const indices = [0, previousLength, 0];
      const sizes = [1, length[i2], elementPerRow];
      tensors2[i2] = reshape(slice(tensor2, indices, sizes), outputElementShape);
    }
    tensor2.dispose();
    return tensors2;
  });
  const list = new TensorList([], elementShape, tensor2.dtype, length.length);
  for (let i2 = 0; i2 < tensors.length; i2++) {
    list.setItem(i2, tensors[i2]);
  }
  return list;
}
var executeOp3 = async (node2, tensorMap, context) => {
  switch (node2.op) {
    case "If":
    case "StatelessIf": {
      const thenFunc = getParamValue("thenBranch", node2, tensorMap, context);
      const elseFunc = getParamValue("elseBranch", node2, tensorMap, context);
      const cond = getParamValue("cond", node2, tensorMap, context);
      const args = getParamValue("args", node2, tensorMap, context);
      const condValue = await cond.data();
      if (condValue[0]) {
        return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      } else {
        return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      }
    }
    case "While":
    case "StatelessWhile": {
      const bodyFunc = getParamValue("body", node2, tensorMap, context);
      const condFunc = getParamValue("cond", node2, tensorMap, context);
      const args = getParamValue("args", node2, tensorMap, context);
      const condResult = await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      const argIds = args.map((tensor2) => tensor2.id);
      let condValue = await condResult[0].data();
      condResult.forEach((tensor2) => {
        if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1) {
          tensor2.dispose();
        }
      });
      let result = args;
      while (condValue[0]) {
        const origResult = result;
        result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
        const resultIds = result.map((tensor2) => tensor2.id);
        origResult.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
        const condResult2 = await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
        condValue = await condResult2[0].data();
        condResult2.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
      }
      return result;
    }
    case "LoopCond": {
      const pred = getParamValue("pred", node2, tensorMap, context);
      return [cloneTensor(pred)];
    }
    case "Switch": {
      const pred = getParamValue("pred", node2, tensorMap, context);
      let data = getParamValue("data", node2, tensorMap, context);
      if (!data.kept) {
        data = cloneTensor(data);
      }
      return (await pred.data())[0] ? [void 0, data] : [data, void 0];
    }
    case "Merge": {
      const inputName = node2.inputNames.find((name) => getTensor(name, tensorMap, context) !== void 0);
      if (inputName) {
        const data = getTensor(inputName, tensorMap, context);
        return [cloneTensor(data)];
      }
      return void 0;
    }
    case "Enter": {
      const frameId = getParamValue("frameName", node2, tensorMap, context);
      const data = getParamValue("tensor", node2, tensorMap, context);
      context.enterFrame(frameId);
      return [cloneTensor(data)];
    }
    case "Exit": {
      const data = getParamValue("tensor", node2, tensorMap, context);
      context.exitFrame();
      return [cloneTensor(data)];
    }
    case "NextIteration": {
      const data = getParamValue("tensor", node2, tensorMap, context);
      context.nextIteration();
      return [cloneTensor(data)];
    }
    case "TensorArrayV3": {
      const size2 = getParamValue("size", node2, tensorMap, context);
      const dtype = getParamValue("dtype", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const dynamicSize = getParamValue("dynamicSize", node2, tensorMap, context);
      const clearAfterRead = getParamValue("clearAfterRead", node2, tensorMap, context);
      const identicalElementShapes = getParamValue("identicalElementShapes", node2, tensorMap, context);
      const name = getParamValue("name", node2, tensorMap, context);
      const tensorArray = new TensorArray(name, dtype, size2, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
      context.addTensorArray(tensorArray);
      return [tensorArray.idTensor, scalar(1)];
    }
    case "TensorArrayWriteV3": {
      const id = getParamValue("tensorArrayId", node2, tensorMap, context);
      const index = getParamValue("index", node2, tensorMap, context);
      const writeTensor = getParamValue("tensor", node2, tensorMap, context);
      const writeTensorArray = context.getTensorArray(id.id);
      writeTensorArray.write(index, writeTensor);
      return [writeTensorArray.idTensor];
    }
    case "TensorArrayReadV3": {
      const readId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const readIndex = getParamValue("index", node2, tensorMap, context);
      const readTensorArray = context.getTensorArray(readId.id);
      return [readTensorArray.read(readIndex)];
    }
    case "TensorArrayGatherV3": {
      const gatherId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const gatherIndices = getParamValue("indices", node2, tensorMap, context);
      const gatherDtype = getParamValue("dtype", node2, tensorMap, context);
      const gatherTensorArray = context.getTensorArray(gatherId.id);
      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
    }
    case "TensorArrayScatterV3": {
      const scatterId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const scatterIndices = getParamValue("indices", node2, tensorMap, context);
      const scatterTensor = getParamValue("tensor", node2, tensorMap, context);
      const scatterTensorArray = context.getTensorArray(scatterId.id);
      scatterTensorArray.scatter(scatterIndices, scatterTensor);
      return [scatterTensorArray.idTensor];
    }
    case "TensorArrayConcatV3": {
      const concatId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const concatTensorArray = context.getTensorArray(concatId.id);
      const concatDtype = getParamValue("dtype", node2, tensorMap, context);
      return [concatTensorArray.concat(concatDtype)];
    }
    case "TensorArraySplitV3": {
      const splitId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const splitTensor = getParamValue("tensor", node2, tensorMap, context);
      const lengths = getParamValue("lengths", node2, tensorMap, context);
      const splitTensorArray = context.getTensorArray(splitId.id);
      splitTensorArray.split(lengths, splitTensor);
      return [splitTensorArray.idTensor];
    }
    case "TensorArraySizeV3": {
      const sizeId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const sizeTensorArray = context.getTensorArray(sizeId.id);
      return [scalar(sizeTensorArray.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const closeId = getParamValue("tensorArrayId", node2, tensorMap, context);
      const closeTensorArray = context.getTensorArray(closeId.id);
      closeTensorArray.clearAndClose();
      return [closeTensorArray.idTensor];
    }
    case "TensorListSetItem": {
      const idTensor = getParamValue("tensorListId", node2, tensorMap, context);
      const index = getParamValue("index", node2, tensorMap, context);
      const writeTensor = getParamValue("tensor", node2, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      tensorList.setItem(index, writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListGetItem": {
      const idTensor = getParamValue("tensorListId", node2, tensorMap, context);
      const readIndex = getParamValue("index", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDType = getParamValue("elementDType", node2, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.getItem(readIndex, elementShape, elementDType)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const scatterIndices = getParamValue("indices", node2, tensorMap, context);
      const scatterTensor = getParamValue("tensor", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const numElements = getParamValue("numElements", node2, tensorMap, context);
      const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node2, tensorMap, context);
      let numElementsParam;
      if (node2.op === "TensorListReserve") {
        numElementsParam = "numElements";
      } else {
        numElementsParam = "maxNumElements";
      }
      const numElements = getParamValue(numElementsParam, node2, tensorMap, context);
      const tensorList = reserve(elementShape, elementDtype, numElements);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListGather": {
      const gatherId = getParamValue("tensorListId", node2, tensorMap, context);
      const gatherIndices = getParamValue("indices", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node2, tensorMap, context);
      const tensorList = context.getTensorList(gatherId.id);
      return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
    }
    case "TensorListStack": {
      const idTensor = getParamValue("tensorListId", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node2, tensorMap, context);
      const numElements = getParamValue("numElements", node2, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.stack(elementShape, elementDtype, numElements)];
    }
    case "TensorListFromTensor": {
      const tensor2 = getParamValue("tensor", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node2, tensorMap, context);
      const tensorList = fromTensor(tensor2, elementShape, elementDtype);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListConcat": {
      const concatId = getParamValue("tensorListId", node2, tensorMap, context);
      const tensorList = context.getTensorList(concatId.id);
      const concatDtype = getParamValue("dtype", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      return [tensorList.concat(concatDtype, elementShape)];
    }
    case "TensorListPushBack": {
      const idTensor = getParamValue("tensorListId", node2, tensorMap, context);
      const writeTensor = getParamValue("tensor", node2, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      tensorList.pushBack(writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListPopBack": {
      const idTensor = getParamValue("tensorListId", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const elementDType = getParamValue("elementDType", node2, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.popBack(elementShape, elementDType)];
    }
    case "TensorListSplit": {
      const splitTensor = getParamValue("tensor", node2, tensorMap, context);
      const elementShape = getParamValue("elementShape", node2, tensorMap, context);
      const lengths = getParamValue("lengths", node2, tensorMap, context);
      const tensorList = split2(splitTensor, lengths, elementShape);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
function fusedConvAndDepthWiseParams(node2, tensorMap, context) {
  const [extraOp, activationFunc] = getParamValue("fusedOps", node2, tensorMap, context);
  const isBiasAdd = extraOp === "biasadd";
  const noBiasAdd = !isBiasAdd;
  const isPrelu = activationFunc === "prelu";
  const isBatchNorm = extraOp === "fusedbatchnorm";
  const numArgs = getParamValue("numArgs", node2, tensorMap, context);
  if (isBiasAdd) {
    if (isPrelu && numArgs !== 2) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    }
    if (!isPrelu && isBiasAdd && numArgs !== 1) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
    }
  }
  if (isBatchNorm) {
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  }
  const stride = getParamValue("strides", node2, tensorMap, context);
  const pad3 = getPadding(node2, tensorMap, context);
  const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
  const dilations = getParamValue("dilations", node2, tensorMap, context);
  let [biasArg, preluArg] = getParamValue("args", node2, tensorMap, context);
  if (noBiasAdd) {
    preluArg = biasArg;
    biasArg = void 0;
  }
  const leakyreluAlpha = getParamValue("leakyreluAlpha", node2, tensorMap, context);
  return {
    stride,
    pad: pad3,
    dataFormat,
    dilations,
    biasArg,
    preluArg,
    activationFunc,
    leakyreluAlpha
  };
}
var executeOp4 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Conv1D": {
      const stride = getParamValue("stride", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
      const dilation = getParamValue("dilation", node2, tensorMap, context);
      return [conv1d(getParamValue("x", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), stride, pad3, dataFormat, dilation)];
    }
    case "Conv2D": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getPadding(node2, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
      const dilations = getParamValue("dilations", node2, tensorMap, context);
      return [conv2d(getParamValue("x", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), [stride[1], stride[2]], pad3, dataFormat, [dilations[1], dilations[2]])];
    }
    case "_FusedConv2D": {
      const { stride, pad: pad3, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node2, tensorMap, context);
      return [fused_ops_exports.conv2d({
        x: getParamValue("x", node2, tensorMap, context),
        filter: getParamValue("filter", node2, tensorMap, context),
        strides: [stride[1], stride[2]],
        pad: pad3,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride, pad: pad3, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node2, tensorMap, context);
      return [fused_ops_exports.depthwiseConv2d({
        x: getParamValue("x", node2, tensorMap, context),
        filter: getParamValue("filter", node2, tensorMap, context),
        strides: [stride[1], stride[2]],
        pad: pad3,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const shape = getParamValue("outputShape", node2, tensorMap, context);
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getPadding(node2, tensorMap, context);
      return [conv2dTranspose(getParamValue("x", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), shape, [stride[1], stride[2]], pad3)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getPadding(node2, tensorMap, context);
      const dilations = getParamValue("dilations", node2, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
      return [depthwiseConv2d(getParamValue("input", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), [stride[1], stride[2]], pad3, dataFormat, [dilations[1], dilations[2]])];
    }
    case "Conv3D": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
      const dilations = getParamValue("dilations", node2, tensorMap, context);
      return [conv3d(getParamValue("x", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), [stride[1], stride[2], stride[3]], pad3, dataFormat, [dilations[1], dilations[2], dilations[3]])];
    }
    case "AvgPool": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node2, tensorMap, context);
      return [avgPool(getParamValue("x", node2, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3)];
    }
    case "MaxPool": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node2, tensorMap, context);
      return [maxPool(getParamValue("x", node2, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3)];
    }
    case "MaxPoolWithArgmax": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node2, tensorMap, context);
      const includeBatchInIndex = getParamValue("includeBatchInIndex", node2, tensorMap, context);
      const { result, indexes } = maxPoolWithArgmax(getParamValue("x", node2, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3, includeBatchInIndex);
      return [result, indexes];
    }
    case "AvgPool3D": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node2, tensorMap, context);
      return [avgPool3d(getParamValue("x", node2, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad3)];
    }
    case "MaxPool3D": {
      const stride = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node2, tensorMap, context);
      return [maxPool3d(getParamValue("x", node2, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad3)];
    }
    case "Dilation2D": {
      const strides = getParamValue("strides", node2, tensorMap, context);
      const pad3 = getParamValue("pad", node2, tensorMap, context);
      const dilations = getParamValue("dilations", node2, tensorMap, context);
      const strideHeight = strides[1];
      const strideWidth = strides[2];
      const dilationHeight = dilations[1];
      const dilationWidth = dilations[2];
      return [dilation2d(getParamValue("x", node2, tensorMap, context), getParamValue("filter", node2, tensorMap, context), [strideHeight, strideWidth], pad3, [dilationHeight, dilationWidth], "NHWC")];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp5 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Fill": {
      const shape = getParamValue("shape", node2, tensorMap, context);
      const dtype = getParamValue("dtype", node2, tensorMap, context);
      const value = getParamValue("value", node2, tensorMap, context);
      return [fill(shape, value, dtype)];
    }
    case "LinSpace": {
      const start = getParamValue("start", node2, tensorMap, context);
      const stop = getParamValue("stop", node2, tensorMap, context);
      const num = getParamValue("num", node2, tensorMap, context);
      return [linspace(start, stop, num)];
    }
    case "Multinomial": {
      const logits = getParamValue("logits", node2, tensorMap, context);
      const numSamples = getParamValue("numSamples", node2, tensorMap, context);
      const seed = getParamValue("seed", node2, tensorMap, context);
      return [multinomial(logits, numSamples, seed)];
    }
    case "OneHot": {
      const indices = getParamValue("indices", node2, tensorMap, context);
      const depth = getParamValue("depth", node2, tensorMap, context);
      const onValue = getParamValue("onValue", node2, tensorMap, context);
      const offValue = getParamValue("offValue", node2, tensorMap, context);
      return [oneHot(indices, depth, onValue, offValue)];
    }
    case "Ones": {
      return [ones2(getParamValue("shape", node2, tensorMap, context), getParamValue("dtype", node2, tensorMap, context))];
    }
    case "OnesLike": {
      return [onesLike(getParamValue("x", node2, tensorMap, context))];
    }
    case "RandomUniform": {
      return [randomUniform(getParamValue("shape", node2, tensorMap, context), getParamValue("minval", node2, tensorMap, context), getParamValue("maxval", node2, tensorMap, context), getParamValue("dtype", node2, tensorMap, context))];
    }
    case "Range": {
      const start = getParamValue("start", node2, tensorMap, context);
      const stop = getParamValue("stop", node2, tensorMap, context);
      const step5 = getParamValue("step", node2, tensorMap, context);
      return [range(start, stop, step5, getParamValue("dtype", node2, tensorMap, context))];
    }
    case "TruncatedNormal": {
      const shape = getParamValue("shape", node2, tensorMap, context);
      const mean5 = getParamValue("mean", node2, tensorMap, context);
      const stdDev = getParamValue("stdDev", node2, tensorMap, context);
      const seed = getParamValue("seed", node2, tensorMap, context);
      return [truncatedNormal(shape, mean5, stdDev, getParamValue("dtype", node2, tensorMap, context), seed)];
    }
    case "Zeros": {
      return [zeros(getParamValue("shape", node2, tensorMap, context), getParamValue("dtype", node2, tensorMap, context))];
    }
    case "ZerosLike": {
      return [zerosLike(getParamValue("x", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
function nmsParams(node2, tensorMap, context) {
  const boxes = getParamValue("boxes", node2, tensorMap, context);
  const scores = getParamValue("scores", node2, tensorMap, context);
  const maxOutputSize = getParamValue("maxOutputSize", node2, tensorMap, context);
  const iouThreshold = getParamValue("iouThreshold", node2, tensorMap, context);
  const scoreThreshold = getParamValue("scoreThreshold", node2, tensorMap, context);
  const softNmsSigma = getParamValue("softNmsSigma", node2, tensorMap, context);
  return {
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    softNmsSigma
  };
}
var executeOp6 = async (node2, tensorMap, context) => {
  switch (node2.op) {
    case "NonMaxSuppressionV5": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node2, tensorMap, context);
      const result = await image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      return [result.selectedIndices, result.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node2, tensorMap, context);
      const padToMaxOutputSize = getParamValue("padToMaxOutputSize", node2, tensorMap, context);
      const result = await image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
      return [result.selectedIndices, result.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node2, tensorMap, context);
      return [await image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
    }
    case "Where": {
      const condition = cast(getParamValue("condition", node2, tensorMap, context), "bool");
      const result = [await whereAsync(condition)];
      condition.dispose();
      return result;
    }
    case "ListDiff": {
      return setdiff1dAsync(getParamValue("x", node2, tensorMap, context), getParamValue("y", node2, tensorMap, context));
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp7 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "TopKV2": {
      const x2 = getParamValue("x", node2, tensorMap, context);
      const k3 = getParamValue("k", node2, tensorMap, context);
      const sorted = getParamValue("sorted", node2, tensorMap, context);
      const result = topk(x2, k3, sorted);
      return [result.values, result.indices];
    }
    case "Unique": {
      const x2 = getParamValue("x", node2, tensorMap, context);
      const result = unique(x2);
      return [result.values, result.indices];
    }
    case "UniqueV2": {
      const x2 = getParamValue("x", node2, tensorMap, context);
      const axis = getParamValue("axis", node2, tensorMap, context);
      const result = unique(x2, axis);
      return [result.values, result.indices];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp8 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Const": {
      return tensorMap[node2.name];
    }
    case "PlaceholderWithDefault":
      const def = getParamValue("default", node2, tensorMap, context);
      return [getTensor(node2.name, tensorMap, context) || def];
    case "Placeholder":
      return [getTensor(node2.name, tensorMap, context)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const data2 = getParamValue("x", node2, tensorMap, context);
      return [cloneTensor(data2)];
    }
    case "IdentityN":
      return getParamValue("x", node2, tensorMap, context).map((t2) => cloneTensor(t2));
    case "Snapshot":
      const snapshot = getParamValue("x", node2, tensorMap, context);
      return [cloneTensor(snapshot)];
    case "Shape":
      return [tensor1d(getParamValue("x", node2, tensorMap, context).shape, "int32")];
    case "ShapeN":
      return getParamValue("x", node2, tensorMap, context).map((t2) => tensor1d(t2.shape));
    case "Size":
      return [scalar(getParamValue("x", node2, tensorMap, context).size, "int32")];
    case "Rank":
      return [scalar(getParamValue("x", node2, tensorMap, context).rank, "int32")];
    case "NoOp":
      return [scalar(1)];
    case "Print":
      const input2 = getParamValue("x", node2, tensorMap, context);
      const data = getParamValue("data", node2, tensorMap, context);
      const message = getParamValue("message", node2, tensorMap, context);
      const summarize = getParamValue("summarize", node2, tensorMap, context);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
      console.log(message);
      for (let i2 = 0; i2 < data.length; i2++) {
        console.log(Array.prototype.slice.call(data[i2].dataSync()).slice(0, summarize));
      }
      return [input2];
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var HashTable = class {
  constructor(keyDType, valueDType) {
    this.keyDType = keyDType;
    this.valueDType = valueDType;
    this.handle = scalar(0);
    this.tensorMap = new Map();
    keep(this.handle);
  }
  get id() {
    return this.handle.id;
  }
  clearAndClose() {
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    this.handle.dispose();
  }
  size() {
    return this.tensorMap.size;
  }
  tensorSize() {
    return scalar(this.size(), "int32");
  }
  async import(keys, values) {
    this.checkKeyAndValueTensor(keys, values);
    const $keys = await keys.data();
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    return tidy(() => {
      const $values = unstack(values);
      const keysLength = $keys.length;
      const valuesLength = $values.length;
      util_exports.assert(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ${keysLength} elements, the values has ${valuesLength} elements.`);
      for (let i2 = 0; i2 < keysLength; i2++) {
        const key = $keys[i2];
        const value = $values[i2];
        keep(value);
        this.tensorMap.set(key, value);
      }
      return this.handle;
    });
  }
  async find(keys, defaultValue) {
    this.checkKeyAndValueTensor(keys, defaultValue);
    const $keys = await keys.data();
    return tidy(() => {
      const result = [];
      for (let i2 = 0; i2 < $keys.length; i2++) {
        const key = $keys[i2];
        const value = this.findWithDefault(key, defaultValue);
        result.push(value);
      }
      return stack(result);
    });
  }
  findWithDefault(key, defaultValue) {
    const result = this.tensorMap.get(key);
    return result != null ? result : defaultValue;
  }
  checkKeyAndValueTensor(key, value) {
    if (key.dtype !== this.keyDType) {
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${key.dtype}`);
    }
    if (value.dtype !== this.valueDType) {
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${value.dtype}`);
    }
  }
};
var executeOp9 = async (node2, tensorMap, context, resourceManager) => {
  switch (node2.op) {
    case "HashTable":
    case "HashTableV2": {
      const keyDType = getParamValue("keyDType", node2, tensorMap, context);
      const valueDType = getParamValue("valueDType", node2, tensorMap, context);
      const hashTable2 = new HashTable(keyDType, valueDType);
      resourceManager.addHashTable(node2.name, hashTable2);
      return [hashTable2.handle];
    }
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const handle = getParamValue("tableHandle", node2, tensorMap, context, resourceManager);
      const keys = getParamValue("keys", node2, tensorMap, context);
      const values = getParamValue("values", node2, tensorMap, context);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [await hashTable2.import(keys, values)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const handle = getParamValue("tableHandle", node2, tensorMap, context, resourceManager);
      const keys = getParamValue("keys", node2, tensorMap, context);
      const defaultValue = getParamValue("defaultValue", node2, tensorMap, context);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [await hashTable2.find(keys, defaultValue)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const handle = getParamValue("tableHandle", node2, tensorMap, context, resourceManager);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [hashTable2.tensorSize()];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp10 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "ResizeBilinear": {
      const images = getParamValue("images", node2, tensorMap, context);
      const size2 = getParamValue("size", node2, tensorMap, context);
      const alignCorners = getParamValue("alignCorners", node2, tensorMap, context);
      const halfPixelCenters = getParamValue("halfPixelCenters", node2, tensorMap, context);
      return [image.resizeBilinear(images, [size2[0], size2[1]], alignCorners, halfPixelCenters)];
    }
    case "ResizeNearestNeighbor": {
      const images = getParamValue("images", node2, tensorMap, context);
      const size2 = getParamValue("size", node2, tensorMap, context);
      const alignCorners = getParamValue("alignCorners", node2, tensorMap, context);
      const halfPixelCenters = getParamValue("halfPixelCenters", node2, tensorMap, context);
      return [image.resizeNearestNeighbor(images, [size2[0], size2[1]], alignCorners, halfPixelCenters)];
    }
    case "CropAndResize": {
      const image32 = getParamValue("image", node2, tensorMap, context);
      const boxes = getParamValue("boxes", node2, tensorMap, context);
      const boxInd = getParamValue("boxInd", node2, tensorMap, context);
      const cropSize = getParamValue("cropSize", node2, tensorMap, context);
      const method = getParamValue("method", node2, tensorMap, context);
      const extrapolationValue = getParamValue("extrapolationValue", node2, tensorMap, context);
      return [image.cropAndResize(image32, boxes, boxInd, cropSize, method, extrapolationValue)];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp11 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Equal": {
      return [equal(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "NotEqual": {
      return [notEqual(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Greater": {
      return [greater(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "GreaterEqual": {
      return [greaterEqual(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Less": {
      return [less(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "LessEqual": {
      return [lessEqual(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "LogicalAnd": {
      return [logicalAnd(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "LogicalNot": {
      return [logicalNot(getParamValue("a", node2, tensorMap, context))];
    }
    case "LogicalOr": {
      return [logicalOr(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    case "Select":
    case "SelectV2": {
      return [where(getParamValue("condition", node2, tensorMap, context), getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp12 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [matMul(getParamValue("a", node2, tensorMap, context), getParamValue("b", node2, tensorMap, context), getParamValue("transposeA", node2, tensorMap, context), getParamValue("transposeB", node2, tensorMap, context))];
    case "Einsum":
      return [einsum(getParamValue("equation", node2, tensorMap, context), ...getParamValue("tensors", node2, tensorMap, context))];
    case "Transpose":
      return [transpose(getParamValue("x", node2, tensorMap, context), getParamValue("perm", node2, tensorMap, context))];
    case "_FusedMatMul":
      const [extraOp, activationFunc] = getParamValue("fusedOps", node2, tensorMap, context);
      const isBiasAdd = extraOp === "biasadd";
      const isPrelu = activationFunc === "prelu";
      const numArgs = getParamValue("numArgs", node2, tensorMap, context);
      const leakyreluAlpha = getParamValue("leakyreluAlpha", node2, tensorMap, context);
      if (isBiasAdd) {
        if (isPrelu && numArgs !== 2) {
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        }
        if (!isPrelu && numArgs !== 1) {
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
        }
      }
      const [biasArg, preluArg] = getParamValue("args", node2, tensorMap, context);
      return [fused_ops_exports.matMul({
        a: getParamValue("a", node2, tensorMap, context),
        b: getParamValue("b", node2, tensorMap, context),
        transposeA: getParamValue("transposeA", node2, tensorMap, context),
        transposeB: getParamValue("transposeB", node2, tensorMap, context),
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp13 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2": {
      return [batchNorm(getParamValue("x", node2, tensorMap, context), getParamValue("mean", node2, tensorMap, context), getParamValue("variance", node2, tensorMap, context), getParamValue("offset", node2, tensorMap, context), getParamValue("scale", node2, tensorMap, context), getParamValue("epsilon", node2, tensorMap, context))];
    }
    case "FusedBatchNormV3": {
      return [batchNorm(getParamValue("x", node2, tensorMap, context), getParamValue("mean", node2, tensorMap, context), getParamValue("variance", node2, tensorMap, context), getParamValue("offset", node2, tensorMap, context), getParamValue("scale", node2, tensorMap, context), getParamValue("epsilon", node2, tensorMap, context))];
    }
    case "LRN": {
      return [localResponseNormalization(getParamValue("x", node2, tensorMap, context), getParamValue("radius", node2, tensorMap, context), getParamValue("bias", node2, tensorMap, context), getParamValue("alpha", node2, tensorMap, context), getParamValue("beta", node2, tensorMap, context))];
    }
    case "Softmax": {
      return [softmax(getParamValue("x", node2, tensorMap, context))];
    }
    case "LogSoftmax": {
      return [logSoftmax(getParamValue("x", node2, tensorMap, context))];
    }
    case "SparseToDense": {
      return [sparseToDense(getParamValue("sparseIndices", node2, tensorMap, context), getParamValue("outputShape", node2, tensorMap, context), getParamValue("sparseValues", node2, tensorMap, context), getParamValue("defaultValue", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp14 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Max": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [max(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "Mean": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [mean(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "Min": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [min(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "Sum": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [sum2(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "All": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [all(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "Any": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [any(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "ArgMax": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      return [argMax(getParamValue("x", node2, tensorMap, context), axis)];
    }
    case "ArgMin": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      return [argMin(getParamValue("x", node2, tensorMap, context), axis)];
    }
    case "Prod": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const keepDims = getParamValue("keepDims", node2, tensorMap, context);
      return [prod(getParamValue("x", node2, tensorMap, context), axis, keepDims)];
    }
    case "Cumsum": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const exclusive = getParamValue("exclusive", node2, tensorMap, context);
      const reverse5 = getParamValue("reverse", node2, tensorMap, context);
      return [cumsum(getParamValue("x", node2, tensorMap, context), axis, exclusive, reverse5)];
    }
    case "Bincount":
      const x2 = getParamValue("x", node2, tensorMap, context);
      const weights = getParamValue("weights", node2, tensorMap, context);
      const size2 = getParamValue("size", node2, tensorMap, context);
      return [bincount(x2, weights, size2)];
    case "DenseBincount": {
      const x22 = getParamValue("x", node2, tensorMap, context);
      const weights2 = getParamValue("weights", node2, tensorMap, context);
      const size22 = getParamValue("size", node2, tensorMap, context);
      const binaryOutput = getParamValue("binaryOutput", node2, tensorMap, context);
      return [denseBincount(x22, weights2, size22, binaryOutput)];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp15 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "ConcatV2":
    case "Concat": {
      const n2 = getParamValue("n", node2, tensorMap, context);
      const axis = getParamValue("axis", node2, tensorMap, context);
      let inputs = getParamValue("tensors", node2, tensorMap, context);
      inputs = inputs.slice(0, n2);
      return [concat(inputs, axis)];
    }
    case "Gather": {
      const input2 = getParamValue("x", node2, tensorMap, context);
      const indices = getParamValue("indices", node2, tensorMap, context);
      return [gather(input2, cast(indices, "int32"), 0)];
    }
    case "GatherV2": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const batchDims = getParamValue("batchDims", node2, tensorMap, context);
      const input2 = getParamValue("x", node2, tensorMap, context);
      const indices = getParamValue("indices", node2, tensorMap, context);
      return [gather(input2, cast(indices, "int32"), axis, batchDims)];
    }
    case "Reverse": {
      const dims = getParamValue("dims", node2, tensorMap, context);
      const axis = [];
      for (let i2 = 0; i2 < dims.length; i2++) {
        if (dims[i2]) {
          axis.push(i2);
        }
      }
      const input2 = getParamValue("x", node2, tensorMap, context);
      return [reverse(input2, axis)];
    }
    case "ReverseV2": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const input2 = getParamValue("x", node2, tensorMap, context);
      return [reverse(input2, axis)];
    }
    case "Slice": {
      const begin = getParamValue("begin", node2, tensorMap, context);
      const size2 = getParamValue("size", node2, tensorMap, context);
      return [slice(getParamValue("x", node2, tensorMap, context), begin, size2)];
    }
    case "StridedSlice": {
      const begin = getParamValue("begin", node2, tensorMap, context);
      const end = getParamValue("end", node2, tensorMap, context);
      const strides = getParamValue("strides", node2, tensorMap, context);
      const beginMask = getParamValue("beginMask", node2, tensorMap, context);
      const endMask = getParamValue("endMask", node2, tensorMap, context);
      const ellipsisMask = getParamValue("ellipsisMask", node2, tensorMap, context);
      const newAxisMask = getParamValue("newAxisMask", node2, tensorMap, context);
      const shrinkAxisMask = getParamValue("shrinkAxisMask", node2, tensorMap, context);
      const tensor2 = getParamValue("x", node2, tensorMap, context);
      return [stridedSlice(tensor2, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
    }
    case "Pack": {
      return tidy(() => {
        const axis = getParamValue("axis", node2, tensorMap, context);
        const tensors = getParamValue("tensors", node2, tensorMap, context);
        const shape = tensors[0].shape;
        const squeezedShape = squeeze(tensors[0]).shape;
        const mapped = tensors.map((tensor2) => {
          const sameShape = util_exports.arraysEqual(tensor2.shape, shape);
          if (!sameShape && !util_exports.arraysEqual(squeeze(tensor2).shape, squeezedShape)) {
            throw new Error("the input tensors shape does not match");
          }
          return sameShape ? tensor2 : reshape(tensor2, shape);
        });
        return [stack(mapped, axis)];
      });
    }
    case "Unpack": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const tensor2 = getParamValue("tensor", node2, tensorMap, context);
      return unstack(tensor2, axis);
    }
    case "Tile": {
      const reps = getParamValue("reps", node2, tensorMap, context);
      return [tile(getParamValue("x", node2, tensorMap, context), reps)];
    }
    case "Split":
    case "SplitV": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      const numOrSizeSplits = getParamValue("numOrSizeSplits", node2, tensorMap, context);
      const tensor2 = getParamValue("x", node2, tensorMap, context);
      return split(tensor2, numOrSizeSplits, axis);
    }
    case "ScatterNd": {
      const indices = getParamValue("indices", node2, tensorMap, context);
      const values = getParamValue("values", node2, tensorMap, context);
      const shape = getParamValue("shape", node2, tensorMap, context);
      return [scatterND(indices, values, shape)];
    }
    case "GatherNd": {
      const x2 = getParamValue("x", node2, tensorMap, context);
      const indices = getParamValue("indices", node2, tensorMap, context);
      return [gatherND(x2, indices)];
    }
    case "SparseToDense": {
      const indices = getParamValue("sparseIndices", node2, tensorMap, context);
      const shape = getParamValue("outputShape", node2, tensorMap, context);
      const sparseValues = getParamValue("sparseValues", node2, tensorMap, context);
      const defaultValue = getParamValue("defaultValue", node2, tensorMap, context);
      return [sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : cast(defaultValue, sparseValues.dtype))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp16 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices, outputValues, emptyRowIndicator, reverseIndexMap } = sparse.sparseFillEmptyRows(getParamValue("indices", node2, tensorMap, context), getParamValue("values", node2, tensorMap, context), getParamValue("denseShape", node2, tensorMap, context), getParamValue("defaultValue", node2, tensorMap, context));
      return [
        outputIndices,
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    case "SparseReshape": {
      const { outputIndices, outputShape } = sparse.sparseReshape(getParamValue("inputIndices", node2, tensorMap, context), getParamValue("inputShape", node2, tensorMap, context), getParamValue("newShape", node2, tensorMap, context));
      return [outputIndices, outputShape];
    }
    case "SparseSegmentMean": {
      const outputData = sparse.sparseSegmentMean(getParamValue("data", node2, tensorMap, context), getParamValue("indices", node2, tensorMap, context), getParamValue("segmentIds", node2, tensorMap, context));
      return [outputData];
    }
    case "SparseSegmentSum": {
      const outputData = sparse.sparseSegmentSum(getParamValue("data", node2, tensorMap, context), getParamValue("indices", node2, tensorMap, context), getParamValue("segmentIds", node2, tensorMap, context));
      return [outputData];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp17 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "FFT": {
      return [fft(getParamValue("x", node2, tensorMap, context))];
    }
    case "IFFT": {
      return [ifft(getParamValue("x", node2, tensorMap, context))];
    }
    case "RFFT": {
      return [rfft(getParamValue("x", node2, tensorMap, context))];
    }
    case "IRFFT": {
      return [irfft(getParamValue("x", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp18 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "StringNGrams": {
      const { nGrams, nGramsSplits } = string.stringNGrams(getParamValue("data", node2, tensorMap, context), getParamValue("dataSplits", node2, tensorMap, context), getParamValue("separator", node2, tensorMap, context), getParamValue("nGramWidths", node2, tensorMap, context), getParamValue("leftPad", node2, tensorMap, context), getParamValue("rightPad", node2, tensorMap, context), getParamValue("padWidth", node2, tensorMap, context), getParamValue("preserveShortSequences", node2, tensorMap, context));
      return [nGrams, nGramsSplits];
    }
    case "StringSplit": {
      const { indices, values, shape } = string.stringSplit(getParamValue("input", node2, tensorMap, context), getParamValue("delimiter", node2, tensorMap, context), getParamValue("skipEmpty", node2, tensorMap, context));
      return [indices, values, shape];
    }
    case "StringToHashBucketFast": {
      const output = string.stringToHashBucketFast(getParamValue("input", node2, tensorMap, context), getParamValue("numBuckets", node2, tensorMap, context));
      return [output];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
var executeOp19 = (node2, tensorMap, context) => {
  switch (node2.op) {
    case "Cast": {
      return [cast(getParamValue("x", node2, tensorMap, context), getParamValue("dtype", node2, tensorMap, context))];
    }
    case "ExpandDims": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      return [expandDims(getParamValue("x", node2, tensorMap, context), axis)];
    }
    case "Squeeze": {
      const axis = getParamValue("axis", node2, tensorMap, context);
      return [squeeze(getParamValue("x", node2, tensorMap, context), axis)];
    }
    case "Reshape": {
      return [reshape(getParamValue("x", node2, tensorMap, context), getParamValue("shape", node2, tensorMap, context))];
    }
    case "MirrorPad": {
      return [mirrorPad(getParamValue("x", node2, tensorMap, context), getParamValue("padding", node2, tensorMap, context), getParamValue("mode", node2, tensorMap, context))];
    }
    case "PadV2":
    case "Pad": {
      return [pad(getParamValue("x", node2, tensorMap, context), getParamValue("padding", node2, tensorMap, context), getParamValue("constantValue", node2, tensorMap, context))];
    }
    case "SpaceToBatchND": {
      const blockShape = getParamValue("blockShape", node2, tensorMap, context);
      const paddings = getParamValue("paddings", node2, tensorMap, context);
      return [spaceToBatchND(getParamValue("x", node2, tensorMap, context), blockShape, paddings)];
    }
    case "BatchToSpaceND": {
      const blockShape = getParamValue("blockShape", node2, tensorMap, context);
      const crops = getParamValue("crops", node2, tensorMap, context);
      return [batchToSpaceND(getParamValue("x", node2, tensorMap, context), blockShape, crops)];
    }
    case "DepthToSpace": {
      const blockSize = getParamValue("blockSize", node2, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node2, tensorMap, context).toUpperCase();
      return [depthToSpace(getParamValue("x", node2, tensorMap, context), blockSize, dataFormat)];
    }
    case "BroadcastTo": {
      return [broadcastTo(getParamValue("x", node2, tensorMap, context), getParamValue("shape", node2, tensorMap, context))];
    }
    case "BroadcastArgs": {
      return [broadcastArgs(getParamValue("s0", node2, tensorMap, context), getParamValue("s1", node2, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node2.op} is not implemented`);
  }
};
function executeOp20(node2, tensorMap, context, resourceManager) {
  const value = ((node22, tensorMap2, context2) => {
    switch (node22.category) {
      case "arithmetic":
        return tidy(() => executeOp(node22, tensorMap2, context2));
      case "basic_math":
        return tidy(() => executeOp2(node22, tensorMap2, context2));
      case "control":
        return executeOp3(node22, tensorMap2, context2);
      case "convolution":
        return tidy(() => executeOp4(node22, tensorMap2, context2));
      case "creation":
        return tidy(() => executeOp5(node22, tensorMap2, context2));
      case "dynamic":
        return executeOp6(node22, tensorMap2, context2);
      case "evaluation":
        return tidy(() => executeOp7(node22, tensorMap2, context2));
      case "image":
        return tidy(() => executeOp10(node22, tensorMap2, context2));
      case "graph":
        return tidy(() => executeOp8(node22, tensorMap2, context2));
      case "logical":
        return tidy(() => executeOp11(node22, tensorMap2, context2));
      case "matrices":
        return tidy(() => executeOp12(node22, tensorMap2, context2));
      case "normalization":
        return tidy(() => executeOp13(node22, tensorMap2, context2));
      case "reduction":
        return tidy(() => executeOp14(node22, tensorMap2, context2));
      case "slice_join":
        return tidy(() => executeOp15(node22, tensorMap2, context2));
      case "sparse":
        return tidy(() => executeOp16(node22, tensorMap2, context2));
      case "spectral":
        return tidy(() => executeOp17(node22, tensorMap2, context2));
      case "string":
        return tidy(() => executeOp18(node22, tensorMap2, context2));
      case "transformation":
        return tidy(() => executeOp19(node22, tensorMap2, context2));
      case "hash_table":
        return executeOp9(node22, tensorMap2, context2, resourceManager);
      case "custom":
        const opMapper = getRegisteredOp(node22.op);
        if (opMapper && opMapper.customExecutor) {
          return opMapper.customExecutor(new NodeValueImpl(node22, tensorMap2, context2));
        } else {
          throw TypeError(`Custom op ${node22.op} is not registered.`);
        }
      default:
        throw TypeError(`Unknown op '${node22.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(node2, tensorMap, context);
  if (util_exports.isPromise(value)) {
    return value.then((data) => [].concat(data));
  }
  return [].concat(value);
}
var ExecutionContext = class {
  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {
    this.weightMap = weightMap;
    this.tensorArrayMap = tensorArrayMap;
    this.tensorListMap = tensorListMap;
    this.functionMap = functionMap;
    this.rootContext = { id: 0, frameName: "", iterationId: 0 };
    this.contexts = [this.rootContext];
    this.lastId = 0;
    this.generateCurrentContextIds();
  }
  newFrame(id, frameName) {
    return { id, frameName, iterationId: 0 };
  }
  set currentContext(contexts2) {
    if (this.contexts !== contexts2) {
      this.contexts = contexts2;
      this.generateCurrentContextIds();
    }
  }
  get currentContext() {
    return this.contexts;
  }
  get currentContextId() {
    return this._currentContextIds[0];
  }
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const names = [];
    for (let i2 = 0; i2 < this.contexts.length - 1; i2++) {
      const contexts2 = this.contexts.slice(0, this.contexts.length - i2);
      names.push(this.contextIdforContexts(contexts2));
    }
    names.push("");
    this._currentContextIds = names;
  }
  contextIdforContexts(contexts2) {
    return contexts2 ? contexts2.map((context) => context.id === 0 && context.iterationId === 0 ? "" : `${context.frameName}-${context.iterationId}`).join("/") : "";
  }
  enterFrame(frameId) {
    if (this.contexts) {
      this.lastId++;
      this.contexts = this.contexts.slice();
      this.contexts.push(this.newFrame(this.lastId, frameId));
      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
    }
  }
  exitFrame() {
    if (this.contexts && this.contexts.length > 1) {
      this.contexts = this.contexts.slice();
      this.contexts.splice(-1);
      this.currentContextIds.shift();
    } else {
      throw new Error("Cannot exit frame, the context is empty");
    }
  }
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice();
      this.lastId++;
      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);
      context.iterationId += 1;
      context.id = this.lastId;
      this.contexts.splice(-1, 1, context);
      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else {
      throw new Error("Cannot increase frame iteration, the context is empty");
    }
  }
  getWeight(name) {
    return this.weightMap[name];
  }
  addTensorArray(tensorArray) {
    this.tensorArrayMap[tensorArray.id] = tensorArray;
  }
  getTensorArray(id) {
    return this.tensorArrayMap[id];
  }
  addTensorList(tensorList) {
    this.tensorListMap[tensorList.id] = tensorList;
  }
  getTensorList(id) {
    return this.tensorListMap[id];
  }
  dispose(keepIds) {
    for (const key in this.tensorArrayMap) {
      this.tensorArrayMap[key].clearAndClose(keepIds);
    }
    for (const key in this.tensorListMap) {
      this.tensorListMap[key].clearAndClose(keepIds);
    }
  }
};
function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
  const usedNodes = new Set();
  const missingInputs = [];
  let dynamicNode = null;
  let syncInputs = null;
  const seen = new Set();
  const inputNodeNames = Object.keys(inputs).map((name) => parseNodeName(name)[0]);
  let initNodeNames = [];
  if (initNodes != null) {
    initNodeNames = initNodes.map((node2) => parseNodeName(node2.name)[0]);
  }
  const frontier = [...outputs];
  while (frontier.length > 0) {
    const node2 = frontier.pop();
    if (isControlFlow(node2) || isDynamicShape(node2) || isHashTable(node2)) {
      if (dynamicNode == null) {
        dynamicNode = node2;
        syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
      }
    }
    usedNodes.add(node2.name);
    if (weightMap[node2.name] != null) {
      continue;
    }
    if (inputNodeNames.indexOf(node2.name) !== -1) {
      continue;
    }
    if (initNodeNames.indexOf(node2.name) !== -1) {
      continue;
    }
    if (node2.inputs.length === 0) {
      missingInputs.push(node2.name);
      continue;
    }
    node2.inputs.forEach((input2) => {
      if (seen.has(input2.name)) {
        return;
      }
      seen.add(input2.name);
      frontier.push(input2);
    });
  }
  return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
}
function getNodesInTopologicalOrder(graph2, weightMap, executionInfo) {
  const { usedNodes, inputs } = executionInfo;
  const frontier = [];
  const inputNodes = Object.keys(inputs).map((name) => parseNodeName(name)[0]).map((name) => graph2.nodes[name]);
  const initNodes = graph2.initNodes;
  inputNodes.forEach((input2) => {
    if (usedNodes.has(input2.name)) {
      frontier.push(input2);
    }
  });
  graph2.weights.forEach((weight) => {
    if (usedNodes.has(weight.name)) {
      frontier.push(weight);
    }
  });
  if (initNodes != null) {
    initNodes.forEach((node2) => {
      if (usedNodes.has(node2.name)) {
        frontier.push(node2);
      }
    });
  }
  const seen = new Set();
  const orderedNodes = [];
  while (frontier.length > 0) {
    const node2 = frontier.pop();
    seen.add(node2.name);
    if (!weightMap[node2.name]) {
      orderedNodes.push(node2);
    }
    node2.children.forEach((child) => {
      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every((input2) => seen.has(input2.name))) {
        frontier.push(child);
      }
    });
  }
  return orderedNodes;
}
var CONTROL_FLOW_OPS = [
  "Switch",
  "Merge",
  "Enter",
  "Exit",
  "NextIteration",
  "StatelessIf",
  "StatelessWhile",
  "if",
  "While"
];
var DYNAMIC_SHAPE_OPS = [
  "NonMaxSuppressionV2",
  "NonMaxSuppressionV3",
  "NonMaxSuppressionV5",
  "Where"
];
var HASH_TABLE_OPS = [
  "HashTable",
  "HashTableV2",
  "LookupTableImport",
  "LookupTableImportV2",
  "LookupTableFind",
  "LookupTableFindV2",
  "LookupTableSize",
  "LookupTableSizeV2"
];
function isControlFlow(node2) {
  return CONTROL_FLOW_OPS.indexOf(node2.op) >= 0;
}
function isDynamicShape(node2) {
  return DYNAMIC_SHAPE_OPS.indexOf(node2.op) >= 0;
}
function isHashTable(node2) {
  return HASH_TABLE_OPS.indexOf(node2.op) >= 0;
}
var GraphExecutor = class {
  constructor(graph2, parent) {
    this.graph = graph2;
    this.parent = parent;
    this.compiledMap = new Map();
    this._weightMap = {};
    this.SEPERATOR = ",";
    this._functions = {};
    this._functionExecutorMap = {};
    this._outputs = graph2.outputs;
    this._inputs = graph2.inputs;
    this._initNodes = graph2.initNodes;
    this._signature = graph2.signature;
    this._functions = graph2.functions;
    if (graph2.functions != null) {
      Object.keys(graph2.functions).forEach((name) => {
        this._functionExecutorMap[name] = new GraphExecutor(graph2.functions[name], this);
      });
    }
  }
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(weightMap) {
    const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor2) => tensor2.id));
    this._weightIds = [].concat(...weightIds);
    this._weightMap = weightMap;
  }
  set resourceManager(resourceManager) {
    this._resourceManager = resourceManager;
  }
  get inputs() {
    return this._inputs.map((node2) => {
      return {
        name: node2.name,
        shape: node2.attrParams["shape"] ? node2.attrParams["shape"].value : void 0,
        dtype: node2.attrParams["dtype"] ? node2.attrParams["dtype"].value : void 0
      };
    });
  }
  get outputs() {
    return this._outputs.map((node2) => {
      return {
        name: node2.name,
        shape: node2.attrParams["shape"] ? node2.attrParams["shape"].value : void 0,
        dtype: node2.attrParams["dtype"] ? node2.attrParams["dtype"].value : void 0
      };
    });
  }
  get inputNodes() {
    return this._inputs.map((node2) => node2.signatureKey || node2.name);
  }
  get outputNodes() {
    return this._outputs.map((node2) => {
      const name = node2.signatureKey || node2.name;
      return node2.defaultOutput ? `${name}:${node2.defaultOutput}` : name;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((map, key) => {
      map[key] = this._functions[key].signature;
      return map;
    }, {});
  }
  getCompilationKey(inputs, outputs) {
    const sortedInputs = inputs.map((node2) => node2.name).sort();
    const sortedOutputs = outputs.map((node2) => node2.name).sort();
    return sortedInputs.join(this.SEPERATOR) + "--" + sortedOutputs.join(this.SEPERATOR);
  }
  compile(inputs, outputs) {
    const executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
    const { missingInputs, dynamicNode, syncInputs } = executionInfo;
    if (dynamicNode != null) {
      throw new Error(`This execution contains the node '${dynamicNode.name}', which has the dynamic op '${dynamicNode.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${syncInputs}]`);
    }
    if (missingInputs.length > 0) {
      const outNames = outputs.map((n2) => n2.name);
      const inNames = Object.keys(inputs);
      throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs [${inNames}]. Missing the following inputs: [${missingInputs}]`);
    }
    return getNodesInTopologicalOrder(this.graph, this.weightMap, executionInfo);
  }
  execute(inputs, outputs) {
    inputs = this.mapInputs(inputs);
    const names = Object.keys(inputs).sort();
    this.checkInputs(inputs);
    this.checkInputShapeAndType(inputs);
    outputs = this.mapOutputs(outputs);
    this.checkOutputs(outputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputs.map((name) => parseNodeName(name)[0]);
    let outputNodes2 = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes2.length === 0) {
      outputNodes2 = this._outputs;
    }
    const compilationKey = this.getCompilationKey(inputNodes, outputNodes2);
    let orderedNodes = this.compiledMap.get(compilationKey);
    if (orderedNodes == null) {
      orderedNodes = this.compile(inputs, outputNodes2);
      this.compiledMap.set(compilationKey, orderedNodes);
    }
    const tensorArrayMap = {};
    const tensorListMap = {};
    return tidy(() => {
      const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
      const tensorsMap = Object.assign({}, this.weightMap);
      Object.keys(inputs).forEach((name) => {
        const [nodeName, index] = parseNodeName(name);
        const tensors = [];
        tensors[index] = inputs[name];
        tensorsMap[nodeName] = tensors;
      });
      const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
      const intermediateTensorConsumerCount = {};
      for (let i2 = 0; i2 < orderedNodes.length; i2++) {
        const node2 = orderedNodes[i2];
        if (!tensorsMap[node2.name]) {
          const tensors = executeOp20(node2, tensorsMap, context, this._resourceManager);
          if (util_exports.isPromise(tensors)) {
            throw new Error(`The execution of the op '${node2.op}' returned a promise. Please use model.executeAsync() instead.`);
          }
          tensorsMap[node2.name] = tensors;
          this.checkTensorForDisposal(node2.name, node2, tensorsMap, context, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount);
        }
      }
      if (this.parent == null) {
        context.dispose(tensorsToKeep);
      }
      return outputs.map((name) => getTensor(name, tensorsMap, context));
    });
  }
  getFrozenTensorIds(tensorMap) {
    const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor2) => tensor2.id)));
    return new Set(ids);
  }
  checkTensorForDisposal(nodeName, node2, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {
    if (node2.category === "control" || outputNames.indexOf(nodeName) !== -1) {
      return;
    }
    tensorMap[nodeName].forEach((tensor2) => {
      if (tensor2 != null) {
        intermediateTensorConsumerCount[tensor2.id] = (intermediateTensorConsumerCount[tensor2.id] || 0) + node2.children.length;
      }
    });
    node2.inputs.forEach((input2) => {
      if (input2.category !== "control") {
        const tensors = getTensorsForCurrentContenxt(input2.name, tensorMap, context);
        if (tensors != null) {
          tensors.forEach((tensor2) => {
            if (tensor2 && !tensor2.kept && !tensorsToKeep.has(tensor2.id)) {
              const count22 = intermediateTensorConsumerCount[tensor2.id];
              if (count22 === 1) {
                tensor2.dispose();
                delete intermediateTensorConsumerCount[tensor2.id];
              } else if (count22 != null) {
                intermediateTensorConsumerCount[tensor2.id]--;
              }
            }
          });
        }
      }
    });
  }
  async executeAsync(inputs, outputs) {
    return this._executeAsync(inputs, outputs);
  }
  async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
    if (!isFunctionExecution) {
      inputs = this.mapInputs(inputs);
      this.checkInputs(inputs);
      this.checkInputShapeAndType(inputs);
      outputs = this.mapOutputs(outputs);
      this.checkOutputs(outputs);
    }
    const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
    const tensorMap = await this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution);
    const results = outputs.map((name) => getTensor(name, tensorMap, context));
    const outputIds = results.map((t2) => t2.id);
    const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
    const keepIds = new Set([...outputIds, ...inputIds, ...this.weightIds]);
    Object.keys(tensorMap).forEach((key) => {
      const tensorArray = tensorMap[key];
      tensorArray.forEach((tensor2) => {
        if (tensor2 && !tensor2.kept && !tensor2.isDisposed && !keepIds.has(tensor2.id)) {
          tensor2.dispose();
        }
      });
    });
    if (this.parent == null) {
      context.dispose(keepIds);
    }
    return results;
  }
  async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
    const mappedInputs = inputs.reduce((map, tensor2, index) => {
      map[this.inputs[index].name] = tensor2;
      return map;
    }, {});
    return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
  }
  async executeWithControlFlow(inputs, context, outputNames, isFunctionExecution) {
    const names = Object.keys(inputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputNames.map((name) => parseNodeName(name)[0]);
    let outputNodes2 = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes2.length === 0) {
      outputNodes2 = this._outputs;
    }
    const { usedNodes, missingInputs, dynamicNode, syncInputs } = getExecutionSubgraph(inputs, outputNodes2, this.weightMap, this._initNodes);
    const stack2 = [
      ...inputNodes,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((node2) => {
      return { node: node2, contexts: context.currentContext };
    });
    const tensorsMap = Object.assign({}, this.weightMap);
    Object.keys(inputs).forEach((name) => {
      const [nodeName, index] = parseNodeName(name);
      const tensors = [];
      tensors[index] = inputs[name];
      tensorsMap[nodeName] = tensors;
    });
    const intermediateTensorConsumerCount = {};
    const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
    const added = {};
    while (stack2.length > 0) {
      const promises = this.processStack(inputNodes, stack2, context, tensorsMap, added, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount, usedNodes);
      await Promise.all(promises);
    }
    if (dynamicNode == null && !isFunctionExecution) {
      console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);
    }
    const missingOutputs = outputNodes2.filter((node2) => !isControlFlow(node2) && !getTensor(node2.name, tensorsMap, context)).map((node2) => node2.name);
    if (missingOutputs.length > 0) {
      let alternativeMsg = "";
      if (dynamicNode != null) {
        alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${syncInputs}]`;
      }
      throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided inputs [${names}]. Consider providing the following inputs: [${missingInputs}]. ${alternativeMsg}`);
    }
    return tensorsMap;
  }
  processStack(inputNodes, stack2, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {
    const promises = [];
    while (stack2.length > 0) {
      const item = stack2.pop();
      context.currentContext = item.contexts;
      let nodeName = "";
      if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context)) {
        [nodeName] = getNodeNameAndIndex(item.node.name, context);
      }
      if (tensorMap[item.node.name] == null) {
        const tensors = executeOp20(item.node, tensorMap, context, this._resourceManager);
        if (!nodeName) {
          [nodeName] = getNodeNameAndIndex(item.node.name, context);
        }
        const currentContext = context.currentContext;
        if (util_exports.isPromise(tensors)) {
          promises.push(tensors.then((t2) => {
            tensorMap[nodeName] = t2;
            context.currentContext = currentContext;
            this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
            this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
            return t2;
          }));
        } else {
          tensorMap[nodeName] = tensors;
          this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
          this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
        }
      } else {
        this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
      }
    }
    return promises;
  }
  processChildNodes(node2, stack2, context, tensorMap, added, usedNodes) {
    node2.children.forEach((childNode) => {
      const [nodeName] = getNodeNameAndIndex(childNode.name, context);
      if (added[nodeName] || !usedNodes.has(childNode.name)) {
        return;
      }
      if (childNode.op === "Merge") {
        if (childNode.inputNames.some((name) => {
          return !!getTensor(name, tensorMap, context);
        })) {
          added[nodeName] = true;
          stack2.push({ contexts: context.currentContext, node: childNode });
        }
      } else if (childNode.inputNames.every((name) => {
        return !!getTensor(name, tensorMap, context);
      })) {
        added[nodeName] = true;
        stack2.push({ contexts: context.currentContext, node: childNode });
      }
    });
  }
  dispose() {
    Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor2) => tensor2.dispose()));
  }
  checkInputShapeAndType(inputs) {
    Object.keys(inputs).forEach((name) => {
      const input2 = inputs[name];
      const [nodeName] = parseNodeName(name);
      const node2 = this.graph.nodes[nodeName];
      if (node2.attrParams["shape"] && node2.attrParams["shape"].value) {
        const shape = node2.attrParams["shape"].value;
        const match4 = shape.length === input2.shape.length && input2.shape.every((dim, index) => shape[index] === -1 || shape[index] === dim);
        util_exports.assert(match4, () => `The shape of dict['${node2.name}'] provided in model.execute(dict) must be [${shape}], but was [${input2.shape}]`);
      }
      if (node2.attrParams["dtype"] && node2.attrParams["dtype"].value) {
        util_exports.assert(input2.dtype === node2.attrParams["dtype"].value, () => `The dtype of dict['${node2.name}'] provided in model.execute(dict) must be ${node2.attrParams["dtype"].value}, but was ${input2.dtype}`);
      }
    });
  }
  mapInputs(inputs) {
    const result = {};
    for (const inputName in inputs) {
      if (this._signature != null && this._signature.inputs != null && this._signature.inputs[inputName] != null) {
        const tensor2 = this._signature.inputs[inputName];
        result[tensor2.name] = inputs[inputName];
      } else {
        result[inputName] = inputs[inputName];
      }
    }
    return result;
  }
  checkInputs(inputs) {
    const notInGraph = Object.keys(inputs).filter((name) => {
      const [nodeName] = parseNodeName(name);
      return this.graph.nodes[nodeName] == null;
    });
    if (notInGraph.length > 0) {
      throw new Error(`The dict provided in model.execute(dict) has keys: [${notInGraph}] that are not part of graph`);
    }
  }
  mapOutputs(outputs) {
    return outputs.map((name) => {
      if (this._signature != null && this._signature.outputs != null && this._signature.outputs[name] != null) {
        const tensor2 = this._signature.outputs[name];
        return tensor2.name;
      }
      return name;
    }, {});
  }
  checkOutputs(outputs) {
    outputs.forEach((name) => {
      const [normalizedName] = parseNodeName(name);
      if (!this.graph.nodes[normalizedName]) {
        throw new Error(`The output '${name}' is not found in the graph`);
      }
    });
  }
};
var ResourceManager = class {
  constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
    this.hashTableNameToHandle = hashTableNameToHandle;
    this.hashTableMap = hashTableMap;
  }
  addHashTable(name, hashTable2) {
    this.hashTableNameToHandle[name] = hashTable2.handle;
    this.hashTableMap[hashTable2.id] = hashTable2;
  }
  getHashTableHandleByName(name) {
    return this.hashTableNameToHandle[name];
  }
  getHashTableById(id) {
    return this.hashTableMap[id];
  }
  dispose() {
    for (const key in this.hashTableMap) {
      this.hashTableMap[key].clearAndClose();
      delete this.hashTableMap[key];
    }
    for (const name in this.hashTableNameToHandle) {
      this.hashTableNameToHandle[name].dispose();
      delete this.hashTableNameToHandle[name];
    }
  }
};
var TFHUB_SEARCH_PARAM = "?tfjs-format=file";
var DEFAULT_MODEL_NAME = "model.json";
var GraphModel = class {
  constructor(modelUrl, loadOptions = {}) {
    this.modelUrl = modelUrl;
    this.loadOptions = loadOptions;
    this.version = "n/a";
    if (loadOptions == null) {
      this.loadOptions = {};
    }
    this.resourceManager = new ResourceManager();
  }
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  findIOHandler() {
    const path = this.modelUrl;
    if (path.load != null) {
      this.handler = path;
    } else if (this.loadOptions.requestInit != null) {
      this.handler = io_exports.browserHTTPRequest(path, this.loadOptions);
    } else {
      const handlers = io_exports.getLoadHandlers(path, this.loadOptions);
      if (handlers.length === 0) {
        handlers.push(io_exports.browserHTTPRequest(path, this.loadOptions));
      } else if (handlers.length > 1) {
        throw new Error(`Found more than one (${handlers.length}) load handlers for URL '${[path]}'`);
      }
      this.handler = handlers[0];
    }
  }
  async load() {
    this.findIOHandler();
    if (this.handler.load == null) {
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    }
    const artifacts = await this.handler.load();
    return this.loadSync(artifacts);
  }
  loadSync(artifacts) {
    this.artifacts = artifacts;
    const graph2 = this.artifacts.modelTopology;
    let signature;
    if (this.artifacts.userDefinedMetadata != null && this.artifacts.userDefinedMetadata.signature != null) {
      signature = this.artifacts.userDefinedMetadata.signature;
    } else {
      signature = this.artifacts.signature;
    }
    this.signature = signature;
    this.version = `${graph2.versions.producer}.${graph2.versions.minConsumer}`;
    const weightMap = io_exports.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
    this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph2, this.signature));
    this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
    this.executor.resourceManager = this.resourceManager;
    if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
      const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
      this.initializer = new GraphExecutor(initializer);
      this.initializer.weightMap = this.executor.weightMap;
      this.initializer.resourceManager = this.resourceManager;
      this.initializer.executeAsync({}, []);
    }
    return true;
  }
  async save(handlerOrURL, config3) {
    if (typeof handlerOrURL === "string") {
      const handlers = io_exports.getSaveHandlers(handlerOrURL);
      if (handlers.length === 0) {
        throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
      } else if (handlers.length > 1) {
        throw new Error(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
      }
      handlerOrURL = handlers[0];
    }
    if (handlerOrURL.save == null) {
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    }
    return handlerOrURL.save(this.artifacts);
  }
  predict(inputs, config3) {
    return this.execute(inputs, this.outputNodes);
  }
  normalizeInputs(inputs) {
    if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
      return inputs;
    }
    inputs = Array.isArray(inputs) ? inputs : [inputs];
    if (inputs.length !== this.inputNodes.length) {
      throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${inputs.length} input tensors.`);
    }
    return this.inputNodes.reduce((map, inputName, i2) => {
      map[inputName] = inputs[i2];
      return map;
    }, {});
  }
  normalizeOutputs(outputs) {
    outputs = outputs || this.outputNodes;
    return !Array.isArray(outputs) ? [outputs] : outputs;
  }
  execute(inputs, outputs) {
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = this.executor.execute(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  async executeAsync(inputs, outputs) {
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = await this.executor.executeAsync(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  convertTensorMapToTensorsMap(map) {
    return Object.keys(map).reduce((newMap, key) => {
      newMap[key] = [map[key]];
      return newMap;
    }, {});
  }
  dispose() {
    this.executor.dispose();
    if (this.initializer) {
      this.initializer.dispose();
    }
    this.resourceManager.dispose();
  }
};
async function loadGraphModel(modelUrl, options3 = {}) {
  if (modelUrl == null) {
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  }
  if (options3 == null) {
    options3 = {};
  }
  if (options3.fromTFHub) {
    if (modelUrl.load == null) {
      if (!modelUrl.endsWith("/")) {
        modelUrl = modelUrl + "/";
      }
      modelUrl = `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
    }
  }
  const model22 = new GraphModel(modelUrl, options3);
  await model22.load();
  return model22;
}
var version3 = "3.9.0";
var dist_exports = {};
__export2(dist_exports, {
  CSVDataset: () => CSVDataset,
  Dataset: () => Dataset,
  FileDataSource: () => FileDataSource,
  TextLineDataset: () => TextLineDataset,
  URLDataSource: () => URLDataSource,
  array: () => array,
  csv: () => csv,
  func: () => func,
  generator: () => generator,
  microphone: () => microphone,
  version_data: () => version4,
  webcam: () => webcam,
  zip: () => zip
});
var seedrandom3 = __toModule(require_seedrandom4());
var seedrandom2 = __toModule(require_seedrandom4());
function deepMap(input2, mapFn) {
  return deepMapInternal(input2, mapFn);
}
function deepMapInternal(input2, mapFn, seen = new Map(), containedIn = new Set()) {
  if (input2 == null) {
    return null;
  }
  if (containedIn.has(input2)) {
    throw new Error("Circular references are not supported.");
  }
  if (seen.has(input2)) {
    return seen.get(input2);
  }
  const result = mapFn(input2);
  if (result.recurse && result.value !== null) {
    throw new Error("A deep map function may not return both a value and recurse=true.");
  }
  if (!result.recurse) {
    seen.set(input2, result.value);
    return result.value;
  } else if (isIterable2(input2)) {
    const mappedIterable = Array.isArray(input2) ? [] : {};
    containedIn.add(input2);
    for (const k3 in input2) {
      const child = input2[k3];
      const childResult = deepMapInternal(child, mapFn, seen, containedIn);
      mappedIterable[k3] = childResult;
    }
    containedIn.delete(input2);
    return mappedIterable;
  } else {
    throw new Error(`Can't recurse into non-iterable type: ${input2}`);
  }
}
function deepZip(inputs, zipFn = zipToList) {
  return deepZipInternal(inputs, zipFn);
}
function deepZipInternal(inputs, zipFn, containedIn = new Set()) {
  const input2 = inputs[0];
  if (containedIn.has(input2)) {
    throw new Error("Circular references are not supported.");
  }
  const result = zipFn(inputs);
  if (result.recurse && result.value !== null) {
    throw new Error("A deep zip function may not return both a value and recurse=true.");
  }
  if (!result.recurse) {
    return result.value;
  } else if (isIterable2(input2)) {
    const mappedIterable = Array.isArray(input2) ? [] : {};
    containedIn.add(input2);
    for (const k3 in input2) {
      const children = inputs.map((x2) => x2[k3]);
      const childResult = deepZipInternal(children, zipFn, containedIn);
      mappedIterable[k3] = childResult;
    }
    containedIn.delete(input2);
    return mappedIterable;
  } else {
    throw new Error(`Can't recurse into non-iterable type: ${input2}`);
  }
}
function zipToList(x2) {
  if (x2 === null) {
    return null;
  }
  if (isIterable2(x2[0])) {
    return { value: null, recurse: true };
  } else {
    return { value: x2, recurse: false };
  }
}
async function deepMapAndAwaitAll(input2, mapFn) {
  const seen = new Map();
  deepMapInternal(input2, mapFn, seen);
  for (const key of Array.from(seen.keys())) {
    const value = seen.get(key);
    if (util_exports.isPromise(value)) {
      const mappedValue = await value;
      seen.set(key, mappedValue);
    }
  }
  const result = deepMapInternal(input2, mapFn, seen);
  return result;
}
function isIterable2(obj) {
  let isTextDecoder = false;
  if (env().get("IS_BROWSER")) {
    isTextDecoder = obj instanceof TextDecoder;
  } else {
    const { StringDecoder } = require_string_decoder();
    isTextDecoder = obj instanceof StringDecoder;
  }
  return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === "object" && !(obj instanceof Tensor) && !(obj instanceof Promise) && !isTextDecoder);
}
function canTensorify(obj) {
  return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === "object" && obj instanceof Tensor || util_exports.isTypedArray(obj);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function deepClone(container) {
  return deepMap(container, cloneIfTensor);
}
function cloneIfTensor(item) {
  if (item instanceof Tensor) {
    return { value: item.clone(), recurse: false };
  } else if (isIterable2(item)) {
    return { value: null, recurse: true };
  } else {
    return { value: item, recurse: false };
  }
}
var RingBuffer = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.begin = 0;
    this.end = 0;
    if (capacity == null) {
      throw new RangeError("Can't create a ring buffer of unknown capacity.");
    }
    if (capacity < 1) {
      throw new RangeError("Can't create ring buffer of capacity < 1.");
    }
    this.data = new Array(capacity);
    this.doubledCapacity = 2 * capacity;
  }
  wrap(index) {
    while (index < 0) {
      index += this.doubledCapacity;
    }
    return index % this.doubledCapacity;
  }
  get(index) {
    if (index < 0) {
      throw new RangeError("Can't get item at a negative index.");
    }
    return this.data[index % this.capacity];
  }
  set(index, value) {
    if (index < 0) {
      throw new RangeError("Can't set item at a negative index.");
    }
    this.data[index % this.capacity] = value;
  }
  length() {
    let length = this.end - this.begin;
    if (length < 0) {
      length = this.doubledCapacity + length;
    }
    return length;
  }
  isFull() {
    return this.length() === this.capacity;
  }
  isEmpty() {
    return this.length() === 0;
  }
  push(value) {
    if (this.isFull()) {
      throw new RangeError("Ring buffer is full.");
    }
    this.set(this.end, value);
    this.end = this.wrap(this.end + 1);
  }
  pushAll(values) {
    for (const value of values) {
      this.push(value);
    }
  }
  pop() {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    this.end = this.wrap(this.end - 1);
    const result = this.get(this.end);
    this.set(this.end, void 0);
    return result;
  }
  unshift(value) {
    if (this.isFull()) {
      throw new RangeError("Ring buffer is full.");
    }
    this.begin = this.wrap(this.begin - 1);
    this.set(this.begin, value);
  }
  shift() {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    const result = this.get(this.begin);
    this.set(this.begin, void 0);
    this.begin = this.wrap(this.begin + 1);
    return result;
  }
  shuffleExcise(relativeIndex) {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    const index = this.wrap(this.begin + relativeIndex);
    const result = this.get(index);
    this.set(index, this.pop());
    return result;
  }
};
var GrowingRingBuffer = class extends RingBuffer {
  constructor() {
    super(GrowingRingBuffer.INITIAL_CAPACITY);
  }
  isFull() {
    return false;
  }
  push(value) {
    if (super.isFull()) {
      this.expand();
    }
    super.push(value);
  }
  unshift(value) {
    if (super.isFull()) {
      this.expand();
    }
    super.unshift(value);
  }
  expand() {
    const newCapacity = this.capacity * 2;
    const newData = new Array(newCapacity);
    const len = this.length();
    for (let i2 = 0; i2 < len; i2++) {
      newData[i2] = this.get(this.wrap(this.begin + i2));
    }
    this.data = newData;
    this.capacity = newCapacity;
    this.doubledCapacity = 2 * this.capacity;
    this.begin = 0;
    this.end = len;
  }
};
GrowingRingBuffer.INITIAL_CAPACITY = 32;
function iteratorFromItems(items) {
  return new ArrayIterator(items);
}
function iteratorFromFunction(func2) {
  return new FunctionCallIterator(func2);
}
function iteratorFromConcatenated(baseIterators, baseErrorHandler) {
  return new ChainedIterator(baseIterators, baseErrorHandler);
}
function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {
  return new ZipIterator(iterators, mismatchMode);
}
var LazyIterator = class {
  async toArray() {
    const result = [];
    let x2 = await this.next();
    while (!x2.done) {
      result.push(x2.value);
      x2 = await this.next();
    }
    return result;
  }
  async toArrayForTest() {
    const stream = this.prefetch(100);
    const result = [];
    let x2 = await stream.next();
    while (!x2.done) {
      result.push(x2.value);
      x2 = await stream.next();
    }
    return result;
  }
  async resolveFully() {
    let x2 = await this.next();
    while (!x2.done) {
      x2 = await this.next();
    }
  }
  async resolveWhile(predicate) {
    let x2 = await this.next();
    let shouldContinue = predicate(x2.value);
    while (!x2.done && shouldContinue) {
      x2 = await this.next();
      shouldContinue = predicate(x2.value);
    }
  }
  handleErrors(handler) {
    return new ErrorHandlingLazyIterator(this, handler);
  }
  filter(predicate) {
    return new FilterIterator(this, predicate);
  }
  map(transform6) {
    return new MapIterator(this, transform6);
  }
  mapAsync(transform6) {
    return new AsyncMapIterator(this, transform6);
  }
  serialMapAsync(transform6) {
    return new AsyncMapIterator(this, transform6).serial();
  }
  flatmap(transform6) {
    return new FlatmapIterator(this, transform6);
  }
  async forEachAsync(f2) {
    return this.map(f2).resolveFully();
  }
  async serialForEach(f2) {
    return this.serialMapAsync(f2).resolveWhile((x2) => x2 === true);
  }
  rowMajorBatch(batchSize, smallLastBatch = true) {
    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);
  }
  columnMajorBatch(batchSize, smallLastBatch = true, zipFn = zipToList) {
    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);
    return rowBatches.map((x2) => deepZip(x2, zipFn));
  }
  concatenate(iterator, baseErrorHandler) {
    return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);
  }
  take(count22) {
    if (count22 < 0 || count22 == null) {
      return this;
    }
    return new TakeIterator(this, count22);
  }
  skip(count22) {
    if (count22 < 0 || count22 == null) {
      return this;
    }
    return new SkipIterator(this, count22);
  }
  prefetch(bufferSize) {
    return new PrefetchIterator(this, bufferSize);
  }
  shuffle(windowSize, seed) {
    return new ShuffleIterator(this, windowSize, seed);
  }
  serial() {
    return new SerialIterator(this);
  }
};
var ArrayIterator = class extends LazyIterator {
  constructor(items) {
    super();
    this.items = items;
    this.trav = 0;
  }
  summary() {
    return `Array of ${this.items.length} items`;
  }
  async next() {
    if (this.trav >= this.items.length) {
      return { value: null, done: true };
    }
    const item = this.items[this.trav];
    this.trav++;
    return { value: deepClone(item), done: false };
  }
};
var FunctionCallIterator = class extends LazyIterator {
  constructor(nextFn) {
    super();
    this.nextFn = nextFn;
  }
  summary() {
    return `Function call`;
  }
  async next() {
    try {
      return this.nextFn();
    } catch (e2) {
      e2.message = `Error thrown while iterating through a dataset: ${e2.message}`;
      throw e2;
    }
  }
};
var SerialIterator = class extends LazyIterator {
  constructor(upstream) {
    super();
    this.upstream = upstream;
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Serial`;
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    return this.upstream.next();
  }
};
var SkipIterator = class extends LazyIterator {
  constructor(upstream, maxCount) {
    super();
    this.upstream = upstream;
    this.maxCount = maxCount;
    this.count = 0;
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Skip`;
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    while (this.count++ < this.maxCount) {
      const skipped11 = await this.upstream.next();
      if (skipped11.done) {
        return skipped11;
      }
      dispose(skipped11.value);
    }
    return this.upstream.next();
  }
};
var TakeIterator = class extends LazyIterator {
  constructor(upstream, maxCount) {
    super();
    this.upstream = upstream;
    this.maxCount = maxCount;
    this.count = 0;
  }
  summary() {
    return `${this.upstream.summary()} -> Take`;
  }
  async next() {
    if (this.count++ >= this.maxCount) {
      return { value: null, done: true };
    }
    return this.upstream.next();
  }
};
var RowMajorBatchIterator = class extends LazyIterator {
  constructor(upstream, batchSize, enableSmallLastBatch = true) {
    super();
    this.upstream = upstream;
    this.batchSize = batchSize;
    this.enableSmallLastBatch = enableSmallLastBatch;
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> RowMajorBatch`;
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    const batch = [];
    while (batch.length < this.batchSize) {
      const item = await this.upstream.next();
      if (item.done) {
        if (this.enableSmallLastBatch && batch.length > 0) {
          return { value: batch, done: false };
        }
        return { value: null, done: true };
      }
      batch.push(item.value);
    }
    return { value: batch, done: false };
  }
};
var FilterIterator = class extends LazyIterator {
  constructor(upstream, predicate) {
    super();
    this.upstream = upstream;
    this.predicate = predicate;
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Filter`;
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    while (true) {
      const item = await this.upstream.next();
      if (item.done || this.predicate(item.value)) {
        return item;
      }
      dispose(item.value);
    }
  }
};
var MapIterator = class extends LazyIterator {
  constructor(upstream, transform6) {
    super();
    this.upstream = upstream;
    this.transform = transform6;
  }
  summary() {
    return `${this.upstream.summary()} -> Map`;
  }
  async next() {
    const item = await this.upstream.next();
    if (item.done) {
      return { value: null, done: true };
    }
    const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
    const mapped = this.transform(item.value);
    const outputTensors = tensor_util_exports.getTensorsInContainer(mapped);
    for (const t2 of inputTensors) {
      if (!tensor_util_exports.isTensorInList(t2, outputTensors)) {
        t2.dispose();
      }
    }
    return { value: mapped, done: false };
  }
};
var ErrorHandlingLazyIterator = class extends LazyIterator {
  constructor(upstream, handler) {
    super();
    this.upstream = upstream;
    this.handler = handler;
    this.count = 0;
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> handleErrors`;
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    while (true) {
      try {
        return await this.upstream.next();
      } catch (e2) {
        if (!this.handler(e2)) {
          return { value: null, done: true };
        }
      }
    }
  }
};
var AsyncMapIterator = class extends LazyIterator {
  constructor(upstream, transform6) {
    super();
    this.upstream = upstream;
    this.transform = transform6;
  }
  summary() {
    return `${this.upstream.summary()} -> AsyncMap`;
  }
  async next() {
    const item = await this.upstream.next();
    if (item.done) {
      return { value: null, done: true };
    }
    const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
    const mapped = await this.transform(item.value);
    const outputTensors = tensor_util_exports.getTensorsInContainer(mapped);
    for (const t2 of inputTensors) {
      if (!tensor_util_exports.isTensorInList(t2, outputTensors)) {
        t2.dispose();
      }
    }
    return { value: mapped, done: false };
  }
};
var OneToManyIterator = class extends LazyIterator {
  constructor() {
    super();
    this.outputQueue = new GrowingRingBuffer();
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  async serialNext() {
    while (this.outputQueue.length() === 0) {
      if (!await this.pump()) {
        return { value: null, done: true };
      }
    }
    return { value: this.outputQueue.shift(), done: false };
  }
};
var FlatmapIterator = class extends OneToManyIterator {
  constructor(upstream, transform6) {
    super();
    this.upstream = upstream;
    this.transform = transform6;
  }
  summary() {
    return `${this.upstream.summary()} -> Flatmap`;
  }
  async pump() {
    const item = await this.upstream.next();
    if (item.done) {
      return false;
    }
    const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
    const mappedArray = this.transform(item.value);
    const outputTensors = tensor_util_exports.getTensorsInContainer(mappedArray);
    this.outputQueue.pushAll(mappedArray);
    for (const t2 of inputTensors) {
      if (!tensor_util_exports.isTensorInList(t2, outputTensors)) {
        t2.dispose();
      }
    }
    return true;
  }
};
var ChainedIterator = class extends LazyIterator {
  constructor(iterators, baseErrorHandler) {
    super();
    this.baseErrorHandler = baseErrorHandler;
    this.lastRead = null;
    this.iterator = null;
    this.moreIterators = iterators;
  }
  summary() {
    const upstreamSummaries = "TODO: fill in upstream of chained summaries";
    return `${upstreamSummaries} -> Chained`;
  }
  async next() {
    this.lastRead = this.readFromChain(this.lastRead);
    return this.lastRead;
  }
  async readFromChain(lastRead) {
    await lastRead;
    if (this.iterator == null) {
      const iteratorResult = await this.moreIterators.next();
      if (iteratorResult.done) {
        return { value: null, done: true };
      }
      this.iterator = iteratorResult.value;
      if (this.baseErrorHandler != null) {
        this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
      }
    }
    const itemResult = await this.iterator.next();
    if (itemResult.done) {
      this.iterator = null;
      return this.readFromChain(lastRead);
    }
    return itemResult;
  }
};
var ZipMismatchMode;
(function(ZipMismatchMode2) {
  ZipMismatchMode2[ZipMismatchMode2["FAIL"] = 0] = "FAIL";
  ZipMismatchMode2[ZipMismatchMode2["SHORTEST"] = 1] = "SHORTEST";
  ZipMismatchMode2[ZipMismatchMode2["LONGEST"] = 2] = "LONGEST";
})(ZipMismatchMode || (ZipMismatchMode = {}));
var ZipIterator = class extends LazyIterator {
  constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {
    super();
    this.iterators = iterators;
    this.mismatchMode = mismatchMode;
    this.count = 0;
    this.currentPromise = null;
  }
  summary() {
    const upstreamSummaries = "TODO: fill in upstream of zip summaries";
    return `{${upstreamSummaries}} -> Zip`;
  }
  async nextState(afterState) {
    await afterState;
    let numIterators = 0;
    let iteratorsDone = 0;
    function getNext(container) {
      if (container instanceof LazyIterator) {
        const result = container.next();
        return {
          value: result.then((x2) => {
            numIterators++;
            if (x2.done) {
              iteratorsDone++;
            }
            return x2.value;
          }),
          recurse: false
        };
      } else {
        return { value: null, recurse: true };
      }
    }
    const mapped = await deepMapAndAwaitAll(this.iterators, getNext);
    if (numIterators === iteratorsDone) {
      return { value: null, done: true };
    }
    if (iteratorsDone > 0) {
      switch (this.mismatchMode) {
        case ZipMismatchMode.FAIL:
          throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);
        case ZipMismatchMode.SHORTEST:
          return { value: null, done: true };
        case ZipMismatchMode.LONGEST:
        default:
      }
    }
    this.count++;
    return { value: mapped, done: false };
  }
  async next() {
    this.currentPromise = this.nextState(this.currentPromise);
    return this.currentPromise;
  }
};
var PrefetchIterator = class extends LazyIterator {
  constructor(upstream, bufferSize) {
    super();
    this.upstream = upstream;
    this.bufferSize = bufferSize;
    this.buffer = new RingBuffer(bufferSize);
  }
  summary() {
    return `${this.upstream.summary()} -> Prefetch`;
  }
  refill() {
    while (!this.buffer.isFull()) {
      const v2 = this.upstream.next();
      this.buffer.push(v2);
    }
  }
  next() {
    this.refill();
    return this.buffer.shift();
  }
};
var ShuffleIterator = class extends PrefetchIterator {
  constructor(upstream, windowSize, seed) {
    super(upstream, windowSize);
    this.upstream = upstream;
    this.windowSize = windowSize;
    this.upstreamExhausted = false;
    this.random = seedrandom2.alea(seed || util_exports.now().toString());
    this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    this.lastRead = this.lastRead.then(() => this.serialNext());
    return this.lastRead;
  }
  randomInt(max7) {
    return Math.floor(this.random() * max7);
  }
  chooseIndex() {
    return this.randomInt(this.buffer.length());
  }
  async serialNext() {
    if (!this.upstreamExhausted) {
      this.refill();
    }
    while (!this.buffer.isEmpty()) {
      const chosenIndex = this.chooseIndex();
      const result = await this.buffer.shuffleExcise(chosenIndex);
      if (result.done) {
        this.upstreamExhausted = true;
      } else {
        this.refill();
        return result;
      }
    }
    return { value: null, done: true };
  }
};
var Dataset = class {
  constructor() {
    this.size = null;
  }
  batch(batchSize, smallLastBatch = true) {
    const base2 = this;
    util_exports.assert(batchSize > 0, () => `batchSize needs to be positive, but it is
      ${batchSize}`);
    let size2;
    if (this.size === Infinity || this.size == null) {
      size2 = this.size;
    } else if (smallLastBatch) {
      size2 = Math.ceil(this.size / batchSize);
    } else {
      size2 = Math.floor(this.size / batchSize);
    }
    return datasetFromIteratorFn(async () => {
      return (await base2.iterator()).columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);
    }, size2);
  }
  concatenate(dataset) {
    const base2 = this;
    let size2;
    if (this.size === Infinity || dataset.size === Infinity) {
      size2 = Infinity;
    } else if (this.size != null && dataset.size != null) {
      size2 = this.size + dataset.size;
    } else {
      size2 = null;
    }
    return datasetFromIteratorFn(async () => (await base2.iterator()).concatenate(await dataset.iterator()), size2);
  }
  filter(predicate) {
    const base2 = this;
    let size2;
    if (this.size === Infinity) {
      size2 = Infinity;
    } else {
      size2 = null;
    }
    return datasetFromIteratorFn(async () => {
      return (await base2.iterator()).filter((x2) => tidy(() => predicate(x2)));
    }, size2);
  }
  async forEachAsync(f2) {
    return (await this.iterator()).forEachAsync(f2);
  }
  map(transform6) {
    const base2 = this;
    return datasetFromIteratorFn(async () => {
      return (await base2.iterator()).map((x2) => tidy(() => transform6(x2)));
    }, this.size);
  }
  mapAsync(transform6) {
    const base2 = this;
    return datasetFromIteratorFn(async () => {
      return (await base2.iterator()).mapAsync(transform6);
    }, this.size);
  }
  prefetch(bufferSize) {
    if (bufferSize == null) {
      throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    }
    const base2 = this;
    return datasetFromIteratorFn(async () => (await base2.iterator()).prefetch(bufferSize), this.size);
  }
  repeat(count22) {
    const base2 = this;
    let size2;
    if (this.size != null && count22 > 0) {
      size2 = this.size * count22;
    } else if (count22 === 0) {
      size2 = 0;
    } else if (this.size != null && (count22 === void 0 || count22 < 0)) {
      size2 = Infinity;
    } else {
      size2 = null;
    }
    return datasetFromIteratorFn(async () => {
      const iteratorIterator = iteratorFromFunction(async () => ({ value: await base2.iterator(), done: false }));
      return iteratorFromConcatenated(iteratorIterator.take(count22));
    }, size2);
  }
  skip(count22) {
    const base2 = this;
    let size2;
    if (this.size != null && count22 >= 0 && this.size >= count22) {
      size2 = this.size - count22;
    } else if (this.size != null && (this.size < count22 || count22 === void 0 || count22 < 0)) {
      size2 = 0;
    } else {
      size2 = null;
    }
    return datasetFromIteratorFn(async () => (await base2.iterator()).skip(count22), size2);
  }
  shuffle(bufferSize, seed, reshuffleEachIteration = true) {
    if (bufferSize == null || bufferSize < 0) {
      if (this.size == null) {
        throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");
      } else {
        throw new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
      }
    }
    const base2 = this;
    const random = seedrandom3.alea(seed || util_exports.now().toString());
    return datasetFromIteratorFn(async () => {
      let seed2 = random.int32();
      if (reshuffleEachIteration) {
        seed2 += random.int32();
      }
      return (await base2.iterator()).shuffle(bufferSize, seed2.toString());
    }, this.size);
  }
  take(count22) {
    const base2 = this;
    let size2;
    if (this.size != null && this.size > count22) {
      size2 = count22;
    } else if (this.size != null && this.size <= count22) {
      size2 = this.size;
    } else {
      size2 = null;
    }
    return datasetFromIteratorFn(async () => (await base2.iterator()).take(count22), size2);
  }
  async toArray() {
    if (this.size === Infinity) {
      throw new Error("Can not convert infinite data stream to array.");
    }
    return (await this.iterator()).toArray();
  }
  async toArrayForTest() {
    if (this.size === Infinity) {
      throw new Error("Can not convert infinite data stream to array.");
    }
    return (await this.iterator()).toArrayForTest();
  }
};
Dataset.MAX_BUFFER_SIZE = 1e4;
function datasetFromIteratorFn(iteratorFn, size2 = null) {
  return new class extends Dataset {
    constructor() {
      super(...arguments);
      this.size = size2;
    }
    async iterator() {
      return iteratorFn();
    }
  }();
}
function array(items) {
  return datasetFromIteratorFn(async () => iteratorFromItems(items), items.length);
}
function zip(datasets) {
  if (!isIterable2(datasets)) {
    throw new Error("The argument to zip() must be an object or array.");
  }
  let size2;
  if (Array.isArray(datasets)) {
    for (let i2 = 0; i2 < datasets.length; i2++) {
      size2 = size2 == null ? datasets[i2].size : Math.min(size2, datasets[i2].size);
    }
  } else if (datasets instanceof Object) {
    for (const ds in datasets) {
      size2 = size2 == null ? datasets[ds].size : Math.min(size2, datasets[ds].size);
    }
  }
  return datasetFromIteratorFn(async () => {
    const streams = await deepMapAndAwaitAll(datasets, (d2) => {
      if (d2 instanceof Dataset) {
        return { value: d2.iterator(), recurse: false };
      } else if (isIterable2(d2)) {
        return { value: null, recurse: true };
      } else {
        throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
      }
    });
    return iteratorFromZipped(streams, ZipMismatchMode.SHORTEST);
  }, size2);
}
function deepBatchConcat(rows) {
  if (rows === null) {
    return null;
  }
  const exampleRow = rows[0];
  if (canTensorify(exampleRow)) {
    const value = batchConcat(rows);
    return { value, recurse: false };
  }
  return { value: null, recurse: true };
}
function batchConcat(arrays) {
  if (arrays.length === 0) {
    throw new Error("Can't make a batch of zero elements.");
  }
  if (arrays[0] instanceof Tensor) {
    return stack(arrays);
  } else {
    return tensor(arrays);
  }
}
var TextLineDataset = class extends Dataset {
  constructor(input2) {
    super();
    this.input = input2;
  }
  async iterator() {
    const inputIterator = await this.input.iterator();
    const utf8Iterator = inputIterator.decodeUTF8();
    const lineIterator = utf8Iterator.split("\n").map((line) => {
      if (line.endsWith("\r")) {
        line = line.slice(0, -1);
      }
      return line;
    });
    return lineIterator;
  }
};
var CODE_QUOTE = '"';
var STATE_OUT = Symbol("out");
var STATE_FIELD = Symbol("field");
var STATE_QUOTE = Symbol("quote");
var STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote");
var STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote");
var CSVDataset = class extends Dataset {
  constructor(input2, csvConfig) {
    super();
    this.input = input2;
    this.hasHeader = true;
    this.fullColumnNames = null;
    this.columnNamesValidated = false;
    this.columnConfigs = null;
    this.configuredColumnsOnly = false;
    this.delimiter = ",";
    this.delimWhitespace = false;
    this.base = new TextLineDataset(input2);
    if (!csvConfig) {
      csvConfig = {};
    }
    this.hasHeader = csvConfig.hasHeader === false ? false : true;
    this.fullColumnNames = csvConfig.columnNames;
    this.columnConfigs = csvConfig.columnConfigs;
    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;
    if (csvConfig.delimWhitespace) {
      util_exports.assert(csvConfig.delimiter == null, () => "Delimiter should not be provided when delimWhitespace is true.");
      this.delimWhitespace = true;
      this.delimiter = " ";
    } else {
      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ",";
    }
  }
  async columnNames() {
    if (!this.columnNamesValidated) {
      await this.setColumnNames();
    }
    return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;
  }
  async setColumnNames() {
    const columnNamesFromFile = await this.maybeReadHeaderLine();
    if (!this.fullColumnNames && !columnNamesFromFile) {
      throw new Error("Column names must be provided if there is no header line.");
    } else if (this.fullColumnNames && columnNamesFromFile) {
      util_exports.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => "The length of provided columnNames (" + this.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + columnNamesFromFile.length.toString() + ").");
    }
    if (!this.fullColumnNames) {
      this.fullColumnNames = columnNamesFromFile;
    }
    const counts = this.fullColumnNames.reduce((countAcc, name) => {
      countAcc[name] = countAcc[name] + 1 || 1;
      return countAcc;
    }, {});
    const duplicateNames = Object.keys(counts).filter((name) => counts[name] > 1);
    util_exports.assert(duplicateNames.length === 0, () => "Duplicate column names found: " + duplicateNames.toString());
    if (this.columnConfigs) {
      for (const key of Object.keys(this.columnConfigs)) {
        const index = this.fullColumnNames.indexOf(key);
        if (index === -1) {
          throw new Error('The key "' + key + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
        }
      }
    }
    this.columnNamesValidated = true;
  }
  async maybeReadHeaderLine() {
    if (this.hasHeader) {
      const iter = await this.base.iterator();
      const firstElement = await iter.next();
      if (firstElement.done) {
        throw new Error("No data was found for CSV parsing.");
      }
      const firstLine = firstElement.value;
      const headers = this.parseRow(firstLine, false);
      return headers;
    } else {
      return null;
    }
  }
  async iterator() {
    if (!this.columnNamesValidated) {
      await this.setColumnNames();
    }
    let lines2 = await this.base.iterator();
    if (this.hasHeader) {
      lines2 = lines2.skip(1);
    }
    return lines2.map((x2) => this.makeDataElement(x2));
  }
  makeDataElement(line) {
    const values = this.parseRow(line);
    const features = {};
    const labels2 = {};
    for (let i2 = 0; i2 < this.fullColumnNames.length; i2++) {
      const key = this.fullColumnNames[i2];
      const config3 = this.columnConfigs ? this.columnConfigs[key] : null;
      if (this.configuredColumnsOnly && !config3) {
        continue;
      } else {
        const value = values[i2];
        let parsedValue = null;
        if (value === "") {
          if (config3 && config3.default !== void 0) {
            parsedValue = config3.default;
          } else if (config3 && (config3.required || config3.isLabel)) {
            throw new Error(`Required column ${key} is empty in this line: ${line}`);
          } else {
            parsedValue = void 0;
          }
        } else {
          const valueAsNum = Number(value);
          if (isNaN(valueAsNum)) {
            if (config3 && config3.dtype === "bool") {
              parsedValue = this.getBoolean(value);
            } else {
              parsedValue = value;
            }
          } else if (!config3 || !config3.dtype) {
            parsedValue = valueAsNum;
          } else {
            switch (config3.dtype) {
              case "float32":
                parsedValue = valueAsNum;
                break;
              case "int32":
                parsedValue = Math.floor(valueAsNum);
                break;
              case "bool":
                parsedValue = this.getBoolean(value);
                break;
              default:
                parsedValue = valueAsNum;
            }
          }
        }
        config3 && config3.isLabel ? labels2[key] = parsedValue : features[key] = parsedValue;
      }
    }
    if (Object.keys(labels2).length === 0) {
      return features;
    } else {
      return { xs: features, ys: labels2 };
    }
  }
  getBoolean(value) {
    if (value === "1" || value.toLowerCase() === "true") {
      return 1;
    } else {
      return 0;
    }
  }
  parseRow(line, validateElementCount = true) {
    const result = [];
    let readOffset = 0;
    const readLength = line.length;
    let currentState = STATE_OUT;
    for (let i2 = 0; i2 < readLength; i2++) {
      switch (currentState) {
        case STATE_OUT:
          switch (line.charAt(i2)) {
            case CODE_QUOTE:
              readOffset = i2 + 1;
              currentState = STATE_QUOTE;
              break;
            case this.delimiter:
              readOffset = i2 + 1;
              if (this.delimiter === " " && this.delimWhitespace) {
                break;
              }
              result.push("");
              currentState = STATE_OUT;
              break;
            default:
              currentState = STATE_FIELD;
              readOffset = i2;
              break;
          }
          break;
        case STATE_FIELD:
          switch (line.charAt(i2)) {
            case this.delimiter:
              result.push(line.substring(readOffset, i2));
              currentState = STATE_OUT;
              readOffset = i2 + 1;
              break;
            default:
          }
          break;
        case STATE_QUOTE:
          switch (line.charAt(i2)) {
            case CODE_QUOTE:
              currentState = STATE_QUOTE_AFTER_QUOTE;
              break;
            default:
          }
          break;
        case STATE_QUOTE_AFTER_QUOTE:
          switch (line.charAt(i2)) {
            case this.delimiter:
              result.push(line.substring(readOffset, i2 - 1));
              currentState = STATE_OUT;
              readOffset = i2 + 1;
              break;
            case CODE_QUOTE:
              currentState = STATE_QUOTE;
              break;
            default:
              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;
              break;
          }
          break;
        case STATE_WITHIN_QUOTE_IN_QUOTE:
          switch (line.charAt(i2)) {
            case CODE_QUOTE:
              currentState = STATE_QUOTE;
              break;
            default:
          }
          break;
        default:
      }
    }
    if (currentState === STATE_QUOTE_AFTER_QUOTE) {
      result.push(line.substring(readOffset, readLength - 1));
    } else {
      result.push(line.substring(readOffset));
    }
    if (validateElementCount && result.length !== this.fullColumnNames.length) {
      throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);
    }
    return result;
  }
};
var MicrophoneIterator = class extends LazyIterator {
  constructor(microphoneConfig) {
    super();
    this.microphoneConfig = microphoneConfig;
    this.isClosed = false;
    this.fftSize = microphoneConfig.fftSize || 1024;
    const fftSizeLog2 = Math.log2(this.fftSize);
    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {
      throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);
    }
    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;
    this.sampleRateHz = microphoneConfig.sampleRateHz;
    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;
    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;
    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;
    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;
    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;
    if (!this.includeSpectrogram && !this.includeWaveform) {
      throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
    }
  }
  summary() {
    return `microphone`;
  }
  static async create(microphoneConfig = {}) {
    if (env().get("IS_NODE")) {
      throw new Error("microphone API is only supported in browser environment.");
    }
    const microphoneIterator = new MicrophoneIterator(microphoneConfig);
    await microphoneIterator.start();
    return microphoneIterator;
  }
  async start() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,
        video: false
      });
    } catch (e2) {
      throw new Error(`Error thrown while initializing video stream: ${e2.message}`);
    }
    if (!this.stream) {
      throw new Error("Could not obtain audio from microphone.");
    }
    const ctxConstructor = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new ctxConstructor();
    if (!this.sampleRateHz) {
      this.sampleRateHz = this.audioContext.sampleRate;
    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {
      throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);
    }
    const streamSource = this.audioContext.createMediaStreamSource(this.stream);
    this.analyser = this.audioContext.createAnalyser();
    this.analyser.fftSize = this.fftSize * 2;
    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;
    streamSource.connect(this.analyser);
    this.freqData = new Float32Array(this.fftSize);
    this.timeData = new Float32Array(this.fftSize);
    return;
  }
  async next() {
    if (this.isClosed) {
      return { value: null, done: true };
    }
    let spectrogramTensor;
    let waveformTensor;
    const audioDataQueue = await this.getAudioData();
    if (this.includeSpectrogram) {
      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);
      spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);
    }
    if (this.includeWaveform) {
      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);
      waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);
    }
    return {
      value: { "spectrogram": spectrogramTensor, "waveform": waveformTensor },
      done: false
    };
  }
  async capture() {
    return (await this.next()).value;
  }
  async getAudioData() {
    const freqDataQueue = [];
    const timeDataQueue = [];
    let currentFrames = 0;
    return new Promise((resolve) => {
      const intervalID = setInterval(() => {
        if (this.includeSpectrogram) {
          this.analyser.getFloatFrequencyData(this.freqData);
          if (this.freqData[0] === -Infinity) {
            resolve({ freqDataQueue, timeDataQueue });
          }
          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));
        }
        if (this.includeWaveform) {
          this.analyser.getFloatTimeDomainData(this.timeData);
          timeDataQueue.push(this.timeData.slice());
        }
        if (++currentFrames === this.numFrames) {
          clearInterval(intervalID);
          resolve({ freqDataQueue, timeDataQueue });
        }
      }, this.fftSize / this.sampleRateHz * 1e3);
    });
  }
  stop() {
    if (!this.isClosed) {
      this.isClosed = true;
      this.analyser.disconnect();
      this.audioContext.close();
      if (this.stream != null && this.stream.getTracks().length > 0) {
        this.stream.getTracks()[0].stop();
      }
    }
  }
  toArray() {
    throw new Error("Can not convert infinite audio stream to array.");
  }
  getSampleRate() {
    return this.sampleRateHz;
  }
  flattenQueue(queue) {
    const frameSize = queue[0].length;
    const freqData = new Float32Array(queue.length * frameSize);
    queue.forEach((data, i2) => freqData.set(data, i2 * frameSize));
    return freqData;
  }
  getTensorFromAudioDataArray(freqData, shape) {
    const vals = new Float32Array(util_exports.sizeFromShape(shape));
    vals.set(freqData, vals.length - freqData.length);
    return tensor(vals, shape);
  }
};
var WebcamIterator = class extends LazyIterator {
  constructor(webcamVideoElement, webcamConfig) {
    super();
    this.webcamVideoElement = webcamVideoElement;
    this.webcamConfig = webcamConfig;
    this.isClosed = true;
    this.resize = false;
    if (this.needToResize()) {
      this.resize = true;
      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];
      this.cropBoxInd = tensor1d([0], "int32");
      if (this.webcamConfig.centerCrop) {
        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1 / this.webcamVideoElement.width;
        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1 / this.webcamVideoElement.height;
        const widthCropStart = (1 - widthCroppingRatio) / 2;
        const heightCropStart = (1 - heightCroppingRatio) / 2;
        const widthCropEnd = widthCropStart + widthCroppingRatio;
        const heightCropEnd = heightCroppingRatio + heightCropStart;
        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);
      } else {
        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);
      }
    }
  }
  summary() {
    return `webcam`;
  }
  static async create(webcamVideoElement, webcamConfig = {}) {
    if (env().get("IS_NODE")) {
      throw new Error("tf.data.webcam is only supported in browser environment.");
    }
    if (!webcamVideoElement) {
      webcamVideoElement = document.createElement("video");
      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {
        throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
      }
      webcamVideoElement.width = webcamConfig.resizeWidth;
      webcamVideoElement.height = webcamConfig.resizeHeight;
    }
    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);
    await webcamIterator.start();
    return webcamIterator;
  }
  async start() {
    if (this.webcamConfig.facingMode) {
      util_exports.assert(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);
    }
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          deviceId: this.webcamConfig.deviceId,
          facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
          width: this.webcamVideoElement.width,
          height: this.webcamVideoElement.height
        }
      });
    } catch (e2) {
      e2.message = `Error thrown while initializing video stream: ${e2.message}`;
      throw e2;
    }
    if (!this.stream) {
      throw new Error("Could not obtain video from webcam.");
    }
    try {
      this.webcamVideoElement.srcObject = this.stream;
    } catch (error) {
      console.log(error);
      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
    }
    this.webcamVideoElement.play();
    this.isClosed = false;
    return new Promise((resolve) => {
      this.webcamVideoElement.onloadedmetadata = () => {
        resolve();
      };
    });
  }
  async next() {
    if (this.isClosed) {
      return { value: null, done: true };
    }
    let img;
    try {
      img = browser_exports.fromPixels(this.webcamVideoElement);
    } catch (e2) {
      throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e2)}`);
    }
    if (this.resize) {
      try {
        return { value: this.cropAndResizeFrame(img), done: false };
      } catch (e2) {
        throw new Error(`Error thrown cropping the video: ${e2.message}`);
      } finally {
        img.dispose();
      }
    } else {
      return { value: img, done: false };
    }
  }
  needToResize() {
    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {
      return true;
    }
    return false;
  }
  cropAndResizeFrame(img) {
    return tidy(() => {
      const expandedImage = expandDims(cast(img, "float32"), 0);
      let resizedImage;
      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, "bilinear");
      const shape = resizedImage.shape;
      return reshape(resizedImage, shape.slice(1));
    });
  }
  async capture() {
    return (await this.next()).value;
  }
  stop() {
    const tracks = this.stream.getTracks();
    tracks.forEach((track) => track.stop());
    try {
      this.webcamVideoElement.srcObject = null;
    } catch (error) {
      console.log(error);
      this.webcamVideoElement.src = null;
    }
    this.isClosed = true;
  }
  toArray() {
    throw new Error("Can not convert infinite video stream to array.");
  }
};
var DataSource = class {
};
var StringIterator = class extends LazyIterator {
  split(separator) {
    return new SplitIterator(this, separator);
  }
};
var SplitIterator = class extends StringIterator {
  constructor(upstream, separator) {
    super();
    this.upstream = upstream;
    this.impl = new SplitIteratorImpl(upstream, separator);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
};
var SplitIteratorImpl = class extends OneToManyIterator {
  constructor(upstream, separator) {
    super();
    this.upstream = upstream;
    this.separator = separator;
    this.carryover = "";
  }
  summary() {
    return `${this.upstream.summary()} -> Split('${this.separator}')`;
  }
  async pump() {
    const chunkResult = await this.upstream.next();
    if (chunkResult.done) {
      if (this.carryover === "") {
        return false;
      }
      this.outputQueue.push(this.carryover);
      this.carryover = "";
      return true;
    }
    const lines2 = chunkResult.value.split(this.separator);
    lines2[0] = this.carryover + lines2[0];
    for (const line of lines2.slice(0, -1)) {
      this.outputQueue.push(line);
    }
    this.carryover = lines2[lines2.length - 1];
    return true;
  }
};
var ByteChunkIterator = class extends LazyIterator {
  decodeUTF8() {
    return new Utf8Iterator(this);
  }
};
var Utf8Iterator = class extends StringIterator {
  constructor(upstream) {
    super();
    this.upstream = upstream;
    this.impl = new Utf8IteratorImpl(upstream);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
};
var Utf8IteratorImpl = class extends OneToManyIterator {
  constructor(upstream) {
    super();
    this.upstream = upstream;
    if (env().get("IS_BROWSER")) {
      this.decoder = new TextDecoder("utf-8");
    } else {
      const { StringDecoder } = require_string_decoder();
      this.decoder = new StringDecoder("utf8");
    }
  }
  summary() {
    return `${this.upstream.summary()} -> Utf8`;
  }
  async pump() {
    const chunkResult = await this.upstream.next();
    let chunk;
    if (chunkResult.done) {
      return false;
    } else {
      chunk = chunkResult.value;
    }
    let text;
    if (env().get("IS_BROWSER")) {
      text = this.decoder.decode(chunk, { stream: true });
    } else {
      text = this.decoder.write(Buffer.from(chunk.buffer));
    }
    this.outputQueue.push(text);
    return true;
  }
};
var FileChunkIterator = class extends ByteChunkIterator {
  constructor(file, options3 = {}) {
    super();
    this.file = file;
    this.options = options3;
    util_exports.assert(file instanceof Uint8Array || (env().get("IS_BROWSER") ? file instanceof File || file instanceof Blob : false), () => "FileChunkIterator only supports File, Blob and Uint8Array right now.");
    this.offset = options3.offset || 0;
    this.chunkSize = options3.chunkSize || 1024 * 1024;
  }
  summary() {
    return `FileChunks ${this.file}`;
  }
  async next() {
    if (this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size)) {
      return { value: null, done: true };
    }
    const chunk = new Promise((resolve, reject) => {
      const end = this.offset + this.chunkSize;
      if (this.file instanceof Uint8Array) {
        resolve(new Uint8Array(this.file.slice(this.offset, end)));
      } else {
        const fileReader = new FileReader();
        fileReader.onload = (event) => {
          let data = fileReader.result;
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
          }
          if (!(data instanceof Uint8Array)) {
            return reject(new TypeError("FileReader returned unknown type."));
          }
          resolve(data);
        };
        fileReader.onabort = (event) => {
          return reject(new Error("Aborted"));
        };
        fileReader.onerror = (event) => {
          return reject(new Error(event.type));
        };
        const slice6 = this.file.slice(this.offset, end);
        fileReader.readAsArrayBuffer(slice6);
      }
      this.offset = end;
    });
    return { value: await chunk, done: false };
  }
};
async function urlChunkIterator(url, options3 = {}) {
  let urlString;
  let requestInit;
  if (typeof url === "string") {
    urlString = url;
  } else {
    urlString = url.url;
    requestInit = getRequestInitFromRequest(url);
  }
  const response = await util_exports.fetch(urlString, requestInit);
  if (response.ok) {
    const uint8Array = new Uint8Array(await response.arrayBuffer());
    return new FileChunkIterator(uint8Array, options3);
  } else {
    throw new Error(response.statusText);
  }
}
var getRequestInitFromRequest = (request) => {
  const init2 = {
    method: request.method,
    headers: request.headers,
    body: request.body,
    mode: request.mode,
    credentials: request.credentials,
    cache: request.cache,
    redirect: request.redirect,
    referrer: request.referrer,
    integrity: request.integrity
  };
  return init2;
};
function isLocalPath(source) {
  return typeof source === "string" && source.substr(0, 7) === "file://";
}
var FileDataSource = class extends DataSource {
  constructor(input2, options3 = {}) {
    super();
    this.input = input2;
    this.options = options3;
  }
  async iterator() {
    if (isLocalPath(this.input) && env().get("IS_NODE")) {
      const fs = __require22("fs");
      this.input = fs.readFileSync(this.input.substr(7));
    }
    return new FileChunkIterator(this.input, this.options);
  }
};
var URLDataSource = class extends DataSource {
  constructor(url, fileOptions = {}) {
    super();
    this.url = url;
    this.fileOptions = fileOptions;
  }
  async iterator() {
    if (isLocalPath(this.url)) {
      return new FileDataSource(this.url, this.fileOptions).iterator();
    } else {
      return urlChunkIterator(this.url, this.fileOptions);
    }
  }
};
function csv(source, csvConfig = {}) {
  return new CSVDataset(new URLDataSource(source), csvConfig);
}
function func(f2) {
  const iter = iteratorFromFunction(f2);
  return datasetFromIteratorFn(async () => iter);
}
function generator(generator2) {
  return datasetFromIteratorFn(async () => {
    const gen = await generator2();
    return iteratorFromFunction(() => gen.next());
  });
}
async function webcam(webcamVideoElement, webcamConfig) {
  return WebcamIterator.create(webcamVideoElement, webcamConfig);
}
async function microphone(microphoneConfig) {
  return MicrophoneIterator.create(microphoneConfig);
}
var version4 = "3.9.0";
function assertNotComplex(tensor2, opName) {
  if (!Array.isArray(tensor2)) {
    tensor2 = [tensor2];
  }
  tensor2.forEach((t2) => {
    if (t2 != null) {
      util_exports.assert(t2.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
    }
  });
}
var whereImpl2 = kernel_impls_exports.whereImpl;
var MathBackendCPU = class extends KernelBackend {
  constructor() {
    super();
    this.blockSize = 48;
    this.firstUse = true;
    this.data = new DataStorage(this, engine());
  }
  nextDataId() {
    return MathBackendCPU.nextDataId++;
  }
  write(values, shape, dtype) {
    if (this.firstUse) {
      this.firstUse = false;
      if (env().get("IS_NODE")) {
        backend_util_exports.warn("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================");
      }
    }
    const dataId = { id: this.nextDataId() };
    this.data.set(dataId, { values, dtype, refCount: 1 });
    return dataId;
  }
  makeTensorInfo(shape, dtype, values) {
    let outId;
    if (dtype === "string" && values != null && values.length > 0 && util_exports.isString(values[0])) {
      const encodedValues = values.map((d2) => util_exports.encodeString(d2));
      outId = this.write(encodedValues, shape, dtype);
    } else {
      outId = this.write(values, shape, dtype);
    }
    return { dataId: outId, shape, dtype };
  }
  refCount(dataId) {
    if (this.data.has(dataId)) {
      const tensorData = this.data.get(dataId);
      return tensorData.refCount;
    }
    return 0;
  }
  incRef(dataId) {
    const tensorData = this.data.get(dataId);
    tensorData.refCount++;
  }
  decRef(dataId) {
    if (this.data.has(dataId)) {
      const tensorData = this.data.get(dataId);
      tensorData.refCount--;
    }
  }
  move(dataId, values, shape, dtype, refCount) {
    this.data.set(dataId, { values, dtype, refCount });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  async read(dataId) {
    return this.readSync(dataId);
  }
  readSync(dataId) {
    const { dtype, complexTensorInfos } = this.data.get(dataId);
    if (dtype === "complex64") {
      const realValues = this.readSync(complexTensorInfos.real.dataId);
      const imagValues = this.readSync(complexTensorInfos.imag.dataId);
      return backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
    }
    return this.data.get(dataId).values;
  }
  bufferSync(t2) {
    const data = this.readSync(t2.dataId);
    let decodedData = data;
    if (t2.dtype === "string") {
      try {
        decodedData = data.map((d2) => util_exports.decodeString(d2));
      } catch (_a) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    }
    return buffer(t2.shape, t2.dtype, decodedData);
  }
  makeOutput(values, shape, dtype) {
    const dataId = this.write(values, shape, dtype);
    return engine().makeTensorFromDataId(dataId, shape, dtype, this);
  }
  disposeData(dataId, force = false) {
    if (this.data.has(dataId)) {
      this.data.get(dataId).refCount--;
      if (!force && this.data.get(dataId).refCount > 0) {
        return false;
      }
      const { complexTensorInfos } = this.data.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, true);
        this.disposeData(complexTensorInfos.imag.dataId, true);
      }
      this.data.delete(dataId);
    }
    return true;
  }
  disposeIntermediateTensorInfo(tensorInfo) {
    this.disposeData(tensorInfo.dataId);
  }
  async time(f2) {
    const start = util_exports.now();
    f2();
    const kernelMs = util_exports.now() - start;
    return { kernelMs };
  }
  memory() {
    return {
      unreliable: true,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }
  where(condition) {
    assertNotComplex([condition], "where");
    const condVals = this.readSync(condition.dataId);
    return whereImpl2(condition.shape, condVals);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  epsilon() {
    return super.epsilon();
  }
};
MathBackendCPU.nextDataId = 0;
var shared_exports = {};
__export2(shared_exports, {
  addImpl: () => addImpl,
  bincountImpl: () => bincountImpl,
  bincountReduceImpl: () => bincountReduceImpl,
  ceilImpl: () => ceilImpl,
  concatImpl: () => concatImpl,
  equalImpl: () => equalImpl,
  expImpl: () => expImpl,
  expm1Impl: () => expm1Impl,
  floorImpl: () => floorImpl,
  gatherNdImpl: () => gatherNdImpl,
  gatherV2Impl: () => gatherV2Impl,
  greaterEqualImpl: () => greaterEqualImpl,
  greaterImpl: () => greaterImpl,
  lessEqualImpl: () => lessEqualImpl,
  lessImpl: () => lessImpl,
  linSpaceImpl: () => linSpaceImpl,
  logImpl: () => logImpl,
  maxImpl: () => maxImpl,
  maximumImpl: () => maximumImpl,
  minimumImpl: () => minimumImpl,
  multiplyImpl: () => multiplyImpl,
  negImpl: () => negImpl,
  notEqualImpl: () => notEqualImpl,
  prodImpl: () => prodImpl,
  rangeImpl: () => rangeImpl,
  rsqrtImpl: () => rsqrtImpl,
  sigmoidImpl: () => sigmoidImpl,
  simpleAbsImpl: () => simpleAbsImpl,
  sliceImpl: () => sliceImpl,
  sparseFillEmptyRowsImpl: () => sparseFillEmptyRowsImpl,
  sparseReshapeImpl: () => sparseReshapeImpl,
  sparseSegmentReductionImpl: () => sparseSegmentReductionImpl,
  sqrtImpl: () => sqrtImpl,
  squaredDifferenceImpl: () => squaredDifferenceImpl,
  stridedSliceImpl: () => stridedSliceImpl,
  stringNGramsImpl: () => stringNGramsImpl,
  stringSplitImpl: () => stringSplitImpl,
  stringToHashBucketFastImpl: () => stringToHashBucketFastImpl,
  subImpl: () => subImpl,
  tileImpl: () => tileImpl,
  topKImpl: () => topKImpl,
  transposeImpl: () => transposeImpl,
  uniqueImpl: () => uniqueImpl
});
function simpleAbsImpl(vals) {
  const resultValues = new Float32Array(vals.length);
  for (let i2 = 0; i2 < vals.length; ++i2) {
    resultValues[i2] = Math.abs(vals[i2]);
  }
  return resultValues;
}
var abs2 = (args) => {
  const { x: x2 } = args.inputs;
  const cpuBackend = args.backend;
  assertNotComplex(x2, "abs");
  let resultValues = new Float32Array(util_exports.sizeFromShape(x2.shape));
  const values = cpuBackend.data.get(x2.dataId).values;
  resultValues = simpleAbsImpl(values);
  return cpuBackend.makeOutput(resultValues, x2.shape, "float32");
};
var absConfig = {
  kernelName: Abs,
  backendName: "cpu",
  kernelFunc: abs2
};
function createSimpleBinaryKernelImpl(op2) {
  return (aShape, bShape, aVals, bVals, dtype) => {
    const newShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    const resultRank = newShape.length;
    const resultStrides = util_exports.computeStrides(newShape);
    const resultSize = util_exports.sizeFromShape(newShape);
    const result = util_exports.getTypedArrayFromDType(dtype, resultSize);
    const aRank = aShape.length;
    const bRank = bShape.length;
    const aStrides = util_exports.computeStrides(aShape);
    const bStrides = util_exports.computeStrides(bShape);
    const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, newShape);
    const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, newShape);
    if (aBroadcastDims.length + bBroadcastDims.length === 0) {
      for (let i2 = 0; i2 < result.length; ++i2) {
        result[i2] = op2(aVals[i2 % aVals.length], bVals[i2 % bVals.length]);
      }
    } else {
      for (let i2 = 0; i2 < result.length; ++i2) {
        const loc = util_exports.indexToLoc(i2, resultRank, resultStrides);
        const aLoc = loc.slice(-aRank);
        aBroadcastDims.forEach((d2) => aLoc[d2] = 0);
        const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
        const bLoc = loc.slice(-bRank);
        bBroadcastDims.forEach((d2) => bLoc[d2] = 0);
        const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
        result[i2] = op2(aVals[aIndex], bVals[bIndex]);
      }
    }
    return [result, newShape];
  };
}
function complex2(args) {
  const { inputs, backend: backend22 } = args;
  const { real: real5, imag: imag5 } = inputs;
  const realVals = backend22.data.get(real5.dataId).values;
  const imagVals = backend22.data.get(imag5.dataId).values;
  const complexInfo = backend22.makeTensorInfo(real5.shape, "complex64");
  const complex5 = backend22.data.get(complexInfo.dataId);
  complex5.complexTensorInfos = {
    real: backend22.makeTensorInfo(real5.shape, "float32", realVals),
    imag: backend22.makeTensorInfo(imag5.shape, "float32", imagVals)
  };
  return complexInfo;
}
var complexConfig = {
  kernelName: Complex,
  backendName: "cpu",
  kernelFunc: complex2
};
function zeros3(backend22, shape, dtype = "float32") {
  if (dtype === "complex64") {
    const real5 = zeros3(backend22, shape, "float32");
    const imag5 = zeros3(backend22, shape, "float32");
    return complex2({ inputs: { real: real5, imag: imag5 }, backend: backend22 });
  }
  const values = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(shape), dtype);
  return backend22.makeTensorInfo(shape, dtype, values);
}
function identity2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  backend22.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: x2.shape, dtype: x2.dtype };
}
var identityConfig = {
  kernelName: Identity,
  backendName: "cpu",
  kernelFunc: identity2
};
function real2(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const real5 = backend22.data.get(input2.dataId).complexTensorInfos.real;
  const realVal = backend22.data.get(real5.dataId).values;
  return backend22.makeTensorInfo(real5.shape, real5.dtype, realVal);
}
var realConfig = {
  kernelName: Real,
  backendName: "cpu",
  kernelFunc: real2
};
function cast3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x2.dtype === "complex64") {
      return identity2({ inputs: { x: x2 }, backend: backend22 });
    }
    const zerosTensorInfo = zeros3(backend22, x2.shape, x2.dtype);
    const floatX = cast3({ inputs: { x: x2 }, backend: backend22, attrs: { dtype: "float32" } });
    const result = complex2({ inputs: { real: floatX, imag: zerosTensorInfo }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(zerosTensorInfo);
    backend22.disposeIntermediateTensorInfo(floatX);
    return result;
  }
  if (x2.dtype === "complex64") {
    const realPart = real2({ inputs: { input: x2 }, backend: backend22 });
    const result = cast3({ inputs: { x: realPart }, backend: backend22, attrs: { dtype } });
    backend22.disposeIntermediateTensorInfo(realPart);
    return result;
  }
  if (!util_exports.hasEncodingLoss(x2.dtype, dtype)) {
    const result = identity2({ inputs: { x: x2 }, backend: backend22 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  if (dtype === "int32") {
    const values = backend22.data.get(x2.dataId).values;
    const resultValues = Int32Array.from(values);
    return backend22.makeTensorInfo(x2.shape, "int32", resultValues);
  }
  if (dtype === "bool") {
    const xVals = backend22.data.get(x2.dataId).values;
    const zero = util_exports.toTypedArray([0], x2.dtype);
    const [resultData, resultShape] = createSimpleBinaryKernelImpl((a6, b2) => a6 !== b2 ? 1 : 0)(x2.shape, [], xVals, zero, "bool");
    return backend22.makeTensorInfo(resultShape, "bool", resultData);
  }
  throw new Error(`Error in Cast: failed to cast ${x2.dtype} to ${dtype}`);
}
var castConfig = {
  kernelName: Cast,
  backendName: "cpu",
  kernelFunc: cast3
};
function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
  if (complexImpl == null) {
    return ({ inputs, backend: backend22 }) => {
      const { a: a6, b: b2 } = inputs;
      const cpuBackend = backend22;
      assertNotComplex([a6, b2], name);
      const aVals = cpuBackend.data.get(a6.dataId).values;
      const bVals = cpuBackend.data.get(b2.dataId).values;
      const decodedAVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
      const decodedBVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
      const $dtype = dtype || a6.dtype;
      const [resultData, resultShape] = simpleImpl(a6.shape, b2.shape, decodedAVals, decodedBVals, $dtype);
      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
    };
  }
  return ({ inputs, backend: backend22 }) => {
    const { a: a6, b: b2 } = inputs;
    const cpuBackend = backend22;
    if (a6.dtype === "complex64" || b2.dtype === "complex64") {
      const $aComplex = cast3({ inputs: { x: a6 }, backend: cpuBackend, attrs: { dtype: "complex64" } });
      const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
      const aReal = $aComplexVals.complexTensorInfos.real;
      const aImag = $aComplexVals.complexTensorInfos.imag;
      const aRealVals = cpuBackend.data.get(aReal.dataId).values;
      const aImagVals = cpuBackend.data.get(aImag.dataId).values;
      const $bComplex = cast3({ inputs: { x: b2 }, backend: cpuBackend, attrs: { dtype: "complex64" } });
      const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
      const bReal = $bComplexVals.complexTensorInfos.real;
      const bImag = $bComplexVals.complexTensorInfos.imag;
      const bRealVals = cpuBackend.data.get(bReal.dataId).values;
      const bImagVals = cpuBackend.data.get(bImag.dataId).values;
      const [resultRealData, resultImagData, resultShape] = complexImpl(a6.shape, b2.shape, aRealVals, aImagVals, bRealVals, bImagVals);
      const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
      const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
      const result = complex2({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
      cpuBackend.disposeIntermediateTensorInfo($aComplex);
      cpuBackend.disposeIntermediateTensorInfo($bComplex);
      cpuBackend.disposeIntermediateTensorInfo(resultReal);
      cpuBackend.disposeIntermediateTensorInfo(resultImag);
      return result;
    } else {
      const aVals = cpuBackend.data.get(a6.dataId).values;
      const bVals = cpuBackend.data.get(b2.dataId).values;
      const $dtype = dtype || a6.dtype;
      const [resultData, resultShape] = simpleImpl(a6.shape, b2.shape, aVals, bVals, $dtype);
      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
    }
  };
}
function createComplexBinaryKernelImpl(op2) {
  return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
    const resultShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    const resultSize = util_exports.sizeFromShape(resultShape);
    const resultRank = resultShape.length;
    const resultStrides = util_exports.computeStrides(resultShape);
    const resultRealVals = util_exports.getTypedArrayFromDType("float32", resultSize);
    const resultImagVals = util_exports.getTypedArrayFromDType("float32", resultSize);
    const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, resultShape);
    const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, resultShape);
    const aVals = backend_util_exports.mergeRealAndImagArrays(aRealVals, aImagVals);
    const bVals = backend_util_exports.mergeRealAndImagArrays(bRealVals, bImagVals);
    const aRank = aShape.length;
    const aStrides = util_exports.computeStrides(aShape);
    const bRank = bShape.length;
    const bStrides = util_exports.computeStrides(bShape);
    if (aBroadcastDims.length + bBroadcastDims.length === 0) {
      for (let i2 = 0; i2 < resultRealVals.length; i2++) {
        const aIdx = i2 % aVals.length;
        const bIdx = i2 % bVals.length;
        const result = op2(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
        resultRealVals[i2] = result.real;
        resultImagVals[i2] = result.imag;
      }
    } else {
      for (let i2 = 0; i2 < resultRealVals.length; i2++) {
        const loc = util_exports.indexToLoc(i2, resultRank, resultStrides);
        const aLoc = loc.slice(-aRank);
        aBroadcastDims.forEach((d2) => aLoc[d2] = 0);
        const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
        const bLoc = loc.slice(-bRank);
        bBroadcastDims.forEach((d2) => bLoc[d2] = 0);
        const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
        const opResult = op2(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
        resultRealVals[i2] = opResult.real;
        resultImagVals[i2] = opResult.imag;
      }
    }
    return [resultRealVals, resultImagVals, resultShape];
  };
}
var addImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 + b2);
var addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
  return { real: aReal + bReal, imag: aImag + bImag };
});
var add4 = binaryKernelFunc(Add, addImpl, addComplexImpl);
var addConfig = {
  kernelName: Add,
  backendName: "cpu",
  kernelFunc: add4
};
function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size2) {
  const weightsSize = util_exports.sizeFromShape(weightsShape);
  const outVals = util_exports.makeZerosTypedArray(size2, weightsDtype);
  for (let i2 = 0; i2 < xVals.length; i2++) {
    const value = xVals[i2];
    if (value < 0) {
      throw new Error("Input x must be non-negative!");
    }
    if (value >= size2) {
      continue;
    }
    if (weightsSize > 0) {
      outVals[value] += weightsVals[i2];
    } else {
      outVals[value] += 1;
    }
  }
  return outVals;
}
function bincountReduceImpl(xBuf, weightsBuf, size2, binaryOutput = false) {
  const numRows = xBuf.shape[0];
  const numCols = xBuf.shape[1];
  const outBuf = buffer([numRows, size2], weightsBuf.dtype);
  for (let i2 = 0; i2 < numRows; i2++) {
    for (let j2 = 0; j2 < numCols; j2++) {
      const value = xBuf.get(i2, j2);
      if (value < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (value >= size2) {
        continue;
      }
      if (binaryOutput) {
        outBuf.set(1, i2, value);
      } else {
        if (weightsBuf.size > 0) {
          outBuf.set(outBuf.get(i2, value) + weightsBuf.get(i2, j2), i2, value);
        } else {
          outBuf.set(outBuf.get(i2, value) + 1, i2, value);
        }
      }
    }
  }
  return outBuf;
}
function createSimpleUnaryImpl(op2) {
  return (values, dtype, attrs) => {
    const newValues = util_exports.getTypedArrayFromDType(dtype, values.length);
    for (let i2 = 0; i2 < values.length; ++i2) {
      newValues[i2] = op2(values[i2], attrs);
    }
    return newValues;
  };
}
function unaryKernelFunc(name, op2, dtype) {
  return ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    assertNotComplex(x2, name);
    if (x2.dtype === "string" || dtype === "string") {
      throw new Error("unaryKernelFunc does not support string input/output");
    }
    const cpuBackend = backend22;
    const values = cpuBackend.data.get(x2.dataId).values;
    const xSize = util_exports.sizeFromShape(x2.shape);
    const $dtype = dtype || x2.dtype;
    const newValues = util_exports.getArrayFromDType($dtype, xSize);
    for (let i2 = 0; i2 < xSize; ++i2) {
      newValues[i2] = op2(values[i2], attrs);
    }
    return cpuBackend.makeTensorInfo(x2.shape, $dtype, newValues);
  };
}
function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
  return ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    assertNotComplex(x2, name);
    if (x2.dtype === "string" || dtype === "string") {
      throw new Error("unaryKernelFunc does not support string input/output");
    }
    const cpuBackend = backend22;
    const values = cpuBackend.data.get(x2.dataId).values;
    const $dtype = dtype || x2.dtype;
    const newValues = unaryImpl(values, $dtype, attrs);
    return cpuBackend.makeTensorInfo(x2.shape, $dtype, newValues);
  };
}
var ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
var ceil2 = unaryKernelFuncFromImpl(Ceil, ceilImpl);
var ceilConfig = {
  kernelName: Ceil,
  backendName: "cpu",
  kernelFunc: ceil2
};
function concatImpl(inputs, outShape, dtype, simplyConcat) {
  const outVals = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
  if (simplyConcat && dtype !== "string") {
    let offset = 0;
    inputs.forEach((input2) => {
      const size2 = util_exports.sizeFromShape(input2.shape);
      outVals.set(input2.vals, offset);
      offset += size2;
    });
  } else {
    let colOffset = 0;
    inputs.forEach((input2) => {
      const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(input2.vals) : input2.vals;
      let tIdx = 0;
      for (let row = 0; row < input2.shape[0]; ++row) {
        const resIdx = row * outShape[1] + colOffset;
        for (let col = 0; col < input2.shape[1]; ++col) {
          outVals[resIdx + col] = decodedData[tIdx++];
        }
      }
      colOffset += input2.shape[1];
    });
  }
  return outVals;
}
var equalImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 === b2 ? 1 : 0);
var equal2 = binaryKernelFunc(Equal, equalImpl, null, "bool");
var equalConfig = {
  kernelName: Equal,
  backendName: "cpu",
  kernelFunc: equal2
};
var expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
var exp2 = unaryKernelFuncFromImpl(Exp, expImpl);
var expConfig = {
  kernelName: Exp,
  backendName: "cpu",
  kernelFunc: exp2
};
var expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
var expm12 = unaryKernelFuncFromImpl(Expm1, expm1Impl);
var expm1Config = {
  kernelName: Expm1,
  backendName: "cpu",
  kernelFunc: expm12
};
var floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
var floor2 = unaryKernelFuncFromImpl(Floor, floorImpl);
var floorConfig = {
  kernelName: Floor,
  backendName: "cpu",
  kernelFunc: floor2
};
function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
  const outBuf = buffer([numSlices, sliceSize], dtype);
  for (let i2 = 0; i2 < numSlices; i2++) {
    const index = [];
    let flattenIndex = 0;
    for (let j2 = 0; j2 < sliceRank; j2++) {
      const dim = indicesData[i2 * sliceRank + j2];
      flattenIndex += dim * strides[j2];
      index.push(dim);
    }
    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
      throw new Error(`Invalid indices: ${index} does not index into ${paramsShape}`);
    }
    for (let k3 = 0; k3 < sliceSize; k3++) {
      outBuf.values[i2 * sliceSize + k3] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k3));
    }
  }
  return outBuf;
}
function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
  const outBuf = buffer(flattenOutputShape, xBuf.dtype);
  for (let i2 = 0; i2 < outBuf.size; ++i2) {
    const newLoc = outBuf.indexToLoc(i2);
    const originalLoc = newLoc.slice();
    const batchIdx = originalLoc[0];
    const indicesIdx = originalLoc[2];
    const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
    originalLoc[2] = indicesBuf.values[indicesIndex];
    const originalIndex = xBuf.locToIndex(originalLoc);
    outBuf.values[i2] = xBuf.values[originalIndex];
  }
  return outBuf;
}
var greaterImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 > b2 ? 1 : 0);
var greater3 = binaryKernelFunc(Greater, greaterImpl, null, "bool");
var greaterConfig = {
  kernelName: Greater,
  backendName: "cpu",
  kernelFunc: greater3
};
var greaterEqualImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 >= b2 ? 1 : 0);
var greaterEqual2 = binaryKernelFunc(GreaterEqual, greaterEqualImpl, null, "bool");
var greaterEqualConfig = {
  kernelName: GreaterEqual,
  backendName: "cpu",
  kernelFunc: greaterEqual2
};
var lessImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 < b2 ? 1 : 0);
var less3 = binaryKernelFunc(Less, lessImpl, null, "bool");
var lessConfig = {
  kernelName: Less,
  backendName: "cpu",
  kernelFunc: less3
};
var lessEqualImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 <= b2 ? 1 : 0);
var lessEqual2 = binaryKernelFunc(LessEqual, lessEqualImpl, null, "bool");
var lessEqualConfig = {
  kernelName: LessEqual,
  backendName: "cpu",
  kernelFunc: lessEqual2
};
function linSpaceImpl(start, stop, num) {
  const step5 = (stop - start) / (num - 1);
  const values = util_exports.makeZerosTypedArray(num, "float32");
  values[0] = start;
  for (let i2 = 1; i2 < values.length; i2++) {
    values[i2] = values[i2 - 1] + step5;
  }
  return values;
}
var logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
var log6 = unaryKernelFuncFromImpl(Log, logImpl);
var logConfig = {
  kernelName: Log,
  backendName: "cpu",
  kernelFunc: log6
};
function maxImpl(aVals, reduceSize, outShape, dtype) {
  const vals = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let max7 = aVals[offset];
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      if (Number.isNaN(value) || value > max7) {
        max7 = value;
      }
    }
    vals[i2] = max7;
  }
  return vals;
}
var maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
var maximum3 = binaryKernelFunc(Maximum, maximumImpl);
var maximumConfig = {
  kernelName: Maximum,
  backendName: "cpu",
  kernelFunc: maximum3
};
var minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
var minimum3 = binaryKernelFunc(Minimum, minimumImpl);
var minimumConfig = {
  kernelName: Minimum,
  backendName: "cpu",
  kernelFunc: minimum3
};
var multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
var multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
  return {
    real: aReal * bReal - aImag * bImag,
    imag: aReal * bImag + aImag * bReal
  };
});
var multiply2 = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);
var multiplyConfig = {
  kernelName: Multiply,
  backendName: "cpu",
  kernelFunc: multiply2
};
function negImpl(xVals, xShape, xDtype) {
  const minusOne = util_exports.createScalarValue(-1, xDtype);
  return multiplyImpl([], xShape, minusOne, xVals, xDtype);
}
function neg2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  assertNotComplex(x2, "neg");
  const xVals = backend22.data.get(x2.dataId).values;
  const [res2, newShape] = negImpl(xVals, x2.shape, x2.dtype);
  return backend22.makeTensorInfo(newShape, x2.dtype, res2);
}
var negConfig = {
  kernelName: Neg,
  backendName: "cpu",
  kernelFunc: neg2
};
var notEqualImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 !== b2 ? 1 : 0);
var notEqual2 = binaryKernelFunc(NotEqual, notEqualImpl, null, "bool");
var notEqualConfig = {
  kernelName: NotEqual,
  backendName: "cpu",
  kernelFunc: notEqual2
};
function transposeImpl(xVals, xShape, dtype, perm, newShape) {
  const xRank = xShape.length;
  const xSize = util_exports.sizeFromShape(xShape);
  const xStrides = util_exports.computeStrides(xShape);
  const newStrides = util_exports.computeStrides(newShape);
  const result = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(newShape));
  for (let i2 = 0; i2 < xSize; ++i2) {
    const loc = util_exports.indexToLoc(i2, xRank, xStrides);
    const newLoc = new Array(loc.length);
    for (let i22 = 0; i22 < newLoc.length; i22++) {
      newLoc[i22] = loc[perm[i22]];
    }
    const newIndex = util_exports.locToIndex(newLoc, xRank, newStrides);
    result[newIndex] = xVals[i2];
  }
  return result;
}
function transpose2(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  const { perm } = attrs;
  assertNotComplex(x2, "transpose");
  const xRank = x2.shape.length;
  const newShape = new Array(xRank);
  for (let i2 = 0; i2 < newShape.length; i2++) {
    newShape[i2] = x2.shape[perm[i2]];
  }
  const values = backend22.data.get(x2.dataId).values;
  const result = transposeImpl(values, x2.shape, x2.dtype, perm, newShape);
  const dataId = backend22.write(result, newShape, x2.dtype);
  return { dataId, shape: newShape, dtype: x2.dtype };
}
var transposeConfig = {
  kernelName: Transpose,
  backendName: "cpu",
  kernelFunc: transpose2
};
function prodImpl(xShape, xDtype, xVals, reductionAxes) {
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, reductionAxes);
  const outDtype = upcastType(xDtype, "int32");
  const outVals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), outDtype);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  for (let i2 = 0; i2 < outVals.length; ++i2) {
    const offset = i2 * reduceSize;
    let prod6 = 1;
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      prod6 *= xVals[offset + j2];
    }
    outVals[i2] = prod6;
  }
  return { outVals, outShape, outDtype };
}
function prod2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x2, "prod");
  const xRank = x2.shape.length;
  const axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutation = backend_util_exports.getAxesPermutation(axes, xRank);
  let reductionAxes = axes;
  let permutedX = x2;
  const intermediateTensorInfos = [];
  if (permutation != null) {
    permutedX = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutation } });
    intermediateTensorInfos.push(permutedX);
    reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, xRank);
  }
  const xVals = backend22.data.get(permutedX.dataId).values;
  const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);
  let resultShape = outShape;
  if (keepDims) {
    resultShape = backend_util_exports.expandShapeToKeepDim(outShape, axes);
  }
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return backend22.makeTensorInfo(resultShape, outDtype, outVals);
}
var prodConfig = {
  kernelName: Prod,
  backendName: "cpu",
  kernelFunc: prod2
};
function rangeImpl(start, stop, step5, dtype) {
  const sameStartStop = start === stop;
  const increasingRangeNegativeStep = start < stop && step5 < 0;
  const decreasingRangePositiveStep = stop < start && step5 > 1;
  if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
    return util_exports.makeZerosTypedArray(0, dtype);
  }
  const numElements = Math.abs(Math.ceil((stop - start) / step5));
  const values = util_exports.makeZerosTypedArray(numElements, dtype);
  if (stop < start && step5 === 1) {
    step5 = -1;
  }
  values[0] = start;
  for (let i2 = 1; i2 < values.length; i2++) {
    values[i2] = values[i2 - 1] + step5;
  }
  return values;
}
var rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
var rsqrt2 = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);
var rsqrtConfig = {
  kernelName: Rsqrt,
  backendName: "cpu",
  kernelFunc: rsqrt2
};
var sigmoidImpl = createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));
var sigmoid2 = unaryKernelFunc(Sigmoid, (xi) => 1 / (1 + Math.exp(-xi)));
var sigmoidConfig = {
  kernelName: Sigmoid,
  backendName: "cpu",
  kernelFunc: sigmoid2
};
function sliceImpl(vals, begin, size2, shape, dtype) {
  const isContinous = slice_util_exports.isSliceContinous(shape, begin, size2);
  const length = util_exports.sizeFromShape(size2);
  const xStrides = util_exports.computeStrides(shape);
  if (isContinous) {
    const flatOffset = slice_util_exports.computeFlatOffset(begin, xStrides);
    if (dtype === "string") {
      return vals.slice(flatOffset, flatOffset + length);
    }
    return vals.subarray(flatOffset, flatOffset + length);
  }
  const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(vals) : vals;
  const inBuf = buffer(shape, dtype, decodedData);
  const outBuf = buffer(size2, dtype);
  for (let i2 = 0; i2 < outBuf.size; ++i2) {
    const outLoc = outBuf.indexToLoc(i2);
    const inLoc = outLoc.map((idx, j2) => idx + begin[j2]);
    outBuf.set(inBuf.get(...inLoc), ...outLoc);
  }
  if (dtype === "string") {
    return backend_util_exports.fromStringArrayToUint8(outBuf.values);
  }
  return outBuf.values;
}
function slice2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, size: size2 } = attrs;
  assertNotComplex(x2, "slice");
  const [$begin, $size] = slice_util_exports.parseSliceParams(x2, begin, size2);
  slice_util_exports.assertParamsValid(x2, $begin, $size);
  const vals = backend22.data.get(x2.dataId).values;
  const outVals = sliceImpl(vals, $begin, $size, x2.shape, x2.dtype);
  return backend22.makeTensorInfo($size, x2.dtype, outVals);
}
var sliceConfig = {
  kernelName: Slice,
  backendName: "cpu",
  kernelFunc: slice2
};
function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
  const indicesCount = indicesShape[0];
  const denseRows = denseShape[0];
  const emptyRowIndicator = new Array(denseRows);
  const reverseIndexMap = new Array(indicesCount);
  const rank = indicesShape[1];
  if (denseRows === 0) {
    if (indicesCount !== 0) {
      throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${indicesCount}`);
    }
    const outputIndices = util_exports.getArrayFromDType(indicesDType, 0);
    const outputValues = util_exports.getArrayFromDType(valuesDType, 0);
    return [
      outputIndices,
      [0, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  }
  let rowsAreOrdered = true;
  let lastIndicesRow = 0;
  const csrOffset = new Array(denseRows).fill(0);
  for (let i2 = 0; i2 < indicesCount; ++i2) {
    const row = indices[i2 * rank];
    if (row < 0) {
      throw new Error(`indices(${i2}, 0) is invalid: ${row} < 0`);
    }
    if (row >= denseRows) {
      throw new Error(`indices(${i2}, 0) is invalid: ${row} >= ${denseRows}`);
    }
    ++csrOffset[row];
    rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
    lastIndicesRow = row;
  }
  let allRowsFull = true;
  for (let row = 0; row < denseRows; ++row) {
    const rowEmpty = csrOffset[row] === 0;
    emptyRowIndicator[row] = rowEmpty;
    allRowsFull = allRowsFull && !rowEmpty;
    csrOffset[row] = Math.max(csrOffset[row], 1);
    if (row > 0) {
      csrOffset[row] += csrOffset[row - 1];
    }
  }
  if (allRowsFull && rowsAreOrdered) {
    const outputIndices = indices;
    const outputValues = values;
    for (let i2 = 0; i2 < indicesCount; ++i2) {
      reverseIndexMap[i2] = i2;
    }
    return [
      outputIndices,
      [indicesCount, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  } else {
    const fullIndicesCount = csrOffset[denseRows - 1];
    const outputIndices = util_exports.getArrayFromDType(indicesDType, fullIndicesCount * rank);
    const outputValues = util_exports.getArrayFromDType(valuesDType, fullIndicesCount);
    const filledCount = new Array(denseRows).fill(0);
    for (let i2 = 0; i2 < indicesCount; ++i2) {
      const row = indices[i2 * rank];
      const offset = filledCount[row];
      const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
      filledCount[row]++;
      for (let j2 = 0; j2 < rank; ++j2) {
        outputIndices[outputI * rank + j2] = indices[i2 * rank + j2];
      }
      outputValues[outputI] = values[i2];
      reverseIndexMap[i2] = outputI;
    }
    for (let row = 0; row < denseRows; ++row) {
      const rowCount = filledCount[row];
      if (rowCount === 0) {
        const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
        outputIndices[startingIndex * rank + 0] = row;
        for (let col = 1; col < rank; ++col) {
          outputIndices[startingIndex * rank + col] = 0;
        }
        outputValues[startingIndex] = defaultValue;
      }
    }
    return [
      outputIndices,
      [fullIndicesCount, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  }
}
function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
  const denseSize = util_exports.sizeFromShape(inputShape);
  const nnz = inputIndicesShape[0];
  const outputRank = targetShape.length;
  const outputShape = [];
  let product = 1;
  let unknownIndex = -1;
  for (let d2 = 0; d2 < outputRank; ++d2) {
    const size2 = targetShape[d2];
    if (size2 === -1) {
      if (unknownIndex !== -1) {
        throw new Error(`only one output dimension may be -1, not both ${unknownIndex} and ${d2}`);
      }
      unknownIndex = d2;
      outputShape.push(1);
    } else {
      if (size2 < 0) {
        throw new Error(`size ${d2} must be non-negative, not ${size2}`);
      }
      product *= size2;
      outputShape.push(size2);
    }
  }
  if (unknownIndex !== -1) {
    if (product <= 0) {
      throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
    }
    const missing = Math.trunc(denseSize / product);
    if (product * missing !== denseSize) {
      throw new Error(`Input to reshape is a SparseTensor with ${denseSize}
          dense values, but the requested shape requires a multiple of ${product}. inputShape=${inputShape} outputShape= ${outputShape}`);
    }
    outputShape[unknownIndex] = missing;
  }
  const outputSize2 = util_exports.sizeFromShape(outputShape);
  if (outputSize2 !== denseSize) {
    throw new Error(`Input to reshape is a tensor with ${denseSize} dense values, but the requested shape has ${outputSize2}. inputShape=${inputShape} outputShape=${outputShape}`);
  }
  const inputRank = inputShape.length;
  const inputStrides = [];
  if (inputRank > 0) {
    inputStrides[inputRank - 1] = 1;
    for (let d2 = inputRank - 2; d2 >= 0; --d2) {
      inputStrides[d2] = inputStrides[d2 + 1] * inputShape[d2 + 1];
    }
  }
  const outputStrides = [];
  if (outputRank > 0) {
    outputStrides[outputRank - 1] = 1;
    for (let d2 = outputRank - 2; d2 >= 0; --d2) {
      outputStrides[d2] = outputStrides[d2 + 1] * outputShape[d2 + 1];
    }
  }
  const newIndices = util_exports.getArrayFromDType(inputDType, nnz * outputRank);
  for (let i2 = 0; i2 < nnz; ++i2) {
    let id = 0;
    for (let j2 = 0; j2 < inputRank; ++j2) {
      id += inputIndices[i2 * inputRank + j2] * inputStrides[j2];
    }
    for (let j2 = 0; j2 < outputRank; ++j2) {
      newIndices[i2 * outputRank + j2] = Math.trunc(id / outputStrides[j2]);
      id %= outputStrides[j2];
    }
  }
  return [newIndices, [nnz, outputRank], outputShape];
}
function sparseSegmentReductionImpl(input2, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
  const numIndices = indices.length;
  if (numIndices !== segmentIds.length) {
    throw new Error(`segmentIds and indices should have same size.`);
  }
  const inputFlat = [inputShape[0], input2.length / inputShape[0]];
  const numCol = inputFlat[1];
  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
  const outputRows = lastSegmentIdPlusOne;
  if (outputRows < 0) {
    throw new Error(`segment ids must be >= 0`);
  }
  const outputShape = inputShape.slice();
  outputShape[0] = outputRows;
  const outputLength = outputShape.reduce((product, value) => product * value, 1);
  const output = util_exports.getArrayFromDType(inputDType, outputLength);
  if (numIndices === 0) {
    if (outputRows > 0) {
      output.fill(defaultValue);
    }
    return [output, outputShape];
  }
  if (outputRows <= 0) {
    throw new Error(`segment ids must be >= 0`);
  }
  let start = 0, end = 1;
  let uninitializedIndex = 0;
  let outIndex = segmentIds[start];
  while (true) {
    let nextIndex = 0;
    if (end < numIndices) {
      nextIndex = segmentIds[end];
      if (outIndex === nextIndex) {
        ++end;
        continue;
      }
      if (outIndex >= nextIndex) {
        throw new Error(`segment ids are not increasing`);
      }
    }
    if (outIndex < 0 || outIndex >= outputRows) {
      throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);
    }
    if (outIndex > uninitializedIndex) {
      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
    }
    for (let i2 = start; i2 < end; ++i2) {
      const index = indices[i2];
      if (index < 0 || index >= inputFlat[0]) {
        throw new Error(`Bad: indices[${i2}] == ${indices[i2]} out of range [0, ${inputFlat[0]})`);
      }
      for (let j2 = 0; j2 < numCol; j2++) {
        output[outIndex * numCol + j2] += input2[index * numCol + j2];
      }
    }
    if (isMean) {
      for (let j2 = 0; j2 < numCol; j2++) {
        output[outIndex * numCol + j2] /= end - start;
      }
    }
    start = end;
    ++end;
    uninitializedIndex = outIndex + 1;
    outIndex = nextIndex;
    if (end > numIndices) {
      break;
    }
  }
  if (uninitializedIndex < outputRows) {
    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
  }
  return [output, outputShape];
}
var sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));
var sqrt2 = unaryKernelFunc(Sqrt, (xi) => Math.sqrt(xi));
var sqrtConfig = {
  kernelName: Sqrt,
  backendName: "cpu",
  kernelFunc: sqrt2
};
var squaredDifferenceImpl = createSimpleBinaryKernelImpl((a6, b2) => {
  const diff = a6 - b2;
  return diff * diff;
});
var squaredDifference2 = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);
var squaredDifferenceConfig = {
  kernelName: SquaredDifference,
  backendName: "cpu",
  kernelFunc: squaredDifference2
};
function stridedSliceImpl(outShape, xBuf, strides, begin) {
  const outBuf = buffer(outShape, xBuf.dtype);
  for (let i2 = 0; i2 < outBuf.size; i2++) {
    const loc = outBuf.indexToLoc(i2);
    const newLoc = new Array(loc.length);
    for (let j2 = 0; j2 < newLoc.length; j2++) {
      newLoc[j2] = loc[j2] * strides[j2] + begin[j2];
    }
    outBuf.set(xBuf.get(...newLoc), ...loc);
  }
  return outBuf;
}
var StringNGramsOp = class {
  constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    this.separator = util_exports.encodeString(separator);
    this.nGramWidths = nGramWidths;
    this.leftPad = util_exports.encodeString(leftPad);
    this.rightPad = util_exports.encodeString(rightPad2);
    this.padWidth = padWidth;
    this.preserveShort = preserveShortSequences;
  }
  getPadWidth(nGramWidth) {
    return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
  }
  getNumNGrams(length, nGramWidth) {
    const padWidth = this.getPadWidth(nGramWidth);
    return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
  }
  createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
    for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {
      const padWidth = this.getPadWidth(nGramWidth);
      const leftPadding = Math.max(0, padWidth - nGramIndex);
      const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
      const numTokens = nGramWidth - (leftPadding + rightPadding);
      const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
      let nGramSize = 0;
      nGramSize += leftPadding * this.leftPad.length;
      for (let n2 = 0; n2 < numTokens; ++n2) {
        nGramSize += data[dataStartIndex + n2].length;
      }
      nGramSize += rightPadding * this.rightPad.length;
      const numSeparators = leftPadding + rightPadding + numTokens - 1;
      nGramSize += numSeparators * this.separator.length;
      output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
      const nGram = output[outputStartIndex + nGramIndex];
      let nextNGramIndex = 0;
      const appendToNGram = (str) => str.forEach((value) => nGram[nextNGramIndex++] = value);
      for (let n2 = 0; n2 < leftPadding; ++n2) {
        appendToNGram(this.leftPad);
        appendToNGram(this.separator);
      }
      for (let n2 = 0; n2 < numTokens - 1; ++n2) {
        appendToNGram(data[dataStartIndex + n2]);
        appendToNGram(this.separator);
      }
      if (numTokens > 0) {
        appendToNGram(data[dataStartIndex + numTokens - 1]);
        for (let n2 = 0; n2 < rightPadding; ++n2) {
          appendToNGram(this.separator);
          appendToNGram(this.rightPad);
        }
      } else {
        for (let n2 = 0; n2 < rightPadding - 1; ++n2) {
          appendToNGram(this.rightPad);
          appendToNGram(this.separator);
        }
        appendToNGram(this.rightPad);
      }
    }
  }
  compute(data, splits) {
    const inputDataSize = data.length;
    const splitsSize = splits.length;
    if (splitsSize > 0) {
      let prevSplit = splits[0];
      if (prevSplit !== 0) {
        throw new Error(`First split value must be 0, got ${prevSplit}`);
      }
      for (let i2 = 1; i2 < splitsSize; ++i2) {
        let validSplits = splits[i2] >= prevSplit;
        validSplits = validSplits && splits[i2] <= inputDataSize;
        if (!validSplits) {
          throw new Error(`Invalid split value ${splits[i2]}, must be in [${prevSplit}, ${inputDataSize}]`);
        }
        prevSplit = splits[i2];
      }
      if (prevSplit !== inputDataSize) {
        throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
      }
    }
    const numBatchItems = splitsSize - 1;
    const nGramsSplits = util_exports.getArrayFromDType("int32", splitsSize);
    if (inputDataSize === 0 || splitsSize === 0) {
      const empty = new Array(inputDataSize);
      for (let i2 = 0; i2 <= numBatchItems; ++i2) {
        nGramsSplits[i2] = 0;
      }
      return [empty, nGramsSplits];
    }
    nGramsSplits[0] = 0;
    for (let i2 = 1; i2 <= numBatchItems; ++i2) {
      const length = splits[i2] - splits[i2 - 1];
      let numNGrams = 0;
      this.nGramWidths.forEach((nGramWidth) => {
        numNGrams += this.getNumNGrams(length, nGramWidth);
      });
      if (this.preserveShort && length > 0 && numNGrams === 0) {
        numNGrams = 1;
      }
      nGramsSplits[i2] = nGramsSplits[i2 - 1] + numNGrams;
    }
    const nGrams = new Array(nGramsSplits[numBatchItems]);
    for (let i2 = 0; i2 < numBatchItems; ++i2) {
      const splitIndex = splits[i2];
      let outputStartIdx = nGramsSplits[i2];
      this.nGramWidths.forEach((nGramWidth) => {
        const length = splits[i2 + 1] - splits[i2];
        const numNGrams = this.getNumNGrams(length, nGramWidth);
        this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
        outputStartIdx += numNGrams;
      });
      if (this.preserveShort && outputStartIdx === nGramsSplits[i2]) {
        const dataLength = splits[i2 + 1] - splits[i2];
        if (dataLength === 0) {
          continue;
        }
        const nGramWidth = dataLength + 2 * this.padWidth;
        const numNGrams = 1;
        this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
      }
    }
    return [nGrams, nGramsSplits];
  }
};
function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
  return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
}
function split3(str, delimiters, skipEmpty, result) {
  if (!str.length) {
    return;
  }
  if (delimiters.length === 0) {
    for (let i2 = 0; i2 < str.length; ++i2) {
      result.push(str.subarray(i2, i2 + 1));
    }
    return;
  }
  if (delimiters.length === 1) {
    const delimiter = delimiters[0];
    let f2 = str.indexOf(delimiter);
    while (f2 !== -1) {
      const token = str.subarray(0, f2);
      if (!skipEmpty || token.length !== 0) {
        result.push(token);
      }
      str = str.subarray(f2 + 1);
      f2 = str.indexOf(delimiter);
    }
    if (!skipEmpty || str.length !== 0) {
      result.push(str);
    }
    return;
  }
  let tokenStart = 0;
  for (let i2 = 0; i2 < str.length + 1; i2++) {
    if (i2 === str.length || delimiters.indexOf(str[i2]) !== -1) {
      const token = str.subarray(tokenStart, i2);
      if (!skipEmpty || token.length !== 0) {
        result.push(token);
      }
      tokenStart = i2 + 1;
    }
  }
}
function stringSplitImpl(input2, delimiter, skipEmpty) {
  const batchSize = input2.length;
  const tokens = [];
  let outputSize2 = 0;
  let maxNumEntries = 0;
  const numIndices = new Array(batchSize);
  for (let i2 = 0; i2 < batchSize; ++i2) {
    const prevTokensLength = tokens.length;
    split3(input2[i2], delimiter, skipEmpty, tokens);
    const nEntries = tokens.length - prevTokensLength;
    numIndices[i2] = nEntries;
    outputSize2 += nEntries;
    maxNumEntries = Math.max(maxNumEntries, nEntries);
  }
  const indices = util_exports.getArrayFromDType("int32", outputSize2 * 2);
  const values = new Array(outputSize2);
  const shape = [batchSize, maxNumEntries];
  let c2 = 0;
  for (let i2 = 0; i2 < batchSize; ++i2) {
    for (let j2 = 0; j2 < numIndices[i2]; ++j2) {
      indices[c2 * 2] = i2;
      indices[c2 * 2 + 1] = j2;
      values[c2] = tokens[c2];
      ++c2;
    }
  }
  return [indices, values, shape];
}
function stringToHashBucketFastImpl(input2, numBuckets) {
  const output = util_exports.getArrayFromDType("int32", input2.length);
  for (let i2 = 0; i2 < input2.length; ++i2) {
    output[i2] = util_exports.fingerPrint64(input2[i2]).modulo(numBuckets).getLowBitsUnsigned();
  }
  return output;
}
var subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
var subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
  return { real: aReal - bReal, imag: aImag - bImag };
});
var sub2 = binaryKernelFunc(Sub, subImpl, subComplexImpl);
var subConfig = {
  kernelName: Sub,
  backendName: "cpu",
  kernelFunc: sub2
};
function tileImpl(xBuf, reps) {
  const newShape = new Array(xBuf.rank);
  for (let i2 = 0; i2 < newShape.length; i2++) {
    newShape[i2] = xBuf.shape[i2] * reps[i2];
  }
  const result = buffer(newShape, xBuf.dtype);
  for (let i2 = 0; i2 < result.values.length; ++i2) {
    const newLoc = result.indexToLoc(i2);
    const originalLoc = new Array(xBuf.rank);
    for (let j2 = 0; j2 < originalLoc.length; j2++) {
      originalLoc[j2] = newLoc[j2] % xBuf.shape[j2];
    }
    const originalIndex = xBuf.locToIndex(originalLoc);
    result.values[i2] = xBuf.values[originalIndex];
  }
  return result;
}
var comparePair = (a6, b2) => {
  const valueDiff = b2.value - a6.value;
  return valueDiff === 0 ? a6.index - b2.index : valueDiff;
};
function select(array2, k3, left = 0, right = array2.length - 1) {
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const i22 = k3 - left + 1;
      const z2 = Math.log(n2);
      const s2 = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * Math.sign(i22 - n2 / 2);
      const newLeft = Math.max(left, Math.floor(k3 - i22 * s2 / n2 + sd));
      const newRight = Math.min(right, Math.floor(k3 + (n2 - i22) * s2 / n2 + sd));
      select(array2, k3, newLeft, newRight);
    }
    const t2 = array2[k3];
    let i2 = left;
    let j2 = right;
    util_exports.swap(array2, left, k3);
    if (comparePair(array2[right], t2) > 0) {
      util_exports.swap(array2, left, right);
    }
    while (i2 < j2) {
      util_exports.swap(array2, i2, j2);
      i2++;
      j2--;
      while (comparePair(array2[i2], t2) < 0) {
        i2 = i2 + 1;
      }
      while (comparePair(array2[j2], t2) > 0) {
        j2 = j2 - 1;
      }
    }
    if (comparePair(array2[left], t2) === 0) {
      util_exports.swap(array2, left, j2);
    } else {
      j2 = j2 + 1;
      util_exports.swap(array2, j2, right);
    }
    if (j2 <= k3) {
      left = j2 + 1;
    }
    if (k3 <= j2) {
      right = j2 - 1;
    }
  }
}
function topKImpl(x2, xShape, xDtype, k3, sorted) {
  const lastDim = xShape[xShape.length - 1];
  const [batch, size2] = [x2.length / lastDim, lastDim];
  const allTopKVals = util_exports.getTypedArrayFromDType(xDtype, batch * k3);
  const allTopKIndices = util_exports.getTypedArrayFromDType("int32", batch * k3);
  for (let b2 = 0; b2 < batch; b2++) {
    const offset = b2 * size2;
    const vals = x2.subarray(offset, offset + size2);
    let valAndInd = new Array(vals.length);
    vals.forEach((value, index) => valAndInd[index] = { value, index });
    if (k3 < valAndInd.length) {
      select(valAndInd, k3);
      valAndInd = valAndInd.slice(0, k3);
    }
    if (sorted) {
      valAndInd.sort(comparePair);
    }
    const outOffset = b2 * k3;
    const topKVals = allTopKVals.subarray(outOffset, outOffset + k3);
    const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k3);
    for (let i2 = 0; i2 < k3; i2++) {
      topKVals[i2] = valAndInd[i2].value;
      topKIndices[i2] = valAndInd[i2].index;
    }
  }
  const outputShape = xShape.slice();
  outputShape[outputShape.length - 1] = k3;
  return [
    buffer(outputShape, xDtype, allTopKVals),
    buffer(outputShape, "int32", allTopKIndices)
  ];
}
function uniqueImpl(values, axis, shape, dtype) {
  const $axis = util_exports.parseAxisParam(axis, shape)[0];
  const newShape = [1, shape[0], 1];
  for (let i2 = 0; i2 < $axis; i2++) {
    newShape[0] *= shape[i2];
  }
  newShape[1] = shape[$axis];
  for (let i2 = $axis + 1; i2 < shape.length; i2++) {
    newShape[2] *= shape[i2];
  }
  const uniqueElements = {};
  const indices = new Int32Array(shape[$axis]);
  const inputBuffer = new TensorBuffer(newShape, dtype, values);
  const uniqueIndices = [];
  const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
  for (let i2 = 0; i2 < shape[$axis]; i2++) {
    let element;
    if (is1DTensor) {
      element = values[i2].toString();
    } else {
      const axisValues = [];
      for (let m2 = 0; m2 < newShape[0]; m2++) {
        for (let n2 = 0; n2 < newShape[2]; n2++) {
          axisValues.push(inputBuffer.get(m2, i2, n2));
        }
      }
      element = axisValues.join(",");
    }
    if (uniqueElements[element] !== void 0) {
      indices[i2] = uniqueElements[element];
    } else {
      const uniqueIndex = Object.keys(uniqueElements).length;
      uniqueElements[element] = uniqueIndex;
      indices[i2] = uniqueIndex;
      uniqueIndices.push(i2);
    }
  }
  const outputTmpShape = newShape.slice();
  outputTmpShape[1] = Object.keys(uniqueElements).length;
  const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
  uniqueIndices.forEach((uniqueElementIndex, i2) => {
    for (let m2 = 0; m2 < newShape[0]; m2++) {
      for (let n2 = 0; n2 < newShape[2]; n2++) {
        outputBuffer.set(inputBuffer.get(m2, uniqueElementIndex, n2), m2, i2, n2);
      }
    }
  });
  const outputShape = shape.slice();
  outputShape[$axis] = outputTmpShape[1];
  return {
    outputValues: outputBuffer.values,
    outputShape,
    indices
  };
}
registerBackend("cpu", () => new MathBackendCPU(), 1);
var elu4 = unaryKernelFunc(Elu, (xi) => xi >= 0 ? xi : Math.exp(xi) - 1);
var eluConfig = {
  kernelName: Elu,
  backendName: "cpu",
  kernelFunc: elu4
};
function leakyRelu2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { alpha } = attrs;
  assertNotComplex([x2], "leakyRelu");
  const xSize = util_exports.sizeFromShape(x2.shape);
  const xVals = backend22.data.get(x2.dataId).values;
  const outVals = util_exports.getTypedArrayFromDType("float32", xSize);
  for (let i2 = 0; i2 < xVals.length; i2++) {
    outVals[i2] = xVals[i2] < 0 ? alpha * xVals[i2] : xVals[i2];
  }
  return backend22.makeTensorInfo(x2.shape, "float32", outVals);
}
var leakyReluConfig = {
  kernelName: LeakyRelu,
  backendName: "cpu",
  kernelFunc: leakyRelu2
};
var preluImpl = createSimpleBinaryKernelImpl((xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);
function prelu3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2, alpha } = inputs;
  assertNotComplex([x2, alpha], "prelu");
  const aVals = backend22.data.get(x2.dataId).values;
  const bVals = backend22.data.get(alpha.dataId).values;
  const [resultData, resultShape] = preluImpl(x2.shape, alpha.shape, aVals, bVals, x2.dtype);
  return backend22.makeTensorInfo(resultShape, x2.dtype, resultData);
}
var preluConfig = {
  kernelName: Prelu,
  backendName: "cpu",
  kernelFunc: prelu3
};
var relu2 = unaryKernelFunc(Relu, (xi) => Math.max(0, xi));
var reluConfig = {
  kernelName: Relu,
  backendName: "cpu",
  kernelFunc: relu2
};
var relu62 = unaryKernelFunc(Relu6, (xi) => Math.min(Math.max(0, xi), 6));
var relu6Config = {
  kernelName: Relu6,
  backendName: "cpu",
  kernelFunc: relu62
};
function applyActivation2(backend22, x2, activation2, preluActivationWeights, leakyreluAlpha) {
  if (activation2 === "linear") {
    return identity2({ inputs: { x: x2 }, backend: backend22 });
  } else if (activation2 === "relu") {
    return relu2({ inputs: { x: x2 }, backend: backend22 });
  } else if (activation2 === "elu") {
    return elu4({ inputs: { x: x2 }, backend: backend22 });
  } else if (activation2 === "relu6") {
    return relu62({ inputs: { x: x2 }, backend: backend22 });
  } else if (activation2 === "prelu") {
    return prelu3({ inputs: { x: x2, alpha: preluActivationWeights }, backend: backend22 });
  } else if (activation2 === "leakyrelu") {
    return leakyRelu2({ inputs: { x: x2 }, backend: backend22, attrs: { alpha: leakyreluAlpha } });
  } else if (activation2 === "sigmoid") {
    return sigmoid2({ inputs: { x: x2 }, backend: backend22 });
  }
  throw new Error(`Activation ${activation2} has not been implemented for the CPU backend.`);
}
function reshape3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { shape } = attrs;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const $shape = util_exports.inferFromImplicitShape(shape, xSize);
  const $xSize = util_exports.sizeFromShape($shape);
  util_exports.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x2.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
  backend22.incRef(x2.dataId);
  const xData = backend22.data.get(x2.dataId);
  if (xData.complexTensorInfos != null) {
    const real5 = xData.complexTensorInfos.real;
    const imag5 = xData.complexTensorInfos.imag;
    real5.shape = $shape;
    imag5.shape = $shape;
  }
  return { dataId: x2.dataId, shape: $shape, dtype: x2.dtype };
}
var reshapeConfig = {
  kernelName: Reshape,
  backendName: "cpu",
  kernelFunc: reshape3
};
function batchMatMul(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2 } = inputs;
  const { transposeA, transposeB } = attrs;
  assertNotComplex([a6, b2], "matMul");
  const aRank = a6.shape.length;
  const bRank = b2.shape.length;
  const innerShapeA = transposeA ? a6.shape[aRank - 2] : a6.shape[aRank - 1];
  const innerShapeB = transposeB ? b2.shape[bRank - 1] : b2.shape[bRank - 2];
  const outerShapeA = transposeA ? a6.shape[aRank - 1] : a6.shape[aRank - 2];
  const outerShapeB = transposeB ? b2.shape[bRank - 2] : b2.shape[bRank - 1];
  const outerDimsA = a6.shape.slice(0, -2);
  const outerDimsB = b2.shape.slice(0, -2);
  const batchDimA = util_exports.sizeFromShape(outerDimsA);
  const batchDimB = util_exports.sizeFromShape(outerDimsB);
  const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
  util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
  const outShapeOuterDims = batchDimA > batchDimB ? a6.shape.slice(0, -2) : b2.shape.slice(0, -2);
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a6.shape} and ${b2.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape3({ inputs: { x: a6 }, backend: backend22, attrs: { shape: a3dShape } });
  const b3d = reshape3({ inputs: { x: b2 }, backend: backend22, attrs: { shape: b3dShape } });
  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
  const batchDim = Math.max(batchDimA, batchDimB);
  const a3dValues = backend22.data.get(a3d.dataId).values;
  const b3dValues = backend22.data.get(b3d.dataId).values;
  const a3dStrides = util_exports.computeStrides(a3d.shape);
  const b3dStrides = util_exports.computeStrides(b3d.shape);
  const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];
  const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];
  const size2 = leftDim * rightDim;
  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);
  const resVals = result.values;
  const blockSize = backend22.blockSize;
  for (let bi = 0; bi < batchDim; bi++) {
    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {
      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {
        for (let k02 = 0; k02 < sharedDim; k02 += blockSize) {
          const iBlock = Math.min(i0 + blockSize, leftDim);
          const jBlock = Math.min(j0 + blockSize, rightDim);
          const kBlock = Math.min(k02 + blockSize, sharedDim);
          for (let i2 = i0; i2 < iBlock; i2++) {
            for (let j2 = j0; j2 < jBlock; j2++) {
              let sum7 = 0;
              for (let k3 = k02; k3 < kBlock; k3++) {
                const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;
                const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;
                const aVal = a3dValues[batchOffsetA + i2 * aOuterStep + k3 * aInnerStep];
                const bVal = b3dValues[k3 * bInnerStep + j2 * bOuterStep + batchOffsetB];
                sum7 += aVal * bVal;
              }
              resVals[bi * size2 + (i2 * rightDim + j2)] += sum7;
            }
          }
        }
      }
    }
  }
  backend22.disposeIntermediateTensorInfo(a3d);
  backend22.disposeIntermediateTensorInfo(b3d);
  return backend22.makeTensorInfo(outShape, result.dtype, result.values);
}
var batchMatMulConfig = {
  kernelName: BatchMatMul,
  backendName: "cpu",
  kernelFunc: batchMatMul
};
function _fusedMatMul(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  let current;
  let addRes;
  let activationRes;
  const intermediates = [];
  const matMulRes = batchMatMul({ inputs: { a: a6, b: b2 }, attrs: { transposeA, transposeB }, backend: backend22 });
  current = matMulRes;
  if (bias) {
    addRes = add4({ inputs: { a: current, b: bias }, backend: backend22 });
    intermediates.push(current);
    current = addRes;
  }
  if (activation2) {
    activationRes = applyActivation2(backend22, current, activation2, preluActivationWeights, leakyreluAlpha);
    intermediates.push(current);
    current = activationRes;
  }
  for (const i2 of intermediates) {
    backend22.disposeIntermediateTensorInfo(i2);
  }
  return current;
}
var _fusedMatMulConfig = {
  kernelName: _FusedMatMul,
  backendName: "cpu",
  kernelFunc: _fusedMatMul
};
var acos2 = unaryKernelFunc(Acos, (xi) => Math.acos(xi));
var acosConfig = {
  kernelName: Acos,
  backendName: "cpu",
  kernelFunc: acos2
};
var acosh2 = unaryKernelFunc(Acosh, (xi) => Math.acosh(xi));
var acoshConfig = {
  kernelName: Acosh,
  backendName: "cpu",
  kernelFunc: acosh2
};
function addN2(args) {
  const { inputs, backend: backend22 } = args;
  const tensors = inputs;
  assertNotComplex(inputs, "addN");
  const vals = tensors.map((t2) => backend22.data.get(t2.dataId).values);
  const outBuf = buffer(tensors[0].shape, tensors[0].dtype);
  const outVals = outBuf.values;
  for (let i2 = 0; i2 < tensors.length; i2++) {
    const currVals = vals[i2];
    for (let j2 = 0; j2 < outVals.length; j2++) {
      outVals[j2] += currVals[j2];
    }
  }
  return backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var addNConfig = {
  kernelName: AddN,
  backendName: "cpu",
  kernelFunc: addN2
};
function all2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x2, "all");
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  if (permutedAxes != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, x2.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("all", axes, $x.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const vals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), $x.dtype);
  const aVals = backend22.data.get($x.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let all52 = aVals[offset];
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      all52 = all52 && value;
    }
    vals[i2] = all52;
  }
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo($x);
  }
  const result = backend22.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: expandedShape } });
    backend22.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var allConfig = {
  kernelName: All,
  backendName: "cpu",
  kernelFunc: all2
};
function any2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x2, "any");
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  if (permutedAxes != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, x2.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("any", axes, $x.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const vals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), $x.dtype);
  const aVals = backend22.data.get($x.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let anyVal = aVals[offset];
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      anyVal = anyVal || value;
    }
    vals[i2] = anyVal;
  }
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo($x);
  }
  const result = backend22.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: expandedShape } });
    backend22.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var anyConfig = {
  kernelName: Any,
  backendName: "cpu",
  kernelFunc: any2
};
function argMax2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  assertNotComplex(x2, "argMax");
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  axes = [axes[0]];
  backend_util_exports.assertAxesAreInnerMostDims("argMax", axes, $x.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
  const outSize = util_exports.sizeFromShape(outShape);
  const vals = util_exports.makeZerosTypedArray(outSize, "int32");
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const aVals = backend22.data.get($x.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let max7 = aVals[offset];
    let maxIndex = 0;
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      if (value > max7) {
        max7 = value;
        maxIndex = j2;
      }
    }
    vals[i2] = maxIndex;
  }
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return backend22.makeTensorInfo(outShape, "int32", vals);
}
var argMaxConfig = {
  kernelName: ArgMax,
  backendName: "cpu",
  kernelFunc: argMax2
};
function argMin2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  assertNotComplex(x2, "argMin");
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  axes = [axes[0]];
  backend_util_exports.assertAxesAreInnerMostDims("argMin", axes, $x.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
  const outSize = util_exports.sizeFromShape(outShape);
  const vals = util_exports.makeZerosTypedArray(outSize, "int32");
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const aVals = backend22.data.get($x.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let min7 = aVals[offset];
    let minIndex = 0;
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      if (value < min7) {
        min7 = value;
        minIndex = j2;
      }
    }
    vals[i2] = minIndex;
  }
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return backend22.makeTensorInfo(outShape, "int32", vals);
}
var argMinConfig = {
  kernelName: ArgMin,
  backendName: "cpu",
  kernelFunc: argMin2
};
var asin2 = unaryKernelFunc(Asin, (xi) => Math.asin(xi));
var asinConfig = {
  kernelName: Asin,
  backendName: "cpu",
  kernelFunc: asin2
};
var asinh2 = unaryKernelFunc(Asinh, (xi) => Math.asinh(xi));
var asinhConfig = {
  kernelName: Asinh,
  backendName: "cpu",
  kernelFunc: asinh2
};
var atan3 = unaryKernelFunc(Atan, (xi) => Math.atan(xi));
var atanConfig = {
  kernelName: Atan,
  backendName: "cpu",
  kernelFunc: atan3
};
var atan2Impl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.atan2(aValue, bValue));
var atan22 = binaryKernelFunc(Atan2, atan2Impl);
var atan2Config = {
  kernelName: Atan2,
  backendName: "cpu",
  kernelFunc: atan22
};
var atanh2 = unaryKernelFunc(Atanh, (xi) => Math.atanh(xi));
var atanhConfig = {
  kernelName: Atanh,
  backendName: "cpu",
  kernelFunc: atanh2
};
function pool2(xValues, xShape, dtype, strides, convInfo, poolType) {
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  const output = buffer(convInfo.outShape, dtype);
  const outputVals = output.values;
  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];
  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];
  const outputColStrides = convInfo.outShape[3];
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    const outputBatchOffset = b2 * outputBatchStrides;
    const inputBatchOffset = b2 * strides[0];
    for (let d2 = 0; d2 < convInfo.inChannels; ++d2) {
      for (let yR = 0; yR < convInfo.outHeight; ++yR) {
        const xRCorner = yR * strideHeight - padTop;
        const xRMin = Math.max(0, xRCorner);
        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;
        for (let yC = 0; yC < convInfo.outWidth; ++yC) {
          const xCCorner = yC * strideWidth - padLeft;
          const xCMin = Math.max(0, xCCorner);
          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
          let minMaxValue = initialValue;
          let avgValue = 0;
          let count22 = 0;
          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
            const xROffset = inputBatchOffset + xR * strides[1];
            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
              const xCOffset = xROffset + xC * strides[2];
              const pixel = xValues[xCOffset + d2];
              if (poolType === "max" && pixel > minMaxValue) {
                minMaxValue = pixel;
              } else if (poolType === "avg") {
                avgValue += pixel;
                count22++;
              }
            }
            if (isNaN(minMaxValue)) {
              break;
            }
          }
          const outputOffset = outputRowOffset + yC * outputColStrides + d2;
          outputVals[outputOffset] = poolType === "avg" ? avgValue / count22 : minMaxValue;
        }
      }
    }
  }
  return output;
}
function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {
  const maxPositions = buffer(convInfo.outShape, "int32");
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const xBuf = buffer(xShape, dtype, xValues);
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    for (let d2 = 0; d2 < convInfo.inChannels; ++d2) {
      for (let yR = 0; yR < convInfo.outHeight; ++yR) {
        const xRCorner = yR * strideHeight - padTop;
        let xRMin = xRCorner;
        while (xRMin < 0) {
          xRMin += dilationHeight;
        }
        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
        for (let yC = 0; yC < convInfo.outWidth; ++yC) {
          const xCCorner = yC * strideWidth - padLeft;
          let xCMin = xCCorner;
          while (xCMin < 0) {
            xCMin += dilationWidth;
          }
          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
          let maxValue = Number.NEGATIVE_INFINITY;
          let maxPosition = -1;
          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
            const wR = xR - xRCorner;
            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
              const wC = xC - xCCorner;
              const pixel = xBuf.get(b2, xR, xC, d2);
              if (pixel > maxValue) {
                maxValue = pixel;
                if (flattenPositions) {
                  maxPosition = includeBatchInIndex ? ((b2 * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d2 : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d2;
                } else {
                  maxPosition = wR * effectiveFilterWidth + wC;
                }
              }
            }
          }
          maxPositions.set(maxPosition, b2, yR, yC, d2);
        }
      }
    }
  }
  return maxPositions;
}
function pool3d2(xValues, xShape, dtype, strides, convInfo, poolType) {
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = convInfo.padInfo.front;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  const output = buffer(convInfo.outShape, dtype);
  const outputVals = output.values;
  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
  const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];
  const outputColStrides = convInfo.outShape[4];
  for (let batch = 0; batch < convInfo.batchSize; ++batch) {
    const outputBatchOffset = batch * outputBatchStrides;
    const inputBatchOffset = batch * strides[0];
    for (let channel = 0; channel < convInfo.inChannels; ++channel) {
      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
        const xDepthCorner = yDepth * strideDepth - padFront;
        let xDepthMin = xDepthCorner;
        while (xDepthMin < 0) {
          xDepthMin += dilationDepth;
        }
        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
        const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;
        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
          const xRowCorner = yRow * strideHeight - padTop;
          let xRowMin = xRowCorner;
          while (xRowMin < 0) {
            xRowMin += dilationHeight;
          }
          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;
          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
            const xColCorner = yCol * strideWidth - padLeft;
            let xColMin = xColCorner;
            while (xColMin < 0) {
              xColMin += dilationWidth;
            }
            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
            const outputColOffset = outputRowOffset + yCol * outputColStrides;
            let minMaxValue = initialValue;
            let avgValue = 0;
            let count22 = 0;
            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
              const xDepthOffset = inputBatchOffset + xDepth * strides[1];
              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                const xRowOffset = xDepthOffset + xRow * strides[2];
                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                  const xColOffset = xRowOffset + xCol * strides[3];
                  const pixel = xValues[xColOffset + channel];
                  if (poolType === "max" && pixel > minMaxValue) {
                    minMaxValue = pixel;
                  } else if (poolType === "avg") {
                    avgValue += pixel;
                    count22++;
                  }
                  if (isNaN(minMaxValue)) {
                    break;
                  }
                }
                if (isNaN(minMaxValue)) {
                  break;
                }
              }
              if (isNaN(minMaxValue)) {
                break;
              }
            }
            const outputOffset = outputColOffset + channel;
            outputVals[outputOffset] = poolType === "avg" ? avgValue / count22 : minMaxValue;
          }
        }
      }
    }
  }
  return output;
}
function maxPool3dPositions(xBuf, convInfo) {
  const maxPositions = buffer(convInfo.outShape, "int32");
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = convInfo.padInfo.front;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  for (let batch = 0; batch < convInfo.batchSize; ++batch) {
    for (let channel = 0; channel < convInfo.inChannels; ++channel) {
      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
        const xDepthCorner = yDepth * strideDepth - padFront;
        let xDepthMin = xDepthCorner;
        while (xDepthMin < 0) {
          xDepthMin += dilationDepth;
        }
        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
          const xRowCorner = yRow * strideHeight - padTop;
          let xRowMin = xRowCorner;
          while (xRowMin < 0) {
            xRowMin += dilationHeight;
          }
          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
            const xColCorner = yCol * strideWidth - padLeft;
            let xColMin = xColCorner;
            while (xColMin < 0) {
              xColMin += dilationWidth;
            }
            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
            let maxValue = Number.NEGATIVE_INFINITY;
            let maxPosition = -1;
            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
              const wDepth = xDepth - xDepthCorner;
              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                const wRow = xRow - xRowCorner;
                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                  const wCol = xCol - xColCorner;
                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);
                  if (pixel >= maxValue) {
                    maxValue = pixel;
                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;
                  }
                }
              }
            }
            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);
          }
        }
      }
    }
  }
  return maxPositions;
}
function avgPool2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  assertNotComplex(x2, "avgPool");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  let res2;
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    res2 = identity2({ inputs: { x: x2 }, backend: backend22 });
  } else {
    const xValues = backend22.data.get(x2.dataId).values;
    const strides2 = util_exports.computeStrides(x2.shape);
    const buffer2 = pool2(xValues, x2.shape, x2.dtype, strides2, convInfo, "avg");
    res2 = backend22.makeTensorInfo(convInfo.outShape, x2.dtype, buffer2.values);
  }
  return res2;
}
var avgPoolConfig = {
  kernelName: AvgPool,
  backendName: "cpu",
  kernelFunc: avgPool2
};
function avgPool3D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
  assertNotComplex(x2, "avgPool3d");
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode, dataFormat);
  const xValues = backend22.data.get(x2.dataId).values;
  const outBuf = pool3d2(xValues, x2.shape, x2.dtype, util_exports.computeStrides(x2.shape), convInfo, "avg");
  return backend22.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
}
var avgPool3DConfig = {
  kernelName: AvgPool3D,
  backendName: "cpu",
  kernelFunc: avgPool3D
};
function avgPool3DGrad(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  assertNotComplex([dy, input2], "avgPool3DGrad");
  const convInfo = backend_util_exports.computePool3DInfo(input2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterDepth = convInfo.filterDepth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(input2.shape, "float32");
  const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
  const dyBuf = backend22.bufferSync(dy);
  for (let batch = 0; batch < convInfo.batchSize; ++batch) {
    for (let channel = 0; channel < convInfo.inChannels; ++channel) {
      for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
        for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
          for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
            const dyDepthCorner = dxDepth - padFront;
            const dyRowCorner = dxRow - padTop;
            const dyColCorner = dxCol - padLeft;
            let dotProd = 0;
            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
              const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
              if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                continue;
              }
              for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                const dyRow = (dyRowCorner + wRow) / strideHeight;
                if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                  continue;
                }
                for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                  const dyCol = (dyColCorner + wCol) / strideWidth;
                  if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                    continue;
                  }
                  const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  dotProd += pixel;
                }
              }
            }
            dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var avgPool3DGradConfig2 = {
  kernelName: AvgPool3DGrad,
  backendName: "cpu",
  kernelFunc: avgPool3DGrad
};
function avgPoolGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const x2 = input2;
  assertNotComplex([dy, input2], "avgPoolGrad");
  const { filterSize, strides, pad: pad3 } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3);
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(x2.shape, "float32");
  const avgMultiplier = 1 / (filterHeight * filterWidth);
  const dyData = backend22.data.get(dy.dataId).values;
  const dyBuf = buffer(dy.shape, "float32", dyData);
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    for (let d2 = 0; d2 < convInfo.inChannels; ++d2) {
      for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
        for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
          const dyRCorner = dxR - padTop;
          const dyCCorner = dxC - padLeft;
          let dotProd = 0;
          for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
            const dyR = (dyRCorner + wR) / strideHeight;
            if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
              continue;
            }
            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
              const dyC = (dyCCorner + wC) / strideWidth;
              if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                continue;
              }
              const pixel = dyBuf.get(b2, dyR, dyC, d2);
              dotProd += pixel;
            }
          }
          dx.set(dotProd * avgMultiplier, b2, dxR, dxC, d2);
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var avgPoolGradConfig2 = {
  kernelName: AvgPoolGrad,
  backendName: "cpu",
  kernelFunc: avgPoolGrad2
};
function batchNorm2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, scale: scale22, offset, mean: mean5, variance } = inputs;
  util_exports.assert(mean5.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
  util_exports.assert(offset == null || mean5.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
  util_exports.assert(scale22 == null || mean5.shape.length === scale22.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  assertNotComplex([x2, mean5, variance, scale22, offset], "batchNorm");
  let { varianceEpsilon } = attrs;
  if (varianceEpsilon == null) {
    varianceEpsilon = 1e-3;
  }
  const xVals = backend22.data.get(x2.dataId).values;
  const mVals = backend22.data.get(mean5.dataId).values;
  const varVals = backend22.data.get(variance.dataId).values;
  const sVals = scale22 ? backend22.data.get(scale22.dataId).values : new Float32Array([1]);
  const offVals = offset ? backend22.data.get(offset.dataId).values : new Float32Array([0]);
  const outVals = new Float32Array(xVals.length);
  const offValsLength = offVals.length;
  const sValsLength = sVals.length;
  const varValsLength = varVals.length;
  const mValsLength = mVals.length;
  let offi = 0;
  let mi = 0;
  let si = 0;
  let vi = 0;
  for (let i2 = 0; i2 < xVals.length; ++i2) {
    outVals[i2] = offVals[offi++] + (xVals[i2] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);
    if (offi >= offValsLength) {
      offi = 0;
    }
    if (mi >= mValsLength) {
      mi = 0;
    }
    if (si >= sValsLength) {
      si = 0;
    }
    if (vi >= varValsLength) {
      vi = 0;
    }
  }
  return backend22.makeTensorInfo(x2.shape, x2.dtype, outVals);
}
var batchNormConfig = {
  kernelName: FusedBatchNorm,
  backendName: "cpu",
  kernelFunc: batchNorm2
};
function batchToSpaceND2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, crops } = attrs;
  assertNotComplex([x2], "batchToSpaceND");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const reshaped = backend_util_exports.getReshaped(x2.shape, blockShape, prod6);
  const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = backend_util_exports.getReshapedPermuted(x2.shape, blockShape, prod6);
  const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const xReshaped = reshape3({ inputs: { x: x2 }, backend: backend22, attrs: { shape: reshaped } });
  const xTransposed = transpose2({ inputs: { x: xReshaped }, backend: backend22, attrs: { perm: permuted } });
  const xTransposedReshaped = reshape3({ inputs: { x: xTransposed }, backend: backend22, attrs: { shape: reshapedPermuted } });
  const result = slice2({
    inputs: { x: xTransposedReshaped },
    backend: backend22,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  backend22.disposeIntermediateTensorInfo(xReshaped);
  backend22.disposeIntermediateTensorInfo(xTransposed);
  backend22.disposeIntermediateTensorInfo(xTransposedReshaped);
  return result;
}
var batchToSpaceNDConfig = {
  kernelName: BatchToSpaceND,
  backendName: "cpu",
  kernelFunc: batchToSpaceND2
};
function bincount2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, weights } = inputs;
  const { size: size2 } = attrs;
  const xVals = backend22.data.get(x2.dataId).values;
  const weightsVals = backend22.data.get(weights.dataId).values;
  const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size2);
  return backend22.makeTensorInfo([size2], weights.dtype, outVals);
}
var bincountConfig = {
  kernelName: Bincount,
  backendName: "cpu",
  kernelFunc: bincount2
};
function broadcastArgs2(args) {
  const { inputs, backend: backend22 } = args;
  const { s0, s1 } = inputs;
  const s0Vals = backend22.data.get(s0.dataId).values;
  const s1Vals = backend22.data.get(s1.dataId).values;
  const broadcastShape = backend_util_exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
  return backend22.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
}
var broadcastArgsConfig = {
  kernelName: BroadcastArgs,
  backendName: "cpu",
  kernelFunc: broadcastArgs2
};
var clip = unaryKernelFunc(ClipByValue, (xi, attrs) => {
  const clipAttrs = attrs;
  if (xi > clipAttrs.clipValueMax) {
    return clipAttrs.clipValueMax;
  }
  return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;
});
var clipConfig = {
  kernelName: ClipByValue,
  backendName: "cpu",
  kernelFunc: clip
};
var complexAbs = (args) => {
  const { x: x2 } = args.inputs;
  const cpuBackend = args.backend;
  const resultValues = new Float32Array(util_exports.sizeFromShape(x2.shape));
  const complexVals = cpuBackend.data.get(x2.dataId);
  const real5 = complexVals.complexTensorInfos.real;
  const imag5 = complexVals.complexTensorInfos.imag;
  const realVals = cpuBackend.data.get(real5.dataId).values;
  const imagVals = cpuBackend.data.get(imag5.dataId).values;
  for (let i2 = 0; i2 < realVals.length; i2++) {
    const real6 = realVals[i2];
    const imag6 = imagVals[i2];
    resultValues[i2] = Math.hypot(real6, imag6);
  }
  return cpuBackend.makeOutput(resultValues, x2.shape, "float32");
};
var complexAbsConfig = {
  kernelName: ComplexAbs,
  backendName: "cpu",
  kernelFunc: complexAbs
};
function imag2(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const imag5 = backend22.data.get(input2.dataId).complexTensorInfos.imag;
  const imagVal = backend22.data.get(imag5.dataId).values;
  return backend22.makeTensorInfo(imag5.shape, imag5.dtype, imagVal);
}
var imagConfig = {
  kernelName: Imag,
  backendName: "cpu",
  kernelFunc: imag2
};
function concat2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, inputs[0].shape)[0];
  let outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), $axis);
  if (util_exports.sizeFromShape(outShape) === 0) {
    return backend22.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t2) => util_exports.sizeFromShape(t2.shape) > 0);
  if ($inputs.length === 1) {
    return identity2({ inputs: { x: $inputs[0] }, backend: backend22 });
  }
  const shapes = $inputs.map((t2) => t2.shape);
  backend_util_exports.assertParamsConsistent(shapes, $axis);
  if ($inputs[0].dtype === "complex64") {
    const reals = $inputs.map((t2) => real2({ inputs: { input: t2 }, backend: backend22 }));
    const imags = $inputs.map((t2) => imag2({ inputs: { input: t2 }, backend: backend22 }));
    const realConcated = concat2({ inputs: reals, backend: backend22, attrs: { axis: $axis } });
    const imagConcated = concat2({ inputs: imags, backend: backend22, attrs: { axis: $axis } });
    const result = complex2({ inputs: { real: realConcated, imag: imagConcated }, backend: backend22 });
    reals.forEach((r2) => backend22.disposeIntermediateTensorInfo(r2));
    imags.forEach((i2) => backend22.disposeIntermediateTensorInfo(i2));
    backend22.disposeIntermediateTensorInfo(realConcated);
    backend22.disposeIntermediateTensorInfo(imagConcated);
    return result;
  }
  const inputs2D = $inputs.map((t2) => {
    const innerSize = util_exports.sizeFromShape(t2.shape.slice($axis));
    const shape = [-1, innerSize];
    return reshape3({ inputs: { x: t2 }, backend: backend22, attrs: { shape } });
  });
  const inputsValShapes = inputs2D.map((t2) => {
    return { vals: backend22.data.get(t2.dataId).values, shape: t2.shape };
  });
  outShape = backend_util_exports.computeOutShape(inputs2D.map((t2) => t2.shape), 1);
  const simplyConcat = inputs2D[0].shape[0] === 1;
  const outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
  const finalOutShape = backend_util_exports.computeOutShape($inputs.map((t2) => t2.shape), $axis);
  const outInfo = backend22.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);
  inputs2D.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return outInfo;
}
var concatConfig = {
  kernelName: Concat,
  backendName: "cpu",
  kernelFunc: concat2
};
function conv2D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode } = attrs;
  assertNotComplex([x2, filter], "conv2d");
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const padLeft = convInfo.padInfo.left;
  const padTop = convInfo.padInfo.top;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const y2 = new TensorBuffer(convInfo.outShape, x2.dtype);
  const xStrides = util_exports.computeStrides(x2.shape);
  const filterStrides = util_exports.computeStrides(filter.shape);
  const xBatchStride = xStrides[0];
  const xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];
  const xColStride = isChannelsLast ? xStrides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : xStrides[1];
  const yBatchStride = y2.strides[0];
  const yRowStride = isChannelsLast ? y2.strides[1] : y2.strides[2];
  const yColStride = isChannelsLast ? y2.strides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : y2.strides[1];
  const xVals = backend22.data.get(x2.dataId).values;
  const wVals = backend22.data.get(filter.dataId).values;
  const yVals = y2.values;
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    const xOffset1 = b2 * xBatchStride;
    const yOffset1 = b2 * yBatchStride;
    for (let yR = 0; yR < convInfo.outHeight; ++yR) {
      const yOffset2 = yOffset1 + yR * yRowStride;
      const xRCorner = yR * convInfo.strideHeight - padTop;
      for (let wR = 0; wR < filterHeight; ++wR) {
        const xR = xRCorner + wR * dilationHeight;
        if (xR < 0 || xR >= convInfo.inHeight) {
          continue;
        }
        const wOffset1 = wR * filterStrides[0];
        const xOffset2 = xOffset1 + xR * xRowStride;
        for (let yC = 0; yC < convInfo.outWidth; ++yC) {
          const yOffset3 = yOffset2 + yC * yColStride;
          const xCCorner = yC * convInfo.strideWidth - padLeft;
          for (let wC = 0; wC < filterWidth; ++wC) {
            const xC = xCCorner + wC * dilationWidth;
            if (xC < 0 || xC >= convInfo.inWidth) {
              continue;
            }
            const wOffset2 = wOffset1 + wC * filterStrides[1];
            const xOffset3 = xOffset2 + xC * xColStride;
            let wOffset3 = wOffset2;
            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
              const xVal = xVals[xOffset3 + d1 * xChannelStride];
              for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];
              }
              wOffset3 += convInfo.outChannels;
            }
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(y2.shape, y2.dtype, yVals);
}
var conv2DConfig = {
  kernelName: Conv2D,
  backendName: "cpu",
  kernelFunc: conv2D
};
function conv2DBackpropFilter2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape } = attrs;
  assertNotComplex([x2, dy], "conv2dBackpropFilter");
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filterShape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
  const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const dW = new TensorBuffer(convInfo.filterShape, "float32");
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  const xVals = backend22.data.get(x2.dataId).values;
  const dyVals = backend22.data.get(dy.dataId).values;
  const xBuf = new TensorBuffer(x2.shape, x2.dtype, xVals);
  const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);
  for (let wR = 0; wR < filterHeight; ++wR) {
    const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
    const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
    for (let wC = 0; wC < filterWidth; ++wC) {
      const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
      const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
      for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
          let dotProd = 0;
          for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
            for (let yR = yRMin; yR < yRMax; ++yR) {
              const xR = wR + yR * strideHeight - topPad;
              for (let yC = yCMin; yC < yCMax; ++yC) {
                const xC = wC + yC * strideWidth - leftPad;
                if (isChannelsLast) {
                  dotProd += xBuf.get(b2, xR, xC, d1) * dyBuf.get(b2, yR, yC, d2);
                } else {
                  dotProd += xBuf.get(b2, d1, xR, xC) * dyBuf.get(b2, d2, yR, yC);
                }
              }
            }
          }
          dW.set(dotProd, wR, wC, d1, d2);
        }
      }
    }
  }
  return backend22.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
var conv2DBackpropFilterConfig = {
  kernelName: Conv2DBackpropFilter,
  backendName: "cpu",
  kernelFunc: conv2DBackpropFilter2
};
function conv2DBackpropInput2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { inputShape, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
  assertNotComplex([dy, filter], "conv2dBackpropInput");
  const filterStrides = util_exports.computeStrides(filter.shape);
  const dyStrides = util_exports.computeStrides(dy.shape);
  let $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const dyValues = backend22.data.get(dy.dataId).values;
  const fltValues = backend22.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2] = filterStrides;
  const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
  $dataFormat = convInfo.dataFormat;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const isChannelsLast = $dataFormat === "channelsLast";
  const xBatchStride = dx.strides[0];
  const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];
  const xColStride = isChannelsLast ? dx.strides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : dx.strides[1];
  const yBatchStride = dyStrides[0];
  const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
  const yColStride = isChannelsLast ? dyStrides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
  for (let b2 = 0; b2 < batchSize; ++b2) {
    for (let d1 = 0; d1 < inChannels; ++d1) {
      for (let xR = 0; xR < inHeight; ++xR) {
        const xRCorner = xR - topPad;
        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
        for (let xC = 0; xC < inWidth; ++xC) {
          const xCCorner = xC - leftPad;
          const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
          const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
          let dotProd = 0;
          for (let yR = xRMin; yR < yRMax; ++yR) {
            const wR = yR * strideHeight - xRCorner;
            for (let yC = xCMin; yC < yCMax; ++yC) {
              const wC = yC * strideWidth - xCCorner;
              const dyOffset = yBatchStride * b2 + yRowStride * yR + yColStride * yC;
              const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
              for (let d2 = 0; d2 < outChannels; ++d2) {
                const pixel = dyValues[dyOffset + yChannelStride * d2];
                const weight = fltValues[fltOffset + d2];
                dotProd += pixel * weight;
              }
            }
          }
          const dxOffset = xBatchStride * b2 + xRowStride * xR + xColStride * xC + xChannelStride * d1;
          dxValues[dxOffset] = dotProd;
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var conv2DBackpropInputConfig = {
  kernelName: Conv2DBackpropInput,
  backendName: "cpu",
  kernelFunc: conv2DBackpropInput2
};
function conv3D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations } = attrs;
  assertNotComplex([x2, filter], "conv3d");
  const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filter.shape, strides, dilations, pad3);
  const { filterDepth, filterHeight, filterWidth, dilationDepth, dilationHeight, dilationWidth, padInfo } = convInfo;
  const padFront = padInfo.front;
  const padLeft = padInfo.left;
  const padTop = padInfo.top;
  const y2 = new TensorBuffer(convInfo.outShape, x2.dtype);
  const xVals = backend22.data.get(x2.dataId).values;
  const wVals = backend22.data.get(filter.dataId).values;
  const yVals = y2.values;
  const xStrides = util_exports.computeStrides(x2.shape);
  const filterStrides = util_exports.computeStrides(filter.shape);
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    const xOffset1 = b2 * xStrides[0];
    const yOffset1 = b2 * y2.strides[0];
    for (let yF = 0; yF < convInfo.outDepth; ++yF) {
      const yOffset2 = yOffset1 + yF * y2.strides[1];
      const xFCorner = yF * convInfo.strideDepth - padFront;
      for (let wF = 0; wF < filterDepth; ++wF) {
        const xF = xFCorner + wF * dilationDepth;
        if (xF < 0 || xF >= convInfo.inDepth) {
          continue;
        }
        const wOffset1 = wF * filterStrides[0];
        const xOffset2 = xOffset1 + xF * xStrides[1];
        for (let yR = 0; yR < convInfo.outHeight; ++yR) {
          const yOffset3 = yOffset2 + yR * y2.strides[2];
          const xRCorner = yR * convInfo.strideHeight - padTop;
          for (let wR = 0; wR < filterHeight; ++wR) {
            const xR = xRCorner + wR * dilationHeight;
            if (xR < 0 || xR >= convInfo.inHeight) {
              continue;
            }
            const wOffset2 = wOffset1 + wR * filterStrides[1];
            const xOffset3 = xOffset2 + xR * xStrides[2];
            for (let yC = 0; yC < convInfo.outWidth; ++yC) {
              const yOffset4 = yOffset3 + yC * convInfo.outChannels;
              const xCCorner = yC * convInfo.strideWidth - padLeft;
              for (let wC = 0; wC < filterWidth; ++wC) {
                const xC = xCCorner + wC * dilationWidth;
                if (xC < 0 || xC >= convInfo.inWidth) {
                  continue;
                }
                const wOffset3 = wOffset2 + wC * filterStrides[2];
                const xOffset4 = xOffset3 + xC * convInfo.inChannels;
                let wOffset4 = wOffset3;
                for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                  const xVal = xVals[xOffset4 + d1];
                  for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                    yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];
                  }
                  wOffset4 += convInfo.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(y2.shape, y2.dtype, y2.values);
}
var conv3DConfig = {
  kernelName: Conv3D,
  backendName: "cpu",
  kernelFunc: conv3D
};
function conv3DBackpropFilterV2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, pad: pad3, filterShape } = attrs;
  assertNotComplex([x2, dy], "conv3dBackpropFilterV2");
  const xStrides = util_exports.computeStrides(x2.shape);
  const dyStrides = util_exports.computeStrides(dy.shape);
  const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filterShape, strides, 1, pad3);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterDepth = convInfo.filterDepth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dw = new TensorBuffer(convInfo.filterShape, "float32");
  const dwValues = dw.values;
  const [dwS0, dwS1, dwS2, dwS3] = dw.strides;
  const dyValues = backend22.data.get(dy.dataId).values;
  const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
  const xValues = backend22.data.get(x2.dataId).values;
  const [xS0, xS1, xS2, xS3] = xStrides;
  const frontPad = convInfo.padInfo.front;
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  for (let wF = 0; wF < filterDepth; ++wF) {
    const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));
    const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);
    const wOffset1 = wF * dwS0;
    for (let wR = 0; wR < filterHeight; ++wR) {
      const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
      const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
      const wOffset2 = wR * dwS1 + wOffset1;
      for (let wC = 0; wC < filterWidth; ++wC) {
        const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
        const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
        const wOffset3 = wC * dwS2 + wOffset2;
        for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
          const wOffset4 = d1 * dwS3 + wOffset3;
          for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
            let dotProd = 0;
            for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
              const xOffset1 = b2 * xS0;
              const yOffset1 = b2 * dyS0;
              for (let yF = yFMin; yF < yFMax; ++yF) {
                const xF = wF + yF * strideDepth - frontPad;
                const xOffset2 = xF * xS1 + xOffset1;
                const yOffset2 = yF * dyS1 + yOffset1;
                for (let yR = yRMin; yR < yRMax; ++yR) {
                  const xR = wR + yR * strideHeight - topPad;
                  const xOffset3 = xR * xS2 + xOffset2;
                  const yOffset3 = yR * dyS2 + yOffset2;
                  for (let yC = yCMin; yC < yCMax; ++yC) {
                    const xC = wC + yC * strideWidth - leftPad;
                    const xOffset4 = xC * xS3 + xOffset3;
                    const yOffset4 = yC * dyS3 + yOffset3;
                    dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];
                  }
                }
              }
            }
            dwValues[wOffset4 + d2] = dotProd;
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(dw.shape, dw.dtype, dw.values);
}
var conv3DBackpropFilterV2Config = {
  kernelName: Conv3DBackpropFilterV2,
  backendName: "cpu",
  kernelFunc: conv3DBackpropFilterV2
};
function conv3DBackpropInputV2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { pad: pad3, strides, inputShape } = attrs;
  assertNotComplex([dy], "conv3dBackpropInputV2");
  const dyStrides = util_exports.computeStrides(dy.shape);
  const filterStrides = util_exports.computeStrides(filter.shape);
  const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad3);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const [dxS0, dxS1, dxS2, dxS3] = dx.strides;
  const dyValues = backend22.data.get(dy.dataId).values;
  const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
  const fltValues = backend22.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2, fltS3] = filterStrides;
  const { batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth } = convInfo;
  const frontPad = filterDepth - 1 - convInfo.padInfo.front;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  for (let b2 = 0; b2 < batchSize; ++b2) {
    for (let d1 = 0; d1 < inChannels; ++d1) {
      for (let xF = 0; xF < inDepth; ++xF) {
        const xFCorner = xF - frontPad;
        const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));
        const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);
        for (let xR = 0; xR < inHeight; ++xR) {
          const xRCorner = xR - topPad;
          const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
          const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
          for (let xC = 0; xC < inWidth; ++xC) {
            const xCCorner = xC - leftPad;
            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
            let dotProd = 0;
            for (let yF = xFMin; yF < yFMax; ++yF) {
              const wF = yF * strideDepth - xFCorner;
              for (let yR = xRMin; yR < yRMax; ++yR) {
                const wR = yR * strideHeight - xRCorner;
                for (let yC = xCMin; yC < yCMax; ++yC) {
                  const wC = yC * strideWidth - xCCorner;
                  const dyOffset = dyS0 * b2 + dyS1 * yF + dyS2 * yR + dyS3 * yC;
                  const fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;
                  for (let d2 = 0; d2 < outChannels; ++d2) {
                    const pixel = dyValues[dyOffset + d2];
                    const weight = fltValues[fltOffset + d2];
                    dotProd += pixel * weight;
                  }
                }
              }
            }
            dxValues[dxS0 * b2 + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var conv3DBackpropInputV2Config = {
  kernelName: Conv3DBackpropInputV2,
  backendName: "cpu",
  kernelFunc: conv3DBackpropInputV2
};
var cos2 = unaryKernelFunc(Cos, (xi) => Math.cos(xi));
var cosConfig = {
  kernelName: Cos,
  backendName: "cpu",
  kernelFunc: cos2
};
var cosh2 = unaryKernelFunc(Cosh, (xi) => Math.cosh(xi));
var coshConfig = {
  kernelName: Cosh,
  backendName: "cpu",
  kernelFunc: cosh2
};
function cropAndResize2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const numBoxes = boxes.shape[0];
  const [cropHeight, cropWidth] = cropSize;
  const output = buffer([numBoxes, cropHeight, cropWidth, numChannels], "float32");
  const boxVals = backend22.data.get(boxes.dataId).values;
  const boxIndVals = backend22.data.get(boxInd.dataId).values;
  const imageVals = backend22.data.get(image32.dataId).values;
  const inStride = util_exports.computeStrides(image32.shape);
  const outStride = util_exports.computeStrides(output.shape);
  for (let b2 = 0; b2 < numBoxes; b2++) {
    const startInd = b2 * 4;
    const y1 = boxVals[startInd];
    const x1 = boxVals[startInd + 1];
    const y2 = boxVals[startInd + 2];
    const x2 = boxVals[startInd + 3];
    const bInd = boxIndVals[b2];
    if (bInd >= batch) {
      continue;
    }
    const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;
    const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
    for (let y3 = 0; y3 < cropHeight; y3++) {
      const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y3 * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);
      if (yInd < 0 || yInd > imageHeight - 1) {
        for (let x3 = 0; x3 < cropWidth; x3++) {
          for (let c2 = 0; c2 < numChannels; c2++) {
            const ind = c2 + x3 * outStride[2] + y3 * outStride[1] + b2 * outStride[0];
            output.values[ind] = extrapolationValue;
          }
        }
        continue;
      }
      if (method === "bilinear") {
        const topInd = Math.floor(yInd);
        const bottomInd = Math.ceil(yInd);
        const yLerp = yInd - topInd;
        for (let x3 = 0; x3 < cropWidth; x3++) {
          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x3 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
          if (xInd < 0 || xInd > imageWidth - 1) {
            for (let c2 = 0; c2 < numChannels; c2++) {
              const ind = c2 + x3 * outStride[2] + y3 * outStride[1] + b2 * outStride[0];
              output.values[ind] = extrapolationValue;
            }
            continue;
          }
          const leftInd = Math.floor(xInd);
          const rightInd = Math.ceil(xInd);
          const xLerp = xInd - leftInd;
          for (let c2 = 0; c2 < numChannels; c2++) {
            let ind = c2 + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
            const topLeft = imageVals[ind];
            ind = c2 + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
            const topRight = imageVals[ind];
            ind = c2 + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
            const bottomLeft = imageVals[ind];
            ind = c2 + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
            const bottomRight = imageVals[ind];
            const top = topLeft + (topRight - topLeft) * xLerp;
            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
            ind = c2 + x3 * outStride[2] + y3 * outStride[1] + b2 * outStride[0];
            output.values[ind] = top + (bottom - top) * yLerp;
          }
        }
      } else {
        for (let x3 = 0; x3 < cropWidth; ++x3) {
          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x3 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
          if (xInd < 0 || xInd > imageWidth - 1) {
            for (let c2 = 0; c2 < numChannels; c2++) {
              const ind = c2 + x3 * outStride[2] + y3 * outStride[1] + b2 * outStride[0];
              output.values[ind] = extrapolationValue;
            }
            continue;
          }
          const closestX = Math.round(xInd);
          const closestY = Math.round(yInd);
          for (let c2 = 0; c2 < numChannels; c2++) {
            const inInd = c2 + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];
            const outInd = c2 + x3 * outStride[2] + y3 * outStride[1] + b2 * outStride[0];
            output.values[outInd] = imageVals[inInd];
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(output.shape, output.dtype, output.values);
}
var cropAndResizeConfig = {
  kernelName: CropAndResize,
  backendName: "cpu",
  kernelFunc: cropAndResize2
};
function cumsum2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, exclusive, reverse: reverse5 } = attrs;
  assertNotComplex(x2, "cumsum");
  const permutation = backend_util_exports.getAxesPermutation([axis], x2.shape.length);
  let $x = x2;
  if (permutation != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutation } });
  }
  const permutedAxis = backend_util_exports.getInnerMostAxes(1, x2.shape.length)[0];
  if (permutedAxis !== $x.shape.length - 1) {
    throw new Error(`backend.cumsum in CPU expects an inner-most axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
  }
  const resultDtype = upcastType($x.dtype, "int32");
  const vals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape($x.shape), resultDtype);
  const aVals = backend22.data.get($x.dataId).values;
  const finalDim = $x.shape[$x.shape.length - 1];
  const indexAdjuster = reverse5 ? (i2, j2) => i2 + finalDim - j2 - 1 : (i2, j2) => i2 + j2;
  for (let i2 = 0; i2 < aVals.length; i2 += finalDim) {
    for (let j2 = 0; j2 < finalDim; j2++) {
      const idx = indexAdjuster(i2, j2);
      if (j2 === 0) {
        vals[idx] = exclusive ? 0 : aVals[idx];
      } else {
        const prevIdx = indexAdjuster(i2, j2 - 1);
        vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];
      }
    }
  }
  const result = backend22.makeTensorInfo($x.shape, resultDtype, vals);
  if (permutation != null) {
    const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose2({ inputs: { x: result }, backend: backend22, attrs: { perm: reversePermutation } });
    backend22.disposeIntermediateTensorInfo(result);
    backend22.disposeIntermediateTensorInfo($x);
    return reverseTransposedResult;
  }
  return result;
}
var cumsumConfig = {
  kernelName: Cumsum,
  backendName: "cpu",
  kernelFunc: cumsum2
};
function denseBincount2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, weights } = inputs;
  const { size: size2, binaryOutput } = attrs;
  if (x2.shape.length === 1) {
    const xVals = backend22.data.get(x2.dataId).values;
    const weightsVals = backend22.data.get(weights.dataId).values;
    const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size2);
    return backend22.makeTensorInfo([size2], weights.dtype, outVals);
  } else if (x2.shape.length === 2) {
    const xBuf = backend22.bufferSync(x2);
    const weightsBuf = backend22.bufferSync(weights);
    const outBuf = bincountReduceImpl(xBuf, weightsBuf, size2, binaryOutput);
    return backend22.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x2.shape.length}.`);
}
var denseBincountConfig = {
  kernelName: DenseBincount,
  backendName: "cpu",
  kernelFunc: denseBincount2
};
function depthToSpace2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockSize, dataFormat } = attrs;
  util_exports.assert(dataFormat === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);
  util_exports.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  const batchSize = x2.shape[0];
  const inputHeight = x2.shape[1];
  const inputWidth = x2.shape[2];
  const inputDepth = x2.shape[3];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const xValues = backend22.data.get(x2.dataId).values;
  const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
  let outputIdx = 0;
  for (let b2 = 0; b2 < batchSize; ++b2) {
    for (let h2 = 0; h2 < outputHeight; ++h2) {
      const inH = Math.floor(h2 / blockSize);
      const offsetH = h2 % blockSize;
      for (let w2 = 0; w2 < outputWidth; ++w2) {
        const inW = Math.floor(w2 / blockSize);
        const offsetW = w2 % blockSize;
        const offsetD = (offsetH * blockSize + offsetW) * outputDepth;
        for (let d2 = 0; d2 < outputDepth; ++d2) {
          const inD = d2 + offsetD;
          const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b2));
          result[outputIdx++] = xValues[inputIdx];
        }
      }
    }
  }
  return backend22.makeTensorInfo([batchSize, outputHeight, outputWidth, outputDepth], x2.dtype, result);
}
var depthToSpaceConfig = {
  kernelName: DepthToSpace,
  backendName: "cpu",
  kernelFunc: depthToSpace2
};
function depthwiseConv2dNative(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations, dimRoundingMode } = attrs;
  assertNotComplex([x2, filter], "depthwiseConv2DNative");
  const xStrides = util_exports.computeStrides(x2.shape);
  const filterStrides = util_exports.computeStrides(filter.shape);
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  const { filterHeight, filterWidth, dilationHeight, dilationWidth, padInfo } = convInfo;
  const padLeft = padInfo.left;
  const padTop = padInfo.top;
  const chMul = convInfo.outChannels / convInfo.inChannels;
  const y2 = new TensorBuffer(convInfo.outShape, x2.dtype);
  const xVals = backend22.data.get(x2.dataId).values;
  const wVals = backend22.data.get(filter.dataId).values;
  const yVals = y2.values;
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    const xOffset1 = b2 * xStrides[0];
    const yOffset1 = b2 * y2.strides[0];
    for (let yR = 0; yR < convInfo.outHeight; ++yR) {
      const yOffset2 = yOffset1 + yR * y2.strides[1];
      const xRCorner = yR * convInfo.strideHeight - padTop;
      for (let wR = 0; wR < filterHeight; ++wR) {
        const xR = xRCorner + wR * dilationHeight;
        if (xR < 0 || xR >= convInfo.inHeight) {
          continue;
        }
        const wOffset1 = wR * filterStrides[0];
        const xOffset2 = xOffset1 + xR * xStrides[1];
        for (let yC = 0; yC < convInfo.outWidth; ++yC) {
          const yOffset3 = yOffset2 + yC * y2.strides[2];
          const xCCorner = yC * convInfo.strideWidth - padLeft;
          for (let wC = 0; wC < filterWidth; ++wC) {
            const xC = xCCorner + wC * dilationWidth;
            if (xC < 0 || xC >= convInfo.inWidth) {
              continue;
            }
            const wOffset2 = wOffset1 + wC * filterStrides[1];
            const xOffset3 = xOffset2 + xC * convInfo.inChannels;
            let yOffset4 = yOffset3;
            let wOffset3 = wOffset2;
            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
              const xVal = xVals[xOffset3 + d1];
              for (let q2 = 0; q2 < chMul; ++q2) {
                yVals[yOffset4 + q2] += xVal * wVals[wOffset3 + q2];
              }
              yOffset4 += chMul;
              wOffset3 += chMul;
            }
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(y2.shape, y2.dtype, y2.values);
}
var depthwiseConv2dNativeConfig = {
  kernelName: DepthwiseConv2dNative,
  backendName: "cpu",
  kernelFunc: depthwiseConv2dNative
};
function depthwiseConv2dNativeBackpropFilter2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, dilations, pad: pad3, dimRoundingMode, filterShape } = attrs;
  assertNotComplex([x2, dy], "depthwiseConv2dNativeBackpropFilter");
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
  const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
  const dW = new TensorBuffer(convInfo.filterShape, "float32");
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  const chMul = convInfo.outChannels / convInfo.inChannels;
  const xVals = backend22.data.get(x2.dataId).values;
  const xBuf = new TensorBuffer(x2.shape, x2.dtype, xVals);
  const dyVals = backend22.data.get(dy.dataId).values;
  const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);
  for (let wR = 0; wR < filterHeight; ++wR) {
    const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
    const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
    for (let wC = 0; wC < filterWidth; ++wC) {
      const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
      const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
      for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
        const d1 = Math.trunc(d2 / chMul);
        const dm = d2 % chMul;
        let dotProd = 0;
        for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
          for (let yR = yRMin; yR < yRMax; ++yR) {
            const xR = wR + yR * strideHeight - topPad;
            for (let yC = yCMin; yC < yCMax; ++yC) {
              const xC = wC + yC * strideWidth - leftPad;
              dotProd += xBuf.get(b2, xR, xC, d1) * dyBuf.get(b2, yR, yC, d2);
            }
          }
        }
        dW.set(dotProd, wR, wC, d1, dm);
      }
    }
  }
  return backend22.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
var depthwiseConv2dNativeBackpropFilterConfig = {
  kernelName: DepthwiseConv2dNativeBackpropFilter,
  backendName: "cpu",
  kernelFunc: depthwiseConv2dNativeBackpropFilter2
};
function depthwiseConv2dNativeBackpropInput2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { strides, dilations, pad: pad3, dimRoundingMode, inputShape } = attrs;
  assertNotComplex([dy, filter], "depthwiseConv2DNativeBackpropInput");
  const dyStrides = util_exports.computeStrides(dy.shape);
  const filterStrides = util_exports.computeStrides(filter.shape);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad3, dimRoundingMode, true);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const [dxS0, dxS1, dxS2] = dx.strides;
  const dyValues = backend22.data.get(dy.dataId).values;
  const [dyS0, dyS1, dyS2] = dyStrides;
  const fltValues = backend22.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2] = filterStrides;
  const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const chMul = outChannels / inChannels;
  for (let b2 = 0; b2 < batchSize; ++b2) {
    for (let d1 = 0; d1 < inChannels; ++d1) {
      for (let xR = 0; xR < inHeight; ++xR) {
        const xRCorner = xR - topPad;
        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
        for (let xC = 0; xC < inWidth; ++xC) {
          const xCCorner = xC - leftPad;
          const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
          const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
          let dotProd = 0;
          for (let yR = xRMin; yR < yRMax; ++yR) {
            const wR = yR * strideHeight - xRCorner;
            for (let yC = xCMin; yC < yCMax; ++yC) {
              const wC = yC * strideWidth - xCCorner;
              const dyOffset = dyS0 * b2 + dyS1 * yR + dyS2 * yC;
              const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
              for (let dm = 0; dm < chMul; ++dm) {
                const d2 = d1 * chMul + dm;
                const pixel = dyValues[dyOffset + d2];
                const weight = fltValues[fltOffset + dm];
                dotProd += pixel * weight;
              }
            }
          }
          dxValues[dxS0 * b2 + dxS1 * xR + dxS2 * xC + d1] = dotProd;
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var depthwiseConv2dNativeBackpropInputConfig = {
  kernelName: DepthwiseConv2dNativeBackpropInput,
  backendName: "cpu",
  kernelFunc: depthwiseConv2dNativeBackpropInput2
};
function diag2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const xVals = backend22.data.get(x2.dataId).values;
  const outBuf = buffer([xSize, xSize], x2.dtype);
  const vals = outBuf.values;
  for (let i2 = 0; i2 < xVals.length; i2++) {
    vals[i2 * xSize + i2] = xVals[i2];
  }
  const outShape = [...x2.shape, ...x2.shape];
  return backend22.makeTensorInfo(outShape, outBuf.dtype, outBuf.values);
}
var diagConfig = {
  kernelName: Diag,
  backendName: "cpu",
  kernelFunc: diag2
};
var dilation2dConfig = {
  kernelName: Dilation2D,
  backendName: "cpu",
  kernelFunc: ({ inputs, backend: backend22, attrs }) => {
    const { x: x2, filter } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    const cpuBackend = backend22;
    const xVals = cpuBackend.data.get(x2.dataId).values;
    const xRank = x2.shape.length;
    const filterVals = cpuBackend.data.get(filter.dataId).values;
    const filterRank = filter.shape.length;
    const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x2.shape, filter.shape, strides, pad3, "NHWC", dilations);
    const outSize = util_exports.sizeFromShape(outShape);
    const outRank = outShape.length;
    const outputVals = util_exports.getArrayFromDType(x2.dtype, outSize);
    for (let b2 = 0; b2 < batchSize; ++b2) {
      for (let hOut = 0; hOut < outHeight; ++hOut) {
        const hBeg = hOut * strideHeight - padInfo.top;
        for (let wOut = 0; wOut < outWidth; ++wOut) {
          const wBeg = wOut * strideWidth - padInfo.left;
          for (let d2 = 0; d2 < inChannels; ++d2) {
            let curVal = Number.MIN_SAFE_INTEGER;
            for (let h2 = 0; h2 < filterHeight; ++h2) {
              const hIn = hBeg + h2 * dilationHeight;
              if (hIn >= 0 && hIn < inHeight) {
                for (let w2 = 0; w2 < filterWidth; ++w2) {
                  const wIn = wBeg + w2 * dilationWidth;
                  if (wIn >= 0 && wIn < inWidth) {
                    const xIndex = util_exports.locToIndex([b2, hIn, wIn, d2], xRank, util_exports.computeStrides(x2.shape));
                    const filterIndex = util_exports.locToIndex([h2, w2, d2], filterRank, util_exports.computeStrides(filter.shape));
                    const val = xVals[xIndex] + filterVals[filterIndex];
                    if (val > curVal) {
                      curVal = val;
                    }
                  }
                }
              }
            }
            const outputIndex = util_exports.locToIndex([b2, hOut, wOut, d2], outRank, util_exports.computeStrides(outShape));
            outputVals[outputIndex] = curVal;
          }
        }
      }
    }
    const dataId = cpuBackend.write(util_exports.toTypedArray(outputVals, x2.dtype), outShape, x2.dtype);
    return { dataId, shape: outShape, dtype: x2.dtype };
  }
};
var dilation2dBackpropFilterConfig = {
  kernelName: Dilation2DBackpropFilter,
  backendName: "cpu",
  kernelFunc: ({ inputs, backend: backend22, attrs }) => {
    const { x: x2, filter, dy } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    const cpuBackend = backend22;
    const $x = util_exports.toNestedArray(x2.shape, cpuBackend.data.get(x2.dataId).values);
    const $filter = util_exports.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
    const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x2.shape, filter.shape, strides, pad3, "NHWC", dilations);
    util_exports.assert(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
    const $dy = util_exports.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
    const gradients = util_exports.makeZerosNestedTypedArray(filter.shape, filter.dtype);
    for (let b2 = 0; b2 < batchSize; ++b2) {
      for (let hOut = 0; hOut < outHeight; ++hOut) {
        const hBeg = hOut * strideHeight - padInfo.top;
        for (let wOut = 0; wOut < outWidth; ++wOut) {
          const wBeg = wOut * strideWidth - padInfo.left;
          for (let d2 = 0; d2 < inChannels; ++d2) {
            let curVal = Number.MIN_SAFE_INTEGER;
            let hMax = 0;
            let wMax = 0;
            for (let h2 = 0; h2 < filterHeight; ++h2) {
              const hIn = hBeg + h2 * dilationHeight;
              if (hIn >= 0 && hIn < inHeight) {
                for (let w2 = 0; w2 < filterWidth; ++w2) {
                  const wIn = wBeg + w2 * dilationWidth;
                  if (wIn >= 0 && wIn < inWidth) {
                    const val = $x[b2][hIn][wIn][d2] + $filter[h2][w2][d2];
                    if (val > curVal) {
                      curVal = val;
                      hMax = h2;
                      wMax = w2;
                    }
                  }
                }
              }
            }
            gradients[hMax][wMax][d2] += $dy[b2][hOut][wOut][d2];
          }
        }
      }
    }
    const dataId = cpuBackend.write(util_exports.toTypedArray(gradients, x2.dtype), filter.shape, filter.dtype);
    return { dataId, shape: filter.shape, dtype: filter.dtype };
  }
};
var dilation2dBackpropInputConfig = {
  kernelName: Dilation2DBackpropInput,
  backendName: "cpu",
  kernelFunc: ({ inputs, backend: backend22, attrs }) => {
    const { x: x2, filter, dy } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    const cpuBackend = backend22;
    const $x = util_exports.toNestedArray(x2.shape, cpuBackend.data.get(x2.dataId).values);
    const $filter = util_exports.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
    const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x2.shape, filter.shape, strides, pad3, "NHWC", dilations);
    util_exports.assert(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
    const $dy = util_exports.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
    const gradients = util_exports.makeZerosNestedTypedArray(x2.shape, x2.dtype);
    for (let b2 = 0; b2 < batchSize; ++b2) {
      for (let hOut = 0; hOut < outHeight; ++hOut) {
        const hBeg = hOut * strideHeight - padInfo.top;
        for (let wOut = 0; wOut < outWidth; ++wOut) {
          const wBeg = wOut * strideWidth - padInfo.left;
          for (let d2 = 0; d2 < inChannels; ++d2) {
            let curVal = Number.MIN_SAFE_INTEGER;
            let hInMax = hBeg < 0 ? 0 : hBeg;
            let wInMax = wBeg < 0 ? 0 : wBeg;
            for (let h2 = 0; h2 < filterHeight; ++h2) {
              const hIn = hBeg + h2 * dilationHeight;
              if (hIn >= 0 && hIn < inHeight) {
                for (let w2 = 0; w2 < filterWidth; ++w2) {
                  const wIn = wBeg + w2 * dilationWidth;
                  if (wIn >= 0 && wIn < inWidth) {
                    const val = $x[b2][hIn][wIn][d2] + $filter[h2][w2][d2];
                    if (val > curVal) {
                      curVal = val;
                      hInMax = hIn;
                      wInMax = wIn;
                    }
                  }
                }
              }
            }
            gradients[b2][hInMax][wInMax][d2] += $dy[b2][hOut][wOut][d2];
          }
        }
      }
    }
    const dataId = cpuBackend.write(util_exports.toTypedArray(gradients, x2.dtype), x2.shape, x2.dtype);
    return { dataId, shape: x2.shape, dtype: x2.dtype };
  }
};
function sum3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x2, "sum");
  let $x;
  if (x2.dtype === "bool") {
    $x = cast3({ inputs: { x: x2 }, backend: backend22, attrs: { dtype: "int32" } });
  } else {
    $x = identity2({ inputs: { x: x2 }, backend: backend22 });
  }
  const xRank = $x.shape.length;
  const axes = util_exports.parseAxisParam(axis, $x.shape);
  const permutation = backend_util_exports.getAxesPermutation(axes, xRank);
  let reductionAxes = axes;
  let permutedX = $x;
  if (permutation != null) {
    permutedX = transpose2({ inputs: { x: $x }, backend: backend22, attrs: { perm: permutation } });
    reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, xRank);
  }
  backend_util_exports.assertAxesAreInnerMostDims("sum", reductionAxes, permutedX.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, reductionAxes);
  const resultDtype = backend_util_exports.upcastType(permutedX.dtype, "int32");
  let result = zeros3(backend22, outShape, resultDtype);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const vals = backend22.data.get(result.dataId).values;
  const aVals = backend22.data.get(permutedX.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let sum7 = 0;
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      sum7 += aVals[offset + j2];
    }
    vals[i2] = sum7;
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(result.shape, axes);
    const oldResult = result;
    result = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: newShape } });
    backend22.disposeIntermediateTensorInfo(oldResult);
  }
  backend22.disposeIntermediateTensorInfo($x);
  if (permutation != null) {
    backend22.disposeIntermediateTensorInfo(permutedX);
  }
  return result;
}
var sumConfig = {
  kernelName: Sum,
  backendName: "cpu",
  kernelFunc: sum3
};
function einsum2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
  backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i2 = 0; i2 < nSteps; ++i2) {
    for (const idTerm of steps[i2]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x2;
      if (backend_util_exports.isIdentityPermutation(perm)) {
        x2 = tensors[idTerm];
      } else {
        x2 = transpose2({ inputs: { x: tensors[idTerm] }, backend: backend22, attrs: { perm } });
        tensorsToDispose.push(x2);
      }
      const targetShape = x2.shape.slice();
      for (let k3 = 0; k3 < dimsToExpand.length; ++k3) {
        targetShape.splice(dimsToExpand[k3], 0, 1);
      }
      if (!util_exports.arraysEqual(x2.shape, targetShape)) {
        x2 = reshape3({ inputs: { x: x2 }, backend: backend22, attrs: { shape: targetShape } });
        tensorsToDispose.push(x2);
      }
      if (out === null) {
        out = x2;
      } else {
        out = multiply2({ inputs: { a: x2, b: out }, backend: backend22 });
        tensorsToDispose.push(out);
      }
    }
    if (i2 < nSteps - 1) {
      if (path[i2] >= 0) {
        out = sum3({
          inputs: { x: out },
          backend: backend22,
          attrs: {
            axis: path[i2] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend22.disposeIntermediateTensorInfo(tensorInfo);
  }
  return out;
}
var einsumConfig = {
  kernelName: Einsum,
  backendName: "cpu",
  kernelFunc: einsum2
};
function eluGrad(args) {
  const { inputs, backend: backend22 } = args;
  const { dy, y: y2 } = inputs;
  assertNotComplex([dy, y2], "eluGrad");
  const resultValues = new Float32Array(util_exports.sizeFromShape(y2.shape));
  const values = backend22.data.get(y2.dataId).values;
  const dyValues = backend22.data.get(dy.dataId).values;
  for (let i2 = 0; i2 < values.length; ++i2) {
    const v2 = values[i2];
    if (v2 >= 1) {
      resultValues[i2] = dyValues[i2];
    } else {
      resultValues[i2] = dyValues[i2] * (v2 + 1);
    }
  }
  return backend22.makeTensorInfo(y2.shape, "float32", resultValues);
}
var eluGradConfig2 = {
  kernelName: EluGrad,
  backendName: "cpu",
  kernelFunc: eluGrad
};
var p2 = backend_util_exports.ERF_P;
var a1 = backend_util_exports.ERF_A1;
var a2 = backend_util_exports.ERF_A2;
var a3 = backend_util_exports.ERF_A3;
var a4 = backend_util_exports.ERF_A4;
var a5 = backend_util_exports.ERF_A5;
var erf2 = unaryKernelFunc(Erf, (xi) => {
  const sign4 = Math.sign(xi);
  const v2 = Math.abs(xi);
  const t2 = 1 / (1 + p2 * v2);
  return sign4 * (1 - ((((a5 * t2 + a4) * t2 + a3) * t2 + a2) * t2 + a1) * t2 * Math.exp(-v2 * v2));
});
var erfConfig = {
  kernelName: Erf,
  backendName: "cpu",
  kernelFunc: erf2
};
function expandDims3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { input: input2 } = inputs;
  const { dim } = attrs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape3({ inputs: { x: input2 }, backend: backend22, attrs: { shape: newShape } });
}
var expandDimsConfig = {
  kernelName: ExpandDims,
  backendName: "cpu",
  kernelFunc: expandDims3
};
var realDivImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 / b2);
var div2 = binaryKernelFunc(RealDiv, realDivImpl);
var realDivConfig = {
  kernelName: RealDiv,
  backendName: "cpu",
  kernelFunc: div2
};
function fftBatch(input2, inverse, cpuBackend) {
  const inputShape = input2.shape;
  const batch = inputShape[0];
  const innerDim = inputShape[1];
  const inputVals = cpuBackend.data.get(input2.dataId);
  const real2D = inputVals.complexTensorInfos.real;
  const imag2D = inputVals.complexTensorInfos.imag;
  const resultShape = [batch, innerDim];
  const resultSize = util_exports.sizeFromShape(resultShape);
  const resultReal = util_exports.getTypedArrayFromDType("float32", resultSize);
  const resultImag = util_exports.getTypedArrayFromDType("float32", resultSize);
  for (let b2 = 0; b2 < batch; b2++) {
    const r2 = slice2({
      inputs: { x: real2D },
      backend: cpuBackend,
      attrs: { begin: [b2, 0], size: [1, innerDim] }
    });
    const i2 = slice2({
      inputs: { x: imag2D },
      backend: cpuBackend,
      attrs: { begin: [b2, 0], size: [1, innerDim] }
    });
    const input3 = complex2({ inputs: { real: r2, imag: i2 }, backend: cpuBackend });
    const { real: real5, imag: imag5 } = fftImpl(input3, inverse, cpuBackend);
    const res2 = backend_util_exports.mergeRealAndImagArrays(real5, imag5);
    for (let d2 = 0; d2 < innerDim; d2++) {
      const c2 = backend_util_exports.getComplexWithIndex(res2, d2);
      resultReal[b2 * innerDim + d2] = c2.real;
      resultImag[b2 * innerDim + d2] = c2.imag;
    }
    cpuBackend.disposeIntermediateTensorInfo(r2);
    cpuBackend.disposeIntermediateTensorInfo(i2);
    cpuBackend.disposeIntermediateTensorInfo(input3);
  }
  const $realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultReal);
  const $imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultImag);
  const result = complex2({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });
  cpuBackend.disposeIntermediateTensorInfo($realInfo);
  cpuBackend.disposeIntermediateTensorInfo($imagInfo);
  return result;
}
function fftImpl(input2, inverse, cpuBackend) {
  const inputSize8 = util_exports.sizeFromShape(input2.shape);
  const inputVals = cpuBackend.data.get(input2.dataId);
  const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;
  const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;
  if (isExponentOf2(inputSize8)) {
    const result = fftRadix2(realVals, imagVals, inputSize8, inverse, cpuBackend);
    const resultShape = [input2.shape[0], input2.shape[1]];
    if (inverse) {
      const realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.real);
      const imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.imag);
      const sizeInfo = cpuBackend.makeTensorInfo([], "float32", util_exports.createScalarValue(inputSize8, "float32"));
      const sizeInfoCopy = identity2({ inputs: { x: sizeInfo }, backend: cpuBackend });
      const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });
      const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });
      const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;
      const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;
      cpuBackend.disposeIntermediateTensorInfo(realInfo);
      cpuBackend.disposeIntermediateTensorInfo(imagInfo);
      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);
      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);
      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);
      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);
      return { real: divRealVals, imag: divImagVals };
    }
    return result;
  } else {
    const data = backend_util_exports.mergeRealAndImagArrays(realVals, imagVals);
    const rawOutput = fourierTransformByMatmul(data, inputSize8, inverse);
    return backend_util_exports.splitRealAndImagArrays(rawOutput);
  }
}
function isExponentOf2(size2) {
  return (size2 & size2 - 1) === 0;
}
function fftRadix2(realVals, imagVals, size2, inverse, cpuBackend) {
  if (size2 === 1) {
    return { real: realVals, imag: imagVals };
  }
  const data = backend_util_exports.mergeRealAndImagArrays(realVals, imagVals);
  const half = size2 / 2;
  const evenComplex = backend_util_exports.complexWithEvenIndex(data);
  const evenRealVals = evenComplex.real;
  const evenImagVals = evenComplex.imag;
  const evenShape = [evenRealVals.length];
  const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenRealVals);
  const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenImagVals);
  const evenTensorInfo = complex2({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });
  const oddComplex = backend_util_exports.complexWithOddIndex(data);
  const oddRealVals = oddComplex.real;
  const oddImagVals = oddComplex.imag;
  const oddShape = [oddRealVals.length];
  const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddRealVals);
  const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddImagVals);
  const oddTensorInfo = complex2({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });
  const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);
  const $evenRealVals = $evenComplex.real;
  const $evenImagVals = $evenComplex.imag;
  const $evenShape = [$evenRealVals.length];
  const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenRealVals);
  const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenImagVals);
  const $evenTensorInfo = complex2({
    inputs: { real: $evenRealInfo, imag: $evenImagInfo },
    backend: cpuBackend
  });
  const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);
  const $oddRealVals = $oddComplex.real;
  const $oddImagVals = $oddComplex.imag;
  const $oddShape = [$oddRealVals.length];
  const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddRealVals);
  const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddImagVals);
  const $oddTensorInfo = complex2({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });
  const e2 = backend_util_exports.exponents(size2, inverse);
  const eShape = [e2.real.length];
  const eRealInfo = cpuBackend.makeTensorInfo(eShape, "float32", e2.real);
  const eImagInfo = cpuBackend.makeTensorInfo(eShape, "float32", e2.imag);
  const complexInfo = complex2({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });
  const exponentInfo = multiply2({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });
  const addPart = add4({
    inputs: { a: $evenTensorInfo, b: exponentInfo },
    backend: cpuBackend
  });
  const subPart = sub2({
    inputs: { a: $evenTensorInfo, b: exponentInfo },
    backend: cpuBackend
  });
  const addPartReal = real2({ inputs: { input: addPart }, backend: cpuBackend });
  const subPartReal = real2({ inputs: { input: subPart }, backend: cpuBackend });
  const addPartImag = imag2({ inputs: { input: addPart }, backend: cpuBackend });
  const subPartImag = imag2({ inputs: { input: subPart }, backend: cpuBackend });
  const $real = concat2({
    inputs: [addPartReal, subPartReal],
    backend: cpuBackend,
    attrs: { axis: 0 }
  });
  const $imag = concat2({
    inputs: [addPartImag, subPartImag],
    backend: cpuBackend,
    attrs: { axis: 0 }
  });
  const $realVals = cpuBackend.data.get($real.dataId).values;
  const $imagVals = cpuBackend.data.get($imag.dataId).values;
  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(complexInfo);
  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);
  cpuBackend.disposeIntermediateTensorInfo(addPart);
  cpuBackend.disposeIntermediateTensorInfo(subPart);
  cpuBackend.disposeIntermediateTensorInfo(addPartReal);
  cpuBackend.disposeIntermediateTensorInfo(addPartImag);
  cpuBackend.disposeIntermediateTensorInfo(subPartReal);
  cpuBackend.disposeIntermediateTensorInfo(subPartImag);
  cpuBackend.disposeIntermediateTensorInfo($real);
  cpuBackend.disposeIntermediateTensorInfo($imag);
  return { real: $realVals, imag: $imagVals };
}
function fourierTransformByMatmul(data, size2, inverse) {
  const ret = new Float32Array(size2 * 2);
  for (let r2 = 0; r2 < size2; r2++) {
    let real5 = 0;
    let imag5 = 0;
    for (let c2 = 0; c2 < size2; c2++) {
      const e2 = backend_util_exports.exponent(r2 * c2, size2, inverse);
      const term = backend_util_exports.getComplexWithIndex(data, c2);
      real5 += term.real * e2.real - term.imag * e2.imag;
      imag5 += term.real * e2.imag + term.imag * e2.real;
    }
    if (inverse) {
      real5 /= size2;
      imag5 /= size2;
    }
    backend_util_exports.assignToTypedArray(ret, real5, imag5, r2);
  }
  return ret;
}
function fft2(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputSize8 = util_exports.sizeFromShape(input2.shape);
  const innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = inputSize8 / innerDimensionSize;
  const input2D = reshape3({
    inputs: { x: input2 },
    backend: backend22,
    attrs: { shape: [batch, innerDimensionSize] }
  });
  const result = fftBatch(input2D, false, backend22);
  const resultReshaped = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: input2.shape } });
  backend22.disposeIntermediateTensorInfo(input2D);
  backend22.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var fftConfig = {
  kernelName: FFT,
  backendName: "cpu",
  kernelFunc: fft2
};
function fill2(args) {
  const { backend: backend22, attrs } = args;
  const { shape, value, dtype } = attrs;
  const $dtype = dtype || util_exports.inferDtype(value);
  const values = util_exports.getArrayFromDType($dtype, util_exports.sizeFromShape(shape));
  fillValues(values, value, $dtype);
  return backend22.makeTensorInfo(shape, $dtype, values);
}
var fillConfig = {
  kernelName: Fill,
  backendName: "cpu",
  kernelFunc: fill2
};
function fillValues(values, value, dtype) {
  if (dtype === "string") {
    values.fill(value);
  } else {
    values.fill(value);
  }
}
var flipLeftRightConfig = {
  kernelName: FlipLeftRight,
  backendName: "cpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const cpuBackend = backend22;
    const output = util_exports.getTypedArrayFromDType(image32.dtype, util_exports.sizeFromShape(image32.shape));
    const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
    const imageVals = cpuBackend.data.get(image32.dataId).values;
    for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
      const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
      for (let row = 0; row < imageHeight; row++) {
        const rowOffset = row * (imageWidth * numChannels);
        for (let col = 0; col < imageWidth; col++) {
          const colOffset = col * numChannels;
          for (let channel = 0; channel < numChannels; channel++) {
            const coordX = Math.round(imageWidth - col - 1);
            const outIdx = batchOffset + rowOffset + colOffset + channel;
            let outputValue = imageVals[outIdx];
            if (coordX >= 0 && coordX < imageWidth) {
              const rotatedColOffset = coordX * numChannels;
              const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;
              outputValue = imageVals[imageIdx];
            }
            output[outIdx] = outputValue;
          }
        }
      }
    }
    const dataId = cpuBackend.write(output, image32.shape, image32.dtype);
    return { dataId, shape: image32.shape, dtype: image32.dtype };
  }
};
var floorDivImpl = createSimpleBinaryKernelImpl((a6, b2) => Math.floor(a6 / b2));
var floorDiv2 = binaryKernelFunc(FloorDiv, floorDivImpl, null, "int32");
var floorDivConfig = {
  kernelName: FloorDiv,
  backendName: "cpu",
  kernelFunc: floorDiv2
};
function fusedConv2D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  let result = conv2D({
    inputs: { x: x2, filter },
    backend: backend22,
    attrs: { strides, pad: pad3, dataFormat, dilations, dimRoundingMode }
  });
  if (bias) {
    const resultOld = result;
    result = add4({ inputs: { a: result, b: bias }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(resultOld);
  }
  if (activation2) {
    const resultOld = result;
    result = applyActivation2(backend22, result, activation2, preluActivationWeights, leakyreluAlpha);
    backend22.disposeIntermediateTensorInfo(resultOld);
  }
  return result;
}
var fusedConv2DConfig = {
  kernelName: FusedConv2D,
  backendName: "cpu",
  kernelFunc: fusedConv2D
};
function fusedDepthwiseConv2D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  let result = depthwiseConv2dNative({
    inputs: { x: x2, filter },
    backend: backend22,
    attrs: { strides, pad: pad3, dataFormat, dilations, dimRoundingMode }
  });
  if (bias) {
    const oldResult = result;
    result = add4({ inputs: { a: result, b: bias }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(oldResult);
  }
  if (activation2) {
    const oldResult = result;
    result = applyActivation2(backend22, result, activation2, preluActivationWeights, leakyreluAlpha);
    backend22.disposeIntermediateTensorInfo(oldResult);
  }
  return result;
}
var fusedDepthwiseConv2DConfig = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "cpu",
  kernelFunc: fusedDepthwiseConv2D
};
function gatherNd(args) {
  const { inputs, backend: backend22 } = args;
  const { params, indices } = inputs;
  const paramsSize = util_exports.sizeFromShape(params.shape);
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
  if (numSlices === 0) {
    return backend22.makeTensorInfo(resultShape, params.dtype, []);
  }
  const indicesData = backend22.data.get(indices.dataId).values;
  const paramsBuf = backend22.bufferSync(params);
  const outBuf = gatherNdImpl(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
  return backend22.makeTensorInfo(resultShape, params.dtype, outBuf.values);
}
var gatherNdConfig = {
  kernelName: GatherNd,
  backendName: "cpu",
  kernelFunc: gatherNd
};
function gatherV2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, indices } = inputs;
  const { axis, batchDims } = attrs;
  assertNotComplex([x2, indices], "gatherV2");
  let $batchDims = batchDims;
  if (batchDims == null) {
    $batchDims = 0;
  }
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const parsedAxis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x2, indices, parsedAxis, $batchDims);
  const flattenX = reshape3({
    inputs: { x: x2 },
    backend: backend22,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape3({
    inputs: { x: indices },
    backend: backend22,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  const indicesBuf = backend22.bufferSync(flattenIndex);
  const xBuf = backend22.bufferSync(flattenX);
  const outBuf = gatherV2Impl(xBuf, indicesBuf, flattenOutputShape);
  backend22.disposeIntermediateTensorInfo(flattenX);
  backend22.disposeIntermediateTensorInfo(flattenIndex);
  return backend22.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
}
var gatherV2Config = {
  kernelName: GatherV2,
  backendName: "cpu",
  kernelFunc: gatherV2
};
function ifft2(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputSize8 = util_exports.sizeFromShape(input2.shape);
  const innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = inputSize8 / innerDimensionSize;
  const input2D = reshape3({
    inputs: { x: input2 },
    backend: backend22,
    attrs: { shape: [batch, innerDimensionSize] }
  });
  const result = fftBatch(input2D, true, backend22);
  const resultReshaped = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: input2.shape } });
  backend22.disposeIntermediateTensorInfo(input2D);
  backend22.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var ifftConfig = {
  kernelName: IFFT,
  backendName: "cpu",
  kernelFunc: ifft2
};
var isFinite3 = unaryKernelFunc(IsFinite, (xi) => Number.isFinite(xi) ? 1 : 0, "bool");
var isFiniteConfig = {
  kernelName: IsFinite,
  backendName: "cpu",
  kernelFunc: isFinite3
};
var isInf2 = unaryKernelFunc(IsInf, (xi) => Math.abs(xi) === Infinity ? 1 : 0, "bool");
var isInfConfig = {
  kernelName: IsInf,
  backendName: "cpu",
  kernelFunc: isInf2
};
var isNaN3 = unaryKernelFunc(IsNan, (xi) => Number.isNaN(xi) ? 1 : 0, "bool");
var isNaNConfig = {
  kernelName: IsNan,
  backendName: "cpu",
  kernelFunc: isNaN3
};
function linSpace(args) {
  const { backend: backend22, attrs } = args;
  const { start, stop, num } = attrs;
  const outVals = linSpaceImpl(start, stop, num);
  return backend22.makeTensorInfo([outVals.length], "float32", outVals);
}
var linSpaceConfig = {
  kernelName: LinSpace,
  backendName: "cpu",
  kernelFunc: linSpace
};
var log1p2 = unaryKernelFunc(Log1p, (xi) => Math.log1p(xi));
var log1pConfig = {
  kernelName: Log1p,
  backendName: "cpu",
  kernelFunc: log1p2
};
var logicalAndImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 && b2);
var logicalAnd2 = binaryKernelFunc(LogicalAnd, logicalAndImpl, null, "bool");
var logicalAndConfig = {
  kernelName: LogicalAnd,
  backendName: "cpu",
  kernelFunc: logicalAnd2
};
var logicalNot2 = unaryKernelFunc(LogicalNot, (xi) => xi ? 0 : 1, "bool");
var logicalNotConfig = {
  kernelName: LogicalNot,
  backendName: "cpu",
  kernelFunc: logicalNot2
};
var logicalOrImpl = createSimpleBinaryKernelImpl((a6, b2) => a6 || b2);
var logicalOr2 = binaryKernelFunc(LogicalOr, logicalOrImpl, null, "bool");
var logicalOrConfig = {
  kernelName: LogicalOr,
  backendName: "cpu",
  kernelFunc: logicalOr2
};
function lRN(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  assertNotComplex(x2, "LRN");
  const channels = x2.shape[3];
  const maxD = channels - 1;
  const xValues = backend22.data.get(x2.dataId).values;
  const size2 = util_exports.sizeFromShape(x2.shape);
  const result = new Float32Array(size2);
  function sumAcrossChannels(offset) {
    const currentChannel = offset % channels;
    let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
    const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);
    let sum7 = 0;
    for (; beginSumOffset <= endSumOffset; beginSumOffset++) {
      const z2 = xValues[beginSumOffset];
      sum7 += z2 * z2;
    }
    return sum7;
  }
  for (let offset = 0; offset < size2; offset++) {
    const sum7 = sumAcrossChannels(offset);
    const val = xValues[offset] * Math.pow(bias + alpha * sum7, -beta);
    result[offset] = val;
  }
  return backend22.makeTensorInfo(x2.shape, x2.dtype, result);
}
var lRNConfig = {
  kernelName: LRN,
  backendName: "cpu",
  kernelFunc: lRN
};
function lRNGrad(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, y: y2, dy } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  assertNotComplex(dy, "LRNGrad");
  const dySize = util_exports.sizeFromShape(dy.shape);
  const channels = dy.shape[3];
  const dyValues = backend22.data.get(dy.dataId).values;
  const xValues = backend22.data.get(x2.dataId).values;
  const yValues = backend22.data.get(y2.dataId).values;
  const result = new Float32Array(dySize);
  const size2 = dySize;
  for (let offset = 0; offset < size2; offset++) {
    const currentChannel = offset % channels;
    const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
    const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);
    let norm2 = 0;
    for (let k3 = depthBegin; k3 < depthEnd; k3++) {
      norm2 += Math.pow(xValues[k3], 2);
    }
    norm2 = alpha * norm2 + bias;
    for (let k3 = depthBegin; k3 < depthEnd; k3++) {
      let dyi = -2 * alpha * beta * xValues[k3] * yValues[offset] / norm2;
      if (offset === k3) {
        dyi += Math.pow(norm2, -beta);
      }
      dyi *= dyValues[offset];
      result[k3] += dyi;
    }
  }
  return backend22.makeTensorInfo(dy.shape, x2.dtype, result);
}
var lRNGradConfig = {
  kernelName: LRNGrad,
  backendName: "cpu",
  kernelFunc: lRNGrad
};
function max3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { reductionIndices, keepDims } = attrs;
  const cpuBackend = backend22;
  let xShape = x2.shape;
  const xRank = xShape.length;
  const origAxes = util_exports.parseAxisParam(reductionIndices, xShape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let xVals = cpuBackend.data.get(x2.dataId).values;
  if (permutedAxes != null) {
    const newShape = new Array(xRank);
    for (let i2 = 0; i2 < newShape.length; i2++) {
      newShape[i2] = xShape[permutedAxes[i2]];
    }
    xVals = transposeImpl(xVals, xShape, x2.dtype, permutedAxes, newShape);
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    xShape = newShape;
  }
  assertNotComplex(x2, "max");
  backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
  const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const result = maxImpl(xVals, reduceSize, maxOutShape, x2.dtype);
  const dataId = cpuBackend.write(result, maxOutShape, x2.dtype);
  let outShape = maxOutShape;
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
    outShape = newShape;
  }
  return { dataId, shape: outShape, dtype: x2.dtype };
}
var maxConfig = {
  kernelName: Max,
  backendName: "cpu",
  kernelFunc: max3
};
function maxPool2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  assertNotComplex(x2, "maxPool");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  let res2;
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    res2 = identity2({ inputs: { x: x2 }, backend: backend22 });
  } else {
    const xValues = backend22.data.get(x2.dataId).values;
    const strides2 = util_exports.computeStrides(x2.shape);
    const buffer2 = pool2(xValues, x2.shape, x2.dtype, strides2, convInfo, "max");
    res2 = backend22.makeTensorInfo(convInfo.outShape, x2.dtype, buffer2.values);
  }
  return res2;
}
var maxPoolConfig = {
  kernelName: MaxPool,
  backendName: "cpu",
  kernelFunc: maxPool2
};
function maxPool3D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
  assertNotComplex(x2, "maxPool3d");
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode, dataFormat);
  const xValues = backend22.data.get(x2.dataId).values;
  const outBuf = pool3d2(xValues, x2.shape, x2.dtype, util_exports.computeStrides(x2.shape), convInfo, "max");
  return backend22.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
}
var maxPool3DConfig = {
  kernelName: MaxPool3D,
  backendName: "cpu",
  kernelFunc: maxPool3D
};
function maxPool3DGrad(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  assertNotComplex([dy, input2], "maxPool3DGrad");
  const convInfo = backend_util_exports.computePool3DInfo(input2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const inputBuf = backend22.bufferSync(input2);
  const maxPosBuf = maxPool3dPositions(inputBuf, convInfo);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(input2.shape, "float32");
  const dyBuf = backend22.bufferSync(dy);
  for (let batch = 0; batch < convInfo.batchSize; ++batch) {
    for (let channel = 0; channel < convInfo.inChannels; ++channel) {
      for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
        for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
          for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
            const dyDepthCorner = dxDepth - padFront;
            const dyRowCorner = dxRow - padTop;
            const dyColCorner = dxCol - padLeft;
            let dotProd = 0;
            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
              const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
              if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                continue;
              }
              for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                const dyRow = (dyRowCorner + wRow) / strideHeight;
                if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                  continue;
                }
                for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                  const dyCol = (dyColCorner + wCol) / strideWidth;
                  if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                    continue;
                  }
                  const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;
                  const mask = maxPos === curPos ? 1 : 0;
                  if (mask === 0) {
                    continue;
                  }
                  const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  dotProd += pixel * mask;
                }
              }
            }
            dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);
          }
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var maxPool3DGradConfig2 = {
  kernelName: MaxPool3DGrad,
  backendName: "cpu",
  kernelFunc: maxPool3DGrad
};
function maxPoolGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2, output } = inputs;
  const x2 = input2;
  assertNotComplex([input2, output], "maxPoolGrad");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const xValues = backend22.data.get(x2.dataId).values;
  const maxPosBuf = buffer(convInfo.outShape, x2.dtype, maxPoolPositions(xValues, x2.shape, x2.dtype, convInfo).values);
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(x2.shape, "float32");
  const dyData = backend22.data.get(dy.dataId).values;
  const dyBuf = buffer(dy.shape, "float32", dyData);
  for (let b2 = 0; b2 < convInfo.batchSize; ++b2) {
    for (let d2 = 0; d2 < convInfo.inChannels; ++d2) {
      for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
        for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
          const dyRCorner = dxR - padTop;
          const dyCCorner = dxC - padLeft;
          let dotProd = 0;
          for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
            const dyR = (dyRCorner + wR) / strideHeight;
            if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
              continue;
            }
            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
              const dyC = (dyCCorner + wC) / strideWidth;
              if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                continue;
              }
              const maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b2, dyR, dyC, d2);
              const curPos = wR * effectiveFilterWidth + wC;
              const mask = maxPos === curPos ? 1 : 0;
              if (mask === 0) {
                continue;
              }
              const pixel = dyBuf.get(b2, dyR, dyC, d2);
              dotProd += pixel * mask;
            }
          }
          dx.set(dotProd, b2, dxR, dxC, d2);
        }
      }
    }
  }
  return backend22.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var maxPoolGradConfig2 = {
  kernelName: MaxPoolGrad,
  backendName: "cpu",
  kernelFunc: maxPoolGrad2
};
function maxPoolWithArgmaxImpl(xValues, xShape, dtype, includeBatchInIndex, convInfo) {
  const strides = util_exports.computeStrides(xShape);
  const maxPools = pool2(xValues, xShape, dtype, strides, convInfo, "max");
  const maxPositions = maxPoolPositions(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);
  return [maxPools.values, maxPositions.values];
}
var maxPoolWithArgmaxConfig = {
  kernelName: MaxPoolWithArgmax,
  backendName: "cpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const { filterSize, strides, pad: pad3, includeBatchInIndex } = attrs;
    const cpuBackend = backend22;
    assertNotComplex(x2, "MaxPoolWithArgmax");
    const values = cpuBackend.data.get(x2.dataId).values;
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, [1, 1], pad3);
    const [pooled, indexes] = maxPoolWithArgmaxImpl(values, x2.shape, x2.dtype, includeBatchInIndex, convInfo);
    const pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x2.dtype);
    const indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x2.dtype);
    return [
      { dataId: pooledDataId, shape: convInfo.outShape, dtype: x2.dtype },
      { dataId: indexesDataId, shape: convInfo.outShape, dtype: "int32" }
    ];
  }
};
function mean2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  const axes = util_exports.parseAxisParam(axis, x2.shape);
  const shapes = backend_util_exports.computeOutAndReduceShapes(x2.shape, axes);
  const reduceShape = shapes[1];
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const toDispose = [];
  const reduceSizeScalar = backend22.makeTensorInfo([], "float32", new Float32Array([reduceSize]));
  toDispose.push(reduceSizeScalar);
  const $x = cast3({ inputs: { x: x2 }, backend: backend22, attrs: { dtype: "float32" } });
  toDispose.push($x);
  const res2 = div2({ inputs: { a: $x, b: reduceSizeScalar }, backend: backend22 });
  toDispose.push(res2);
  const result = sum3({ inputs: { x: res2 }, backend: backend22, attrs: { axis, keepDims } });
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var meanConfig = {
  kernelName: Mean,
  backendName: "cpu",
  kernelFunc: mean2
};
function min3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x2, "min");
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  if (permutedAxes != null) {
    $x = transpose2({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, x2.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("min", axes, $x.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const vals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), $x.dtype);
  const aVals = backend22.data.get($x.dataId).values;
  for (let i2 = 0; i2 < vals.length; ++i2) {
    const offset = i2 * reduceSize;
    let min7 = aVals[offset];
    for (let j2 = 0; j2 < reduceSize; ++j2) {
      const value = aVals[offset + j2];
      if (Number.isNaN(value) || value < min7) {
        min7 = value;
      }
    }
    vals[i2] = min7;
  }
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo($x);
  }
  const result = backend22.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: expandedShape } });
    backend22.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var minConfig = {
  kernelName: Min,
  backendName: "cpu",
  kernelFunc: min3
};
function mirrorPad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { paddings, mode } = attrs;
  assertNotComplex(x2, "mirrorPad");
  const outShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
  const start = paddings.map((p22) => p22[0]);
  const end = paddings.map((p22, i2) => p22[0] + x2.shape[i2]);
  const offset = mode === "reflect" ? 0 : 1;
  const xVals = backend22.data.get(x2.dataId).values;
  const xRank = x2.shape.length;
  const xStrides = util_exports.computeStrides(x2.shape);
  const resultSize = util_exports.sizeFromShape(outShape);
  const resultRank = outShape.length;
  const resultStrides = util_exports.computeStrides(outShape);
  const resVals = util_exports.getTypedArrayFromDType(x2.dtype, resultSize);
  for (let i2 = 0; i2 < resultSize; i2++) {
    let coords32 = util_exports.indexToLoc(i2, resultRank, resultStrides);
    for (let i22 = 0; i22 < resultRank; i22++) {
      if (coords32[i22] < start[i22]) {
        coords32[i22] = start[i22] * 2 - coords32[i22] - offset;
      } else if (coords32[i22] >= end[i22]) {
        coords32[i22] = (end[i22] - 1) * 2 - coords32[i22] + offset;
      }
    }
    coords32 = coords32.map((c2, i22) => c2 - start[i22]);
    const inIndex = util_exports.locToIndex(coords32, xRank, xStrides);
    resVals[i2] = xVals[inIndex];
  }
  const outId = backend22.write(resVals, outShape, x2.dtype);
  return { dataId: outId, shape: outShape, dtype: x2.dtype };
}
var mirrorPadConfig = {
  kernelName: MirrorPad,
  backendName: "cpu",
  kernelFunc: mirrorPad2
};
var modImpl = createSimpleBinaryKernelImpl((aValue, bValue) => {
  const rem = aValue % bValue;
  if (aValue < 0 && bValue < 0 || aValue >= 0 && bValue >= 0) {
    return rem;
  } else {
    return (rem + bValue) % bValue;
  }
});
var mod2 = binaryKernelFunc(Mod, modImpl);
var modConfig = {
  kernelName: Mod,
  backendName: "cpu",
  kernelFunc: mod2
};
var seedrandom4 = __toModule(require_seedrandom2());
function softmax3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const logitsRank = logits.shape.length;
  let $dim = dim;
  if ($dim === -1) {
    $dim = logitsRank - 1;
  }
  if ($dim !== logitsRank - 1) {
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${logitsRank} and dim was ${$dim}`);
  }
  const axes = util_exports.parseAxisParam([$dim], logits.shape);
  const maxLogit = max3({
    inputs: { x: logits },
    backend: backend22,
    attrs: { reductionIndices: axes, keepDims: false }
  });
  const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
  const maxLogitReshaped = reshape3({ inputs: { x: maxLogit }, backend: backend22, attrs: { shape: expandedShape } });
  const a6 = sub2({ inputs: { a: logits, b: maxLogitReshaped }, backend: backend22 });
  const b2 = exp2({ inputs: { x: a6 }, backend: backend22 });
  const sumExp = sum3({ inputs: { x: b2 }, backend: backend22, attrs: { axis: axes, keepDims: false } });
  const sumReshaped = reshape3({ inputs: { x: sumExp }, backend: backend22, attrs: { shape: expandedShape } });
  const result = div2({ inputs: { a: b2, b: sumReshaped }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(maxLogit);
  backend22.disposeIntermediateTensorInfo(maxLogitReshaped);
  backend22.disposeIntermediateTensorInfo(a6);
  backend22.disposeIntermediateTensorInfo(b2);
  backend22.disposeIntermediateTensorInfo(sumExp);
  backend22.disposeIntermediateTensorInfo(sumReshaped);
  return result;
}
var softmaxConfig = {
  kernelName: Softmax,
  backendName: "cpu",
  kernelFunc: softmax3
};
function multinomial2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { logits } = inputs;
  const { numSamples, seed, normalized } = attrs;
  assertNotComplex(logits, "multinomial");
  const probabilities = normalized ? logits : softmax3({ inputs: { logits }, backend: backend22, attrs: { dim: -1 } });
  const batchSize = probabilities.shape[0];
  const numEvents = probabilities.shape[1];
  const probVals = backend22.data.get(probabilities.dataId).values;
  const resShape = [batchSize, numSamples];
  const resVals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(resShape), "int32");
  for (let b2 = 0; b2 < batchSize; ++b2) {
    const offset = b2 * numEvents;
    const cdf = new Float32Array(numEvents - 1);
    cdf[0] = probVals[offset];
    for (let event = 1; event < cdf.length; ++event) {
      cdf[event] = cdf[event - 1] + probVals[offset + event];
    }
    const random = seedrandom4.alea(seed.toString());
    const outOffset = b2 * numSamples;
    for (let sampleId = 0; sampleId < numSamples; ++sampleId) {
      const r2 = random();
      resVals[outOffset + sampleId] = cdf.length;
      for (let event = 0; event < cdf.length; event++) {
        if (r2 < cdf[event]) {
          resVals[outOffset + sampleId] = event;
          break;
        }
      }
    }
  }
  if (!normalized) {
    backend22.disposeIntermediateTensorInfo(probabilities);
  }
  return backend22.makeTensorInfo(resShape, "int32", resVals);
}
var multinomialConfig = {
  kernelName: Multinomial,
  backendName: "cpu",
  kernelFunc: multinomial2
};
var nonMaxSuppressionV3Impl2 = kernel_impls_exports.nonMaxSuppressionV3Impl;
function nonMaxSuppressionV3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  assertNotComplex(boxes, "NonMaxSuppression");
  const boxesVals = backend22.data.get(boxes.dataId).values;
  const scoresVals = backend22.data.get(scores.dataId).values;
  const { selectedIndices } = nonMaxSuppressionV3Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Config = {
  kernelName: NonMaxSuppressionV3,
  backendName: "cpu",
  kernelFunc: nonMaxSuppressionV3
};
var nonMaxSuppressionV4Impl2 = kernel_impls_exports.nonMaxSuppressionV4Impl;
function nonMaxSuppressionV4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
  assertNotComplex(boxes, "NonMaxSuppressionPadded");
  const boxesVals = backend22.data.get(boxes.dataId).values;
  const scoresVals = backend22.data.get(scores.dataId).values;
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  return [
    backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend22.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
  ];
}
var nonMaxSuppressionV4Config = {
  kernelName: NonMaxSuppressionV4,
  backendName: "cpu",
  kernelFunc: nonMaxSuppressionV4
};
var nonMaxSuppressionV5Impl2 = kernel_impls_exports.nonMaxSuppressionV5Impl;
function nonMaxSuppressionV5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  assertNotComplex(boxes, "NonMaxSuppressionWithScore");
  const boxesVals = backend22.data.get(boxes.dataId).values;
  const scoresVals = backend22.data.get(scores.dataId).values;
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend22.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Config = {
  kernelName: NonMaxSuppressionV5,
  backendName: "cpu",
  kernelFunc: nonMaxSuppressionV5
};
function oneHot2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { indices } = inputs;
  const { depth, onValue, offValue } = attrs;
  assertNotComplex(indices, "oneHot");
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const res2 = new Float32Array(indicesSize * depth);
  res2.fill(offValue);
  const indicesVal = backend22.data.get(indices.dataId).values;
  for (let event = 0; event < indicesSize; ++event) {
    if (indicesVal[event] >= 0 && indicesVal[event] < depth) {
      res2[event * depth + indicesVal[event]] = onValue;
    }
  }
  return backend22.makeTensorInfo([...indices.shape, depth], "int32", res2);
}
var oneHotConfig = {
  kernelName: OneHot,
  backendName: "cpu",
  kernelFunc: oneHot2
};
function zerosLike2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "string") {
    throw new Error("zerosLike is not supported for string tensors");
  } else if (x2.dtype === "complex64") {
    const realPart = real2({ inputs: { input: x2 }, backend: backend22 });
    const r2 = zerosLike2({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag2({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike2({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex2({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(realPart);
    backend22.disposeIntermediateTensorInfo(r2);
    backend22.disposeIntermediateTensorInfo(imagPart);
    backend22.disposeIntermediateTensorInfo(i2);
    return result;
  } else {
    return fill2({ backend: backend22, attrs: { shape: x2.shape, value: 0, dtype: x2.dtype } });
  }
}
var zerosLikeConfig = {
  kernelName: ZerosLike,
  backendName: "cpu",
  kernelFunc: zerosLike2
};
function onesLike2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "string") {
    throw new Error("onesLike is not supported for string tensors");
  } else if (x2.dtype === "complex64") {
    const realPart = real2({ inputs: { input: x2 }, backend: backend22 });
    const r2 = onesLike2({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag2({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike2({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex2({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(realPart);
    backend22.disposeIntermediateTensorInfo(r2);
    backend22.disposeIntermediateTensorInfo(imagPart);
    backend22.disposeIntermediateTensorInfo(i2);
    return result;
  } else {
    return fill2({ backend: backend22, attrs: { shape: x2.shape, value: 1, dtype: x2.dtype } });
  }
}
var onesLikeConfig = {
  kernelName: OnesLike,
  backendName: "cpu",
  kernelFunc: onesLike2
};
function pack(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims3({ inputs: { input: inputs[0] }, backend: backend22, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t2) => {
    util_exports.assertShapesMatch(shape, t2.shape, "All tensors passed to stack must have matching shapes");
    util_exports.assert(dtype === t2.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t2) => {
    const expandedT = expandDims3({ inputs: { input: t2 }, backend: backend22, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat2({ inputs: expandedTensors, backend: backend22, attrs: { axis } });
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var packConfig = {
  kernelName: Pack,
  backendName: "cpu",
  kernelFunc: pack
};
function padV2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { paddings, constantValue } = attrs;
  assertNotComplex(x2, "pad");
  const outShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
  const start = paddings.map((p22) => p22[0]);
  const xVals = backend22.data.get(x2.dataId).values;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const xRank = x2.shape.length;
  const xStrides = util_exports.computeStrides(x2.shape);
  const resultSize = util_exports.sizeFromShape(outShape);
  const resultRank = outShape.length;
  const resultStrides = util_exports.computeStrides(outShape);
  const resVals = util_exports.getTypedArrayFromDType(x2.dtype, resultSize);
  if (constantValue !== 0) {
    resVals.fill(constantValue);
  }
  for (let i2 = 0; i2 < xSize; i2++) {
    const coords32 = util_exports.indexToLoc(i2, xRank, xStrides);
    const outCoords = coords32.map((c2, i22) => c2 + start[i22]);
    const outIndex = util_exports.locToIndex(outCoords, resultRank, resultStrides);
    resVals[outIndex] = xVals[i2];
  }
  const outId = backend22.write(resVals, outShape, x2.dtype);
  return { dataId: outId, shape: outShape, dtype: x2.dtype };
}
var padV2Config = {
  kernelName: PadV2,
  backendName: "cpu",
  kernelFunc: padV2
};
var powImpl = createSimpleBinaryKernelImpl((a6, b2) => Math.pow(a6, b2));
var pow2 = binaryKernelFunc(Pow, powImpl);
var powConfig = {
  kernelName: Pow,
  backendName: "cpu",
  kernelFunc: pow2
};
function range3(args) {
  const { backend: backend22, attrs } = args;
  const { start, stop, dtype, step: step5 } = attrs;
  const values = rangeImpl(start, stop, step5, dtype);
  return backend22.makeTensorInfo([values.length], dtype, values);
}
var rangeConfig = {
  kernelName: Range,
  backendName: "cpu",
  kernelFunc: range3
};
var reciprocal2 = unaryKernelFunc(Reciprocal, (xi) => 1 / xi);
var reciprocalConfig = {
  kernelName: Reciprocal,
  backendName: "cpu",
  kernelFunc: reciprocal2
};
function resizeBilinear2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  assertNotComplex(images, "resizeBilinear");
  const imagesStrides = util_exports.computeStrides(images.shape);
  const [newHeight, newWidth] = size2;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const xValues = backend22.data.get(images.dataId).values;
  const result = new Float32Array(util_exports.sizeFromShape([batch, newHeight, newWidth, numChannels]));
  const effectiveInputSize = [
    alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
    alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
  ];
  const effectiveOutputSize = [
    alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
    alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
  ];
  let outputIdx = 0;
  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
  for (let b2 = 0; b2 < batch; b2++) {
    for (let r2 = 0; r2 < newHeight; r2++) {
      let sourceFracRow;
      if (halfPixelCenters) {
        sourceFracRow = effectiveRowSizeRatio * (r2 + 0.5) - 0.5;
      } else {
        sourceFracRow = effectiveRowSizeRatio * r2;
      }
      const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));
      const rowFrac = sourceFracRow - sourceRowFloor;
      const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
      const topRowOffset = b2 * imagesStrides[0] + sourceRowFloor * imagesStrides[1];
      const botRowOffset = b2 * imagesStrides[0] + sourceRowCeil * imagesStrides[1];
      for (let c2 = 0; c2 < newWidth; c2++) {
        let sourceFracCol;
        if (halfPixelCenters) {
          sourceFracCol = effectiveColSizeRatio * (c2 + 0.5) - 0.5;
        } else {
          sourceFracCol = effectiveColSizeRatio * c2;
        }
        const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));
        const colFrac = sourceFracCol - sourceColFloor;
        const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
        const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];
        const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];
        const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];
        const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];
        for (let d2 = 0; d2 < numChannels; d2++) {
          const topLeft = xValues[topLeftOffest + d2];
          const bottomLeft = xValues[botLeftOffset + d2];
          const topRight = xValues[topRightOffset + d2];
          const bottomRight = xValues[botRightOffest + d2];
          const top = topLeft + (topRight - topLeft) * colFrac;
          const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
          const newValue = top + (bottom - top) * rowFrac;
          result[outputIdx++] = newValue;
        }
      }
    }
  }
  return backend22.makeTensorInfo([batch, newHeight, newWidth, numChannels], "float32", result);
}
var resizeBilinearConfig = {
  kernelName: ResizeBilinear,
  backendName: "cpu",
  kernelFunc: resizeBilinear2
};
function resizeBilinearGrad(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images, dy } = inputs;
  const { alignCorners } = attrs;
  assertNotComplex([dy, images], "resizeBilinearGrad");
  const imagesStrides = util_exports.computeStrides(images.shape);
  const [batch, xHeight, xWidth, depth] = images.shape;
  const [, yHeight, yWidth] = dy.shape;
  const output = new Float32Array(batch * xHeight * xWidth * depth);
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const dyValues = backend22.data.get(dy.dataId).values;
  let offset = 0;
  for (let b2 = 0; b2 < batch; b2++) {
    const bOffset = b2 * imagesStrides[0];
    for (let r2 = 0; r2 < yHeight; r2++) {
      const dxR = r2 * heightScale;
      const topDxRIndex = Math.floor(dxR);
      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];
      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];
      const dxRLerp = dxR - topDxRIndex;
      const inverseDxRLerp = 1 - dxRLerp;
      for (let c2 = 0; c2 < yWidth; c2++) {
        const dxC = c2 * widthScale;
        const leftDxCIndex = Math.floor(dxC);
        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
        const dxCLerp = dxC - leftDxCIndex;
        const inverseDxCLerp = 1 - dxCLerp;
        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];
        const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];
        const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];
        const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];
        const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
        for (let d2 = 0; d2 < depth; d2++) {
          const dyVal = dyValues[offset++];
          output[topLeftRCOffset + d2] += dyVal * inverseDxRLerpTimesInverseDxCLerp;
          output[topRightRCOffset + d2] += dyVal * inverseDxRLerpTimesDxCLerp;
          output[bottomLeftRCOffset + d2] += dyVal * dxRLerpTimesInverseDxCLerp;
          output[bottomRightRCOffset + d2] += dyVal * dxRLerpTimesDxCLerp;
        }
      }
    }
  }
  return backend22.makeTensorInfo([batch, xWidth, xHeight, depth], "float32", output);
}
var resizeBilinearGradConfig2 = {
  kernelName: ResizeBilinearGrad,
  backendName: "cpu",
  kernelFunc: resizeBilinearGrad
};
function resizeNearestNeighbor2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  assertNotComplex(images, "resizeNearestNeighbor");
  const imagesStrides = util_exports.computeStrides(images.shape);
  const [newHeight, newWidth] = size2;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const xValues = backend22.data.get(images.dataId).values;
  const output = new Float32Array(batch * newHeight * newWidth * numChannels);
  const effectiveInputSize = [
    alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
    alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
  ];
  const effectiveOutputSize = [
    alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
    alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
  ];
  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
  let outputOffset = 0;
  for (let b2 = 0; b2 < batch; b2++) {
    const batchOffset = b2 * imagesStrides[0];
    for (let r2 = 0; r2 < newHeight; r2++) {
      const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r2 + 0.5) : effectiveRowSizeRatio * r2;
      let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
      if (halfPixelCenters) {
        sourceNearestRow = Math.max(0, sourceNearestRow);
      }
      const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];
      for (let c2 = 0; c2 < newWidth; c2++) {
        const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c2 + 0.5) : effectiveColSizeRatio * c2;
        let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
        if (halfPixelCenters) {
          sourceNearestCol = Math.max(0, sourceNearestCol);
        }
        const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];
        for (let d2 = 0; d2 < numChannels; d2++) {
          const newVal = xValues[colOffset + d2];
          output[outputOffset++] = newVal;
        }
      }
    }
  }
  return backend22.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);
}
var resizeNearestNeighborConfig = {
  kernelName: ResizeNearestNeighbor,
  backendName: "cpu",
  kernelFunc: resizeNearestNeighbor2
};
function resizeNearestNeighborGrad(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images, dy } = inputs;
  const { alignCorners } = attrs;
  assertNotComplex([dy, images], "resizeNearestNeighborGrad");
  const imagesStrides = util_exports.computeStrides(images.shape);
  const dyStrides = util_exports.computeStrides(dy.shape);
  const [batch, xHeight, xWidth, depth] = images.shape;
  const [, yHeight, yWidth] = dy.shape;
  const output = new Float32Array(batch * xHeight * xWidth * depth);
  const dyValues = backend22.data.get(dy.dataId).values;
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const invHeightScale = 1 / heightScale;
  const invWidthScale = 1 / widthScale;
  const winHeight = Math.ceil(invHeightScale) * 2 + 2;
  const winWidth = Math.ceil(invWidthScale) * 2 + 2;
  for (let b2 = 0; b2 < batch; b2++) {
    const batchOffset = b2 * imagesStrides[0];
    for (let r2 = 0; r2 < xHeight; r2++) {
      const rowOffset = batchOffset + r2 * imagesStrides[1];
      const startRLerp = Math.floor(r2 * invHeightScale);
      const startDyR = Math.floor(startRLerp - winHeight / 2);
      for (let c2 = 0; c2 < xWidth; c2++) {
        const colOffset = rowOffset + c2 * imagesStrides[2];
        const startCLerp = Math.floor(c2 * invWidthScale);
        const startDyC = Math.floor(startCLerp - winWidth / 2);
        for (let d2 = 0; d2 < depth; d2++) {
          let accum = 0;
          for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {
            const dyR = dyRIndex + startDyR;
            if (dyR < 0 || dyR >= yHeight) {
              continue;
            }
            const dyROffset = batchOffset + dyR * dyStrides[1];
            const sourceFracRow = dyR * heightScale;
            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
            if (r2 !== sourceNearestRow) {
              continue;
            }
            for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {
              const dyC = dyCIndex + startDyC;
              if (dyC < 0 || dyC >= yWidth) {
                continue;
              }
              const dyCOffset = dyROffset + dyC * dyStrides[2];
              const sourceFracCol = dyC * widthScale;
              const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
              if (c2 === sourceNearestCol) {
                accum += dyValues[dyCOffset + d2];
              }
            }
          }
          output[colOffset + d2] = accum;
        }
      }
    }
  }
  return backend22.makeTensorInfo(images.shape, images.dtype, output);
}
var resizeNearestNeighborGradConfig2 = {
  kernelName: ResizeNearestNeighborGrad,
  backendName: "cpu",
  kernelFunc: resizeNearestNeighborGrad
};
function reverse2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dims } = attrs;
  assertNotComplex(x2, "reverse");
  const xRank = x2.shape.length;
  const $dims = util_exports.parseAxisParam(dims, x2.shape);
  if (xRank === 0) {
    return identity2({ inputs: { x: x2 }, backend: backend22 });
  }
  const outBuf = new TensorBuffer(x2.shape, x2.dtype);
  const xBuf = backend22.bufferSync(x2);
  for (let i2 = 0; i2 < outBuf.size; i2++) {
    const outLoc = outBuf.indexToLoc(i2);
    const inLoc = outLoc.slice();
    $dims.forEach((d2) => inLoc[d2] = x2.shape[d2] - 1 - inLoc[d2]);
    outBuf.set(xBuf.get(...inLoc), ...outLoc);
  }
  return backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var reverseConfig = {
  kernelName: Reverse,
  backendName: "cpu",
  kernelFunc: reverse2
};
var rotateWithOffsetConfig = {
  kernelName: RotateWithOffset,
  backendName: "cpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const { radians, fillValue, center } = attrs;
    const cpuBackend = backend22;
    const output = util_exports.getTypedArrayFromDType(image32.dtype, util_exports.sizeFromShape(image32.shape));
    const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
    const [centerX, centerY] = backend_util_exports.getImageCenter(center, imageHeight, imageWidth);
    const fullOpacityValue = 255;
    const sinFactor = Math.sin(radians);
    const cosFactor = Math.cos(radians);
    const imageVals = cpuBackend.data.get(image32.dataId).values;
    for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
      const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
      for (let row = 0; row < imageHeight; row++) {
        const rowOffset = row * (imageWidth * numChannels);
        for (let col = 0; col < imageWidth; col++) {
          const colOffset = col * numChannels;
          for (let channel = 0; channel < numChannels; channel++) {
            const coords32 = [batch, row, col, channel];
            const x2 = coords32[2];
            const y2 = coords32[1];
            let coordX = (x2 - centerX) * cosFactor - (y2 - centerY) * sinFactor;
            let coordY = (x2 - centerX) * sinFactor + (y2 - centerY) * cosFactor;
            coordX = Math.round(coordX + centerX);
            coordY = Math.round(coordY + centerY);
            let outputValue = fillValue;
            if (typeof fillValue !== "number") {
              if (channel === 3) {
                outputValue = fullOpacityValue;
              } else {
                outputValue = fillValue[channel];
              }
            }
            if (coordX >= 0 && coordX < imageWidth && coordY >= 0 && coordY < imageHeight) {
              const rotatedRowOffset = coordY * (imageWidth * numChannels);
              const rotatedColOffset = coordX * numChannels;
              const imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;
              outputValue = imageVals[imageIdx];
            }
            const outIdx = batchOffset + rowOffset + colOffset + channel;
            output[outIdx] = outputValue;
          }
        }
      }
    }
    const dataId = cpuBackend.write(output, image32.shape, image32.dtype);
    return { dataId, shape: image32.shape, dtype: image32.dtype };
  }
};
var round3 = unaryKernelFunc(Round, (xi) => {
  const base2 = Math.floor(xi);
  if (xi - base2 < 0.5) {
    return Math.floor(xi);
  } else if (xi - base2 > 0.5) {
    return Math.ceil(xi);
  } else {
    if (base2 % 2 === 0) {
      return base2;
    } else {
      return base2 + 1;
    }
  }
});
var roundConfig = {
  kernelName: Round,
  backendName: "cpu",
  kernelFunc: round3
};
function scatterImpl(indices, updates, shape, outputSize2, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
  const flattenShape = [outputSize2 / sliceSize, sliceSize];
  const indicesData = indices.values;
  const updatesData = updates.values;
  if (outputSize2 === 0) {
    return buffer(shape, updates.dtype);
  }
  const outBuf = buffer(flattenShape, updates.dtype);
  outBuf.values.fill(defaultValue);
  for (let i2 = 0; i2 < numUpdates; i2++) {
    const index = [];
    let flattenIndex = 0;
    for (let j2 = 0; j2 < sliceRank; j2++) {
      const dim = indicesData[i2 * sliceRank + j2];
      index.push(dim);
      flattenIndex += dim * strides[j2];
    }
    if (flattenIndex < 0 || flattenIndex >= outputSize2 / sliceSize) {
      throw new Error(`Invalid indices: ${index} does not index into ${shape}`);
    }
    for (let k3 = 0; k3 < sliceSize; k3++) {
      if (sumDupeIndices) {
        outBuf.values[flattenIndex * sliceSize + k3] += updatesData[i2 * sliceSize + k3];
      } else {
        outBuf.values[flattenIndex * sliceSize + k3] = updates.rank === 0 ? updatesData[0] : updatesData[i2 * sliceSize + k3];
      }
    }
  }
  return outBuf;
}
function scatterNd(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(updates, indices, shape);
  const sumDupeIndices = true;
  const indicesBuf = backend22.bufferSync(indices);
  const updatesBuf = backend22.bufferSync(updates);
  const outBuf = scatterImpl(indicesBuf, updatesBuf, shape, outputSize2, sliceSize, numUpdates, sliceRank, strides, 0, sumDupeIndices);
  return backend22.makeTensorInfo(shape, outBuf.dtype, outBuf.values);
}
var scatterNdConfig = {
  kernelName: ScatterNd,
  backendName: "cpu",
  kernelFunc: scatterNd
};
function select2(args) {
  const { inputs, backend: backend22 } = args;
  const { condition, t: t2, e: e2 } = inputs;
  assertNotComplex([condition, t2, e2], "select");
  const conditionRank = condition.shape.length;
  const values = backend22.data.get(condition.dataId).values;
  const tValues = backend22.data.get(t2.dataId).values;
  const eValues = backend22.data.get(e2.dataId).values;
  const resultDtype = upcastType(t2.dtype, e2.dtype);
  const newValues = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(t2.shape), resultDtype);
  let index = 0;
  const offset = conditionRank === 0 || conditionRank > 1 || t2.shape.length === 1 ? 1 : util_exports.sizeFromShape(t2.shape.slice(1));
  for (let i2 = 0; i2 < values.length; i2++) {
    for (let j2 = 0; j2 < offset; j2++) {
      if (values[i2] === 1) {
        newValues[index++] = tValues[i2];
      } else {
        newValues[index++] = eValues[i2];
      }
    }
  }
  return backend22.makeTensorInfo(t2.shape, resultDtype, newValues);
}
var selectConfig = {
  kernelName: Select,
  backendName: "cpu",
  kernelFunc: select2
};
var scaleAlpha = backend_util_exports.SELU_SCALEALPHA;
var scale = backend_util_exports.SELU_SCALE;
var selu2 = unaryKernelFunc(Selu, (xi) => {
  if (xi >= 0) {
    return scale * xi;
  } else {
    return scaleAlpha * (Math.exp(xi) - 1);
  }
});
var seluConfig = {
  kernelName: Selu,
  backendName: "cpu",
  kernelFunc: selu2
};
var sign22 = unaryKernelFunc(Sign, (xi) => {
  if (xi < 0) {
    return -1;
  } else if (xi > 0) {
    return 1;
  } else {
    return 0;
  }
});
var signConfig = {
  kernelName: Sign,
  backendName: "cpu",
  kernelFunc: sign22
};
var sin2 = unaryKernelFunc(Sin, (xi) => Math.sin(xi));
var sinConfig = {
  kernelName: Sin,
  backendName: "cpu",
  kernelFunc: sin2
};
var sinh2 = unaryKernelFunc(Sinh, (xi) => Math.sinh(xi));
var sinhConfig = {
  kernelName: Sinh,
  backendName: "cpu",
  kernelFunc: sinh2
};
var epsilon2 = 11920928955078125e-23;
var threshold2 = Math.log(epsilon2) + 2;
var softplus2 = unaryKernelFunc(Softplus, (xi) => {
  const tooLarge = xi > -threshold2;
  const tooSmall = xi < threshold2;
  const expX = Math.exp(xi);
  let result;
  if (tooSmall) {
    result = expX;
  } else if (tooLarge) {
    result = xi;
  } else {
    result = Math.log(1 + expX);
  }
  return result;
});
var softplusConfig = {
  kernelName: Softplus,
  backendName: "cpu",
  kernelFunc: softplus2
};
function spaceToBatchND2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, paddings } = attrs;
  assertNotComplex([x2], "spaceToBatchND");
  const prod6 = util_exports.sizeFromShape(blockShape);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i2 = 1 + blockShape.length; i2 < x2.shape.length; ++i2) {
    completePaddings.push([0, 0]);
  }
  const paddedX = padV2Config.kernelFunc({
    inputs: { x: x2 },
    backend: backend22,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod6, false);
  const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod6, false);
  const reshapeInputs = { x: paddedX };
  const reshapeAttrs = { shape: reshapedPaddedShape };
  const paddedXReshaped = reshape3({ inputs: reshapeInputs, backend: backend22, attrs: reshapeAttrs });
  const transposeInputs = { x: paddedXReshaped };
  const transposeAttrs = { perm: permutedReshapedPaddedPermutation };
  const paddedXT = transpose2({ inputs: transposeInputs, backend: backend22, attrs: transposeAttrs });
  const resultReshapeInputs = { x: paddedXT };
  const resultReshapeAttrs = { shape: flattenShape };
  const result = reshape3({ inputs: resultReshapeInputs, backend: backend22, attrs: resultReshapeAttrs });
  backend22.disposeIntermediateTensorInfo(paddedX);
  backend22.disposeIntermediateTensorInfo(paddedXReshaped);
  backend22.disposeIntermediateTensorInfo(paddedXT);
  return result;
}
var spaceToBatchNDConfig = {
  kernelName: SpaceToBatchND,
  backendName: "cpu",
  kernelFunc: spaceToBatchND2
};
function sparseFillEmptyRows2(args) {
  const { inputs, backend: backend22 } = args;
  const { indices, values, denseShape, defaultValue } = inputs;
  if (denseShape.shape.length !== 1) {
    throw new Error(`Dense shape must be a vector, saw:
        ${denseShape.shape}`);
  }
  if (indices.shape.length !== 2) {
    throw new Error(`Indices must be a matrix, saw:
        ${indices.shape}`);
  }
  if (values.shape.length !== 1) {
    throw new Error(`Values must be a vector, saw:
        ${values.shape}`);
  }
  if (defaultValue.shape.length !== 0) {
    throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
  }
  const $indices = backend22.data.get(indices.dataId).values;
  const $values = backend22.data.get(values.dataId).values;
  const $denseShape = backend22.data.get(denseShape.dataId).values;
  const $defaultValue = backend22.data.get(defaultValue.dataId).values[0];
  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
  return [
    backend22.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
    backend22.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
    backend22.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
    backend22.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
  ];
}
var sparseFillEmptyRowsConfig = {
  kernelName: SparseFillEmptyRows,
  backendName: "cpu",
  kernelFunc: sparseFillEmptyRows2
};
function sparseReshape2(args) {
  const { inputs, backend: backend22 } = args;
  const { inputIndices, inputShape, newShape } = inputs;
  if (inputIndices.shape.length !== 2) {
    throw new Error(`Input indices should be a matrix but received shape
        ${inputIndices.shape}`);
  }
  if (inputShape.shape.length !== 1) {
    throw new Error(`Input shape should be a vector but received shape
        ${inputShape.shape}`);
  }
  if (newShape.shape.length !== 1) {
    throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
  }
  const $inputShape = Array.from(backend22.data.get(inputShape.dataId).values);
  const $inputIndices = backend22.data.get(inputIndices.dataId).values;
  const targetShape = Array.from(backend22.data.get(newShape.dataId).values);
  const [newIndices, indicesShape, outputShape] = sparseReshapeImpl($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
  return [
    backend22.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
    backend22.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
  ];
}
var sparseReshapeConfig = {
  kernelName: SparseReshape,
  backendName: "cpu",
  kernelFunc: sparseReshape2
};
function sparseSegmentMean2(args) {
  const { inputs, backend: backend22 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
          ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
          ${segmentIds.shape}`);
  }
  const $data = backend22.data.get(data.dataId).values;
  const $indices = backend22.data.get(indices.dataId).values;
  const $segmentIds = backend22.data.get(segmentIds.dataId).values;
  const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds, true);
  return backend22.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentMeanConfig = {
  kernelName: SparseSegmentMean,
  backendName: "cpu",
  kernelFunc: sparseSegmentMean2
};
function sparseSegmentSum2(args) {
  const { inputs, backend: backend22 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
         ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
         ${segmentIds.shape}`);
  }
  const $data = backend22.data.get(data.dataId).values;
  const $indices = backend22.data.get(indices.dataId).values;
  const $segmentIds = backend22.data.get(segmentIds.dataId).values;
  const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds);
  return backend22.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentSumConfig = {
  kernelName: SparseSegmentSum,
  backendName: "cpu",
  kernelFunc: sparseSegmentSum2
};
function sparseToDense2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  const indicesBuf = backend22.bufferSync(sparseIndices);
  const updatesBuf = backend22.bufferSync(sparseValues);
  const $defaultValue = backend22.data.get(defaultValue.dataId).values[0];
  const outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize2, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
  return backend22.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
}
var sparseToDenseConfig = {
  kernelName: SparseToDense,
  backendName: "cpu",
  kernelFunc: sparseToDense2
};
function splitV(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const splitSizes = backend_util_exports.prepareSplitSize(x2, numOrSizeSplits, $axis);
  const begin = new Array(x2.shape.length).fill(0);
  const size2 = x2.shape.slice();
  return splitSizes.map((s2) => {
    const sliceSize = [...size2];
    sliceSize[$axis] = s2;
    const sliceT = slice2({ inputs: { x: x2 }, backend: backend22, attrs: { begin, size: sliceSize } });
    begin[$axis] += s2;
    return sliceT;
  });
}
var splitVConfig = {
  kernelName: SplitV,
  backendName: "cpu",
  kernelFunc: splitV
};
var squareConfig = {
  kernelName: Square,
  backendName: "cpu",
  kernelFunc: ({ inputs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const cpuBackend = backend22;
    assertNotComplex(x2, "square");
    const values = cpuBackend.data.get(x2.dataId).values;
    const newValues = new Float32Array(values.length);
    for (let i2 = 0; i2 < values.length; ++i2) {
      const value = values[i2];
      newValues[i2] = value * value;
    }
    const dataId = cpuBackend.write(newValues, x2.shape, x2.dtype);
    return { dataId, shape: x2.shape, dtype: x2.dtype };
  }
};
var step2 = unaryKernelFunc(Step, (xi, attrs) => {
  const stepAttrs = attrs;
  if (isNaN(xi)) {
    return NaN;
  } else {
    return xi > 0 ? 1 : stepAttrs.alpha;
  }
});
var stepConfig = {
  kernelName: Step,
  backendName: "cpu",
  kernelFunc: step2
};
function stridedSlice2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  assertNotComplex(x2, "stridedSlice");
  const { nonStrided, $begin, $strides, size: size2, newShape, outShape } = slice_util_exports.sliceInfo(x2.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  const $x = reshape3({ inputs: { x: x2 }, backend: backend22, attrs: { shape: newShape } });
  let result;
  if (nonStrided) {
    const sliced = slice2({ inputs: { x: $x }, backend: backend22, attrs: { begin: $begin, size: size2 } });
    result = reshape3({ inputs: { x: sliced }, backend: backend22, attrs: { shape: outShape } });
    backend22.disposeIntermediateTensorInfo(sliced);
  } else if (outShape.some((axis) => axis === 0)) {
    result = backend22.makeTensorInfo(outShape, x2.dtype, []);
  } else {
    const xBuf = backend22.bufferSync($x);
    const outBuf = stridedSliceImpl(outShape, xBuf, $strides, $begin);
    result = backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  const resultReshaped = reshape3({ inputs: { x: result }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeIntermediateTensorInfo($x);
  backend22.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var stridedSliceConfig = {
  kernelName: StridedSlice,
  backendName: "cpu",
  kernelFunc: stridedSlice2
};
function stringNGrams2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend22.data.get(data.dataId).values;
  const $dataSplits = backend22.data.get(dataSplits.dataId).values;
  const [nGrams, nGramsSplits] = stringNGramsImpl($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend22.makeTensorInfo([nGrams.length], "string", nGrams),
    backend22.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig = {
  kernelName: StringNGrams,
  backendName: "cpu",
  kernelFunc: stringNGrams2
};
function stringSplit2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { skipEmpty } = attrs;
  const { input: input2, delimiter } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (input2.shape.length !== 1) {
    throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
  }
  if (delimiter.shape.length !== 0) {
    throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
  }
  const $input = backend22.data.get(input2.dataId).values;
  const $delimiter = backend22.data.get(delimiter.dataId).values[0];
  const [indices, values, shape] = stringSplitImpl($input, $delimiter, skipEmpty);
  const outputSize2 = values.length;
  return [
    backend22.makeTensorInfo([outputSize2, 2], "int32", indices),
    backend22.makeTensorInfo([outputSize2], "string", values),
    backend22.makeTensorInfo([2], "int32", new Int32Array(shape))
  ];
}
var stringSplitConfig = {
  kernelName: StringSplit,
  backendName: "cpu",
  kernelFunc: stringSplit2
};
function stringToHashBucketFast2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { numBuckets } = attrs;
  const { input: input2 } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const $input = backend22.data.get(input2.dataId).values;
  const output = stringToHashBucketFastImpl($input, numBuckets);
  return backend22.makeTensorInfo(input2.shape, "int32", output);
}
var stringToHashBucketFastConfig = {
  kernelName: StringToHashBucketFast,
  backendName: "cpu",
  kernelFunc: stringToHashBucketFast2
};
var tan2 = unaryKernelFunc(Tan, (xi) => Math.tan(xi));
var tanConfig = {
  kernelName: Tan,
  backendName: "cpu",
  kernelFunc: tan2
};
var tanh3 = unaryKernelFunc(Tanh, (xi) => Math.tanh(xi));
var tanhConfig = {
  kernelName: Tanh,
  backendName: "cpu",
  kernelFunc: tanh3
};
function tile3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { reps } = attrs;
  assertNotComplex(x2, "tile");
  const outBuf = tileImpl(backend22.bufferSync(x2), reps);
  return backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var tileConfig = {
  kernelName: Tile,
  backendName: "cpu",
  kernelFunc: tile3
};
function topK(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { k: k3, sorted } = attrs;
  assertNotComplex(x2, "topk");
  const xVals = backend22.data.get(x2.dataId).values;
  const [allTopKVals, allTopKIndices] = topKImpl(xVals, x2.shape, x2.dtype, k3, sorted);
  return [
    backend22.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
    backend22.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
  ];
}
var topKConfig = {
  kernelName: TopK,
  backendName: "cpu",
  kernelFunc: topK
};
function transform2(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { image: image32, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [batch, outHeight, outWidth, numChannels];
  const strides = util_exports.computeStrides(image32.shape);
  const batchStride = strides[0];
  const rowStride = strides[1];
  const colStride = strides[2];
  const outVals = util_exports.getTypedArrayFromDType(image32.dtype, util_exports.sizeFromShape(outShape));
  outVals.fill(fillValue);
  const imageVals = backend22.data.get(image32.dataId).values;
  const transformVals = backend22.data.get(transforms.dataId).values;
  for (let b2 = 0; b2 < batch; ++b2) {
    const transform6 = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b2 * 8, b2 * 8 + 8);
    for (let outY = 0; outY < outHeight; ++outY) {
      for (let outX = 0; outX < outWidth; ++outX) {
        for (let channel = 0; channel < numChannels; ++channel) {
          let val;
          const projection = transform6[6] * outX + transform6[7] * outY + 1;
          if (projection === 0) {
            continue;
          }
          const inX = (transform6[0] * outX + transform6[1] * outY + transform6[2]) / projection;
          const inY = (transform6[3] * outX + transform6[4] * outY + transform6[5]) / projection;
          const x2 = mapCoord(inX, imageWidth, fillMode);
          const y2 = mapCoord(inY, imageHeight, fillMode);
          switch (interpolation) {
            case "nearest":
              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b2, y2, x2, channel, fillValue);
              break;
            case "bilinear":
              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b2, y2, x2, channel, fillValue);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${interpolation}`);
          }
          const ind = b2 * batchStride + outY * rowStride + outX * colStride + channel;
          outVals[ind] = val;
        }
      }
    }
    return backend22.makeTensorInfo(outShape, image32.dtype, outVals);
  }
  const dataId = backend22.write(outVals, outShape, image32.dtype);
  return { dataId, shape: image32.shape, dtype: image32.dtype };
}
var transformConfig = {
  kernelName: Transform,
  backendName: "cpu",
  kernelFunc: transform2
};
function mapCoord(outCoord, len, mode) {
  switch (mode) {
    case "reflect":
      return mapCoordReflect(outCoord, len);
    case "wrap":
      return mapCoordWrap(outCoord, len);
    case "nearest":
      return mapCoordNearest(outCoord, len);
    case "constant":
    default:
      return mapCoordConstant(outCoord, len);
  }
}
function mapCoordReflect(outCoord, len) {
  let inCoord = outCoord;
  if (inCoord < 0) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz2 = 2 * len;
      if (inCoord < sz2) {
        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;
      }
      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;
    }
  } else if (inCoord > len - 1) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz2 = 2 * len;
      inCoord -= sz2 * Math.trunc(inCoord / sz2);
      if (inCoord >= len) {
        inCoord = sz2 - inCoord - 1;
      }
    }
  }
  return util_exports.clamp(0, inCoord, len - 1);
}
function mapCoordWrap(outCoord, len) {
  let inCoord = outCoord;
  if (inCoord < 0) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz = len - 1;
      inCoord += len * (Math.trunc(-inCoord / sz) + 1);
    }
  } else if (inCoord > len - 1) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz = len - 1;
      inCoord -= len * Math.trunc(inCoord / sz);
    }
  }
  return util_exports.clamp(0, inCoord, len - 1);
}
function mapCoordConstant(outCoord, len) {
  return outCoord;
}
function mapCoordNearest(outCoord, len) {
  return util_exports.clamp(0, outCoord, len - 1);
}
function readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y2, x2, channel, fillValue) {
  const ind = batch * batchStride + y2 * rowStride + x2 * colStride + channel;
  if (0 <= y2 && y2 < imageHeight && 0 <= x2 && x2 < imageWidth) {
    return imageVals[ind];
  } else {
    return fillValue;
  }
}
function nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y2, x2, channel, fillValue) {
  const $y = Math.round(y2);
  const $x = Math.round(x2);
  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);
}
function bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y2, x2, channel, fillValue) {
  const yFloor = Math.floor(y2);
  const xFloor = Math.floor(x2);
  const yCeil = yFloor + 1;
  const xCeil = xFloor + 1;
  const valueYFloor = (xCeil - x2) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x2 - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);
  const valueYCeil = (xCeil - x2) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x2 - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);
  return (yCeil - y2) * valueYFloor + (y2 - yFloor) * valueYCeil;
}
function unique3(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { axis } = attrs;
  const { x: x2 } = inputs;
  assertNotComplex(x2, "unique");
  const values = backend22.data.get(x2.dataId).values;
  const { outputValues, outputShape, indices } = uniqueImpl(values, axis, x2.shape, x2.dtype);
  return [
    backend22.makeTensorInfo(outputShape, x2.dtype, outputValues),
    backend22.makeTensorInfo([indices.length], "int32", indices)
  ];
}
var uniqueConfig = {
  kernelName: Unique,
  backendName: "cpu",
  kernelFunc: unique3
};
function unpack(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const valueRank = value.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(valueRank - 1);
  let outIndex = 0;
  for (let i2 = 0; i2 < valueRank; i2++) {
    if (i2 !== axis) {
      outShape[outIndex++] = value.shape[i2];
    }
  }
  const begin = new Array(valueRank).fill(0);
  const size2 = value.shape.slice();
  size2[axis] = 1;
  const res2 = new Array(num);
  for (let i2 = 0; i2 < res2.length; i2++) {
    begin[axis] = i2;
    const tempRes = slice2({ inputs: { x: value }, backend: backend22, attrs: { begin, size: size2 } });
    res2[i2] = reshape3({ inputs: { x: tempRes }, backend: backend22, attrs: { shape: outShape } });
    backend22.disposeIntermediateTensorInfo(tempRes);
  }
  return res2;
}
var unpackConfig = {
  kernelName: Unpack,
  backendName: "cpu",
  kernelFunc: unpack
};
function unsortedSegmentSum2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, segmentIds } = inputs;
  const { numSegments } = attrs;
  assertNotComplex(x2, "unsortedSegmentSum");
  const xRank = x2.shape.length;
  const segmentIdsRank = segmentIds.shape.length;
  const res2 = [];
  const intermediates = [];
  const numIters = xRank - segmentIdsRank;
  let $segmentIds = segmentIds;
  for (let i2 = 0; i2 < numIters; ++i2) {
    const expanded = expandDims3({ inputs: { input: $segmentIds }, backend: backend22, attrs: { dim: i2 + 1 } });
    $segmentIds = expanded;
    intermediates.push(expanded);
  }
  for (let i2 = 0; i2 < numSegments; ++i2) {
    const scalarValue = util_exports.createScalarValue(i2, "int32");
    const segmentId = backend22.makeTensorInfo([], "int32", scalarValue);
    const mask = equal2({ inputs: { a: segmentId, b: $segmentIds }, backend: backend22 });
    const maskCasted = cast3({ inputs: { x: mask }, backend: backend22, attrs: { dtype: "float32" } });
    const mul2 = multiply2({ inputs: { a: maskCasted, b: x2 }, backend: backend22 });
    const sumTensorInfo = sum3({ inputs: { x: mul2 }, backend: backend22, attrs: { axis: 0, keepDims: false } });
    res2.push(sumTensorInfo);
    intermediates.push(segmentId);
    intermediates.push(mask);
    intermediates.push(maskCasted);
    intermediates.push(mul2);
    intermediates.push(sumTensorInfo);
  }
  const result = pack({ inputs: res2, backend: backend22, attrs: { axis: 0 } });
  intermediates.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var unsortedSegmentSumConfig = {
  kernelName: UnsortedSegmentSum,
  backendName: "cpu",
  kernelFunc: unsortedSegmentSum2
};
var kernelConfigs = [
  _fusedMatMulConfig,
  absConfig,
  acosConfig,
  acoshConfig,
  addConfig,
  addNConfig,
  allConfig,
  anyConfig,
  argMaxConfig,
  argMinConfig,
  asinConfig,
  asinhConfig,
  atanConfig,
  atan2Config,
  atanhConfig,
  avgPoolConfig,
  avgPool3DConfig,
  avgPool3DGradConfig2,
  avgPoolGradConfig2,
  batchMatMulConfig,
  batchNormConfig,
  batchToSpaceNDConfig,
  bincountConfig,
  broadcastArgsConfig,
  castConfig,
  ceilConfig,
  clipConfig,
  complexConfig,
  complexAbsConfig,
  concatConfig,
  conv2DBackpropFilterConfig,
  conv2DBackpropInputConfig,
  conv2DConfig,
  conv3DBackpropFilterV2Config,
  conv3DBackpropInputV2Config,
  conv3DConfig,
  cosConfig,
  coshConfig,
  cropAndResizeConfig,
  cumsumConfig,
  denseBincountConfig,
  depthToSpaceConfig,
  depthwiseConv2dNativeConfig,
  depthwiseConv2dNativeBackpropFilterConfig,
  depthwiseConv2dNativeBackpropInputConfig,
  diagConfig,
  dilation2dConfig,
  dilation2dBackpropInputConfig,
  dilation2dBackpropFilterConfig,
  realDivConfig,
  einsumConfig,
  eluConfig,
  eluGradConfig2,
  equalConfig,
  erfConfig,
  expConfig,
  expandDimsConfig,
  expm1Config,
  fftConfig,
  fillConfig,
  flipLeftRightConfig,
  floorConfig,
  floorDivConfig,
  fusedConv2DConfig,
  fusedDepthwiseConv2DConfig,
  gatherNdConfig,
  gatherV2Config,
  greaterConfig,
  greaterEqualConfig,
  identityConfig,
  ifftConfig,
  imagConfig,
  isFiniteConfig,
  isInfConfig,
  isNaNConfig,
  leakyReluConfig,
  lessConfig,
  lessEqualConfig,
  linSpaceConfig,
  logConfig,
  log1pConfig,
  logicalAndConfig,
  logicalNotConfig,
  logicalOrConfig,
  lRNConfig,
  lRNGradConfig,
  maximumConfig,
  maxPoolConfig,
  maxPool3DConfig,
  maxPool3DGradConfig2,
  maxPoolGradConfig2,
  maxPoolWithArgmaxConfig,
  maxConfig,
  meanConfig,
  minConfig,
  minimumConfig,
  mirrorPadConfig,
  modConfig,
  multinomialConfig,
  multiplyConfig,
  negConfig,
  nonMaxSuppressionV3Config,
  nonMaxSuppressionV4Config,
  nonMaxSuppressionV5Config,
  notEqualConfig,
  oneHotConfig,
  onesLikeConfig,
  packConfig,
  padV2Config,
  powConfig,
  preluConfig,
  prodConfig,
  rangeConfig,
  realConfig,
  reciprocalConfig,
  reluConfig,
  relu6Config,
  reshapeConfig,
  resizeBilinearConfig,
  resizeBilinearGradConfig2,
  resizeNearestNeighborConfig,
  resizeNearestNeighborGradConfig2,
  reverseConfig,
  rotateWithOffsetConfig,
  roundConfig,
  rsqrtConfig,
  scatterNdConfig,
  selectConfig,
  seluConfig,
  sigmoidConfig,
  signConfig,
  sinConfig,
  sinhConfig,
  sliceConfig,
  softmaxConfig,
  softplusConfig,
  spaceToBatchNDConfig,
  sparseFillEmptyRowsConfig,
  sparseReshapeConfig,
  sparseSegmentMeanConfig,
  sparseSegmentSumConfig,
  sparseToDenseConfig,
  splitVConfig,
  sqrtConfig,
  squareConfig,
  squaredDifferenceConfig,
  stepConfig,
  stridedSliceConfig,
  stringNGramsConfig,
  stringSplitConfig,
  stringToHashBucketFastConfig,
  subConfig,
  sumConfig,
  tanConfig,
  tanhConfig,
  tileConfig,
  topKConfig,
  transposeConfig,
  transformConfig,
  uniqueConfig,
  unpackConfig,
  unsortedSegmentSumConfig,
  zerosLikeConfig
];
for (const kernelConfig of kernelConfigs) {
  registerKernel(kernelConfig);
}
var webgl_util_exports = {};
__export2(webgl_util_exports, {
  assertNotComplex: () => assertNotComplex2,
  bindCanvasToFramebuffer: () => bindCanvasToFramebuffer,
  bindColorTextureToFramebuffer: () => bindColorTextureToFramebuffer,
  bindTextureToProgramUniformSampler: () => bindTextureToProgramUniformSampler,
  bindTextureUnit: () => bindTextureUnit,
  bindVertexBufferToProgramAttribute: () => bindVertexBufferToProgramAttribute,
  callAndCheck: () => callAndCheck,
  canBeRepresented: () => canBeRepresented,
  createFragmentShader: () => createFragmentShader,
  createFramebuffer: () => createFramebuffer,
  createProgram: () => createProgram,
  createStaticIndexBuffer: () => createStaticIndexBuffer,
  createStaticVertexBuffer: () => createStaticVertexBuffer,
  createTexture: () => createTexture,
  createVertexShader: () => createVertexShader,
  getBatchDim: () => getBatchDim,
  getExtensionOrThrow: () => getExtensionOrThrow,
  getFramebufferErrorMessage: () => getFramebufferErrorMessage,
  getMaxTexturesInShader: () => getMaxTexturesInShader,
  getNumChannels: () => getNumChannels,
  getProgramUniformLocation: () => getProgramUniformLocation,
  getProgramUniformLocationOrThrow: () => getProgramUniformLocationOrThrow,
  getRowsCols: () => getRowsCols,
  getShapeAs3D: () => getShapeAs3D,
  getTextureShapeFromLogicalShape: () => getTextureShapeFromLogicalShape,
  getWebGLDisjointQueryTimerVersion: () => getWebGLDisjointQueryTimerVersion,
  getWebGLErrorMessage: () => getWebGLErrorMessage,
  getWebGLMaxTextureSize: () => getWebGLMaxTextureSize,
  hasExtension: () => hasExtension,
  isCapableOfRenderingToFloatTexture: () => isCapableOfRenderingToFloatTexture,
  isDownloadFloatTextureEnabled: () => isDownloadFloatTextureEnabled,
  isReshapeFree: () => isReshapeFree,
  isWebGLFenceEnabled: () => isWebGLFenceEnabled,
  isWebGLVersionEnabled: () => isWebGLVersionEnabled,
  linkProgram: () => linkProgram,
  resetMaxTextureSize: () => resetMaxTextureSize,
  resetMaxTexturesInShader: () => resetMaxTexturesInShader,
  unbindColorTextureFromFramebuffer: () => unbindColorTextureFromFramebuffer,
  unbindTextureUnit: () => unbindTextureUnit,
  validateFramebuffer: () => validateFramebuffer,
  validateProgram: () => validateProgram,
  validateTextureSize: () => validateTextureSize
});
var contexts = {};
var WEBGL_ATTRIBUTES = {
  alpha: false,
  antialias: false,
  premultipliedAlpha: false,
  preserveDrawingBuffer: false,
  depth: false,
  stencil: false,
  failIfMajorPerformanceCaveat: true
};
function setWebGLContext(webGLVersion, gl) {
  contexts[webGLVersion] = gl;
}
function getWebGLContext(webGLVersion) {
  if (!(webGLVersion in contexts)) {
    const newCtx = getWebGLRenderingContext(webGLVersion);
    if (newCtx !== null) {
      contexts[webGLVersion] = newCtx;
    } else {
      console.log("Could not get context for WebGL version", webGLVersion);
      return null;
    }
  }
  const gl = contexts[webGLVersion];
  if (gl.isContextLost()) {
    delete contexts[webGLVersion];
    return getWebGLContext(webGLVersion);
  }
  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);
  gl.disable(gl.BLEND);
  gl.disable(gl.DITHER);
  gl.disable(gl.POLYGON_OFFSET_FILL);
  gl.disable(gl.SAMPLE_COVERAGE);
  gl.enable(gl.SCISSOR_TEST);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return contexts[webGLVersion];
}
function createCanvas(webGLVersion) {
  if (typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
    return new OffscreenCanvas(300, 150);
  } else if (typeof document !== "undefined") {
    return document.createElement("canvas");
  } else {
    throw new Error("Cannot create a canvas in this context");
  }
}
function getWebGLRenderingContext(webGLVersion) {
  if (webGLVersion !== 1 && webGLVersion !== 2) {
    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  }
  const canvas3 = createCanvas(webGLVersion);
  canvas3.addEventListener("webglcontextlost", (ev) => {
    ev.preventDefault();
    delete contexts[webGLVersion];
  }, false);
  if (webGLVersion === 1) {
    return canvas3.getContext("webgl", WEBGL_ATTRIBUTES) || canvas3.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
  }
  return canvas3.getContext("webgl2", WEBGL_ATTRIBUTES);
}
var PackingScheme;
(function(PackingScheme2) {
  PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
  PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
})(PackingScheme || (PackingScheme = {}));
var TextureUsage;
(function(TextureUsage2) {
  TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
  TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
  TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
  TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
})(TextureUsage || (TextureUsage = {}));
var PhysicalTextureType;
(function(PhysicalTextureType2) {
  PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
  PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
  PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
  PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
  PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
})(PhysicalTextureType || (PhysicalTextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
  return [columns, rows];
}
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
  return matrixSize * channelsPerTexture;
}
function getDenseTexShape(shape) {
  const size2 = util_exports.sizeFromShape(shape);
  const texelsNeeded = Math.ceil(size2 / 4);
  return util_exports.sizeToSquarishShape(texelsNeeded);
}
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
  return [
    Math.max(1, Math.ceil(columns / 2)),
    Math.max(1, Math.ceil(rows / 2))
  ];
}
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
  const [w2, h2] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return w2 * h2 * 4;
}
function getTextureConfig(gl, textureHalfFloatExtension) {
  const glany = gl;
  let internalFormatFloat;
  let internalFormatHalfFloat;
  let internalFormatPackedHalfFloat;
  let internalFormatPackedFloat;
  let textureFormatFloat;
  let downloadTextureFormat;
  let downloadUnpackNumChannels;
  let defaultNumChannels;
  let textureTypeHalfFloat;
  let textureTypeFloat;
  if (env().getNumber("WEBGL_VERSION") === 2) {
    internalFormatFloat = glany.R32F;
    internalFormatHalfFloat = glany.R16F;
    internalFormatPackedHalfFloat = glany.RGBA16F;
    internalFormatPackedFloat = glany.RGBA32F;
    textureFormatFloat = glany.RED;
    downloadUnpackNumChannels = 4;
    defaultNumChannels = 1;
    textureTypeHalfFloat = glany.HALF_FLOAT;
    textureTypeFloat = glany.FLOAT;
  } else {
    internalFormatFloat = gl.RGBA;
    internalFormatHalfFloat = gl.RGBA;
    internalFormatPackedHalfFloat = gl.RGBA;
    internalFormatPackedFloat = glany.RGBA;
    textureFormatFloat = gl.RGBA;
    downloadUnpackNumChannels = 4;
    defaultNumChannels = 4;
    textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
    textureTypeFloat = gl.FLOAT;
  }
  downloadTextureFormat = gl.RGBA;
  return {
    internalFormatFloat,
    internalFormatHalfFloat,
    internalFormatPackedHalfFloat,
    internalFormatPackedFloat,
    textureFormatFloat,
    downloadTextureFormat,
    downloadUnpackNumChannels,
    defaultNumChannels,
    textureTypeHalfFloat,
    textureTypeFloat
  };
}
function callAndCheck(gl, func2) {
  const returnValue = func2();
  if (env().getBool("DEBUG")) {
    checkWebGLError(gl);
  }
  return returnValue;
}
function checkWebGLError(gl) {
  const error = gl.getError();
  if (error !== gl.NO_ERROR) {
    throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
  }
}
var MIN_FLOAT16 = 596e-10;
var MAX_FLOAT16 = 65504;
function canBeRepresented(num) {
  if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
    return true;
  }
  return false;
}
function getWebGLErrorMessage(gl, status) {
  switch (status) {
    case gl.NO_ERROR:
      return "NO_ERROR";
    case gl.INVALID_ENUM:
      return "INVALID_ENUM";
    case gl.INVALID_VALUE:
      return "INVALID_VALUE";
    case gl.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case gl.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case gl.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case gl.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return `Unknown error code ${status}`;
  }
}
function getExtensionOrThrow(gl, extensionName) {
  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
}
function createVertexShader(gl, vertexShaderSource) {
  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
  callAndCheck(gl, () => gl.compileShader(vertexShader));
  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
    console.log(gl.getShaderInfoLog(vertexShader));
    throw new Error("Failed to compile vertex shader.");
  }
  return vertexShader;
}
function createFragmentShader(gl, fragmentShaderSource) {
  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
  callAndCheck(gl, () => gl.compileShader(fragmentShader));
  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
    throw new Error("Failed to compile fragment shader.");
  }
  return fragmentShader;
}
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
  if (lineNumberRegexResult == null) {
    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
    console.log(shaderSource);
    return;
  }
  const lineNumber = +lineNumberRegexResult[1];
  const shaderLines = shaderSource.split("\n");
  const pad3 = shaderLines.length.toString().length + 2;
  const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => util_exports.rightPad((lineNumber2 + 1).toString(), pad3) + line);
  let maxLineLength = 0;
  for (let i2 = 0; i2 < linesWithLineNumbers.length; i2++) {
    maxLineLength = Math.max(linesWithLineNumbers[i2].length, maxLineLength);
  }
  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
  console.log(beforeErrorLines.join("\n"));
  console.log(shaderInfoLog.split("\n")[0]);
  console.log(`%c ${util_exports.rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
  console.log(afterErrorLines.join("\n"));
}
function createProgram(gl) {
  return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
}
function linkProgram(gl, program) {
  callAndCheck(gl, () => gl.linkProgram(program));
  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    console.log(gl.getProgramInfoLog(program));
    throw new Error("Failed to link vertex and fragment shaders.");
  }
}
function validateProgram(gl, program) {
  callAndCheck(gl, () => gl.validateProgram(program));
  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
    console.log(gl.getProgramInfoLog(program));
    throw new Error("Shader program validation failed.");
  }
}
function createStaticVertexBuffer(gl, data) {
  const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
  return buffer2;
}
function createStaticIndexBuffer(gl, data) {
  const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer2));
  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
  return buffer2;
}
function getNumChannels() {
  if (env().getNumber("WEBGL_VERSION") === 2) {
    return 1;
  }
  return 4;
}
function createTexture(gl) {
  return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
}
function validateTextureSize(width, height) {
  const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (width <= 0 || height <= 0) {
    const requested = `[${width}x${height}]`;
    throw new Error("Requested texture size " + requested + " is invalid.");
  }
  if (width > maxTextureSize || height > maxTextureSize) {
    const requested = `[${width}x${height}]`;
    const max7 = `[${maxTextureSize}x${maxTextureSize}]`;
    throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max7 + ".");
  }
}
function createFramebuffer(gl) {
  return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer2, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
  const loc = gl.getAttribLocation(program, attribute);
  if (loc === -1) {
    return false;
  }
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
  return true;
}
function bindTextureUnit(gl, texture, textureUnit) {
  validateTextureUnit(gl, textureUnit);
  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
}
function unbindTextureUnit(gl, textureUnit) {
  validateTextureUnit(gl, textureUnit);
  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
}
function getProgramUniformLocation(gl, program, uniformName) {
  return gl.getUniformLocation(program, uniformName);
}
function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
}
function bindCanvasToFramebuffer(gl) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));
  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));
}
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
}
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
}
function validateFramebuffer(gl) {
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status));
  }
}
function getFramebufferErrorMessage(gl, status) {
  switch (status) {
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case gl.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return `unknown error ${status}`;
  }
}
function throwIfNull(gl, returnTOrNull, failureMessage) {
  const tOrNull = callAndCheck(gl, () => returnTOrNull());
  if (tOrNull == null) {
    throw new Error(failureMessage);
  }
  return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
  const glTextureUnit = textureUnit + gl.TEXTURE0;
  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
    throw new Error(`textureUnit must be in ${textureUnitRange}.`);
  }
}
function getBatchDim(shape, dimsToSkip = 2) {
  return util_exports.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
function getRowsCols(shape) {
  if (shape.length === 0) {
    throw Error("Cannot get rows and columns of an empty shape array.");
  }
  return [
    shape.length > 1 ? shape[shape.length - 2] : 1,
    shape[shape.length - 1]
  ];
}
function getShapeAs3D(shape) {
  let shapeAs3D = [1, 1, 1];
  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
  if (!isScalar) {
    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
  }
  return shapeAs3D;
}
function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
  let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (isPacked) {
    maxTexSize = maxTexSize * 2;
    logShape = logShape.map((d2, i2) => i2 >= logShape.length - 2 ? util_exports.nearestLargerEven(logShape[i2]) : logShape[i2]);
    if (logShape.length === 1) {
      logShape = [2, logShape[0]];
    }
  }
  if (logShape.length !== 2) {
    const squeezeResult = util_exports.squeezeShape(logShape);
    logShape = squeezeResult.newShape;
  }
  let size2 = util_exports.sizeFromShape(logShape);
  if (logShape.length <= 1 && size2 <= maxTexSize) {
    return [1, size2];
  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
    return logShape;
  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
    return [logShape[0] * logShape[1], logShape[2]];
  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
    return [logShape[0], logShape[1] * logShape[2]];
  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
  } else {
    if (isPacked) {
      const batchDim = getBatchDim(logShape);
      let rows = 2, cols = 2;
      if (logShape.length) {
        [rows, cols] = getRowsCols(logShape);
      }
      size2 = batchDim * (rows / 2) * (cols / 2);
      return util_exports.sizeToSquarishShape(size2).map((d2) => d2 * 2);
    }
    return util_exports.sizeToSquarishShape(size2);
  }
}
function isEven(n2) {
  return n2 % 2 === 0;
}
function isReshapeFree(shape1, shape2) {
  shape1 = shape1.slice(-2);
  shape2 = shape2.slice(-2);
  if (util_exports.arraysEqual(shape1, shape2)) {
    return true;
  }
  if (!shape1.length || !shape2.length) {
    return true;
  }
  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
    return true;
  }
  if (shape1.length !== shape2.length) {
    const shape1Cols = shape1.slice(-1)[0];
    const shape2Cols = shape2.slice(-1)[0];
    if (shape1Cols === shape2Cols) {
      return true;
    }
    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
      return true;
    }
  }
  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
}
var MAX_TEXTURE_SIZE;
var MAX_TEXTURES_IN_SHADER;
function getWebGLMaxTextureSize(webGLVersion) {
  if (MAX_TEXTURE_SIZE == null) {
    const gl = getWebGLContext(webGLVersion);
    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  }
  return MAX_TEXTURE_SIZE;
}
function resetMaxTextureSize() {
  MAX_TEXTURE_SIZE = null;
}
function resetMaxTexturesInShader() {
  MAX_TEXTURES_IN_SHADER = null;
}
function getMaxTexturesInShader(webGLVersion) {
  if (MAX_TEXTURES_IN_SHADER == null) {
    const gl = getWebGLContext(webGLVersion);
    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, MAX_TEXTURES_IN_SHADER);
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
  if (webGLVersion === 0) {
    return 0;
  }
  let queryTimerVersion;
  const gl = getWebGLContext(webGLVersion);
  if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
    queryTimerVersion = 2;
  } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
    queryTimerVersion = 1;
  } else {
    queryTimerVersion = 0;
  }
  return queryTimerVersion;
}
function hasExtension(gl, extensionName) {
  const ext = gl.getExtension(extensionName);
  return ext != null;
}
function isWebGLVersionEnabled(webGLVersion) {
  try {
    const gl = getWebGLContext(webGLVersion);
    if (gl != null) {
      return true;
    }
  } catch (e2) {
    console.log("Error when getting WebGL context: ", e2);
    return false;
  }
  return false;
}
function isCapableOfRenderingToFloatTexture(webGLVersion) {
  if (webGLVersion === 0) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  if (webGLVersion === 1) {
    if (!hasExtension(gl, "OES_texture_float")) {
      return false;
    }
  } else {
    if (!hasExtension(gl, "EXT_color_buffer_float")) {
      return false;
    }
  }
  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
  return isFrameBufferComplete;
}
function isDownloadFloatTextureEnabled(webGLVersion) {
  if (webGLVersion === 0) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  if (webGLVersion === 1) {
    if (!hasExtension(gl, "OES_texture_float")) {
      return false;
    }
    if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
      return false;
    }
  } else {
    if (hasExtension(gl, "EXT_color_buffer_float")) {
      return createFloatTextureAndBindToFramebuffer(gl);
    }
    const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
    }
    return false;
  }
  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
  return isFrameBufferComplete;
}
function createFloatTextureAndBindToFramebuffer(gl) {
  const texConfig = getTextureConfig(gl);
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  const width = 1;
  const height = 1;
  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteTexture(texture);
  gl.deleteFramebuffer(frameBuffer);
  return isFrameBufferComplete;
}
function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  const width = 1;
  const height = 1;
  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteTexture(texture);
  gl.deleteFramebuffer(frameBuffer);
  return isFrameBufferComplete;
}
function isWebGLFenceEnabled(webGLVersion) {
  if (webGLVersion !== 2) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  const isEnabled = gl.fenceSync != null;
  return isEnabled;
}
function assertNotComplex2(tensor2, opName) {
  if (!Array.isArray(tensor2)) {
    tensor2 = [tensor2];
  }
  tensor2.forEach((t2) => {
    if (t2 != null) {
      util_exports.assert(t2.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
    }
  });
}
var ENV3 = env();
ENV3.registerFlag("HAS_WEBGL", () => ENV3.getNumber("WEBGL_VERSION") > 0);
ENV3.registerFlag("WEBGL_VERSION", () => {
  if (isWebGLVersionEnabled(2)) {
    return 2;
  } else if (isWebGLVersionEnabled(1)) {
    return 1;
  }
  return 0;
});
ENV3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
ENV3.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV3.get("WEBGL_VERSION") === 2);
ENV3.registerFlag("WEBGL_CPU_FORWARD", () => true);
ENV3.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
ENV3.registerFlag("WEBGL_PACK", () => ENV3.getBool("HAS_WEBGL"));
ENV3.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_CLIP", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_PACK_REDUCE", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_CONV_IM2COL", () => ENV3.getBool("WEBGL_PACK"));
ENV3.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV3.getNumber("WEBGL_VERSION")));
ENV3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV3.getNumber("WEBGL_VERSION")));
ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  const webGLVersion = ENV3.getNumber("WEBGL_VERSION");
  if (webGLVersion === 0) {
    return 0;
  }
  return getWebGLDisjointQueryTimerVersion(webGLVersion);
});
ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !device_util_exports.isMobile());
ENV3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV3.getNumber("WEBGL_VERSION")));
ENV3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
  return ENV3.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
});
ENV3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV3.getNumber("WEBGL_VERSION")));
ENV3.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV3.getNumber("WEBGL_VERSION")));
ENV3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
  const useUniforms = ENV3.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
  return useUniforms ? 4 : 0;
});
ENV3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
  return -1;
}, (threshold3) => {
  if (threshold3 < 0 && threshold3 !== -1) {
    throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold3}.`);
  }
});
ENV3.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
  return device_util_exports.isMobile() && ENV3.getBool("IS_CHROME") ? 1 : -1;
}, (threshold3) => {
  if (threshold3 < 0 && threshold3 !== -1) {
    throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${threshold3}.`);
  }
});
ENV3.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
ENV3.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
ENV3.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
ENV3.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
function getGlslDifferences() {
  let version10;
  let attribute;
  let varyingVs;
  let varyingFs;
  let texture2D;
  let output;
  let defineOutput;
  let defineSpecialNaN;
  let defineSpecialInf;
  let defineRound;
  if (env().getNumber("WEBGL_VERSION") === 2) {
    version10 = "#version 300 es";
    attribute = "in";
    varyingVs = "out";
    varyingFs = "in";
    texture2D = "texture";
    output = "outputColor";
    defineOutput = "out vec4 outputColor;";
    defineSpecialNaN = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `;
    defineSpecialInf = ``;
    defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
  } else {
    version10 = "";
    attribute = "attribute";
    varyingVs = "varying";
    varyingFs = "varying";
    texture2D = "texture2D";
    output = "gl_FragColor";
    defineOutput = "";
    defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
    defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
    defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
  }
  return {
    version: version10,
    attribute,
    varyingVs,
    varyingFs,
    texture2D,
    output,
    defineOutput,
    defineSpecialNaN,
    defineSpecialInf,
    defineRound
  };
}
function getLogicalCoordinatesFromFlatIndex(coords32, shape, index = "index") {
  const strides = util_exports.computeStrides(shape);
  return strides.map((stride, i2) => {
    const line1 = `int ${coords32[i2]} = ${index} / ${stride}`;
    const line2 = i2 === strides.length - 1 ? `int ${coords32[i2 + 1]} = ${index} - ${coords32[i2]} * ${stride}` : `index -= ${coords32[i2]} * ${stride}`;
    return `${line1}; ${line2};`;
  }).join("");
}
function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords32, shape, index = "index") {
  const strides = util_exports.computeStrides(shape);
  return strides.map((_2, i2) => {
    const line1 = `int ${coords32[i2]} = ${index} / outShapeStrides[${i2}]`;
    const line2 = i2 === strides.length - 1 ? `int ${coords32[i2 + 1]} = ${index} - ${coords32[i2]} * outShapeStrides[${i2}]` : `index -= ${coords32[i2]} * outShapeStrides[${i2}]`;
    return `${line1}; ${line2};`;
  }).join("");
}
function symbolicallyComputeStrides(indicesArr, variableName) {
  const numCoords = indicesArr.length;
  const shape = indicesArr.map((d2) => `${variableName}[${d2}]`);
  const strides = new Array(numCoords - 1);
  strides[numCoords - 2] = shape[numCoords - 1];
  for (let i2 = numCoords - 3; i2 >= 0; --i2) {
    strides[i2] = `(${strides[i2 + 1]} * ${shape[i2 + 1]})`;
  }
  return strides;
}
function getLogicalCoordinatesFromFlatIndexByUniform(coords32, variableName, index = "index") {
  const indicesArray = coords32.map((_2, i2) => i2);
  const strides = symbolicallyComputeStrides(indicesArray, variableName);
  return strides.map((_2, i2) => {
    const line1 = `int ${coords32[i2]} = ${index} / ${strides[i2]}`;
    const line2 = i2 === strides.length - 1 ? `int ${coords32[i2 + 1]} = ${index} - ${coords32[i2]} * ${strides[i2]}` : `index -= ${coords32[i2]} * ${strides[i2]}`;
    return `${line1}; ${line2};`;
  }).join("");
}
function getFlatIndexFrom3D(shape) {
  const strides = util_exports.computeStrides(shape).map((d2) => d2.toString());
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
}
function getFlatIndexFrom3DOutput() {
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
var ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
var { getBroadcastDims: getBroadcastDims2 } = backend_util_exports;
function makeShader(inputsInfo, outputShape, program) {
  const prefixSnippets = [];
  inputsInfo.forEach((x2) => {
    const size2 = util_exports.sizeFromShape(x2.shapeInfo.logicalShape);
    if (x2.shapeInfo.isUniform) {
      prefixSnippets.push(`uniform float ${x2.name}${size2 > 1 ? `[${size2}]` : ""};`);
    } else {
      prefixSnippets.push(`uniform sampler2D ${x2.name};`);
      prefixSnippets.push(`uniform int offset${x2.name};`);
    }
    if (program.enableShapeUniforms) {
      const { uniformShape } = getUniformInfoFromShape(program.packedInputs, x2.shapeInfo.logicalShape, x2.shapeInfo.texShape);
      switch (uniformShape.length) {
        case 1:
          prefixSnippets.push(`uniform int ${x2.name}Shape;`);
          break;
        case 2:
          prefixSnippets.push(`uniform ivec2 ${x2.name}Shape;`);
          break;
        case 3:
          prefixSnippets.push(`uniform ivec3 ${x2.name}Shape;`);
          break;
        case 4:
          prefixSnippets.push(`uniform ivec4 ${x2.name}Shape;`);
          break;
        default:
          break;
      }
      prefixSnippets.push(`uniform ivec2 ${x2.name}TexShape;`);
    }
  });
  if (program.enableShapeUniforms) {
    switch (outputShape.logicalShape.length) {
      case 1:
        prefixSnippets.push(`uniform int outShape;`);
        break;
      case 2:
        prefixSnippets.push(`uniform ivec2 outShape;`);
        prefixSnippets.push(`uniform int outShapeStrides;`);
        break;
      case 3:
        prefixSnippets.push(`uniform ivec3 outShape;`);
        prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
        break;
      case 4:
        prefixSnippets.push(`uniform ivec4 outShape;`);
        prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
        break;
      default:
        break;
    }
    prefixSnippets.push(`uniform ivec2 outTexShape;`);
  }
  if (program.customUniforms) {
    program.customUniforms.forEach((d2) => {
      prefixSnippets.push(`uniform ${d2.type} ${d2.name}${d2.arrayIndex ? `[${d2.arrayIndex}]` : ""};`);
    });
  }
  const inputPrefixSnippet = prefixSnippets.join("\n");
  const inputSamplingSnippet = inputsInfo.map((x2) => getInputSamplingSnippet(x2, outputShape, program.packedInputs, program.enableShapeUniforms)).join("\n");
  const outTexShape = outputShape.texShape;
  const glsl = getGlslDifferences();
  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
  let outputSamplingSnippet;
  let floatTextureSetOutputSnippet;
  let shaderPrefix = getShaderPrefix(glsl);
  if (outputShape.isPacked) {
    outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
  } else {
    outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
  }
  if (program.packedInputs) {
    shaderPrefix += SHADER_PACKED_PREFIX;
  }
  const source = [
    shaderPrefix,
    floatTextureSampleSnippet,
    floatTextureSetOutputSnippet,
    inputPrefixSnippet,
    outputSamplingSnippet,
    inputSamplingSnippet,
    program.userCode
  ].join("\n");
  return source;
}
function getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
  const shape = inInfo.shapeInfo.logicalShape;
  switch (shape.length) {
    case 0:
      return getSamplerScalar(inInfo, enableShapeUniforms);
    case 1:
      return getSampler1D(inInfo, enableShapeUniforms);
    case 2:
      return getSampler2D(inInfo, enableShapeUniforms);
    case 3:
      return getSampler3D(inInfo, enableShapeUniforms);
    case 4:
      return getSampler4D(inInfo, enableShapeUniforms);
    case 5:
      return getSampler5D(inInfo);
    case 6:
      return getSampler6D(inInfo);
    default:
      throw new Error(`${shape.length}-D input sampling is not yet supported`);
  }
}
function getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
  const shape = inInfo.shapeInfo.logicalShape;
  switch (shape.length) {
    case 0:
      return getPackedSamplerScalar(inInfo);
    case 1:
      return getPackedSampler1D(inInfo, enableShapeUniforms);
    case 2:
      return getPackedSampler2D(inInfo, enableShapeUniforms);
    case 3:
      return getPackedSampler3D(inInfo, enableShapeUniforms);
    default:
      return getPackedSamplerND(inInfo, enableShapeUniforms);
  }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
  let res2 = "";
  if (usesPackedTextures) {
    res2 += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
  } else {
    res2 += getSamplerFromInInfo(inInfo, enableShapeUniforms);
  }
  const inShape = inInfo.shapeInfo.logicalShape;
  const outShape = outShapeInfo.logicalShape;
  if (inShape.length <= outShape.length) {
    if (usesPackedTextures) {
      res2 += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
    } else {
      res2 += getSamplerAtOutputCoords(inInfo, outShapeInfo);
    }
  }
  return res2;
}
function getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
  switch (outShape.length) {
    case 0:
      return getOutputScalarCoords();
    case 1:
      return getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
    case 2:
      return getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
    case 3:
      return getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
    default:
      return getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
  }
}
function getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
  switch (outShape.length) {
    case 0:
      return getOutputScalarCoords();
    case 1:
      return getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
    case 2:
      return getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
    case 3:
      return getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
    case 4:
      return getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
    case 5:
      return getOutput5DCoords(outShape, outTexShape);
    case 6:
      return getOutput6DCoords(outShape, outTexShape);
    default:
      throw new Error(`${outShape.length}-D output sampling is not yet supported`);
  }
}
function getFloatTextureSampleSnippet(glsl) {
  return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
}
function getFloatTextureSetRSnippet(glsl) {
  return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function getFloatTextureSetRGBASnippet(glsl) {
  return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
}
function getShaderPrefix(glsl) {
  const SHADER_PREFIX2 = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
  return SHADER_PREFIX2;
}
var SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function getOutputScalarCoords() {
  return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (packedTexShape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
  }
  if (packedTexShape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
  }
  return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
}
function getOutput1DCoords(shape, texShape, enableShapeUniforms) {
  if (texShape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
  }
  if (texShape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
  }
  return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
}
function getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texelsInLogicalRow = Math.ceil(shape[2] / 2);
  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function getOutput3DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], shape);
    return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet2}
    return ivec3(r, c, d);
  }
`;
  }
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
function getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
  let texelsInBatchN = texelsInBatch;
  let batches = ``;
  let coords32 = "b, r, c";
  for (let b2 = 2; b2 < shape.length - 1; b2++) {
    texelsInBatchN *= shape[shape.length - b2 - 1];
    batches = `
      int b${b2} = index / ${texelsInBatchN};
      index -= b${b2} * ${texelsInBatchN};
    ` + batches;
    coords32 = `b${b2}, ` + coords32;
  }
  return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords32});
    }
  `;
}
function getOutput4DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d", "d2"], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet2}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
  return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
}
function getOutput5DCoords(shape, texShape) {
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
  return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function getOutput6DCoords(shape, texShape) {
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
  return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (util_exports.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
  }
  const texelsInLogicalRow = Math.ceil(shape[1] / 2);
  if (enableShapeUniforms) {
    return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
  }
  return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
}
function getOutput2DCoords(shape, texShape, enableShapeUniforms) {
  if (util_exports.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
  }
  if (shape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
  }
  if (shape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
  }
  return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
}
function getFlatOffsetUniformName(texName) {
  return `offset${texName}`;
}
function getPackedSamplerScalar(inputInfo) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const glsl = getGlslDifferences();
  return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
}
function getSamplerScalar(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  if (inputInfo.shapeInfo.isUniform) {
    return `float ${funcName}() {return ${texName};}`;
  }
  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
  if (texNumR === 1 && texNumC === 1) {
    return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
  return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler1D(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler1D(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texShape = inputInfo.shapeInfo.texShape;
  const tNumR = texShape[0];
  const tNumC = texShape[1];
  if (tNumC === 1 && tNumR === 1) {
    return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (tNumC === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (tNumR === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler2D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const glsl = getGlslDifferences();
  if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const valuesPerRow = Math.ceil(shape[1] / 2);
  return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler2D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const texNumR2 = texShape[0];
    const texNumC2 = texShape[1];
    return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  const squeezedShape = newShape;
  if (squeezedShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["row", "col"];
    return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const offset = getFlatOffsetUniformName(texName);
  if (texNumC === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  if (texNumR === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  if (enableShapeUniforms) {
    return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
}
function getPackedSampler3D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (shape[0] === 1) {
    const squeezedShape = shape.slice(1);
    const keptDims = [1, 2];
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["b", "row", "col"];
    return `
        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
  }
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const texNumR = packedTexShape[0];
  const texNumC = packedTexShape[1];
  const valuesPerRow = Math.ceil(shape[2] / 2);
  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
  return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler3D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride0 = shape[1] * shape[2];
  const stride1 = shape[2];
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  const squeezedShape = newShape;
  if (squeezedShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["row", "col", "depth"];
    return `
        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  if (texNumC === stride0 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
  }
  if (texNumC === stride1 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
  }
  return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
}
function getPackedSamplerND(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const shape = inputInfo.shapeInfo.logicalShape;
  const rank = shape.length;
  const texShape = inputInfo.shapeInfo.texShape;
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texNumR = packedTexShape[0];
  const texNumC = packedTexShape[1];
  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
  let params = `int b, int row, int col`;
  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
  for (let b2 = 2; b2 < rank - 1; b2++) {
    params = `int b${b2}, ` + params;
    texelsInBatch *= shape[rank - b2 - 1];
    index = `b${b2} * ${texelsInBatch} + ` + index;
  }
  return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler4D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride2 = shape[3];
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2"];
    return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const stride2Str = `int stride2 = ${texName}Shape[3];`;
  const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
  const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
  if (texNumC === stride0 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride2 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler5D(inputInfo) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride3 = shape[4];
  const stride2 = shape[3] * stride3;
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2", "depth3"];
    return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  if (texNumC === stride0 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride3 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler6D(inputInfo) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  const stride4 = shape[5];
  const stride3 = shape[4] * stride4;
  const stride2 = shape[3] * stride3;
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  if (texNumC === stride0 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride4 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getUniformSampler(inputInfo) {
  const texName = inputInfo.name;
  const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
  if (inSize < 2) {
    return `return ${texName};`;
  }
  return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
}
function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
  const texName = inputInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "AtOutCoords";
  const inRank = inputInfo.shapeInfo.logicalShape.length;
  const outRank = outShapeInfo.logicalShape.length;
  const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
  const type = getCoordsDataType(outRank);
  const rankDiff = outRank - inRank;
  let coordsSnippet;
  const fields = ["x", "y", "z", "w", "u", "v"];
  if (inRank === 0) {
    coordsSnippet = "";
  } else if (outRank < 2 && broadcastDims.length >= 1) {
    coordsSnippet = "coords = 0;";
  } else {
    coordsSnippet = broadcastDims.map((d2) => `coords.${fields[d2 + rankDiff]} = 0;`).join("\n");
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s2, i2) => `coords.${fields[i2 + rankDiff]}`).join(", ");
  }
  let output = `return outputValue;`;
  const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
  const isInputScalar = inSize === 1;
  const outSize = util_exports.sizeFromShape(outShapeInfo.logicalShape);
  const isOutputScalar = outSize === 1;
  if (inRank === 1 && !isInputScalar && !isOutputScalar) {
    output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
  } else if (isInputScalar && !isOutputScalar) {
    if (outRank === 1) {
      output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
    } else {
      output = `
        return vec4(outputValue.x);
      `;
    }
  } else if (broadcastDims.length) {
    const rows = inRank - 2;
    const cols = inRank - 1;
    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
      output = `return vec4(outputValue.x);`;
    } else if (broadcastDims.indexOf(rows) > -1) {
      output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
    } else if (broadcastDims.indexOf(cols) > -1) {
      output = `return vec4(outputValue.xx, outputValue.zz);`;
    }
  }
  return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
  const texName = inputInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "AtOutCoords";
  const outTexShape = outShapeInfo.texShape;
  const inTexShape = inputInfo.shapeInfo.texShape;
  const inRank = inputInfo.shapeInfo.logicalShape.length;
  const outRank = outShapeInfo.logicalShape.length;
  if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && util_exports.arraysEqual(inTexShape, outTexShape)) {
    return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
  }
  const type = getCoordsDataType(outRank);
  const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
  const rankDiff = outRank - inRank;
  let coordsSnippet;
  const fields = ["x", "y", "z", "w", "u", "v"];
  if (inRank === 0) {
    coordsSnippet = "";
  } else if (outRank < 2 && broadcastDims.length >= 1) {
    coordsSnippet = "coords = 0;";
  } else {
    coordsSnippet = broadcastDims.map((d2) => `coords.${fields[d2 + rankDiff]} = 0;`).join("\n");
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s2, i2) => `coords.${fields[i2 + rankDiff]}`).join(", ");
  }
  return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
}
function getCoordsDataType(rank) {
  if (rank <= 1) {
    return "int";
  } else if (rank === 2) {
    return "ivec2";
  } else if (rank === 3) {
    return "ivec3";
  } else if (rank === 4) {
    return "ivec4";
  } else if (rank === 5) {
    return "ivec5";
  } else if (rank === 6) {
    return "ivec6";
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function getUniformInfoFromShape(isPacked, shape, texShape) {
  const { newShape, keptDims } = util_exports.squeezeShape(shape);
  const rank = shape.length;
  const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
  const squeezeShape2 = useSqueezePackedShape ? shape.slice(1) : newShape;
  const useSqueezeShape = !isPacked && rank > 1 && !util_exports.arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
  const uniformShape = useSqueezeShape ? squeezeShape2 : shape;
  return { useSqueezeShape, uniformShape, keptDims };
}
function squeezeInputInfo(inInfo, squeezedShape) {
  const newInputInfo = JSON.parse(JSON.stringify(inInfo));
  newInputInfo.shapeInfo.logicalShape = squeezedShape;
  return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
  return keptDims.map((d2) => params[d2]).join(", ");
}
function compileProgram(gpgpu, program, inputs, output) {
  const inputInfos = inputs.map((input2, i2) => {
    const shapeInfo = {
      logicalShape: input2.shape,
      texShape: input2.isUniform ? null : input2.texData.texShape,
      isUniform: input2.isUniform,
      isPacked: input2.isUniform ? false : input2.texData.isPacked,
      flatOffset: null
    };
    if (input2.texData != null && input2.texData.slice != null && input2.texData.slice.flatOffset > 0) {
      shapeInfo.flatOffset = input2.texData.slice.flatOffset;
    }
    return { name: program.variableNames[i2], shapeInfo };
  });
  const inShapeInfos = inputInfos.map((x2) => x2.shapeInfo);
  const outShapeInfo = {
    logicalShape: output.shape,
    texShape: output.texData.texShape,
    isUniform: false,
    isPacked: output.texData.isPacked,
    flatOffset: null
  };
  const source = makeShader(inputInfos, outShapeInfo, program);
  const webGLProgram = gpgpu.createProgram(source);
  let infLoc = null;
  const nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
  if (env().getNumber("WEBGL_VERSION") === 1) {
    infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
  }
  const shouldThrow = false;
  const uniformLocations = {};
  const inShapesLocations = {};
  const inTexShapesLocations = {};
  for (let i2 = 0; i2 < program.variableNames.length; i2++) {
    const varName = program.variableNames[i2];
    uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
    uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
    if (program.enableShapeUniforms) {
      inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
      inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
    }
  }
  let outShapeLocation;
  let outTexShapeLocation;
  let outShapeStridesLocation;
  if (program.enableShapeUniforms) {
    outShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outShape", shouldThrow);
    outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, "outShapeStrides", shouldThrow);
    outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outTexShape", shouldThrow);
  }
  const customUniformLocations = [];
  if (program.customUniforms) {
    program.customUniforms.forEach((d2, i2) => {
      customUniformLocations[i2] = gpgpu.getUniformLocation(webGLProgram, d2.name, shouldThrow);
    });
  }
  return {
    program,
    source,
    webGLProgram,
    uniformLocations,
    customUniformLocations,
    inShapeInfos,
    outShapeInfo,
    infLoc,
    nanLoc,
    inShapesLocations,
    inTexShapesLocations,
    outShapeLocation,
    outShapeStridesLocation,
    outTexShapeLocation
  };
}
function validateBinaryAndProgram(shapeInfos, inputs) {
  if (shapeInfos.length !== inputs.length) {
    throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
  }
  shapeInfos.forEach((s2, i2) => {
    const shapeA = s2.logicalShape;
    const input2 = inputs[i2];
    const shapeB = input2.shape;
    if (!util_exports.arraysEqual(shapeA, shapeB)) {
      throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
    }
    if (s2.isUniform && input2.isUniform) {
      return;
    }
    const texShapeA = s2.texShape;
    const texShapeB = input2.isUniform ? null : input2.texData.texShape;
    if (!util_exports.arraysEqual(texShapeA, texShapeB)) {
      throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
    }
  });
}
function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
  if (!binary.program.enableShapeUniforms) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
  }
  const outTex = output.texData.texture;
  const outTexShape = output.texData.texShape;
  if (output.texData.isPacked) {
    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
  } else {
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
  }
  gpgpu.setProgram(binary.webGLProgram);
  if (env().getNumber("WEBGL_VERSION") === 1) {
    if (binary.infLoc !== null) {
      gpgpu.gl.uniform1f(binary.infLoc, Infinity);
    }
  }
  if (binary.nanLoc !== null) {
    gpgpu.gl.uniform1f(binary.nanLoc, NaN);
  }
  inputs.forEach((input2, i2) => {
    const varName = binary.program.variableNames[i2];
    const varLoc = binary.uniformLocations[varName];
    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
    const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];
    const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];
    if (varShapeLoc) {
      const { uniformShape } = getUniformInfoFromShape(binary.program.packedInputs, input2.shape, input2.texData.texShape);
      switch (uniformShape.length) {
        case 1:
          gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 2:
          gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 3:
          gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 4:
          gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        default:
          break;
      }
    }
    if (varTexShapeLoc) {
      gpgpu.gl.uniform2i(varTexShapeLoc, input2.texData.texShape[0], input2.texData.texShape[1]);
    }
    if (varLoc == null) {
      return;
    }
    if (input2.isUniform) {
      if (util_exports.sizeFromShape(input2.shape) < 2) {
        gpgpu.gl.uniform1f(varLoc, input2.uniformValues[0]);
      } else {
        let vals = input2.uniformValues;
        if (!(vals instanceof Float32Array)) {
          vals = new Float32Array(vals);
        }
        gpgpu.gl.uniform1fv(varLoc, vals);
      }
      return;
    }
    if (input2.texData.slice != null && varOffsetLoc != null) {
      gpgpu.gl.uniform1i(varOffsetLoc, input2.texData.slice.flatOffset);
    }
    gpgpu.setInputMatrixTexture(input2.texData.texture, varLoc, i2);
  });
  const outShapeLoc = binary.outShapeLocation;
  if (outShapeLoc) {
    switch (output.shape.length) {
      case 1:
        gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 2:
        gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 3:
        gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 4:
        gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
        break;
      default:
        break;
    }
  }
  if (binary.outShapeStridesLocation) {
    const strides = util_exports.computeStrides(output.shape);
    switch (output.shape.length) {
      case 2:
        gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      case 3:
        gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      case 4:
        gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      default:
        break;
    }
  }
  if (binary.outTexShapeLocation) {
    gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
  }
  if (binary.program.customUniforms && customUniformValues) {
    binary.program.customUniforms.forEach((d2, i2) => {
      const customLoc = binary.customUniformLocations[i2];
      const customValue = customUniformValues[i2];
      if (d2.type === "float") {
        gpgpu.gl.uniform1fv(customLoc, customValue);
      } else if (d2.type === "vec2") {
        gpgpu.gl.uniform2fv(customLoc, customValue);
      } else if (d2.type === "vec3") {
        gpgpu.gl.uniform3fv(customLoc, customValue);
      } else if (d2.type === "vec4") {
        gpgpu.gl.uniform4fv(customLoc, customValue);
      } else if (d2.type === "int") {
        gpgpu.gl.uniform1iv(customLoc, customValue);
      } else if (d2.type === "ivec2") {
        gpgpu.gl.uniform2iv(customLoc, customValue);
      } else if (d2.type === "ivec3") {
        gpgpu.gl.uniform3iv(customLoc, customValue);
      } else if (d2.type === "ivec4") {
        gpgpu.gl.uniform4iv(customLoc, customValue);
      } else {
        throw Error(`uniform type ${d2.type} is not supported yet.`);
      }
    });
  }
  gpgpu.executeProgram();
}
function makeShaderKey(program, inputs, output) {
  let keyInputs = "";
  inputs.concat(output).forEach((x2) => {
    const hasOffset = x2.texData != null && x2.texData.slice != null && x2.texData.slice.flatOffset > 0;
    if (program.enableShapeUniforms && !x2.isUniform) {
      const xTexShape = x2.texData.texShape;
      const { useSqueezeShape, uniformShape, keptDims } = getUniformInfoFromShape(program.packedInputs, x2.shape, xTexShape);
      let rank1 = "", rank2 = "", rank34 = "";
      if (uniformShape.length === 1 && program.packedInputs) {
        const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
        rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
      } else if (uniformShape.length === 2 && !program.packedInputs) {
        rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
      } else if (uniformShape.length > 2 && !program.packedInputs) {
        const strides = util_exports.computeStrides(uniformShape);
        rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
      }
      const xRank = x2.shape.length;
      const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util_exports.arraysEqual(x2.shape, xTexShape);
      const isScalar = util_exports.sizeFromShape(x2.shape) === 1;
      const broadcastDims = backend_util_exports.getBroadcastDims(x2.shape, output.shape);
      const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && util_exports.arraysEqual(xTexShape, output.texData.texShape);
      const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? "" : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
      keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ""}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
    } else {
      const texShape = x2.isUniform ? "uniform" : x2.texData.texShape;
      keyInputs += `${x2.shape}_${texShape}_${hasOffset}`;
    }
  });
  const keyUserCode = program.userCode;
  let key = program.constructor.name;
  key += "_" + keyInputs + "_" + keyUserCode + `${env().getNumber("WEBGL_VERSION")}`;
  return key;
}
function useShapeUniforms(rank) {
  return env().getBool("WEBGL_USE_SHAPES_UNIFORMS") && rank <= 4;
}
var DecodeMatrixProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.outPackingScheme = PackingScheme.DENSE;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
  }
};
var DecodeMatrixPackedProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outPackingScheme = PackingScheme.DENSE;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
  }
};
var EncodeFloatProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.outTexUsage = TextureUsage.DOWNLOAD;
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
  }
};
var EncodeFloatPackedProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outTexUsage = TextureUsage.DOWNLOAD;
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
  }
};
var EncodeMatrixProgram = class {
  constructor(outputShape, inputIsUnsignedByte = false) {
    this.variableNames = ["A"];
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let output = `result`;
    if (inputIsUnsignedByte) {
      output = `floor(result * 255. + 0.5)`;
    }
    this.userCode = `
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
  }
};
var EncodeMatrixPackedProgram = class {
  constructor(outputShape, inputIsUnsignedByte = false) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let mainLoop = "";
    let output = "result";
    if (inputIsUnsignedByte) {
      output = "floor(result * 255. + 0.5)";
    }
    for (let row = 0; row <= 1; row++) {
      for (let col = 0; col <= 1; col++) {
        const channel = row * 2 + col;
        mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? "outShape[2]" : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? "outShape[1]" : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
      }
    }
    this.userCode = `
        ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
  }
};
var gpgpu_util_exports = {};
__export2(gpgpu_util_exports, {
  bindVertexProgramAttributeStreams: () => bindVertexProgramAttributeStreams,
  createBufferFromOutputTexture: () => createBufferFromOutputTexture,
  createFloat16MatrixTexture: () => createFloat16MatrixTexture,
  createFloat16PackedMatrixTexture: () => createFloat16PackedMatrixTexture,
  createFloat32MatrixTexture: () => createFloat32MatrixTexture,
  createIndexBuffer: () => createIndexBuffer,
  createPackedMatrixTexture: () => createPackedMatrixTexture,
  createUnsignedBytesMatrixTexture: () => createUnsignedBytesMatrixTexture,
  createVertexBuffer: () => createVertexBuffer,
  createVertexShader: () => createVertexShader2,
  downloadByteEncodedFloatMatrixFromOutputTexture: () => downloadByteEncodedFloatMatrixFromOutputTexture,
  downloadFloat32MatrixFromBuffer: () => downloadFloat32MatrixFromBuffer,
  downloadMatrixFromPackedOutputTexture: () => downloadMatrixFromPackedOutputTexture,
  downloadPackedMatrixFromBuffer: () => downloadPackedMatrixFromBuffer,
  getInternalFormatForFloat16MatrixTexture: () => getInternalFormatForFloat16MatrixTexture,
  getInternalFormatForFloat16PackedMatrixTexture: () => getInternalFormatForFloat16PackedMatrixTexture,
  getInternalFormatForFloat32MatrixTexture: () => getInternalFormatForFloat32MatrixTexture,
  getInternalFormatForPackedMatrixTexture: () => getInternalFormatForPackedMatrixTexture,
  getInternalFormatForUnsignedBytesMatrixTexture: () => getInternalFormatForUnsignedBytesMatrixTexture,
  uploadDenseMatrixToTexture: () => uploadDenseMatrixToTexture,
  uploadPixelDataToTexture: () => uploadPixelDataToTexture
});
function createVertexShader2(gl) {
  const glsl = getGlslDifferences();
  const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
  return createVertexShader(gl, vertexShaderSource);
}
function createVertexBuffer(gl) {
  const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return createStaticVertexBuffer(gl, vertexArray);
}
function createIndexBuffer(gl) {
  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return createStaticIndexBuffer(gl, triangleVertexIndices);
}
function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
  validateTextureSize(width, height);
  const texture = createTexture(gl);
  const tex2d = gl.TEXTURE_2D;
  callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
  callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  return texture;
}
function getInternalFormatForFloat32MatrixTexture(textureConfig) {
  return textureConfig.internalFormatFloat;
}
function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
}
function getInternalFormatForFloat16MatrixTexture(textureConfig) {
  return textureConfig.internalFormatHalfFloat;
}
function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
}
function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
  return textureConfig.downloadTextureFormat;
}
function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
}
function getInternalFormatForPackedMatrixTexture(textureConfig) {
  return textureConfig.internalFormatPackedFloat;
}
function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
}
function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
  return textureConfig.internalFormatPackedHalfFloat;
}
function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
}
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
  const posOffset = 0;
  const uvOffset = 3 * 4;
  const stride = 3 * 4 + 2 * 4;
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
  const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
  return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
}
function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  let dataForUpload, texelDataType, internalFormat;
  if (data instanceof Uint8Array) {
    dataForUpload = new Uint8Array(width * height * 4);
    texelDataType = gl.UNSIGNED_BYTE;
    internalFormat = gl.RGBA;
  } else {
    dataForUpload = new Float32Array(width * height * 4);
    texelDataType = gl.FLOAT;
    internalFormat = textureConfig.internalFormatPackedFloat;
  }
  dataForUpload.set(data);
  callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function uploadPixelDataToTexture(gl, texture, pixels) {
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  if (pixels.data instanceof Uint8Array) {
    callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
  } else {
    callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
  }
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
  const buffer2 = gl2.createBuffer();
  callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2));
  const bytesPerFloat = 4;
  const valuesPerTexel = 4;
  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
  callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
  callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
  callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
  return buffer2;
}
function downloadFloat32MatrixFromBuffer(gl, buffer2, size2) {
  const gl2 = gl;
  const downloadTarget = new Float32Array(size2);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
  return downloadTarget;
}
function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
  const [w2, h2] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  const numChannels = 4;
  const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
  callAndCheck(gl, () => gl.readPixels(0, 0, w2, h2, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
  return new Float32Array(downloadTarget.buffer);
}
function downloadPackedMatrixFromBuffer(gl, buffer2, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
  const gl2 = gl;
  const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
  return downloadTarget;
}
function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
  callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
  return packedRGBA;
}
var GPGPUContext = class {
  constructor(gl) {
    this.outputTexture = null;
    this.program = null;
    this.disposed = false;
    this.vertexAttrsAreBound = false;
    this.itemsToPoll = [];
    const glVersion = env().getNumber("WEBGL_VERSION");
    if (gl != null) {
      this.gl = gl;
      setWebGLContext(glVersion, gl);
    } else {
      this.gl = getWebGLContext(glVersion);
    }
    let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
    const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
    if (env().getNumber("WEBGL_VERSION") === 1) {
      const TEXTURE_FLOAT = "OES_texture_float";
      const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
      this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
      if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
        this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
      } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
        throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
      if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
        this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
      } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
        throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
    } else {
      COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
      if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
      } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
      } else {
        throw new Error("GL context does not support color renderable floats");
      }
    }
    this.vertexBuffer = createVertexBuffer(this.gl);
    this.indexBuffer = createIndexBuffer(this.gl);
    this.framebuffer = createFramebuffer(this.gl);
    this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return env().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (this.program != null) {
      console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
    }
    if (this.outputTexture != null) {
      console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    }
    const gl = this.gl;
    callAndCheck(gl, () => gl.finish());
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
    callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
    this.disposed = true;
  }
  createFloat32MatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createFloat16MatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  uploadPixelDataToTexture(texture, pixels) {
    this.throwIfDisposed();
    uploadPixelDataToTexture(this.gl, texture, pixels);
  }
  uploadDenseMatrixToTexture(texture, width, height, data) {
    this.throwIfDisposed();
    uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createPackedMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  deleteMatrixTexture(texture) {
    this.throwIfDisposed();
    if (this.outputTexture === texture) {
      unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
      this.outputTexture = null;
    }
    callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
    return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(buffer2, batch, rows, columns, physicalRows, physicalCols) {
    return downloadPackedMatrixFromBuffer(this.gl, buffer2, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
  }
  downloadFloat32MatrixFromBuffer(buffer2, size2) {
    return downloadFloat32MatrixFromBuffer(this.gl, buffer2, size2);
  }
  createBufferFromTexture(texture, rows, columns) {
    this.bindTextureToFrameBuffer(texture);
    const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
    this.unbindTextureToFrameBuffer();
    return result;
  }
  createAndWaitForFence() {
    const fenceContext = this.createFence(this.gl);
    return this.pollFence(fenceContext);
  }
  createFence(gl) {
    let query;
    let isFencePassed;
    if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
      const gl2 = gl;
      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
      gl.flush();
      isFencePassed = () => {
        const status = gl2.clientWaitSync(sync, 0, 0);
        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
      };
      query = sync;
    } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
      query = this.beginQuery();
      this.endQuery();
      isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    } else {
      isFencePassed = () => true;
    }
    return { query, isFencePassed };
  }
  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
    return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
  }
  createProgram(fragmentShaderSource) {
    this.throwIfDisposed();
    const gl = this.gl;
    const fragmentShader = createFragmentShader(gl, fragmentShaderSource);
    if (this.vertexShader == null) {
      this.vertexShader = createVertexShader2(gl);
    }
    const program = createProgram(gl);
    callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));
    callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
    linkProgram(gl, program);
    if (this.debug) {
      validateProgram(gl, program);
    }
    if (!this.vertexAttrsAreBound) {
      this.setProgram(program);
      this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
    }
    return program;
  }
  deleteProgram(program) {
    this.throwIfDisposed();
    if (program === this.program) {
      this.program = null;
    }
    if (program != null) {
      callAndCheck(this.gl, () => this.gl.deleteProgram(program));
    }
  }
  setProgram(program) {
    this.throwIfDisposed();
    this.program = program;
    if (this.program != null && this.debug) {
      validateProgram(this.gl, this.program);
    }
    callAndCheck(this.gl, () => this.gl.useProgram(program));
  }
  getUniformLocation(program, uniformName, shouldThrow = true) {
    this.throwIfDisposed();
    if (shouldThrow) {
      return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
    } else {
      return getProgramUniformLocation(this.gl, program, uniformName);
    }
  }
  getAttributeLocation(program, attribute) {
    this.throwIfDisposed();
    return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
  }
  getUniformLocationNoThrow(program, uniformName) {
    this.throwIfDisposed();
    return this.gl.getUniformLocation(program, uniformName);
  }
  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
    this.throwIfDisposed();
    this.throwIfNoProgram();
    bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
  }
  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
  }
  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
    this.throwIfDisposed();
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
  }
  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
  }
  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    if (this.program != null) {
      validateProgram(this.gl, this.program);
    }
    validateFramebuffer(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed();
    this.throwIfNoProgram();
    const gl = this.gl;
    if (this.debug) {
      this.debugValidate();
    }
    callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed();
    callAndCheck(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    if (this.disjointQueryTimerExtension == null) {
      this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
    }
    return this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const gl2 = this.gl;
      const ext2 = this.getQueryTimerExtensionWebGL2();
      const query2 = gl2.createQuery();
      gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
      return query2;
    }
    const ext = this.getQueryTimerExtensionWebGL1();
    const query = ext.createQueryEXT();
    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
    return query;
  }
  endQuery() {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const gl2 = this.gl;
      const ext2 = this.getQueryTimerExtensionWebGL2();
      gl2.endQuery(ext2.TIME_ELAPSED_EXT);
      return;
    }
    const ext = this.getQueryTimerExtensionWebGL1();
    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
  }
  async waitForQueryAndGetTime(query) {
    await util_exports.repeatedTry(() => this.disposed || this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
    return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  getQueryTime(query, queryTimerVersion) {
    if (queryTimerVersion === 0) {
      return null;
    }
    if (queryTimerVersion === 2) {
      const gl2 = this.gl;
      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
      return timeElapsedNanos / 1e6;
    } else {
      const ext = this.getQueryTimerExtensionWebGL1();
      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
      return timeElapsedNanos / 1e6;
    }
  }
  isQueryAvailable(query, queryTimerVersion) {
    if (queryTimerVersion === 0) {
      return true;
    }
    if (queryTimerVersion === 2) {
      const gl2 = this.gl;
      const ext = this.getQueryTimerExtensionWebGL2();
      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
      if (this.disjoint == null) {
        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
      }
      return available && !this.disjoint;
    } else {
      const ext = this.getQueryTimerExtensionWebGL1();
      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
      if (this.disjoint == null) {
        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
      }
      return available && !this.disjoint;
    }
  }
  pollFence(fenceContext) {
    return new Promise((resolve) => {
      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
    });
  }
  pollItems() {
    const index = linearSearchLastTrue(this.itemsToPoll.map((x2) => x2.isDoneFn));
    for (let i2 = 0; i2 <= index; ++i2) {
      const { resolveFn } = this.itemsToPoll[i2];
      resolveFn();
    }
    this.itemsToPoll = this.itemsToPoll.slice(index + 1);
  }
  addItemToPoll(isDoneFn, resolveFn) {
    this.itemsToPoll.push({ isDoneFn, resolveFn });
    if (this.itemsToPoll.length > 1) {
      return;
    }
    util_exports.repeatedTry(() => {
      this.pollItems();
      return this.itemsToPoll.length === 0;
    });
  }
  bindTextureToFrameBuffer(texture) {
    this.throwIfDisposed();
    bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
    if (this.debug) {
      validateFramebuffer(this.gl);
    }
  }
  unbindTextureToFrameBuffer() {
    if (this.outputTexture != null) {
      bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(this.gl);
      }
    } else {
      unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
    }
  }
  downloadMatrixDriver(texture, downloadAndDecode) {
    this.bindTextureToFrameBuffer(texture);
    const result = downloadAndDecode();
    this.unbindTextureToFrameBuffer();
    return result;
  }
  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
    this.throwIfDisposed();
    const gl = this.gl;
    bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
    if (this.debug) {
      validateFramebuffer(gl);
    }
    this.outputTexture = outputMatrixTextureMaybePacked;
    callAndCheck(gl, () => gl.viewport(0, 0, width, height));
    callAndCheck(gl, () => gl.scissor(0, 0, width, height));
  }
  setOutputMatrixWriteRegionDriver(x2, y2, width, height) {
    this.throwIfDisposed();
    callAndCheck(this.gl, () => this.gl.scissor(x2, y2, width, height));
  }
  throwIfDisposed() {
    if (this.disposed) {
      throw new Error("Attempted to use disposed GPGPUContext.");
    }
  }
  throwIfNoProgram() {
    if (this.program == null) {
      throw new Error("No GPU program is currently set.");
    }
  }
};
function linearSearchLastTrue(arr) {
  let i2 = 0;
  for (; i2 < arr.length; ++i2) {
    const isDone = arr[i2]();
    if (!isDone) {
      break;
    }
  }
  return i2 - 1;
}
var { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, sigmoidImpl: sigmoidImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, sqrtImpl: sqrtImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = shared_exports;
function getVecChannels(name, rank) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d2) => `${name}.${d2}`);
}
function getChannels(name, rank) {
  if (rank === 1) {
    return [name];
  }
  return getVecChannels(name, rank);
}
function getSourceCoords(rank, dims) {
  if (rank === 1) {
    return "rc";
  }
  let coords32 = "";
  for (let i2 = 0; i2 < rank; i2++) {
    coords32 += dims[i2];
    if (i2 < rank - 1) {
      coords32 += ",";
    }
  }
  return coords32;
}
var PackProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.outputShape = outputShape;
    const rank = outputShape.length;
    if (rank === 0) {
      this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
    } else {
      const channels = getChannels("rc", rank);
      const dtype = getCoordsDataType(rank);
      const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);
      const setup46 = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);
      const output = getOutput(outputShape, channels);
      this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup46}

            setOutput(vec4(${output}));
          }
        }
      `;
    }
  }
};
function getSourceCoordsArr(rank, dims) {
  const coords32 = [];
  for (let row = 0; row <= 1; row++) {
    for (let col = 0; col <= 1; col++) {
      let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
      for (let d2 = 2; d2 < rank; d2++) {
        coord = `${dims[dims.length - 1 - d2]},` + coord;
      }
      coords32.push(coord);
    }
  }
  return coords32;
}
function getOutOfBoundsCondition(rank, shape, dims) {
  if (rank === 1) {
    return `rc > ${shape[0]}`;
  }
  let cond = "";
  for (let i2 = rank - 2; i2 < rank; i2++) {
    cond += `${dims[i2]} >= ${shape[i2]}`;
    if (i2 < rank - 1) {
      cond += "||";
    }
  }
  return cond;
}
function getSetup(rank, cols, rows, dims) {
  if (rank === 1) {
    return "";
  }
  const innerDims = dims.slice(-2);
  return `
    int r = ${innerDims[0]};
    int c = ${innerDims[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${cols};
    bool rEdge = rp1 >= ${rows};
  `;
}
function getOutput(shape, dims) {
  const rank = shape.length;
  const sourceCoords = getSourceCoordsArr(rank, dims);
  if (rank === 1) {
    return `getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`;
  }
  return `getA(${sourceCoords[0]}),
          cEdge ? 0. : getA(${sourceCoords[1]}),
          rEdge ? 0. : getA(${sourceCoords[2]}),
          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
}
var ReshapePackedProgram = class {
  constructor(outputShape, inputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{ name: "inputShape", type: "ivec3" }];
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let mainLoop = ``;
    for (let i2 = 0; i2 < 4; i2++) {
      let thisRC = `thisRC = rc;`;
      if (i2 % 2 === 1) {
        thisRC += `thisRC.z += 1;`;
      }
      if (i2 > 1) {
        thisRC += `thisRC.y += 1;`;
      }
      mainLoop += `
        ${thisRC}
        ${i2 > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i2}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i2 > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
  }
};
function getReshapedInputCoords(shape, enableShapeUniforms) {
  const coordsFromIndexSnippet = enableShapeUniforms ? getLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], "inputShape") : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
var TextureManager = class {
  constructor(gpgpu) {
    this.gpgpu = gpgpu;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this._numBytesAllocated = 0;
    this._numBytesFree = 0;
    this.freeTextures = {};
    this.logEnabled = false;
    this.usedTextures = {};
  }
  acquireTexture(shapeRC, usage, isPacked) {
    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
    if (!(shapeKey in this.freeTextures)) {
      this.freeTextures[shapeKey] = [];
    }
    if (!(shapeKey in this.usedTextures)) {
      this.usedTextures[shapeKey] = [];
    }
    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
    if (this.freeTextures[shapeKey].length > 0) {
      this.numFreeTextures--;
      this.numUsedTextures++;
      this._numBytesFree -= texBytes;
      this.log();
      const newTexture2 = this.freeTextures[shapeKey].shift();
      this.usedTextures[shapeKey].push(newTexture2);
      return newTexture2;
    }
    let newTexture;
    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
    }
    this.usedTextures[shapeKey].push(newTexture);
    this.numUsedTextures++;
    this._numBytesAllocated += texBytes;
    this.log();
    return newTexture;
  }
  releaseTexture(texture, shape, logicalTexType, isPacked) {
    if (this.freeTextures == null) {
      return;
    }
    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
    if (!(shapeKey in this.freeTextures)) {
      this.freeTextures[shapeKey] = [];
    }
    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
    const deleteTexThreshold = env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
      this.gpgpu.deleteMatrixTexture(texture);
      this._numBytesAllocated -= texBytes;
    } else {
      this.freeTextures[shapeKey].push(texture);
      this.numFreeTextures++;
      this._numBytesFree += texBytes;
    }
    this.numUsedTextures--;
    const texList = this.usedTextures[shapeKey];
    const texIndex = texList.indexOf(texture);
    if (texIndex < 0) {
      throw new Error("Cannot release a texture that was never provided by this texture manager");
    }
    texList.splice(texIndex, 1);
    this.log();
  }
  log() {
    if (!this.logEnabled) {
      return;
    }
    const total = this.numFreeTextures + this.numUsedTextures;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
    const freeRatio = this._numBytesFree / this._numBytesAllocated;
    console.log(`Bytes allocated: ${this._numBytesAllocated}`);
    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
  }
  get numBytesAllocated() {
    return this._numBytesAllocated;
  }
  get numBytesFree() {
    return this._numBytesFree;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (this.freeTextures == null) {
      return;
    }
    for (const texShape in this.freeTextures) {
      this.freeTextures[texShape].forEach((tex) => {
        this.gpgpu.deleteMatrixTexture(tex);
      });
    }
    for (const texShape in this.usedTextures) {
      this.usedTextures[texShape].forEach((tex) => {
        this.gpgpu.deleteMatrixTexture(tex);
      });
    }
    this.freeTextures = null;
    this.usedTextures = null;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this._numBytesAllocated = 0;
    this._numBytesFree = 0;
  }
};
function numBytesForInternalFormat(gl, internalFormat) {
  const glany = gl;
  if (internalFormat === glany.R32F) {
    return 4;
  } else if (internalFormat === glany.R16F) {
    return 2;
  } else if (internalFormat === glany.RGBA32F) {
    return 16;
  } else if (internalFormat === gl.RGBA) {
    return 16;
  } else if (internalFormat === glany.RGBA16F) {
    return 8;
  }
  throw new Error(`Unknown internal format ${internalFormat}`);
}
function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
  let numElements;
  if (isPacked) {
    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
    numElements = packedWidth * packedHeight;
  } else {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
    numElements = width * height;
  }
  const bytesPerElement2 = numBytesForInternalFormat(gl, internalFormat);
  return numElements * bytesPerElement2;
}
function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
  switch (physicalTexType) {
    case PhysicalTextureType.PACKED_2X2_FLOAT32:
      return getInternalFormatForPackedMatrixTexture(textureConfig);
    case PhysicalTextureType.PACKED_2X2_FLOAT16:
      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
    case PhysicalTextureType.UNPACKED_FLOAT32:
      return getInternalFormatForFloat32MatrixTexture(textureConfig);
    case PhysicalTextureType.UNPACKED_FLOAT16:
      return getInternalFormatForFloat16MatrixTexture(textureConfig);
    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
    default:
      throw new Error(`Unknown physical texture type ${physicalTexType}`);
  }
}
function getPhysicalTextureForRendering(isPacked) {
  if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
    if (isPacked) {
      return PhysicalTextureType.PACKED_2X2_FLOAT32;
    }
    return PhysicalTextureType.UNPACKED_FLOAT32;
  }
  if (isPacked) {
    return PhysicalTextureType.PACKED_2X2_FLOAT16;
  }
  return PhysicalTextureType.UNPACKED_FLOAT16;
}
function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
  if (logicalTexType === TextureUsage.UPLOAD) {
    return PhysicalTextureType.PACKED_2X2_FLOAT32;
  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
    return getPhysicalTextureForRendering(isPacked);
  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
  }
  throw new Error(`Unknown logical texture type ${logicalTexType}`);
}
function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
}
var UnaryOpProgram = class {
  constructor(aShape, opSnippet) {
    this.variableNames = ["A"];
    this.outputShape = aShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;
var LINEAR = `return x;`;
var ABS = `return abs(x);`;
var ELU2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
var RELU = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
var RELU6 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
var CLONE = "return x;";
var SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;
var LINEAR2 = `return x;`;
var ELU3 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
var RELU2 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var RELU62 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var SIGMOID2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
var UnaryOpPackedProgram = class {
  constructor(aShape, opSnippet) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = aShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var UnpackProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outputShape = outputShape;
    const rank = outputShape.length;
    const channels = getChannels("rc", rank);
    const dtype = getCoordsDataType(rank);
    const sourceCoords = getSourceCoords(rank, channels);
    const innerDims = channels.slice(-2);
    const coords32 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
    this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords32}));
      }
    `;
  }
};
var whereImpl3 = kernel_impls_exports.whereImpl;
var EPSILON_FLOAT322 = 1e-7;
var EPSILON_FLOAT162 = 1e-4;
var binaryCaches = {};
function getBinaryCache(webGLVersion) {
  if (webGLVersion in binaryCaches) {
    return binaryCaches[webGLVersion];
  }
  binaryCaches[webGLVersion] = {};
  return binaryCaches[webGLVersion];
}
var CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
var BEFORE_PAGING_CONSTANT = 600;
function numMBBeforeWarning() {
  if (env().global.screen == null) {
    return 1024;
  }
  return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
}
var MathBackendWebGL = class extends KernelBackend {
  constructor(gpgpu) {
    super();
    this.pendingRead = new WeakMap();
    this.pendingDisposal = new WeakSet();
    this.dataRefCount = new WeakMap();
    this.numBytesInGPU = 0;
    this.uploadWaitMs = 0;
    this.downloadWaitMs = 0;
    this.lastGlFlushTime = 0;
    this.warnedAboutMemory = false;
    this.pendingDeletes = 0;
    this.disposed = false;
    if (!env().getBool("HAS_WEBGL")) {
      throw new Error("WebGL is not supported on this device");
    }
    if (gpgpu == null) {
      const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"));
      this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
      this.gpgpu = new GPGPUContext(gl);
      this.canvas = gl.canvas;
      this.gpgpuCreatedLocally = true;
    } else {
      this.gpgpu = gpgpu;
      this.binaryCache = {};
      this.gpgpuCreatedLocally = false;
      this.canvas = gpgpu.gl.canvas;
    }
    this.textureManager = new TextureManager(this.gpgpu);
    this.numMBBeforeWarning = numMBBeforeWarning();
    this.texData = new DataStorage(this, engine());
  }
  nextDataId() {
    return MathBackendWebGL.nextDataId++;
  }
  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }
  write(values, shape, dtype) {
    if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
      this.checkNumericalProblems(values);
    }
    if (dtype === "complex64" && values != null) {
      throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
    }
    const dataId = { id: this.nextDataId() };
    this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
    return dataId;
  }
  refCount(dataId) {
    if (this.texData.has(dataId)) {
      const tensorData = this.texData.get(dataId);
      return tensorData.refCount;
    }
    return 0;
  }
  incRef(dataId) {
    const texData = this.texData.get(dataId);
    texData.refCount++;
  }
  decRef(dataId) {
    if (this.texData.has(dataId)) {
      const texData = this.texData.get(dataId);
      texData.refCount--;
    }
  }
  move(dataId, values, shape, dtype, refCount) {
    if (env().getBool("DEBUG")) {
      this.checkNumericalProblems(values);
    }
    if (dtype === "complex64") {
      throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
    }
    this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
  }
  disposeIntermediateTensorInfo(tensorInfo) {
    this.disposeData(tensorInfo.dataId);
  }
  readSync(dataId) {
    const texData = this.texData.get(dataId);
    const { values, dtype, complexTensorInfos, slice: slice6, shape, isPacked } = texData;
    if (slice6 != null) {
      let program;
      if (isPacked) {
        program = new UnaryOpPackedProgram(shape, CLONE);
      } else {
        program = new UnaryOpProgram(shape, CLONE);
      }
      const res2 = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
      const data = this.readSync(res2.dataId);
      this.disposeIntermediateTensorInfo(res2);
      return data;
    }
    if (values != null) {
      return this.convertAndCacheOnCPU(dataId);
    }
    if (dtype === "string") {
      return values;
    }
    const shouldTimeProgram = this.activeTimers != null;
    let start;
    if (shouldTimeProgram) {
      start = util_exports.now();
    }
    let result;
    if (dtype === "complex64") {
      const realValues = this.readSync(complexTensorInfos.real.dataId);
      const imagValues = this.readSync(complexTensorInfos.imag.dataId);
      result = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
    } else {
      result = this.getValuesFromTexture(dataId);
    }
    if (shouldTimeProgram) {
      this.downloadWaitMs += util_exports.now() - start;
    }
    return this.convertAndCacheOnCPU(dataId, result);
  }
  async read(dataId) {
    if (this.pendingRead.has(dataId)) {
      const subscribers2 = this.pendingRead.get(dataId);
      return new Promise((resolve) => subscribers2.push(resolve));
    }
    const texData = this.texData.get(dataId);
    const { values, shape, slice: slice6, dtype, complexTensorInfos, isPacked } = texData;
    if (slice6 != null) {
      let program;
      if (isPacked) {
        program = new UnaryOpPackedProgram(shape, CLONE);
      } else {
        program = new UnaryOpProgram(shape, CLONE);
      }
      const res2 = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
      const data = this.read(res2.dataId);
      this.disposeIntermediateTensorInfo(res2);
      return data;
    }
    if (values != null) {
      return this.convertAndCacheOnCPU(dataId);
    }
    if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
      throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
    }
    let buffer2 = null;
    let tmpDownloadTarget;
    if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
      tmpDownloadTarget = this.decode(dataId);
      const tmpData = this.texData.get(tmpDownloadTarget.dataId);
      buffer2 = this.gpgpu.createBufferFromTexture(tmpData.texture, ...getDenseTexShape(shape));
    }
    this.pendingRead.set(dataId, []);
    if (dtype !== "complex64") {
      await this.gpgpu.createAndWaitForFence();
    }
    let vals;
    if (dtype === "complex64") {
      const ps = await Promise.all([
        this.read(complexTensorInfos.real.dataId),
        this.read(complexTensorInfos.imag.dataId)
      ]);
      const realValues = ps[0];
      const imagValues = ps[1];
      vals = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
    } else if (buffer2 == null) {
      vals = this.getValuesFromTexture(dataId);
    } else {
      const size2 = util_exports.sizeFromShape(shape);
      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer2, size2);
    }
    if (tmpDownloadTarget != null) {
      this.disposeIntermediateTensorInfo(tmpDownloadTarget);
    }
    if (buffer2 != null) {
      const gl = this.gpgpu.gl;
      callAndCheck(gl, () => gl.deleteBuffer(buffer2));
    }
    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
    const subscribers = this.pendingRead.get(dataId);
    this.pendingRead.delete(dataId);
    subscribers.forEach((resolve) => resolve(dTypeVals));
    if (this.pendingDisposal.has(dataId)) {
      this.pendingDisposal.delete(dataId);
      if (this.disposeData(dataId)) {
        engine().removeDataId(dataId, this);
      }
      this.pendingDeletes--;
    }
    return dTypeVals;
  }
  bufferSync(t2) {
    const data = this.readSync(t2.dataId);
    let decodedData = data;
    if (t2.dtype === "string") {
      try {
        decodedData = data.map((d2) => util_exports.decodeString(d2));
      } catch (_a) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    }
    return buffer(t2.shape, t2.dtype, decodedData);
  }
  checkNumericalProblems(values) {
    if (values == null) {
      return;
    }
    for (let i2 = 0; i2 < values.length; i2++) {
      const num = values[i2];
      if (!canBeRepresented(num)) {
        if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
          throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
        }
        throw Error(`The value ${num} cannot be represented on this device.`);
      }
    }
  }
  getValuesFromTexture(dataId) {
    const { shape, dtype, isPacked } = this.texData.get(dataId);
    const size2 = util_exports.sizeFromShape(shape);
    if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      const tmpTarget = this.decode(dataId);
      const tmpData2 = this.texData.get(tmpTarget.dataId);
      const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture, ...getDenseTexShape(shape)).subarray(0, size2);
      this.disposeIntermediateTensorInfo(tmpTarget);
      return vals2;
    }
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
    const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
    const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
    const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
    const tmpData = this.texData.get(output.dataId);
    const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size2);
    this.disposeIntermediateTensorInfo(output);
    return vals;
  }
  timerAvailable() {
    return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  async time(f2) {
    const oldActiveTimers = this.activeTimers;
    const newActiveTimers = [];
    let outerMostTime = false;
    if (this.programTimersStack == null) {
      this.programTimersStack = newActiveTimers;
      outerMostTime = true;
    } else {
      this.activeTimers.push(newActiveTimers);
    }
    this.activeTimers = newActiveTimers;
    f2();
    const flattenedActiveTimerQueries = util_exports.flatten(this.activeTimers.map((d2) => d2.query)).filter((d2) => d2 != null);
    const flattenedActiveTimerNames = util_exports.flatten(this.activeTimers.map((d2) => d2.name)).filter((d2) => d2 != null);
    this.activeTimers = oldActiveTimers;
    if (outerMostTime) {
      this.programTimersStack = null;
    }
    const res2 = {
      uploadWaitMs: this.uploadWaitMs,
      downloadWaitMs: this.downloadWaitMs,
      kernelMs: null,
      wallMs: null
    };
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
      const kernelMs = await Promise.all(flattenedActiveTimerQueries);
      res2["kernelMs"] = util_exports.sum(kernelMs);
      res2["getExtraProfileInfo"] = () => kernelMs.map((d2, i2) => ({ name: flattenedActiveTimerNames[i2], ms: d2 })).map((d2) => `${d2.name}: ${d2.ms}`).join(", ");
    } else {
      res2["kernelMs"] = {
        error: "WebGL query timers are not supported in this environment."
      };
    }
    this.uploadWaitMs = 0;
    this.downloadWaitMs = 0;
    return res2;
  }
  memory() {
    return {
      unreliable: false,
      numBytesInGPU: this.numBytesInGPU,
      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
      numBytesInGPUFree: this.textureManager.numBytesFree
    };
  }
  startTimer() {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
      return this.gpgpu.beginQuery();
    }
    return { startMs: util_exports.now(), endMs: null };
  }
  endTimer(query) {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
      this.gpgpu.endQuery();
      return query;
    }
    query.endMs = util_exports.now();
    return query;
  }
  async getQueryTime(query) {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
      return this.gpgpu.waitForQueryAndGetTime(query);
    }
    const timerQuery = query;
    return timerQuery.endMs - timerQuery.startMs;
  }
  disposeData(dataId, force = false) {
    if (this.pendingDisposal.has(dataId)) {
      return false;
    }
    if (!this.texData.has(dataId)) {
      return true;
    }
    if (force) {
      this.texData.get(dataId).refCount = 0;
    } else {
      this.texData.get(dataId).refCount--;
    }
    if (!force && this.texData.get(dataId).refCount > 0) {
      return false;
    }
    if (this.pendingRead.has(dataId)) {
      this.pendingDisposal.add(dataId);
      this.pendingDeletes++;
      return false;
    }
    this.releaseGPUData(dataId);
    const { complexTensorInfos } = this.texData.get(dataId);
    if (complexTensorInfos != null) {
      this.disposeData(complexTensorInfos.real.dataId, force);
      this.disposeData(complexTensorInfos.imag.dataId, force);
    }
    this.texData.delete(dataId);
    return true;
  }
  releaseGPUData(dataId) {
    const { texture, dtype, texShape, usage, isPacked, slice: slice6 } = this.texData.get(dataId);
    const key = slice6 && slice6.origDataId || dataId;
    const refCount = this.dataRefCount.get(key);
    if (refCount > 1) {
      this.dataRefCount.set(key, refCount - 1);
    } else {
      this.dataRefCount.delete(key);
      if (texture != null) {
        this.numBytesInGPU -= this.computeBytes(texShape, dtype);
        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
      }
    }
    const texData = this.texData.get(dataId);
    texData.texture = null;
    texData.texShape = null;
    texData.isPacked = false;
    texData.slice = null;
  }
  getTexture(dataId) {
    this.uploadToGPU(dataId);
    return this.texData.get(dataId).texture;
  }
  getDataInfo(dataId) {
    return this.texData.get(dataId);
  }
  shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
    return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input2) => this.texData.get(input2.dataId).texture == null && util_exports.sizeFromShape(input2.shape) < sizeThreshold);
  }
  getGPGPUContext() {
    return this.gpgpu;
  }
  where(condition) {
    backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    const condVals = condition.dataSync();
    return whereImpl3(condition.shape, condVals);
  }
  packedUnaryOp(x2, op2, dtype) {
    const program = new UnaryOpPackedProgram(x2.shape, op2);
    const outInfo = this.compileAndRun(program, [x2], dtype);
    return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
  }
  abs(x2) {
    if (this.shouldExecuteOnCPU([x2]) && x2.dtype !== "complex64") {
      const outValues = simpleAbsImplCPU(this.texData.get(x2.dataId).values);
      return this.makeOutput(x2.shape, x2.dtype, outValues);
    }
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      return this.packedUnaryOp(x2, ABS, x2.dtype);
    }
    const program = new UnaryOpProgram(x2.shape, ABS);
    const outInfo = this.compileAndRun(program, [x2]);
    return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
  }
  makeTensorInfo(shape, dtype, values) {
    let dataId;
    if (dtype === "string" && values != null && values.length > 0 && util_exports.isString(values[0])) {
      const encodedValues = values.map((d2) => util_exports.encodeString(d2));
      dataId = this.write(encodedValues, shape, dtype);
    } else {
      dataId = this.write(values, shape, dtype);
    }
    this.texData.get(dataId).usage = null;
    return { dataId, shape, dtype };
  }
  makeOutput(shape, dtype, values) {
    const { dataId } = this.makeTensorInfo(shape, dtype, values);
    return engine().makeTensorFromDataId(dataId, shape, dtype, this);
  }
  unpackTensor(input2) {
    const program = new UnpackProgram(input2.shape);
    return this.runWebGLProgram(program, [input2], input2.dtype);
  }
  packTensor(input2) {
    const program = new PackProgram(input2.shape);
    const preventEagerUnpackingOutput = true;
    return this.runWebGLProgram(program, [input2], input2.dtype, null, preventEagerUnpackingOutput);
  }
  packedReshape(input2, afterShape) {
    const input3DShape = [
      getBatchDim(input2.shape),
      ...getRowsCols(input2.shape)
    ];
    const input3D = {
      dtype: input2.dtype,
      shape: input3DShape,
      dataId: input2.dataId
    };
    const afterShapeAs3D = [
      getBatchDim(afterShape),
      ...getRowsCols(afterShape)
    ];
    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const customValues = [input3DShape];
    const output = this.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
  }
  decode(dataId) {
    const texData = this.texData.get(dataId);
    const { isPacked, shape, dtype } = texData;
    const shapeAs3D = getShapeAs3D(shape);
    let program;
    const denseTexShape = getDenseTexShape(shapeAs3D);
    if (isPacked) {
      program = new DecodeMatrixPackedProgram(shapeAs3D);
    } else {
      program = new DecodeMatrixProgram(shapeAs3D);
    }
    const preventEagerUnpackingOfOutput = true;
    const customValues = [denseTexShape];
    const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput);
    return { dtype, shape, dataId: out.dataId };
  }
  runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
    const output = this.makeTensorInfo(program.outputShape, outputDtype);
    const outData = this.texData.get(output.dataId);
    if (program.packedOutput) {
      outData.isPacked = true;
    }
    if (program.outPackingScheme === PackingScheme.DENSE) {
      const texelShape = getDenseTexShape(program.outputShape);
      outData.texShape = texelShape.map((d2) => d2 * 2);
    }
    if (program.outTexUsage != null) {
      outData.usage = program.outTexUsage;
    }
    if (util_exports.sizeFromShape(output.shape) === 0) {
      outData.values = util_exports.getTypedArrayFromDType(output.dtype, 0);
      return output;
    }
    const dataToDispose = [];
    const inputsData = inputs.map((input2) => {
      if (input2.dtype === "complex64") {
        throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
      }
      let texData = this.texData.get(input2.dataId);
      if (texData.texture == null) {
        if (!program.packedInputs && util_exports.sizeFromShape(input2.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
          return {
            shape: input2.shape,
            texData: null,
            isUniform: true,
            uniformValues: texData.values
          };
        }
        if (program.packedInputs) {
          texData.isPacked = true;
          texData.shape = input2.shape;
        }
      } else if (!!texData.isPacked !== !!program.packedInputs) {
        input2 = texData.isPacked ? this.unpackTensor(input2) : this.packTensor(input2);
        dataToDispose.push(input2);
        texData = this.texData.get(input2.dataId);
      } else if (texData.isPacked && !isReshapeFree(texData.shape, input2.shape)) {
        const savedInput = input2;
        const targetShape = input2.shape;
        input2.shape = texData.shape;
        input2 = this.packedReshape(input2, targetShape);
        dataToDispose.push(input2);
        texData = this.texData.get(input2.dataId);
        savedInput.shape = targetShape;
      }
      this.uploadToGPU(input2.dataId);
      return { shape: input2.shape, texData, isUniform: false };
    });
    this.uploadToGPU(output.dataId);
    const outputData = { shape: output.shape, texData: outData, isUniform: false };
    const key = makeShaderKey(program, inputsData, outputData);
    const binary = this.getAndSaveBinary(key, () => {
      return compileProgram(this.gpgpu, program, inputsData, outputData);
    });
    const shouldTimeProgram = this.activeTimers != null;
    let query;
    if (shouldTimeProgram) {
      query = this.startTimer();
    }
    runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
    dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
    if (shouldTimeProgram) {
      query = this.endTimer(query);
      this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
    }
    const glFlushThreshold = env().get("WEBGL_FLUSH_THRESHOLD");
    if (glFlushThreshold > 0) {
      const time2 = util_exports.now();
      if (time2 - this.lastGlFlushTime > glFlushThreshold) {
        this.gpgpu.gl.flush();
        this.lastGlFlushTime = time2;
      }
    }
    if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
      const unpacked = this.unpackTensor(output);
      this.disposeIntermediateTensorInfo(output);
      return unpacked;
    }
    return output;
  }
  compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
    outputDtype = outputDtype || inputs[0].dtype;
    const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
    return outInfo;
  }
  getAndSaveBinary(key, getBinary) {
    if (!(key in this.binaryCache)) {
      this.binaryCache[key] = getBinary();
    }
    return this.binaryCache[key];
  }
  getTextureManager() {
    return this.textureManager;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (!env().getBool("IS_TEST")) {
      const allKeys = Object.keys(this.binaryCache);
      allKeys.forEach((key) => {
        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        delete this.binaryCache[key];
      });
    }
    this.textureManager.dispose();
    if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
      this.canvas.remove();
    } else {
      this.canvas = null;
    }
    if (this.gpgpuCreatedLocally) {
      this.gpgpu.program = null;
      this.gpgpu.dispose();
    }
    this.disposed = true;
  }
  floatPrecision() {
    if (this.floatPrecisionValue == null) {
      this.floatPrecisionValue = tidy(() => {
        if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          const debugFlag = env().getBool("DEBUG");
          env().set("DEBUG", false);
          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
          env().set("DEBUG", debugFlag);
          if (underflowCheckValue > 0) {
            return 32;
          }
        }
        return 16;
      });
    }
    return this.floatPrecisionValue;
  }
  epsilon() {
    return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
  }
  uploadToGPU(dataId) {
    const texData = this.texData.get(dataId);
    const { shape, dtype, values, texture, usage, isPacked } = texData;
    if (texture != null) {
      return;
    }
    const shouldTimeProgram = this.activeTimers != null;
    let start;
    if (shouldTimeProgram) {
      start = util_exports.now();
    }
    let texShape = texData.texShape;
    if (texShape == null) {
      texShape = getTextureShapeFromLogicalShape(shape, isPacked);
      texData.texShape = texShape;
    }
    if (values != null) {
      const shapeAs3D = getShapeAs3D(shape);
      let program;
      let width = texShape[1], height = texShape[0];
      const isByteArray = values instanceof Uint8Array;
      if (isPacked) {
        [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
        program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
      } else {
        program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
      }
      const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);
      if (isByteArray) {
        this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.PIXELS;
      } else {
        this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.UPLOAD;
      }
      this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
      const customValues = [[height, width]];
      const preventEagerUnpacking = true;
      const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
      const outputTexData = this.texData.get(encodedOutputTarget.dataId);
      texData.texture = outputTexData.texture;
      texData.texShape = outputTexData.texShape;
      texData.isPacked = outputTexData.isPacked;
      texData.usage = outputTexData.usage;
      this.disposeIntermediateTensorInfo(tempDenseInputHandle);
      this.texData.delete(encodedOutputTarget.dataId);
      texData.values = null;
      if (shouldTimeProgram) {
        this.uploadWaitMs += util_exports.now() - start;
      }
    } else {
      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
      texData.texture = newTexture;
    }
  }
  convertAndCacheOnCPU(dataId, float32Values) {
    const texData = this.texData.get(dataId);
    const { dtype } = texData;
    this.releaseGPUData(dataId);
    if (float32Values != null) {
      texData.values = float32ToTypedArray(float32Values, dtype);
    }
    return texData.values;
  }
  acquireTexture(texShape, texType, dtype, isPacked) {
    this.numBytesInGPU += this.computeBytes(texShape, dtype);
    if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true;
      console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
    }
    return this.textureManager.acquireTexture(texShape, texType, isPacked);
  }
  computeBytes(shape, dtype) {
    return shape[0] * shape[1] * util_exports.bytesPerElement(dtype);
  }
};
MathBackendWebGL.nextDataId = 0;
function float32ToTypedArray(a6, dtype) {
  if (dtype === "float32" || dtype === "complex64") {
    return a6;
  } else if (dtype === "int32" || dtype === "bool") {
    const result = dtype === "int32" ? new Int32Array(a6.length) : new Uint8Array(a6.length);
    for (let i2 = 0; i2 < result.length; ++i2) {
      result[i2] = Math.round(a6[i2]);
    }
    return result;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
var version5 = "3.9.0";
function forceHalfFloat() {
  env().set("WEBGL_FORCE_F16_TEXTURES", true);
}
if (device_util_exports.isBrowser()) {
  registerBackend("webgl", () => new MathBackendWebGL(), 2);
}
var webgl = { forceHalfFloat };
var CHECK_NAN_SNIPPET2 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
var BinaryOpProgram = class {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["A", "B"];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
};
var CHECK_NAN_SNIPPET3 = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
var BinaryOpPackedProgram = class {
  constructor(op2, aShape, bShape, checkOutOfBounds = false) {
    this.variableNames = ["A", "B"];
    this.supportsBroadcasting = true;
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    const rank = this.outputShape.length;
    this.enableShapeUniforms = useShapeUniforms(rank);
    let checkOutOfBoundsString = "";
    if (checkOutOfBounds) {
      if (rank === 0 || util_exports.sizeFromShape(this.outputShape) === 1) {
        checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      } else {
        const dtype = getCoordsDataType(rank);
        checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
        if (rank === 1) {
          if (this.enableShapeUniforms) {
            checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
          } else {
            checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
          }
        } else {
          const channels = getChannels("coords", rank);
          if (this.enableShapeUniforms) {
            checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          } else {
            checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          }
        }
      }
    }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
  }
};
function identity3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  backend22.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: x2.shape, dtype: x2.dtype };
}
var identityConfig2 = {
  kernelName: Identity,
  backendName: "webgl",
  kernelFunc: identity3
};
function complex3(args) {
  const { inputs, backend: backend22 } = args;
  const { real: real5, imag: imag5 } = inputs;
  const complexInfo = backend22.makeTensorInfo(real5.shape, "complex64");
  const complex5 = backend22.texData.get(complexInfo.dataId);
  const realTensorInfo = identity3({ inputs: { x: real5 }, backend: backend22 });
  const imagTensorInfo = identity3({ inputs: { x: imag5 }, backend: backend22 });
  complex5.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
  return complexInfo;
}
var complexConfig2 = {
  kernelName: Complex,
  backendName: "webgl",
  kernelFunc: complex3
};
var LEAKYRELU = `return (a < 0.) ? b * a : a;`;
var LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function leakyRelu3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { alpha } = attrs;
  const $alpha = backend22.makeTensorInfo([], "float32", util_exports.createScalarValue(alpha, "float32"));
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x2.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x2.shape, $alpha.shape);
  const result = backend22.runWebGLProgram(program, [x2, $alpha], x2.dtype);
  backend22.disposeIntermediateTensorInfo($alpha);
  return result;
}
var leakyReluConfig2 = {
  kernelName: LeakyRelu,
  backendName: "webgl",
  kernelFunc: leakyRelu3
};
var PRELU = `return (a < 0.) ? b * a : a;`;
var PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function prelu4(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2, alpha } = inputs;
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x2.shape, alpha.shape) : new BinaryOpProgram(PRELU, x2.shape, alpha.shape);
  return backend22.runWebGLProgram(program, [x2, alpha], x2.dtype);
}
var preluConfig2 = {
  kernelName: Prelu,
  backendName: "webgl",
  kernelFunc: prelu4
};
var CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
var CHECK_NAN_SNIPPET_BINARY = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
var CHECK_NAN_SNIPPET_BINARY_PACKED = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
function unaryKernelFunc2({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const webglBackend = backend22;
    const $dtype = dtype || x2.dtype;
    if (webglBackend.shouldExecuteOnCPU([x2]) && cpuKernelImpl != null) {
      const xData = webglBackend.texData.get(x2.dataId);
      const outValues = cpuKernelImpl(xData.values, $dtype);
      return webglBackend.makeTensorInfo(x2.shape, $dtype, outValues);
    }
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
    let program;
    if (shouldUsePackedProgram) {
      program = new UnaryOpPackedProgram(x2.shape, packedOpSnippet);
    } else {
      program = new UnaryOpProgram(x2.shape, opSnippet);
    }
    return webglBackend.runWebGLProgram(program, [x2], $dtype);
  };
}
function binaryKernelFunc2({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend22 }) => {
    const { a: a6, b: b2 } = inputs;
    const webglBackend = backend22;
    if (supportsComplex && a6.dtype === "complex64") {
      const aData = webglBackend.texData.get(a6.dataId);
      const bData = webglBackend.texData.get(b2.dataId);
      const [real5, imag5] = [
        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
      ].map((complexParts) => {
        const [aPart, bPart] = complexParts;
        const aHandle = {
          dataId: aPart.dataId,
          dtype: aPart.dtype,
          shape: a6.shape
        };
        const bHandle = {
          dataId: bPart.dataId,
          dtype: bPart.dtype,
          shape: b2.shape
        };
        const program2 = new BinaryOpProgram(opSnippet, a6.shape, b2.shape);
        return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
      });
      const complexOutput = complex3({ inputs: { real: real5, imag: imag5 }, backend: webglBackend });
      webglBackend.disposeIntermediateTensorInfo(real5);
      webglBackend.disposeIntermediateTensorInfo(imag5);
      return complexOutput;
    }
    const $dtype = dtype || upcastType(a6.dtype, b2.dtype);
    if ((a6.dtype === "string" || b2.dtype === "string" || webglBackend.shouldExecuteOnCPU([a6, b2])) && cpuKernelImpl != null) {
      const aVals = webglBackend.texData.get(a6.dataId).values;
      const bVals = webglBackend.texData.get(b2.dataId).values;
      const decodedAVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
      const decodedBVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
      const [outValues, outShape] = cpuKernelImpl(a6.shape, b2.shape, decodedAVals, decodedBVals, $dtype);
      const out = webglBackend.makeTensorInfo(outShape, $dtype);
      const outData = webglBackend.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
    let program;
    if (shouldUsePackedProgram) {
      program = new BinaryOpPackedProgram(packedOpSnippet, a6.shape, b2.shape, checkOutOfBounds);
    } else {
      program = new BinaryOpProgram(opSnippet, a6.shape, b2.shape);
    }
    return webglBackend.runWebGLProgram(program, [a6, b2], $dtype);
  };
}
function mapActivationToShaderProgram(activation2, packed = false) {
  if (activation2 === "linear") {
    if (packed) {
      return LINEAR2;
    }
    return LINEAR;
  } else if (activation2 === "relu") {
    if (packed) {
      return RELU2;
    }
    return RELU;
  } else if (activation2 === "elu") {
    if (packed) {
      return ELU3;
    }
    return ELU2;
  } else if (activation2 === "relu6") {
    if (packed) {
      return RELU62;
    }
    return RELU6;
  } else if (activation2 === "prelu") {
    if (packed) {
      return PRELU_PACKED;
    }
    return PRELU;
  } else if (activation2 === "leakyrelu") {
    if (packed) {
      return LEAKYRELU_PACKED;
    }
    return LEAKYRELU;
  } else if (activation2 === "sigmoid") {
    if (packed) {
      return SIGMOID2;
    }
    return SIGMOID;
  }
  throw new Error(`Activation ${activation2} has not been implemented for the WebGL backend.`);
}
var MatMulPackedProgram = class {
  constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
    this.variableNames = ["matrixA", "matrixB"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const sharedDim = transposeA ? aShape[1] : aShape[2];
    const sharedDimensionPacked = Math.ceil(sharedDim / 2);
    const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
    const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
    const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
    const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyreluActivation) {
      this.variableNames.push("leakyreluAlpha");
    }
    let batchASnippet = "rc.x";
    let batchBSnippet = "rc.x";
    if (aShape[0] < bShape[0]) {
      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
    } else if (bShape[0] < aShape[0]) {
      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
    }
    this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
  }
};
var COMPLEX_MULTIPLY = {
  REAL: "return areal * breal - aimag * bimag;",
  IMAG: "return areal * bimag + aimag * breal;"
};
var BinaryOpComplexProgram = class {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
};
var MUL = "return a * b;";
function multiply3(args) {
  const { inputs, backend: backend22 } = args;
  const { a: a6, b: b2 } = inputs;
  const dtype = backend_util_exports.upcastType(a6.dtype, b2.dtype);
  if (a6.dtype === "complex64") {
    const aData = backend22.texData.get(a6.dataId);
    const bData = backend22.texData.get(b2.dataId);
    const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a6.shape, b2.shape);
    const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a6.shape, b2.shape);
    const inputs2 = [
      {
        dataId: aData.complexTensorInfos.real.dataId,
        dtype: aData.complexTensorInfos.real.dtype,
        shape: a6.shape
      },
      {
        dataId: aData.complexTensorInfos.imag.dataId,
        dtype: aData.complexTensorInfos.imag.dtype,
        shape: a6.shape
      },
      {
        dataId: bData.complexTensorInfos.real.dataId,
        dtype: bData.complexTensorInfos.real.dtype,
        shape: b2.shape
      },
      {
        dataId: bData.complexTensorInfos.imag.dataId,
        dtype: bData.complexTensorInfos.imag.dtype,
        shape: b2.shape
      }
    ];
    const realPart = backend22.runWebGLProgram(realProgram, inputs2, "float32");
    const imagPart = backend22.runWebGLProgram(imagProgram, inputs2, "float32");
    const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(realPart);
    backend22.disposeIntermediateTensorInfo(imagPart);
    return complexOutput;
  }
  if (backend22.shouldExecuteOnCPU([a6, b2])) {
    const aData = backend22.texData.get(a6.dataId);
    const bData = backend22.texData.get(b2.dataId);
    const [outValues, outShape] = multiplyImplCPU(a6.shape, b2.shape, aData.values, bData.values, dtype);
    const out = backend22.makeTensorInfo(outShape, dtype);
    const outData = backend22.texData.get(out.dataId);
    outData.values = outValues;
    return out;
  }
  let program;
  if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
    program = new BinaryOpPackedProgram(MUL, a6.shape, b2.shape);
  } else {
    program = new BinaryOpProgram(MUL, a6.shape, b2.shape);
  }
  return backend22.runWebGLProgram(program, [a6, b2], dtype);
}
var multiplyConfig2 = {
  kernelName: Multiply,
  backendName: "webgl",
  kernelFunc: multiply3
};
function packedReshape(input2, afterShape, backend22) {
  const input3DShape = [
    getBatchDim(input2.shape),
    ...getRowsCols(input2.shape)
  ];
  const input3D = {
    dtype: input2.dtype,
    shape: input3DShape,
    dataId: input2.dataId
  };
  const afterShapeAs3D = [
    getBatchDim(afterShape),
    ...getRowsCols(afterShape)
  ];
  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
  const preventEagerUnpackingOfOutput = true;
  const customValues = [input3DShape];
  const output = backend22.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
  return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
}
function reshape4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { shape } = attrs;
  const webglBackend = backend22;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const $shape = util_exports.inferFromImplicitShape(shape, xSize);
  const $xSize = util_exports.sizeFromShape($shape);
  util_exports.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x2.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
  const xTexData = webglBackend.texData.get(x2.dataId);
  if (xTexData.isPacked && !isReshapeFree(x2.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
    return packedReshape(x2, $shape, webglBackend);
  }
  webglBackend.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: $shape, dtype: x2.dtype };
}
var reshapeConfig2 = {
  kernelName: Reshape,
  backendName: "webgl",
  kernelFunc: reshape4
};
var MeanProgram = class {
  constructor(reduceInfo, divisor) {
    this.variableNames = ["x"];
    const { windowSize, batchSize, inSize, outSize } = reduceInfo;
    this.outputShape = [batchSize, outSize];
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    let updateSnippet = `sumValue += dot(values, ones);`;
    if (divisor != null) {
      const denominator = 1 / divisor;
      updateSnippet = `sumValue += dot(values * ${util_exports.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
    }
    let checkOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
    }
    this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
  }
};
var ReduceProgram = class {
  constructor(reduceInfo, reduceType) {
    this.variableNames = ["x"];
    const { windowSize, batchSize, inSize, outSize } = reduceInfo;
    this.outputShape = [batchSize, outSize];
    let initializationValue = "0.0";
    let compareOp = ``;
    if (reduceType === "prod") {
      initializationValue = "1.0";
    } else if (reduceType === "min") {
      initializationValue = "1.0 / 1e-20";
      compareOp = `min`;
    } else if (reduceType === "max") {
      initializationValue = "-1.0 / 1e-20";
      compareOp = `max`;
    }
    let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    if (reduceType === "sum") {
      returnValue = `sumValue`;
    } else if (reduceType === "prod") {
      returnValue = `prodValue`;
    } else if (reduceType === "all") {
      returnValue = `allValue`;
    } else if (reduceType === "any") {
      returnValue = `anyValue`;
    }
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === "min"} || ${reduceType === "max"}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
    let vecType = `vec4`;
    if (reduceType === "all") {
      initializationValue = "1.0";
      updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
      vecType = `bvec4`;
    } else if (reduceType === "any") {
      initializationValue = "0.0";
      updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
      vecType = `bvec4`;
    }
    let checkOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
  }
};
function getReductionStages(inShape) {
  const stages = [];
  while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
    const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
    const windowSize = backend_util_exports.computeOptimalWindowSize(outSize);
    stages.push({
      inSize: outSize,
      windowSize,
      outSize: Math.ceil(outSize / windowSize)
    });
  }
  return stages;
}
function reduce(x2, dtype, reductionType, backend22) {
  const reductionStages = getReductionStages(x2.shape);
  let result = x2;
  for (let i2 = 0; i2 < reductionStages.length; i2++) {
    const { inSize, windowSize, outSize } = reductionStages[i2];
    let program;
    let previousResult;
    if (reductionType === "mean") {
      program = i2 === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize });
    } else {
      program = new ReduceProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize }, reductionType);
    }
    previousResult = result;
    result = backend22.runWebGLProgram(program, [result], dtype);
    if (previousResult.dataId !== x2.dataId) {
      backend22.disposeIntermediateTensorInfo(previousResult);
    }
  }
  return result;
}
var TransposeProgram = class {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[newDim[i2]];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const switched = getSwitchedCoords(newDim);
    this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
  }
};
function getSwitchedCoords(newDim) {
  const rank = newDim.length;
  if (rank > 6) {
    throw Error(`Transpose for rank ${rank} is not yet supported`);
  }
  const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
  const switchedCoords = new Array(rank);
  for (let i2 = 0; i2 < newDim.length; i2++) {
    switchedCoords[newDim[i2]] = originalOrder[i2];
  }
  return switchedCoords.join();
}
var TransposePackedProgram = class {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[newDim[i2]];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    if (this.rank > 6) {
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    }
    const dtype = getCoordsDataType(this.rank);
    const outputOrder = getVecChannels("rc", this.rank);
    const switchedOrder = new Array(this.rank);
    for (let i2 = 0; i2 < newDim.length; i2++) {
      switchedOrder[newDim[i2]] = outputOrder[i2];
    }
    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
    const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
    this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
  }
};
function transposeImpl2(x2, perm, backend22) {
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x2.shape, perm) : new TransposeProgram(x2.shape, perm);
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
function sumImpl(x2, axis, keepDims, backend22) {
  const reductionIndices = axis;
  const xRank = x2.shape.length;
  const origAxes = util_exports.parseAxisParam(reductionIndices, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  const sumInputIsTransposed = permutedAxes != null;
  let sumInput = x2;
  if (sumInputIsTransposed) {
    sumInput = transposeImpl2(x2, permutedAxes, backend22);
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
  }
  backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
  const [sumOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(sumInput.shape, axes);
  let outShape = sumOutShape;
  if (keepDims) {
    outShape = backend_util_exports.expandShapeToKeepDim(sumOutShape, origAxes);
  }
  const inSize = util_exports.sizeFromShape(reduceShape);
  const xSize = util_exports.sizeFromShape(x2.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape4({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend: backend22 });
  const outType = sumOutType(x2.dtype);
  const reduced = reduce(reshapedInput, outType, "sum", backend22);
  const out = reshape4({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(reshapedInput);
  backend22.disposeIntermediateTensorInfo(reduced);
  if (sumInputIsTransposed) {
    backend22.disposeIntermediateTensorInfo(sumInput);
  }
  return out;
}
function sum4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  return sumImpl(x2, axis, keepDims, backend22);
}
var sumConfig2 = {
  kernelName: Sum,
  backendName: "webgl",
  kernelFunc: sum4
};
function transpose3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { perm } = attrs;
  const webglBackend = backend22;
  const xRank = x2.shape.length;
  const newShape = new Array(xRank);
  for (let i2 = 0; i2 < newShape.length; i2++) {
    newShape[i2] = x2.shape[perm[i2]];
  }
  let out;
  if (webglBackend.shouldExecuteOnCPU([x2])) {
    const xTexData = webglBackend.texData.get(x2.dataId);
    const values = xTexData.values;
    const outValues = transposeImplCPU(values, x2.shape, x2.dtype, perm, newShape);
    out = webglBackend.makeTensorInfo(newShape, x2.dtype);
    const outData = webglBackend.texData.get(out.dataId);
    outData.values = outValues;
  } else {
    out = transposeImpl2(x2, perm, webglBackend);
  }
  return out;
}
var transposeConfig2 = {
  kernelName: Transpose,
  backendName: "webgl",
  kernelFunc: transpose3
};
var MATMUL_SHARED_DIM_THRESHOLD = 1e3;
function batchMatMulImpl({ a: a6, b: b2, transposeA, transposeB, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const aRank = a6.shape.length;
  const bRank = b2.shape.length;
  const innerShapeA = transposeA ? a6.shape[aRank - 2] : a6.shape[aRank - 1];
  const innerShapeB = transposeB ? b2.shape[bRank - 1] : b2.shape[bRank - 2];
  const outerShapeA = transposeA ? a6.shape[aRank - 1] : a6.shape[aRank - 2];
  const outerShapeB = transposeB ? b2.shape[bRank - 2] : b2.shape[bRank - 1];
  const outerDimsA = a6.shape.slice(0, -2);
  const outerDimsB = b2.shape.slice(0, -2);
  const batchDimA = util_exports.sizeFromShape(outerDimsA);
  const batchDimB = util_exports.sizeFromShape(outerDimsB);
  const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
  util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
  const outShapeOuterDims = batchDimA > batchDimB ? a6.shape.slice(0, -2) : b2.shape.slice(0, -2);
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a6.shape} and ${b2.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape4({ inputs: { x: a6 }, backend: backend22, attrs: { shape: a3dShape } });
  const b3d = reshape4({ inputs: { x: b2 }, backend: backend22, attrs: { shape: b3dShape } });
  const intermediates = [a3d, b3d];
  const batchDim = Math.max(batchDimA, batchDimB);
  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  const fusedActivation = activation2 != null ? mapActivationToShaderProgram(activation2, true) : null;
  const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
  let out;
  if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
    let aVec = a3d;
    let bVec = b3d;
    if (transposeA) {
      aVec = transpose3({ inputs: { x: a3d }, backend: backend22, attrs: { perm: [0, 2, 1] } });
      intermediates.push(aVec);
    }
    if (transposeB) {
      bVec = transpose3({ inputs: { x: b3d }, backend: backend22, attrs: { perm: [0, 2, 1] } });
      intermediates.push(bVec);
    }
    const shouldReshapeA = outerShapeB !== 1;
    const shouldReshapeB = outerShapeB === 1;
    let aVec3d = aVec;
    if (shouldReshapeA) {
      aVec3d = reshape4({
        inputs: { x: aVec },
        backend: backend22,
        attrs: { shape: [batchDim, sharedDim, 1] }
      });
      intermediates.push(aVec3d);
    }
    const axis = outerShapeB === 1 ? 2 : 1;
    let bVec3d = bVec;
    if (shouldReshapeB) {
      bVec3d = reshape4({
        inputs: { x: bVec },
        backend: backend22,
        attrs: { shape: [batchDim, 1, sharedDim] }
      });
      intermediates.push(bVec3d);
    }
    const product = multiply3({ inputs: { a: aVec3d, b: bVec3d }, backend: backend22 });
    out = sum4({ inputs: { x: product }, backend: backend22, attrs: { axis, keepDims: true } });
    intermediates.push(product);
  } else {
    const dtype = upcastType(a6.dtype, b2.dtype);
    const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [a3d, b3d];
    if (bias != null) {
      inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend22.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
      inputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    out = backend22.runWebGLProgram(program, inputs, dtype);
  }
  const outReshaped = reshape4({ inputs: { x: out }, backend: backend22, attrs: { shape: outShape } });
  intermediates.push(out);
  for (const i2 of intermediates) {
    backend22.disposeIntermediateTensorInfo(i2);
  }
  return outReshaped;
}
function _fusedMatMul2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  return batchMatMulImpl({
    a: a6,
    b: b2,
    transposeA,
    transposeB,
    backend: backend22,
    bias,
    preluActivationWeights,
    leakyreluAlpha,
    activation: activation2
  });
}
var _fusedMatMulConfig2 = {
  kernelName: _FusedMatMul,
  backendName: "webgl",
  kernelFunc: _fusedMatMul2
};
var ABS2 = `return abs(x);`;
function abs3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (backend22.shouldExecuteOnCPU([x2]) && x2.dtype !== "complex64") {
    const xData = backend22.texData.get(x2.dataId);
    const outValues = simpleAbsImplCPU(xData.values);
    return backend22.makeTensorInfo(x2.shape, x2.dtype, outValues);
  }
  let program;
  if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
    program = new UnaryOpPackedProgram(x2.shape, ABS2);
  } else {
    program = new UnaryOpProgram(x2.shape, ABS2);
  }
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
var absConfig2 = {
  kernelName: Abs,
  backendName: "webgl",
  kernelFunc: abs3
};
var ACOS = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
var acos3 = unaryKernelFunc2({ opSnippet: ACOS });
var acosConfig2 = {
  kernelName: Acos,
  backendName: "webgl",
  kernelFunc: acos3
};
var ACOSH = CHECK_NAN_SNIPPET + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
var acosh3 = unaryKernelFunc2({ opSnippet: ACOSH });
var acoshConfig2 = {
  kernelName: Acosh,
  backendName: "webgl",
  kernelFunc: acosh3
};
var ADD = "return a + b;";
var addKernelFunc = binaryKernelFunc2({
  opSnippet: ADD,
  packedOpSnippet: ADD,
  supportsComplex: true,
  cpuKernelImpl: addImplCPU
});
var addConfig2 = {
  kernelName: Add,
  backendName: "webgl",
  kernelFunc: addKernelFunc
};
var AddNProgram = class {
  constructor(outputShape, shapes) {
    this.outputShape = [];
    this.outputShape = outputShape;
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
    });
    const operation = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation};
        setOutput(result);
      }
    `;
  }
};
var AddNPackedProgram = class {
  constructor(outputShape, shapes) {
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = outputShape;
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
    });
    const operation = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
  }
};
function addN3(args) {
  const { inputs, backend: backend22 } = args;
  const tensors = inputs;
  if (tensors.length === 1) {
    return identity3({ inputs: { x: tensors[0] }, backend: backend22 });
  }
  if (tensors.length > env().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const midIndex = Math.floor(tensors.length / 2);
    const leftSide = addN3({ inputs: tensors.slice(0, midIndex), backend: backend22 });
    const rightSide = addN3({ inputs: tensors.slice(midIndex), backend: backend22 });
    return addN3({ inputs: [leftSide, rightSide], backend: backend22 });
  }
  const dtype = tensors.map((t2) => t2.dtype).reduce((d1, d2) => upcastType(d1, d2));
  const shapes = tensors.map((t2) => t2.shape);
  const usePackedOp = env().getBool("WEBGL_PACK");
  const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
  return backend22.runWebGLProgram(program, tensors, dtype);
}
var addNConfig2 = {
  kernelName: AddN,
  backendName: "webgl",
  kernelFunc: addN3
};
function all3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x2.shape.length;
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let permutedX = x2;
  if (permutedAxes != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
  }
  backend_util_exports.assertAxesAreInnerMostDims("all", axes, xRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = util_exports.sizeFromShape(reduceShape);
  const a2D = reshape4({ inputs: { x: permutedX }, backend: backend22, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "all", backend22);
  let res2;
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: newShape } });
  } else {
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: outShape } });
  }
  backend22.disposeIntermediateTensorInfo(a2D);
  backend22.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo(permutedX);
  }
  return res2;
}
var allConfig2 = {
  kernelName: All,
  backendName: "webgl",
  kernelFunc: all3
};
function any3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x2.shape.length;
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let permutedX = x2;
  if (permutedAxes != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
  }
  backend_util_exports.assertAxesAreInnerMostDims("any", axes, xRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = util_exports.sizeFromShape(reduceShape);
  const a2D = reshape4({ inputs: { x: permutedX }, backend: backend22, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "any", backend22);
  let res2;
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: newShape } });
  } else {
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: outShape } });
  }
  backend22.disposeIntermediateTensorInfo(a2D);
  backend22.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo(permutedX);
  }
  return res2;
}
var anyConfig2 = {
  kernelName: Any,
  backendName: "webgl",
  kernelFunc: any3
};
var ArgMinMaxProgram = class {
  constructor(reduceInfo, op2, firstPass) {
    this.variableNames = ["A"];
    const { windowSize, batchSize, outSize } = reduceInfo;
    if (!firstPass) {
      this.variableNames.push("bestIndicesA");
    }
    this.outputShape = [batchSize, outSize];
    const compOp = op2 === "max" ? ">" : "<";
    const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
};
var ArgMinMaxPackedProgram = class {
  constructor(shape, windowSize, op2, firstPass) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    util_exports.assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
    const inSize = shape[shape.length - 1];
    const outSize = Math.ceil(inSize / windowSize);
    this.outputShape = shape.slice(0, -1);
    if (outSize > 1) {
      this.outputShape.push(outSize);
    }
    if (!firstPass) {
      this.variableNames.push("bestIndicesA");
    }
    const outShape = this.outputShape;
    const rank = outShape.length;
    const dtype = getCoordsDataType(rank);
    const coords32 = getChannels("coords", rank);
    let sourceLocSetup;
    let sourceRank;
    if (outSize === 1) {
      sourceRank = rank + 1;
      const sourceLocDType = getCoordsDataType(sourceRank);
      sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords32.join()}, 0);
        ++${coords32[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords32.join()}, 0);
        ++${coords32[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords32.join()}, 0);
        --${coords32[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords32.join()}, 0);
        --${coords32[rank - 2]};`;
    } else {
      sourceRank = rank;
      sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords32[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords32[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords32[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords32[rank - 2]};`;
    }
    const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
    const inChannel = "." + channels[sourceRank - 1];
    const intChannels = channels.map((x2) => "int " + x2);
    const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
    const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
    const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
    const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
    const compOp = op2 === "max" ? "greaterThan" : "lessThan";
    const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
    const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
    const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords32[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords32[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
};
function argReduce(backend22, x2, reduceType, bestIndicesA = null) {
  let batchSize = x2.shape[0];
  let inSize = x2.shape[1];
  if (bestIndicesA != null) {
    batchSize = bestIndicesA.shape[0];
    inSize = bestIndicesA.shape[1];
  }
  const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
  const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
  const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
  const inputs = [x2];
  if (bestIndicesA != null) {
    inputs.push(bestIndicesA);
  }
  const output = backend22.runWebGLProgram(program, inputs, "int32");
  if (output.shape[1] === 1) {
    return output;
  }
  const result = argReduce(backend22, x2, reduceType, output);
  backend22.disposeIntermediateTensorInfo(output);
  return result;
}
function argReducePacked(backend22, x2, reduceType, bestIndicesA = null) {
  const inShape = bestIndicesA != null ? bestIndicesA.shape : x2.shape;
  const inSize = inShape[inShape.length - 1];
  const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
  const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
  const inputs = bestIndicesA == null ? [x2] : [x2, bestIndicesA];
  const output = backend22.runWebGLProgram(program, inputs, "int32");
  if (output.shape.length === x2.shape.length) {
    const result = argReducePacked(backend22, x2, reduceType, output);
    backend22.disposeIntermediateTensorInfo(output);
    return result;
  }
  return output;
}
function argMinMaxReduce(backend22, x2, axis, reduceType) {
  const axes = [axis];
  backend_util_exports.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x2.shape.length);
  if (!env().getBool("WEBGL_PACK_REDUCE") || x2.shape.length <= 2) {
    const intermediateTensorInfos = [];
    const xtexData = backend22.texData.get(x2.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    let xUnPacked = x2;
    if (xIsPacked) {
      xUnPacked = backend22.unpackTensor(x2);
      intermediateTensorInfos.push(xUnPacked);
    }
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xUnPacked.shape, axes);
    const inSize = util_exports.sizeFromShape(reduceShape);
    const a2D = reshape4({ inputs: { x: xUnPacked }, backend: backend22, attrs: { shape: [-1, inSize] } });
    intermediateTensorInfos.push(a2D);
    const reduced = argReduce(backend22, a2D, reduceType);
    intermediateTensorInfos.push(reduced);
    const reshaped = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: outShape } });
    intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
    return reshaped;
  }
  return argReducePacked(backend22, x2, reduceType);
}
function argMax3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
  const out = argMinMaxReduce(backend22, $x, axes[0], "max");
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return out;
}
var argMaxConfig2 = {
  kernelName: ArgMax,
  backendName: "webgl",
  kernelFunc: argMax3
};
function argMin3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
  const out = argMinMaxReduce(backend22, $x, axes[0], "min");
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return out;
}
var argMinConfig2 = {
  kernelName: ArgMin,
  backendName: "webgl",
  kernelFunc: argMin3
};
var ASIN = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
var asin3 = unaryKernelFunc2({ opSnippet: ASIN });
var asinConfig2 = {
  kernelName: Asin,
  backendName: "webgl",
  kernelFunc: asin3
};
var ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
var asinh3 = unaryKernelFunc2({ opSnippet: ASINH });
var asinhConfig2 = {
  kernelName: Asinh,
  backendName: "webgl",
  kernelFunc: asinh3
};
var ATAN = CHECK_NAN_SNIPPET + `
  return atan(x);
`;
var atan4 = unaryKernelFunc2({ opSnippet: ATAN });
var atanConfig2 = {
  kernelName: Atan,
  backendName: "webgl",
  kernelFunc: atan4
};
var ATAN2 = CHECK_NAN_SNIPPET_BINARY + `
  return atan(a, b);
`;
var ATAN2_PACKED = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET_BINARY_PACKED + `
  return result;
`;
var atan23 = binaryKernelFunc2({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
var atan2Config2 = {
  kernelName: Atan2,
  backendName: "webgl",
  kernelFunc: atan23
};
var ATANH = CHECK_NAN_SNIPPET + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
var atanh3 = unaryKernelFunc2({ opSnippet: ATANH });
var atanhConfig2 = {
  kernelName: Atanh,
  backendName: "webgl",
  kernelFunc: atanh3
};
var Pool2DProgram = class {
  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
    this.variableNames = ["x"];
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.outputShape = convInfo.outShape;
    const isAvgPool = poolType === "avg";
    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
    const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
    let initializationValue = "0.0";
    if (!isAvgPool) {
      initializationValue = "-1.0 / 1e-20";
    }
    if (computePositions) {
      const compareOp2 = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const compareOp = "max";
    let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    if (poolType === "avg") {
      returnValue = `avgValue / count`;
    }
    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
    const filterWidthVec4Remainder = filterWidth % 4;
    const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
  }
};
var Pool3DProgram = class {
  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
    this.variableNames = ["x"];
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.outputShape = convInfo.outShape;
    const isAvgPool = poolType === "avg";
    let initializationValue = "0.0";
    if (!isAvgPool) {
      initializationValue = "-1.0 / 1e-20";
    }
    if (computePositions) {
      const compareOp2 = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const compareOp = "max";
    let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    if (poolType === "avg") {
      returnValue = `avgValue / count`;
    }
    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
    const filterWidthVec4Remainder = filterWidth % 4;
    const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `;
  }
};
function avgPool3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  assertNotComplex2(x2, "avgPool");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity3({ inputs: { x: x2 }, backend: backend22 });
  }
  const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
  return backend22.runWebGLProgram(avgPoolProgram, [x2], "float32");
}
var avgPoolConfig2 = {
  kernelName: AvgPool,
  backendName: "webgl",
  kernelFunc: avgPool3
};
function avgPool3D2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
  const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
  return backend22.runWebGLProgram(avgPoolProgram, [x2], "float32");
}
var avgPool3DConfig2 = {
  kernelName: AvgPool3D,
  backendName: "webgl",
  kernelFunc: avgPool3D2
};
var AvgPool2DBackpropProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const avgMultiplier = 1 / (filterHeight * filterWidth);
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var AvgPool3DBackpropProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.outputShape = convInfo.inShape;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function avgPool3DGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const x2 = input2;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
  return backend22.runWebGLProgram(avgPoolBackpropProgram, [dy], x2.dtype);
}
var avgPoolGrad3DConfig = {
  kernelName: AvgPool3DGrad,
  backendName: "webgl",
  kernelFunc: avgPool3DGrad2
};
function avgPoolGrad3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const x2 = input2;
  assertNotComplex2([dy, input2], "avgPoolGrad");
  const { filterSize, strides, pad: pad3 } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3);
  const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
  return backend22.runWebGLProgram(avgPoolBackpropProgram, [dy], x2.dtype);
}
var avgPoolGradConfig3 = {
  kernelName: AvgPoolGrad,
  backendName: "webgl",
  kernelFunc: avgPoolGrad3
};
function batchMatMul2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2 } = inputs;
  const { transposeA, transposeB } = attrs;
  return batchMatMulImpl({ a: a6, b: b2, transposeA, transposeB, backend: backend22 });
}
var batchMatMulConfig2 = {
  kernelName: BatchMatMul,
  backendName: "webgl",
  kernelFunc: batchMatMul2
};
var BatchNormProgram = class {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
    this.outputShape = [];
    this.variableNames = ["x", "mean", "variance"];
    backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
    backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
    let offsetSnippet = "0.0";
    if (offsetShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
      offsetSnippet = "getOffsetAtOutCoords()";
    }
    let scaleSnippet = "1.0";
    if (scaleShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
      scaleSnippet = "getScaleAtOutCoords()";
    }
    this.outputShape = xShape;
    this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
};
var BatchNormPackedProgram = class {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
    this.packedInputs = true;
    this.packedOutput = true;
    this.variableNames = ["x", "mean", "variance"];
    backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
    backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
    let offsetSnippet = "vec4(0.0)";
    if (offsetShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
      offsetSnippet = "getOffsetAtOutCoords()";
    }
    let scaleSnippet = "vec4(1.0)";
    if (scaleShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
      scaleSnippet = "getScaleAtOutCoords()";
    }
    this.outputShape = xShape;
    this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
};
var batchNorm3 = ({ inputs, backend: backend22, attrs }) => {
  const { x: x2, mean: mean5, variance, offset, scale: scale22 } = inputs;
  util_exports.assert(mean5.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
  util_exports.assert(offset == null || mean5.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
  util_exports.assert(scale22 == null || mean5.shape.length === scale22.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let { varianceEpsilon } = attrs;
  if (varianceEpsilon == null) {
    varianceEpsilon = 1e-3;
  }
  const finalInputs = [x2, mean5, variance];
  let offsetShape = null;
  if (offset != null) {
    offsetShape = offset.shape;
    finalInputs.push(offset);
  }
  let scaleShape = null;
  if (scale22 != null) {
    scaleShape = scale22.shape;
    finalInputs.push(scale22);
  }
  const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x2.shape, mean5.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x2.shape, mean5.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
  const output = backend22.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
  return output;
};
var batchNormConfig2 = {
  kernelName: FusedBatchNorm,
  backendName: "webgl",
  kernelFunc: batchNorm3
};
var SliceProgram = class {
  constructor(destSize) {
    this.variableNames = ["source"];
    this.outputShape = destSize;
    this.rank = destSize.length;
    const dtype = getCoordsDataType(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const sourceCoords = getCoords(this.rank);
    let body4;
    const coordSum = destSize.map((_2, i2) => {
      return `sourceLoc.${coords[i2]} = start[${i2}] + coords.${coords[i2]};`;
    });
    body4 = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
    this.userCode = `
      void main() {
        ${body4}
        setOutput(getSource(${sourceCoords}));
      }
    `;
  }
};
var coords = ["x", "y", "z", "w", "u", "v"];
function getCoords(rank) {
  if (rank === 1) {
    return "sourceLoc";
  } else if (rank <= 6) {
    return coords.slice(0, rank).map((x2) => "sourceLoc." + x2).join(",");
  } else {
    throw Error(`Slicing for rank ${rank} is not yet supported`);
  }
}
var SlicePackedProgram = class {
  constructor(destSize) {
    this.variableNames = ["source"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = destSize;
    this.rank = destSize.length;
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const dtype = getCoordsDataType(this.rank);
    const coords32 = getChannels("coords", this.rank);
    const sourceLoc = getChannels("sourceLoc", this.rank);
    const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
    const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
    const upperRow = `
      result.x = ${getChannel};
      if (++${coords32[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
    const lowerRow = this.rank === 1 ? "" : `
      --${coords32[this.rank - 1]};
      if (++${coords32[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords32[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
    const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_2, i2) => `start[${i2}]`).join()});` : destSize.map((_2, i2) => `${sourceLoc[i2]} = ${coords32[i2]} + start[${i2}];`).join("\n");
    this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
  }
};
function shallowSlice(x2, begin, size2, backend22) {
  const xTexData = backend22.texData.get(x2.dataId);
  const t2 = backend22.makeTensorInfo(size2, x2.dtype);
  const newTexData = backend22.texData.get(t2.dataId);
  Object.assign(newTexData, xTexData);
  newTexData.refCount = 1;
  newTexData.shape = size2;
  newTexData.dtype = x2.dtype;
  let flatOffset = slice_util_exports.computeFlatOffset(begin, util_exports.computeStrides(x2.shape));
  if (xTexData.slice) {
    flatOffset += xTexData.slice.flatOffset;
  }
  newTexData.slice = {
    flatOffset,
    origDataId: xTexData.slice && xTexData.slice.origDataId || x2.dataId
  };
  const refCount = backend22.dataRefCount.get(newTexData.slice.origDataId) || 1;
  backend22.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
  return t2;
}
function slice3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, size: size2 } = attrs;
  const [$begin, $size] = slice_util_exports.parseSliceParams(x2, begin, size2);
  slice_util_exports.assertParamsValid(x2, $begin, $size);
  if (util_exports.sizeFromShape($size) === 0) {
    return backend22.makeTensorInfo($size, x2.dtype, []);
  }
  if (backend22.shouldExecuteOnCPU([x2]) || x2.dtype === "string") {
    const xTexData = backend22.texData.get(x2.dataId);
    const outValues = sliceImplCPU(xTexData.values, $begin, $size, x2.shape, x2.dtype);
    return backend22.makeTensorInfo($size, x2.dtype, outValues);
  }
  const { isPacked } = backend22.texData.get(x2.dataId);
  const isContinous = slice_util_exports.isSliceContinous(x2.shape, $begin, $size);
  if (isPacked || !isContinous) {
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
    const customValues = [$begin];
    return backend22.runWebGLProgram(program, [x2], x2.dtype, customValues);
  }
  backend22.uploadToGPU(x2.dataId);
  return shallowSlice(x2, $begin, $size, backend22);
}
var sliceConfig2 = {
  kernelName: Slice,
  backendName: "webgl",
  kernelFunc: slice3
};
var batchToSpaceND3 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, crops } = attrs;
  util_exports.assert(x2.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const reshaped = backend_util_exports.getReshaped(x2.shape, blockShape, prod6);
  const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = backend_util_exports.getReshapedPermuted(x2.shape, blockShape, prod6);
  const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const toDispose = [];
  const reshapedIntermediate = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: reshaped } });
  const transposedIntermediate = transpose3({ inputs: { x: reshapedIntermediate }, backend: backend22, attrs: { perm: permuted } });
  const reshapedIntermediate2 = reshape4({
    inputs: { x: transposedIntermediate },
    backend: backend22,
    attrs: { shape: reshapedPermuted }
  });
  const sliced = slice3({
    inputs: { x: reshapedIntermediate2 },
    backend: backend22,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  toDispose.push(reshapedIntermediate);
  toDispose.push(transposedIntermediate);
  toDispose.push(reshapedIntermediate2);
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return sliced;
};
var batchToSpaceNDConfig2 = {
  kernelName: BatchToSpaceND,
  backendName: "webgl",
  kernelFunc: batchToSpaceND3
};
function bincount3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, weights } = inputs;
  const { size: size2 } = attrs;
  const xVals = backend22.readSync(x2.dataId);
  const weightsVals = backend22.readSync(weights.dataId);
  const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size2);
  return backend22.makeTensorInfo([size2], weights.dtype, outVals);
}
var bincountConfig2 = {
  kernelName: Bincount,
  backendName: "webgl",
  kernelFunc: bincount3
};
var NOT_EQUAL = `return float(a != b);`;
var notEqual3 = binaryKernelFunc2({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
var notEqualConfig2 = {
  kernelName: NotEqual,
  backendName: "webgl",
  kernelFunc: notEqual3
};
function real3(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputData = backend22.texData.get(input2.dataId);
  return identity3({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend22 });
}
var realConfig2 = {
  kernelName: Real,
  backendName: "webgl",
  kernelFunc: real3
};
var TO_INT = `return float(int(x));`;
function int(input2, backend22) {
  const program = new UnaryOpProgram(input2.shape, TO_INT);
  const output = backend22.runWebGLProgram(program, [input2], "int32");
  return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
}
function cast4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x2.dtype === "complex64") {
      return identity3({ inputs: { x: x2 }, backend: backend22 });
    }
    const zerosTensor = zeros(x2.shape);
    const floatX = cast4({ inputs: { x: x2 }, backend: backend22, attrs: { dtype: "float32" } });
    const result = complex3({ inputs: { real: floatX, imag: zerosTensor }, backend: backend22 });
    zerosTensor.dispose();
    backend22.disposeIntermediateTensorInfo(floatX);
    return result;
  }
  if (x2.dtype === "complex64") {
    const realPart = real3({ inputs: { input: x2 }, backend: backend22 });
    const result = cast4({ inputs: { x: realPart }, backend: backend22, attrs: { dtype } });
    backend22.disposeIntermediateTensorInfo(realPart);
    return result;
  }
  if (!util_exports.hasEncodingLoss(x2.dtype, dtype)) {
    const result = identity3({ inputs: { x: x2 }, backend: backend22 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  if (dtype === "int32") {
    return int(x2, backend22);
  }
  if (dtype === "bool") {
    const zerosTensorInfo = backend22.makeTensorInfo([], "bool", util_exports.getTypedArrayFromDType("bool", 1));
    const binaryInputs = { a: x2, b: zerosTensorInfo };
    const result = notEqual3({ inputs: binaryInputs, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(zerosTensorInfo);
    return result;
  }
  throw new Error(`Error in Cast: failed to cast ${x2.dtype} to ${dtype}`);
}
var castConfig2 = {
  kernelName: Cast,
  backendName: "webgl",
  kernelFunc: cast4
};
var CEIL = `return ceil(x);`;
var ceil3 = unaryKernelFunc2({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
var ceilConfig2 = {
  kernelName: Ceil,
  backendName: "webgl",
  kernelFunc: ceil3
};
var ClipProgram = class {
  constructor(aShape) {
    this.variableNames = ["A"];
    this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ];
    this.outputShape = aShape;
    this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
};
var ClipPackedProgram = class {
  constructor(aShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ];
    this.outputShape = aShape;
    this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
};
function clipByValue2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { clipValueMin, clipValueMax } = attrs;
  let program;
  if (env().getBool("WEBGL_PACK_CLIP")) {
    program = new ClipPackedProgram(x2.shape);
  } else {
    program = new ClipProgram(x2.shape);
  }
  const customValues = [[clipValueMin], [clipValueMax]];
  return backend22.runWebGLProgram(program, [x2], x2.dtype, customValues);
}
var clipByValueConfig = {
  kernelName: ClipByValue,
  backendName: "webgl",
  kernelFunc: clipByValue2
};
var ComplexAbsProgram = class {
  constructor(shape) {
    this.variableNames = ["real", "imag"];
    this.outputShape = shape;
    this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
  }
};
function makeComplexComponentTensorInfo(complexTensor, complexPart) {
  return {
    dataId: complexPart.dataId,
    dtype: complexPart.dtype,
    shape: complexTensor.shape
  };
}
function complexAbs2(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  const xData = backend22.texData.get(x2.dataId);
  const program = new ComplexAbsProgram(x2.shape);
  const programInputs = [
    makeComplexComponentTensorInfo(x2, xData.complexTensorInfos.real),
    makeComplexComponentTensorInfo(x2, xData.complexTensorInfos.imag)
  ];
  return backend22.runWebGLProgram(program, programInputs, programInputs[0].dtype);
}
var complexAbsConfig2 = {
  kernelName: ComplexAbs,
  backendName: "webgl",
  kernelFunc: complexAbs2
};
var ConcatProgram = class {
  constructor(shapes) {
    this.outputShape = [];
    this.outputShape = backend_util_exports.computeOutShape(shapes, 1);
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    const offsets = new Array(shapes.length - 1);
    offsets[0] = shapes[0][1];
    for (let i2 = 1; i2 < offsets.length; i2++) {
      offsets[i2] = offsets[i2 - 1] + shapes[i2][1];
    }
    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
    for (let i2 = 1; i2 < offsets.length; i2++) {
      const shift = offsets[i2 - 1];
      snippets.push(`else if (yC < ${offsets[i2]}) setOutput(getT${i2}(yR, yC-${shift}));`);
    }
    const lastIndex = offsets.length;
    const lastShift = offsets[offsets.length - 1];
    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
  }
};
var ConcatPackedProgram = class {
  constructor(shapes, axis) {
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    this.outputShape = backend_util_exports.computeOutShape(shapes, axis);
    const shape = this.outputShape;
    const rank = shape.length;
    const dtype = getCoordsDataType(rank);
    const coords32 = getChannels("coords", rank);
    const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    const offsets = new Array(shapes.length - 1);
    offsets[0] = shapes[0][axis];
    for (let i2 = 1; i2 < offsets.length; i2++) {
      offsets[i2] = offsets[i2 - 1] + shapes[i2][axis];
    }
    const channel = channels[axis];
    const lastChannels = channels.slice(-2);
    const allChannels = channels.join();
    let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
    for (let i2 = 1; i2 < offsets.length; i2++) {
      const shift2 = offsets[i2 - 1];
      getValueSnippet += `
        if (${channel} < ${offsets[i2]}  && ${channel} >= ${offsets[i2 - 1]}) {
          return getChannel(
            getT${i2}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
    }
    const lastIndex = offsets.length;
    const shift = offsets[offsets.length - 1];
    getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
    this.userCode = `
      float getValue(${channels.map((x2) => "int " + x2)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords32}), 0., 0., 0.);

        ${coords32[rank - 1]} = ${coords32[rank - 1]} + 1;
        if (${coords32[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords32});
        }

        ${coords32[rank - 2]} = ${coords32[rank - 2]} + 1;
        if (${coords32[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords32});
        }

        ${coords32[rank - 1]} = ${coords32[rank - 1]} - 1;
        if (${coords32[rank - 2]} < ${shape[rank - 2]} &&
            ${coords32[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords32});
        }
        setOutput(result);
      }
    `;
  }
};
function shiftedChannels(channels, channel, shift) {
  const channelIdx = channels.indexOf(channel);
  const res2 = channels.map((c2, idx) => {
    if (idx === channelIdx) {
      return `${c2} - ${shift}`;
    } else {
      return c2;
    }
  });
  return res2.join();
}
function imag3(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputData = backend22.texData.get(input2.dataId);
  return identity3({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend22 });
}
var imagConfig2 = {
  kernelName: Imag,
  backendName: "webgl",
  kernelFunc: imag3
};
function concatImpl2(inputs, axis, backend22) {
  const dtype = inputs[0].dtype;
  if (dtype === "complex64") {
    const reals = inputs.map((t2) => real3({ inputs: { input: t2 }, backend: backend22 }));
    const imags = inputs.map((t2) => imag3({ inputs: { input: t2 }, backend: backend22 }));
    const realConcated = concatImpl2(reals, axis, backend22);
    const imagConcated = concatImpl2(imags, axis, backend22);
    const result2 = complex3({ inputs: { real: realConcated, imag: imagConcated }, backend: backend22 });
    reals.forEach((r2) => backend22.disposeIntermediateTensorInfo(r2));
    imags.forEach((i2) => backend22.disposeIntermediateTensorInfo(i2));
    backend22.disposeIntermediateTensorInfo(realConcated);
    backend22.disposeIntermediateTensorInfo(imagConcated);
    return result2;
  }
  let runOnCpu = backend22.shouldExecuteOnCPU(inputs);
  if (dtype === "string") {
    runOnCpu = true;
  }
  if (runOnCpu) {
    const tensors2D2 = inputs.map((t2) => {
      const innerSize = util_exports.sizeFromShape(t2.shape.slice(axis));
      const shape = [-1, innerSize];
      return reshape4({ inputs: { x: t2 }, backend: backend22, attrs: { shape } });
    });
    const inputsValShapes = tensors2D2.map((t2) => {
      return { vals: backend22.readSync(t2.dataId), shape: t2.shape };
    });
    const outShape2 = backend_util_exports.computeOutShape(tensors2D2.map((t2) => t2.shape), 1);
    const simplyConcat = tensors2D2[0].shape[0] === 1;
    const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
    const finalOutShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), axis);
    const outInfo = backend22.makeTensorInfo(finalOutShape, dtype, outVals);
    tensors2D2.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
    return outInfo;
  }
  if (inputs.length > env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const midIndex = Math.floor(inputs.length / 2);
    const leftSide = concatImpl2(inputs.slice(0, midIndex), axis, backend22);
    const rightSide = concatImpl2(inputs.slice(midIndex), axis, backend22);
    const result2 = concatImpl2([leftSide, rightSide], axis, backend22);
    backend22.disposeIntermediateTensorInfo(leftSide);
    backend22.disposeIntermediateTensorInfo(rightSide);
    return result2;
  }
  if (env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && inputs[0].shape.length > 1) {
    const program2 = new ConcatPackedProgram(inputs.map((t2) => t2.shape), axis);
    return backend22.runWebGLProgram(program2, inputs, dtype);
  }
  const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend22);
  const program = new ConcatProgram(tensors2D.map((t2) => t2.shape));
  const result = backend22.runWebGLProgram(program, tensors2D, dtype);
  tensors2D.forEach((r2) => backend22.disposeIntermediateTensorInfo(r2));
  const reshapedResult = reshape4({ inputs: { x: result }, attrs: { shape: outShape }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(result);
  return reshapedResult;
}
function computeTensors2D(inputs, axis, backend22) {
  const outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), axis);
  const tensors2D = inputs.map((x2) => reshape4({
    inputs: { x: x2 },
    attrs: { shape: [-1, util_exports.sizeFromShape(x2.shape.slice(axis))] },
    backend: backend22
  }));
  return { tensors2D, outShape };
}
function concat3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, inputs[0].shape)[0];
  const outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), $axis);
  if (util_exports.sizeFromShape(outShape) === 0) {
    return backend22.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t2) => util_exports.sizeFromShape(t2.shape) > 0);
  if ($inputs.length === 1) {
    return identity3({ inputs: { x: $inputs[0] }, backend: backend22 });
  }
  const shapes = $inputs.map((t2) => t2.shape);
  backend_util_exports.assertParamsConsistent(shapes, $axis);
  return concatImpl2($inputs, $axis, backend22);
}
var concatConfig2 = {
  kernelName: Concat,
  backendName: "webgl",
  kernelFunc: concat3
};
var Conv2DProgram = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
    const inputDepthVec4Remainder = convInfo.inChannels % 4;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const rowDim = isChannelsLast ? 1 : 2;
    const colDim = isChannelsLast ? 2 : 3;
    const channelDim = isChannelsLast ? 3 : 1;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivationWeights) {
        activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyreluAlpha) {
        activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyreluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
};
var Conv3DProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
    const inputDepthVec4Remainder = convInfo.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var Im2ColPackedProgram = class {
  constructor(outputShape, convInfo) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "inputShape", type: "ivec3" },
      { name: "pad", type: "ivec2" },
      { name: "stride", type: "ivec2" },
      { name: "dilation", type: "ivec2" },
      { name: "inChannels", type: "int" },
      { name: "itemsPerBlockRow", type: "int" },
      { name: "outWidth", type: "int" }
    ];
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const { dataFormat } = convInfo;
    const glsl = getGlslDifferences();
    const isChannelsLast = dataFormat === "channelsLast";
    const rowDim = isChannelsLast ? 0 : 1;
    const colDim = isChannelsLast ? 1 : 2;
    const boundsCheckingSnippet = this.enableShapeUniforms ? "if(blockIndex < outShape[1] && pos < outShape[0]) {" : `if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {`;
    let unrolled = ``;
    for (let row = 0; row <= 1; row++) {
      for (let col = 0; col <= 1; col++) {
        unrolled += `
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      }
    }
    this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
  }
};
function conv2dByMatMul({ x: x2, filter, convInfo, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const xShape = x2.shape;
  const xTexData = backend22.texData.get(x2.dataId);
  const sharedMatMulDim = convInfo.inChannels;
  const outerShapeX = xShape[0] * xShape[1] * xShape[2];
  const outerShapeFilter = convInfo.outChannels;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const transposeA = false;
  const transposeB = false;
  let out;
  const intermediates = [];
  const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
  const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && util_exports.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
  if (canOptimize) {
    const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
    const xReshaped = {
      dataId: x2.dataId,
      shape: [1, targetShape, convInfo.inChannels],
      dtype: x2.dtype
    };
    const originalXTexDataShape = xTexData.shape;
    xTexData.shape = xTexData.shape.slice();
    xTexData.shape[xTexData.shape.length - 2]++;
    util_exports.assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
    const filterReshaped = reshape4({
      inputs: { x: filter },
      backend: backend22,
      attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
    });
    intermediates.push(filterReshaped);
    const pointwiseConv = batchMatMulImpl({
      a: xReshaped,
      b: filterReshaped,
      backend: backend22,
      transposeA,
      transposeB,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
    const pointwiseConvTexData = backend22.texData.get(pointwiseConv.dataId);
    util_exports.assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
    xTexData.shape = originalXTexDataShape;
    pointwiseConvTexData.shape = convInfo.outShape;
    out = identity3({ inputs: { x: pointwiseConv }, backend: backend22 });
    out.shape = convInfo.outShape;
    intermediates.push(pointwiseConv);
  } else {
    const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
    const xReshaped = reshape4({
      inputs: { x: x2 },
      backend: backend22,
      attrs: { shape: [1, targetShape, convInfo.inChannels] }
    });
    const filterReshaped = reshape4({
      inputs: { x: filter },
      backend: backend22,
      attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
    });
    const result = batchMatMulImpl({
      a: xReshaped,
      b: filterReshaped,
      transposeA,
      transposeB,
      backend: backend22,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
    out = reshape4({ inputs: { x: result }, backend: backend22, attrs: { shape: convInfo.outShape } });
    intermediates.push(xReshaped);
    intermediates.push(filterReshaped);
    intermediates.push(result);
  }
  for (const i2 of intermediates) {
    backend22.disposeIntermediateTensorInfo(i2);
  }
  return out;
}
function conv2dWithIm2Row({ x: x2, filter, convInfo, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
  const isChannelsLast = dataFormat === "channelsLast";
  const sharedDim = filterWidth * filterHeight * inChannels;
  const numCols = outHeight * outWidth;
  const x2ColShape = [sharedDim, numCols];
  const transposeA = true;
  const transposeB = false;
  const intermediates = [];
  const xSqueezed = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: x2.shape.slice(1) } });
  const w2Row = reshape4({
    inputs: { x: filter },
    backend: backend22,
    attrs: { shape: [1, sharedDim, util_exports.sizeFromShape(filter.shape) / sharedDim] }
  });
  intermediates.push(xSqueezed);
  intermediates.push(w2Row);
  const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
  const customValues = [
    xSqueezed.shape,
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inChannels],
    [convInfo.filterWidth * convInfo.inChannels],
    [convInfo.outWidth]
  ];
  const im2Col = backend22.runWebGLProgram(im2ColProgram, [xSqueezed], "float32", customValues);
  const im2ColReshaped = reshape4({
    inputs: { x: im2Col },
    backend: backend22,
    attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
  });
  intermediates.push(im2Col);
  intermediates.push(im2ColReshaped);
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
  const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  const inputs = [im2ColReshaped, w2Row];
  if (bias) {
    inputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    inputs.push(preluActivationWeights);
  }
  if (hasLeakyreluAlpha) {
    const $leakyreluAlpha = backend22.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
    inputs.push($leakyreluAlpha);
    intermediates.push($leakyreluAlpha);
  }
  const product = backend22.runWebGLProgram(matmulProgram, inputs, "float32");
  const outShape = isChannelsLast ? [1, outHeight, outWidth, convInfo.outChannels] : [1, convInfo.outChannels, outHeight, outWidth];
  const out = reshape4({ inputs: { x: product }, backend: backend22, attrs: { shape: outShape } });
  intermediates.push(product);
  for (const i2 of intermediates) {
    backend22.disposeIntermediateTensorInfo(i2);
  }
  return out;
}
function conv2d4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  let out;
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    out = conv2dByMatMul({ x: x2, filter, convInfo, backend: backend22 });
  } else if (env().getBool("WEBGL_CONV_IM2COL") && x2.shape[0] === 1) {
    out = conv2dWithIm2Row({ x: x2, filter, convInfo, backend: backend22 });
  } else {
    const program = new Conv2DProgram(convInfo);
    out = backend22.runWebGLProgram(program, [x2, filter], "float32");
  }
  const outReshaped = reshape4({ inputs: { x: out }, backend: backend22, attrs: { shape: convInfo.outShape } });
  backend22.disposeIntermediateTensorInfo(out);
  return outReshaped;
}
var conv2DConfig2 = {
  kernelName: Conv2D,
  backendName: "webgl",
  kernelFunc: conv2d4
};
var Conv2DDerFilterProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var Conv2DDerInputProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    const rowDim = isChannelsLast ? 1 : 2;
    const colDim = isChannelsLast ? 2 : 3;
    const channelDim = isChannelsLast ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var Conv3DDerFilterProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var Conv3DDerInputProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padFront = filterDepth - 1 - convInfo.padInfo.front;
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function conv2DBackpropFilter3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filterShape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
  const program = new Conv2DDerFilterProgram(convInfo);
  return backend22.runWebGLProgram(program, [x2, dy], "float32");
}
var conv2DBackpropFilterConfig2 = {
  kernelName: Conv2DBackpropFilter,
  backendName: "webgl",
  kernelFunc: conv2DBackpropFilter3
};
function conv2DBackpropInput3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { inputShape, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
  const program = new Conv2DDerInputProgram(convInfo);
  return backend22.runWebGLProgram(program, [dy, filter], "float32");
}
var conv2DBackpropInputConfig2 = {
  kernelName: Conv2DBackpropInput,
  backendName: "webgl",
  kernelFunc: conv2DBackpropInput3
};
function conv3D2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations } = attrs;
  const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filter.shape, strides, dilations, pad3);
  const program = new Conv3DProgram(convInfo);
  return backend22.runWebGLProgram(program, [x2, filter], "float32");
}
var conv3DConfig2 = {
  kernelName: Conv3D,
  backendName: "webgl",
  kernelFunc: conv3D2
};
function conv3DBackpropFilterV22(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, pad: pad3, filterShape } = attrs;
  const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filterShape, strides, 1, pad3);
  const program = new Conv3DDerFilterProgram(convInfo);
  return backend22.runWebGLProgram(program, [x2, dy], "float32");
}
var conv3DBackpropFilterV2Config2 = {
  kernelName: Conv3DBackpropFilterV2,
  backendName: "webgl",
  kernelFunc: conv3DBackpropFilterV22
};
function conv3DBackpropInput2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { pad: pad3, strides, inputShape } = attrs;
  const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad3);
  const program = new Conv3DDerInputProgram(convInfo);
  return backend22.runWebGLProgram(program, [dy, filter], "float32");
}
var conv3DBackpropInputConfig = {
  kernelName: Conv3DBackpropInputV2,
  backendName: "webgl",
  kernelFunc: conv3DBackpropInput2
};
var COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
var cos3 = unaryKernelFunc2({ opSnippet: COS });
var cosConfig2 = {
  kernelName: Cos,
  backendName: "webgl",
  kernelFunc: cos3
};
var COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
var cosh3 = unaryKernelFunc2({ opSnippet: COSH });
var coshConfig2 = {
  kernelName: Cosh,
  backendName: "webgl",
  kernelFunc: cosh3
};
var CropAndResizeProgram = class {
  constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
    this.variableNames = ["Image", "Boxes", "BoxInd"];
    this.outputShape = [];
    const [batch, imageHeight, imageWidth, depth] = imageShape;
    const [numBoxes] = boxShape;
    const [cropHeight, cropWidth] = cropSize;
    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
    const methodId = method === "bilinear" ? 1 : 0;
    const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
    const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
      `${(imageHeight - 1) / (cropHeight - 1)}`,
      "(y2-y1) * height_ratio",
      `y1*${inputHeightFloat} + float(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${inputHeightFloat}`
    ];
    const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
      `${(imageWidth - 1) / (cropWidth - 1)}`,
      "(x2-x1) * width_ratio",
      `x1*${inputWidthFloat} + float(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${inputWidthFloat}`
    ];
    this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
};
var cropAndResize3 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const program = new CropAndResizeProgram(image32.shape, boxes.shape, cropSize, method, extrapolationValue);
  return backend22.runWebGLProgram(program, [image32, boxes, boxInd], "float32");
};
var cropAndResizeConfig2 = {
  kernelName: CropAndResize,
  backendName: "webgl",
  kernelFunc: cropAndResize3
};
var CumSumProgram = class {
  constructor(shape, exclusive, reverse5) {
    this.variableNames = ["x"];
    this.customUniforms = [{ name: "index", type: "float" }];
    this.outputShape = shape;
    const rank = shape.length;
    const val = exclusive ? "0.0" : `getX(${getCoords2(rank, "coords")})`;
    const length = shape[shape.length - 1];
    let condition = "";
    let idxString = "";
    if (exclusive) {
      condition = reverse5 ? `end != ${length - 1}` : "end != 0";
      idxString = reverse5 ? "end + 1" : "end - 1";
    } else {
      condition = reverse5 ? `end + pow2 < ${length}` : "end >= pow2";
      idxString = reverse5 ? "end + pow2" : "end - pow2";
    }
    this.userCode = `
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords")};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords")} = idx;
          val += getX(${getCoords2(rank, "coords")});
        }
        setOutput(val);
      }
    `;
  }
};
function getCoords2(rank, name) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.x, ${name}.y`;
  } else if (rank === 3) {
    return `${name}.x, ${name}.y, ${name}.z`;
  } else if (rank === 4) {
    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
  } else {
    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
  }
}
function getFinalCoord(rank, name) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.y`;
  } else if (rank === 3) {
    return `${name}.z`;
  } else if (rank === 4) {
    return `${name}.w`;
  } else {
    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
  }
}
function cumsum3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, exclusive, reverse: reverse5 } = attrs;
  const xRank = x2.shape.length;
  const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
  let permutedX = x2;
  if (permutation != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutation } });
  }
  const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
  if (permutedAxis !== xRank - 1) {
    throw new Error(`WebGL cumsum shader expects an inner-most axis=${x2.shape.length - 1} but got axis=${axis}`);
  }
  const size2 = permutedX.shape[permutedAxis];
  let result = identity3({ inputs: { x: permutedX }, backend: backend22 });
  for (let i2 = 0; i2 <= Math.ceil(Math.log2(size2)) - 1; i2++) {
    const program = new CumSumProgram(permutedX.shape, false, reverse5);
    const customValues = [[i2]];
    const prevResult = result;
    result = backend22.runWebGLProgram(program, [result], result.dtype, customValues);
    backend22.disposeIntermediateTensorInfo(prevResult);
  }
  if (exclusive) {
    const program = new CumSumProgram(permutedX.shape, exclusive, reverse5);
    const prevResult = result;
    result = backend22.runWebGLProgram(program, [result], result.dtype);
    backend22.disposeIntermediateTensorInfo(prevResult);
  }
  if (permutation != null) {
    const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose3({ inputs: { x: result }, backend: backend22, attrs: { perm: reversePermutation } });
    backend22.disposeIntermediateTensorInfo(result);
    backend22.disposeIntermediateTensorInfo(permutedX);
    return reverseTransposedResult;
  }
  return result;
}
var cumsumConfig2 = {
  kernelName: Cumsum,
  backendName: "webgl",
  kernelFunc: cumsum3
};
function denseBincount3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, weights } = inputs;
  const { size: size2, binaryOutput } = attrs;
  if (x2.shape.length === 1) {
    const xVals = backend22.readSync(x2.dataId);
    const weightsVals = backend22.readSync(weights.dataId);
    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size2);
    return backend22.makeTensorInfo([size2], weights.dtype, outVals);
  } else if (x2.shape.length === 2) {
    const xBuf = backend22.bufferSync(x2);
    const weightsBuf = backend22.bufferSync(weights);
    const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size2, binaryOutput);
    return backend22.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x2.shape.length}.`);
}
var denseBincountConfig2 = {
  kernelName: DenseBincount,
  backendName: "webgl",
  kernelFunc: denseBincount3
};
var DepthToSpaceProgram = class {
  constructor(outputShape, blockSize, dataFormat) {
    this.variableNames = ["x"];
    this.outputShape = [];
    this.outputShape = outputShape;
    this.blockSize = blockSize;
    this.dataFormat = dataFormat;
    this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[1]`;
    } else {
      return `coords[2]`;
    }
  }
  getWidthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[2]`;
    } else {
      return `coords[3]`;
    }
  }
  getDepthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[3]`;
    } else {
      return `coords[1]`;
    }
  }
  getOutputDepthSize() {
    if (this.dataFormat === "NHWC") {
      return this.outputShape[3];
    } else {
      return this.outputShape[1];
    }
  }
  getInputSamplingString() {
    if (this.dataFormat === "NHWC") {
      return `getX(b, in_h, in_w, in_d)`;
    } else {
      return `getX(b, in_d, in_h, in_w)`;
    }
  }
};
function depthToSpace3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockSize, dataFormat } = attrs;
  util_exports.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  const batchSize = x2.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x2.shape[1] : x2.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x2.shape[2] : x2.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x2.shape[3] : x2.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
var depthToSpaceConfig2 = {
  kernelName: DepthToSpace,
  backendName: "webgl",
  kernelFunc: depthToSpace3
};
var DepthwiseConv2DProgram = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ];
    this.outputShape = convInfo.outShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyReluAlpha) {
        activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyReluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
};
var DepthwiseConvPacked2DProgram = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ];
    this.outputShape = convInfo.outShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    const padLeft = convInfo.padInfo.left;
    const strideWidth = convInfo.strideWidth;
    const dilationWidth = convInfo.dilationWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const texelsAcross = filterWidth;
    let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
    for (let c2 = 0; c2 < filterWidth; c2++) {
      mainLoop += `
          vec4 xTexelC${c2 * 2};
          int xTexelC${c2 * 2}Ready;
          vec4 xTexelC${c2 * 2 + 1};
          int xTexelC${c2 * 2 + 1}Ready;
          vec4 xC${c2};`;
    }
    for (let r2 = 0; r2 < filterHeight; r2++) {
      for (let c2 = 0; c2 < filterWidth; c2++) {
        mainLoop += `
          xTexelC${c2 * 2} = vec4(0.0);
          xTexelC${c2 * 2}Ready = 0;
          xTexelC${c2 * 2 + 1} = vec4(0.0);
          xTexelC${c2 * 2 + 1}Ready = 0;
          xC${c2} = vec4(0.0);`;
      }
      mainLoop += `
        xR = xRCorner + ${r2} * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
              } else {
                mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
              }
            } else {
              mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? util_exports.nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
                if (dilationWidth > 1) {
                  mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                      xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                      xTexelC${colIndex}Ready = 1;
                    }
                    `;
                }
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                  `;
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
                } else {
                  mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
              }
            } else {
              mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
            wTexel = getW(${r2}, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
              wTexel = getW(${r2}, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
          }
        }
      }
      mainLoop += `
        }
      `;
    }
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyReluAlpha) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyReluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
};
function depthwiseConv2dNative2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations, dimRoundingMode } = attrs;
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  let program;
  if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
    program = new DepthwiseConvPacked2DProgram(convInfo);
  } else {
    program = new DepthwiseConv2DProgram(convInfo);
  }
  const customValues = [
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inHeight, convInfo.inWidth]
  ];
  return backend22.runWebGLProgram(program, [x2, filter], "float32", customValues);
}
var depthwiseConv2dNativeConfig2 = {
  kernelName: DepthwiseConv2dNative,
  backendName: "webgl",
  kernelFunc: depthwiseConv2dNative2
};
var DepthwiseConv2DDerFilterProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var DepthwiseConv2DDerInputProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function depthwiseConv2dNativeBackpropFilter3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, dy } = inputs;
  const { strides, dilations, pad: pad3, dimRoundingMode, filterShape } = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerFilterProgram(convInfo);
  return backend22.runWebGLProgram(program, [x2, dy], "float32");
}
var depthwiseConv2dNativeBackpropFilterConfig2 = {
  kernelName: DepthwiseConv2dNativeBackpropFilter,
  backendName: "webgl",
  kernelFunc: depthwiseConv2dNativeBackpropFilter3
};
function depthwiseConv2dNativeBackpropInput3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { strides, dilations, pad: pad3, dimRoundingMode, inputShape } = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad3, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerInputProgram(convInfo);
  return backend22.runWebGLProgram(program, [dy, filter], "float32");
}
var depthwiseConv2dNativeBackpropInputConfig2 = {
  kernelName: DepthwiseConv2dNativeBackpropInput,
  backendName: "webgl",
  kernelFunc: depthwiseConv2dNativeBackpropInput3
};
var DiagProgram = class {
  constructor(size2) {
    this.variableNames = ["X"];
    this.outputShape = [size2, size2];
    this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
  }
};
function diag3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  const outShape = [...x2.shape, ...x2.shape];
  const xSize = util_exports.sizeFromShape(x2.shape);
  const flat = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: [xSize] } });
  const program = new DiagProgram(xSize);
  const res2 = backend22.runWebGLProgram(program, [flat], flat.dtype);
  const out = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeIntermediateTensorInfo(flat);
  backend22.disposeIntermediateTensorInfo(res2);
  return out;
}
var diagConfig2 = {
  kernelName: Diag,
  backendName: "webgl",
  kernelFunc: diag3
};
var Dilation2DProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
    const { top: padTop, left: padLeft } = padInfo;
    this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
};
function dilation2D(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations } = attrs;
  const convInfo = backend_util_exports.computeDilation2DInfo(x2.shape, filter.shape, strides, pad3, "NHWC", dilations);
  let out;
  const program = new Dilation2DProgram(convInfo);
  out = backend22.runWebGLProgram(program, [x2, filter], "float32");
  const outReshaped = reshape4({ inputs: { x: out }, backend: backend22, attrs: { shape: convInfo.outShape } });
  backend22.disposeIntermediateTensorInfo(out);
  return outReshaped;
}
var dilation2DConfig = {
  kernelName: Dilation2D,
  backendName: "webgl",
  kernelFunc: dilation2D
};
function einsum3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
  backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i2 = 0; i2 < nSteps; ++i2) {
    for (const idTerm of steps[i2]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x2;
      if (backend_util_exports.isIdentityPermutation(perm)) {
        x2 = tensors[idTerm];
      } else {
        x2 = transpose3({ inputs: { x: tensors[idTerm] }, backend: backend22, attrs: { perm } });
        tensorsToDispose.push(x2);
      }
      const targetShape = x2.shape.slice();
      for (let k3 = 0; k3 < dimsToExpand.length; ++k3) {
        targetShape.splice(dimsToExpand[k3], 0, 1);
      }
      if (!util_exports.arraysEqual(x2.shape, targetShape)) {
        x2 = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: targetShape } });
        tensorsToDispose.push(x2);
      }
      if (out === null) {
        out = x2;
      } else {
        out = multiply3({ inputs: { a: x2, b: out }, backend: backend22 });
        tensorsToDispose.push(out);
      }
    }
    if (i2 < nSteps - 1) {
      if (path[i2] >= 0) {
        out = sum4({
          inputs: { x: out },
          backend: backend22,
          attrs: {
            axis: path[i2] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend22.disposeIntermediateTensorInfo(tensorInfo);
  }
  return out;
}
var einsumConfig2 = {
  kernelName: Einsum,
  backendName: "webgl",
  kernelFunc: einsum3
};
var ELU4 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
var ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
var elu5 = unaryKernelFunc2({ opSnippet: ELU4, packedOpSnippet: ELU_PACKED });
var eluConfig2 = {
  kernelName: Elu,
  backendName: "webgl",
  kernelFunc: elu5
};
var ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
var ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
var eluGrad2 = (args) => {
  const { inputs, backend: backend22 } = args;
  const { dy, y: y2 } = inputs;
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y2.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y2.shape);
  return backend22.runWebGLProgram(program, [dy, y2], dy.dtype);
};
var eluGradConfig3 = {
  kernelName: EluGrad,
  backendName: "webgl",
  kernelFunc: eluGrad2
};
var PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
var EQUAL = `return float(a == b);`;
var equal3 = binaryKernelFunc2({
  opSnippet: EQUAL,
  packedOpSnippet: PACKED_EQUAL,
  dtype: "bool",
  cpuKernelImpl: equalImplCPU
});
var equalConfig2 = {
  kernelName: Equal,
  backendName: "webgl",
  kernelFunc: equal3
};
var ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${backend_util_exports.ERF_P};
  float a1 = ${backend_util_exports.ERF_A1};
  float a2 = ${backend_util_exports.ERF_A2};
  float a3 = ${backend_util_exports.ERF_A3};
  float a4 = ${backend_util_exports.ERF_A4};
  float a5 = ${backend_util_exports.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
var erf3 = unaryKernelFunc2({ opSnippet: ERF });
var erfConfig2 = {
  kernelName: Erf,
  backendName: "webgl",
  kernelFunc: erf3
};
var EXP = `return exp(x);`;
var exp3 = unaryKernelFunc2({ opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: expImplCPU });
var expConfig2 = {
  kernelName: Exp,
  backendName: "webgl",
  kernelFunc: exp3
};
function expandDims4(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { dim } = attrs;
  const { input: input2 } = inputs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape4({ inputs: { x: input2 }, backend: backend22, attrs: { shape: newShape } });
}
var expandDimsConfig2 = {
  kernelName: ExpandDims,
  backendName: "webgl",
  kernelFunc: expandDims4
};
var EXPM1 = `return exp(x) - 1.0;`;
var expm13 = unaryKernelFunc2({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
var expm1Config2 = {
  kernelName: Expm1,
  backendName: "webgl",
  kernelFunc: expm13
};
var FFTProgram = class {
  constructor(component, inputShape, inverse) {
    this.variableNames = ["real", "imag"];
    const innerDim = inputShape[1];
    this.outputShape = inputShape;
    const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
    const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
    let opString;
    if (component === "real") {
      opString = "return real * expR - imag * expI;";
    } else if (component === "imag") {
      opString = "return real * expI + imag * expR;";
    } else {
      throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
    }
    this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
};
function fftImpl2(x2, inverse, backend22) {
  const xData = backend22.texData.get(x2.dataId);
  const inputSize8 = util_exports.sizeFromShape(x2.shape);
  const innerDimensionSize = x2.shape[x2.shape.length - 1];
  const batch = inputSize8 / innerDimensionSize;
  const input2D = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: [batch, innerDimensionSize] } });
  const xShape = input2D.shape;
  const realProgram = new FFTProgram("real", xShape, inverse);
  const imagProgram = new FFTProgram("imag", xShape, inverse);
  const inputs = [
    {
      dataId: xData.complexTensorInfos.real.dataId,
      dtype: xData.complexTensorInfos.real.dtype,
      shape: xShape
    },
    {
      dataId: xData.complexTensorInfos.imag.dataId,
      dtype: xData.complexTensorInfos.imag.dtype,
      shape: xShape
    }
  ];
  const realPart = backend22.runWebGLProgram(realProgram, inputs, "float32");
  const imagPart = backend22.runWebGLProgram(imagProgram, inputs, "float32");
  const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(realPart);
  backend22.disposeIntermediateTensorInfo(imagPart);
  const complexOutputReshaped = reshape4({ inputs: { x: complexOutput }, backend: backend22, attrs: { shape: x2.shape } });
  backend22.disposeIntermediateTensorInfo(input2D);
  backend22.disposeIntermediateTensorInfo(complexOutput);
  return complexOutputReshaped;
}
function fft3(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  return fftImpl2(input2, false, backend22);
}
var fftConfig2 = {
  kernelName: FFT,
  backendName: "webgl",
  kernelFunc: fft3
};
var FillProgram = class {
  constructor(shape, value) {
    this.outputShape = [];
    this.customUniforms = [{ name: "value", type: "float" }];
    this.variableNames = ["x"];
    this.outputShape = shape;
    this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
};
function fill3(args) {
  const { backend: backend22, attrs } = args;
  const { shape, value } = attrs;
  let { dtype } = attrs;
  dtype = dtype || util_exports.inferDtype(value);
  if (dtype === "string") {
    const values = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(shape));
    values.fill(value);
    return backend22.makeTensorInfo(shape, dtype, values);
  } else {
    const program = new FillProgram(shape, value);
    const customValues = [[value]];
    return backend22.runWebGLProgram(program, [], dtype, customValues);
  }
}
var fillConfig2 = {
  kernelName: Fill,
  backendName: "webgl",
  kernelFunc: fill3
};
var FlipLeftRightProgram = class {
  constructor(imageShape) {
    this.variableNames = ["Image"];
    this.outputShape = [];
    const imageWidth = imageShape[2];
    this.outputShape = imageShape;
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var flipLeftRightConfig2 = {
  kernelName: FlipLeftRight,
  backendName: "webgl",
  kernelFunc: ({ inputs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const webglBackend = backend22;
    const program = new FlipLeftRightProgram(image32.shape);
    const output = webglBackend.runWebGLProgram(program, [image32], image32.dtype);
    return output;
  }
};
var FLOOR = `return floor(x);`;
var floor3 = unaryKernelFunc2({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
var floorConfig2 = {
  kernelName: Floor,
  backendName: "webgl",
  kernelFunc: floor3
};
var INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
var INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
var floorDiv3 = binaryKernelFunc2({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
var floorDivConfig2 = {
  kernelName: FloorDiv,
  backendName: "webgl",
  kernelFunc: floorDiv3
};
var FromPixelsProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    const glsl = getGlslDifferences();
    const [height, width] = outputShape;
    this.outputShape = outputShape;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
};
var FromPixelsPackedProgram = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    const glsl = getGlslDifferences();
    const [height, width] = outputShape;
    this.outputShape = outputShape;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
  }
};
var fromPixelsConfig = {
  kernelName: FromPixels,
  backendName: "webgl",
  kernelFunc: fromPixels2
};
var fromPixels2DContext2;
function fromPixels2(args) {
  const { inputs, backend: backend22, attrs } = args;
  let { pixels } = inputs;
  const { numChannels } = attrs;
  const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
  const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  const texShape = [height, width];
  const outShape = [height, width, numChannels];
  if (isImage || isVideo) {
    if (fromPixels2DContext2 == null) {
      fromPixels2DContext2 = document.createElement("canvas").getContext("2d");
    }
    fromPixels2DContext2.canvas.width = width;
    fromPixels2DContext2.canvas.height = height;
    fromPixels2DContext2.drawImage(pixels, 0, 0, width, height);
    pixels = fromPixels2DContext2.canvas;
  }
  const tempPixelHandle = backend22.makeTensorInfo(texShape, "int32");
  backend22.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
  backend22.gpgpu.uploadPixelDataToTexture(backend22.getTexture(tempPixelHandle.dataId), pixels);
  const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
  const res2 = backend22.runWebGLProgram(program, [tempPixelHandle], "int32");
  backend22.disposeData(tempPixelHandle.dataId);
  return res2;
}
function fusedConv2d(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  let out;
  const intermediates = [];
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    out = conv2dByMatMul({
      x: x2,
      filter,
      convInfo,
      backend: backend22,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  } else if (env().getBool("WEBGL_CONV_IM2COL") && x2.shape[0] === 1) {
    out = conv2dWithIm2Row({
      x: x2,
      filter,
      convInfo,
      backend: backend22,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  } else {
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation2 === "leakyrelu";
    const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, false) : null;
    const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs2 = [x2, filter];
    if (bias) {
      inputs2.push(bias);
    }
    if (preluActivationWeights) {
      inputs2.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend22.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
      inputs2.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    out = backend22.runWebGLProgram(program, inputs2, "float32");
  }
  const outReshaped = reshape4({ inputs: { x: out }, backend: backend22, attrs: { shape: convInfo.outShape } });
  intermediates.push(out);
  intermediates.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return outReshaped;
}
var fusedConv2DConfig2 = {
  kernelName: FusedConv2D,
  backendName: "webgl",
  kernelFunc: fusedConv2d
};
function fusedDepthwiseConv2D2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const intermediates = [];
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
  const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, shouldPackDepthwiseConv) : null;
  const programInputs = [x2, filter];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  if (hasBias) {
    programInputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    programInputs.push(preluActivationWeights);
  }
  if (hasLeakyreluAlpha) {
    const $leakyreluAlpha = backend22.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
    programInputs.push($leakyreluAlpha);
    intermediates.push($leakyreluAlpha);
  }
  let program;
  if (shouldPackDepthwiseConv) {
    program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  } else {
    program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  }
  const customValues = [
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inHeight, convInfo.inWidth]
  ];
  const result = backend22.runWebGLProgram(program, programInputs, "float32", customValues);
  intermediates.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var fusedDepthwiseConv2DConfig2 = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "webgl",
  kernelFunc: fusedDepthwiseConv2D2
};
var GatherNDProgram = class {
  constructor(sliceDim, strides, shape) {
    this.sliceDim = sliceDim;
    this.strides = strides;
    this.variableNames = ["x", "indices"];
    this.outputShape = shape;
    const stridesType = getCoordsDataType(strides.length);
    const dtype = getCoordsDataType(shape.length);
    const strideString = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
  }
};
function gatherNd2(args) {
  const { inputs, backend: backend22 } = args;
  const { params, indices } = inputs;
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const paramsSize = util_exports.sizeFromShape(params.shape);
  const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
  const flattenIndices = reshape4({ inputs: { x: indices }, backend: backend22, attrs: { shape: [numSlices, sliceRank] } });
  const flattenX = reshape4({
    inputs: { x: params },
    backend: backend22,
    attrs: { shape: [util_exports.sizeFromShape(params.shape) / sliceSize, sliceSize] }
  });
  if (backend22.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
    const indicesData = backend22.readSync(indices.dataId);
    const paramsBuf = backend22.bufferSync(params);
    const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend22.makeTensorInfo(resultShape, params.dtype, outValue.values);
  }
  const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
  const res2 = backend22.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
  const reshaped = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape: resultShape } });
  backend22.disposeIntermediateTensorInfo(flattenIndices);
  backend22.disposeIntermediateTensorInfo(flattenX);
  backend22.disposeIntermediateTensorInfo(res2);
  return reshaped;
}
var gatherNdConfig2 = {
  kernelName: GatherNd,
  backendName: "webgl",
  kernelFunc: gatherNd2
};
var GatherProgram = class {
  constructor(aShape, outputShape) {
    this.variableNames = ["A", "indices"];
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const sourceCoords = getSourceCoords2(aShape, 2);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
  }
};
function getSourceCoords2(aShape, axis) {
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i2 = 0; i2 < aShape.length; i2++) {
    if (i2 === 2) {
      sourceCoords.push("int(getIndices(resRC.x, resRC.z))");
    } else {
      sourceCoords.push(`${currentCoords[i2]}`);
    }
  }
  return sourceCoords.join();
}
function gatherV22(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, indices } = inputs;
  const { axis, batchDims } = attrs;
  const parsedAxis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x2, indices, parsedAxis, batchDims);
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const toDispose = [];
  const flattenX = reshape4({
    inputs: { x: x2 },
    backend: backend22,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape4({
    inputs: { x: indices },
    backend: backend22,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  toDispose.push(flattenX);
  toDispose.push(flattenIndex);
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  if (backend22.shouldExecuteOnCPU([x2, indices]) || x2.dtype === "string") {
    const indicesBuf = backend22.bufferSync(flattenIndex);
    const xBuf = backend22.bufferSync(flattenX);
    const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
    toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
    return backend22.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
  }
  const program = new GatherProgram(flattenX.shape, flattenOutputShape);
  const res2 = backend22.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
  toDispose.push(res2);
  const reshaped = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape: shapeInfo.outputShape } });
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return reshaped;
}
var gatherV2Config2 = {
  kernelName: GatherV2,
  backendName: "webgl",
  kernelFunc: gatherV22
};
var GREATER = `return float(a > b);`;
var GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
var greater4 = binaryKernelFunc2({
  opSnippet: GREATER,
  packedOpSnippet: GREATER_PACKED,
  cpuKernelImpl: greaterImplCPU,
  dtype: "bool"
});
var greaterConfig2 = {
  kernelName: Greater,
  backendName: "webgl",
  kernelFunc: greater4
};
var GREATER_EQUAL = `return float(a >= b);`;
var GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
var greaterEqual3 = binaryKernelFunc2({
  opSnippet: GREATER_EQUAL,
  packedOpSnippet: GREATER_EQUAL_PACKED,
  dtype: "bool",
  cpuKernelImpl: greaterEqualImplCPU
});
var greaterEqualConfig2 = {
  kernelName: GreaterEqual,
  backendName: "webgl",
  kernelFunc: greaterEqual3
};
function ifft3(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  return fftImpl2(input2, true, backend22);
}
var ifftConfig2 = {
  kernelName: IFFT,
  backendName: "webgl",
  kernelFunc: ifft3
};
var IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
var isFinite4 = unaryKernelFunc2({ opSnippet: IS_FINITE, dtype: "bool" });
var isFiniteConfig2 = {
  kernelName: IsFinite,
  backendName: "webgl",
  kernelFunc: isFinite4
};
var IS_INF = `return float(isinf(x));`;
var isInf3 = unaryKernelFunc2({ opSnippet: IS_INF, dtype: "bool" });
var isInfConfig2 = {
  kernelName: IsInf,
  backendName: "webgl",
  kernelFunc: isInf3
};
var IS_NAN = `return float(isnan(x));`;
var isNaN4 = unaryKernelFunc2({ opSnippet: IS_NAN, dtype: "bool" });
var isNaNConfig2 = {
  kernelName: IsNan,
  backendName: "webgl",
  kernelFunc: isNaN4
};
var LESS = `return float(a < b);`;
var LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
var less4 = binaryKernelFunc2({
  opSnippet: LESS,
  packedOpSnippet: LESS_PACKED,
  cpuKernelImpl: lessImplCPU,
  dtype: "bool"
});
var lessConfig2 = {
  kernelName: Less,
  backendName: "webgl",
  kernelFunc: less4
};
var LESS_EQUAL = `return float(a <= b);`;
var LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`;
var lessEqual3 = binaryKernelFunc2({
  opSnippet: LESS_EQUAL,
  packedOpSnippet: LESS_EQUAL_PACKED,
  cpuKernelImpl: lessEqualImplCPU,
  dtype: "bool"
});
var lessEqualConfig2 = {
  kernelName: LessEqual,
  backendName: "webgl",
  kernelFunc: lessEqual3
};
function linSpace2(args) {
  const { backend: backend22, attrs } = args;
  const { start, stop, num } = attrs;
  const outVals = linSpaceImplCPU(start, stop, num);
  return backend22.makeTensorInfo([outVals.length], "float32", outVals);
}
var linSpaceConfig2 = {
  kernelName: LinSpace,
  backendName: "webgl",
  kernelFunc: linSpace2
};
var LOG = `if (x < 0.0) return NAN;
  return log(x);`;
var LOG_PACKED = `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`;
var log7 = unaryKernelFunc2({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
var logConfig2 = {
  kernelName: Log,
  backendName: "webgl",
  kernelFunc: log7
};
var LOG1P = `return log(1.0 + x);`;
var log1p3 = unaryKernelFunc2({ opSnippet: LOG1P });
var log1pConfig2 = {
  kernelName: Log1p,
  backendName: "webgl",
  kernelFunc: log1p3
};
var LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
var LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
var logicalAnd3 = binaryKernelFunc2({
  opSnippet: LOGICAL_AND,
  packedOpSnippet: LOGICAL_AND_PACKED,
  dtype: "bool"
});
var logicalAndConfig2 = {
  kernelName: LogicalAnd,
  backendName: "webgl",
  kernelFunc: logicalAnd3
};
var LOGICAL_NOT = `return float(!(x >= 1.0));`;
var logicalNot3 = unaryKernelFunc2({ opSnippet: LOGICAL_NOT });
var logicalNotConfig2 = {
  kernelName: LogicalNot,
  backendName: "webgl",
  kernelFunc: logicalNot3
};
var LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
var LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
var logicalOr3 = binaryKernelFunc2({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
var logicalOrConfig2 = {
  kernelName: LogicalOr,
  backendName: "webgl",
  kernelFunc: logicalOr3
};
var LRNProgram = class {
  constructor(xShape, radius, bias, alpha, beta) {
    this.variableNames = ["x"];
    this.outputShape = [];
    const rad = radius;
    const maxD = xShape[3] - 1;
    this.outputShape = xShape;
    let powOperator;
    const basis = `float(${bias}) + float(${alpha}) * sum`;
    if (beta === 0.5) {
      powOperator = `inversesqrt(${basis})`;
    } else if (beta === 1) {
      powOperator = `1.0/(${basis})`;
    } else {
      powOperator = `exp(log(${basis}) * float(-${beta}));`;
    }
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
  }
};
var LRNPackedProgram = class {
  constructor(xShape, radius, bias, alpha, beta) {
    this.variableNames = ["x"];
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    const rad = radius;
    const maxD = xShape[3] - 1;
    this.outputShape = xShape;
    let powOperator;
    const basis = `float(${bias}) + float(${alpha}) * sum`;
    if (beta === 0.5) {
      powOperator = `inversesqrt(${basis})`;
    } else if (beta === 1) {
      powOperator = `1.0/(${basis})`;
    } else {
      powOperator = `exp(log(${basis}) * float(-${beta}));`;
    }
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
  }
};
var lrn = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x2.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x2.shape, depthRadius, bias, alpha, beta);
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
};
var LRNConfig = {
  kernelName: LRN,
  backendName: "webgl",
  kernelFunc: lrn
};
var LRNGradProgram = class {
  constructor(inputShape, depthRadius, bias, alpha, beta) {
    this.variableNames = ["inputImage", "outputImage", "dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    this.depth = inputShape[3];
    this.depthRadius = depthRadius;
    this.bias = bias;
    this.alpha = alpha;
    this.beta = beta;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
};
var lrnGrad = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, y: y2, dy } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  const program = new LRNGradProgram(x2.shape, depthRadius, bias, alpha, beta);
  return backend22.runWebGLProgram(program, [x2, y2, dy], x2.dtype);
};
var LRNGradConfig = {
  kernelName: LRNGrad,
  backendName: "webgl",
  kernelFunc: lrnGrad
};
function maxImpl2(x2, reduceShape, outShape, backend22) {
  const inSize = util_exports.sizeFromShape(reduceShape);
  const xSize = util_exports.sizeFromShape(x2.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape4({ inputs: { x: x2 }, attrs: { shape: [batchSize, inSize] }, backend: backend22 });
  const reduced = reduce(reshapedInput, x2.dtype, "max", backend22);
  const reshapedOutput = reshape4({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(reshapedInput);
  backend22.disposeIntermediateTensorInfo(reduced);
  return reshapedOutput;
}
function max4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { reductionIndices, keepDims } = attrs;
  const xRank = x2.shape.length;
  const origAxes = util_exports.parseAxisParam(reductionIndices, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  const maxInputIsTransposed = permutedAxes != null;
  const shouldExecuteOnCPU = backend22.shouldExecuteOnCPU([x2]);
  let maxInput = x2;
  if (maxInputIsTransposed) {
    if (shouldExecuteOnCPU) {
      const xTexData = backend22.texData.get(maxInput.dataId);
      const values = xTexData.values;
      const newShape = new Array(xRank);
      for (let i2 = 0; i2 < newShape.length; i2++) {
        newShape[i2] = x2.shape[permutedAxes[i2]];
      }
      const maxInputValues = transposeImplCPU(values, x2.shape, x2.dtype, permutedAxes, newShape);
      maxInput = backend22.makeTensorInfo(newShape, x2.dtype);
      const maxInputData = backend22.texData.get(maxInput.dataId);
      maxInputData.values = maxInputValues;
    } else {
      maxInput = transposeImpl2(x2, permutedAxes, backend22);
    }
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
  }
  backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
  const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(maxInput.shape, axes);
  let outShape = maxOutShape;
  if (keepDims) {
    outShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
  }
  let out;
  if (shouldExecuteOnCPU) {
    const xTexData = backend22.texData.get(maxInput.dataId);
    const values = xTexData.values;
    const outValues = maxImplCPU(values, util_exports.sizeFromShape(reduceShape), outShape, x2.dtype);
    out = backend22.makeTensorInfo(outShape, x2.dtype);
    const outData = backend22.texData.get(out.dataId);
    outData.values = outValues;
  } else {
    out = maxImpl2(maxInput, reduceShape, outShape, backend22);
  }
  if (maxInputIsTransposed) {
    backend22.disposeIntermediateTensorInfo(maxInput);
  }
  return out;
}
var maxConfig2 = {
  kernelName: Max,
  backendName: "webgl",
  kernelFunc: max4
};
var MAXIMUM = CHECK_NAN_SNIPPET2 + `
  return max(a, b);
`;
var MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
var maximum4 = binaryKernelFunc2({
  opSnippet: MAXIMUM,
  packedOpSnippet: MAXIMUM_PACKED,
  cpuKernelImpl: maximumImplCPU
});
var maximumConfig2 = {
  kernelName: Maximum,
  backendName: "webgl",
  kernelFunc: maximum4
};
function maxPool3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  assertNotComplex2(x2, "maxPool");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity3({ inputs: { x: x2 }, backend: backend22 });
  }
  const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
  return backend22.runWebGLProgram(maxPoolProgram, [x2], x2.dtype);
}
var maxPoolConfig2 = {
  kernelName: MaxPool,
  backendName: "webgl",
  kernelFunc: maxPool3
};
function maxPool3d2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
  const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
  return backend22.runWebGLProgram(maxPoolProgram, [x2], x2.dtype);
}
var maxPool3DConfig2 = {
  kernelName: MaxPool3D,
  backendName: "webgl",
  kernelFunc: maxPool3d2
};
var MaxPool2DBackpropProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = convInfo.inShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var MaxPool3DBackpropProgram = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = convInfo.inShape;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function maxPool3DGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2 } = inputs;
  const x2 = input2;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, "max", true);
  const maxPool3dPositions2 = backend22.runWebGLProgram(maxPool3dPositionsProgram, [x2], x2.dtype);
  const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
  const result = backend22.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions2], x2.dtype);
  backend22.disposeIntermediateTensorInfo(maxPool3dPositions2);
  return result;
}
var maxPoolGrad3DConfig = {
  kernelName: MaxPool3DGrad,
  backendName: "webgl",
  kernelFunc: maxPool3DGrad2
};
function maxPoolGrad3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, input: input2, output } = inputs;
  const x2 = input2;
  assertNotComplex2([input2, output], "maxPoolGrad");
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const getPositions = true;
  const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
  const maxPoolPositions2 = backend22.runWebGLProgram(maxPoolPositionsProgram, [x2], x2.dtype);
  const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
  const result = backend22.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions2], x2.dtype);
  backend22.disposeIntermediateTensorInfo(maxPoolPositions2);
  return result;
}
var maxPoolGradConfig3 = {
  kernelName: MaxPoolGrad,
  backendName: "webgl",
  kernelFunc: maxPoolGrad3
};
function maxPoolWithArgmaxImpl2(x2, includeBatchInIndex, convInfo, backend22) {
  let program = new Pool2DProgram(convInfo, "max", false);
  const poolOutput = backend22.runWebGLProgram(program, [x2], "float32");
  program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
  const indexOutput = backend22.runWebGLProgram(program, [x2], "float32");
  return [poolOutput, indexOutput];
}
var maxPoolWithArgmaxConfig2 = {
  kernelName: MaxPoolWithArgmax,
  backendName: "webgl",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const { filterSize, strides, pad: pad3, includeBatchInIndex } = attrs;
    const webglBackend = backend22;
    util_exports.assert(x2.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x2.shape.length}.`);
    const dilations = [1, 1];
    util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3);
    const [result, indexes] = maxPoolWithArgmaxImpl2(x2, includeBatchInIndex, convInfo, webglBackend);
    return [result, indexes];
  }
};
function meanImpl(x2, reduceShape, outShape, backend22) {
  const inSize = util_exports.sizeFromShape(reduceShape);
  const xSize = util_exports.sizeFromShape(x2.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape4({ inputs: { x: x2 }, attrs: { shape: [batchSize, inSize] }, backend: backend22 });
  const reduced = reduce(reshapedInput, "float32", "mean", backend22);
  const reshapedOutput = reshape4({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(reshapedInput);
  backend22.disposeIntermediateTensorInfo(reduced);
  return reshapedOutput;
}
var meanConfig2 = {
  kernelName: Mean,
  backendName: "webgl",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const { keepDims, axis } = attrs;
    const webglBackend = backend22;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(axis, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    const meanInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x2]);
    const intermediates = [];
    let meanInput = x2;
    if (meanInputIsTransposed) {
      if (shouldExecuteOnCPU) {
        const xTexData = webglBackend.texData.get(meanInput.dataId);
        const values = xTexData.values;
        const newShape = new Array(xRank);
        for (let i2 = 0; i2 < newShape.length; i2++) {
          newShape[i2] = x2.shape[permutedAxes[i2]];
        }
        const meanInputValues = transposeImplCPU(values, x2.shape, x2.dtype, permutedAxes, newShape);
        meanInput = webglBackend.makeTensorInfo(newShape, x2.dtype);
        const meanInputData = webglBackend.texData.get(meanInput.dataId);
        meanInputData.values = meanInputValues;
      } else {
        meanInput = transposeImpl2(x2, permutedAxes, webglBackend);
      }
      intermediates.push(meanInput);
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
    const [meanOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(meanInput.shape, axes);
    let outShape = meanOutShape;
    if (keepDims) {
      outShape = backend_util_exports.expandShapeToKeepDim(meanOutShape, origAxes);
    }
    const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
    for (const i2 of intermediates) {
      webglBackend.disposeIntermediateTensorInfo(i2);
    }
    return out;
  }
};
function min4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x2.shape.length;
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let permutedX = x2;
  if (permutedAxes != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, x2.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("min", axes, xRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = util_exports.sizeFromShape(reduceShape);
  const a2D = reshape4({ inputs: { x: permutedX }, backend: backend22, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "min", backend22);
  let res2;
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: newShape } });
  } else {
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: outShape } });
  }
  backend22.disposeIntermediateTensorInfo(a2D);
  backend22.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend22.disposeIntermediateTensorInfo(permutedX);
  }
  return res2;
}
var minConfig2 = {
  kernelName: Min,
  backendName: "webgl",
  kernelFunc: min4
};
var MINIMUM = CHECK_NAN_SNIPPET2 + `
  return min(a, b);
`;
var MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
var minimum4 = binaryKernelFunc2({
  opSnippet: MINIMUM,
  packedOpSnippet: MINIMUM_PACKED,
  cpuKernelImpl: minimumImplCPU
});
var minimumConfig2 = {
  kernelName: Minimum,
  backendName: "webgl",
  kernelFunc: minimum4
};
var MirrorPadProgram = class {
  constructor(xShape, paddings, mode) {
    this.variableNames = ["x"];
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p22) => p22[0]).join(",");
    const end = paddings.map((p22, i2) => p22[0] + xShape[i2]).join(",");
    const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
    const offset = mode === "reflect" ? 0 : 1;
    if (rank === 1) {
      this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
      return;
    }
    this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
  }
};
var MirrorPadPackedProgram = class {
  constructor(xShape, paddings, mode) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p22) => p22[0]).join(",");
    const end = paddings.map((p22, i2) => p22[0] + xShape[i2]).join(",");
    const coords32 = getChannels("rc", rank);
    const source = getChannels("source", rank);
    const cLimit = `${coords32[rank - 1]} < ${this.outputShape[rank - 1]}`;
    const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
    const offset = mode === "reflect" ? 0 : 1;
    let mainLoop = "";
    if (rank === 1) {
      const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
      mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords32[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
    } else {
      const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
      mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords32[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords32[rank - 2]} += 1;
        if(${coords32[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords32[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
    }
    this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
  }
};
var mirrorPadKernelFunc = ({ inputs, backend: backend22, attrs }) => {
  const { x: x2 } = inputs;
  const { paddings, mode } = attrs;
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x2.shape, paddings, mode) : new MirrorPadProgram(x2.shape, paddings, mode);
  const output = backend22.runWebGLProgram(program, [x2], x2.dtype);
  return output;
};
var mirrorPadConfig2 = {
  kernelName: MirrorPad,
  backendName: "webgl",
  kernelFunc: mirrorPadKernelFunc
};
var MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
var MOD_PACKED = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
var mod3 = binaryKernelFunc2({
  opSnippet: MOD,
  packedOpSnippet: MOD_PACKED
});
var modConfig2 = {
  kernelName: Mod,
  backendName: "webgl",
  kernelFunc: mod3
};
var MultinomialProgram = class {
  constructor(batchSize, numOutcomes, numSamples) {
    this.variableNames = ["probs"];
    this.customUniforms = [{ name: "seed", type: "float" }];
    this.outputShape = [batchSize, numSamples];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
  }
};
var DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
var DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
var realDiv = binaryKernelFunc2({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
var realDivConfig2 = {
  kernelName: RealDiv,
  backendName: "webgl",
  kernelFunc: realDiv
};
var SUB = "return a - b;";
var sub3 = binaryKernelFunc2({
  opSnippet: SUB,
  packedOpSnippet: SUB,
  supportsComplex: true,
  cpuKernelImpl: subImplCPU
});
var subConfig2 = {
  kernelName: Sub,
  backendName: "webgl",
  kernelFunc: sub3
};
function softmax4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const axes = util_exports.parseAxisParam([dim], logits.shape);
  const maxLogit = max4({
    inputs: { x: logits },
    backend: backend22,
    attrs: { reductionIndices: axes, keepDims: false }
  });
  const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
  const maxLogitsReshaped = reshape4({ inputs: { x: maxLogit }, backend: backend22, attrs: { shape: expandedShape } });
  const a6 = sub3({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend22 });
  const b2 = exp3({ inputs: { x: a6 }, backend: backend22 });
  const sumExp = sum4({ inputs: { x: b2 }, backend: backend22, attrs: { axis: axes, keepDims: false } });
  const sumExpReshaped = reshape4({ inputs: { x: sumExp }, backend: backend22, attrs: { shape: expandedShape } });
  const res2 = realDiv({ inputs: { a: b2, b: sumExpReshaped }, backend: backend22 });
  backend22.disposeIntermediateTensorInfo(maxLogit);
  backend22.disposeIntermediateTensorInfo(maxLogitsReshaped);
  backend22.disposeIntermediateTensorInfo(a6);
  backend22.disposeIntermediateTensorInfo(b2);
  backend22.disposeIntermediateTensorInfo(sumExp);
  backend22.disposeIntermediateTensorInfo(sumExpReshaped);
  return res2;
}
var softmaxConfig2 = {
  kernelName: Softmax,
  backendName: "webgl",
  kernelFunc: softmax4
};
function multinomial3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { logits } = inputs;
  const { numSamples, seed, normalized } = attrs;
  const probs = normalized ? logits : softmax4({ inputs: { logits }, backend: backend22, attrs: { dim: logits.shape.length - 1 } });
  const batchSize = probs.shape[0];
  const numOutcomes = probs.shape[1];
  const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
  const customValues = [[seed]];
  const res2 = backend22.runWebGLProgram(program, [probs], "int32", customValues);
  if (!normalized) {
    backend22.disposeIntermediateTensorInfo(probs);
  }
  return res2;
}
var multinomialConfig2 = {
  kernelName: Multinomial,
  backendName: "webgl",
  kernelFunc: multinomial3
};
var NEG = `return -x;`;
function neg3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (backend22.shouldExecuteOnCPU([x2])) {
    const xData = backend22.texData.get(x2.dataId);
    const [outValues, newShape] = negImplCPU(xData.values, x2.shape, x2.dtype);
    return backend22.makeTensorInfo(newShape, x2.dtype, outValues);
  }
  let program;
  if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
    program = new UnaryOpPackedProgram(x2.shape, NEG);
  } else {
    program = new UnaryOpProgram(x2.shape, NEG);
  }
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
var negConfig2 = {
  kernelName: Neg,
  backendName: "webgl",
  kernelFunc: neg3
};
var nonMaxSuppressionV3Impl3 = kernel_impls_exports.nonMaxSuppressionV3Impl;
function nonMaxSuppressionV32(args) {
  backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  const boxesVals = backend22.readSync(boxes.dataId);
  const scoresVals = backend22.readSync(scores.dataId);
  const { selectedIndices } = nonMaxSuppressionV3Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Config2 = {
  kernelName: NonMaxSuppressionV3,
  backendName: "webgl",
  kernelFunc: nonMaxSuppressionV32
};
var nonMaxSuppressionV4Impl3 = kernel_impls_exports.nonMaxSuppressionV4Impl;
function nonMaxSuppressionV42(args) {
  backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
  const boxesVals = backend22.readSync(boxes.dataId);
  const scoresVals = backend22.readSync(scores.dataId);
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  return [
    backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend22.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
  ];
}
var nonMaxSuppressionV4Config2 = {
  kernelName: NonMaxSuppressionV4,
  backendName: "webgl",
  kernelFunc: nonMaxSuppressionV42
};
var nonMaxSuppressionV5Impl3 = kernel_impls_exports.nonMaxSuppressionV5Impl;
function nonMaxSuppressionV52(args) {
  backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  const boxesVals = backend22.readSync(boxes.dataId);
  const scoresVals = backend22.readSync(scores.dataId);
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl3(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend22.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Config2 = {
  kernelName: NonMaxSuppressionV5,
  backendName: "webgl",
  kernelFunc: nonMaxSuppressionV52
};
var OneHotProgram = class {
  constructor(numIndices, depth, onValue, offValue) {
    this.variableNames = ["indices"];
    this.outputShape = [numIndices, depth];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
  }
};
var oneHot3 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { indices } = inputs;
  const { depth, onValue, offValue } = attrs;
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
  const reshaped = reshape4({ inputs: { x: indices }, backend: backend22, attrs: { shape: [indicesSize] } });
  const result = backend22.runWebGLProgram(program, [reshaped], indices.dtype);
  backend22.disposeIntermediateTensorInfo(reshaped);
  const outShape = [...indices.shape, depth];
  const out = reshape4({ inputs: { x: result }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeIntermediateTensorInfo(result);
  return out;
};
var oneHotConfig2 = {
  kernelName: OneHot,
  backendName: "webgl",
  kernelFunc: oneHot3
};
function zerosLike3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "complex64") {
    const realPart = real3({ inputs: { input: x2 }, backend: backend22 });
    const r2 = zerosLike3({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag3({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike3({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex3({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(realPart);
    backend22.disposeIntermediateTensorInfo(r2);
    backend22.disposeIntermediateTensorInfo(imagPart);
    backend22.disposeIntermediateTensorInfo(i2);
    return result;
  } else {
    return fill3({
      attrs: {
        shape: x2.shape,
        dtype: x2.dtype,
        value: x2.dtype === "string" ? "" : 0
      },
      backend: backend22
    });
  }
}
var zerosLikeConfig2 = {
  kernelName: ZerosLike,
  backendName: "webgl",
  kernelFunc: zerosLike3
};
function onesLike3(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "string") {
    throw new Error("onesLike is not supported under string dtype");
  } else if (x2.dtype === "complex64") {
    const realPart = real3({ inputs: { input: x2 }, backend: backend22 });
    const r2 = onesLike3({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag3({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike3({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex3({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeIntermediateTensorInfo(realPart);
    backend22.disposeIntermediateTensorInfo(r2);
    backend22.disposeIntermediateTensorInfo(imagPart);
    backend22.disposeIntermediateTensorInfo(i2);
    return result;
  } else {
    return fill3({ attrs: { shape: x2.shape, dtype: x2.dtype, value: 1 }, backend: backend22 });
  }
}
var onesLikeConfig2 = {
  kernelName: OnesLike,
  backendName: "webgl",
  kernelFunc: onesLike3
};
function pack2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims4({ inputs: { input: inputs[0] }, backend: backend22, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t2) => {
    util_exports.assertShapesMatch(shape, t2.shape, "All tensors passed to stack must have matching shapes");
    util_exports.assert(dtype === t2.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t2) => {
    const expandedT = expandDims4({ inputs: { input: t2 }, backend: backend22, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat3({ inputs: expandedTensors, backend: backend22, attrs: { axis } });
  intermediateTensorInfos.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var packConfig2 = {
  kernelName: Pack,
  backendName: "webgl",
  kernelFunc: pack2
};
var PadProgram = class {
  constructor(xShape, paddings, constantValue) {
    this.variableNames = ["x"];
    this.customUniforms = [{ name: "value", type: "float" }];
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    const rank = xShape.length;
    const type = getCoordsDataType(rank);
    const start = paddings.map((p22) => p22[0]).join(",");
    const end = paddings.map((p22, i2) => p22[0] + xShape[i2]).join(",");
    const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
    if (rank === 1) {
      this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
      return;
    }
    this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
  }
};
var PadPackedProgram = class {
  constructor(xShape, paddings, constantValue) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{ name: "value", type: "float" }];
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p22) => p22[0]).join(",");
    const end = paddings.map((p22, i2) => p22[0] + xShape[i2]).join(",");
    const coords32 = getChannels("rc", rank);
    const source = getChannels("source", rank);
    const cLimit = `${coords32[rank - 1]} < ${this.outputShape[rank - 1]}`;
    const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
    const componentSetup = [
      `${dtype} rc = outputLoc;`,
      `${coords32[rank - 1]} += 1;
       if(${cLimit}) {
      `,
      rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords32[rank - 2]} += 1;
       if(${coords32[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
      rank === 1 ? "" : `  ${coords32[rank - 1]} += 1;
         if(${cLimit}) {`
    ];
    const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    let mainLoop = "";
    for (let i2 = 0, j2 = rank === 1 ? 2 : 4; i2 < j2; i2++) {
      mainLoop += `
        ${componentSetup[i2]}
        if (${paddingArea}) {
          result[${i2}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i2}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
    }
    mainLoop += rank === 1 ? `} ` : `}}`;
    this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
  }
};
var padV22 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { paddings, constantValue } = attrs;
  if (util_exports.sizeFromShape(x2.shape) === 0) {
    const outputShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
    return fill3({
      backend: backend22,
      attrs: { shape: outputShape, value: constantValue, dtype: x2.dtype }
    });
  }
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x2.shape, paddings, constantValue) : new PadProgram(x2.shape, paddings, constantValue);
  const customValues = [[constantValue]];
  return backend22.runWebGLProgram(program, [x2], x2.dtype, customValues);
};
var padV2Config2 = {
  kernelName: PadV2,
  backendName: "webgl",
  kernelFunc: padV22
};
var POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
var POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
var pow3 = binaryKernelFunc2({ opSnippet: POW, packedOpSnippet: POW_PACKED });
var powConfig2 = {
  kernelName: Pow,
  backendName: "webgl",
  kernelFunc: pow3
};
function prod3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x2.shape.length;
  const toDispose = [];
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let permutedX = x2;
  if (permutedAxes != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    toDispose.push(permutedX);
  }
  backend_util_exports.assertAxesAreInnerMostDims("prod", axes, xRank);
  let res2;
  if (backend22.shouldExecuteOnCPU([permutedX])) {
    const xVals = backend22.texData.get(permutedX.dataId).values;
    const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
    res2 = backend22.makeTensorInfo(outShape, outDtype, outVals);
  } else {
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports.sizeFromShape(reduceShape);
    const a2D = reshape4({ inputs: { x: permutedX }, backend: backend22, attrs: { shape: [-1, inSize] } });
    const outputDType = sumOutType(x2.dtype);
    const reduced = reduce(a2D, outputDType, "prod", backend22);
    res2 = reshape4({ inputs: { x: reduced }, backend: backend22, attrs: { shape: outShape } });
    toDispose.push(a2D);
    toDispose.push(reduced);
  }
  if (keepDims) {
    toDispose.push(res2);
    const newShape = backend_util_exports.expandShapeToKeepDim(res2.shape, origAxes);
    res2 = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape: newShape } });
  }
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return res2;
}
var prodConfig2 = {
  kernelName: Prod,
  backendName: "webgl",
  kernelFunc: prod3
};
var range4 = (args) => {
  const { backend: backend22, attrs } = args;
  const { start, stop, step: step5, dtype } = attrs;
  const values = rangeImplCPU(start, stop, step5, dtype);
  return backend22.makeTensorInfo([values.length], dtype, values);
};
var rangeConfig2 = {
  kernelName: Range,
  backendName: "webgl",
  kernelFunc: range4
};
var RECIPROCAL = `return 1.0 / x;`;
var reciprocal3 = unaryKernelFunc2({ opSnippet: RECIPROCAL });
var reciprocalConfig2 = {
  kernelName: Reciprocal,
  backendName: "webgl",
  kernelFunc: reciprocal3
};
var RELU3 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
var RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var relu3 = unaryKernelFunc2({ opSnippet: RELU3, packedOpSnippet: RELU_PACKED });
var reluConfig2 = {
  kernelName: Relu,
  backendName: "webgl",
  kernelFunc: relu3
};
var RELU63 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
var RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var relu63 = unaryKernelFunc2({ opSnippet: RELU63, packedOpSnippet: RELU6_PACKED });
var relu6Config2 = {
  kernelName: Relu6,
  backendName: "webgl",
  kernelFunc: relu63
};
var ResizeBilinearProgram = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`;
    } else {
      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
};
var ResizeBilinearPackedProgram = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`;
    } else {
      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
};
function resizeBilinear3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  const [newHeight, newWidth] = size2;
  const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend22.runWebGLProgram(program, [images], "float32");
}
var resizeBilinearConfig2 = {
  kernelName: ResizeBilinear,
  backendName: "webgl",
  kernelFunc: resizeBilinear3
};
var ResizeBilinearBackpropProgram = class {
  constructor(dyShape, inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    const [, xHeight, xWidth] = inputShape;
    const [, yHeight, yWidth] = dyShape;
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
function resizeBilinearGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images, dy } = inputs;
  const { alignCorners } = attrs;
  const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
  return backend22.runWebGLProgram(program, [dy], dy.dtype);
}
var resizeBilinearGradConfig3 = {
  kernelName: ResizeBilinearGrad,
  backendName: "webgl",
  kernelFunc: resizeBilinearGrad2
};
var ResizeNearestNeighborProgram = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const roundBase = alignCorners ? "0.5" : "0.0";
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`;
    } else {
      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
};
var ResizeNearestNeighborPackedProgram = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const roundBase = alignCorners ? "0.5" : "0.0";
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`;
    } else {
      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
};
function resizeNearestNeighbor3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  const [newHeight, newWidth] = size2;
  const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend22.runWebGLProgram(program, [images], images.dtype);
}
var resizeNearestNeighborConfig2 = {
  kernelName: ResizeNearestNeighbor,
  backendName: "webgl",
  kernelFunc: resizeNearestNeighbor3
};
var ResizeNearestNeigborBackpropProgram = class {
  constructor(dyShape, inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    const [, xHeight, xWidth] = inputShape;
    const [, yHeight, yWidth] = dyShape;
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
function resizeNearestNeighborGrad2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images, dy } = inputs;
  const { alignCorners } = attrs;
  const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
  return backend22.runWebGLProgram(program, [dy], dy.dtype);
}
var resizeNearestNeighborGradConfig3 = {
  kernelName: ResizeNearestNeighborGrad,
  backendName: "webgl",
  kernelFunc: resizeNearestNeighborGrad2
};
var ReverseProgram = class {
  constructor(xShape, axis) {
    this.variableNames = ["x"];
    const rank = xShape.length;
    if (rank > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
    }
    this.outputShape = xShape;
    if (rank === 1) {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
      return;
    }
    const getInCoord = (i2) => {
      if (axis.indexOf(i2) !== -1 && xShape[i2] !== 1) {
        return `${xShape[i2]} - coords[${i2}] - 1`;
      }
      return `coords[${i2}]`;
    };
    const inCoords = xShape.map((_2, i2) => getInCoord(i2)).join(",");
    const type = getCoordsDataType(rank);
    this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
  }
};
var ReversePackedProgram = class {
  constructor(xShape, axis) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    const rank = xShape.length;
    if (rank > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
    }
    this.outputShape = xShape;
    const channels = getChannels("rc", rank);
    const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
    const type = getCoordsDataType(rank);
    if (rank === 1) {
      this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
    } else {
      this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
    }
    function getR(channels2) {
      return getChannel(channels2);
    }
    function getG(channels2) {
      channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
      return getChannel(channels2);
    }
    function getB(channels2) {
      channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
      return getChannel(channels2);
    }
    function getA(channels2) {
      channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
      channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
      return getChannel(channels2);
    }
    function getChannel(channels2) {
      const inCoordsArray = xShape.map((_2, i2) => getInCoord(i2, channels2));
      const inCoords = inCoordsArray.join(",");
      const innerDims = inCoordsArray.slice(-2).join(",");
      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
    }
    function getInCoord(i2, channels1) {
      if (axis.indexOf(i2) !== -1 && xShape[i2] !== 1) {
        return `${xShape[i2]} - ${channels1[i2]} - 1`;
      } else {
        return `${channels1[i2]}`;
      }
    }
  }
};
function reverse3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dims } = attrs;
  const xRank = x2.shape.length;
  const $dims = util_exports.parseAxisParam(dims, x2.shape);
  if (xRank === 0) {
    return identity3({ inputs: { x: x2 }, backend: backend22 });
  }
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x2.shape, $dims) : new ReverseProgram(x2.shape, $dims);
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
var reverseConfig2 = {
  kernelName: Reverse,
  backendName: "webgl",
  kernelFunc: reverse3
};
var RotateProgram = class {
  constructor(imageShape, fillValue) {
    this.variableNames = ["Image"];
    this.outputShape = [];
    this.customUniforms = [{ name: "params", type: "vec4" }];
    const imageHeight = imageShape[1];
    const imageWidth = imageShape[2];
    this.outputShape = imageShape;
    let fillSnippet = "";
    if (typeof fillValue === "number") {
      fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
    } else {
      fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
    }
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var rotateWithOffsetConfig2 = {
  kernelName: RotateWithOffset,
  backendName: "webgl",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const { radians, fillValue, center } = attrs;
    const webglBackend = backend22;
    const program = new RotateProgram(image32.shape, fillValue);
    const [centerX, centerY] = backend_util_exports.getImageCenter(center, image32.shape[1], image32.shape[2]);
    const customValues = [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];
    const output = webglBackend.runWebGLProgram(program, [image32], image32.dtype, customValues);
    return output;
  }
};
var ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
var round4 = unaryKernelFunc2({ opSnippet: ROUND });
var roundConfig2 = {
  kernelName: Round,
  backendName: "webgl",
  kernelFunc: round4
};
var RSQRT = `return inversesqrt(x);`;
var rsqrt3 = unaryKernelFunc2({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
var rsqrtConfig2 = {
  kernelName: Rsqrt,
  backendName: "webgl",
  kernelFunc: rsqrt3
};
var ScatterProgram = class {
  constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.outputShape = shape;
    const stridesType = getCoordsDataType(strides.length);
    const dtype = getCoordsDataType(shape.length);
    let indicesString = "";
    if (indicesRank === 1) {
      indicesString = "i";
    } else if (indicesRank === 2) {
      indicesString = "i, j";
    }
    const indicesSnippet = `getIndices(${indicesString})`;
    let updatesString = "";
    if (updatesRank === 1) {
      updatesString = "i";
    } else if (updatesRank === 2) {
      updatesString = "i, coords[1]";
    }
    const updatesSnippet = `getUpdates(${updatesString})`;
    const strideString = sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
  }
};
function scatterNd2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(updates, indices, shape);
  const flattenShape = [outputSize2 / sliceSize, sliceSize];
  if (outputSize2 === 0) {
    return backend22.makeTensorInfo(shape, indices.dtype);
  }
  const flattenIndices = reshape4({ inputs: { x: indices }, backend: backend22, attrs: { shape: [numUpdates, sliceRank] } });
  const flattenX = reshape4({ inputs: { x: updates }, backend: backend22, attrs: { shape: [numUpdates, sliceSize] } });
  const defaultValue = backend22.makeTensorInfo([], "float32", new Float32Array([0]));
  const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
  const res2 = backend22.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
  const reshaped = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape } });
  backend22.disposeIntermediateTensorInfo(flattenIndices);
  backend22.disposeIntermediateTensorInfo(flattenX);
  backend22.disposeIntermediateTensorInfo(res2);
  backend22.disposeIntermediateTensorInfo(defaultValue);
  return reshaped;
}
var scatterNdConfig2 = {
  kernelName: ScatterNd,
  backendName: "webgl",
  kernelFunc: scatterNd2
};
var SelectProgram = class {
  constructor(cRank, shape, rank) {
    this.variableNames = ["c", "a", "b"];
    this.outputShape = shape;
    let cCoords;
    let abCoords;
    if (rank > 4) {
      throw Error(`Where for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
      abCoords = `resRC`;
      cCoords = `resRC`;
    } else {
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const cCoordVars = [];
      const abCoordVars = [];
      for (let i2 = 0; i2 < shape.length; i2++) {
        abCoordVars.push(`${currentCoords[i2]}`);
        if (i2 < cRank) {
          cCoordVars.push(`${currentCoords[i2]}`);
        }
      }
      cCoords = cCoordVars.join();
      abCoords = abCoordVars.join();
    }
    const dtype = getCoordsDataType(rank);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
  }
};
function select3(args) {
  const { inputs, backend: backend22 } = args;
  const { condition, t: t2, e: e2 } = inputs;
  const program = new SelectProgram(condition.shape.length, t2.shape, t2.shape.length);
  return backend22.runWebGLProgram(program, [condition, t2, e2], upcastType(t2.dtype, e2.dtype));
}
var selectConfig2 = {
  kernelName: Select,
  backendName: "webgl",
  kernelFunc: select3
};
var SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};
  float scale = ${backend_util_exports.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
var selu3 = unaryKernelFunc2({ opSnippet: SELU });
var seluConfig2 = {
  kernelName: Selu,
  backendName: "webgl",
  kernelFunc: selu3
};
var SIGMOID3 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
var sigmoid3 = unaryKernelFunc2({
  opSnippet: SIGMOID3,
  packedOpSnippet: SIGMOID3,
  cpuKernelImpl: sigmoidImplCPU
});
var sigmoidConfig2 = {
  kernelName: Sigmoid,
  backendName: "webgl",
  kernelFunc: sigmoid3
};
var SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
var sign3 = unaryKernelFunc2({ opSnippet: SIGN });
var signConfig2 = {
  kernelName: Sign,
  backendName: "webgl",
  kernelFunc: sign3
};
var SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
var sin3 = unaryKernelFunc2({ opSnippet: SIN });
var sinConfig2 = {
  kernelName: Sin,
  backendName: "webgl",
  kernelFunc: sin3
};
var SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
var sinh3 = unaryKernelFunc2({ opSnippet: SINH });
var sinhConfig2 = {
  kernelName: Sinh,
  backendName: "webgl",
  kernelFunc: sinh3
};
var SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
var softplus3 = unaryKernelFunc2({ opSnippet: SOFTPLUS });
var softplusConfig2 = {
  kernelName: Softplus,
  backendName: "webgl",
  kernelFunc: softplus3
};
var spaceToBatchND3 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, paddings } = attrs;
  util_exports.assert(x2.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i2 = 1 + blockShape.length; i2 < x2.shape.length; ++i2) {
    completePaddings.push([0, 0]);
  }
  const toDispose = [];
  const paddedX = padV22({
    inputs: { x: x2 },
    backend: backend22,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod6, false);
  const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod6, false);
  const reshapedPaddedX = reshape4({ inputs: { x: paddedX }, backend: backend22, attrs: { shape: reshapedPaddedShape } });
  const paddedXT = transpose3({
    inputs: { x: reshapedPaddedX },
    backend: backend22,
    attrs: { perm: permutedReshapedPaddedPermutation }
  });
  const result = reshape4({ inputs: { x: paddedXT }, backend: backend22, attrs: { shape: flattenShape } });
  toDispose.push(paddedX);
  toDispose.push(reshapedPaddedX);
  toDispose.push(paddedXT);
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
};
var spaceToBatchNDConfig2 = {
  kernelName: SpaceToBatchND,
  backendName: "webgl",
  kernelFunc: spaceToBatchND3
};
function sparseFillEmptyRows3(args) {
  const { inputs, backend: backend22 } = args;
  const { indices, values, denseShape, defaultValue } = inputs;
  if (denseShape.shape.length !== 1) {
    throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
  }
  if (indices.shape.length !== 2) {
    throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
  }
  if (values.shape.length !== 1) {
    throw new Error(`Values must be a vector, saw:
         ${values.shape}`);
  }
  if (defaultValue.shape.length !== 0) {
    throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
  }
  const $indices = backend22.readSync(indices.dataId);
  const $values = backend22.readSync(values.dataId);
  const $denseShape = backend22.readSync(denseShape.dataId);
  const $defaultValue = backend22.readSync(defaultValue.dataId)[0];
  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
  return [
    backend22.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
    backend22.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
    backend22.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
    backend22.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
  ];
}
var sparseFillEmptyRowsConfig2 = {
  kernelName: SparseFillEmptyRows,
  backendName: "webgl",
  kernelFunc: sparseFillEmptyRows3
};
function sparseReshape3(args) {
  const { inputs, backend: backend22 } = args;
  const { inputIndices, inputShape, newShape } = inputs;
  if (inputIndices.shape.length !== 2) {
    throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
  }
  if (inputShape.shape.length !== 1) {
    throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
  }
  if (newShape.shape.length !== 1) {
    throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
  }
  const $inputShape = Array.from(backend22.readSync(inputShape.dataId));
  const $inputIndices = backend22.readSync(inputIndices.dataId);
  const targetShape = Array.from(backend22.readSync(newShape.dataId));
  const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
  return [
    backend22.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
    backend22.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
  ];
}
var sparseReshapeConfig2 = {
  kernelName: SparseReshape,
  backendName: "webgl",
  kernelFunc: sparseReshape3
};
function sparseSegmentMean3(args) {
  const { inputs, backend: backend22 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
  }
  const $data = backend22.readSync(data.dataId);
  const $indices = backend22.readSync(indices.dataId);
  const $segmentIds = backend22.readSync(segmentIds.dataId);
  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
  return backend22.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentMeanConfig2 = {
  kernelName: SparseSegmentMean,
  backendName: "webgl",
  kernelFunc: sparseSegmentMean3
};
function sparseSegmentSum3(args) {
  const { inputs, backend: backend22 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
  }
  const $data = backend22.readSync(data.dataId);
  const $indices = backend22.readSync(indices.dataId);
  const $segmentIds = backend22.readSync(segmentIds.dataId);
  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
  return backend22.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentSumConfig2 = {
  kernelName: SparseSegmentSum,
  backendName: "webgl",
  kernelFunc: sparseSegmentSum3
};
function sparseToDense3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize2, 1], sumDupeIndices);
  const res2 = backend22.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
  const reshaped = reshape4({ inputs: { x: res2 }, backend: backend22, attrs: { shape: outputShape } });
  backend22.disposeIntermediateTensorInfo(res2);
  return reshaped;
}
var sparseToDenseConfig2 = {
  kernelName: SparseToDense,
  backendName: "webgl",
  kernelFunc: sparseToDense3
};
function splitV2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const splitSizes = backend_util_exports.prepareSplitSize(x2, numOrSizeSplits, $axis);
  const xRank = x2.shape.length;
  const begin = new Array(xRank).fill(0);
  const size2 = x2.shape.slice();
  return splitSizes.map((s2) => {
    const sliceSize = [...size2];
    sliceSize[$axis] = s2;
    const sliceT = slice3({ inputs: { x: x2 }, backend: backend22, attrs: { begin, size: sliceSize } });
    begin[$axis] += s2;
    return sliceT;
  });
}
var splitVConfig2 = {
  kernelName: SplitV,
  backendName: "webgl",
  kernelFunc: splitV2
};
var SQRT = `return sqrt(x);`;
var sqrt3 = unaryKernelFunc2({ opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU });
var sqrtConfig2 = {
  kernelName: Sqrt,
  backendName: "webgl",
  kernelFunc: sqrt3
};
var SQUARE = `return x * x;`;
var square3 = unaryKernelFunc2({ opSnippet: SQUARE });
var squareConfig2 = {
  kernelName: Square,
  backendName: "webgl",
  kernelFunc: square3
};
var SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
var squaredDifference3 = binaryKernelFunc2({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
var squaredDifferenceConfig2 = {
  kernelName: SquaredDifference,
  backendName: "webgl",
  kernelFunc: squaredDifference3
};
function step3({ inputs, attrs, backend: backend22 }) {
  const { x: x2 } = inputs;
  const opSnippet = CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
  const program = new UnaryOpProgram(x2.shape, opSnippet);
  return backend22.runWebGLProgram(program, [x2], x2.dtype);
}
var stepConfig2 = {
  kernelName: Step,
  backendName: "webgl",
  kernelFunc: step3
};
var StridedSliceProgram = class {
  constructor(begin, strides, size2) {
    this.variableNames = ["x"];
    this.outputShape = size2;
    const rank = size2.length;
    const inputDtype = getCoordsDataType(size2.length);
    const dtype = getCoordsDataType(size2.length);
    let newCoords = "";
    if (rank === 1) {
      newCoords = "coords * strides + begin";
    } else {
      let outputAxis = 0;
      newCoords = size2.map((_2, i2) => {
        outputAxis++;
        return size2.length === 1 ? `coords * strides[${i2}] + begin[${i2}]` : `coords[${outputAxis - 1}] * strides[${i2}] + begin[${i2}]`;
      }).join(",");
    }
    this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
  }
};
function stridedSlice3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  const { nonStrided, $begin, $strides, size: size2, newShape, outShape } = slice_util_exports.sliceInfo(x2.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  const $x = reshape4({ inputs: { x: x2 }, backend: backend22, attrs: { shape: newShape } });
  let result;
  if (nonStrided) {
    const sliced = slice3({ inputs: { x: $x }, backend: backend22, attrs: { begin: $begin, size: size2 } });
    result = reshape4({ inputs: { x: sliced }, backend: backend22, attrs: { shape: outShape } });
    backend22.disposeIntermediateTensorInfo(sliced);
  } else if (outShape.some((axis) => axis === 0)) {
    result = backend22.makeTensorInfo(outShape, x2.dtype, []);
  } else {
    const shouldExecuteOnCPU = backend22.shouldExecuteOnCPU([$x]);
    if (shouldExecuteOnCPU) {
      const xTexData = backend22.texData.get($x.dataId);
      const values = xTexData.values;
      const xBuf = buffer($x.shape, $x.dtype, values);
      const resultValues = stridedSliceImplCPU(outShape, xBuf, $strides, $begin);
      result = backend22.makeTensorInfo(outShape, $x.dtype, resultValues.values);
    } else {
      const program = new StridedSliceProgram($begin, $strides, outShape);
      result = backend22.runWebGLProgram(program, [$x], $x.dtype);
    }
  }
  const resultReshaped = reshape4({ inputs: { x: result }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeIntermediateTensorInfo($x);
  backend22.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var stridedSliceConfig2 = {
  kernelName: StridedSlice,
  backendName: "webgl",
  kernelFunc: stridedSlice3
};
function stringNGrams3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend22.readSync(data.dataId);
  const $dataSplits = backend22.readSync(dataSplits.dataId);
  const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend22.makeTensorInfo([nGrams.length], "string", nGrams),
    backend22.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig2 = {
  kernelName: StringNGrams,
  backendName: "webgl",
  kernelFunc: stringNGrams3
};
function stringSplit3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { skipEmpty } = attrs;
  const { input: input2, delimiter } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (input2.shape.length !== 1) {
    throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
  }
  if (delimiter.shape.length !== 0) {
    throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
  }
  const $input = backend22.readSync(input2.dataId);
  const $delimiter = backend22.readSync(delimiter.dataId)[0];
  const [indices, values, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
  const outputSize2 = values.length;
  return [
    backend22.makeTensorInfo([outputSize2, 2], "int32", indices),
    backend22.makeTensorInfo([outputSize2], "string", values),
    backend22.makeTensorInfo([2], "int32", new Int32Array(shape))
  ];
}
var stringSplitConfig2 = {
  kernelName: StringSplit,
  backendName: "webgl",
  kernelFunc: stringSplit3
};
function stringToHashBucketFast3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { numBuckets } = attrs;
  const { input: input2 } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const $input = backend22.readSync(input2.dataId);
  const output = stringToHashBucketFastImplCPU($input, numBuckets);
  return backend22.makeTensorInfo(input2.shape, "int32", output);
}
var stringToHashBucketFastConfig2 = {
  kernelName: StringToHashBucketFast,
  backendName: "webgl",
  kernelFunc: stringToHashBucketFast3
};
var TAN = `return tan(x);`;
var tan3 = unaryKernelFunc2({ opSnippet: TAN });
var tanConfig2 = {
  kernelName: Tan,
  backendName: "webgl",
  kernelFunc: tan3
};
var TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
var tanh4 = unaryKernelFunc2({ opSnippet: TANH });
var tanhConfig2 = {
  kernelName: Tanh,
  backendName: "webgl",
  kernelFunc: tanh4
};
var TileProgram = class {
  constructor(aShape, reps) {
    this.variableNames = ["A"];
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[i2] * reps[i2];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const sourceCoords = getSourceCoords3(aShape);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
  }
};
function getSourceCoords3(aShape) {
  const rank = aShape.length;
  if (rank > 5) {
    throw Error(`Tile for rank ${rank} is not yet supported`);
  }
  if (rank === 1) {
    return `imod(resRC, ${aShape[0]})`;
  }
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
  const sourceCoords = [];
  for (let i2 = 0; i2 < aShape.length; i2++) {
    sourceCoords.push(`imod(${currentCoords[i2]}, ${aShape[i2]})`);
  }
  return sourceCoords.join();
}
function tile4(params) {
  const { inputs, backend: backend22, attrs } = params;
  const { x: x2 } = inputs;
  const { reps } = attrs;
  if (x2.dtype === "string" || x2.shape.length > 5) {
    const data = backend22.readSync(x2.dataId);
    const value = x2.dtype === "string" ? data.map((d2) => util_exports.decodeString(d2)) : data;
    const buf = buffer(x2.shape, x2.dtype, value);
    const outBuf = tileImplCPU(buf, reps);
    return backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  const program = new TileProgram(x2.shape, reps);
  const output = backend22.runWebGLProgram(program, [x2], x2.dtype);
  return output;
}
var tileConfig2 = {
  kernelName: Tile,
  backendName: "webgl",
  kernelFunc: tile4
};
var SwapProgram = class {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "negativeInf", type: "float" },
      { name: "dir", type: "int" },
      { name: "inc", type: "int" }
    ];
    this.outputShape = shape;
    this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
  }
};
var MergeProgram = class {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "k", type: "int" }
    ];
    this.outputShape = shape;
    this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
  }
};
function disposeIntermediateTensorInfoOrNull(backend22, tensorInfo) {
  if (tensorInfo !== null) {
    backend22.disposeIntermediateTensorInfo(tensorInfo);
  }
}
function roundUpToPow2(num) {
  let pow22 = 1;
  while (pow22 < num) {
    pow22 *= 2;
  }
  return pow22;
}
function topK2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { k: k3, sorted } = attrs;
  const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
  const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
  const xShape = x2.shape;
  const lastDim = xShape[xShape.length - 1];
  if (backend22.shouldExecuteOnCPU([x2]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k3 > TOPK_K_CPU_HANDOFF_THRESHOLD) {
    const xVals = backend22.readSync(x2.dataId);
    const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x2.dtype, k3, sorted);
    return [
      backend22.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
      backend22.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
  }
  if (k3 === 0) {
    xShape[xShape.length - 1] = 0;
    return [
      backend22.makeTensorInfo(xShape, x2.dtype, []),
      backend22.makeTensorInfo(xShape, "int32", [])
    ];
  }
  if (lastDim === 1) {
    return [
      x2,
      fill3({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend: backend22 })
    ];
  }
  const xtexData = backend22.texData.get(x2.dataId);
  const xIsPacked = xtexData !== null && xtexData.isPacked;
  const xUnPacked = xIsPacked ? backend22.unpackTensor(x2) : x2;
  const xSize = util_exports.sizeFromShape(xShape);
  const batch = xSize / lastDim;
  const x2D = reshape4({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend: backend22 });
  if (xIsPacked) {
    disposeIntermediateTensorInfoOrNull(backend22, xUnPacked);
  }
  const kPow2 = roundUpToPow2(k3);
  const lastDimPow2 = roundUpToPow2(lastDim);
  let indices = null;
  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
  const runSwap = (dir, inc, shape) => {
    const inputs2 = getInputs();
    const program = new SwapProgram(shape);
    const fistPass = indices === null ? 1 : 0;
    const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];
    const prevIndices2 = indices;
    indices = backend22.runWebGLProgram(program, inputs2, "int32", customValues);
    disposeIntermediateTensorInfoOrNull(backend22, prevIndices2);
  };
  for (let len = 1; len < kPow2; len *= 2) {
    const dir = len * 2;
    for (let inc = len; inc >= 1; inc /= 2) {
      runSwap(dir, inc, [batch, lastDimPow2]);
    }
  }
  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {
    const inputs2 = getInputs();
    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
    const firstPass = indices === null ? 1 : 0;
    const customValues = [[lastDim], [firstPass], [kPow2]];
    const prevIndices2 = indices;
    indices = backend22.runWebGLProgram(mergeProgram, inputs2, "int32", customValues);
    disposeIntermediateTensorInfoOrNull(backend22, prevIndices2);
    const len = kPow2 / 2;
    const dir = len * 2;
    for (let inc = len; inc >= 1; inc /= 2) {
      runSwap(dir, inc, indices.shape);
    }
  }
  let prevIndices = indices;
  indices = slice3({ inputs: { x: indices }, backend: backend22, attrs: { begin: 0, size: [batch, k3] } });
  disposeIntermediateTensorInfoOrNull(backend22, prevIndices);
  let values = gatherV22({ inputs: { x: x2D, indices }, backend: backend22, attrs: { axis: 1, batchDims: 1 } });
  disposeIntermediateTensorInfoOrNull(backend22, x2D);
  const newShape = xShape.slice(0, -1);
  newShape.push(k3);
  prevIndices = indices;
  indices = reshape4({ inputs: { x: indices }, attrs: { shape: newShape }, backend: backend22 });
  disposeIntermediateTensorInfoOrNull(backend22, prevIndices);
  const prevValues = values;
  values = reshape4({ inputs: { x: values }, attrs: { shape: newShape }, backend: backend22 });
  disposeIntermediateTensorInfoOrNull(backend22, prevValues);
  return [values, indices];
}
var topKConfig2 = {
  kernelName: TopK,
  backendName: "webgl",
  kernelFunc: topK2
};
var TransformProgram = class {
  constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
    this.variableNames = ["Image", "Transforms"];
    this.outputShape = outShape;
    const interpolationModeId = interpolation === "nearest" ? 1 : 2;
    let fillModeId;
    switch (fillMode) {
      case "constant":
        fillModeId = 1;
        break;
      case "reflect":
        fillModeId = 2;
        break;
      case "wrap":
        fillModeId = 3;
        break;
      case "nearest":
        fillModeId = 4;
        break;
      default:
        fillModeId = 1;
        break;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
};
function transform3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [
    batch,
    outHeight,
    outWidth,
    numChannels
  ];
  const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
  return backend22.runWebGLProgram(program, [image32, transforms], "float32");
}
var transformConfig2 = {
  kernelName: Transform,
  backendName: "webgl",
  kernelFunc: transform3
};
function unique4(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { axis } = attrs;
  const { x: x2 } = inputs;
  assertNotComplex2(x2, "unique");
  console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  const values = backend22.readSync(x2.dataId);
  const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x2.shape, x2.dtype);
  return [
    backend22.makeTensorInfo(outputShape, x2.dtype, outputValues),
    backend22.makeTensorInfo([indices.length], "int32", indices)
  ];
}
var uniqueConfig2 = {
  kernelName: Unique,
  backendName: "webgl",
  kernelFunc: unique4
};
function unpack2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const x2 = value;
  const xRank = x2.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(xRank - 1);
  let outIndex = 0;
  for (let i2 = 0; i2 < xRank; i2++) {
    if (i2 !== axis) {
      outShape[outIndex++] = x2.shape[i2];
    }
  }
  const toDispose = [];
  const begin = new Array(xRank).fill(0);
  const size2 = x2.shape.slice();
  size2[axis] = 1;
  const res2 = new Array(num);
  for (let i2 = 0; i2 < res2.length; i2++) {
    begin[axis] = i2;
    const sliced = slice3({ inputs: { x: x2 }, backend: backend22, attrs: { begin, size: size2 } });
    const reshaped = reshape4({ inputs: { x: sliced }, backend: backend22, attrs: { shape: outShape } });
    res2[i2] = reshaped;
    toDispose.push(sliced);
  }
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return res2;
}
var unpackConfig2 = {
  kernelName: Unpack,
  backendName: "webgl",
  kernelFunc: unpack2
};
var SegmentOpProgram = class {
  constructor(segOpInfo, segOpType) {
    this.variableNames = ["x", "segmentIds"];
    const windowSize = segOpInfo.windowSize;
    const batchSize = segOpInfo.batchSize;
    const inSize = segOpInfo.inSize;
    const numSegments = segOpInfo.numSegments;
    const outSize = numSegments * Math.ceil(inSize / windowSize);
    this.outputShape = [batchSize, outSize];
    const initializationValue = "0.0";
    const returnValue = `sumValue`;
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
    let checkValueOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
    }
    let checkSegmentIdOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
  }
};
function unsortedSegmentSum3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, segmentIds } = inputs;
  const { numSegments } = attrs;
  const xRank = x2.shape.length;
  const toDispose = [];
  let axis = 0;
  const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
  let permutedX = x2;
  if (permutation != null) {
    permutedX = transpose3({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutation } });
    toDispose.push(permutedX);
    axis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
  }
  const outShape = backend_util_exports.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
  const inSize = util_exports.sizeFromShape([permutedX.shape[axis]]);
  const a2D = reshape4({ inputs: { x: permutedX }, backend: backend22, attrs: { shape: [-1, inSize] } });
  toDispose.push(a2D);
  const outputDType = sumOutType(x2.dtype);
  const segOpCompute = (x22, segOpType, segmentIds2, dtype, numSegments2) => {
    const batchSize = x22.shape[0];
    const inSize2 = x22.shape[1];
    const windowSize = backend_util_exports.segment_util.segOpComputeOptimalWindowSize(inSize2, numSegments2);
    const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
    const program = new SegmentOpProgram(segOpInfo, segOpType);
    const output = backend22.compileAndRun(program, [x22, segmentIds2], dtype);
    toDispose.push(output);
    if (output.shape[1] === numSegments2) {
      return output;
    }
    const rangeInfo = range4({
      backend: backend22,
      attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
    });
    const tileInfo = tile4({
      inputs: { x: rangeInfo },
      backend: backend22,
      attrs: { reps: [inSize2 / windowSize] }
    });
    toDispose.push(rangeInfo);
    toDispose.push(tileInfo);
    const result2 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
    return result2;
  };
  const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
  const reshaped = reshape4({ inputs: { x: segOpResult }, backend: backend22, attrs: { shape: outShape } });
  let result = reshaped;
  if (permutation != null) {
    toDispose.push(reshaped);
    const perm = backend_util_exports.getUndoAxesPermutation(permutation);
    result = transpose3({ inputs: { x: result }, backend: backend22, attrs: { perm } });
  }
  toDispose.forEach((t2) => backend22.disposeIntermediateTensorInfo(t2));
  return result;
}
var unsortedSegmentSumConfig2 = {
  kernelName: UnsortedSegmentSum,
  backendName: "webgl",
  kernelFunc: unsortedSegmentSum3
};
var kernelConfigs2 = [
  LRNConfig,
  LRNGradConfig,
  _fusedMatMulConfig2,
  absConfig2,
  acosConfig2,
  acoshConfig2,
  addConfig2,
  addNConfig2,
  allConfig2,
  anyConfig2,
  argMaxConfig2,
  argMinConfig2,
  asinConfig2,
  asinhConfig2,
  atan2Config2,
  atanConfig2,
  atanhConfig2,
  avgPool3DConfig2,
  avgPoolConfig2,
  avgPoolGrad3DConfig,
  avgPoolGradConfig3,
  batchMatMulConfig2,
  batchNormConfig2,
  batchToSpaceNDConfig2,
  bincountConfig2,
  castConfig2,
  ceilConfig2,
  clipByValueConfig,
  complexAbsConfig2,
  complexConfig2,
  concatConfig2,
  conv2DBackpropFilterConfig2,
  conv2DBackpropInputConfig2,
  conv2DConfig2,
  conv3DBackpropFilterV2Config2,
  conv3DBackpropInputConfig,
  conv3DConfig2,
  cosConfig2,
  coshConfig2,
  cropAndResizeConfig2,
  cumsumConfig2,
  denseBincountConfig2,
  depthToSpaceConfig2,
  depthwiseConv2dNativeBackpropFilterConfig2,
  depthwiseConv2dNativeBackpropInputConfig2,
  depthwiseConv2dNativeConfig2,
  diagConfig2,
  dilation2DConfig,
  einsumConfig2,
  eluConfig2,
  eluGradConfig3,
  equalConfig2,
  erfConfig2,
  expConfig2,
  expandDimsConfig2,
  expm1Config2,
  fftConfig2,
  fillConfig2,
  flipLeftRightConfig2,
  floorConfig2,
  floorDivConfig2,
  fromPixelsConfig,
  fusedConv2DConfig2,
  fusedDepthwiseConv2DConfig2,
  gatherNdConfig2,
  gatherV2Config2,
  greaterConfig2,
  greaterEqualConfig2,
  identityConfig2,
  ifftConfig2,
  imagConfig2,
  isFiniteConfig2,
  isInfConfig2,
  isNaNConfig2,
  leakyReluConfig2,
  lessConfig2,
  lessEqualConfig2,
  linSpaceConfig2,
  log1pConfig2,
  logConfig2,
  logicalAndConfig2,
  logicalNotConfig2,
  logicalOrConfig2,
  maxConfig2,
  maxPool3DConfig2,
  maxPoolConfig2,
  maxPoolGrad3DConfig,
  maxPoolGradConfig3,
  maxPoolWithArgmaxConfig2,
  maximumConfig2,
  meanConfig2,
  minConfig2,
  minimumConfig2,
  mirrorPadConfig2,
  modConfig2,
  multinomialConfig2,
  multiplyConfig2,
  negConfig2,
  nonMaxSuppressionV3Config2,
  nonMaxSuppressionV4Config2,
  nonMaxSuppressionV5Config2,
  notEqualConfig2,
  oneHotConfig2,
  onesLikeConfig2,
  packConfig2,
  padV2Config2,
  powConfig2,
  preluConfig2,
  prodConfig2,
  rangeConfig2,
  realConfig2,
  realDivConfig2,
  reciprocalConfig2,
  relu6Config2,
  reluConfig2,
  reshapeConfig2,
  resizeBilinearConfig2,
  resizeBilinearGradConfig3,
  resizeNearestNeighborConfig2,
  resizeNearestNeighborGradConfig3,
  reverseConfig2,
  rotateWithOffsetConfig2,
  roundConfig2,
  rsqrtConfig2,
  scatterNdConfig2,
  selectConfig2,
  seluConfig2,
  sigmoidConfig2,
  signConfig2,
  sinConfig2,
  sinhConfig2,
  sliceConfig2,
  softmaxConfig2,
  softplusConfig2,
  spaceToBatchNDConfig2,
  sparseFillEmptyRowsConfig2,
  sparseReshapeConfig2,
  sparseSegmentMeanConfig2,
  sparseSegmentSumConfig2,
  sparseToDenseConfig2,
  splitVConfig2,
  sqrtConfig2,
  squareConfig2,
  squaredDifferenceConfig2,
  stepConfig2,
  stridedSliceConfig2,
  stringNGramsConfig2,
  stringSplitConfig2,
  stringToHashBucketFastConfig2,
  subConfig2,
  sumConfig2,
  tanConfig2,
  tanhConfig2,
  tileConfig2,
  topKConfig2,
  transformConfig2,
  transposeConfig2,
  uniqueConfig2,
  unpackConfig2,
  unsortedSegmentSumConfig2,
  zerosLikeConfig2
];
for (const kernelConfig of kernelConfigs2) {
  registerKernel(kernelConfig);
}
var CppDType;
(function(CppDType2) {
  CppDType2[CppDType2["float32"] = 0] = "float32";
  CppDType2[CppDType2["int32"] = 1] = "int32";
  CppDType2[CppDType2["bool"] = 2] = "bool";
  CppDType2[CppDType2["string"] = 3] = "string";
  CppDType2[CppDType2["complex64"] = 4] = "complex64";
})(CppDType || (CppDType = {}));
var FusableActivation;
(function(FusableActivation2) {
  FusableActivation2[FusableActivation2["linear"] = 0] = "linear";
  FusableActivation2[FusableActivation2["relu"] = 1] = "relu";
  FusableActivation2[FusableActivation2["relu6"] = 2] = "relu6";
  FusableActivation2[FusableActivation2["prelu"] = 3] = "prelu";
  FusableActivation2[FusableActivation2["leakyrelu"] = 4] = "leakyrelu";
  FusableActivation2[FusableActivation2["sigmoid"] = 5] = "sigmoid";
  FusableActivation2[FusableActivation2["elu"] = 6] = "elu";
})(FusableActivation || (FusableActivation = {}));
var wasmFusedMatMul;
function setup(backend22) {
  wasmFusedMatMul = backend22.wasm.cwrap(_FusedMatMul, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedBatchMatMul(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2, bias, preluActivationWeights } = inputs;
  if (a6.dtype !== "float32" || b2.dtype !== "float32") {
    throw new Error(`_FusedMatMul for non non-float32 tensors not yet supported.`);
  }
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  const aId = backend22.dataIdMap.get(a6.dataId).id;
  const bId = backend22.dataIdMap.get(b2.dataId).id;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend22.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    biasId = biasData.id;
  }
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend22.dataIdMap.get(preluActivationWeights.dataId).id;
  const fusedActivation = FusableActivation[activation2];
  if (fusedActivation == null) {
    throw new Error(`${activation2} activation not yet supported for FusedConv2D in the wasm backend.`);
  }
  const leftDim = transposeA ? a6.shape[2] : a6.shape[1];
  const rightDim = transposeB ? b2.shape[1] : b2.shape[2];
  const batchDim = a6.shape[0];
  const out = backend22.makeOutput([batchDim, leftDim, rightDim], a6.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const aShapeBytes = new Uint8Array(new Int32Array(a6.shape).buffer);
  const bShapeBytes = new Uint8Array(new Int32Array(b2.shape).buffer);
  wasmFusedMatMul(aId, aShapeBytes, a6.shape.length, bId, bShapeBytes, b2.shape.length, transposeA, transposeB, fusedActivation, biasId, preluActivationWeightsId, leakyreluAlpha || 0, outId);
  return out;
}
var fusedMatMulConfig = {
  kernelName: _FusedMatMul,
  backendName: "wasm",
  setupFunc: setup,
  kernelFunc: fusedBatchMatMul
};
function createUnaryKernelConfig(kernelName) {
  let wasmFunc9;
  function setupFunc3(backend22) {
    wasmFunc9 = backend22.wasm.cwrap(kernelName, null, ["number", "number"]);
  }
  function kernelFunc3(args) {
    const { backend: backend22, inputs: { x: x2 } } = args;
    const xId = backend22.dataIdMap.get(x2.dataId).id;
    const out = backend22.makeOutput(x2.shape, x2.dtype);
    const outId = backend22.dataIdMap.get(out.dataId).id;
    if (util_exports.sizeFromShape(out.shape) === 0) {
      return out;
    }
    wasmFunc9(xId, outId);
    return out;
  }
  return { kernelName, backendName: "wasm", setupFunc: setupFunc3, kernelFunc: kernelFunc3 };
}
var absConfig3 = createUnaryKernelConfig(Abs);
function createBinaryKernelConfig(kernelName, supportsFullBroadcast17, dtype) {
  let wasmFunc9;
  function setupFunc3(backend22) {
    wasmFunc9 = backend22.wasm.cwrap(kernelName, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number"
    ]);
  }
  function kernelFunc3(args) {
    const { backend: backend22, inputs } = args;
    const { a: a6, b: b2 } = inputs;
    const aId = backend22.dataIdMap.get(a6.dataId).id;
    const bId = backend22.dataIdMap.get(b2.dataId).id;
    const outputType = dtype != null ? dtype : a6.dtype;
    const newShape = backend_util_exports.assertAndGetBroadcastShape(a6.shape, b2.shape);
    const out = backend22.makeOutput(newShape, outputType);
    if (util_exports.sizeFromShape(newShape) === 0) {
      return out;
    }
    const aShapeBytes = new Uint8Array(new Int32Array(a6.shape).buffer);
    const bShapeBytes = new Uint8Array(new Int32Array(b2.shape).buffer);
    const outId = backend22.dataIdMap.get(out.dataId).id;
    const kernelFunc4 = () => wasmFunc9(aId, aShapeBytes, a6.shape.length, bId, bShapeBytes, b2.shape.length, CppDType[a6.dtype], outId);
    if (supportsFullBroadcast17 && a6.dtype === "float32") {
      kernelFunc4();
      return out;
    }
    const aBroadcastDims = backend_util_exports.getBroadcastDims(a6.shape, newShape);
    const bBroadcastDims = backend_util_exports.getBroadcastDims(b2.shape, newShape);
    const loopsOverAllOfA = aBroadcastDims.every((v2, i2) => v2 === i2);
    const loopsOverAllOfB = bBroadcastDims.every((v2, i2) => v2 === i2);
    if (loopsOverAllOfA && loopsOverAllOfB) {
      kernelFunc4();
      return out;
    } else {
      throw new Error(`Broadcasting along outer dims is not yet supported for ${a6.dtype} ${kernelName}.`);
    }
  }
  return { kernelName, backendName: "wasm", setupFunc: setupFunc3, kernelFunc: kernelFunc3 };
}
var supportsFullBroadcast = true;
var addConfig3 = createBinaryKernelConfig(Add, supportsFullBroadcast);
var wasmFunc;
function setupFunc(backend22) {
  wasmFunc = backend22.wasm.cwrap(AddN, null, [
    "array",
    "number",
    "number",
    "number"
  ]);
}
function addn(args) {
  const { inputs, backend: backend22 } = args;
  const out = backend22.makeOutput(inputs[0].shape, inputs[0].dtype);
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  const inputIds = inputs.map((x2) => backend22.dataIdMap.get(x2.dataId).id);
  const inputIdsBytes = new Uint8Array(new Int32Array(inputIds).buffer);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmFunc(inputIdsBytes, inputIds.length, CppDType[out.dtype], outId);
  return out;
}
var addNConfig3 = {
  kernelName: AddN,
  backendName: "wasm",
  setupFunc,
  kernelFunc: addn
};
function identity4(args) {
  const { inputs: { x: x2 }, backend: backend22 } = args;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const inVals = backend22.typedArrayFromHeap(x2);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.set(inVals);
  return out;
}
var identityConfig3 = {
  kernelName: Identity,
  backendName: "wasm",
  kernelFunc: identity4
};
var wasmTranspose;
function setup2(backend22) {
  wasmTranspose = backend22.wasm.cwrap(Transpose, null, [
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function transpose4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const [reducedShape, perm] = removeOneSizeDims(inputs.x.shape, attrs.perm);
  let permIsNoOp = true;
  for (let i2 = 0; i2 < perm.length; i2++) {
    if (perm[i2] !== i2) {
      permIsNoOp = false;
    }
  }
  const outShape = computeOutShape4(inputs.x.shape, attrs.perm);
  const x2 = {
    dataId: inputs.x.dataId,
    shape: reducedShape,
    dtype: inputs.x.dtype
  };
  if (permIsNoOp) {
    const cloned = identity4({ inputs, backend: backend22 });
    cloned.shape = outShape;
    return cloned;
  }
  const out = backend22.makeOutput(outShape, x2.dtype);
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const permBytes = new Uint8Array(new Int32Array(perm).buffer);
  const xShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  wasmTranspose(xId, xShapeBytes, x2.shape.length, CppDType[x2.dtype], outId, permBytes, perm.length);
  return out;
}
function computeOutShape4(inShape, perm) {
  const outShape = new Array(inShape.length);
  for (let i2 = 0; i2 < outShape.length; i2++) {
    outShape[i2] = inShape[perm[i2]];
  }
  return outShape;
}
function removeOneSizeDims(shape, perm) {
  const newShape = [];
  const newPerm = [];
  for (let i2 = 0; i2 < shape.length; ++i2) {
    if (shape[i2] !== 1) {
      newShape.push(shape[i2]);
    }
    if (shape[perm[i2]] !== 1) {
      newPerm.push(perm[i2]);
    }
  }
  for (let i2 = 0; i2 < newPerm.length; ++i2) {
    let minValIdx = -1;
    for (let j2 = 0; j2 < newPerm.length; ++j2) {
      if (newPerm[j2] >= i2 && (minValIdx === -1 || newPerm[minValIdx] > newPerm[j2])) {
        minValIdx = j2;
      }
    }
    newPerm[minValIdx] = i2;
  }
  return [newShape, newPerm];
}
var transposeConfig3 = {
  kernelName: Transpose,
  backendName: "wasm",
  kernelFunc: transpose4,
  setupFunc: setup2
};
function permuteAxesAndTranspose(x2, axis, backend22) {
  const xShape = x2.shape;
  const xRank = x2.shape.length;
  const originalAxes = util_exports.parseAxisParam(axis, xShape);
  let axes = originalAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let xTransposed = null;
  let inputWasTransposed = false;
  if (permutedAxes != null) {
    const newShape = new Array(xRank);
    for (let i2 = 0; i2 < newShape.length; i2++) {
      newShape[i2] = xShape[permutedAxes[i2]];
    }
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    xTransposed = transpose4({ inputs: { x: x2 }, attrs: { perm: permutedAxes }, backend: backend22 });
    const xId = backend22.dataIdMap.get(x2.dataId).id;
    const transposedId = backend22.dataIdMap.get(xTransposed.dataId).id;
    if (transposedId !== xId) {
      inputWasTransposed = true;
    }
  }
  return { transposed: xTransposed, originalAxes, axes, inputWasTransposed };
}
var wasmAll;
function setup3(backend22) {
  wasmAll = backend22.wasm.cwrap(All, null, ["number, number, number"]);
}
function all4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    input2 = transposed;
    inputId = transposedId;
  }
  const inputRank = input2.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("all", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, x2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmAll(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var allConfig3 = {
  kernelName: All,
  backendName: "wasm",
  setupFunc: setup3,
  kernelFunc: all4
};
var wasmAny;
function setup4(backend22) {
  wasmAny = backend22.wasm.cwrap(Any, null, ["number, number, number"]);
}
function any4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    input2 = transposed;
    inputId = transposedId;
  }
  const inputRank = input2.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("any", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, x2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmAny(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var anyConfig3 = {
  kernelName: Any,
  backendName: "wasm",
  setupFunc: setup4,
  kernelFunc: any4
};
var wasmFunc2;
function setup5(backend22) {
  wasmFunc2 = backend22.wasm.cwrap(ArgMax, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function argmax(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input2 = transposed;
      inputId = transposedId;
    }
  }
  const outShape = input2.shape.slice(0, -1);
  const out = backend22.makeOutput(outShape, "int32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const outerSize = util_exports.sizeFromShape(out.shape);
  const innerSize = input2.shape[axes[0]];
  wasmFunc2(inputId, CppDType[input2.dtype], outerSize, innerSize, outId);
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  return out;
}
var argMaxConfig3 = {
  kernelName: ArgMax,
  backendName: "wasm",
  kernelFunc: argmax,
  setupFunc: setup5
};
var wasmAvgPool;
function setup6(backend22) {
  wasmAvgPool = backend22.wasm.cwrap(AvgPool, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function avgPool4(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const x2 = inputs.x;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const channels = convInfo.inChannels;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  if (convInfo.dilationWidth !== 1 || convInfo.dilationHeight !== 1) {
    throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${convInfo.dilationHeight}, ${convInfo.dilationWidth}].`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmAvgPool(xId, x2.shape[0], x2.shape[1], x2.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, strideHeight, strideWidth, channels, outId);
  return out;
}
var avgPoolConfig3 = {
  kernelName: AvgPool,
  backendName: "wasm",
  setupFunc: setup6,
  kernelFunc: avgPool4
};
function reshape5(args) {
  const { inputs, attrs } = args;
  const { x: x2 } = inputs;
  const { shape } = attrs;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const $shape = util_exports.inferFromImplicitShape(shape, xSize);
  util_exports.assert(xSize === util_exports.sizeFromShape($shape), () => `new shape: ${$shape}, old shape: ${x2.shape}. New shape and old shape must have the same number of elements.`);
  args.backend.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: $shape, dtype: x2.dtype };
}
var reshapeConfig3 = {
  kernelName: Reshape,
  backendName: "wasm",
  kernelFunc: reshape5
};
var wasmBatchMatMul;
function setup7(backend22) {
  wasmBatchMatMul = backend22.wasm.cwrap(BatchMatMul, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function batchMatMul3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2 } = inputs;
  const { transposeA, transposeB } = attrs;
  if (a6.dtype !== "float32" || b2.dtype !== "float32") {
    throw new Error(`BatchMatMul for non non-float32 tensors not yet supported.`);
  }
  const aRank = a6.shape.length;
  const bRank = b2.shape.length;
  const innerShapeA = transposeA ? a6.shape[aRank - 2] : a6.shape[aRank - 1];
  const innerShapeB = transposeB ? b2.shape[bRank - 1] : b2.shape[bRank - 2];
  const outerShapeA = transposeA ? a6.shape[aRank - 1] : a6.shape[aRank - 2];
  const outerShapeB = transposeB ? b2.shape[bRank - 2] : b2.shape[bRank - 1];
  const outerDimsA = a6.shape.slice(0, -2);
  const outerDimsB = b2.shape.slice(0, -2);
  const batchDimA = util_exports.sizeFromShape(outerDimsA);
  const batchDimB = util_exports.sizeFromShape(outerDimsB);
  const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
  util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
  const outShapeOuterDims = batchDimA > batchDimB ? a6.shape.slice(0, -2) : b2.shape.slice(0, -2);
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a6.shape} and ${b2.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape5({ inputs: { x: a6 }, backend: backend22, attrs: { shape: a3dShape } });
  const b3d = reshape5({ inputs: { x: b2 }, backend: backend22, attrs: { shape: b3dShape } });
  const a3dId = backend22.dataIdMap.get(a3d.dataId).id;
  const b3dId = backend22.dataIdMap.get(b3d.dataId).id;
  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
  const batchDim = Math.max(batchDimA, batchDimB);
  const out = backend22.makeOutput([batchDim, leftDim, rightDim], a3d.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const aShapeBytes = new Uint8Array(new Int32Array(a3d.shape).buffer);
  const bShapeBytes = new Uint8Array(new Int32Array(b3d.shape).buffer);
  wasmBatchMatMul(a3dId, aShapeBytes, a3d.shape.length, b3dId, bShapeBytes, b3d.shape.length, transposeA, transposeB, outId);
  backend22.disposeData(a3d.dataId);
  backend22.disposeData(b3d.dataId);
  out.shape = outShape;
  return out;
}
var batchMatMulConfig3 = {
  kernelName: BatchMatMul,
  backendName: "wasm",
  setupFunc: setup7,
  kernelFunc: batchMatMul3
};
function slice4(args) {
  const { inputs: { x: x2 }, attrs: { begin, size: size2 }, backend: backend22 } = args;
  const [begin_, size_] = slice_util_exports.parseSliceParams(x2, begin, size2);
  const isContinous = slice_util_exports.isSliceContinous(x2.shape, begin_, size_);
  const xVals = backend22.readSync(x2.dataId);
  const out = backend22.makeOutput(size_, x2.dtype);
  const xStrides = util_exports.computeStrides(x2.shape);
  const outData = backend22.dataIdMap.get(out.dataId);
  if (isContinous) {
    const flatOffset = slice_util_exports.computeFlatOffset(begin_, xStrides);
    if (x2.dtype === "string") {
      outData.stringBytes = xVals.slice(flatOffset, flatOffset + util_exports.sizeFromShape(size_));
    } else {
      const outVals2 = backend22.typedArrayFromHeap(out);
      outVals2.set(xVals.subarray(flatOffset, flatOffset + util_exports.sizeFromShape(size_)));
    }
    return out;
  }
  if (x2.dtype === "string") {
    const res2 = sliceImpl(xVals, begin_, size_, x2.shape, x2.dtype);
    outData.stringBytes = res2;
    return out;
  }
  const outVals = backend22.typedArrayFromHeap(out);
  const rank = x2.shape.length;
  if (rank === 2) {
    slice2d2(xVals, xStrides[0], outVals, begin_, size_);
  } else if (rank === 3) {
    slice3d2(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);
  } else if (rank === 4) {
    slice4d2(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);
  } else {
    const res2 = sliceImpl(xVals, begin_, size_, x2.shape, x2.dtype);
    outVals.set(res2);
  }
  return out;
}
function slice2d2(xVals, xStride, outVals, begin, size2) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const endI = beginI + size2[0];
  for (let i2 = beginI; i2 < endI; i2++) {
    const xOffset = i2 * xStride + beginJ;
    outVals.set(xVals.subarray(xOffset, xOffset + size2[1]), outOffset);
    outOffset += size2[1];
  }
}
function slice3d2(xVals, xStride1, xStride2, outVals, begin, size2) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const beginK = begin[2];
  const endI = beginI + size2[0];
  const endJ = beginJ + size2[1];
  for (let i2 = beginI; i2 < endI; i2++) {
    for (let j2 = beginJ; j2 < endJ; j2++) {
      const xOffset = i2 * xStride1 + j2 * xStride2 + beginK;
      outVals.set(xVals.subarray(xOffset, xOffset + size2[2]), outOffset);
      outOffset += size2[2];
    }
  }
}
function slice4d2(xVals, xStride1, xStride2, xStride3, outVals, begin, size2) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const beginK = begin[2];
  const endI = beginI + size2[0];
  const endJ = beginJ + size2[1];
  const endK = beginK + size2[2];
  const beginL = begin[3];
  for (let i2 = beginI; i2 < endI; i2++) {
    for (let j2 = beginJ; j2 < endJ; j2++) {
      for (let k3 = beginK; k3 < endK; k3++) {
        const xOffset = i2 * xStride1 + j2 * xStride2 + k3 * xStride3 + beginL;
        outVals.set(xVals.subarray(xOffset, xOffset + size2[3]), outOffset);
        outOffset += size2[3];
      }
    }
  }
}
var sliceConfig3 = {
  kernelName: Slice,
  backendName: "wasm",
  kernelFunc: slice4
};
function batchToSpaceND4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, crops } = attrs;
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const reshaped = backend_util_exports.getReshaped(x2.shape, blockShape, prod6);
  const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = backend_util_exports.getReshapedPermuted(x2.shape, blockShape, prod6);
  const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const xReshaped = reshape5({ inputs: { x: x2 }, backend: backend22, attrs: { shape: reshaped } });
  const xTransposed = transpose4({ inputs: { x: xReshaped }, backend: backend22, attrs: { perm: permuted } });
  const xTransposedReshaped = reshape5({ inputs: { x: xTransposed }, backend: backend22, attrs: { shape: reshapedPermuted } });
  const result = slice4({
    inputs: { x: xTransposedReshaped },
    backend: backend22,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  backend22.disposeData(xReshaped.dataId);
  backend22.disposeData(xTransposed.dataId);
  backend22.disposeData(xReshaped.dataId);
  return result;
}
var batchToSpaceNDConfig3 = {
  kernelName: BatchToSpaceND,
  backendName: "wasm",
  kernelFunc: batchToSpaceND4
};
function cast5(args) {
  const { inputs: { x: x2 }, attrs: { dtype }, backend: backend22 } = args;
  const out = backend22.makeOutput(x2.shape, dtype);
  const inVals = backend22.typedArrayFromHeap(x2);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.set(inVals);
  return out;
}
var castConfig3 = {
  kernelName: Cast,
  backendName: "wasm",
  kernelFunc: cast5
};
var ceilConfig3 = createUnaryKernelConfig(Ceil);
var wasmClip;
function setup8(backend22) {
  wasmClip = backend22.wasm.cwrap(ClipByValue, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function clip2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { clipValueMin, clipValueMax } = attrs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmClip(xId, clipValueMin, clipValueMax, outId);
  return out;
}
var clipByValueConfig2 = {
  kernelName: ClipByValue,
  backendName: "wasm",
  setupFunc: setup8,
  kernelFunc: clip2
};
function concat4(args) {
  const { inputs, backend: backend22 } = args;
  const axis = util_exports.parseAxisParam(args.attrs.axis, inputs[0].shape)[0];
  let outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), axis);
  const $inputs = inputs.filter((t2) => util_exports.sizeFromShape(t2.shape) > 0);
  if ($inputs.length === 1) {
    return identity4({ inputs: { x: $inputs[0] }, backend: backend22 });
  }
  const out = backend22.makeOutput(outShape, inputs[0].dtype);
  if (util_exports.sizeFromShape(outShape) === 0) {
    return out;
  }
  const shapes = $inputs.map((t2) => t2.shape);
  backend_util_exports.assertParamsConsistent(shapes, axis);
  if ($inputs[0].dtype === "string") {
    const inputs2D = $inputs.map((t2) => {
      const innerSize = util_exports.sizeFromShape(t2.shape.slice(axis));
      const shape = [-1, innerSize];
      return reshape5({ inputs: { x: t2 }, backend: backend22, attrs: { shape } });
    });
    const inputsValShapes = inputs2D.map((t2) => {
      return { vals: backend22.readSync(t2.dataId), shape: t2.shape };
    });
    outShape = backend_util_exports.computeOutShape(inputs2D.map((t2) => t2.shape), 1);
    const simplyConcat = inputs2D[0].shape[0] === 1;
    const outVals2 = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
    const finalOutShape = backend_util_exports.computeOutShape($inputs.map((t2) => t2.shape), axis);
    out.shape = finalOutShape;
    const outData = backend22.dataIdMap.get(out.dataId);
    outData.stringBytes = backend_util_exports.fromStringArrayToUint8(outVals2);
    inputs2D.forEach((t2) => backend22.disposeData(t2.dataId));
    return out;
  }
  const batchDim = util_exports.sizeFromShape($inputs[0].shape.slice(0, axis));
  let sumInnerDims = 0;
  const innerDims = $inputs.map((input2) => {
    const innerDim = util_exports.sizeFromShape(input2.shape.slice(axis));
    sumInnerDims += innerDim;
    return innerDim;
  });
  const inVals = $inputs.map((input2) => backend22.typedArrayFromHeap(input2));
  const outVals = backend22.typedArrayFromHeap(out);
  for (let b2 = 0; b2 < batchDim; b2++) {
    let outOffset = b2 * sumInnerDims;
    for (let i2 = 0; i2 < inVals.length; i2++) {
      const innerDim = innerDims[i2];
      const inOffset = b2 * innerDim;
      const vals = inVals[i2].subarray(inOffset, inOffset + innerDim);
      outVals.set(vals, outOffset);
      outOffset += innerDim;
    }
  }
  return out;
}
var concatConfig3 = {
  kernelName: Concat,
  backendName: "wasm",
  kernelFunc: concat4
};
var wasmConv2d;
function setup9(backend22) {
  wasmConv2d = backend22.wasm.cwrap(Conv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function conv2d5(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2, filter } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const filterId = backend22.dataIdMap.get(filter.dataId).id;
  const { strides, dilations, pad: pad3, dimRoundingMode, dataFormat } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend Conv2D does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmConv2d(xId, x2.shape[0], x2.shape[1], x2.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
var conv2DConfig3 = {
  kernelName: Conv2D,
  backendName: "wasm",
  setupFunc: setup9,
  kernelFunc: conv2d5
};
var wasmConv2DBackpropInput;
function setup10(backend22) {
  wasmConv2DBackpropInput = backend22.wasm.cwrap(Conv2DBackpropInput, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function conv2DBackpropInput4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { dy, filter } = inputs;
  const { strides, pad: pad3, dataFormat, dimRoundingMode, inputShape } = attrs;
  const dilations = 1;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const dxStrides = util_exports.computeStrides(convInfo.inShape);
  const dyStrides = util_exports.computeStrides(dy.shape);
  const [fltS0, fltS1, fltS2] = util_exports.computeStrides(filter.shape);
  const xBatchStride = dxStrides[0];
  const xRowStride = isChannelsLast ? dxStrides[1] : dxStrides[2];
  const xColStride = isChannelsLast ? dxStrides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : dxStrides[1];
  const yBatchStride = dyStrides[0];
  const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
  const yColStride = isChannelsLast ? dyStrides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
  const out = backend22.makeOutput(convInfo.inShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const dyId = backend22.dataIdMap.get(dy.dataId).id;
  const filterId = backend22.dataIdMap.get(filter.dataId).id;
  wasmConv2DBackpropInput(dyId, filterId, batchSize, filterHeight, filterWidth, inHeight, inWidth, inChannels, outHeight, outWidth, outChannels, strideHeight, strideWidth, topPad, leftPad, fltS0, fltS1, fltS2, xBatchStride, xRowStride, xColStride, xChannelStride, yBatchStride, yRowStride, yColStride, yChannelStride, outId);
  return out;
}
var conv2DBackpropInputConfig3 = {
  kernelName: Conv2DBackpropInput,
  backendName: "wasm",
  setupFunc: setup10,
  kernelFunc: conv2DBackpropInput4
};
var cosConfig3 = createUnaryKernelConfig(Cos);
var coshConfig3 = createUnaryKernelConfig(Cosh);
var InterpolationMethod;
(function(InterpolationMethod2) {
  InterpolationMethod2[InterpolationMethod2["bilinear"] = 0] = "bilinear";
  InterpolationMethod2[InterpolationMethod2["nearest"] = 1] = "nearest";
})(InterpolationMethod || (InterpolationMethod = {}));
var wasmCropAndResize;
function setup11(backend22) {
  wasmCropAndResize = backend22.wasm.cwrap(CropAndResize, null, [
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function cropAndResize4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { method, extrapolationValue, cropSize } = attrs;
  const { image: image32, boxes, boxInd } = inputs;
  const numBoxes = boxes.shape[0];
  const [cropHeight, cropWidth] = cropSize;
  const outShape = [numBoxes, cropHeight, cropWidth, image32.shape[3]];
  let imagesData = backend22.dataIdMap.get(image32.dataId);
  let castedData;
  if (image32.dtype !== "float32") {
    castedData = cast5({ backend: backend22, inputs: { x: image32 }, attrs: { dtype: "float32" } });
    imagesData = backend22.dataIdMap.get(castedData.dataId);
  }
  const imagesId = imagesData.id;
  const boxesId = backend22.dataIdMap.get(boxes.dataId).id;
  const boxIndId = backend22.dataIdMap.get(boxInd.dataId).id;
  const out = backend22.makeOutput(outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const imagesShapeBytes = new Uint8Array(new Int32Array(image32.shape).buffer);
  wasmCropAndResize(imagesId, boxesId, boxIndId, numBoxes, imagesShapeBytes, cropHeight, cropWidth, InterpolationMethod[method], extrapolationValue, outId);
  if (castedData != null) {
    backend22.disposeData(castedData.dataId);
  }
  return out;
}
var cropAndResizeConfig3 = {
  kernelName: CropAndResize,
  backendName: "wasm",
  setupFunc: setup11,
  kernelFunc: cropAndResize4
};
var wasmCumsum;
function setup12(backend22) {
  wasmCumsum = backend22.wasm.cwrap(Cumsum, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function cumsum4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, exclusive, reverse: reverse5 } = attrs;
  const xRank = x2.shape.length;
  util_exports.assert(x2.dtype === "float32" || x2.dtype === "int32", () => `cumsum does not support ${x2.dtype} tensors in the WASM backend`);
  const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
  let permutedX = x2;
  if (permutation !== null) {
    permutedX = transpose4({ inputs: { x: x2 }, attrs: { perm: permutation }, backend: backend22 });
  }
  const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
  backend_util_exports.assertAxesAreInnerMostDims("cumsum", [permutedAxis], xRank);
  const permutedOut = backend22.makeOutput(permutedX.shape, permutedX.dtype);
  const finalDim = permutedX.shape[permutedAxis];
  const permutedXId = backend22.dataIdMap.get(permutedX.dataId).id;
  const permutedOutId = backend22.dataIdMap.get(permutedOut.dataId).id;
  wasmCumsum(permutedXId, exclusive ? 1 : 0, reverse5 ? 1 : 0, finalDim, permutedOutId, CppDType[x2.dtype]);
  let out = permutedOut;
  if (permutation !== null) {
    const undoPermutation = backend_util_exports.getUndoAxesPermutation(permutation);
    out = transpose4({ inputs: { x: permutedOut }, attrs: { perm: undoPermutation }, backend: backend22 });
    backend22.disposeData(permutedX.dataId);
    backend22.disposeData(permutedOut.dataId);
  }
  return out;
}
var cumsumConfig3 = {
  kernelName: Cumsum,
  backendName: "wasm",
  setupFunc: setup12,
  kernelFunc: cumsum4
};
var wasmDepthToSpace;
function setup13(backend22) {
  wasmDepthToSpace = backend22.wasm.cwrap(DepthToSpace, null, [
    "number",
    "number",
    "number",
    "array",
    "number",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function depthToSpace4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { x: x2 } = inputs;
  const { blockSize, dataFormat } = attrs;
  util_exports.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  const batchSize = x2.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x2.shape[1] : x2.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x2.shape[2] : x2.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x2.shape[3] : x2.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const out = backend22.makeOutput(outputShape, "float32");
  const xData = backend22.dataIdMap.get(x2.dataId);
  const xId = xData.id;
  const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(x2.shape)).buffer);
  const outputShapeBytes = new Uint8Array(new Int32Array(outputShape).buffer);
  const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(outputShape)).buffer);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const channelsLast = dataFormat === "NHWC" ? 1 : 0;
  wasmDepthToSpace(xId, blockSize, channelsLast, xStridesBytes, x2.shape.length - 1, outputShapeBytes, outStridesBytes, outputShape.length, outId);
  return out;
}
var depthToSpaceConfig3 = {
  kernelName: DepthToSpace,
  backendName: "wasm",
  setupFunc: setup13,
  kernelFunc: depthToSpace4
};
var wasmDepthwiseConv2d;
function setup14(backend22) {
  wasmDepthwiseConv2d = backend22.wasm.cwrap(DepthwiseConv2dNative, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function depthwiseConv2d5(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2, filter } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const filterId = backend22.dataIdMap.get(filter.dataId).id;
  const { strides, dilations, pad: pad3, dimRoundingMode } = attrs;
  const $dilations = dilations == null ? [1, 1] : dilations;
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmDepthwiseConv2d(xId, x2.shape[0], x2.shape[1], x2.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
var depthwiseConv2dNativeConfig3 = {
  kernelName: DepthwiseConv2dNative,
  backendName: "wasm",
  setupFunc: setup14,
  kernelFunc: depthwiseConv2d5
};
var eluConfig3 = createUnaryKernelConfig(Elu);
var supportsFullBroadcast2 = false;
var equalConfig3 = createBinaryKernelConfig(Equal, supportsFullBroadcast2, "bool");
var expConfig3 = createUnaryKernelConfig(Exp);
function expandDims5(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const { dim } = attrs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape5({ inputs: { x: input2 }, backend: backend22, attrs: { shape: newShape } });
}
var expandDimsConfig3 = {
  kernelName: ExpandDims,
  backendName: "wasm",
  kernelFunc: expandDims5
};
function fill4(args) {
  const { attrs: { shape, value, dtype }, backend: backend22 } = args;
  const out = backend22.makeOutput(shape, dtype);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.fill(value);
  return out;
}
var fillConfig3 = {
  kernelName: Fill,
  backendName: "wasm",
  kernelFunc: fill4
};
var wasmFlipLeftRight;
function setup15(backend22) {
  wasmFlipLeftRight = backend22.wasm.cwrap(FlipLeftRight, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function flipLeftRight2(args) {
  const { inputs, backend: backend22 } = args;
  const { image: image32 } = inputs;
  const out = backend22.makeOutput(image32.shape, image32.dtype);
  const imageId = backend22.dataIdMap.get(image32.dataId).id;
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  wasmFlipLeftRight(imageId, batch, imageHeight, imageWidth, numChannels, outId);
  return out;
}
var flipLeftRightConfig3 = {
  kernelName: FlipLeftRight,
  backendName: "wasm",
  kernelFunc: flipLeftRight2,
  setupFunc: setup15
};
var floorConfig3 = createUnaryKernelConfig(Floor);
var supportsFullBroadcast3 = false;
var floorDivConfig3 = createBinaryKernelConfig(FloorDiv, supportsFullBroadcast3);
var wasmBatchNorm;
function setup16(backend22) {
  wasmBatchNorm = backend22.wasm.cwrap(FusedBatchNorm, null, ["number", "number", "number", "number", "number", "number", "number"]);
}
function fusedBatchNorm(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { varianceEpsilon } = attrs;
  const { x: x2, mean: mean5, variance, offset, scale: scale22 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const meanId = backend22.dataIdMap.get(mean5.dataId).id;
  const varianceId = backend22.dataIdMap.get(variance.dataId).id;
  const offsetId = offset != null ? backend22.dataIdMap.get(offset.dataId).id : 0;
  const scaleId = scale22 != null ? backend22.dataIdMap.get(scale22.dataId).id : 0;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  if (util_exports.sizeFromShape(x2.shape) === 0) {
    return out;
  }
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmBatchNorm(xId, meanId, varianceId, offsetId, scaleId, varianceEpsilon, outId);
  return out;
}
var fusedBatchNormConfig = {
  kernelName: FusedBatchNorm,
  backendName: "wasm",
  setupFunc: setup16,
  kernelFunc: fusedBatchNorm
};
var wasmFusedConv2d;
function setup17(backend22) {
  wasmFusedConv2d = backend22.wasm.cwrap(FusedConv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedConv2d2(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dilations, dataFormat, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode);
  const fusedActivation = FusableActivation[activation2];
  if (fusedActivation == null) {
    throw new Error(`${activation2} activation not yet supported for FusedConv2D in the wasm backend.`);
  }
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const filterId = backend22.dataIdMap.get(filter.dataId).id;
  const outputChannels = convInfo.outChannels;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend22.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    if (biasData.shape[0] !== outputChannels) {
      throw new Error(`FusedConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);
    }
    biasId = biasData.id;
  }
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  const batchSize = convInfo.batchSize;
  const inHeight = convInfo.inHeight;
  const inWidth = convInfo.inWidth;
  if (dataFormat !== "NHWC") {
    throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend22.dataIdMap.get(preluActivationWeights.dataId).id;
  wasmFusedConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, leakyreluAlpha || 0, outId);
  return out;
}
var fusedConv2DConfig3 = {
  kernelName: FusedConv2D,
  backendName: "wasm",
  setupFunc: setup17,
  kernelFunc: fusedConv2d2
};
var wasmFusedDepthwiseConv2d;
function setup18(backend22) {
  wasmFusedDepthwiseConv2d = backend22.wasm.cwrap(FusedDepthwiseConv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedDepthwiseConv2d(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dilations, dataFormat, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, true);
  const fusedActivation = FusableActivation[activation2];
  if (fusedActivation == null) {
    throw new Error(`${activation2} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
  }
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const filterId = backend22.dataIdMap.get(filter.dataId).id;
  const outputChannels = convInfo.outChannels;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend22.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    if (biasData.shape[0] !== outputChannels) {
      throw new Error(`FusedDepthwiseConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);
    }
    biasId = biasData.id;
  }
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  const batchSize = convInfo.batchSize;
  const inHeight = convInfo.inHeight;
  const inWidth = convInfo.inWidth;
  if (dataFormat !== "NHWC") {
    throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend22.dataIdMap.get(preluActivationWeights.dataId).id;
  wasmFusedDepthwiseConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, leakyreluAlpha || 0, outId);
  return out;
}
var fusedDepthwiseConv2DConfig3 = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "wasm",
  setupFunc: setup18,
  kernelFunc: fusedDepthwiseConv2d
};
var wasmGatherNd;
function setup19(backend22) {
  wasmGatherNd = backend22.wasm.cwrap(GatherNd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function gatherNd3(args) {
  const { backend: backend22, inputs } = args;
  const { params, indices } = inputs;
  const [resultShape, numSlices, sliceSize, strides] = gather_nd_util_exports.prepareAndValidate(params, indices);
  const out = backend22.makeOutput(resultShape, params.dtype);
  if (numSlices === 0) {
    return out;
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const xData = backend22.dataIdMap.get(params.dataId);
  const xId = xData.id;
  const indicesData = backend22.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmGatherNd(xId, CppDType[params.dtype], indicesId, numSlices, sliceRank, sliceSize, stridesBytes, outId);
  return out;
}
var gatherNdConfig3 = {
  kernelName: GatherNd,
  backendName: "wasm",
  setupFunc: setup19,
  kernelFunc: gatherNd3
};
var wasmGather;
function setup20(backend22) {
  wasmGather = backend22.wasm.cwrap("Gather", null, [
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function gatherV23(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { x: x2, indices } = inputs;
  const { axis, batchDims } = attrs;
  const parsedAxis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x2, indices, parsedAxis, batchDims);
  const flattenX = reshape5({
    inputs: { x: x2 },
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    },
    backend: backend22
  });
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const flattenIndex = reshape5({
    inputs: { x: indices },
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] },
    backend: backend22
  });
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  const out = backend22.makeOutput(flattenOutputShape, x2.dtype);
  if (util_exports.sizeFromShape(x2.shape) === 0) {
    return out;
  }
  const stridesSize = flattenX.shape.length - 1;
  const xData = backend22.dataIdMap.get(flattenX.dataId);
  const xId = xData.id;
  const indicesData = backend22.dataIdMap.get(flattenIndex.dataId);
  const indicesId = indicesData.id;
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(flattenX.shape)).buffer);
  const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(flattenOutputShape)).buffer);
  wasmGather(xId, CppDType[x2.dtype], xStridesBytes, stridesSize, indicesId, shapeInfo.batchSize, outStridesBytes, outId);
  backend22.disposeData(flattenX.dataId);
  backend22.disposeData(flattenIndex.dataId);
  out.shape = shapeInfo.outputShape;
  return out;
}
var gatherV2Config3 = {
  kernelName: GatherV2,
  backendName: "wasm",
  setupFunc: setup20,
  kernelFunc: gatherV23
};
var supportsFullBroadcast4 = false;
var greaterConfig3 = createBinaryKernelConfig(Greater, supportsFullBroadcast4, "bool");
var supportsFullBroadcast5 = false;
var greaterEqualConfig3 = createBinaryKernelConfig(GreaterEqual, supportsFullBroadcast5, "bool");
var wasmFunc3;
function setupFunc2(backend22) {
  wasmFunc3 = backend22.wasm.cwrap(LeakyRelu, null, [
    "number",
    "number",
    "number"
  ]);
}
function leakyRelu4(args) {
  const { inputs: { x: x2 }, attrs: { alpha }, backend: backend22 } = args;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  if (util_exports.sizeFromShape(x2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmFunc3(xId, alpha, outId);
  }
  return out;
}
var leakyReluConfig3 = {
  kernelName: LeakyRelu,
  backendName: "wasm",
  setupFunc: setupFunc2,
  kernelFunc: leakyRelu4
};
var supportsFullBroadcast6 = false;
var lessConfig3 = createBinaryKernelConfig(Less, supportsFullBroadcast6, "bool");
var supportsFullBroadcast7 = false;
var lessEqualConfig3 = createBinaryKernelConfig(LessEqual, supportsFullBroadcast7, "bool");
var logConfig3 = createUnaryKernelConfig(Log);
var supportsFullBroadcast8 = false;
var logicalAndConfig3 = createBinaryKernelConfig(LogicalAnd, supportsFullBroadcast8, "bool");
var wasmMax;
function setup21(backend22) {
  wasmMax = backend22.wasm.cwrap(Max, null, ["number, number, number"]);
}
function max5(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { reductionIndices: axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    input2 = transposed;
    inputId = transposedId;
  }
  const inputRank = input2.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("max", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, x2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmMax(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var maxConfig3 = {
  kernelName: Max,
  backendName: "wasm",
  setupFunc: setup21,
  kernelFunc: max5
};
var supportsFullBroadcast9 = false;
var maximumConfig3 = createBinaryKernelConfig(Maximum, supportsFullBroadcast9);
var wasmMaxPool;
function setup22(backend22) {
  wasmMaxPool = backend22.wasm.cwrap(MaxPool, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function maxPool4(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const x2 = inputs.x;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend22.makeOutput(convInfo.outShape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmMaxPool(xId, x2.shape[0], x2.shape[1], x2.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
var maxPoolConfig3 = {
  kernelName: MaxPool,
  backendName: "wasm",
  setupFunc: setup22,
  kernelFunc: maxPool4
};
var wasmMean;
function setup23(backend22) {
  wasmMean = backend22.wasm.cwrap(Mean, null, ["number, number, number"]);
}
function mean3(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  let reductionAxes = axes;
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input2 = transposed;
      inputId = transposedId;
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, input2.shape.length);
    }
  }
  backend_util_exports.assertAxesAreInnerMostDims("mean", reductionAxes, input2.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, reductionAxes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  let castedInput = input2;
  if (input2.dtype !== "float32") {
    castedInput = cast5({ backend: backend22, inputs: { x: input2 }, attrs: { dtype: "float32" } });
    inputId = backend22.dataIdMap.get(castedInput.dataId).id;
  }
  const out = backend22.makeOutput(outShape, "float32");
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmMean(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  if (input2.dtype !== "float32") {
    backend22.disposeData(castedInput.dataId);
  }
  return out;
}
var meanConfig3 = {
  kernelName: Mean,
  backendName: "wasm",
  setupFunc: setup23,
  kernelFunc: mean3
};
var wasmMin;
function setup24(backend22) {
  wasmMin = backend22.wasm.cwrap(Min, null, ["number, number, number"]);
}
function min5(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input2 = transposed;
      inputId = transposedId;
    }
  }
  const inputRank = input2.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("min", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, input2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmMin(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var minConfig3 = {
  kernelName: Min,
  backendName: "wasm",
  setupFunc: setup24,
  kernelFunc: min5
};
var supportsFullBroadcast10 = false;
var minimumConfig3 = createBinaryKernelConfig(Minimum, supportsFullBroadcast10);
var MirrorPaddingMode;
(function(MirrorPaddingMode2) {
  MirrorPaddingMode2[MirrorPaddingMode2["reflect"] = 0] = "reflect";
  MirrorPaddingMode2[MirrorPaddingMode2["symmetric"] = 1] = "symmetric";
})(MirrorPaddingMode || (MirrorPaddingMode = {}));
var wasmMirrorPad;
function setup25(backend22) {
  wasmMirrorPad = backend22.wasm.cwrap(MirrorPad, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function mirrorPad3(args) {
  const { inputs: { x: x2 }, backend: backend22, attrs: { paddings, mode } } = args;
  const outShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(outShape, x2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const xShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  const prePaddingsFlat = paddings.map((padTuple) => padTuple[0]);
  const postPaddingsFlat = paddings.map((padTuple) => padTuple[1]);
  const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
  const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
  wasmMirrorPad(xId, xShapeBytes, x2.shape.length, CppDType[x2.dtype], prePaddingsBytes, postPaddingsBytes, MirrorPaddingMode[mode], outId);
  return out;
}
var mirrorPadConfig3 = {
  kernelName: MirrorPad,
  backendName: "wasm",
  kernelFunc: mirrorPad3,
  setupFunc: setup25
};
var supportsFullBroadcast11 = true;
var multiplyConfig3 = createBinaryKernelConfig(Multiply, supportsFullBroadcast11);
var negConfig3 = createUnaryKernelConfig(Neg);
function parseResultStruct(backend22, resOffset) {
  const result = new Int32Array(backend22.wasm.HEAPU8.buffer, resOffset, 4);
  const pSelectedIndices = result[0];
  const selectedSize = result[1];
  const pSelectedScores = result[2];
  const pValidOutputs = result[3];
  backend22.wasm._free(resOffset);
  return { pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs };
}
var wasmFunc4;
function setup26(backend22) {
  wasmFunc4 = backend22.wasm.cwrap(NonMaxSuppressionV3, "number", [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function kernelFunc(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { iouThreshold, maxOutputSize, scoreThreshold } = attrs;
  const { boxes, scores } = inputs;
  const boxesId = backend22.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend22.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc4(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold);
  const { pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs } = parseResultStruct(backend22, resOffset);
  backend22.wasm._free(pSelectedScores);
  backend22.wasm._free(pValidOutputs);
  const selectedIndicesTensor = backend22.makeOutput([selectedSize], "int32", pSelectedIndices);
  return selectedIndicesTensor;
}
var nonMaxSuppressionV3Config3 = {
  kernelName: NonMaxSuppressionV3,
  backendName: "wasm",
  setupFunc: setup26,
  kernelFunc
};
var wasmFunc5;
function setup27(backend22) {
  wasmFunc5 = backend22.wasm.cwrap(NonMaxSuppressionV4, "number", [
    "number",
    "number",
    "number",
    "number",
    "number",
    "bool"
  ]);
}
function nonMaxSuppressionV43(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { iouThreshold, maxOutputSize, scoreThreshold, padToMaxOutputSize } = attrs;
  const { boxes, scores } = inputs;
  const boxesId = backend22.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend22.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc5(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  const { pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs } = parseResultStruct(backend22, resOffset);
  backend22.wasm._free(pSelectedScores);
  const selectedIndicesTensor = backend22.makeOutput([selectedSize], "int32", pSelectedIndices);
  const validOutputsTensor = backend22.makeOutput([], "int32", pValidOutputs);
  return [selectedIndicesTensor, validOutputsTensor];
}
var nonMaxSuppressionV4Config3 = {
  kernelName: NonMaxSuppressionV4,
  backendName: "wasm",
  setupFunc: setup27,
  kernelFunc: nonMaxSuppressionV43
};
var wasmFunc6;
function setup28(backend22) {
  wasmFunc6 = backend22.wasm.cwrap(NonMaxSuppressionV5, "number", [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function kernelFunc2(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { iouThreshold, maxOutputSize, scoreThreshold, softNmsSigma } = attrs;
  const { boxes, scores } = inputs;
  const boxesId = backend22.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend22.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc6(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  const { pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs } = parseResultStruct(backend22, resOffset);
  backend22.wasm._free(pValidOutputs);
  const selectedIndicesTensor = backend22.makeOutput([selectedSize], "int32", pSelectedIndices);
  const selectedScoresTensor = backend22.makeOutput([selectedSize], "float32", pSelectedScores);
  return [selectedIndicesTensor, selectedScoresTensor];
}
var nonMaxSuppressionV5Config3 = {
  kernelName: NonMaxSuppressionV5,
  backendName: "wasm",
  setupFunc: setup28,
  kernelFunc: kernelFunc2
};
var supportsFullBroadcast12 = false;
var notEqualConfig3 = createBinaryKernelConfig(NotEqual, supportsFullBroadcast12, "bool");
var wasmOneHot;
function setup29(backend22) {
  wasmOneHot = backend22.wasm.cwrap(OneHot, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function oneHot4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { indices } = inputs;
  const { depth, onValue, offValue } = attrs;
  const out = backend22.makeOutput([...indices.shape, depth], "int32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const indicesData = backend22.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  wasmOneHot(indicesId, depth, onValue, offValue, outId);
  return out;
}
var oneHotConfig3 = {
  kernelName: OneHot,
  backendName: "wasm",
  setupFunc: setup29,
  kernelFunc: oneHot4
};
function onesLike4(args) {
  const { inputs: { x: x2 }, backend: backend22 } = args;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.fill(1);
  return out;
}
var onesLikeConfig3 = {
  kernelName: OnesLike,
  backendName: "wasm",
  kernelFunc: onesLike4
};
function pack3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims5({ inputs: { input: inputs[0] }, backend: backend22, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t2) => {
    util_exports.assertShapesMatch(shape, t2.shape, "All tensors passed to stack must have matching shapes");
    util_exports.assert(dtype === t2.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t2) => {
    const expandedT = expandDims5({ inputs: { input: t2 }, backend: backend22, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat4({ inputs: expandedTensors, backend: backend22, attrs: { axis } });
  intermediateTensorInfos.forEach((t2) => backend22.disposeData(t2.dataId));
  return result;
}
var packConfig3 = {
  kernelName: Pack,
  backendName: "wasm",
  kernelFunc: pack3
};
var wasmPadV2;
function setup30(backend22) {
  wasmPadV2 = backend22.wasm.cwrap(PadV2, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function pad2(args) {
  const { inputs: { x: x2 }, backend: backend22, attrs: { paddings, constantValue } } = args;
  const outShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
  if (util_exports.sizeFromShape(x2.shape) === 0) {
    return fill4({
      backend: backend22,
      attrs: { shape: outShape, value: constantValue, dtype: x2.dtype }
    });
  }
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(outShape, x2.dtype);
  const outTensorData = backend22.dataIdMap.get(out.dataId);
  const outId = outTensorData.id;
  const xShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  const prePaddingsFlat = paddings.map((padTuple) => padTuple[0]);
  const postPaddingsFlat = paddings.map((padTuple) => padTuple[1]);
  const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
  const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
  wasmPadV2(xId, xShapeBytes, x2.shape.length, CppDType[x2.dtype], prePaddingsBytes, postPaddingsBytes, constantValue, outId);
  return out;
}
var padV2Config3 = {
  kernelName: PadV2,
  backendName: "wasm",
  kernelFunc: pad2,
  setupFunc: setup30
};
var supportsFullBroadcast13 = false;
var powConfig3 = createBinaryKernelConfig(Pow, supportsFullBroadcast13);
var wasmPrelu;
function setup31(backend22) {
  wasmPrelu = backend22.wasm.cwrap(Prelu, null, [
    "number",
    "number",
    "number"
  ]);
}
function prelu5(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2, alpha } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const weightsId = backend22.dataIdMap.get(alpha.dataId).id;
  const out = backend22.makeOutput(x2.shape, "float32");
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmPrelu(xId, weightsId, outId);
  return out;
}
var preluConfig3 = {
  kernelName: Prelu,
  backendName: "wasm",
  setupFunc: setup31,
  kernelFunc: prelu5
};
var wasmProd;
function setup32(backend22) {
  wasmProd = backend22.wasm.cwrap(Prod, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function prod4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  let reductionAxes = axes;
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input2 = transposed;
      inputId = transposedId;
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, input2.shape.length);
    }
  }
  backend_util_exports.assertAxesAreInnerMostDims("prod", reductionAxes, input2.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, reductionAxes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, input2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmProd(inputId, reduceSize, CppDType[out.dtype], outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var prodConfig3 = {
  kernelName: Prod,
  backendName: "wasm",
  setupFunc: setup32,
  kernelFunc: prod4
};
var range5 = (args) => {
  const { backend: backend22, attrs } = args;
  const { start, stop, step: step5, dtype } = attrs;
  const values = rangeImpl(start, stop, step5, dtype);
  const out = backend22.makeOutput([values.length], dtype);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.set(values);
  return out;
};
var rangeConfig3 = {
  kernelName: Range,
  backendName: "wasm",
  kernelFunc: range5
};
var supportsFullBroadcast14 = true;
var realDivConfig3 = createBinaryKernelConfig(RealDiv, supportsFullBroadcast14);
var reluConfig3 = createUnaryKernelConfig(Relu);
var relu6Config3 = createUnaryKernelConfig(Relu6);
var wasmResizeBilinear;
function setup33(backend22) {
  wasmResizeBilinear = backend22.wasm.cwrap(ResizeBilinear, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function resizeBilinear4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  const [newHeight, newWidth] = size2;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const outShape = [batch, newHeight, newWidth, numChannels];
  let xData = backend22.dataIdMap.get(images.dataId);
  let castedData;
  if (xData.dtype !== "float32") {
    castedData = cast5({ backend: backend22, inputs: { x: images }, attrs: { dtype: "float32" } });
    xData = backend22.dataIdMap.get(castedData.dataId);
  }
  const xId = xData.id;
  const out = backend22.makeOutput(outShape, "float32");
  if (util_exports.sizeFromShape(images.shape) === 0) {
    return out;
  }
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmResizeBilinear(xId, batch, oldHeight, oldWidth, numChannels, newHeight, newWidth, alignCorners ? 1 : 0, halfPixelCenters ? 1 : 0, outId);
  if (castedData != null) {
    backend22.disposeData(castedData.dataId);
  }
  return out;
}
var resizeBilinearConfig3 = {
  kernelName: ResizeBilinear,
  backendName: "wasm",
  setupFunc: setup33,
  kernelFunc: resizeBilinear4
};
var wasmReverse;
function setup34(backend22) {
  wasmReverse = backend22.wasm.cwrap(Reverse, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function reverse4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dims } = attrs;
  const axes = util_exports.parseAxisParam(dims, x2.shape);
  if (x2.shape.length === 0) {
    return identity4({ inputs: { x: x2 }, backend: backend22 });
  }
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const axesBytes = new Uint8Array(new Int32Array(axes).buffer);
  const outShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  wasmReverse(xId, axesBytes, axes.length, outShapeBytes, x2.shape.length, outId);
  const reshaped = reshape5({ inputs: { x: out }, attrs: { shape: x2.shape }, backend: backend22 });
  backend22.disposeData(out.dataId);
  return reshaped;
}
var reverseConfig3 = {
  kernelName: Reverse,
  backendName: "wasm",
  kernelFunc: reverse4,
  setupFunc: setup34
};
var wasmRotate;
function setup35(backend22) {
  wasmRotate = backend22.wasm.cwrap(RotateWithOffset, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function rotateWithOffset2(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32 } = inputs;
  const { radians, fillValue, center } = attrs;
  const out = backend22.makeOutput(image32.shape, image32.dtype);
  const imageId = backend22.dataIdMap.get(image32.dataId).id;
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const [centerX, centerY] = backend_util_exports.getImageCenter(center, imageHeight, imageWidth);
  const fillIsBlack = fillValue === 0;
  const fullOpacityValue = 255;
  const fillValues2 = typeof fillValue === "number" ? [fillValue, fillValue, fillValue, fillIsBlack ? 0 : fullOpacityValue] : [...fillValue, fullOpacityValue];
  const fillBytes = new Uint8Array(new Int32Array(fillValues2).buffer);
  wasmRotate(imageId, batch, imageHeight, imageWidth, numChannels, radians, centerX, centerY, fillBytes, fillValues2.length, outId);
  return out;
}
var rotateWithOffsetConfig3 = {
  kernelName: RotateWithOffset,
  backendName: "wasm",
  kernelFunc: rotateWithOffset2,
  setupFunc: setup35
};
var roundConfig3 = createUnaryKernelConfig(Round);
var rsqrtConfig3 = createUnaryKernelConfig(Rsqrt);
var wasmScatterNd;
function setup36(backend22) {
  wasmScatterNd = backend22.wasm.cwrap(ScatterNd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function scatterNd3(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const out = backend22.makeOutput(shape, updates.dtype);
  if (util_exports.sizeFromShape(shape) === 0) {
    return out;
  }
  const { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 } = scatter_nd_util_exports.calculateShapes(updates, indices, shape);
  const indicesData = backend22.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  const updatesData = backend22.dataIdMap.get(updates.dataId);
  const updatesId = updatesData.id;
  const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmScatterNd(indicesId, updatesId, CppDType[updates.dtype], sliceRank, numUpdates, sliceSize, stridesBytes, outputSize2, outId);
  return out;
}
var scatterNdConfig3 = {
  kernelName: ScatterNd,
  backendName: "wasm",
  setupFunc: setup36,
  kernelFunc: scatterNd3
};
var wasmSelect;
function setup37(backend22) {
  wasmSelect = backend22.wasm.cwrap("SelectV2", null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function select4(args) {
  const { inputs, backend: backend22 } = args;
  const { condition, t: t2, e: e2 } = inputs;
  const conditionId = backend22.dataIdMap.get(condition.dataId).id;
  const tId = backend22.dataIdMap.get(t2.dataId).id;
  const eId = backend22.dataIdMap.get(e2.dataId).id;
  const out = backend22.makeOutput(t2.shape, t2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const cRank = condition.shape.length;
  const tRank = t2.shape.length;
  const offset = cRank === 0 || cRank > 1 || tRank === 1 ? 1 : util_exports.sizeFromShape(t2.shape.slice(1));
  wasmSelect(conditionId, tId, eId, offset, outId);
  return out;
}
var selectConfig3 = {
  kernelName: Select,
  backendName: "wasm",
  kernelFunc: select4,
  setupFunc: setup37
};
var wasmFunc7;
function setup38(backend22) {
  wasmFunc7 = backend22.wasm.cwrap(Sigmoid, null, ["number", "number"]);
}
function sigmoid4(args) {
  const { backend: backend22, inputs: { x: x2 } } = args;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  wasmFunc7(xId, outId);
  return out;
}
var sigmoidConfig3 = {
  kernelName: "Sigmoid",
  backendName: "wasm",
  setupFunc: setup38,
  kernelFunc: sigmoid4
};
var sinConfig3 = createUnaryKernelConfig(Sin);
var wasmFunc8;
function setup39(backend22) {
  wasmFunc8 = backend22.wasm.cwrap(Softmax, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function softmax5(args) {
  const { backend: backend22, inputs: { logits }, attrs: { dim } } = args;
  const xId = backend22.dataIdMap.get(logits.dataId).id;
  const out = backend22.makeOutput(logits.shape, logits.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const channels = logits.shape[dim];
  const batch = util_exports.sizeFromShape(logits.shape) / channels;
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  wasmFunc8(xId, outId, channels, batch);
  return out;
}
var softmaxConfig3 = {
  kernelName: Softmax,
  backendName: "wasm",
  setupFunc: setup39,
  kernelFunc: softmax5
};
function spaceToBatchND4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, paddings } = attrs;
  const prod6 = util_exports.sizeFromShape(blockShape);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i2 = 1 + blockShape.length; i2 < x2.shape.length; ++i2) {
    completePaddings.push([0, 0]);
  }
  const paddedX = padV2Config3.kernelFunc({
    inputs: { x: x2 },
    backend: backend22,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod6, false);
  const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod6, false);
  const reshapeInputs = { x: paddedX };
  const reshapeAttrs = { shape: reshapedPaddedShape };
  const paddedXReshaped = reshape5({ inputs: reshapeInputs, backend: backend22, attrs: reshapeAttrs });
  const transposeInputs = { x: paddedXReshaped };
  const transposeAttrs = { perm: permutedReshapedPaddedPermutation };
  const paddedXT = transpose4({ inputs: transposeInputs, backend: backend22, attrs: transposeAttrs });
  const resultReshapeInputs = { x: paddedXT };
  const resultReshapeAttrs = { shape: flattenShape };
  const result = reshape5({ inputs: resultReshapeInputs, backend: backend22, attrs: resultReshapeAttrs });
  backend22.disposeData(paddedX.dataId);
  backend22.disposeData(paddedXReshaped.dataId);
  backend22.disposeData(paddedXT.dataId);
  return result;
}
var spaceToBatchNDConfig3 = {
  kernelName: SpaceToBatchND,
  backendName: "wasm",
  kernelFunc: spaceToBatchND4
};
function splitV3(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const splitSizes = backend_util_exports.prepareSplitSize(x2, numOrSizeSplits, $axis);
  const begin = new Array(x2.shape.length).fill(0);
  const size2 = x2.shape.slice();
  return splitSizes.map((s2) => {
    const xSliceSize = [...size2];
    xSliceSize[$axis] = s2;
    const xSlice = slice4({ inputs: { x: x2 }, attrs: { begin, size: xSliceSize }, backend: backend22 });
    begin[$axis] += s2;
    return xSlice;
  });
}
var splitVConfig3 = {
  kernelName: SplitV,
  backendName: "wasm",
  kernelFunc: splitV3
};
var sqrtConfig3 = createUnaryKernelConfig(Sqrt);
var squareConfig3 = createUnaryKernelConfig(Square);
var supportsFullBroadcast15 = true;
var squaredDifferenceConfig3 = createBinaryKernelConfig(SquaredDifference, supportsFullBroadcast15);
var wasmStep;
function setup40(backend22) {
  wasmStep = backend22.wasm.cwrap(Step, null, [
    "number",
    "number",
    "number"
  ]);
}
function step4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { alpha } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmStep(xId, alpha, outId);
  return out;
}
var stepConfig3 = {
  kernelName: Step,
  backendName: "wasm",
  setupFunc: setup40,
  kernelFunc: step4
};
var wasmStridedSlice;
function setup41(backend22) {
  wasmStridedSlice = backend22.wasm.cwrap(StridedSlice, null, [
    "number",
    "array",
    "number",
    "array",
    "array",
    "array",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function stridedSlice4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { x: x2 } = inputs;
  let { begin, end, strides } = attrs;
  if (strides == null) {
    strides = new Array(begin.length);
  }
  const { beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  const ellipsisAxes = backend_util_exports.slice_util.maskToAxes(ellipsisMask);
  if (ellipsisAxes.length > 1) {
    throw new Error("Multiple ellipses in slice is not allowed.");
  }
  if (ellipsisMask !== 0 && newAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  }
  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  }
  const numInterpolatedAxes = x2.shape.length - begin.length;
  const expandAxes = backend_util_exports.slice_util.maskToAxes(newAxisMask);
  const newShape = x2.shape.slice();
  expandAxes.forEach((axis) => {
    begin[axis] = 0;
    end[axis] = 1;
    newShape.splice(axis, 0, 1);
  });
  const xReshaped = reshape5({ inputs: { x: x2 }, attrs: { shape: newShape }, backend: backend22 });
  const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = backend_util_exports.slice_util.getNormalizedAxes(xReshaped.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);
  begin = normalizedBegin;
  end = normalizedEnd;
  strides = normalizedStrides;
  const shrinkAxes = backend_util_exports.slice_util.maskToAxes(shrinkAxisMask);
  shrinkAxes.forEach((axis) => {
    end[axis] = begin[axis] + 1;
    strides[axis] = 1;
  });
  const size2 = backend_util_exports.slice_util.computeOutShape(begin, end, strides);
  const outShape = size2.filter((_2, axis) => shrinkAxes.indexOf(axis) === -1);
  const nonStrided = strides.every((v2) => v2 === 1);
  if (nonStrided) {
    const xSliced = slice4({ inputs: { x: xReshaped }, attrs: { begin, size: size2 }, backend: backend22 });
    backend22.disposeData(xReshaped.dataId);
    const reshaped2 = reshape5({ inputs: { x: xSliced }, attrs: { shape: outShape }, backend: backend22 });
    backend22.disposeData(xSliced.dataId);
    return reshaped2;
  }
  const out = backend22.makeOutput(outShape, "float32");
  if (!outShape.some((axis) => axis === 0)) {
    const xId = backend22.dataIdMap.get(xReshaped.dataId).id;
    const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(xReshaped.shape)).buffer);
    const beginBytes = new Uint8Array(new Int32Array(begin).buffer);
    const endBytes = new Uint8Array(new Int32Array(end).buffer);
    const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
    const outputShapeBytes = new Uint8Array(new Int32Array(outShape).buffer);
    const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(outShape)).buffer);
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmStridedSlice(xId, xStridesBytes, xReshaped.shape.length, beginBytes, endBytes, stridesBytes, outputShapeBytes, outStridesBytes, outShape.length, outId);
  }
  backend22.disposeData(xReshaped.dataId);
  const reshaped = reshape5({ inputs: { x: out }, attrs: { shape: outShape }, backend: backend22 });
  backend22.disposeData(out.dataId);
  return reshaped;
}
var stridedSliceConfig3 = {
  kernelName: StridedSlice,
  backendName: "wasm",
  setupFunc: setup41,
  kernelFunc: stridedSlice4
};
var supportsFullBroadcast16 = true;
var subConfig3 = createBinaryKernelConfig(Sub, supportsFullBroadcast16);
var wasmSum;
function setup42(backend22) {
  wasmSum = backend22.wasm.cwrap(Sum, null, ["number, number, number"]);
}
function sum5(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { axis, keepDims } = attrs;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  let inputId = xId;
  let input2 = x2;
  const { transposed, axes, originalAxes, inputWasTransposed } = permuteAxesAndTranspose(x2, axis, backend22);
  let reductionAxes = axes;
  if (inputWasTransposed) {
    const transposedId = backend22.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input2 = transposed;
      inputId = transposedId;
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, input2.shape.length);
    }
  }
  backend_util_exports.assertAxesAreInnerMostDims("sum", reductionAxes, input2.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, reductionAxes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend22.makeOutput(outShape, input2.dtype);
  if (util_exports.sizeFromShape(input2.shape) !== 0) {
    const outId = backend22.dataIdMap.get(out.dataId).id;
    wasmSum(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend22.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
var sumConfig3 = {
  kernelName: Sum,
  backendName: "wasm",
  setupFunc: setup42,
  kernelFunc: sum5
};
var tanConfig3 = createUnaryKernelConfig(Tan);
var tanhConfig3 = createUnaryKernelConfig(Tanh);
var wasmTile;
function setup43(backend22) {
  wasmTile = backend22.wasm.cwrap(Tile, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function tile5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const { reps } = attrs;
  const newShape = new Array(x2.shape.length);
  for (let i2 = 0; i2 < newShape.length; i2++) {
    newShape[i2] = x2.shape[i2] * reps[i2];
  }
  const xShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  const newShapeBytes = new Uint8Array(new Int32Array(newShape).buffer);
  const out = backend22.makeOutput(newShape, x2.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  wasmTile(xId, xShapeBytes, x2.shape.length, newShapeBytes, newShape.length, CppDType[out.dtype], outId);
  return out;
}
var tileConfig3 = {
  kernelName: Tile,
  backendName: "wasm",
  setupFunc: setup43,
  kernelFunc: tile5
};
var wasmTopK;
function setup44(backend22) {
  wasmTopK = backend22.wasm.cwrap(TopK, null, [
    "number",
    "array",
    "number",
    "number",
    "number",
    "bool",
    "number",
    "number"
  ]);
}
var topk2 = ({ inputs, backend: backend22, attrs }) => {
  const { x: x2 } = inputs;
  const { k: k3, sorted } = attrs;
  const xId = backend22.dataIdMap.get(x2.dataId).id;
  const xShapeBytes = new Uint8Array(new Int32Array(x2.shape).buffer);
  const outputShape = x2.shape.slice();
  outputShape[outputShape.length - 1] = k3;
  const outValues = backend22.makeOutput(outputShape, x2.dtype);
  const outValuesId = backend22.dataIdMap.get(outValues.dataId).id;
  const outIndices = backend22.makeOutput(outputShape, "int32");
  const outIndicesId = backend22.dataIdMap.get(outIndices.dataId).id;
  wasmTopK(xId, xShapeBytes, x2.shape.length, CppDType[x2.dtype], k3, sorted, outValuesId, outIndicesId);
  return [outValues, outIndices];
};
var topKConfig3 = {
  kernelName: TopK,
  backendName: "wasm",
  setupFunc: setup44,
  kernelFunc: topk2
};
var wasmTransform;
function setup45(backend22) {
  wasmTransform = backend22.wasm.cwrap(Transform, null, [
    "number",
    "number",
    "bool",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function transform4(args) {
  const { backend: backend22, inputs, attrs } = args;
  const { image: image32, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [
    batch,
    outHeight,
    outWidth,
    numChannels
  ];
  const strides = new Uint8Array(new Int32Array(util_exports.computeStrides(image32.shape)).buffer);
  const out = backend22.makeOutput(outShape, image32.dtype);
  const outId = backend22.dataIdMap.get(out.dataId).id;
  const imageData = backend22.dataIdMap.get(image32.dataId);
  const imageId = imageData.id;
  const transformsData = backend22.dataIdMap.get(transforms.dataId);
  const transformsId = transformsData.id;
  const interpolationModeId = interpolation === "nearest" ? 1 : 2;
  let fillModeId;
  switch (fillMode) {
    case "constant":
      fillModeId = 1;
      break;
    case "reflect":
      fillModeId = 2;
      break;
    case "wrap":
      fillModeId = 3;
      break;
    case "nearest":
      fillModeId = 4;
      break;
    default:
      fillModeId = 1;
      break;
  }
  wasmTransform(imageId, transformsId, transforms.shape[0] > 1, batch, outHeight, outWidth, numChannels, imageWidth, imageHeight, strides, image32.shape.length - 1, interpolationModeId, fillModeId, fillValue, outId);
  return out;
}
var transformConfig3 = {
  kernelName: Transform,
  backendName: "wasm",
  setupFunc: setup45,
  kernelFunc: transform4
};
function unpack3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const numOutputs = value.shape[axis];
  const rank = value.shape.length;
  const outShape = new Array(rank - 1);
  let outIndex = 0;
  for (let i2 = 0; i2 < rank; i2++) {
    if (i2 !== axis) {
      outShape[outIndex++] = value.shape[i2];
    }
  }
  const outs = new Array(numOutputs);
  const begin = new Array(rank).fill(0);
  const size2 = value.shape.slice();
  size2[axis] = 1;
  for (let i2 = 0; i2 < outs.length; i2++) {
    begin[axis] = i2;
    outs[i2] = slice4({ inputs: { x: value }, attrs: { begin, size: size2 }, backend: backend22 });
  }
  return outs.map(({ dataId, dtype }) => ({ dataId, dtype, shape: outShape }));
}
var unpackConfig3 = {
  kernelName: Unpack,
  backendName: "wasm",
  kernelFunc: unpack3
};
function zerosLike4(args) {
  const { inputs: { x: x2 }, backend: backend22 } = args;
  const out = backend22.makeOutput(x2.shape, x2.dtype);
  const outVals = backend22.typedArrayFromHeap(out);
  outVals.fill(0);
  return out;
}
var zerosLikeConfig3 = {
  kernelName: ZerosLike,
  backendName: "wasm",
  kernelFunc: zerosLike4
};
var kernelConfigs3 = [
  absConfig3,
  addConfig3,
  addNConfig3,
  allConfig3,
  anyConfig3,
  argMaxConfig3,
  avgPoolConfig3,
  batchMatMulConfig3,
  batchToSpaceNDConfig3,
  castConfig3,
  ceilConfig3,
  clipByValueConfig2,
  concatConfig3,
  conv2DConfig3,
  conv2DBackpropInputConfig3,
  cosConfig3,
  coshConfig3,
  cropAndResizeConfig3,
  cumsumConfig3,
  depthToSpaceConfig3,
  depthwiseConv2dNativeConfig3,
  eluConfig3,
  equalConfig3,
  expConfig3,
  expandDimsConfig3,
  fillConfig3,
  flipLeftRightConfig3,
  floorConfig3,
  floorDivConfig3,
  fusedMatMulConfig,
  fusedBatchNormConfig,
  fusedConv2DConfig3,
  fusedDepthwiseConv2DConfig3,
  gatherNdConfig3,
  gatherV2Config3,
  greaterConfig3,
  greaterEqualConfig3,
  identityConfig3,
  leakyReluConfig3,
  lessConfig3,
  lessEqualConfig3,
  logConfig3,
  logicalAndConfig3,
  maxConfig3,
  maximumConfig3,
  maxPoolConfig3,
  meanConfig3,
  minConfig3,
  minimumConfig3,
  mirrorPadConfig3,
  multiplyConfig3,
  negConfig3,
  nonMaxSuppressionV3Config3,
  nonMaxSuppressionV4Config3,
  nonMaxSuppressionV5Config3,
  notEqualConfig3,
  oneHotConfig3,
  onesLikeConfig3,
  packConfig3,
  padV2Config3,
  powConfig3,
  preluConfig3,
  prodConfig3,
  rangeConfig3,
  realDivConfig3,
  reluConfig3,
  relu6Config3,
  reshapeConfig3,
  resizeBilinearConfig3,
  reverseConfig3,
  rotateWithOffsetConfig3,
  rsqrtConfig3,
  roundConfig3,
  scatterNdConfig3,
  selectConfig3,
  sigmoidConfig3,
  sinConfig3,
  sliceConfig3,
  softmaxConfig3,
  spaceToBatchNDConfig3,
  splitVConfig3,
  sqrtConfig3,
  squareConfig3,
  squaredDifferenceConfig3,
  stepConfig3,
  stridedSliceConfig3,
  subConfig3,
  sumConfig3,
  tanConfig3,
  tanhConfig3,
  tileConfig3,
  topKConfig3,
  transformConfig3,
  transposeConfig3,
  unpackConfig3,
  zerosLikeConfig3
];
for (const kernelConfig of kernelConfigs3) {
  registerKernel(kernelConfig);
}
var ENV4 = env();
ENV4.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => WebAssembly.validate(new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  2,
  1,
  0,
  10,
  9,
  1,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
])));
ENV4.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
  if (ENV4.get("IS_NODE")) {
    return false;
  }
  try {
    new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
    return WebAssembly.validate(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      4,
      1,
      96,
      0,
      0,
      3,
      2,
      1,
      0,
      5,
      4,
      1,
      3,
      1,
      1,
      10,
      11,
      1,
      9,
      0,
      65,
      0,
      254,
      16,
      2,
      0,
      26,
      11
    ]));
  } catch (e2) {
    return false;
  }
});
var import_tfjs_backend_wasm_threaded_simd = __toModule(require_tfjs_backend_wasm_threaded_simd());
var wasmWorkerContents = 'var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';
var import_tfjs_backend_wasm = __toModule(require_tfjs_backend_wasm());
var BackendWasm = class extends KernelBackend {
  constructor(wasm) {
    super();
    this.wasm = wasm;
    this.dataIdNextNumber = 1;
    this.wasm.tfjs.init();
    this.dataIdMap = new DataStorage(this, engine());
  }
  write(values, shape, dtype) {
    const dataId = { id: this.dataIdNextNumber++ };
    this.move(dataId, values, shape, dtype, 1);
    return dataId;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  async time(f2) {
    const start = util_exports.now();
    f2();
    const kernelMs = util_exports.now() - start;
    return { kernelMs };
  }
  move(dataId, values, shape, dtype, refCount) {
    const id = this.dataIdNextNumber++;
    if (dtype === "string") {
      const stringBytes = values;
      this.dataIdMap.set(dataId, { id, stringBytes, shape, dtype, memoryOffset: null, refCount });
      return;
    }
    const size2 = util_exports.sizeFromShape(shape);
    const numBytes = size2 * util_exports.bytesPerElement(dtype);
    const memoryOffset = this.wasm._malloc(numBytes);
    this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount });
    this.wasm.tfjs.registerTensor(id, size2, memoryOffset);
    if (values != null) {
      this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);
    }
  }
  async read(dataId) {
    return this.readSync(dataId);
  }
  readSync(dataId) {
    const { memoryOffset, dtype, shape, stringBytes } = this.dataIdMap.get(dataId);
    if (dtype === "string") {
      return stringBytes;
    }
    const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util_exports.sizeFromShape(shape) * util_exports.bytesPerElement(dtype));
    return typedArrayFromBuffer(bytes.buffer, dtype);
  }
  disposeData(dataId, force = false) {
    if (this.dataIdMap.has(dataId)) {
      const data = this.dataIdMap.get(dataId);
      data.refCount--;
      if (!force && data.refCount > 0) {
        return false;
      }
      this.wasm._free(data.memoryOffset);
      this.wasm.tfjs.disposeData(data.id);
      this.dataIdMap.delete(dataId);
    }
    return true;
  }
  refCount(dataId) {
    if (this.dataIdMap.has(dataId)) {
      const tensorData = this.dataIdMap.get(dataId);
      return tensorData.refCount;
    }
    return 0;
  }
  incRef(dataId) {
    const data = this.dataIdMap.get(dataId);
    if (data != null) {
      data.refCount++;
    }
  }
  floatPrecision() {
    return 32;
  }
  getMemoryOffset(dataId) {
    return this.dataIdMap.get(dataId).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose();
    if ("PThread" in this.wasm) {
      this.wasm.PThread.terminateAllThreads();
    }
    this.wasm = null;
  }
  memory() {
    return { unreliable: false };
  }
  makeOutput(shape, dtype, memoryOffset) {
    let dataId;
    if (memoryOffset == null) {
      dataId = this.write(null, shape, dtype);
    } else {
      const id = this.dataIdNextNumber++;
      dataId = { id };
      this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount: 1 });
      const size2 = util_exports.sizeFromShape(shape);
      this.wasm.tfjs.registerTensor(id, size2, memoryOffset);
    }
    return { dataId, shape, dtype };
  }
  typedArrayFromHeap({ shape, dtype, dataId }) {
    const buffer2 = this.wasm.HEAPU8.buffer;
    const { memoryOffset } = this.dataIdMap.get(dataId);
    const size2 = util_exports.sizeFromShape(shape);
    switch (dtype) {
      case "float32":
        return new Float32Array(buffer2, memoryOffset, size2);
      case "int32":
        return new Int32Array(buffer2, memoryOffset, size2);
      case "bool":
        return new Uint8Array(buffer2, memoryOffset, size2);
      default:
        throw new Error(`Unknown dtype ${dtype}`);
    }
  }
};
function createInstantiateWasmFunc(path) {
  return (imports, callback) => {
    util_exports.fetch(path, { credentials: "same-origin" }).then((response) => {
      if (!response["ok"]) {
        imports.env.a(`failed to load wasm binary file at '${path}'`);
      }
      response.arrayBuffer().then((binary) => {
        WebAssembly.instantiate(binary, imports).then((output) => {
          callback(output.instance, output.module);
        });
      });
    });
    return {};
  };
}
function getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {
  if (wasmPath != null) {
    return wasmPath;
  }
  let path = "tfjs-backend-wasm.wasm";
  if (simdSupported && threadsSupported) {
    path = "tfjs-backend-wasm-threaded-simd.wasm";
  } else if (simdSupported) {
    path = "tfjs-backend-wasm-simd.wasm";
  }
  if (wasmFileMap != null) {
    if (wasmFileMap[path] != null) {
      return wasmFileMap[path];
    }
  }
  return wasmModuleFolder + path;
}
async function init() {
  const [simdSupported, threadsSupported] = await Promise.all([
    env().getAsync("WASM_HAS_SIMD_SUPPORT"),
    env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")
  ]);
  return new Promise((resolve, reject) => {
    const factoryConfig = {};
    factoryConfig.locateFile = (path, prefix) => {
      if (path.endsWith(".worker.js")) {
        const response = wasmWorkerContents;
        const blob = new Blob([response], { type: "application/javascript" });
        return URL.createObjectURL(blob);
      }
      if (path.endsWith(".wasm")) {
        return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);
      }
      return prefix + path;
    };
    if (customFetch) {
      factoryConfig.instantiateWasm = createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ""));
    }
    let initialized = false;
    factoryConfig.onAbort = () => {
      if (initialized) {
        return;
      }
      if (initAborted) {
        return;
      }
      initAborted = true;
      const rejectMsg = "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers";
      reject({ message: rejectMsg });
    };
    let wasm;
    if (threadsSupported && simdSupported && wasmPath == null) {
      factoryConfig.mainScriptUrlOrBlob = new Blob([`var WasmBackendModuleThreadedSimd = ` + import_tfjs_backend_wasm_threaded_simd.default.toString()], { type: "text/javascript" });
      wasm = (0, import_tfjs_backend_wasm_threaded_simd.default)(factoryConfig);
    } else {
      wasm = (0, import_tfjs_backend_wasm.default)(factoryConfig);
    }
    wasm.then((module) => {
      initialized = true;
      initAborted = false;
      const voidReturnType = null;
      module.tfjs = {
        init: module.cwrap("init", null, []),
        registerTensor: module.cwrap("register_tensor", null, [
          "number",
          "number",
          "number"
        ]),
        disposeData: module.cwrap("dispose_data", voidReturnType, ["number"]),
        dispose: module.cwrap("dispose", voidReturnType, [])
      };
      resolve({ wasm: module });
    });
  });
}
function typedArrayFromBuffer(buffer2, dtype) {
  switch (dtype) {
    case "float32":
      return new Float32Array(buffer2);
    case "int32":
      return new Int32Array(buffer2);
    case "bool":
      return new Uint8Array(buffer2);
    default:
      throw new Error(`Unknown dtype ${dtype}`);
  }
}
var wasmBinaryNames = [
  "tfjs-backend-wasm.wasm",
  "tfjs-backend-wasm-simd.wasm",
  "tfjs-backend-wasm-threaded-simd.wasm"
];
var wasmPath = null;
var wasmPathPrefix = null;
var wasmFileMap = {};
var initAborted = false;
var customFetch = false;
function setWasmPath(path, usePlatformFetch = false) {
  deprecationWarn("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.");
  if (initAborted) {
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
  }
  wasmPath = path;
  customFetch = usePlatformFetch;
}
function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {
  if (initAborted) {
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
  }
  if (typeof prefixOrFileMap === "string") {
    wasmPathPrefix = prefixOrFileMap;
  } else {
    wasmFileMap = prefixOrFileMap;
    const missingPaths = wasmBinaryNames.filter((name) => wasmFileMap[name] == null);
    if (missingPaths.length > 0) {
      throw new Error(`There were no entries found for the following binaries: ${missingPaths.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
    }
  }
  customFetch = usePlatformFetch;
}
var version8 = "3.9.0";
var WASM_PRIORITY = 2;
registerBackend("wasm", async () => {
  const { wasm } = await init();
  return new BackendWasm(wasm);
}, WASM_PRIORITY);
var ENV5 = env();
ENV5.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
ENV5.registerFlag("WEBGPU_CPU_FORWARD", () => true);
ENV5.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD", () => 4);
ENV5.registerFlag("WEBGPU_USE_NAIVE_CONV2D", () => false);
ENV5.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => false);
ENV5.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
ENV5.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
ENV5.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3);
ENV5.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
ENV5.registerFlag("WEBGPU_USE_IMPORT", () => false);
function symbolicallyComputeStrides2(indicesArr, variableName) {
  if (Math.max(...indicesArr) > 3) {
    throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");
  }
  const numCoords = indicesArr.length;
  const shape = indicesArr.map((d2) => `${variableName}[${d2}]`);
  const strides = new Array(numCoords - 1);
  strides[numCoords - 2] = shape[numCoords - 1];
  for (let i2 = numCoords - 3; i2 >= 0; --i2) {
    strides[i2] = `(${strides[i2 + 1]} * ${shape[i2 + 1]})`;
  }
  return strides;
}
function getCoordsDataType2(rank) {
  if (rank <= 1) {
    return "i32";
  } else if (rank === 2) {
    return `vec2<i32>`;
  } else if (rank === 3) {
    return `vec3<i32>`;
  } else if (rank === 4) {
    return `vec4<i32>`;
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function mapToWgslTypes(type, isVec4) {
  if (type === "float32") {
    return isVec4 ? "vec4<f32>" : "f32";
  } else if (type === "int32") {
    return isVec4 ? "vec4<i32>" : "i32";
  } else if (type === "bool") {
    return isVec4 ? "vec4<i32>" : "i32";
  }
  return type;
}
function getGlobalIndexString() {
  return `
  let index = getGlobalIndex(globalId, localId);
`;
}
function getMainHeaderString() {
  return `
  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>, [[builtin(global_invocation_id)]] globalId : vec3<u32>)
`;
}
function makeShader2(inputInfo, outputData, program, isFromPixel = false) {
  const workGroupSizeSnippet = `
    let workGroupSizeX = ${program.workGroupSize[0]}u;
    let workGroupSizeY = ${program.workGroupSize[1]}u;
    let workGroupSizeZ = ${program.workGroupSize[2]}u;`;
  if (isFromPixel === true) {
    const getCoords5 = generateGetCoordsFromFlatIndex(outputData.shape);
    const outputBufferStr = `
      [[block]] struct Matrix0 {
        numbers: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
      };
      [[block]] struct Uniform {
        size            : i32;
        numChannels     : i32;
        outShapeStrides : vec2<i32>;
        dispatchSize    : vec3<u32>;
      };

      [[group(0), binding(0)]] var<storage, write> result : Matrix0;
      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;
    `;
    return [
      SHADER_PREFIX,
      outputBufferStr,
      workGroupSizeSnippet,
      SAMPLING_SNIPPETS,
      getCoords5,
      program.getUserCode()
    ].join("\n");
  }
  const prefixSnippets = [];
  let uniformDeclaration = "[[block]] struct Uniforms { NAN : f32; ";
  program.variableNames.forEach((x2, i2) => {
    uniformDeclaration += `${x2.charAt(0).toLowerCase() + x2.slice(1)}Shape : ${getCoordsDataType2(inputInfo[i2].shape.length)}; `;
  });
  uniformDeclaration += `outShape : ${getCoordsDataType2(outputData.shape.length)} ; `;
  const stridesLength = outputData.shape.length - 1;
  uniformDeclaration += `
       outShapeStrides: ${getCoordsDataType2(stridesLength)}; `;
  if (program.size != null) {
    uniformDeclaration += "size : i32; ";
  }
  uniformDeclaration += "dispatchSize : vec3<u32>; ";
  if (program.uniforms) {
    uniformDeclaration += program.uniforms;
  }
  uniformDeclaration += "};";
  prefixSnippets.push(uniformDeclaration);
  prefixSnippets.push(`
    [[block]] struct Matrix0 {
        numbers: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
    };

    [[group(0), binding(0)]] var<storage, write> result : Matrix0;
  `);
  program.variableNames.forEach((x2, i2) => {
    prefixSnippets.push(`
    [[block]] struct Matrix${1 + i2} {
      numbers: array<${mapToWgslTypes(inputInfo[i2].dtype, program.isVec4)}>;
    };
    [[group(0), binding(${1 + i2})]] var<storage, read> ${x2} : Matrix${1 + i2};
    `);
  });
  if (uniformDeclaration !== "") {
    prefixSnippets.push(`
    [[group(0), binding(${1 + program.variableNames.length})]] var<uniform> uniforms : Uniforms;
    `);
  }
  prefixSnippets.push(workGroupSizeSnippet);
  const [getOutputCoords, dispatchLayoutRank] = generateGetOutputCoords(outputData.shape, program.dispatchLayout);
  const getCoords4 = generateGetCoordsFromFlatIndex(outputData.shape);
  const sources = [
    SHADER_PREFIX,
    prefixSnippets.join("\n"),
    SAMPLING_SNIPPETS,
    getCoords4,
    getOutputCoords,
    getSetOutputSnippet(outputData.shape, outputData.dtype, program.isVec4)
  ];
  if (dispatchLayoutRank === outputData.shape.length) {
    const inputSamplingSnippet = inputInfo.map((x2) => getInputSamplingSnippet2(x2, outputData.shape, program.isVec4, program.dispatchLayout.x.length === outputData.shape.length)).join("\n");
    sources.push(inputSamplingSnippet);
  }
  sources.push(program.getUserCode());
  const source = sources.join("\n");
  return source;
}
var SHADER_PREFIX = `
  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let mod: i32 = a % b;
    if (sign < 0. && mod != 0) {
      res = res - 1;
    }
    return res;
  }

  fn isNanCustom(val : f32) -> bool {
    if (val > 0.0) {
      return false;
    }
    if (val < 0.0) {
      return false;
    }
    if (val == 0.0) {
      return false;
    }
    return true;
  }

  fn isNanCustomVec4F32(val : vec4<f32>) -> vec4<f32> {
    var res = vec4<f32> (0.0);
    for (var i = 0u; i < 4u; i = i + 1u) {
      if (isNanCustom(val[i])) {
        res[i] = 1.0;
      } else {
        res[i] = 0.0;
      }
    }
    return res;
  }

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) &&
        all(coord < shape);
  }
  `;
var SAMPLING_SNIPPETS = `
  fn getFlatIndex1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }

  fn getFlatIndex2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return i32(dot(vec2<f32>(coords), vec2<f32>(f32(shape.y), 1.0)));
  }

  fn getFlatIndex3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return i32(dot(vec3<f32>(coords), vec3<f32>(f32(shape.y) * f32(shape.z), f32(shape.z), 1.0)));
  }

  fn getFlatIndex4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return i32(dot(vec4<f32>(coords), vec4<f32>(
        f32(shape.y) * f32(shape.z) * f32(shape.w), f32(shape.z) * f32(shape.w), f32(shape.w), 1.0)));
  }

  // Only used when the y/z dimension of workgroup size is 1.
  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>) -> i32 {
    if (uniforms.dispatchSize.y == 1u && uniforms.dispatchSize.z == 1u) {
      return i32(globalId.x);
    }
    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
      localId.y * workGroupSizeX + localId.x;
    let workGroupID = (globalId - localId)/vec3<u32>(
      workGroupSizeX, workGroupSizeY, workGroupSizeZ);
    return i32((workGroupID.z * uniforms.dispatchSize.x * uniforms.dispatchSize.y +
      workGroupID.y * uniforms.dispatchSize.x + workGroupID.x) *
      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
      localInvocationIndex);
  }
`;
function getSetOutputSnippet(outShape, outBufferType, isVec4) {
  const outRank = outShape.length;
  const wgslType = mapToWgslTypes(outBufferType, isVec4);
  let snippet;
  if (isVec4) {
    snippet = `fn setOutputFlat(flatIndex : i32, value : vec4<f32>) {
      result.numbers[flatIndex] = ${wgslType}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : vec4<i32>) {
      result.numbers[flatIndex] = ${wgslType}(value);
    }`;
  } else {
    snippet = `fn setOutputFlat(flatIndex : i32, value : f32) {
      result.numbers[flatIndex] = ${wgslType}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : i32) {
      result.numbers[flatIndex] = ${wgslType}(value);
    }`;
  }
  if (outRank >= 2) {
    switch (outRank) {
      case 2:
        snippet += `
        fn getOutputFlatIndex(coords : vec2<i32>) -> i32 {
          return i32(dot(vec2<f32>(coords), vec2<f32>(f32(uniforms.outShapeStrides), 1.0)));
        }
        `;
        break;
      case 3:
        snippet += `
        fn getOutputFlatIndex(coords : vec3<i32>) -> i32 {
          return i32(dot(vec3<f32>(coords), vec3<f32>(f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), 1.0)));
        }
        `;
        break;
      case 4:
        snippet += `
        fn getOutputFlatIndex(coords : vec4<i32>) -> i32 {
          return i32(dot(vec4<f32>(coords), vec4<f32>(
            f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), f32(uniforms.outShapeStrides.z), 1.0)));
        }
        `;
        break;
      default:
        util_exports.assert(false, () => `Unsupported ${outRank}D shape`);
        break;
    }
    const dims = ["d0", "d1", "d2", "d3"].slice(0, outRank);
    const type = getCoordsDataType2(outRank);
    if (isVec4) {
      snippet += `
      fn setOutput(${dims.map((d2) => `${d2} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputFlatIndex(${type}(${dims.join(", ")}));
        setOutputFlat(flatIndex / 4, value);
      }
      fn setOutputI32(${dims.map((d2) => `${d2} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputFlatIndex(${type}(${dims.join(", ")}));
        setOutputFlatI32(flatIndex / 4, value);
      }
    `;
    } else {
      snippet += `
      fn setOutput(${dims.map((d2) => `${d2} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputFlatIndex(${type}(${dims.join(", ")}));
        setOutputFlat(flatIndex, value);
      }
      fn setOutputI32(${dims.map((d2) => `${d2} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputFlatIndex(${type}(${dims.join(", ")}));
        setOutputFlatI32(flatIndex, value);
      }
    `;
    }
  }
  return snippet;
}
function getInputSamplingSnippet2(inInfo, outShape, isVec4, isFlatDispatchLayout) {
  let res2 = getSamplerFromInInfo2(inInfo, isVec4);
  const inShape = inInfo.shape;
  if (inShape.length <= outShape.length) {
    res2 += getSamplerAtOutputCoords2(inInfo, outShape, isVec4, isFlatDispatchLayout);
  }
  return res2;
}
function getSamplerFromInInfo2(inInfo, isVec4) {
  const texName = inInfo.name;
  const rank = inInfo.shape.length;
  const type = getCoordsDataType2(rank);
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const dims = ["d0", "d1", "d2", "d3"].slice(0, rank);
  const inputs = dims.map((d2) => `${d2} : i32`).join(", ");
  if (rank < 1) {
    if (isVec4) {
      return `
        fn ${funcName}() -> vec4<f32> {
          return vec4<f32>(${texName}.numbers[0]);
        }
      `;
    }
    return `
      fn ${funcName}() ->f32 {
        return f32(${texName}.numbers[0]);
      }
    `;
  }
  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
  let rankStr = `${rank}D`;
  if (rank === 0) {
    rankStr = "1D";
  }
  if (isVec4) {
    return `
      fn ${funcName}(${inputs}) -> vec4<f32> {
        return vec4<f32>(${texName}.numbers[getFlatIndex${rankStr}(${type}(${dims.join(",")}),
          ${shapeStr}) / 4]);
      }
      `;
  }
  return `
    fn ${funcName}(${inputs}) -> f32 {
      return f32(${texName}.numbers[getFlatIndex${rankStr}(${type}(${dims.join(",")}),
        ${shapeStr})]);
    }
   `;
}
function getSamplerAtOutputCoords2(inInfo, outShape, isVec4, isFlatDispatchLayout) {
  const texName = inInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "AtOutCoords";
  const inRank = inInfo.shape.length;
  const outRank = outShape.length;
  const type = getCoordsDataType2(outRank);
  if (util_exports.arraysEqual(inInfo.shape, outShape) && isFlatDispatchLayout) {
    if (isVec4) {
      return `
        fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
          return vec4<f32>(${texName}.numbers[globalIndex]);
        }

        fn ${funcName}ByCoords(coords : ${type}) -> vec4<f32> {
          return vec4<f32>(${texName}.numbers[${outRank > 1 ? "getOutputFlatIndex(coords)" : "coords"} / 4]);
        }
        `;
    } else {
      return `
      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32 {
        return f32(${texName}.numbers[globalIndex]);
      }

      fn ${funcName}ByCoords(coords : ${type}) -> f32 {
        return f32(${texName}.numbers[${outRank > 1 ? "getOutputFlatIndex(coords)" : "coords"}]);
      }
      `;
    }
  }
  const broadcastDims = backend_util_exports.getBroadcastDims(inInfo.shape, outShape);
  const rankDiff = outRank - inRank;
  let coordsSnippet = "";
  if (inRank === 0) {
    if (isVec4) {
      return `
      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
        return get${texFuncSnippet}();
      }

      fn ${funcName}ByCoords(coords : ${type}) -> vec4<f32> {
        return get${texFuncSnippet}();
      }
    `;
    }
    return `
      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32{
        return get${texFuncSnippet}();
      }

      fn ${funcName}ByCoords(coords : ${type}) -> f32{
        return get${texFuncSnippet}();
      }
    `;
  } else {
    if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d2) => `coords[${d2 + rankDiff}] = 0;`).join("\n");
    }
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    if (outRank > 1) {
      const coordsType = getCoordsDataType2(inRank);
      const coordsValues = inInfo.shape.map((s2, i2) => `coords[${i2 + rankDiff}]`).join(", ");
      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;
    } else {
      unpackedCoordsSnippet = "coords";
    }
  }
  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
  const rankStr = `${inRank}D`;
  if (isVec4) {
    return `
      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
        var coords = getOutputCoords(globalId, globalIndex);
        ${coordsSnippet}
        return ${texName}.numbers[getFlatIndex${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
      }

      fn ${funcName}ByCoords(coordsIn : ${type}) -> vec4<f32> {
        var coords = coordsIn;
        ${coordsSnippet}
        return ${texName}.numbers[getFlatIndex${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
      }
    `;
  }
  return `
    fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32 {
      var coords = getOutputCoords(globalId, globalIndex);
      ${coordsSnippet}
      return f32(${texName}.numbers[getFlatIndex${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
    }

    fn ${funcName}ByCoords(coordsIn : ${type}) -> f32 {
      var coords = coordsIn;
      ${coordsSnippet}
      return f32(${texName}.numbers[getFlatIndex${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
    }
  `;
}
function generateGetOutputCoords(outShape, dispatchLayout) {
  const { x: x2, y: y2 = [], z: z2 = [] } = dispatchLayout;
  const outRank = outShape.length;
  if (x2.length === outRank) {
    const dtype2 = getCoordsDataType2(outRank);
    const snippet2 = `fn getOutputCoords(globalId : vec3<u32>, globalIndex : i32) -> ${dtype2}{
      return getCoordsFromFlatIndex(i32(globalIndex));
    }
    `;
    return [snippet2, outRank];
  }
  let gatherDimensionsStr = "";
  const dims = [x2, y2, z2];
  let rank = 0;
  for (let i2 = 0; i2 < dims.length; i2++) {
    const arr = dims[i2];
    if (arr.length === 0) {
      continue;
    }
    rank += arr.length;
    if (arr.length === 1) {
      gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i2}]);`;
    } else {
      const strides = symbolicallyComputeStrides2(arr, "uniforms.outShape");
      gatherDimensionsStr += `var index${i2} = i32(globalId[${i2}]);`;
      for (let j2 = 0; j2 < strides.length; j2++) {
        gatherDimensionsStr += `let d${arr[j2]} = index${i2} / ${strides[j2]};`;
        if (j2 === strides.length - 1) {
          gatherDimensionsStr += `let d${arr[j2 + 1]} = index${i2} - d${arr[j2]} * ${strides[j2]};`;
        } else {
          gatherDimensionsStr += `index${i2} = index${i2} - d${arr[j2]} * ${strides[j2]};`;
        }
      }
    }
  }
  const dimensions = [];
  for (let i2 = 0; i2 < rank; i2++) {
    dimensions.push(`d${i2}`);
  }
  const dtype = getCoordsDataType2(rank);
  let snippet = `fn getOutputCoords(globalId : vec3<u32>, globalIndex : i32) -> ${dtype} {
    ${gatherDimensionsStr}
  `;
  if (dimensions.length === 0) {
    snippet += `return ${dtype}(0); }`;
  } else {
    snippet += `return ${dtype}(${dimensions.join(",")}); }`;
  }
  return [snippet, rank];
}
function generateGetCoordsFromFlatIndex(shape) {
  const rank = shape.length;
  if (rank <= 1) {
    return `fn getCoordsFromFlatIndex(index : i32) -> i32 { return index; }`;
  }
  const strides = util_exports.computeStrides(shape);
  const dtype = getCoordsDataType2(rank);
  const coords32 = [];
  for (let i2 = 0; i2 < rank; i2++) {
    coords32.push(`d${i2}`);
  }
  if (strides.length === 1) {
    return `    fn getCoordsFromFlatIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;
  }
  const snippet = "var index2 = index;" + strides.map((_2, i2) => {
    const line1 = `let ${coords32[i2]} = index2 / uniforms.outShapeStrides[${i2}]`;
    const line2 = i2 === strides.length - 1 ? `let ${coords32[i2 + 1]} = index2 - ${coords32[i2]} * uniforms.outShapeStrides[${i2}]` : `index2 = index2 - ${coords32[i2]} * uniforms.outShapeStrides[${i2}]`;
    return `${line1}; ${line2};`;
  }).join("");
  return `
    fn getCoordsFromFlatIndex(index : i32) -> ${dtype} {
      ${snippet}
      return ${dtype}(${coords32.join(",")});
    }
  `;
}
var webgpu_util_exports = {};
__export2(webgpu_util_exports, {
  ArrayBufferToTypedArray: () => ArrayBufferToTypedArray,
  GPUBytesPerElement: () => GPUBytesPerElement,
  computeDispatch: () => computeDispatch,
  computeWorkGroupSizeForConv2d: () => computeWorkGroupSizeForConv2d,
  computeWorkGroupSizeForMatMul: () => computeWorkGroupSizeForMatMul,
  computeWorkPerThreadForConv2d: () => computeWorkPerThreadForConv2d,
  flatDispatchLayout: () => flatDispatchLayout,
  isWebGPUSupported: () => isWebGPUSupported,
  tilesFitEvenlyIntoShape: () => tilesFitEvenlyIntoShape
});
var MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE = 65535;
var arrayProduct = (arr) => {
  let product = 1;
  for (let i2 = 0; i2 < arr.length; i2++) {
    product *= arr[i2];
  }
  return product;
};
function tilesFitEvenlyIntoShape(tileSize, shape) {
  if (tileSize.length !== shape.length) {
    throw new Error(`Cannot compute whether rank ${tileSize.length} tiles fit evenly into rank ${shape.length} shape - ranks must match.`);
  }
  return shape.every((dim, dimIdx) => dim % tileSize[dimIdx] === 0);
}
function computeDispatch(layout, outputShape, workGroupSize = [1, 1, 1], elementsPerThread = [1, 1, 1]) {
  const [dispatchX, dispatchY, dispatchZ] = [
    Math.ceil(arrayProduct(layout.x.map((d2) => outputShape[d2])) / (workGroupSize[0] * elementsPerThread[0])),
    layout.y ? Math.ceil(arrayProduct(layout.y.map((d2) => outputShape[d2])) / (workGroupSize[1] * elementsPerThread[1])) : 1,
    layout.z ? Math.ceil(arrayProduct(layout.z.map((d2) => outputShape[d2])) / (workGroupSize[2] * elementsPerThread[2])) : 1
  ];
  if (dispatchX <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE && dispatchY <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE && dispatchZ <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {
    return [dispatchX, dispatchY, dispatchZ];
  }
  util_exports.assert(dispatchX > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE && layout.y === void 0 && layout.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
  let dispatchAverage = Math.ceil(Math.sqrt(dispatchX));
  if (dispatchAverage > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {
    dispatchAverage = Math.ceil(Math.cbrt(dispatchX));
    util_exports.assert(dispatchAverage <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE, () => "Total dispatch size exceeds WebGPU maximum.");
    return [dispatchAverage, dispatchAverage, dispatchAverage];
  } else {
    return [dispatchAverage, dispatchAverage, 1];
  }
}
function computeWorkGroupSizeForConv2d(layout, outputShape) {
  const dim0 = arrayProduct(layout.x.map((d2) => outputShape[d2]));
  const dim1 = arrayProduct(layout.y.map((d2) => outputShape[d2]));
  if (dim0 <= 4) {
    return [4, 16, 1];
  }
  if (dim1 <= 4) {
    return [16, 4, 1];
  }
  return [16, 16, 1];
}
function computeWorkGroupSizeForMatMul(dimAOuter, dimInner, dimBOuter) {
  if (dimAOuter === 1) {
    return [32, 1, 1];
  } else if (dimBOuter === 1) {
    return [1, 32, 1];
  }
  return [8, 8, 1];
}
function computeWorkPerThreadForConv2d(layout, outputShape) {
  const dim0 = arrayProduct(layout.x.map((d2) => outputShape[d2]));
  const dim1 = arrayProduct(layout.y.map((d2) => outputShape[d2]));
  if (dim0 <= 4) {
    return [1, 2, 1];
  }
  if (dim1 <= 4) {
    return [2, 1, 1];
  }
  return [2, 2, 1];
}
function flatDispatchLayout(shape) {
  return { x: shape.map((d2, i2) => i2) };
}
function GPUBytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32" || dtype === "bool" || dtype === "string") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function ArrayBufferToTypedArray(data, dtype) {
  if (dtype === "float32") {
    return new Float32Array(data);
  } else if (dtype === "int32") {
    return new Int32Array(data);
  } else if (dtype === "bool" || dtype === "string") {
    const dataAsInt32Array = new Int32Array(data);
    const boolData = new ArrayBuffer(dataAsInt32Array.length);
    const dataAsTypedArray = new Uint8Array(boolData);
    for (let i2 = 0; i2 < dataAsInt32Array.length; i2++) {
      dataAsTypedArray[i2] = dataAsInt32Array[i2];
    }
    return dataAsTypedArray;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function isWebGPUSupported() {
  if (!navigator.gpu) {
    return false;
  }
  return true;
}
var BinaryOpType;
(function(BinaryOpType2) {
  BinaryOpType2[BinaryOpType2["MUL"] = 0] = "MUL";
  BinaryOpType2[BinaryOpType2["ADD"] = 1] = "ADD";
  BinaryOpType2[BinaryOpType2["SUB"] = 2] = "SUB";
  BinaryOpType2[BinaryOpType2["DIV"] = 3] = "DIV";
  BinaryOpType2[BinaryOpType2["EQUAL"] = 4] = "EQUAL";
  BinaryOpType2[BinaryOpType2["GREATER"] = 5] = "GREATER";
  BinaryOpType2[BinaryOpType2["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
  BinaryOpType2[BinaryOpType2["LESS"] = 7] = "LESS";
  BinaryOpType2[BinaryOpType2["LESS_EQUAL"] = 8] = "LESS_EQUAL";
  BinaryOpType2[BinaryOpType2["LOGICAL_AND"] = 9] = "LOGICAL_AND";
  BinaryOpType2[BinaryOpType2["NOT_EQUAL"] = 10] = "NOT_EQUAL";
  BinaryOpType2[BinaryOpType2["SQUARED_DIFFERENCE"] = 11] = "SQUARED_DIFFERENCE";
  BinaryOpType2[BinaryOpType2["INT_DIV"] = 12] = "INT_DIV";
  BinaryOpType2[BinaryOpType2["POW"] = 13] = "POW";
  BinaryOpType2[BinaryOpType2["PRELU"] = 14] = "PRELU";
  BinaryOpType2[BinaryOpType2["MAX"] = 15] = "MAX";
  BinaryOpType2[BinaryOpType2["MIN"] = 16] = "MIN";
  BinaryOpType2[BinaryOpType2["COMPLEX_MULTIPLY_REAL"] = 17] = "COMPLEX_MULTIPLY_REAL";
  BinaryOpType2[BinaryOpType2["COMPLEX_MULTIPLY_IMAG"] = 18] = "COMPLEX_MULTIPLY_IMAG";
})(BinaryOpType || (BinaryOpType = {}));
var ADD2 = "return a + b;";
var COMPLEX_MULTIPLY_REAL = "return areal * breal - aimag * bimag;";
var COMPLEX_MULTIPLY_IMAG = "return areal * bimag + aimag * breal;";
var DIV2 = "return a / b;";
var MUL2 = "return a * b;";
var SQUARED_DIFFERENCE2 = "return (a - b) * (a - b);";
var SUB2 = "return a - b;";
var EQUAL2 = "return f32(a == b);";
var EQUAL_VEC4 = "return vec4<f32>(a == b);";
var GREATER2 = "return f32(a > b);";
var GREATER_VEC4 = "return vec4<f32>(a > b);";
var GREATER_EQUAL2 = "return f32(a >= b);";
var GREATER_EQUAL_VEC4 = "return vec4<f32>(a >= b);";
var LESS2 = "return f32(a < b);";
var LESS_VEC4 = "return vec4<f32>(a < b);";
var LESS_EQUAL2 = "return f32(a <= b);";
var LESS_EQUAL_VEC4 = "return vec4<f32>(a <= b);";
var LOGICAL_AND2 = "return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";
var LOGICAL_AND_VEC4 = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`;
var CHECK_NAN_SNIPPET4 = `
  if (isNanCustom(a)) { return a; }
  if (isNanCustom(b)) { return b; }
  `;
var CHECK_NAN_SNIPPET_VEC4 = `
  if (isNaN.r > 0.) {
    resultTemp.r = uniforms.NAN;
  }
  if (isNaN.g > 0.) {
    resultTemp.g = uniforms.NAN;
  }
  if (isNaN.b > 0.) {
    resultTemp.b = uniforms.NAN;
  }
  if (isNaN.a > 0.) {
    resultTemp.a = uniforms.NAN;
  }
  `;
var INT_DIV2 = `
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `;
var INT_DIV_VEC4 = `
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `;
var NOT_EQUAL2 = "return f32(a != b);";
var NOT_EQUAL_VEC4 = "return vec4<f32>(a != b);";
var POW2 = `
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `;
var POW_VEC4 = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = vec4<f32>(a < vec4<f32>(0.0)) * vec4<f32>(floor(b) < b);
  ${CHECK_NAN_SNIPPET_VEC4}
  return resultTemp;
  `;
var PRELU2 = `if (a < 0.0) { return b * a; }  return a;`;
var PRELU_VEC4 = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;
function getMinMaxString(op2, useVec4) {
  const checkNanSnippet = useVec4 ? CHECK_NAN_SNIPPET_VEC4 : CHECK_NAN_SNIPPET4;
  return useVec4 ? `
    var resultTemp = vec4<f32>(${op2}(a, b));
    let isNaN = min(vec4<f32>(isNanCustomVec4F32(a)) + vec4<f32>(isNanCustomVec4F32(b)), vec4<f32>(1.0));
    ` + checkNanSnippet + `
    return resultTemp;
  ` : checkNanSnippet + `
    return ${op2}(a, b);
  `;
}
function getBinaryOpString(type, useVec4) {
  switch (type) {
    case BinaryOpType.MUL:
      return MUL2;
    case BinaryOpType.ADD:
      return ADD2;
    case BinaryOpType.SUB:
      return SUB2;
    case BinaryOpType.DIV:
      return DIV2;
    case BinaryOpType.EQUAL:
      return useVec4 ? EQUAL_VEC4 : EQUAL2;
    case BinaryOpType.GREATER:
      return useVec4 ? GREATER_VEC4 : GREATER2;
    case BinaryOpType.GREATER_EQUAL:
      return useVec4 ? GREATER_EQUAL_VEC4 : GREATER_EQUAL2;
    case BinaryOpType.LESS:
      return useVec4 ? LESS_VEC4 : LESS2;
    case BinaryOpType.LESS_EQUAL:
      return useVec4 ? LESS_EQUAL_VEC4 : LESS_EQUAL2;
    case BinaryOpType.LOGICAL_AND:
      return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND2;
    case BinaryOpType.NOT_EQUAL:
      return useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL2;
    case BinaryOpType.SQUARED_DIFFERENCE:
      return SQUARED_DIFFERENCE2;
    case BinaryOpType.INT_DIV:
      return useVec4 ? INT_DIV_VEC4 : INT_DIV2;
    case BinaryOpType.PRELU:
      return useVec4 ? PRELU_VEC4 : PRELU2;
    case BinaryOpType.MAX:
      return getMinMaxString("max", useVec4);
    case BinaryOpType.MIN:
      return getMinMaxString("min", useVec4);
    case BinaryOpType.POW:
      return useVec4 ? POW_VEC4 : POW2;
    case BinaryOpType.COMPLEX_MULTIPLY_REAL:
      return COMPLEX_MULTIPLY_REAL;
    case BinaryOpType.COMPLEX_MULTIPLY_IMAG:
      return COMPLEX_MULTIPLY_IMAG;
    default:
      throw new Error(`BinaryType ${type} is not implemented!`);
  }
}
var UnaryOpType;
(function(UnaryOpType2) {
  UnaryOpType2[UnaryOpType2["ABS"] = 0] = "ABS";
  UnaryOpType2[UnaryOpType2["CEIL"] = 1] = "CEIL";
  UnaryOpType2[UnaryOpType2["COS"] = 2] = "COS";
  UnaryOpType2[UnaryOpType2["COSH"] = 3] = "COSH";
  UnaryOpType2[UnaryOpType2["ELU"] = 4] = "ELU";
  UnaryOpType2[UnaryOpType2["EXP"] = 5] = "EXP";
  UnaryOpType2[UnaryOpType2["EXPM1"] = 6] = "EXPM1";
  UnaryOpType2[UnaryOpType2["FLOOR"] = 7] = "FLOOR";
  UnaryOpType2[UnaryOpType2["LINEAR"] = 8] = "LINEAR";
  UnaryOpType2[UnaryOpType2["LOG"] = 9] = "LOG";
  UnaryOpType2[UnaryOpType2["LOGICAL_NOT"] = 10] = "LOGICAL_NOT";
  UnaryOpType2[UnaryOpType2["NEG"] = 11] = "NEG";
  UnaryOpType2[UnaryOpType2["PRELU"] = 12] = "PRELU";
  UnaryOpType2[UnaryOpType2["RELU"] = 13] = "RELU";
  UnaryOpType2[UnaryOpType2["RELU6"] = 14] = "RELU6";
  UnaryOpType2[UnaryOpType2["RSQRT"] = 15] = "RSQRT";
  UnaryOpType2[UnaryOpType2["SIN"] = 16] = "SIN";
  UnaryOpType2[UnaryOpType2["SINH"] = 17] = "SINH";
  UnaryOpType2[UnaryOpType2["SIGMOID"] = 18] = "SIGMOID";
  UnaryOpType2[UnaryOpType2["SQRT"] = 19] = "SQRT";
  UnaryOpType2[UnaryOpType2["SQUARE"] = 20] = "SQUARE";
  UnaryOpType2[UnaryOpType2["TANH"] = 21] = "TANH";
  UnaryOpType2[UnaryOpType2["TO_INT"] = 22] = "TO_INT";
})(UnaryOpType || (UnaryOpType = {}));
var ABS3 = `return abs(a);`;
var CEIL2 = `return ceil(a);`;
var COS2 = `return cos(a);`;
var COSH2 = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;
var EXPM12 = `return exp(a) - 1.0;`;
var ELU5 = `if (a >= 0.0) { return a; }  return (exp(a) - 1.0);`;
var ELU_VEC4 = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
var EXP2 = `return exp(a);`;
var FLOOR2 = `return floor(a);`;
var LINEAR3 = `return a;`;
var LOG2 = `if (a < 0.0) { return 1.0/0.0; }
  return log(a);`;
var LOGICAL_NOT2 = `return f32(!(a >= 1.0));`;
var NEG2 = `return -a;`;
var PRELU3 = `return (a < 0.0) ? b * a : a;`;
var RELU4 = "return max(a, 0.0);";
var RELU64 = "return clamp(a, 0.0, 6.0);";
var RELU6_VEC4 = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));";
var RELU_VEC4 = `
  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));
  let isNaN = isNan(a);

  if (isNaN.r) {
    resFloat.r = a.r;
  }
  if (isNaN.g) {
    resFloat.g = a.g;
  }
  if (isNaN.b) {
    resFloat.b = a.b;
  }
  if (isNaN.a) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
var RSQRT2 = `return 1.0/sqrt(a);`;
var SIGMOID4 = `return 1.0 / (1.0 + exp(-1.0 * a));`;
var SIN2 = `return sin(a);`;
var SINH2 = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;
var SQRT2 = `return sqrt(a);`;
var SQUARE2 = `return a * a;`;
var TANH2 = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;
var TO_INT2 = `return f32(i32((a)));`;
function getUnaryOpString(type, useVec4) {
  switch (type) {
    case UnaryOpType.ABS:
      return ABS3;
    case UnaryOpType.COS:
      return COS2;
    case UnaryOpType.COSH:
      return COSH2;
    case UnaryOpType.CEIL:
      return CEIL2;
    case UnaryOpType.ELU:
      return useVec4 ? ELU_VEC4 : ELU5;
    case UnaryOpType.EXP:
      return EXP2;
    case UnaryOpType.EXPM1:
      return EXPM12;
    case UnaryOpType.FLOOR:
      return FLOOR2;
    case UnaryOpType.LINEAR:
      return LINEAR3;
    case UnaryOpType.LOG:
      return LOG2;
    case UnaryOpType.LOGICAL_NOT:
      return LOGICAL_NOT2;
    case UnaryOpType.NEG:
      return NEG2;
    case UnaryOpType.PRELU:
      return PRELU3;
    case UnaryOpType.RELU:
      return useVec4 ? RELU_VEC4 : RELU4;
    case UnaryOpType.RELU6:
      return useVec4 ? RELU6_VEC4 : RELU64;
    case UnaryOpType.RSQRT:
      return RSQRT2;
    case UnaryOpType.SIGMOID:
      return SIGMOID4;
    case UnaryOpType.SIN:
      return SIN2;
    case UnaryOpType.SINH:
      return SINH2;
    case UnaryOpType.SQRT:
      return SQRT2;
    case UnaryOpType.SQUARE:
      return SQUARE2;
    case UnaryOpType.TANH:
      return TANH2;
    case UnaryOpType.TO_INT:
      return TO_INT2;
    default:
      throw new Error(`BinaryType ${type} is not implemented!`);
  }
}
function mapActivationToShaderProgram2(activation2, packed = false) {
  if (activation2 === null) {
    return null;
  } else if (activation2 === "linear") {
    return getUnaryOpString(UnaryOpType.LINEAR);
  } else if (activation2 === "relu") {
    return getUnaryOpString(UnaryOpType.RELU, packed);
  } else if (activation2 === "elu") {
    return getUnaryOpString(UnaryOpType.ELU, packed);
  } else if (activation2 === "relu6") {
    return getUnaryOpString(UnaryOpType.RELU6, packed);
  } else if (activation2 === "prelu") {
    return getBinaryOpString(BinaryOpType.PRELU, packed);
  } else if (activation2 === "sigmoid") {
    return getUnaryOpString(UnaryOpType.SIGMOID);
  }
  throw new Error(`Activation ${activation2} has not been implemented for the WebGPU backend.`);
}
function makeMatMulPackedVec4Source(workPerThread, workGroupSize) {
  const tileInfo = {
    RowPerThread: workPerThread[1],
    ColPerThread: workPerThread[0],
    TileAOuter: workGroupSize[1] * workPerThread[1],
    TileBOuter: workGroupSize[0] * workPerThread[0],
    TileInner: workGroupSize[0] * workPerThread[0]
  };
  return `
  var<workgroup> mm_Asub : array<array<vec4<f32>, ${tileInfo.TileInner / tileInfo.ColPerThread}>, ${tileInfo.TileAOuter}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${tileInfo.TileBOuter / tileInfo.ColPerThread}>, ${tileInfo.TileInner}>;

  let RowPerThread = ${tileInfo.RowPerThread};
  let ColPerThread = ${tileInfo.ColPerThread}; // only support ColPerThread = 4
  let TileAOuter = ${tileInfo.TileAOuter};
  let TileBOuter = ${tileInfo.TileBOuter};
  let TileInner = ${tileInfo.TileInner};

  ${getMainHeaderString()} {

    let tileRow = i32(localId.y) * RowPerThread;
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * RowPerThread;
    let globalCol = i32(globalId.x);
    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;

    var acc: array<vec4<f32>, ${tileInfo.RowPerThread}>;
    var ACached : vec4<f32>;
    var BCached : array<vec4<f32>, 4>;

    // Loop over shared dimension.
    var globalColA = tileCol;
    let RowPerThreadB = TileInner / ${workGroupSize[1]};
    let tileRowB = i32(localId.y) * RowPerThreadB;
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);
        }
        globalColA = globalColA + TileInner / ColPerThread;

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {
            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];
            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];
            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];
            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];

            for (var i = 0; i < RowPerThread; i = i + 1) {
                ACached = mm_Asub[tileRow + i][k];
                acc[i] = BCached[0] * ACached.x + acc[i];
                acc[i] = BCached[1] * ACached.y + acc[i];
                acc[i] = BCached[2] * ACached.z + acc[i];
                acc[i] = BCached[3] * ACached.w + acc[i];
            }
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(globalRow + innerRow,
                 globalCol,
                 acc[innerRow], globalId);
    }
}`;
}
function makeMatMulVectorVec4Source(workGroupSize) {
  return `
  var<workgroup> mm_Asub : array<vec4<f32>, ${workGroupSize[0]}>;
  let tileSize = ${workGroupSize[0] * 4};
  ${getMainHeaderString()} {
    let tileCol = i32(localId.x);
    let globalCol = i32(globalId.x);
    let globalRow = i32(globalId.y);

    let numTiles = (uniforms.dimInner - 1) / tileSize + 1;

    // Without this initialization strange values show up in acc.
    var acc = vec4<f32>(0.0);

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      let colA = t * tileSize / 4 + tileCol;
      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);

      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileSize / 4; k = k + 1) {
        let rowB = t * tileSize + k * 4;
        let BCached0 = mm_readB(rowB, globalCol, globalId);
        let BCached1 = mm_readB(rowB + 1, globalCol, globalId);
        let BCached2 = mm_readB(rowB + 2, globalCol, globalId);
        let BCached3 = mm_readB(rowB + 3, globalCol, globalId);

        let ACached = mm_Asub[k];
        acc = acc + BCached0 * ACached.x;
        acc = acc + BCached1 * ACached.y;
        acc = acc + BCached2 * ACached.z;
        acc = acc + BCached3 * ACached.w;
      }

      workgroupBarrier();
    }

    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
      mm_write(globalRow, globalCol, acc, globalId);
    }
  }
`;
}
var MatMulPackedVec4Program = class {
  constructor(aShape, outputShape, rowPerThread, bias = null, activation2 = null, preluActivationWeights = null) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;
    this.workGroupSize = [16, 16, 1];
    this.isVec4 = true;
    this.vecSize = 4;
    this.outputShape = outputShape;
    this.workGroupSize = computeWorkGroupSizeForMatMul(outputShape[1], aShape[2], outputShape[2]);
    this.dispatchLayout = { x: [2], y: [1], z: [0] };
    if (outputShape[1] === 1) {
      rowPerThread = 1;
    }
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.vecSize, rowPerThread, 1]);
    const addBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.workPerThread = rowPerThread;
    this.aShape = aShape;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    [this.fitA, this.fitB] = this.getShapeFit();
    this.shaderKey = `matMulPackedVec4_${rowPerThread}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1] > 1}`;
  }
  getShapeFit() {
    const dimInner = this.aShape[2];
    const dimBOuter = this.outputShape[2];
    const bShape = [this.outputShape[0], dimInner, dimBOuter];
    const tileAOuter = this.workGroupSize[1] * this.workPerThread;
    const tileBOuter = this.workGroupSize[0] * this.vecSize;
    const tileInner = tileBOuter;
    const tileSizeA = [tileAOuter, tileInner];
    const tileSizeB = [tileInner, tileBOuter];
    return [
      tilesFitEvenlyIntoShape(tileSizeA, this.aShape.slice(1)),
      tilesFitEvenlyIntoShape(tileSizeB, bShape.slice(1))
    ];
  }
  getUserCode() {
    const sampleA = this.fitA ? `return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]` : `if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];
        }
        return vec4<f32>(0.0)`;
    const sampleB = this.fitB ? `return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]` : `if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];
        }
        return vec4<f32>(0.0)`;
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, this.isVec4);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${activationOp}
                }`;
      } else {
        activationSnippet = `
            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
              ${activationOp}
            }`;
      }
      applyActivationSnippet = "value = activation(value, outCoord);";
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
      ${activationSnippet}
      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${sampleA};
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${sampleB};
      }

      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {
        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])
        {
          var value = valueIn;
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col * 4);
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(outCoord[0], outCoord[1], outCoord[2], value);
        }
      }
      ${this.outputShape[1] > 1 ? makeMatMulPackedVec4Source([this.vecSize, this.workPerThread, 1], this.workGroupSize) : makeMatMulVectorVec4Source(this.workGroupSize)}

    `;
    return userCode;
  }
};
function makeMatMulPackedSource(workPerThread, workGroupSize) {
  const tileAOuter = workGroupSize[1] * workPerThread[1];
  const tileBOuter = workGroupSize[0] * workPerThread[0];
  const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
  return `
    var<workgroup> mm_Asub : array<array<f32, ${tileInner}>, ${tileAOuter}>;
    var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;
    ${getMainHeaderString()} {
      let tileRow = i32(localId.y) * ${workPerThread[1]};
      let tileCol = i32(localId.x) * ${workPerThread[0]};

      let globalRow = i32(globalId.y) * ${workPerThread[1]};
      let globalCol = i32(globalId.x) * ${workPerThread[0]};

      let numTiles = (uniforms.dimInner - 1) / ${tileInner} + 1;

      var acc : array<array<f32, ${workPerThread[0]}>, ${workPerThread[1]}>;
      var ACached : f32;
      var BCached : array<f32, ${workPerThread[0]}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${workPerThread[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${workPerThread[0]}; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let ColPerThreadA = ${tileInner} / ${workGroupSize[0]};
      let tileColA = i32(localId.x) * ColPerThreadA;
      let RowPerThreadB = ${tileInner} / ${workGroupSize[1]};
      let tileRowB = i32(localId.y) * RowPerThreadB;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${workPerThread[1]}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileColA + innerCol;

            mm_Asub[inputRow][inputCol] = mm_readA(
                globalRow + innerRow,
                t * ${tileInner} + inputCol, globalId);
          }
        }
        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${workPerThread[0]}; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;

            mm_Bsub[inputRow][inputCol] = mm_readB(
              t * ${tileInner} + inputRow,
              globalCol + innerCol, globalId);
          }
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${tileInner}; k = k + 1) {
          for (var inner = 0; inner < ${workPerThread[0]}; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < ${workPerThread[1]}; innerRow = innerRow + 1) {
            ACached = mm_Asub[tileRow + innerRow][k];
            for (var innerCol = 0; innerCol < ${workPerThread[0]}; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < ${workPerThread[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${workPerThread[0]}; innerCol = innerCol + 1) {

          if ((globalCol + innerCol) < uniforms.dimBOuter &&
              (globalRow + innerRow) < uniforms.dimAOuter) {
            mm_write(globalRow + innerRow,
                     globalCol + innerCol,
                     acc[innerRow][innerCol], globalId);
          }
        }
      }
    }
  `;
}
function makeMatMulVectorSource(workGroupSize) {
  return `
    let TileSize = ${workGroupSize[0] * 4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${workGroupSize[0]}>;

    ${getMainHeaderString()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;

      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),
                                mm_readA(globalRow, colA + 1, globalId),
                                mm_readA(globalRow, colA + 2, globalId),
                                mm_readA(globalRow, colA + 3, globalId));
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),
                              mm_readB(rowB + 1, globalCol, globalId),
                              mm_readB(rowB + 2, globalCol, globalId),
                              mm_readB(rowB + 3, globalCol, globalId));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
        mm_write(globalRow, globalCol, acc, globalId);
      }
    }
  `;
}
var MatMulPackedProgram2 = class {
  constructor(aShape, outputShape, workPerThread, transposeA = false, transposeB = false, bias = null, activation2 = null, preluActivationWeights = null) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;
    this.workGroupSize = [16, 16, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [2], y: [1], z: [0] };
    const dimInner = transposeA ? aShape[1] : aShape[2];
    this.workGroupSize = computeWorkGroupSizeForMatMul(outputShape[1], dimInner, outputShape[2]);
    if (outputShape[1] === 1 || outputShape[2] === 1) {
      workPerThread = 1;
    }
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [workPerThread, workPerThread, 1]);
    if (util_exports.arraysEqual(this.dispatch, [1, 1, 1])) {
      workPerThread = 1;
      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [workPerThread, workPerThread, 1]);
    }
    const addBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.workPerThread = workPerThread;
    this.aShape = aShape;
    this.transposeA = transposeA;
    this.transposeB = transposeB;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    const dimBOuter = this.outputShape[2];
    const bShape = this.transposeB ? [this.outputShape[0], dimBOuter, dimInner] : [this.outputShape[0], dimInner, dimBOuter];
    [this.fitA, this.fitB] = this.getShapeFit(bShape);
    this.shaderKey = `matMulPacked_${this.workPerThread}_${transposeA}_${transposeB}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1] > 1}`;
  }
  getShapeFit(bShape) {
    const tileAOuter = this.workGroupSize[1] * this.workPerThread;
    const tileBOuter = this.workGroupSize[0] * this.workPerThread;
    let tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
    if (this.outputShape[1] === 1) {
      tileInner *= 4;
    }
    util_exports.assert(tileInner % this.workGroupSize[0] === 0 && tileInner % this.workGroupSize[1] === 0, () => `tileInner must be multiple of workgroupsize.x and workgroupsize.y`);
    const tileSizeA = [tileAOuter, tileInner];
    const tileSizeB = [tileInner, tileBOuter];
    return [
      tilesFitEvenlyIntoShape(tileSizeA, this.aShape.slice(1)),
      tilesFitEvenlyIntoShape(tileSizeB, bShape.slice(1))
    ];
  }
  getUserCode() {
    let sampleA;
    if (this.transposeA === false) {
      sampleA = this.fitA ? `return A.numbers[batch * batchASize + row * uniforms.dimInner + col];` : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
           }
           return 0.0;`;
    } else {
      sampleA = this.fitA ? `return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];` : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];
           }
           return 0.0;`;
    }
    let sampleB;
    if (this.transposeB === false) {
      sampleB = this.fitB ? `return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];` : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
           }
           return 0.0;`;
    } else {
      sampleB = this.fitB ? `return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];` : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];
           }
           return 0.0;`;
    }
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, false);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${activationOp}
            }`;
      } else {
        activationSnippet = `
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${activationOp}
              }
            `;
      }
      applyActivationSnippet = "value = activation(value, outCoord);";
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
      ${activationSnippet}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${sampleA}
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${sampleB}
      }

      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        var value = valueIn;
        let batch = i32(globalId.z);
        let outCoord = vec3<i32>(batch, row, col);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(batch, row, col, value);
      }
      ${this.outputShape[1] > 1 ? makeMatMulPackedSource([this.workPerThread, this.workPerThread, 1], this.workGroupSize) : makeMatMulVectorSource(this.workGroupSize)}
    `;
    return userCode;
  }
};
function makeMatMulSmallOutputSizeSource(workGroupSize) {
  const tileAOuter = workGroupSize[1] / 2;
  const tileBOuter = workGroupSize[0];
  const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
  return `
  var<workgroup> mm_Asub1 : array<array<f32, ${tileInner}>, ${tileAOuter}>;
  var<workgroup> mm_Bsub1 : array<array<f32, ${tileBOuter}>, ${tileInner}>;
  var<workgroup> mm_Asub2 : array<array<f32, ${tileInner}>, ${tileAOuter}>;
  var<workgroup> mm_Bsub2 : array<array<f32, ${tileBOuter}>, ${tileInner}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Introduces two shared memory buffers, some logical threads could handle
  // arithmetic operations and others handle IO operations between barrier api,
  // makes ALUs and load/store units work simultaneously, could improves
  // the performance.
  ${getMainHeaderString()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${tileInner} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = tileRow;
    for (var t = 0; t < numTiles; t = t + 1) {
      if (t == 0) {
        if (tileRow < ${tileAOuter}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${tileInner};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${tileInner};
        }
      } else {
        if (tileRow < ${tileAOuter}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${tileInner};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${tileInner};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${tileInner}; k = k + 1) {
            let subRow = tileRow - ${tileAOuter};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];
          }
        }
      }
      workgroupBarrier();
      if (t != 0) {
        t = t + 1;
      }

      if (t < numTiles) {
        if (tileRow < ${tileAOuter}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub2[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${tileInner};
          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${tileInner};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${tileInner}; k = k + 1) {
            let subRow = tileRow - ${tileAOuter};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];
          }
        }
      }
      workgroupBarrier();
    }
    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${tileAOuter};
    if (tileRow >= ${tileAOuter} && writeCol >= 0) {
      mm_write(writeCol, globalCol, acc, globalId);
    }
  }
  `;
}
var MatMulSmallOutputSizeProgram = class {
  constructor(aShape, bShape, outputShape, bias = null, activation2 = null, preluActivationWeights = null) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;
    this.workGroupSize = [8, 16, 1];
    util_exports.assert(aShape[1] <= 16 || bShape[2] <= 16, () => "This program can be only used when A width or B Height are small");
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [2], y: [1], z: [0] };
    this.dispatch = [
      Math.ceil(outputShape[2] / this.workGroupSize[0]),
      Math.ceil(outputShape[1] * 2 / this.workGroupSize[1]),
      outputShape[0]
    ];
    const addBias = bias != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.shaderKey = `matMulSmallOutputSize_${this.activation}`;
  }
  getUserCode() {
    const sampleA = `if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
        }
        return 0.0;`;
    const sampleB = `if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
         }
         return 0.0;`;
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, false);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
            ${activationOp}
            }`;
      } else {
        activationSnippet = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            ${activationOp}
        }`;
      }
      applyActivationSnippet = "value = activation(value, outCoord);";
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
      ${activationSnippet}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${sampleA}
      }
      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${sampleB}
      }
      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col);
          var value = valueIn;
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(batch, row, col, value);
        }
      }
      ${makeMatMulSmallOutputSizeSource(this.workGroupSize)}
    `;
    return userCode;
  }
};
function reshape6(args) {
  const { inputs, attrs } = args;
  const { x: x2 } = inputs;
  const { shape } = attrs;
  const xSize = util_exports.sizeFromShape(x2.shape);
  const $shape = util_exports.inferFromImplicitShape(shape, xSize);
  const $xSize = util_exports.sizeFromShape($shape);
  util_exports.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x2.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
  args.backend.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: $shape, dtype: x2.dtype };
}
var reshapeConfig4 = {
  kernelName: Reshape,
  backendName: "webgpu",
  kernelFunc: reshape6
};
function batchMatMulImpl2({ a: a6, b: b2, transposeA, transposeB, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const aRank = a6.shape.length;
  const bRank = b2.shape.length;
  const innerShapeA = transposeA ? a6.shape[aRank - 2] : a6.shape[aRank - 1];
  const innerShapeB = transposeB ? b2.shape[bRank - 1] : b2.shape[bRank - 2];
  const outerShapeA = transposeA ? a6.shape[aRank - 1] : a6.shape[aRank - 2];
  const outerShapeB = transposeB ? b2.shape[bRank - 2] : b2.shape[bRank - 1];
  const outerDimsA = a6.shape.slice(0, -2);
  const outerDimsB = b2.shape.slice(0, -2);
  const batchDimA = util_exports.sizeFromShape(outerDimsA);
  const batchDimB = util_exports.sizeFromShape(outerDimsB);
  const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
  util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
  const outShapeOuterDims = batchDimA > batchDimB ? a6.shape.slice(0, -2) : b2.shape.slice(0, -2);
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a6.shape} and ${b2.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape6({ inputs: { x: a6 }, backend: backend22, attrs: { shape: a3dShape } });
  const b3d = reshape6({ inputs: { x: b2 }, backend: backend22, attrs: { shape: b3dShape } });
  const intermediates = [a3d, b3d];
  const batchDim = Math.max(batchDimA, batchDimB);
  const useVec4 = innerShapeA % 4 === 0 && outerShapeB % 4 === 0 && !transposeA && !transposeB && outerShapeB >= 32;
  let program;
  if (!transposeA && !transposeB && (outerShapeA <= 16 && (outerShapeB <= 512 || innerShapeB >= 2 * outerShapeB) || outerShapeB <= 16 && (outerShapeA <= 512 || innerShapeA >= 2 * outerShapeA))) {
    program = new MatMulSmallOutputSizeProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], bias, activation2, preluActivationWeights);
  } else if (useVec4) {
    program = new MatMulPackedVec4Program(a3dShape, [batchDim, outerShapeA, outerShapeB], env().get("WEBGPU_MATMUL_WORK_PER_THREAD"), bias, activation2, preluActivationWeights);
  } else {
    program = new MatMulPackedProgram2(a3dShape, [batchDim, outerShapeA, outerShapeB], env().get("WEBGPU_MATMUL_WORK_PER_THREAD"), transposeA, transposeB, bias, activation2, preluActivationWeights);
  }
  const inputs = [a3d, b3d];
  if (bias) {
    inputs.push(bias);
  }
  if (preluActivationWeights) {
    inputs.push(preluActivationWeights);
  }
  const dimensions = [
    { type: "int32", data: [outerShapeA] },
    { type: "int32", data: [outerShapeB] },
    { type: "int32", data: [innerShapeA] }
  ];
  const out = backend22.runWebGPUProgram(program, inputs, a6.dtype, dimensions);
  const outReshaped = reshape6({ inputs: { x: out }, backend: backend22, attrs: { shape: outShape } });
  intermediates.push(out);
  for (const i2 of intermediates) {
    backend22.disposeData(i2.dataId);
  }
  return outReshaped;
}
function _fusedMatMul3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  return batchMatMulImpl2({
    a: a6,
    b: b2,
    transposeA,
    transposeB,
    backend: backend22,
    bias,
    preluActivationWeights,
    leakyreluAlpha,
    activation: activation2
  });
}
var _fusedMatMulConfig3 = {
  kernelName: _FusedMatMul,
  backendName: "webgpu",
  kernelFunc: _fusedMatMul3
};
var BinaryOpComplexProgram2 = class {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
    this.workGroupSize = [128, 1, 1];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = `binaryOpComplex_${op2}`;
    this.op = op2;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const opStr = getBinaryOpString(this.op, false);
    const userCode = `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${opStr}
      }

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if(index < uniforms.size) {
          let areal = getARealAtOutCoordsByGlobalId(globalId, index);
          let aimag = getAImagAtOutCoordsByGlobalId(globalId, index);
          let breal = getBRealAtOutCoordsByGlobalId(globalId, index);
          let bimag = getBImagAtOutCoordsByGlobalId(globalId, index);
          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    return userCode;
  }
};
var BinaryOpSharedProgram = class {
  constructor(op2, aShape, bShape, useSharedMemoryWithB) {
    this.variableNames = ["A", "B"];
    const workGroupSizeX = 256;
    this.workGroupSize = [workGroupSizeX, 1, 1];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.lastDimensionSize = useSharedMemoryWithB ? bShape[0] : aShape[0];
    if (this.lastDimensionSize < 256) {
      this.workPerThread = 1;
    } else if (this.lastDimensionSize < 512) {
      this.workPerThread = 2;
    } else {
      this.workPerThread = 4;
    }
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.useSharedMemoryWithB = useSharedMemoryWithB;
    this.op = op2;
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.sizeFit = this.size % (this.workGroupSize[0] * this.workPerThread) === 0;
    this.shaderKey = `binaryShared_${op2}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}_${this.sizeFit}`;
  }
  getUserCode() {
    const sharedIndexSnippet = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0";
    const accessDataSnippet = this.useSharedMemoryWithB ? `let a = getAAtOutCoordsByCoords(coords);
         let b = sharedBuf[${sharedIndexSnippet}];` : `let a = sharedBuf[${sharedIndexSnippet}];
         let b = getBAtOutCoordsByCoords(coords);`;
    const writeDataSnippet = this.sizeFit ? `let coords = getCoordsFromFlatIndex(flatIndex);

         ${accessDataSnippet}
         setOutputFlat(flatIndex, binaryOperation(a, b));` : `if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);

            ${accessDataSnippet}
            setOutputFlat(flatIndex, binaryOperation(a, b));
          }`;
    const opStr = getBinaryOpString(this.op, false);
    const userCode = `
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${opStr}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${getMainHeaderString()} {
          ${getGlobalIndexString()}

          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}.numbers[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;

            ${writeDataSnippet}
          }
        }
        `;
    return userCode;
  }
};
var BinaryOpVec4Program = class {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["A", "B"];
    this.workPerThread = 4;
    this.isVec4 = true;
    const workGroupSizeX = 128;
    this.workGroupSize = [workGroupSizeX, 1, 1];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.op = op2;
    this.fitShape = this.size % this.workGroupSize[0] === 0;
    this.shaderKey = `binaryVec4_${op2}_${this.fitShape}`;
    this.size = util_exports.sizeFromShape(this.outputShape) / this.workPerThread;
  }
  getUserCode() {
    let userCode;
    const opStr = getBinaryOpString(this.op, this.isVec4);
    const miscStr = `fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
          ${opStr}
        }`;
    if (this.fitShape) {
      userCode = `
      ${miscStr}
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let a = vec4<f32>(A.numbers[index]);
        let b = vec4<f32>(B.numbers[index]);
        setOutputFlat(index, binaryOperation(a, b));
      }
    `;
    } else {
      userCode = `
      ${miscStr}
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          let a = vec4<f32>(A.numbers[index]);
          let b = vec4<f32>(B.numbers[index]);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
    `;
    }
    return userCode;
  }
};
var BinaryOpProgram2 = class {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["A", "B"];
    const workGroupSizeX = 128;
    this.workGroupSize = [workGroupSizeX, 1, 1];
    this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.sizeFit = this.size % workGroupSizeX === 0;
    this.shapesFit = util_exports.arraysEqual(aShape, bShape) && this.sizeFit;
    this.workPerThread = this.sizeFit || this.shapesFit ? 1 : 2;
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = `binary_${op2}_${this.sizeFit}_${this.shapesFit}`;
    this.op = op2;
  }
  getUserCode() {
    let userCode;
    const opStr = getBinaryOpString(this.op, false);
    const miscStr = `          fn binaryOperation(a : f32, b : f32) -> f32 {
      ${opStr}
    }`;
    if (this.shapesFit) {
      userCode = `
          ${miscStr}
          ${getMainHeaderString()} {
            ${getGlobalIndexString()}

            let a = f32(A[index]);
            let b = f32(B[index]);
            setOutputFlat(index, binaryOperation(a, b));
          }
        `;
    } else if (this.sizeFit) {
      userCode = `
      ${miscStr}
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}

        let coords = getCoordsFromFlatIndex(index);

        let a = getAAtOutCoordsByCoords(coords);
        let b = getBAtOutCoordsByCoords(coords);
        setOutputFlat(index, binaryOperation(a, b));
      }
      `;
    } else {
      userCode = `
      ${miscStr}
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1 ) {
          let flatIndex = index * ${this.workPerThread} + i;

          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);

            let a = getAAtOutCoordsByCoords(coords);
            let b = getBAtOutCoordsByCoords(coords);
            setOutputFlat(flatIndex, binaryOperation(a, b));
          }
        }
      }
      `;
    }
    return userCode;
  }
};
function getBinaryProgram(op2, aShape, bShape) {
  const useVec4 = util_exports.arraysEqual(aShape, bShape) && util_exports.sizeFromShape(aShape) % 4 === 0;
  if (useVec4) {
    return new BinaryOpVec4Program(op2, aShape, bShape);
  }
  const useSharedMemoryWithA = aShape.length === 1 && bShape.length > 1 && aShape[0] < 1024;
  const useSharedMemoryWithB = bShape.length === 1 && aShape.length > 1 && bShape[0] < 1024;
  if (useSharedMemoryWithA || useSharedMemoryWithB) {
    return new BinaryOpSharedProgram(op2, aShape, bShape, useSharedMemoryWithB);
  } else {
    return new BinaryOpProgram2(op2, aShape, bShape);
  }
}
function identity5(args) {
  const { inputs } = args;
  const { x: x2 } = inputs;
  args.backend.incRef(x2.dataId);
  return { dataId: x2.dataId, shape: x2.shape, dtype: x2.dtype };
}
var identityConfig4 = {
  kernelName: Identity,
  backendName: "webgpu",
  kernelFunc: identity5
};
function complex4(args) {
  const { inputs, backend: backend22 } = args;
  const { real: real5, imag: imag5 } = inputs;
  const complexInfo = backend22.makeTensorInfo(real5.shape, "complex64");
  const complex5 = backend22.tensorMap.get(complexInfo.dataId);
  const realTensorInfo = identity5({ inputs: { x: real5 }, backend: backend22 });
  const imagTensorInfo = identity5({ inputs: { x: imag5 }, backend: backend22 });
  complex5.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
  return complexInfo;
}
var complexConfig3 = {
  kernelName: Complex,
  backendName: "webgpu",
  kernelFunc: complex4
};
var UnaryOpProgram2 = class {
  constructor(outputShape, op2) {
    this.variableNames = ["A"];
    const workGroupSizeX = 128;
    this.workGroupSize = [workGroupSizeX, 1, 1];
    this.outputShape = outputShape;
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.op = op2;
    this.shaderKey = `unary_${op2}`;
  }
  getUserCode() {
    return `
      fn unaryOperation(a : f32) -> f32 {
        ${getUnaryOpString(this.op, false)}
      }
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalId(globalId, index);
          setOutputFlat(index, unaryOperation(a));
        }
      }
      `;
  }
};
function unaryKernelFunc3({ opType, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const webgpuBackend = backend22;
    const $dtype = dtype || x2.dtype;
    if (webgpuBackend.shouldExecuteOnCPU([x2]) && cpuKernelImpl != null) {
      const xData = webgpuBackend.tensorMap.get(x2.dataId);
      const outValues = cpuKernelImpl(xData.values, $dtype);
      return webgpuBackend.makeTensorInfo(x2.shape, $dtype, outValues);
    }
    const program = new UnaryOpProgram2(x2.shape, opType);
    return webgpuBackend.runWebGPUProgram(program, [x2], $dtype);
  };
}
function binaryKernelFunc3({ opSnippet, cpuKernelImpl, supportsComplex = false, dtype }) {
  return ({ inputs, backend: backend22 }) => {
    const { a: a6, b: b2 } = inputs;
    const webgpuBackend = backend22;
    if (supportsComplex && a6.dtype === "complex64") {
      const aData = webgpuBackend.tensorMap.get(a6.dataId);
      const bData = webgpuBackend.tensorMap.get(b2.dataId);
      let real5, imag5;
      if (opSnippet !== BinaryOpType.MUL) {
        [real5, imag5] = [
          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
        ].map((complexParts) => {
          const [aPart, bPart] = complexParts;
          const aHandle = {
            dataId: aPart.dataId,
            dtype: aPart.dtype,
            shape: a6.shape
          };
          const bHandle = {
            dataId: bPart.dataId,
            dtype: bPart.dtype,
            shape: b2.shape
          };
          const program2 = getBinaryProgram(opSnippet, a6.shape, b2.shape);
          return webgpuBackend.runWebGPUProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
        });
      } else {
        const realProgram = new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_REAL, a6.shape, b2.shape);
        const imagProgram = new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_IMAG, a6.shape, b2.shape);
        const inputs2 = [
          {
            dataId: aData.complexTensorInfos.real.dataId,
            dtype: aData.complexTensorInfos.real.dtype,
            shape: a6.shape
          },
          {
            dataId: aData.complexTensorInfos.imag.dataId,
            dtype: aData.complexTensorInfos.imag.dtype,
            shape: a6.shape
          },
          {
            dataId: bData.complexTensorInfos.real.dataId,
            dtype: bData.complexTensorInfos.real.dtype,
            shape: b2.shape
          },
          {
            dataId: bData.complexTensorInfos.imag.dataId,
            dtype: bData.complexTensorInfos.imag.dtype,
            shape: b2.shape
          }
        ];
        real5 = webgpuBackend.runWebGPUProgram(realProgram, inputs2, "float32");
        imag5 = webgpuBackend.runWebGPUProgram(imagProgram, inputs2, "float32");
      }
      const complexOutput = complex4({ inputs: { real: real5, imag: imag5 }, backend: webgpuBackend });
      webgpuBackend.disposeData(real5.dataId);
      webgpuBackend.disposeData(imag5.dataId);
      return complexOutput;
    }
    const $dtype = dtype || upcastType(a6.dtype, b2.dtype);
    if ((a6.dtype === "string" || b2.dtype === "string" || webgpuBackend.shouldExecuteOnCPU([a6, b2])) && cpuKernelImpl != null) {
      const aData = webgpuBackend.tensorMap.get(a6.dataId).values;
      const bData = webgpuBackend.tensorMap.get(b2.dataId).values;
      const decodedAVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aData) : aData;
      const decodedBVals = a6.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bData) : bData;
      const [outValues, outShape] = cpuKernelImpl(a6.shape, b2.shape, decodedAVals, decodedBVals, $dtype);
      return webgpuBackend.makeTensorInfo(outShape, $dtype, outValues);
    }
    const program = getBinaryProgram(opSnippet, a6.shape, b2.shape);
    return webgpuBackend.runWebGPUProgram(program, [a6, b2], $dtype);
  };
}
var { addImpl: addImplCPU2, ceilImpl: ceilImplCPU2, concatImpl: concatImplCPU2, equalImpl: equalImplCPU2, expImpl: expImplCPU2, expm1Impl: expm1ImplCPU2, floorImpl: floorImplCPU2, gatherNdImpl: gatherNdImplCPU2, gatherV2Impl: gatherV2ImplCPU2, greaterEqualImpl: greaterEqualImplCPU2, greaterImpl: greaterImplCPU2, lessEqualImpl: lessEqualImplCPU2, lessImpl: lessImplCPU2, logImpl: logImplCPU2, maxImpl: maxImplCPU2, maximumImpl: maximumImplCPU2, minimumImpl: minimumImplCPU2, multiplyImpl: multiplyImplCPU2, negImpl: negImplCPU2, notEqualImpl: notEqualImplCPU2, prodImpl: prodImplCPU2, rangeImpl: rangeImplCPU2, rsqrtImpl: rsqrtImplCPU2, simpleAbsImpl: simpleAbsImplCPU2, sliceImpl: sliceImplCPU2, stridedSliceImpl: stridedSliceImplCPU2, stringNGramsImpl: stringNGramsImplCPU2, subImpl: subImplCPU2, tileImpl: tileImplCPU2, transposeImpl: transposeImplCPU2, uniqueImpl: uniqueImplCPU2 } = shared_exports;
var abs4 = unaryKernelFunc3({ opType: UnaryOpType.ABS, cpuKernelImpl: simpleAbsImplCPU2 });
var absConfig4 = {
  kernelName: Abs,
  backendName: "webgpu",
  kernelFunc: abs4
};
var addKernelFunc2 = binaryKernelFunc3({
  opSnippet: BinaryOpType.ADD,
  cpuKernelImpl: addImplCPU2,
  supportsComplex: true
});
var addConfig4 = {
  kernelName: Add,
  backendName: "webgpu",
  kernelFunc: addKernelFunc2
};
var AddNPackedProgram2 = class {
  constructor(shapes) {
    this.workPerThread = 4;
    this.workGroupSize = [64, 1, 1];
    this.outputShape = shapes[0];
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = "addN";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`let v${variable2} = get${variable2}AtOutCoordsByCoords(coords);`);
    });
    const operation = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            ${snippets.join("\n        ")}
            setOutputFlat(flatIndex, ${operation});
          }
        }
      }
    `;
    return userCode;
  }
};
function addN4(args) {
  const { inputs, backend: backend22 } = args;
  const tensors = inputs;
  if (tensors.length === 1) {
    return identity5({ inputs: { x: tensors[0] }, backend: backend22 });
  }
  const dtype = tensors.map((t2) => t2.dtype).reduce((d1, d2) => upcastType(d1, d2));
  const shapes = tensors.map((t2) => t2.shape);
  const program = new AddNPackedProgram2(shapes);
  return backend22.runWebGPUProgram(program, tensors, dtype);
}
var addNConfig4 = {
  kernelName: AddN,
  backendName: "webgpu",
  kernelFunc: addN4
};
var ArgMinMaxProgram2 = class {
  constructor(inputShape, axis, reduceType) {
    this.variableNames = ["x"];
    this.uniforms = "axis : i32;";
    const axes = [axis];
    backend_util_exports.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, inputShape.length);
    this.op = reduceType === "min" ? "<" : ">";
    const [outputShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(inputShape, axes);
    this.outputShape = outputShape.length === 0 ? [1] : outputShape;
    const reduceSize = util_exports.sizeFromShape(reduceShape);
    this.reductionFactor = 2;
    const xMaxThreads = 256;
    const xThreads = Math.min(Math.ceil(reduceSize / this.reductionFactor), xMaxThreads);
    this.workGroupSize = [xThreads, 1, 1];
    this.dispatchLayout = { x: [], y: this.outputShape.map((d2, i2) => i2) };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.inputShape = inputShape;
    this.shaderKey = `argMinMax${this.op}`;
  }
  getUserCode() {
    const reduceInSharedMemory = this.workGroupSize[0] > 1;
    const sharedMemorySnippet = `
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `;
    const sharedMemoryReduceSnippet = `
      xBestIndices[localId.x] = bestIndex;
      xBestValues[localId.x] = bestValue;

      for(var currentSize = WorkGroupSize; currentSize > 1; currentSize = DIV_CEIL(currentSize, ${this.reductionFactor})) {
        workgroupBarrier();

        for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {
          let i = i32(localId.x) * ${this.reductionFactor} + w;
          if (i < currentSize) {
            let candidateIndex = xBestIndices[i];
            let candidate = xBestValues[i];
            if(candidate ${this.op} bestValue && !isNanCustom(candidate)) {
              bestValue = candidate;
              bestIndex = candidateIndex;
            }
          }
        }

        xBestIndices[localId.x] = bestIndex;
        xBestValues[localId.x] = bestValue;
      }

      if (localId.x == 0u) {
        setOutputFlatI32(flatOutputIndex, i32(bestIndex));
      }
    `;
    const outputCoordsType = getCoordsDataType2(this.outputShape.length);
    const indexOutputCoords = (outputCoords, index) => {
      if (this.outputShape.length === 1) {
        return outputCoords;
      } else {
        return `${outputCoords}[${index}]`;
      }
    };
    const indexInputShape = (index) => {
      if (this.inputShape.length === 1) {
        return "uniforms.xShape";
      } else {
        return `uniforms.xShape[${index}]`;
      }
    };
    const userCode = `
      fn DIV_CEIL(a : i32, b : i32) -> i32 {
        return ((a - 1) / b + 1);
      }

      let WorkGroupSize = ${this.workGroupSize[0]};

      ${reduceInSharedMemory ? sharedMemorySnippet : ""}

      // In order to get a flattened index into the input tensor, we need to
      // add back the index along the reduced dimension to |outputCoords|.
      // This function outputs the offset to the first value along
      // |axis| and the stride to get the next value of the input along |axis|.
      fn getInputCoordInfo(globalId : vec3<u32>, globalIndex : i32) -> vec2<i32>{
        let outputCoords : ${outputCoordsType} = getOutputCoords(globalId, globalIndex);
        var i = ${this.outputShape.length - 1};

        var stride = 1;
        var inputStride = 1;
        var offset = 0;

        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {
          let length = ${indexInputShape(`${this.inputShape.length} - r`)};
          if (${this.inputShape.length} - r == uniforms.axis) {
            inputStride = stride;
          } else {
            offset = offset + ${indexOutputCoords("outputCoords", "i")} * stride;
            i = i - 1;
          }
          stride = stride * length;
        }

        return vec2<i32>(offset, inputStride);
      }

      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{
        return coordInfo[0] + coordInfo[1] * index;
      }

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coordInfo = getInputCoordInfo(globalId, index);

        var bestIndex = 0;
        var bestValue = x.numbers[getInputIndex(coordInfo, bestIndex)];

        let Length = ${indexInputShape("uniforms.axis")};
        let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);

        for (var w = 0; w < WorkPerThread; w = w + 1) {
          let i = i32(globalId.x) * WorkPerThread + w;
          if (i < Length) {
            let candidate = x.numbers[getInputIndex(coordInfo, i)];
            if (candidate ${this.op} bestValue && !isNanCustom(f32(candidate))) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
        }

        let flatOutputIndex = i32(globalId.y);
        ${reduceInSharedMemory ? sharedMemoryReduceSnippet : "setOutputFlatI32(flatOutputIndex, bestIndex);"}
      }
    `;
    return userCode;
  }
};
var TransposeSharedProgram = class {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.workGroupSize = [16, 16, 1];
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[newDim[i2]];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [0], y: [1] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 1, 1]);
    this.shaderKey = "transposeShared";
  }
  getUserCode() {
    const userCode = `
      let TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0] + 1}>, ${this.workGroupSize[0]}>;
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let workGroupID = (globalId - localId)/vec3<u32>(${this.workGroupSize[0]}u, ${this.workGroupSize[1]}u, ${this.workGroupSize[2]}u);
        var x = i32(workGroupID.x) * TILE_DIM + i32(localId.x);
        var y = i32(workGroupID.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] =
              A.numbers[y * width + x];
        }
        workgroupBarrier();

        x = i32(workGroupID.y) * TILE_DIM + i32(localId.x);
        y = i32(workGroupID.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputFlat((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    return userCode;
  }
};
var TransposeProgram2 = class {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.workPerThread = 4;
    this.workGroupSize = [64, 1, 1];
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[newDim[i2]];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.newDim = newDim;
    this.shaderKey = `transpose_${newDim}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const dtype = getCoordsDataType2(this.outputShape.length);
    const switched = getSwitchedCoords2(this.newDim);
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}

        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromFlatIndex(flatIndex);
            setOutputFlat(flatIndex, A.numbers[getFlatIndex${this.outputShape.length}D(
              ${dtype}(${switched}), uniforms.aShape)]);
          }
        }
      }
    `;
    return userCode;
  }
};
function getSwitchedCoords2(newDim) {
  const rank = newDim.length;
  if (rank > 4) {
    throw Error(`Transpose for rank ${rank} is not yet supported`);
  }
  const switchedCoords = new Array(rank);
  for (let i2 = 0; i2 < newDim.length; i2++) {
    switchedCoords[newDim[i2]] = `resRC[${i2}]`;
  }
  return switchedCoords.join();
}
function transpose5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { perm } = attrs;
  const webgpuBackend = backend22;
  const xRank = x2.shape.length;
  const newShape = new Array(xRank);
  for (let i2 = 0; i2 < newShape.length; i2++) {
    newShape[i2] = x2.shape[perm[i2]];
  }
  if (backend22.shouldExecuteOnCPU([x2])) {
    const xData = webgpuBackend.tensorMap.get(x2.dataId);
    const values = xData.values;
    const outValues = transposeImplCPU2(values, x2.shape, x2.dtype, perm, newShape);
    return backend22.makeTensorInfo(newShape, x2.dtype, outValues);
  }
  if (x2.shape.length === 2 && util_exports.arraysEqual(perm, [1, 0])) {
    const program2 = new TransposeSharedProgram(x2.shape, perm);
    return webgpuBackend.runWebGPUProgram(program2, [x2], x2.dtype);
  }
  const program = new TransposeProgram2(x2.shape, perm);
  return webgpuBackend.runWebGPUProgram(program, [x2], x2.dtype);
}
var transposeConfig4 = {
  kernelName: Transpose,
  backendName: "webgpu",
  kernelFunc: transpose5
};
function argMax4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose5({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
  const program = new ArgMinMaxProgram2($x.shape, axes[0], "max");
  const uniformData = [{ type: "int32", data: [axes[0]] }];
  const out = backend22.runWebGPUProgram(program, [$x], "int32", uniformData);
  intermediateTensorInfos.forEach((t2) => backend22.disposeData(t2.dataId));
  return out;
}
var argMaxConfig4 = {
  kernelName: ArgMax,
  backendName: "webgpu",
  kernelFunc: argMax4
};
function argMin4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis } = attrs;
  let axes = util_exports.parseAxisParam(axis, x2.shape);
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
  let $x = x2;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose5({ inputs: { x: x2 }, backend: backend22, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
  }
  backend_util_exports.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
  const program = new ArgMinMaxProgram2($x.shape, axes[0], "min");
  const uniformData = [{ type: "int32", data: [axes[0]] }];
  const out = backend22.runWebGPUProgram(program, [$x], "int32", uniformData);
  intermediateTensorInfos.forEach((t2) => backend22.disposeData(t2.dataId));
  return out;
}
var argMinConfig3 = {
  kernelName: ArgMin,
  backendName: "webgpu",
  kernelFunc: argMin4
};
var Pool2DProgram2 = class {
  constructor(convInfo, poolType) {
    this.variableNames = ["x"];
    this.uniforms = `stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;`;
    this.workGroupSize = [128, 1, 1];
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = `pool2D_${poolType}`;
    this.poolType = poolType;
  }
  getUserCode() {
    let updateSnippet = `resultValue = max(value, resultValue);`;
    if (this.poolType === "avg") {
      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;
    }
    let returnValue = `resultValue`;
    if (this.poolType === "avg") {
      returnValue = `resultValue / count`;
    }
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${updateSnippet}
            }
          }

          setOutput(batch, coords[1], coords[2], coords[3], ${returnValue});
        }
      }
    `;
    return userCode;
  }
};
var PoolWithFilterSizeEqualsOneProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x"];
    this.uniforms = `stride : vec2<i32>;`;
    this.workGroupSize = [256, 1, 1];
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = "poolWithFilterSizeEqualsOne";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let d = coords[3];

        if (all(coords < uniforms.outShape)) {
          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutput(batch, coords[1], coords[2], d, value);
        }
      }
    `;
    return userCode;
  }
};
function avgPool5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity5({ inputs: { x: x2 }, backend: backend22 });
  }
  let program;
  const dimensions = [{ type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] }];
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1) {
    program = new PoolWithFilterSizeEqualsOneProgram(convInfo);
  } else {
    program = new Pool2DProgram2(convInfo, "avg");
    dimensions.push({ type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] }, {
      type: "int32",
      data: [convInfo.dilationHeight, convInfo.dilationWidth]
    }, { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }, {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    });
  }
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, dimensions);
}
var avgPoolConfig4 = {
  kernelName: AvgPool,
  backendName: "webgpu",
  kernelFunc: avgPool5
};
function batchMatMul4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { a: a6, b: b2 } = inputs;
  const { transposeA, transposeB } = attrs;
  return batchMatMulImpl2({ a: a6, b: b2, transposeA, transposeB, backend: backend22 });
}
var batchMatMulConfig4 = {
  kernelName: BatchMatMul,
  backendName: "webgpu",
  kernelFunc: batchMatMul4
};
var SliceProgram2 = class {
  constructor(start, destSize) {
    this.variableNames = ["source"];
    this.workPerThread = 1;
    this.workGroupSize = [64, 1, 1];
    this.outputShape = destSize;
    this.rank = destSize.length;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.start = start;
    this.uniforms = `start : ${getCoordsDataType2(start.length)}; `;
    this.shaderKey = "slice";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const dtype = getCoordsDataType2(this.rank);
    const sourceCoords = getCoords3(this.rank);
    let coordSum;
    if (this.start.length === 1) {
      coordSum = this.outputShape.map((_2, i2) => {
        return `sourceLoc = uniforms.start + coords;`;
      });
    } else {
      coordSum = this.outputShape.map((_2, i2) => {
        return `sourceLoc.${coords2[i2]} = uniforms.start[${i2}] + coords.${coords2[i2]};`;
      });
    }
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          var sourceLoc : ${dtype};
          let coords = getOutputCoords(globalId, index);
          ${coordSum.join("\n")}
          setOutputFlat(index, getSource(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
};
var coords2 = ["x", "y", "z", "w", "u", "v"];
function getCoords3(rank) {
  if (rank === 1) {
    return "sourceLoc";
  } else if (rank <= 6) {
    return coords2.slice(0, rank).map((coord) => `sourceLoc.${coord}`).join(",");
  } else {
    throw Error(`Slicing for rank ${rank} is not yet supported`);
  }
}
function slice5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, size: size2 } = attrs;
  const [$begin, $size] = slice_util_exports.parseSliceParams(x2, begin, size2);
  slice_util_exports.assertParamsValid(x2, $begin, $size);
  if (backend22.shouldExecuteOnCPU([x2]) || x2.dtype === "string") {
    const xBufferInfo = backend22.tensorMap.get(x2.dataId);
    const outValues = sliceImplCPU2(xBufferInfo.values, $begin, $size, x2.shape, x2.dtype);
    return backend22.makeTensorInfo($size, x2.dtype, outValues);
  }
  if (util_exports.sizeFromShape($size) === 0) {
    return backend22.makeTensorInfo($size, x2.dtype, []);
  }
  const program = new SliceProgram2($begin, $size);
  const uniformData = [{ type: "int32", data: $begin }];
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, uniformData);
}
var sliceConfig4 = {
  kernelName: Slice,
  backendName: "webgpu",
  kernelFunc: slice5
};
var batchToSpaceND5 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, crops } = attrs;
  util_exports.assert(x2.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const reshaped = backend_util_exports.getReshaped(x2.shape, blockShape, prod6);
  const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = backend_util_exports.getReshapedPermuted(x2.shape, blockShape, prod6);
  const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const toDispose = [];
  const reshapedIntermediate = reshape6({ inputs: { x: x2 }, backend: backend22, attrs: { shape: reshaped } });
  const transposedIntermediate = transpose5({ inputs: { x: reshapedIntermediate }, backend: backend22, attrs: { perm: permuted } });
  const reshapedIntermediate2 = reshape6({
    inputs: { x: transposedIntermediate },
    backend: backend22,
    attrs: { shape: reshapedPermuted }
  });
  const sliced = slice5({
    inputs: { x: reshapedIntermediate2 },
    backend: backend22,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  toDispose.push(reshapedIntermediate);
  toDispose.push(transposedIntermediate);
  toDispose.push(reshapedIntermediate2);
  toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
  return sliced;
};
var batchToSpaceNDConfig4 = {
  kernelName: BatchToSpaceND,
  backendName: "webgpu",
  kernelFunc: batchToSpaceND5
};
var notEqual4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.NOT_EQUAL,
  dtype: "bool",
  cpuKernelImpl: notEqualImplCPU2
});
var notEqualConfig4 = {
  kernelName: NotEqual,
  backendName: "webgpu",
  kernelFunc: notEqual4
};
function real4(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputData = backend22.tensorMap.get(input2.dataId);
  return identity5({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend22 });
}
var realConfig3 = {
  kernelName: Real,
  backendName: "webgpu",
  kernelFunc: real4
};
function int2(input2, backend22) {
  const program = new UnaryOpProgram2(input2.shape, UnaryOpType.TO_INT);
  const output = backend22.runWebGPUProgram(program, [input2], "int32");
  return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
}
function cast6(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x2.dtype === "complex64") {
      return identity5({ inputs: { x: x2 }, backend: backend22 });
    }
    const zerosTensor = zeros(x2.shape);
    const floatX = cast6({ inputs: { x: x2 }, backend: backend22, attrs: { dtype: "float32" } });
    const result = complex4({ inputs: { real: floatX, imag: zerosTensor }, backend: backend22 });
    zerosTensor.dispose();
    backend22.disposeData(floatX.dataId);
    return result;
  }
  if (x2.dtype === "complex64") {
    const realPart = real4({ inputs: { input: x2 }, backend: backend22 });
    const result = cast6({ inputs: { x: realPart }, backend: backend22, attrs: { dtype } });
    backend22.disposeData(realPart.dataId);
    return result;
  }
  if (!util_exports.hasEncodingLoss(x2.dtype, dtype)) {
    const result = identity5({ inputs: { x: x2 }, backend: backend22 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  if (dtype === "int32") {
    return int2(x2, backend22);
  }
  if (dtype === "bool") {
    const zerosTensorInfo = backend22.makeTensorInfo([], "bool", util_exports.getTypedArrayFromDType("bool", 1));
    const binaryInputs = { a: x2, b: zerosTensorInfo };
    const result = notEqual4({ inputs: binaryInputs, backend: backend22 });
    backend22.disposeData(zerosTensorInfo.dataId);
    return result;
  }
  throw new Error(`Error in Cast: failed to cast ${x2.dtype} to ${dtype}`);
}
var castConfig4 = {
  kernelName: Cast,
  backendName: "webgpu",
  kernelFunc: cast6
};
var ceil4 = unaryKernelFunc3({ opType: UnaryOpType.CEIL, cpuKernelImpl: ceilImplCPU2 });
var ceilConfig4 = {
  kernelName: Ceil,
  backendName: "webgpu",
  kernelFunc: ceil4
};
var ClipVec4Program = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.uniforms = "minVal : f32; maxVal : f32;";
    this.workPerThread = 4;
    this.workGroupSize = [64, 1, 1];
    this.isVec4 = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = "clipVec4";
    this.size = util_exports.sizeFromShape(this.outputShape) / 4;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalId(globalId, index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isNanCustom(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputFlat(index, clampedValue);
        }
      }
    `;
    return userCode;
  }
};
var ClipProgram2 = class {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.uniforms = "minVal : f32; maxVal : f32;";
    this.workGroupSize = [64, 1, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = "clip";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalId(globalId, index);
          if (isNanCustom(value)) {
            setOutputFlat(index, value);
            return;
          }
          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    return userCode;
  }
};
function clipByValue3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { clipValueMin, clipValueMax } = attrs;
  let program;
  const uniformData = [
    { type: "float32", data: [clipValueMin] },
    { type: "float32", data: [clipValueMax] }
  ];
  if (util_exports.sizeFromShape(x2.shape) % 4 === 0) {
    program = new ClipVec4Program(x2.shape);
  } else {
    program = new ClipProgram2(x2.shape);
  }
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, uniformData);
}
var clipByValueConfig3 = {
  kernelName: ClipByValue,
  backendName: "webgpu",
  kernelFunc: clipByValue3
};
var ConcatProgram2 = class {
  constructor(shapes) {
    this.workPerThread = 4;
    this.workGroupSize = [64, 1, 1];
    this.outputShape = backend_util_exports.computeOutShape(shapes, 1);
    this.variableNames = shapes.map((_2, i2) => `T${i2}`);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.shapes = shapes;
    this.shaderKey = `concat${shapes}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const offsets = new Array(this.shapes.length - 1);
    const snippets = [];
    if (offsets.length > 0) {
      offsets[0] = this.shapes[0][1];
      for (let i2 = 1; i2 < offsets.length; i2++) {
        offsets[i2] = offsets[i2 - 1] + this.shapes[i2][1];
      }
      snippets.push(`if (yC < ${offsets[0]}){ setOutput(coords.x, coords.y, getT0(yR, yC)); }`);
      for (let i2 = 1; i2 < offsets.length; i2++) {
        const shift = offsets[i2 - 1];
        snippets.push(`elseif (yC < ${offsets[i2]}){ setOutput(coords.x, coords.y, getT${i2}(yR, yC - ${shift})); }`);
      }
      const lastIndex = offsets.length;
      const lastShift = offsets[offsets.length - 1];
      snippets.push(`else { setOutput(coords.x, coords.y, getT${lastIndex}(yR, yC - ${lastShift})); }`);
    } else {
      snippets.push(`setOutput(coords.x, coords.y, getT0(yR, yC));`);
    }
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${snippets.join("\n        ")}
          }
        }
      }
    `;
    return userCode;
  }
};
function imag4(args) {
  const { inputs, backend: backend22 } = args;
  const { input: input2 } = inputs;
  const inputData = backend22.tensorMap.get(input2.dataId);
  return identity5({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend22 });
}
var imagConfig3 = {
  kernelName: Imag,
  backendName: "webgpu",
  kernelFunc: imag4
};
function concatImpl3(inputs, axis, backend22) {
  const dtype = inputs[0].dtype;
  if (dtype === "complex64") {
    const reals = inputs.map((t2) => real4({ inputs: { input: t2 }, backend: backend22 }));
    const imags = inputs.map((t2) => imag4({ inputs: { input: t2 }, backend: backend22 }));
    const realConcated = concatImpl3(reals, axis, backend22);
    const imagConcated = concatImpl3(imags, axis, backend22);
    const result = complex4({ inputs: { real: realConcated, imag: imagConcated }, backend: backend22 });
    reals.forEach((r2) => backend22.disposeData(r2.dataId));
    imags.forEach((i2) => backend22.disposeData(i2.dataId));
    backend22.disposeData(realConcated.dataId);
    backend22.disposeData(imagConcated.dataId);
    return result;
  }
  let runOnCpu = backend22.shouldExecuteOnCPU(inputs);
  if (dtype === "string") {
    runOnCpu = true;
  }
  if (runOnCpu) {
    const tensors2D2 = inputs.map((t2) => {
      const innerSize = util_exports.sizeFromShape(t2.shape.slice(axis));
      const shape = [-1, innerSize];
      return reshape6({ inputs: { x: t2 }, backend: backend22, attrs: { shape } });
    });
    const inputsValShapes = tensors2D2.map((t2) => {
      return { vals: backend22.readSync(t2.dataId), shape: t2.shape };
    });
    const outShape2 = backend_util_exports.computeOutShape(tensors2D2.map((t2) => t2.shape), 1);
    const simplyConcat = tensors2D2[0].shape[0] === 1;
    const outVals = concatImplCPU2(inputsValShapes, outShape2, dtype, simplyConcat);
    const finalOutShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), axis);
    const outInfo = backend22.makeTensorInfo(finalOutShape, dtype, outVals);
    tensors2D2.forEach((t2) => backend22.disposeData(t2.dataId));
    return outInfo;
  }
  const { tensors2D, outShape } = computeTensors2D2(inputs, axis, backend22);
  const program = new ConcatProgram2(tensors2D.map((t2) => t2.shape));
  const res2 = backend22.runWebGPUProgram(program, tensors2D, tensors2D[0].dtype);
  tensors2D.forEach((r2) => backend22.disposeData(r2.dataId));
  const reshapedResult = reshape6({ inputs: { x: res2 }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeData(res2.dataId);
  return reshapedResult;
}
function computeTensors2D2(inputs, axis, backend22) {
  const outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), axis);
  const tensors2D = inputs.map((t2) => reshape6({
    inputs: { x: t2 },
    backend: backend22,
    attrs: {
      shape: [
        util_exports.sizeFromShape(t2.shape.slice(0, axis)),
        util_exports.sizeFromShape(t2.shape.slice(axis))
      ]
    }
  }));
  return { tensors2D, outShape };
}
function concat5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, inputs[0].shape)[0];
  const outShape = backend_util_exports.computeOutShape(inputs.map((t2) => t2.shape), $axis);
  if (util_exports.sizeFromShape(outShape) === 0) {
    return backend22.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t2) => util_exports.sizeFromShape(t2.shape) > 0);
  if ($inputs.length === 1) {
    return identity5({ inputs: { x: $inputs[0] }, backend: backend22 });
  }
  const shapes = $inputs.map((t2) => t2.shape);
  backend_util_exports.assertParamsConsistent(shapes, $axis);
  return concatImpl3($inputs, $axis, backend22);
}
var concatConfig4 = {
  kernelName: Concat,
  backendName: "webgpu",
  kernelFunc: concat5
};
var Im2ColProgram = class {
  constructor(outputShape, isChannelsLast) {
    this.variableNames = ["A"];
    this.uniforms = `pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;
      inChannels : i32;`;
    this.workPerThread = 4;
    this.workGroupSize = [64, 1, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.isChannelsLast = isChannelsLast;
    this.shaderKey = `im2col_${this.isChannelsLast}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const rowDim = this.isChannelsLast ? 0 : 1;
    const colDim = this.isChannelsLast ? 1 : 2;
    const userCode = `
    ${getMainHeaderString()} {
      ${getGlobalIndexString()}

      for(var i = 0; i<${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;

        let rc = getCoordsFromFlatIndex(flatIndex);

        if(flatIndex < uniforms.size) {
          let blockIndex = rc[0];
          let pos = rc[1];

          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];
          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;
          var value = 0.0;
          if(d0 < uniforms.aShape[${rowDim}] && d0 >= 0) {
            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -
              uniforms.pad[0];
            let d1 = offsetX + uniforms.dilation[0] * ((pos %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
            let ch = pos % uniforms.inChannels;
            if(d1 < uniforms.aShape[${colDim}] && d1 >= 0) {
              value = getA(d0, d1, ch);
            }
          }
          setOutputFlat(flatIndex, value);
        }
      }
    }
  `;
    return userCode;
  }
};
function conv2dByMatMul2({ x: x2, filter, convInfo, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const xShape = x2.shape;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const transposeA = false;
  const transposeB = false;
  const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
  const xReshaped = reshape6({
    inputs: { x: x2 },
    backend: backend22,
    attrs: { shape: [1, targetShape, convInfo.inChannels] }
  });
  const filterReshaped = reshape6({
    inputs: { x: filter },
    backend: backend22,
    attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
  });
  const result = batchMatMulImpl2({
    a: xReshaped,
    b: filterReshaped,
    transposeA,
    transposeB,
    backend: backend22,
    bias,
    activation: activation2,
    preluActivationWeights,
    leakyreluAlpha
  });
  const out = reshape6({ inputs: { x: result }, backend: backend22, attrs: { shape: convInfo.outShape } });
  backend22.disposeData(xReshaped.dataId);
  backend22.disposeData(filterReshaped.dataId);
  backend22.disposeData(result.dataId);
  return out;
}
function conv2dWithIm2Col({ x: x2, filter, convInfo, backend: backend22, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const { filterWidth, filterHeight, inChannels, strideWidth, strideHeight, padInfo, outWidth, outHeight, dilationWidth, dilationHeight, dataFormat } = convInfo;
  const isChannelsLast = dataFormat === "channelsLast";
  const sharedDim = filterWidth * filterHeight * inChannels;
  const numCols = outHeight * outWidth;
  const x2ColShape = [numCols, sharedDim];
  const transposeA = false;
  const transposeB = false;
  const intermediates = [];
  const xSqueezed = reshape6({ inputs: { x: x2 }, backend: backend22, attrs: { shape: x2.shape.slice(1) } });
  const w2Row = reshape6({ inputs: { x: filter }, backend: backend22, attrs: { shape: [1, sharedDim, -1] } });
  intermediates.push(xSqueezed);
  intermediates.push(w2Row);
  const im2ColProgram = new Im2ColProgram(x2ColShape, isChannelsLast);
  const dimensions = [
    { type: "int32", data: [padInfo.left, padInfo.top] },
    { type: "int32", data: [strideWidth, strideHeight] },
    { type: "int32", data: [dilationWidth, dilationHeight] },
    { type: "int32", data: [outWidth] },
    { type: "int32", data: [inChannels * filterWidth] },
    { type: "int32", data: [inChannels] }
  ];
  const im2Col = backend22.runWebGPUProgram(im2ColProgram, [xSqueezed], xSqueezed.dtype, dimensions);
  const im2Col3D = reshape6({
    inputs: { x: im2Col },
    backend: backend22,
    attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
  });
  intermediates.push(im2Col);
  intermediates.push(im2Col3D);
  const a3dShape = [1, x2ColShape[0], x2ColShape[1]];
  const matMulProgram = new MatMulPackedProgram2(a3dShape, [1, numCols, convInfo.outChannels], env().get("WEBGPU_MATMUL_WORK_PER_THREAD"), transposeA, transposeB);
  const dimAOuter = a3dShape[1];
  const dimInner = a3dShape[2];
  const dimBOuter = convInfo.outChannels;
  const matmulDimensions = [
    { type: "int32", data: [dimAOuter] },
    { type: "int32", data: [dimBOuter] },
    { type: "int32", data: [dimInner] }
  ];
  const result = backend22.runWebGPUProgram(matMulProgram, [im2Col3D, w2Row], im2Col3D.dtype, matmulDimensions);
  const outShape = isChannelsLast ? [1, outHeight, outWidth, convInfo.outChannels] : [1, convInfo.outChannels, outHeight, outWidth];
  const out = reshape6({ inputs: { x: result }, backend: backend22, attrs: { shape: outShape } });
  intermediates.push(result);
  for (const i2 of intermediates) {
    backend22.disposeData(i2.dataId);
  }
  return out;
}
var Conv2DMMVec4Program = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;
    this.isVec4 = true;
    this.outputShape = convInfo.outShape;
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    this.dispatchLayout = { x: [3], y: [1, 2], z: [0] };
    this.workGroupSize = [8, 8, 1];
    const elementsPerThread = [4, 4, 1];
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, elementsPerThread);
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.hasLeakyreluAlpha = hasLeakyreluAlpha;
    if (this.addBias) {
      this.variableNames.push("bias");
    }
    if (this.hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    if (this.hasLeakyreluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    [this.fitA, this.fitB] = this.getShapeFit(elementsPerThread);
    this.shaderKey = `conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`;
  }
  getShapeFit(elementsPerThread) {
    const tileAOuter = this.workGroupSize[1] * elementsPerThread[1];
    const tileBOuter = this.workGroupSize[0] * elementsPerThread[0];
    const tileInner = tileBOuter;
    const tileSizeA = [tileAOuter, tileInner];
    const tileSizeB = [tileInner, tileBOuter];
    const dimAOuter = this.outputShape[1] * this.outputShape[2];
    const dimBOuter = this.outputShape[3];
    const dimInner = this.convInfo.filterHeight * this.convInfo.filterWidth * this.convInfo.inChannels;
    return [
      tilesFitEvenlyIntoShape(tileSizeA, [dimAOuter, dimInner]),
      tilesFitEvenlyIntoShape(tileSizeB, [dimInner, dimBOuter])
    ];
  }
  getSampleAWithRemainder(index) {
    return `let flatIndex${index} = getFlatIndex4D(coord, uniforms.xShape);
    let divBy4Remainder${index} = flatIndex${index} % 4;
    let divBy4Index${index} = flatIndex${index} / 4;
    let curData${index} = x.numbers[divBy4Index${index}];
    if (divBy4Remainder${index} == 0) {
      temp = curData${index};
    } else {
      // TODO: This could end up being a redundant load with another one in
      // the same shader invocation. Perhaps there's an opportunity for
      // optimization
      let nextData${index} = x.numbers[divBy4Index${index} + 1];
      if (divBy4Remainder${index} == 1) {
        temp = vec4<f32>(curData${index}.yzw, nextData${index}.x);
      } elseif (divBy4Remainder${index} == 2) {
        temp = vec4<f32>(curData${index}.zw, nextData${index}.xy);
      } elseif (divBy4Remainder${index} == 3) {
        temp = vec4<f32>(curData${index}.w, nextData${index}.xyz);
      }
    }
    `;
  }
  getUserCode() {
    const elementsPerThread = [4, 4, 1];
    const matMulSource = makeMatMulPackedVec4Source(elementsPerThread, this.workGroupSize);
    const remainder = this.convInfo.inChannels % 4;
    const remainderSnippet = remainder === 0 ? `// The bounds checking is always needed since we use it to pad zero for
          // the 'same' padding type.
          if (coordsInBounds4D(coord, uniforms.xShape)) {
            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4];
          } else {
            resData = vec4<f32>(0.0); }` : `var temp = vec4<f32>(0.0);
          ${this.getSampleAWithRemainder(1)}
          resData = temp;
          if (WCol == (uniforms.filterDims[1] - 1)) {
            coord = vec4<i32>(
              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);
              ${this.getSampleAWithRemainder(2)}
            if (inChCoord == 0) {
              resData = vec4<f32>(resData.xyz, temp.x);
            } elseif (inChCoord == 1) {
              resData = vec4<f32>(resData.xy, temp.xy);
            } else {
              resData = vec4<f32>(resData.x, temp.xyz);
            }
          }
          `;
    const readASnippet = `let outRow = r / uniforms.outShape[2];
        let outCol = r % uniforms.outShape[2];
        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);
        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];
        let inChCoord = c % uniforms.xShape[3];
        var coord = vec4<i32>(
            batch,
            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
            inChCoord);
        var resData = vec4<f32>(0.0);
        ${remainderSnippet}
        return resData;`;
    const sampleA = this.fitA ? `${readASnippet}` : `if (r < uniforms.dimAOuter && c < uniforms.dimInner) {
          ${readASnippet}
         }
         return vec4<f32>(0.0);
        `;
    const sampleB = this.fitB ? `return W.numbers[row * uniforms.dimBOuter / 4 + col];` : `if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter / 4 + col];
         }
         return vec4<f32>(0.0);
        `;
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, this.isVec4);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${activationOp}
        }`;
      } else if (this.hasLeakyreluAlpha) {
        activationSnippet = `fn activation(a: vec4<f32>) -> vec4<f32> {
          let b = getLeakyreluAlphaAtOutCoords();
          ${activationOp}
        }`;
        throw new Error("Leakyrelu is not supported.");
      } else {
        activationSnippet = `
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          ${activationOp}
        }`;
      }
      applyActivationSnippet = `value = activation(value, outCoord);`;
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
        ${activationSnippet}
        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          let r = row;
          let c = col * 4;
          var batch = i32(globalId.z);
          ${sampleA}
        }

        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          ${sampleB}
        }

        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {
          var batch = i32(globalId.z);
          var value = valueInput;
          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)
          {
            let outCoord = vec4<i32>(
              batch,
              row / uniforms.outShape[2],
              row % uniforms.outShape[2],
              col * 4);
            ${addBiasSnippet}
            ${applyActivationSnippet}
            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],
              value);
          }
        }
        ${matMulSource}
      `;
    return userCode;
  }
};
var Conv2DMMProgram = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;
    this.outputShape = convInfo.outShape;
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    this.dispatchLayout = { x: [3], y: [1, 2], z: [0] };
    this.workGroupSize = computeWorkGroupSizeForConv2d(this.dispatchLayout, this.outputShape);
    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread);
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    [this.fitA, this.fitB] = this.getShapeFit();
    this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`;
  }
  getShapeFit() {
    const tileAOuter = this.workGroupSize[1] * this.elementsPerThread[1];
    const tileBOuter = this.workGroupSize[0] * this.elementsPerThread[0];
    const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
    util_exports.assert(tileInner % this.workGroupSize[0] === 0 && tileInner % this.workGroupSize[1] === 0, () => "tileInner must be multiple of workgroupsize.x and workgroupsize.y");
    const tileSizeA = [tileAOuter, tileInner];
    const tileSizeB = [tileInner, tileBOuter];
    const dimAOuter = this.outputShape[1] * this.outputShape[2];
    const dimBOuter = this.outputShape[3];
    const dimInner = this.convInfo.filterHeight * this.convInfo.filterWidth * this.convInfo.inChannels;
    return [
      tilesFitEvenlyIntoShape(tileSizeA, [dimAOuter, dimInner]),
      tilesFitEvenlyIntoShape(tileSizeB, [dimInner, dimBOuter])
    ];
  }
  getUserCode() {
    const matMulSource = makeMatMulPackedSource(this.elementsPerThread, this.workGroupSize);
    const readASnippet = `
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);
    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];
    let coord = vec4<i32>(
        batch,
        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
        col % uniforms.xShape[3]);
    // The bounds checking is always needed since we use it to pad zero for the
    // 'same' padding type.
    if(coordsInBounds4D(coord, uniforms.xShape)) {
      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;`;
    const sampleA = this.fitA ? `${readASnippet}` : `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${readASnippet}
    }
    return 0.0;
    `;
    const sampleB = this.fitB ? `return W.numbers[row * uniforms.dimBOuter + col];` : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter + col];
	 }
	 return 0.0;
	 `;
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, false);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a: f32, outCoord : vec4<i32>) -> f32 {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${activationOp}
                }`;
      } else {
        activationSnippet = `
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
                    ${activationOp}
                  }
                `;
      }
      applyActivationSnippet = `value = activation(value, outCoord);`;
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
    ${activationSnippet}
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${sampleA}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      ${sampleB}
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      ${addBiasSnippet}
      ${applyActivationSnippet}
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }
    ${matMulSource}
  `;
    return userCode;
  }
};
var Conv2DNaiveProgram = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;`;
    this.workGroupSize = [128, 1, 1];
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.shaderKey = `conv2DNaive_${this.activation}`;
  }
  getUserCode() {
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation);
      if (this.hasPreluActivationWeights) {
        activationSnippet = `fn activation(a : f32, outCoord : vec4<i32>) -> f32{
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${activationOp}
             }`;
      } else {
        activationSnippet = `
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{
                    ${activationOp}
                  }
                `;
      }
      applyActivationSnippet = `value = activation(value, outCoord);`;
    }
    const addBiasSnippet = this.addBias ? "value = value + getBiasAtOutCoordsByCoords(outCoord);" : "";
    const userCode = `
      ${activationSnippet}
      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {
        let coord = vec4<i32>(batch, row, col, chan);
        if(coordsInBounds4D(coord, uniforms.xShape)) {
          return getX(batch, row, col, chan);
        }
        return 0.0;
      }

      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
        let coord = vec4<i32>(row, col, xChannel, outChannel);
        if(coordsInBounds4D(coord, uniforms.wShape)) {
          return getW(row, col, xChannel, outChannel);
        }
        return 0.0;
      }

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(batch, row, col, chan, value);
        }
      }

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let outChannel = coords[3];

        var acc = 0.0;

        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {
              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
              let v = readInp(batch, coordRow, coordCol, xChannel);
              let f = readFilt(row, col, xChannel, outChannel);
              acc = acc + v * f;
            }
          }
        }

        writeResult(batch, coords[1], coords[2], outChannel, acc);
      }
    `;
    return userCode;
  }
};
function conv2d6(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    return conv2dByMatMul2({ x: x2, filter, convInfo, backend: backend22 });
  }
  if (env().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") && x2.shape[0] === 1) {
    return conv2dWithIm2Col({ x: x2, filter, convInfo, backend: backend22 });
  }
  let program;
  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];
  const dimensions = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [...padInfo] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] }
  ];
  const useNaive = env().getBool("WEBGPU_USE_NAIVE_CONV2D");
  if (useNaive) {
    program = new Conv2DNaiveProgram(convInfo);
  } else if ((convInfo.inChannels % 4 === 0 || convInfo.inChannels === 3 && convInfo.padInfo.type === "VALID") && convInfo.outChannels % 4 === 0 && convInfo.outChannels >= 64) {
    program = new Conv2DMMVec4Program(convInfo);
  } else {
    program = new Conv2DMMProgram(convInfo);
  }
  if (!useNaive) {
    const dimAOuter = convInfo.outShape[1] * convInfo.outShape[2];
    const dimBOuter = convInfo.outShape[3];
    const dimInner = convInfo.filterHeight * convInfo.filterWidth * convInfo.inShape[3];
    dimensions.push({ type: "int32", data: [dimAOuter] }, { type: "int32", data: [dimBOuter] }, { type: "int32", data: [dimInner] });
  }
  return backend22.runWebGPUProgram(program, [x2, filter], x2.dtype, dimensions);
}
var conv2DConfig4 = {
  kernelName: Conv2D,
  backendName: "webgpu",
  kernelFunc: conv2d6
};
var Conv2DDerInputMMProgram = class {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.uniforms = "filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;";
    this.outputShape = convInfo.inShape;
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    this.dispatchLayout = { x: [3], y: [1, 2], z: [0] };
    this.workGroupSize = computeWorkGroupSizeForConv2d(this.dispatchLayout, this.outputShape);
    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread);
    this.shaderKey = `conv2DDerInputMM_${this.elementsPerThread}`;
  }
  getUserCode() {
    const matMulSource = makeMatMulPackedSource(this.elementsPerThread, this.workGroupSize);
    const readASnippet = `
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
      return 0.0;
    }
    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
      return 0.0;
    }
    let coord = vec4<i32>(
        batch,
        i32(xR),
        i32(xC),
        col % uniforms.outBackprop[3]);
    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];`;
    const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${readASnippet}
    }
    return 0.0;`;
    const userCode = `
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${sampleA}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      let coordX = uniforms.filterDims.x - 1 -
          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let coordY = uniforms.filterDims.y - 1 -
          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
          coordX >= 0 && coordY >= 0) {
        let coord = vec4<i32>(coordX, coordY, col,
            row % uniforms.outBackprop[3]);
        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];
      }
      return 0.0;
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }

    ${matMulSource}
  `;
    return userCode;
  }
};
var Conv2DDerInputProgram2 = class {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.uniforms = "filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;";
    this.workGroupSize = [64, 1, 1];
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.shaderKey = `conv2DDerInput_${this.isChannelsLast}`;
  }
  getUserCode() {
    const rowDim = this.isChannelsLast ? 1 : 2;
    const colDim = this.isChannelsLast ? 2 : 3;
    const channelDim = this.isChannelsLast ? 3 : 1;
    return `
    ${getMainHeaderString()} {
      ${getGlobalIndexString()}
      let coords = getOutputCoords(globalId, index);
      if (coordsInBounds4D(coords, uniforms.outShape)) {
        let batch = coords[0];
        let d1 = coords[${channelDim}];

        let dyCorner = vec2<i32>(coords[${rowDim}]), coords[${colDim}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutput(coords[0], coords[1], coords[2], coords[3], dotProd);
      }
    }
  `;
  }
};
function conv2DBackpropInput5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { dy, filter } = inputs;
  const { inputShape, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
  const dimensions = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    {
      type: "int32",
      data: [
        convInfo.filterHeight - 1 - convInfo.padInfo.top,
        convInfo.filterWidth - 1 - convInfo.padInfo.left
      ]
    },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    {
      type: "int32",
      data: [
        convInfo.batchSize,
        convInfo.outHeight,
        convInfo.outWidth,
        convInfo.outChannels
      ]
    }
  ];
  let program;
  if (env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")) {
    program = new Conv2DDerInputProgram2(convInfo);
  } else {
    program = new Conv2DDerInputMMProgram(convInfo);
    const dimAOuter = convInfo.inShape[1] * convInfo.inShape[2];
    const dimBOuter = convInfo.inShape[3];
    const dimInner = convInfo.filterHeight * convInfo.filterWidth * convInfo.outChannels;
    dimensions.push({ type: "uint32", data: [dimAOuter] }, { type: "uint32", data: [dimBOuter] }, { type: "uint32", data: [dimInner] });
  }
  return backend22.runWebGPUProgram(program, [dy, filter], "float32", dimensions);
}
var conv2DBackpropInputConfig4 = {
  kernelName: Conv2DBackpropInput,
  backendName: "webgpu",
  kernelFunc: conv2DBackpropInput5
};
var cos4 = unaryKernelFunc3({ opType: UnaryOpType.COS });
var cosConfig4 = {
  kernelName: Cos,
  backendName: "webgpu",
  kernelFunc: cos4
};
var cosh4 = unaryKernelFunc3({ opType: UnaryOpType.COSH });
var coshConfig4 = {
  kernelName: Cosh,
  backendName: "webgpu",
  kernelFunc: cosh4
};
var CropAndResizeProgram2 = class {
  constructor(channnel, boxShape, cropSize, method) {
    this.variableNames = ["Image", "Boxes", "BoxInd"];
    this.uniforms = "extrapolationValue : f32;";
    this.workGroupSize = [64, 1, 1];
    const [numBoxes] = boxShape;
    this.outputShape = [numBoxes, cropSize[0], cropSize[1], channnel];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.methodId = method === "bilinear" ? 1 : 0;
    this.cropHeightBiggerThan1 = this.outputShape[1] > 1;
    this.cropWidthBiggerThan1 = this.outputShape[2] > 1;
    this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
  }
  getUserCode() {
    const [inputHeightFloat, inputWidthFloat] = [`f32(uniforms.imageShape[1] - 1)`, `f32(uniforms.imageShape[2] - 1)`];
    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ? [
      `(${inputHeightFloat} / f32(uniforms.outShape[1] - 1))`,
      "(y2-y1) * height_ratio",
      `y1*${inputHeightFloat} + f32(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${inputHeightFloat}`
    ];
    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ? [
      `(${inputWidthFloat} / f32(uniforms.outShape[2] - 1))`,
      "(x2-x1) * width_ratio",
      `x1*${inputWidthFloat} + f32(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${inputWidthFloat}`
    ];
    const userCode = `
      fn writeResult(coords : vec4<i32>, value : f32) {
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutput(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let height_ratio = f32(${heightRatio});
        let width_ratio = f32(${widthRatio});
        let coords = getOutputCoords(globalId, index);
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${heightScale};
        let width_scale = ${widthScale};
        let in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          writeResult(coords, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          writeResult(coords, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          writeResult(coords, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          writeResult(coords,newValue);
        }
      }
    `;
    return userCode;
  }
};
var cropAndResize5 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const program = new CropAndResizeProgram2(image32.shape[3], boxes.shape, cropSize, method);
  const uniformData = [{ type: "float32", data: [extrapolationValue] }];
  return backend22.runWebGPUProgram(program, [image32, boxes, boxInd], "float32", uniformData);
};
var cropAndResizeConfig4 = {
  kernelName: CropAndResize,
  backendName: "webgpu",
  kernelFunc: cropAndResize5
};
var DepthToSpaceProgram2 = class {
  constructor(outputShape, dataFormat) {
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.uniforms = "blockSize : i32;";
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = `depthToSpace_${dataFormat}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.dataFormat = dataFormat;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          let coords = getOutputCoords(globalId, index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputFlat(index, rlt);
        }
      }`;
    return userCode;
  }
  getHeightCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[1]`;
    } else {
      return `coords[2]`;
    }
  }
  getWidthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[2]`;
    } else {
      return `coords[3]`;
    }
  }
  getDepthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[3]`;
    } else {
      return `coords[1]`;
    }
  }
  getOutputDepthSize() {
    if (this.dataFormat === "NHWC") {
      return `uniforms.outShape[3]`;
    } else {
      return `uniforms.outShape[1]`;
    }
  }
  getInputSamplingString() {
    if (this.dataFormat === "NHWC") {
      return `getX(b, in_h, in_w, in_d)`;
    } else {
      return `getX(b, in_d, in_h, in_w)`;
    }
  }
};
function depthToSpace5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockSize, dataFormat } = attrs;
  const batchSize = x2.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x2.shape[1] : x2.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x2.shape[2] : x2.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x2.shape[3] : x2.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const uniformData = [
    { type: "int32", data: [blockSize] }
  ];
  const program = new DepthToSpaceProgram2(outputShape, dataFormat);
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, uniformData);
}
var depthToSpaceConfig4 = {
  kernelName: DepthToSpace,
  backendName: "webgpu",
  kernelFunc: depthToSpace5
};
var DepthwiseConv2D3x3Program = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = "pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;";
    this.workGroupSize = [4, 4, 4];
    this.isVec4 = true;
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = { x: [0, 1], y: [2], z: [3] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 4, 4]);
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivation = hasPreluActivation;
    this.shaderKey = `depthwise3x3_${activation2}`;
  }
  getUserCode() {
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, this.isVec4);
      if (this.hasPreluActivation) {
        activationSnippet = `fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, globalIndex);
          ${activationOp}
        }`;
      } else {
        activationSnippet = `
        fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
            ${activationOp}
          }
        `;
      }
      applyActivationSnippet = `dotProd[i] = activation(dotProd[i], globalId, index);`;
    }
    const addBiasSnippet = this.addBias ? "dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);" : "";
    const userCode = `
      ${activationSnippet}

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let batch = 0;
        let r = i32(globalId.x);
        let c = i32(globalId.y) * 4;
        let d2 = i32(globalId.z) * 4;
        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;
        let d1 = d2;
        let q = 0;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;

        var wVals : array<vec4<f32>, 9>;
        wVals[0] = getW(0, 0, d1, q);
        wVals[1] = getW(0, 1, d1, q);
        wVals[2] = getW(0, 2, d1, q);
        wVals[3] = getW(1, 0, d1, q);
        wVals[4] = getW(1, 1, d1, q);
        wVals[5] = getW(1, 2, d1, q);
        wVals[6] = getW(2, 0, d1, q);
        wVals[7] = getW(2, 1, d1, q);
        wVals[8] = getW(2, 2, d1, q);

        var xVals : array<array<vec4<f32>, 6>, 3>;
        for (var wR = 0; wR < 3; wR = wR + 1) {
          let xR = xRCorner + wR * uniforms.dilation[0];
          for (var wC = 0; wC < 6; wC = wC + 1) {
            let xC = xCCorner + wC * uniforms.dilation[1];
            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {
              xVals[wR][wC] = vec4<f32>(0.0);
            } else {
              xVals[wR][wC] = getX(batch, xR, xC, d1);
            }
          }
        }

        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        for (var wR = 0; wR < 3; wR = wR + 1) {
          for (var wC = 0; wC < 3; wC = wC + 1) {
            let indexW = wR * 3 + wC;
            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];
            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];
            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];
            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d2);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            ${addBiasSnippet}
            ${applyActivationSnippet}
            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
          }
        }
      }
    `;
    return userCode;
  }
};
var DepthwiseConv2DProgram2 = class {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;`;
    this.workGroupSize = [256, 1, 1];
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    util_exports.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivation = hasPreluActivation;
    this.shaderKey = `depthwise_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.activation}_${this.convInfo.outChannels / this.convInfo.inChannels}`;
  }
  getUserCode() {
    const channelMul = this.convInfo.outChannels / this.convInfo.inChannels;
    let activationSnippet = "", applyActivationSnippet = "";
    if (this.activation) {
      const activationOp = mapActivationToShaderProgram2(this.activation, false);
      if (this.hasPreluActivation) {
        activationSnippet = `fn activation(a : f32, globalId : vec3<u32>, index : i32) -> f32 {
          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, index);
          ${activationOp}
        }`;
      } else {
        activationSnippet = `
          fn activation(a : f32, globalId : vec3<u32>, index : i32) -> f32 {
            ${activationOp}
          }
        `;
      }
      applyActivationSnippet = `dotProd = activation(dotProd, globalId, index);`;
    }
    const addBiasSnippet = this.addBias ? "dotProd = dotProd + getBiasAtOutCoordsByGlobalId(globalId, index);" : "";
    const userCode = `
      ${activationSnippet}

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          setOutput(batch, row, col, chan, value);
        }
      }

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
        let d2 = coords[3];
        let d1 = d2 / ${channelMul};
        let q = d2 - d1 * ${channelMul};

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + ${this.convInfo.filterHeight} * uniforms.dilation[0];
        let inputColEnd = inputColStart + ${this.convInfo.filterWidth} * uniforms.dilation[1];

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] && inputColEnd < uniforms.inDims[1]) {
            // Here using a constant value |this.convInfo.filterHeight| instead
            // of uniform value is in order to loop unrolling.
            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          }

        ${addBiasSnippet}
        ${applyActivationSnippet}
        writeResult(batch, coords[1], coords[2], d2, dotProd);
      }
    `;
    return userCode;
  }
};
function depthwiseConv2dNative3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter } = inputs;
  const { strides, pad: pad3, dilations, dimRoundingMode } = attrs;
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  let program;
  if (convInfo.batchSize === 1 && convInfo.inHeight === convInfo.outHeight && convInfo.inWidth === convInfo.outWidth && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && convInfo.filterHeight === convInfo.filterWidth && convInfo.inChannels === convInfo.outChannels && convInfo.filterHeight === 3 && convInfo.inChannels % 4 === 0) {
    program = new DepthwiseConv2D3x3Program(convInfo);
  } else {
    program = new DepthwiseConv2DProgram2(convInfo);
  }
  const dimensions = [
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }
  ];
  return backend22.runWebGPUProgram(program, [x2, filter], x2.dtype, dimensions);
}
var depthwiseConv2dNativeConfig4 = {
  kernelName: DepthwiseConv2dNative,
  backendName: "webgpu",
  kernelFunc: depthwiseConv2dNative3
};
var multiplyKernelFunc = binaryKernelFunc3({
  opSnippet: BinaryOpType.MUL,
  cpuKernelImpl: multiplyImplCPU2,
  supportsComplex: true
});
var multiplyConfig4 = {
  kernelName: Multiply,
  backendName: "webgpu",
  kernelFunc: multiplyKernelFunc
};
var ReduceProgram2 = class {
  constructor(reduceInfo, reduceType, outputDtype) {
    this.variableNames = ["x"];
    this.uniforms = "reduceSize : i32;";
    this.inputShape = [reduceInfo.batchSize, reduceInfo.inSize];
    const [outputShape] = backend_util_exports.computeOutAndReduceShapes(this.inputShape, [1]);
    this.outputShape = outputShape.length === 0 ? [1] : outputShape;
    this.reductionFactor = 2;
    const xMaxThreads = 256;
    const xThreads = Math.min(Math.ceil(reduceInfo.inSize / this.reductionFactor), xMaxThreads);
    this.workGroupSize = [xThreads, 1, 1];
    this.dispatchLayout = { x: [], y: this.outputShape.map((d2, i2) => i2) };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.reduceType = reduceType;
    this.shaderKey = `reduce_${reduceType}_${outputDtype}`;
  }
  getUserCode() {
    const reduceInSharedMemory = this.workGroupSize[0] > 1;
    let reduceOp = ``;
    let initValue = "0.0";
    if (this.reduceType === "min" || this.reduceType === "max") {
      reduceOp = `
         if (isNanCustom(candidate)) {
          bestValue = uniforms.NAN;
         } elseif (candidate ${this.reduceType === "min" ? "<" : ">"}
           bestValue)
           {  bestValue = candidate; }`;
      initValue = "f32(x.numbers[offset])";
    } else if (this.reduceType === "sum" || this.reduceType === "mean") {
      reduceOp = " bestValue = bestValue + candidate; ";
    } else if (this.reduceType === "prod") {
      reduceOp = " bestValue = bestValue * candidate; ";
      initValue = "1.0";
    }
    const outputSnippet = this.reduceType === "mean" ? `setOutputFlat(flatOutputIndex, bestValue / f32(uniforms.reduceSize));` : `setOutputFlat(flatOutputIndex, bestValue);`;
    const sharedMemorySnippet = `
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `;
    const sharedMemoryReduceSnippet = `
       xBestValues[localId.x] = bestValue;
       ${this.reduceType === "sum" || this.reduceType === "mean" || this.reduceType === "prod" ? `bestValue = ${initValue};` : " "}
       var currentSize = WorkGroupSize;
       for(; currentSize > 1;) {
         workgroupBarrier();
         for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {
           let i = i32(localId.x) * ${this.reductionFactor} + w;
           if (i < currentSize) {
             let candidate = xBestValues[i];
             ${reduceOp}
           }
         }
         workgroupBarrier();
         xBestValues[localId.x] = bestValue;
         currentSize = DIV_CEIL(currentSize, ${this.reductionFactor});
         ${this.reduceType === "sum" || this.reduceType === "mean" || this.reduceType === "prod" ? `if(currentSize > 1) { bestValue = ${initValue}; }` : ""}
       }
       if (localId.x == 0u) {
         ${outputSnippet}
       }
     `;
    const userCode = `
       fn DIV_CEIL(a : i32, b : i32) -> i32 {
        return ((a - 1) / b + 1);
       }
       let WorkGroupSize = ${this.workGroupSize[0]};
       ${reduceInSharedMemory ? sharedMemorySnippet : ""}
       fn getOffset(globalId : vec3<u32>, index : i32) -> i32 {
         let outputCoords = getOutputCoords(globalId, index);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
         return offset;
       }
       ${getMainHeaderString()} {
         ${getGlobalIndexString()}
         let offset= getOffset(globalId, index);
         var bestValue = ${initValue};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);
         for (var w = 0; w < WorkPerThread; w = w + 1) {
           let i = i32(globalId.x) * WorkPerThread + w;
           if (i < Length) {
             let candidate = f32(x.numbers[offset + i]);
             ${reduceOp}
           }
         }
         let flatOutputIndex = i32(globalId.y);
         ${reduceInSharedMemory ? sharedMemoryReduceSnippet : outputSnippet}
       }
     `;
    return userCode;
  }
};
function reduce2(x2, axis, keepDims, reduceType, backend22) {
  const xRank = x2.shape.length;
  const toDispose = [];
  const origAxes = util_exports.parseAxisParam(axis, x2.shape);
  let axes = origAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let input2 = x2;
  if (permutedAxes != null) {
    input2 = transpose5({ inputs: { x: x2 }, attrs: { perm: permutedAxes }, backend: backend22 });
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    toDispose.push(input2);
  }
  backend_util_exports.assertAxesAreInnerMostDims(reduceType, axes, xRank);
  const [reduceOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input2.shape, axes);
  let resOutShape = reduceOutShape;
  if (keepDims) {
    resOutShape = backend_util_exports.expandShapeToKeepDim(reduceOutShape, origAxes);
  }
  let res2;
  if ((reduceType === "max" || reduceType === "prod") && backend22.shouldExecuteOnCPU([input2])) {
    const xVals = backend22.tensorMap.get(input2.dataId).values;
    switch (reduceType) {
      case "max":
        const outValues = maxImplCPU2(xVals, util_exports.sizeFromShape(reduceShape), resOutShape, x2.dtype);
        res2 = backend22.makeTensorInfo(resOutShape, x2.dtype, outValues);
        break;
      case "prod":
        const { outVals, outShape, outDtype } = prodImplCPU2(input2.shape, input2.dtype, xVals, axes);
        res2 = backend22.makeTensorInfo(outShape, outDtype, outVals);
        break;
      default:
        throw new Error(`${reduceType} CPU implementation is not yet supported.`);
    }
  } else {
    const inSize = util_exports.sizeFromShape(reduceShape);
    const xSize = util_exports.sizeFromShape(input2.shape);
    const batchSize = xSize / inSize;
    const reduceInfo = { windowSize: inSize, inSize, batchSize, outSize: 1 };
    const dtype = reduceType === "mean" ? "float32" : sumOutType(x2.dtype);
    const uniformData = [
      { type: "int32", data: [inSize] }
    ];
    const program = new ReduceProgram2(reduceInfo, reduceType, dtype);
    const reduced = backend22.runWebGPUProgram(program, [input2], dtype, uniformData);
    toDispose.push(reduced);
    res2 = reshape6({ inputs: { x: reduced }, attrs: { shape: resOutShape }, backend: backend22 });
  }
  toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
  return res2;
}
function sum6(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  return reduce2(x2, axis, keepDims, "sum", backend22);
}
var sumConfig4 = {
  kernelName: Sum,
  backendName: "webgpu",
  kernelFunc: sum6
};
function einsum4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
  backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i2 = 0; i2 < nSteps; ++i2) {
    for (const idTerm of steps[i2]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x2;
      if (backend_util_exports.isIdentityPermutation(perm)) {
        x2 = tensors[idTerm];
      } else {
        x2 = transpose5({ inputs: { x: tensors[idTerm] }, backend: backend22, attrs: { perm } });
        tensorsToDispose.push(x2);
      }
      const targetShape = x2.shape.slice();
      for (let k3 = 0; k3 < dimsToExpand.length; ++k3) {
        targetShape.splice(dimsToExpand[k3], 0, 1);
      }
      if (!util_exports.arraysEqual(x2.shape, targetShape)) {
        x2 = reshape6({ inputs: { x: x2 }, backend: backend22, attrs: { shape: targetShape } });
        tensorsToDispose.push(x2);
      }
      if (out === null) {
        out = x2;
      } else {
        out = multiplyKernelFunc({ inputs: { a: x2, b: out }, backend: backend22 });
        tensorsToDispose.push(out);
      }
    }
    if (i2 < nSteps - 1) {
      if (path[i2] >= 0) {
        out = sum6({
          inputs: { x: out },
          backend: backend22,
          attrs: {
            axis: path[i2] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend22.disposeData(tensorInfo.dataId);
  }
  return out;
}
var einsumConfig3 = {
  kernelName: Einsum,
  backendName: "webgpu",
  kernelFunc: einsum4
};
var elu6 = unaryKernelFunc3({ opType: UnaryOpType.ELU });
var eluConfig4 = {
  kernelName: Elu,
  backendName: "webgpu",
  kernelFunc: elu6
};
var equal4 = binaryKernelFunc3({ opSnippet: BinaryOpType.EQUAL, dtype: "bool", cpuKernelImpl: equalImplCPU2 });
var equalConfig4 = {
  kernelName: Equal,
  backendName: "webgpu",
  kernelFunc: equal4
};
var exp4 = unaryKernelFunc3({
  opType: UnaryOpType.EXP,
  cpuKernelImpl: expImplCPU2,
  dtype: "float32"
});
var expConfig4 = {
  kernelName: Exp,
  backendName: "webgpu",
  kernelFunc: exp4
};
function expandDims6(args) {
  const { inputs, attrs, backend: backend22 } = args;
  const { dim } = attrs;
  const { input: input2 } = inputs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape6({ inputs: { x: input2 }, backend: backend22, attrs: { shape: newShape } });
}
var expandDimsConfig4 = {
  kernelName: ExpandDims,
  backendName: "webgpu",
  kernelFunc: expandDims6
};
var expm14 = unaryKernelFunc3({ opType: UnaryOpType.EXPM1, cpuKernelImpl: expm1ImplCPU2 });
var expm1Config3 = {
  kernelName: Expm1,
  backendName: "webgpu",
  kernelFunc: expm14
};
var FillProgram2 = class {
  constructor(shape) {
    this.variableNames = [];
    this.outputShape = [];
    this.uniforms = "value : f32;";
    this.workPerThread = 4;
    this.workGroupSize = [16, 1, 1];
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = "fill";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString()} {
      ${getGlobalIndexString()}
      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;
        if (flatIndex < uniforms.size) {
          setOutputFlat(flatIndex, uniforms.value);
        }
      }
    }
  `;
    return userCode;
  }
};
function fill5(args) {
  const { backend: backend22, attrs } = args;
  const { shape, value } = attrs;
  let { dtype } = attrs;
  dtype = dtype || util_exports.inferDtype(value);
  if (dtype === "string") {
    const values = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(shape));
    values.fill(value);
    return backend22.makeTensorInfo(shape, dtype, values);
  } else {
    const program = new FillProgram2(shape);
    const uniformData = [{ type: "float32", data: [value] }];
    return backend22.runWebGPUProgram(program, [], dtype, uniformData);
  }
}
var fillConfig4 = {
  kernelName: Fill,
  backendName: "webgpu",
  kernelFunc: fill5
};
var FlipLeftRightProgram2 = class {
  constructor(imageShape) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = imageShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = "flipLeftRight";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}

        if (index < uniforms.size) {
          let coords = getOutputCoords(globalId, index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputFlat(index, outputValue);
        }
      }
    `;
    return userCode;
  }
};
var flipLeftRightConfig4 = {
  kernelName: FlipLeftRight,
  backendName: "webgpu",
  kernelFunc: ({ inputs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const webgpuBackend = backend22;
    const program = new FlipLeftRightProgram2(image32.shape);
    const output = webgpuBackend.runWebGPUProgram(program, [image32], image32.dtype);
    return output;
  }
};
var floor4 = unaryKernelFunc3({ opType: UnaryOpType.FLOOR, cpuKernelImpl: floorImplCPU2 });
var floorConfig4 = {
  kernelName: Floor,
  backendName: "webgpu",
  kernelFunc: floor4
};
var floorDiv4 = binaryKernelFunc3({ opSnippet: BinaryOpType.INT_DIV, dtype: "int32" });
var floorDivConfig4 = {
  kernelName: FloorDiv,
  backendName: "webgpu",
  kernelFunc: floorDiv4
};
var makeBindGroup = (device, bindGroupLayout, inputs, output, uniforms) => {
  const bindings = [output, ...inputs];
  if (uniforms) {
    bindings.push(uniforms);
  }
  return device.createBindGroup({
    layout: bindGroupLayout,
    entries: bindings.map((b2, i2) => ({ binding: i2, resource: b2 }))
  });
};
var compileProgram2 = (device, program, pipelineLayout, inputsData, output, isFromPixel = false) => {
  const outputData = { dtype: output.dtype, shape: output.shape };
  const source = makeShader2(inputsData, outputData, program, isFromPixel);
  const module = device.createShaderModule({ code: source });
  const pipeline = device.createComputePipeline({ layout: pipelineLayout, compute: { module, entryPoint: "main" } });
  return pipeline;
};
function makeShaderKey2(program, shapes, types, broadcastDimsKey = "", inputShapesEqualsOutShape = "") {
  const key = (program.workGroupSize ? program.workGroupSize.join(",") : "") + shapes.map((shape) => shape.length).join(",") + types.join(",") + program.variableNames.join(",") + broadcastDimsKey + inputShapesEqualsOutShape + program.shaderKey;
  return key;
}
function fromPixelsExternalImage(args) {
  const { externalImage, backend: backend22, attrs, outShape, useImport } = args;
  const { numChannels } = attrs;
  const size2 = util_exports.sizeFromShape(outShape);
  const strides = util_exports.computeStrides(outShape);
  const output = backend22.makeTensorInfo(outShape, "int32");
  const program = backend22.getFromPixelsProgram(useImport ? "import" : "copyExternal");
  program.updateOutputShape(outShape);
  const outputShapes = [output.shape];
  const outputTypes = [output.dtype, useImport ? "import" : "copyExternal"];
  const key = makeShaderKey2(program, outputShapes, outputTypes);
  const layout = program.getLayout(backend22.device);
  const pipeline = backend22.getAndSavePipeline(key, () => {
    return compileProgram2(backend22.device, program, layout.pipelineLayout, [], output, true);
  });
  program.setPipeline(pipeline);
  if (!useImport) {
    backend22.queue.copyExternalImageToTexture({ source: externalImage, origin: { x: 0, y: 0 } }, {
      texture: program.makeInputTexture(backend22.device, outShape[1], outShape[0])
    }, [outShape[1], outShape[0]]);
  }
  const info = backend22.tensorMap.get(output.dataId);
  info.bufferInfo.buffer = backend22.acquireBuffer(info.bufferInfo.byteSize);
  const uniformData = [size2, numChannels, ...strides, ...program.dispatch];
  program.setUniform(backend22.device, uniformData);
  let externalResource;
  if (useImport) {
    const externalTextureDescriptor = {
      source: externalImage
    };
    externalResource = backend22.device.importExternalTexture(externalTextureDescriptor);
  } else {
    externalResource = program.inputTexture.createView();
  }
  backend22.runFromPixelsProgram(program, info.bufferInfo.buffer, layout, externalResource, output.dataId);
  return output;
}
var fromPixelsConfig2 = {
  kernelName: FromPixels,
  backendName: "webgpu",
  kernelFunc: fromPixels3
};
var fromPixels2DContext3;
function fromPixels3(args) {
  const { inputs, backend: backend22, attrs } = args;
  let { pixels } = inputs;
  const { numChannels } = attrs;
  if (pixels == null) {
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  }
  const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
  const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
  const isCanvas = typeof HTMLCanvasElement !== "undefined" && pixels instanceof HTMLCanvasElement;
  const isImageBitmap = typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap;
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  const outShape = [height, width, numChannels];
  if (env().getBool("WEBGPU_USE_IMPORT")) {
    if (isVideo) {
      return fromPixelsExternalImage({
        externalImage: pixels,
        backend: backend22,
        attrs,
        outShape,
        useImport: true
      });
    }
  }
  if (isVideo || isImage) {
    if (fromPixels2DContext3 == null) {
      fromPixels2DContext3 = document.createElement("canvas").getContext("2d");
    }
    fromPixels2DContext3.canvas.width = width;
    fromPixels2DContext3.canvas.height = height;
    fromPixels2DContext3.drawImage(pixels, 0, 0, width, height);
    pixels = fromPixels2DContext3.canvas;
  }
  if (isImageBitmap || isCanvas || isVideo || isImage) {
    return fromPixelsExternalImage({
      externalImage: pixels,
      backend: backend22,
      attrs,
      outShape,
      useImport: false
    });
  }
  const imageData = pixels.data;
  let pixelArray = imageData;
  if (numChannels != null && numChannels !== 4) {
    pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);
    const dataLength = imageData.length;
    let j2 = 0;
    for (let i2 = 0; i2 < dataLength; i2++) {
      if (i2 % 4 < numChannels) {
        pixelArray[j2++] = imageData[i2];
      }
    }
  }
  const output = backend22.makeTensorInfo(outShape, "int32");
  const info = backend22.tensorMap.get(output.dataId);
  info.values = new Int32Array(pixelArray);
  backend22.maybeReleaseBuffer(output.dataId);
  backend22.uploadToGPU(output.dataId);
  return output;
}
var BatchNormProgram2 = class {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape) {
    this.uniforms = "varianceEpsilon : f32;";
    this.workGroupSize = [128, 1, 1];
    this.variableNames = ["x", "mean", "variance"];
    backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
    backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
    this.outputShape = xShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    if (offsetShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
    }
    if (scaleShape != null) {
      backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
    }
    this.offsetShape = offsetShape;
    this.scaleShape = scaleShape;
    this.shaderKey = "batchNorm";
  }
  getUserCode() {
    let offsetSnippet = "0.0";
    if (this.offsetShape != null) {
      offsetSnippet = "getOffsetAtOutCoordsByGlobalId(globalId, index)";
    }
    let scaleSnippet = "1.0";
    if (this.scaleShape != null) {
      scaleSnippet = "getScaleAtOutCoordsByGlobalId(globalId, index)";
    }
    const dim = this.outputShape.length;
    const coordsDataType = getCoordsDataType2(dim);
    let setOutput = "setOutput(coords[0], coords[1], coords[2], coords[3], value);";
    if (dim === 2) {
      setOutput = "setOutput(coords[0], coords[1], value);";
    }
    if (dim === 3) {
      setOutput = "setOutput(coords[0], coords[1], coords[2], value);";
    }
    const userCode = `
      fn writeResult(coords : ${coordsDataType}, value : f32) {
        if (coordsInBounds${dim}D(coords, uniforms.outShape)) {
          ${setOutput}
        }
      }
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        let xValue = getXAtOutCoordsByGlobalId(globalId, index);
        let meanValue = getMeanAtOutCoordsByGlobalId(globalId, index);
        let varianValue = getVarianceAtOutCoordsByGlobalId(globalId, index);
        let offsetValue = ${offsetSnippet};
        let scaleValue = ${scaleSnippet};
        let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
        writeResult(coords,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
      }
  `;
    return userCode;
  }
};
var fusedBatchNormConfig2 = {
  kernelName: FusedBatchNorm,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2, scale: scale22, offset, mean: mean5, variance } = inputs;
    const { varianceEpsilon } = attrs;
    const webGPUBackend = backend22;
    const batchNormInputs = [x2, mean5, variance];
    let offsetShape = null;
    if (offset != null) {
      offsetShape = offset.shape;
      batchNormInputs.push(offset);
    }
    let scaleShape = null;
    if (scale22 != null) {
      scaleShape = scale22.shape;
      batchNormInputs.push(scale22);
    }
    const program = new BatchNormProgram2(x2.shape, mean5.shape, variance.shape, offsetShape, scaleShape);
    const uniformData = [{ type: "float32", data: [varianceEpsilon] }];
    return webGPUBackend.runWebGPUProgram(program, batchNormInputs, x2.dtype, uniformData);
  }
};
function fusedConv2d3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  let program;
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    return conv2dByMatMul2({
      x: x2,
      filter,
      convInfo,
      backend: backend22,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  }
  const useNaive = env().getBool("WEBGPU_USE_NAIVE_CONV2D");
  const useVec4 = convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;
  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];
  const dimensions = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [...padInfo] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] }
  ];
  if (useNaive) {
    program = new Conv2DNaiveProgram(convInfo, hasBias, activation2, hasPreluActivationWeights);
  } else {
    if (useVec4) {
      program = new Conv2DMMVec4Program(convInfo, hasBias, activation2, hasPreluActivationWeights);
    } else {
      program = new Conv2DMMProgram(convInfo, hasBias, activation2, hasPreluActivationWeights);
    }
    const dimAOuter = convInfo.outShape[1] * convInfo.outShape[2];
    const dimBOuter = convInfo.outShape[3];
    const dimInner = convInfo.filterHeight * convInfo.filterWidth * convInfo.inShape[3];
    dimensions.push({ type: "int32", data: [dimAOuter] }, { type: "int32", data: [dimBOuter] }, { type: "int32", data: [dimInner] });
  }
  const inputVar = [x2, filter];
  if (hasBias) {
    inputVar.push(bias);
  }
  if (hasPreluActivationWeights) {
    inputVar.push(preluActivationWeights);
  }
  return backend22.runWebGPUProgram(program, inputVar, x2.dtype, dimensions);
}
var fusedConv2DConfig4 = {
  kernelName: FusedConv2D,
  backendName: "webgpu",
  kernelFunc: fusedConv2d3
};
function fusedDepthwiseConv2D3(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad3, dilations, dimRoundingMode, activation: activation2 } = attrs;
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
  const programInputs = [x2, filter];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  if (hasBias) {
    programInputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    programInputs.push(preluActivationWeights);
  }
  let program;
  if (convInfo.batchSize === 1 && convInfo.inHeight === convInfo.outHeight && convInfo.inWidth === convInfo.outWidth && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && convInfo.filterHeight === convInfo.filterWidth && convInfo.inChannels === convInfo.outChannels && convInfo.filterHeight === 3 && convInfo.inChannels % 4 === 0) {
    program = new DepthwiseConv2D3x3Program(convInfo, hasBias, activation2, hasPreluActivationWeights);
  } else {
    program = new DepthwiseConv2DProgram2(convInfo, hasBias, activation2, hasPreluActivationWeights);
  }
  const dimensions = [
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }
  ];
  const result = backend22.runWebGPUProgram(program, programInputs, "float32", dimensions);
  return result;
}
var fusedDepthwiseConv2DConfig4 = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "webgpu",
  kernelFunc: fusedDepthwiseConv2D3
};
var GatherNDProgram2 = class {
  constructor(sliceDim, shape) {
    this.variableNames = ["A", "indices"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = `gathernd_${sliceDim}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.sliceDim = sliceDim;
    this.uniforms = `sliceDim : i32; strides : ${getCoordsDataType2(sliceDim)};`;
  }
  getUserCode() {
    let strideString;
    if (this.sliceDim > 1) {
      strideString = "uniforms.strides[j]";
    } else {
      strideString = "uniforms.strides";
    }
    const userCode = `
        ${getMainHeaderString()} {
          ${getGlobalIndexString()}
          let coords = getOutputCoords(globalId, index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${strideString};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }
          if (index < uniforms.size) {
            setOutputFlat(index, getA(flattenIndex, coords[1]));
          }
        }
      `;
    return userCode;
  }
};
function gatherNd4(args) {
  const { inputs, backend: backend22 } = args;
  const { params, indices } = inputs;
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const paramsSize = util_exports.sizeFromShape(params.shape);
  const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
  const flattenIndices = reshape6({ inputs: { x: indices }, backend: backend22, attrs: { shape: [numSlices, sliceRank] } });
  const flattenX = reshape6({
    inputs: { x: params },
    backend: backend22,
    attrs: { shape: [util_exports.sizeFromShape(params.shape) / sliceSize, sliceSize] }
  });
  if (backend22.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
    const indicesData = backend22.readSync(indices.dataId);
    const paramsBuf = backend22.bufferSync(params);
    const outValue = gatherNdImplCPU2(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend22.makeTensorInfo(resultShape, params.dtype, outValue.values);
  }
  const program = new GatherNDProgram2(sliceRank, [numSlices, sliceSize]);
  const uniformData = [{ type: "int32", data: [sliceRank] }, { type: "int32", data: strides }];
  const res2 = backend22.runWebGPUProgram(program, [flattenX, flattenIndices], flattenX.dtype, uniformData);
  const reshaped = reshape6({ inputs: { x: res2 }, backend: backend22, attrs: { shape: resultShape } });
  backend22.disposeData(flattenIndices.dataId);
  backend22.disposeData(flattenX.dataId);
  backend22.disposeData(res2.dataId);
  return reshaped;
}
var gatherNdConfig4 = {
  kernelName: GatherNd,
  backendName: "webgpu",
  kernelFunc: gatherNd4
};
var GatherProgram2 = class {
  constructor(aShape, outputShape) {
    this.variableNames = ["A", "indices"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = aShape.slice();
    this.aShape = aShape;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = `gather`;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const sourceCoords = getSourceCoords4(this.aShape, "i32");
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let resRC = getOutputCoords(globalId, index);
        if (index < uniforms.size) {
          setOutputFlat(index, getA(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
};
function getSourceCoords4(aShape, typePrefix = "int") {
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i2 = 0; i2 < aShape.length; i2++) {
    if (i2 === 2) {
      sourceCoords.push(`${typePrefix}(getIndices(resRC.x, resRC.z))`);
    } else {
      sourceCoords.push(`${currentCoords[i2]}`);
    }
  }
  return sourceCoords.join();
}
function gatherV24(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2, indices } = inputs;
  const { axis, batchDims } = attrs;
  const parsedAxis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const indicesVals = backend22.readSync(indices.dataId);
  const axisDim = x2.shape[parsedAxis];
  for (let i2 = 0; i2 < indicesVals.length; ++i2) {
    const index = indicesVals[i2];
    util_exports.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
  }
  const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x2, indices, parsedAxis, batchDims);
  const indicesSize = util_exports.sizeFromShape(indices.shape);
  const toDispose = [];
  const flattenX = reshape6({
    inputs: { x: x2 },
    backend: backend22,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape6({
    inputs: { x: indices },
    backend: backend22,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  toDispose.push(flattenX);
  toDispose.push(flattenIndex);
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  if (backend22.shouldExecuteOnCPU([x2, indices])) {
    const indicesBufferInfo = backend22.tensorMap.get(flattenIndex.dataId);
    const indicesValues = indicesBufferInfo.values;
    const indicesBuf = buffer(flattenIndex.shape, flattenIndex.dtype, indicesValues);
    const xBufferInfo = backend22.tensorMap.get(flattenX.dataId);
    const xValues = xBufferInfo.values;
    const xBuf = buffer(flattenX.shape, flattenX.dtype, xValues);
    const outBuf = gatherV2ImplCPU2(xBuf, indicesBuf, flattenOutputShape);
    toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
    return backend22.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
  }
  const program = new GatherProgram2(flattenX.shape, flattenOutputShape);
  const res2 = backend22.runWebGPUProgram(program, [flattenX, flattenIndex], flattenX.dtype);
  toDispose.push(res2);
  const reshaped = reshape6({ inputs: { x: res2 }, backend: backend22, attrs: { shape: shapeInfo.outputShape } });
  toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
  return reshaped;
}
var gatherV2Config4 = {
  kernelName: GatherV2,
  backendName: "webgpu",
  kernelFunc: gatherV24
};
var greater5 = binaryKernelFunc3({
  opSnippet: BinaryOpType.GREATER,
  cpuKernelImpl: greaterImplCPU2,
  dtype: "bool"
});
var greaterConfig4 = {
  kernelName: Greater,
  backendName: "webgpu",
  kernelFunc: greater5
};
var greaterEqual4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.GREATER_EQUAL,
  dtype: "bool",
  cpuKernelImpl: greaterEqualImplCPU2
});
var greaterEqualConfig4 = {
  kernelName: GreaterEqual,
  backendName: "webgpu",
  kernelFunc: greaterEqual4
};
var less5 = binaryKernelFunc3({ opSnippet: BinaryOpType.LESS, dtype: "bool", cpuKernelImpl: lessImplCPU2 });
var lessConfig4 = {
  kernelName: Less,
  backendName: "webgpu",
  kernelFunc: less5
};
var lessEqual4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.LESS_EQUAL,
  dtype: "bool",
  cpuKernelImpl: lessEqualImplCPU2
});
var lessEqualConfig4 = {
  kernelName: LessEqual,
  backendName: "webgpu",
  kernelFunc: lessEqual4
};
var log8 = unaryKernelFunc3({ opType: UnaryOpType.LOG, cpuKernelImpl: logImplCPU2 });
var logConfig4 = {
  kernelName: Log,
  backendName: "webgpu",
  kernelFunc: log8
};
var logicalAnd4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.LOGICAL_AND,
  dtype: "bool"
});
var logicalAndConfig4 = {
  kernelName: LogicalAnd,
  backendName: "webgpu",
  kernelFunc: logicalAnd4
};
var logicalNot4 = unaryKernelFunc3({ opType: UnaryOpType.LOGICAL_NOT });
var logicalNotConfig3 = {
  kernelName: LogicalNot,
  backendName: "webgpu",
  kernelFunc: logicalNot4
};
function max6(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { reductionIndices, keepDims } = attrs;
  return reduce2(x2, reductionIndices, keepDims, "max", backend22);
}
var maxConfig4 = {
  kernelName: Max,
  backendName: "webgpu",
  kernelFunc: max6
};
var maximum5 = binaryKernelFunc3({
  opSnippet: BinaryOpType.MAX,
  cpuKernelImpl: maximumImplCPU2
});
var maximumConfig4 = {
  kernelName: Maximum,
  backendName: "webgpu",
  kernelFunc: maximum5
};
function maxPool5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
  const dilations = 1;
  const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
  let program;
  const dimensions = [];
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1) {
    if (util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity5({ inputs: { x: x2 }, backend: backend22 });
    }
    program = new PoolWithFilterSizeEqualsOneProgram(convInfo);
    dimensions.push({ type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] });
  } else {
    program = new Pool2DProgram2(convInfo, "max");
    dimensions.push({ type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] }, { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] }, {
      type: "int32",
      data: [convInfo.dilationHeight, convInfo.dilationWidth]
    }, { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }, {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    });
  }
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, dimensions);
}
var maxPoolConfig4 = {
  kernelName: MaxPool,
  backendName: "webgpu",
  kernelFunc: maxPool5
};
function mean4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { keepDims, axis } = attrs;
  return reduce2(x2, axis, keepDims, "mean", backend22);
}
var meanConfig4 = {
  kernelName: Mean,
  backendName: "webgpu",
  kernelFunc: mean4
};
function min6(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  return reduce2(x2, axis, keepDims, "min", backend22);
}
var minConfig4 = {
  kernelName: Min,
  backendName: "webgpu",
  kernelFunc: min6
};
var minimum5 = binaryKernelFunc3({
  opSnippet: BinaryOpType.MIN,
  cpuKernelImpl: minimumImplCPU2
});
var minimumConfig4 = {
  kernelName: Minimum,
  backendName: "webgpu",
  kernelFunc: minimum5
};
var MirrorPadProgram2 = class {
  constructor(xShape, paddings, mode) {
    this.uniforms = "";
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.xShape = xShape;
    paddings.map((_2, i2) => {
      this.uniforms += ` pad${i2} : vec2<i32>;`;
    });
    this.offset = mode === "reflect" ? 0 : 1;
    this.shaderKey = `mirrorPad_${mode}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const rank = this.xShape.length;
    const start = this.xShape.map((_2, i2) => `uniforms.pad${i2}[0]`).join(",");
    const end = this.xShape.map((_2, i2) => `uniforms.pad${i2}[0] + uniforms.xShape${rank > 1 ? `[${i2}]` : ""}`).join(",");
    const shaderStart = rank === 1 ? "start" : "start[i]";
    const shaderEnd = rank === 1 ? "end" : "end[i]";
    const shaderOutC = rank === 1 ? "outC" : "outC[i]";
    const dtype = getCoordsDataType2(rank);
    const unpackedCoords = rank > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank) : "coords";
    return `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let start = ${dtype}(${start});
        let end = ${dtype}(${end});
        var outC = getOutputCoords(globalId, index);
        if (index < uniforms.size) {
          for (var i = 0; i < ${rank}; i = i + 1) {
            if (${shaderOutC} < ${shaderStart}) {
              ${shaderOutC} = ${shaderStart} * 2 - ${shaderOutC} - ${this.offset};
            } elseif(${shaderOutC} >= ${shaderEnd}) {
              ${shaderOutC} = (${shaderEnd} - 1) * 2 - ${shaderOutC} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputFlat(index, getX(${unpackedCoords}));
        }
      }
    `;
  }
};
var mirrorPadConfig4 = {
  kernelName: MirrorPad,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const { paddings, mode } = attrs;
    const webGPUBackend = backend22;
    const uniformData = paddings.map((p22) => {
      return { type: "int32", data: [p22[0], p22[1]] };
    });
    const program = new MirrorPadProgram2(x2.shape, paddings, mode);
    const output = webGPUBackend.runWebGPUProgram(program, [x2], x2.dtype, uniformData);
    return output;
  }
};
function neg4(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (backend22.shouldExecuteOnCPU([x2])) {
    const xData = backend22.tensorMap.get(x2.dataId);
    const [outValues, newShape] = negImplCPU2(xData.values, x2.shape, x2.dtype);
    return backend22.makeTensorInfo(newShape, x2.dtype, outValues);
  }
  const program = new UnaryOpProgram2(x2.shape, UnaryOpType.NEG);
  return backend22.runWebGPUProgram(program, [x2], x2.dtype);
}
var negConfig4 = {
  kernelName: Neg,
  backendName: "webgpu",
  kernelFunc: neg4
};
function nonMaxSuppressionV33(args) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  const boxesVals = backend22.readSync(boxes.dataId);
  const scoresVals = backend22.readSync(scores.dataId);
  const { selectedIndices } = kernel_impls_exports.nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Config4 = {
  kernelName: NonMaxSuppressionV3,
  backendName: "webgpu",
  kernelFunc: nonMaxSuppressionV33
};
function nonMaxSuppressionV53(args) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend22, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  const boxesVals = backend22.readSync(boxes.dataId);
  const scoresVals = backend22.readSync(scores.dataId);
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = kernel_impls_exports.nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend22.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend22.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Config4 = {
  kernelName: NonMaxSuppressionV5,
  backendName: "webgpu",
  kernelFunc: nonMaxSuppressionV53
};
function zerosLike5(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "complex64") {
    const realPart = real4({ inputs: { input: x2 }, backend: backend22 });
    const r2 = zerosLike5({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag4({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike5({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex4({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeData(realPart.dataId);
    backend22.disposeData(r2.dataId);
    backend22.disposeData(imagPart.dataId);
    backend22.disposeData(i2.dataId);
    return result;
  } else {
    return fill5({
      attrs: {
        shape: x2.shape,
        dtype: x2.dtype,
        value: x2.dtype === "string" ? "" : 0
      },
      backend: backend22
    });
  }
}
var zerosLikeConfig4 = {
  kernelName: ZerosLike,
  backendName: "webgpu",
  kernelFunc: zerosLike5
};
function onesLike5(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2 } = inputs;
  if (x2.dtype === "string") {
    throw new Error("onesLike is not supported under string dtype");
  } else if (x2.dtype === "complex64") {
    const realPart = real4({ inputs: { input: x2 }, backend: backend22 });
    const r2 = onesLike5({ inputs: { x: realPart }, backend: backend22 });
    const imagPart = imag4({ inputs: { input: x2 }, backend: backend22 });
    const i2 = zerosLike5({ inputs: { x: imagPart }, backend: backend22 });
    const result = complex4({ inputs: { real: r2, imag: i2 }, backend: backend22 });
    backend22.disposeData(realPart.dataId);
    backend22.disposeData(r2.dataId);
    backend22.disposeData(imagPart.dataId);
    backend22.disposeData(i2.dataId);
    return result;
  } else {
    return fill5({ attrs: { shape: x2.shape, dtype: x2.dtype, value: 1 }, backend: backend22 });
  }
}
var onesLikeConfig4 = {
  kernelName: OnesLike,
  backendName: "webgpu",
  kernelFunc: onesLike5
};
function pack4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims6({ inputs: { input: inputs[0] }, backend: backend22, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t2) => {
    util_exports.assertShapesMatch(shape, t2.shape, "All tensors passed to stack must have matching shapes");
    util_exports.assert(dtype === t2.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t2) => {
    const expandedT = expandDims6({ inputs: { input: t2 }, backend: backend22, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat5({ inputs: expandedTensors, backend: backend22, attrs: { axis } });
  intermediateTensorInfos.forEach((t2) => backend22.disposeData(t2.dataId));
  return result;
}
var packConfig4 = {
  kernelName: Pack,
  backendName: "webgpu",
  kernelFunc: pack4
};
var PadProgram2 = class {
  constructor(xShape, paddings) {
    this.variableNames = ["x"];
    this.uniforms = "constantValue : f32;";
    this.workGroupSize = [64, 1, 1];
    this.outputShape = paddings.map((p22, i2) => p22[0] + xShape[i2] + p22[1]);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    paddings.map((_2, i2) => {
      this.uniforms += ` pad${i2} : vec2<i32>;`;
    });
    this.xShape = xShape;
    this.shaderKey = "pad";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const rank = this.xShape.length;
    const type = getCoordsDataType2(rank);
    const start = this.xShape.map((_2, i2) => `uniforms.pad${i2}[0]`).join(",");
    const end = this.xShape.map((_2, i2) => `uniforms.pad${i2}[0] + uniforms.xShape${rank > 1 ? `[${i2}]` : ""}`).join(",");
    const startValue = rank > 1 ? `${type}(${start})` : `${start}`;
    const endValue = rank > 1 ? `${type}(${end})` : `${end}`;
    const leftPadCondition = rank > 1 ? `any(outC < start)` : `outC < start`;
    const rightPadCondition = rank > 1 ? `any(outC >= end)` : `outC >= end`;
    const unpackedCoords = rank > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank) : "coords";
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let start = ${startValue};
        let end = ${endValue};
        if (index < uniforms.size) {
          let outC = getOutputCoords(globalId, index);

          if (${leftPadCondition} || ${rightPadCondition}) {
            setOutputFlat(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputFlat(index, getX(${unpackedCoords}));
          }
        }
      }
    `;
    return userCode;
  }
};
var padV23 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { paddings, constantValue } = attrs;
  if (paddings.every((p22) => util_exports.arraysEqual(p22, [0, 0]))) {
    return identity5({ inputs: { x: x2 }, backend: backend22 });
  }
  if (util_exports.sizeFromShape(x2.shape) === 0) {
    const outputShape = paddings.map((p22, i2) => p22[0] + x2.shape[i2] + p22[1]);
    return fill5({
      backend: backend22,
      attrs: { shape: outputShape, value: constantValue, dtype: x2.dtype }
    });
  }
  const uniformData = [{ type: "float32", data: [constantValue] }];
  paddings.map((p22) => uniformData.push({ type: "int32", data: [p22[0], p22[1]] }));
  const program = new PadProgram2(x2.shape, paddings);
  return backend22.runWebGPUProgram(program, [x2], x2.dtype, uniformData);
};
var padV2Config4 = {
  kernelName: PadV2,
  backendName: "webgpu",
  kernelFunc: padV23
};
var pow4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.POW
});
var powConfig4 = {
  kernelName: Pow,
  backendName: "webgpu",
  kernelFunc: pow4
};
function prelu6(args) {
  const { inputs, backend: backend22 } = args;
  const { x: x2, alpha } = inputs;
  const program = new BinaryOpProgram2(BinaryOpType.PRELU, x2.shape, alpha.shape);
  return backend22.runWebGPUProgram(program, [x2, alpha], "float32");
}
var preluConfig4 = {
  kernelName: Prelu,
  backendName: "webgpu",
  kernelFunc: prelu6
};
function prod5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { axis, keepDims } = attrs;
  return reduce2(x2, axis, keepDims, "prod", backend22);
}
var prodConfig4 = {
  kernelName: Prod,
  backendName: "webgpu",
  kernelFunc: prod5
};
var range6 = (args) => {
  const { backend: backend22, attrs } = args;
  const { start, stop, step: step5, dtype } = attrs;
  const values = rangeImplCPU2(start, stop, step5, dtype);
  return backend22.makeTensorInfo([values.length], dtype, values);
};
var rangeConfig4 = {
  kernelName: Range,
  backendName: "webgpu",
  kernelFunc: range6
};
var realDiv2 = binaryKernelFunc3({ opSnippet: BinaryOpType.DIV });
var realDivConfig4 = {
  kernelName: RealDiv,
  backendName: "webgpu",
  kernelFunc: realDiv2
};
var relu4 = unaryKernelFunc3({ opType: UnaryOpType.RELU });
var reluConfig4 = {
  kernelName: Relu,
  backendName: "webgpu",
  kernelFunc: relu4
};
var relu64 = unaryKernelFunc3({ opType: UnaryOpType.RELU6 });
var relu6Config4 = {
  kernelName: Relu6,
  backendName: "webgpu",
  kernelFunc: relu64
};
var ResizeBilinearProgram2 = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.alignCorners = alignCorners;
    this.halfPixelCenters = halfPixelCenters;
    this.shaderKey = `resizeBilinear_${alignCorners}_${halfPixelCenters}_${this.outputShape[1] > 1}_${this.outputShape[2] > 1}`;
  }
  getUserCode() {
    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;
    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        if (all(coords < uniforms.outShape)) {
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            ${adjustHeight ? `f32(uniforms.xShape.y) - 1.0` : `f32(uniforms.xShape.y)`},
            ${adjustWidth ? `f32(uniforms.xShape.z) - 1.0` : `f32(uniforms.xShape.z)`});

          let effectiveOutSize = vec2<f32>(
            ${adjustHeight ? `f32(uniforms.outShape.y) - 1.0` : `f32(uniforms.outShape.y)`},
            ${adjustWidth ? `f32(uniforms.outShape.z) - 1.0` : `f32(uniforms.outShape.z)`});

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${this.halfPixelCenters ? "(vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC - vec2<f32>(0.5)" : "vec2<f32>(rc) * effectiveInputOverOutputRatioRC"};

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutput(b, coords[1], coords[2], d, newValue);
        }
      }
    `;
    return userCode;
  }
};
function resizeBilinear5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, size: size2, halfPixelCenters } = attrs;
  const [newHeight, newWidth] = size2;
  const program = new ResizeBilinearProgram2(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend22.runWebGPUProgram(program, [images], "float32");
}
var resizeBilinearConfig4 = {
  kernelName: ResizeBilinear,
  backendName: "webgpu",
  kernelFunc: resizeBilinear5
};
var ResizeNearestNeighborProgram2 = class {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.alignCorners = alignCorners;
    this.halfPixelCenters = halfPixelCenters;
    this.shaderKey = `resizeNearest_${alignCorners}_${this.outputShape[1] > 1}_${this.outputShape[2] > 1}_${halfPixelCenters}`;
  }
  getUserCode() {
    const roundBase = this.alignCorners ? "0.5" : "0.0";
    let sourceFracIndexRC;
    if (this.halfPixelCenters) {
      sourceFracIndexRC = `max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))`;
    } else {
      sourceFracIndexRC = `vec2<f32>(rc) * effectiveInputOverOutputRatioRC`;
    }
    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;
    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let coords = getOutputCoords(globalId, index);
        if (all(coords < uniforms.outShape)) {
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            ${adjustHeight ? `f32(uniforms.xShape.y) - 1.0` : `f32(uniforms.xShape.y)`},
            ${adjustWidth ? `f32(uniforms.xShape.z) - 1.0` : `f32(uniforms.xShape.z)`});

          let effectiveOutSize = vec2<f32>(
            ${adjustHeight ? `f32(uniforms.outShape.y) - 1.0` : `f32(uniforms.outShape.y)`},
            ${adjustWidth ? `f32(uniforms.outShape.z) - 1.0` : `f32(uniforms.outShape.z)`});

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${sourceFracIndexRC};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutput(b, coords[1], coords[2], d, newValue);
        }
      }
    `;
    return userCode;
  }
};
function resizeNearestNeighbor4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size: size2 } = attrs;
  const [newHeight, newWidth] = size2;
  const program = new ResizeNearestNeighborProgram2(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend22.runWebGPUProgram(program, [images], images.dtype);
}
var resizeNearestNeighborConfig3 = {
  kernelName: ResizeNearestNeighbor,
  backendName: "webgpu",
  kernelFunc: resizeNearestNeighbor4
};
var RotateProgram2 = class {
  constructor(imageShape, fillValue) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = imageShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.uniforms = `centerX : f32; centerY : f32; sinRadians : f32;
          cosRadians : f32;`;
    this.shaderKey = "rotate";
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.outputShape = imageShape;
    if (typeof fillValue === "number") {
      this.uniforms += ` fillValue : f32;`;
      this.fillSnippet = `var outputValue = uniforms.fillValue;`;
      this.shaderKey += "_float";
    } else {
      this.uniforms += ` fillValue : vec3<f32>;`;
      this.fillSnippet = `var outputValue = uniforms.fillValue[coords[3]];`;
      this.shaderKey += "_vec3";
    }
  }
  getUserCode() {
    const userCode = `
        ${getMainHeaderString()} {
          ${getGlobalIndexString()}

          if (index < uniforms.size) {
            let coords = getOutputCoords(globalId, index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputFlat(index, outputValue);
          }
        }
      `;
    return userCode;
  }
};
var rotateWithOffsetConfig4 = {
  kernelName: RotateWithOffset,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend22 }) => {
    const { image: image32 } = inputs;
    const { radians, fillValue, center } = attrs;
    const webgpuBackend = backend22;
    const program = new RotateProgram2(image32.shape, fillValue);
    const [centerX, centerY] = backend_util_exports.getImageCenter(center, image32.shape[1], image32.shape[2]);
    const uniformData = [
      { type: "float32", data: [centerX] },
      { type: "float32", data: [centerY] },
      { type: "float32", data: [Math.sin(radians)] },
      { type: "float32", data: [Math.cos(radians)] }
    ];
    if (typeof fillValue === "number") {
      uniformData.push({ type: "float32", data: [Number.parseFloat(fillValue.toFixed(2))] });
    } else {
      uniformData.push({ type: "float32", data: fillValue });
    }
    const output = webgpuBackend.runWebGPUProgram(program, [image32], image32.dtype, uniformData);
    return output;
  }
};
var rsqrt4 = unaryKernelFunc3({ opType: UnaryOpType.RSQRT, cpuKernelImpl: rsqrtImplCPU2 });
var rsqrtConfig4 = {
  kernelName: Rsqrt,
  backendName: "webgpu",
  kernelFunc: rsqrt4
};
var ScatterProgram2 = class {
  constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.workGroupSize = [64, 1, 1];
    this.workPerThread = 4;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    const sliceDimGreaterThanOne = sliceDim > 1;
    this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${sliceDimGreaterThanOne}`;
    this.size = util_exports.sizeFromShape(this.outputShape);
    const stridesType = getCoordsDataType2(strides.length);
    this.uniforms = `updateSize : i32; sliceDim : i32; strides: ${stridesType};`;
    let indicesString = "";
    if (indicesRank === 1) {
      indicesString = "i";
    } else if (indicesRank === 2) {
      indicesString = "i, j";
    }
    this.indicesSnippet = `getIndices(${indicesString})`;
    let updatesString = "";
    if (updatesRank === 1) {
      updatesString = "i";
    } else if (updatesRank === 2) {
      updatesString = "i, coords[1]";
    }
    this.updatesSnippet = `getUpdates(${updatesString})`;
    this.strideString = sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}

        let globalIndex = index * ${this.workPerThread};
        if (globalIndex < uniforms.size) {
          var sum = vec4<f32>(0.0);
          var found = vec4<bool>(false);
          for (var i = 0; i < uniforms.updateSize; i = i + 1) {
            var flattenedIndex = 0;
            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
              let indexInside = i32(round(${this.indicesSnippet}));
              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};
            }
            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
              let curIndex = globalIndex + innerIndex;
              let coords = getCoordsFromFlatIndex(curIndex);
              if (flattenedIndex == coords[0]) {
                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};
                found[innerIndex] = true;
              }
            }
          }
          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
            let curIndex = globalIndex + innerIndex;
            if (curIndex < uniforms.size)
            {
              setOutputFlat(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));
            }
          }
        }
      }`;
    return userCode;
  }
};
function scatterNd4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(updates, indices, shape);
  const flattenShape = [outputSize2 / sliceSize, sliceSize];
  if (outputSize2 === 0) {
    return backend22.makeTensorInfo(shape, indices.dtype);
  }
  const flattenIndices = reshape6({ inputs: { x: indices }, backend: backend22, attrs: { shape: [numUpdates, sliceRank] } });
  const flattenX = reshape6({ inputs: { x: updates }, backend: backend22, attrs: { shape: [numUpdates, sliceSize] } });
  const defaultValue = backend22.makeTensorInfo([], "float32", new Float32Array([0]));
  const uniformData = [
    { type: "int32", data: [numUpdates] },
    { type: "int32", data: [sliceRank] },
    { type: "int32", data: strides }
  ];
  const program = new ScatterProgram2(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
  const res2 = backend22.runWebGPUProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype, uniformData);
  const reshaped = reshape6({ inputs: { x: res2 }, backend: backend22, attrs: { shape } });
  backend22.disposeData(flattenIndices.dataId);
  backend22.disposeData(flattenX.dataId);
  backend22.disposeData(res2.dataId);
  backend22.disposeData(defaultValue.dataId);
  return reshaped;
}
var scatterNdConfig4 = {
  kernelName: ScatterNd,
  backendName: "webgpu",
  kernelFunc: scatterNd4
};
var SelectProgram2 = class {
  constructor(cRank, shape, rank) {
    this.variableNames = ["c", "a", "b"];
    this.workGroupSize = [64, 1, 1];
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.cRank = cRank;
    this.rank = rank;
    this.shaderKey = "select";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    let cCoords;
    let abCoords;
    if (this.rank > 4) {
      throw Error(`Where for rank ${this.rank} is not yet supported`);
    }
    if (this.rank === 1) {
      abCoords = `resRC`;
      cCoords = `resRC`;
    } else {
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const cCoordVars = [];
      const abCoordVars = [];
      for (let i2 = 0; i2 < this.outputShape.length; i2++) {
        abCoordVars.push(`${currentCoords[i2]}`);
        if (i2 < this.cRank) {
          cCoordVars.push(`${currentCoords[i2]}`);
        }
      }
      cCoords = cCoordVars.join();
      abCoords = abCoordVars.join();
    }
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          let resRC = getOutputCoords(globalId, index);
          let cVal = getC(${cCoords});
          if (cVal >= 1.0) {
            setOutputFlat(index, getA(${abCoords}));
          } else {
            setOutputFlat(index, getB(${abCoords}));
          }
        }
      }
    `;
    return userCode;
  }
};
function select5(args) {
  const { inputs, backend: backend22 } = args;
  const { condition, t: t2, e: e2 } = inputs;
  const program = new SelectProgram2(condition.shape.length, t2.shape, t2.shape.length);
  return backend22.runWebGPUProgram(program, [condition, t2, e2], upcastType(t2.dtype, e2.dtype));
}
var selectConfig4 = {
  kernelName: Select,
  backendName: "webgpu",
  kernelFunc: select5
};
var sigmoid5 = unaryKernelFunc3({ opType: UnaryOpType.SIGMOID });
var sigmoidConfig4 = {
  kernelName: Sigmoid,
  backendName: "webgpu",
  kernelFunc: sigmoid5
};
var sin4 = unaryKernelFunc3({ opType: UnaryOpType.SIN });
var sinConfig4 = {
  kernelName: Sin,
  backendName: "webgpu",
  kernelFunc: sin4
};
var sinh4 = unaryKernelFunc3({ opType: UnaryOpType.SINH });
var sinhConfig3 = {
  kernelName: Sinh,
  backendName: "webgpu",
  kernelFunc: sinh4
};
var sub4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.SUB,
  cpuKernelImpl: subImplCPU2,
  supportsComplex: true
});
var subConfig4 = {
  kernelName: Sub,
  backendName: "webgpu",
  kernelFunc: sub4
};
function softmax6(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const axes = util_exports.parseAxisParam([dim], logits.shape);
  const maxLogit = max6({
    inputs: { x: logits },
    backend: backend22,
    attrs: { reductionIndices: axes, keepDims: false }
  });
  const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
  const maxLogitsReshaped = reshape6({ inputs: { x: maxLogit }, backend: backend22, attrs: { shape: expandedShape } });
  const a6 = sub4({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend22 });
  const b2 = exp4({ inputs: { x: a6 }, backend: backend22 });
  const sumExp = sum6({ inputs: { x: b2 }, backend: backend22, attrs: { axis: axes, keepDims: false } });
  const sumExpReshaped = reshape6({ inputs: { x: sumExp }, backend: backend22, attrs: { shape: expandedShape } });
  const res2 = realDiv2({ inputs: { a: b2, b: sumExpReshaped }, backend: backend22 });
  backend22.disposeData(maxLogit.dataId);
  backend22.disposeData(maxLogitsReshaped.dataId);
  backend22.disposeData(a6.dataId);
  backend22.disposeData(b2.dataId);
  backend22.disposeData(sumExp.dataId);
  backend22.disposeData(sumExpReshaped.dataId);
  return res2;
}
var softmaxConfig4 = {
  kernelName: Softmax,
  backendName: "webgpu",
  kernelFunc: softmax6
};
var spaceToBatchND5 = (args) => {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { blockShape, paddings } = attrs;
  util_exports.assert(x2.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
  const prod6 = blockShape.reduce((a6, b2) => a6 * b2);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i2 = 1 + blockShape.length; i2 < x2.shape.length; ++i2) {
    completePaddings.push([0, 0]);
  }
  const toDispose = [];
  const paddedX = padV23({
    inputs: { x: x2 },
    backend: backend22,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod6, false);
  const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod6, false);
  const reshapedPaddedX = reshape6({ inputs: { x: paddedX }, backend: backend22, attrs: { shape: reshapedPaddedShape } });
  const paddedXT = transpose5({
    inputs: { x: reshapedPaddedX },
    backend: backend22,
    attrs: { perm: permutedReshapedPaddedPermutation }
  });
  const result = reshape6({ inputs: { x: paddedXT }, backend: backend22, attrs: { shape: flattenShape } });
  toDispose.push(paddedX);
  toDispose.push(reshapedPaddedX);
  toDispose.push(paddedXT);
  toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
  return result;
};
var spaceToBatchNDConfig4 = {
  kernelName: SpaceToBatchND,
  backendName: "webgpu",
  kernelFunc: spaceToBatchND5
};
function sparseToDense4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, strides, outputSize: outputSize2 } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  const uniformData = [
    { type: "int32", data: [numUpdates] },
    { type: "int32", data: [sliceRank] },
    { type: "int32", data: strides }
  ];
  const program = new ScatterProgram2(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize2, 1], sumDupeIndices);
  const res2 = backend22.runWebGPUProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype, uniformData);
  const reshaped = reshape6({ inputs: { x: res2 }, backend: backend22, attrs: { shape: outputShape } });
  backend22.disposeData(res2.dataId);
  return reshaped;
}
var sparseToDenseConfig3 = {
  kernelName: SparseToDense,
  backendName: "webgpu",
  kernelFunc: sparseToDense4
};
function splitV4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = util_exports.parseAxisParam(axis, x2.shape)[0];
  const splitSizes = backend_util_exports.prepareSplitSize(x2, numOrSizeSplits, $axis);
  const xRank = x2.shape.length;
  const begin = new Array(xRank).fill(0);
  const size2 = x2.shape.slice();
  return splitSizes.map((s2) => {
    const sliceSize = [...size2];
    sliceSize[$axis] = s2;
    const sliceT = slice5({ inputs: { x: x2 }, backend: backend22, attrs: { begin, size: sliceSize } });
    begin[$axis] += s2;
    return sliceT;
  });
}
var splitVConfig4 = {
  kernelName: SplitV,
  backendName: "webgpu",
  kernelFunc: splitV4
};
var sqrt4 = unaryKernelFunc3({ opType: UnaryOpType.SQRT });
var sqrtConfig4 = {
  kernelName: Sqrt,
  backendName: "webgpu",
  kernelFunc: sqrt4
};
var squareConfig4 = {
  kernelName: Square,
  backendName: "webgpu",
  kernelFunc: ({ inputs, backend: backend22 }) => {
    const { x: x2 } = inputs;
    const webGPUBackend = backend22;
    const program = new UnaryOpProgram2(x2.shape, UnaryOpType.SQUARE);
    return webGPUBackend.runWebGPUProgram(program, [x2], x2.dtype);
  }
};
var squaredDifference4 = binaryKernelFunc3({
  opSnippet: BinaryOpType.SQUARED_DIFFERENCE
});
var squaredDifferenceConfig4 = {
  kernelName: SquaredDifference,
  backendName: "webgpu",
  kernelFunc: squaredDifference4
};
var StridedSliceProgram2 = class {
  constructor(destSize) {
    this.variableNames = ["x"];
    this.workPerThread = 1;
    this.workGroupSize = [64, 1, 1];
    this.outputShape = destSize;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    const dtype = getCoordsDataType2(this.outputShape.length);
    this.uniforms = `begin : ${dtype};  strides : ${dtype}; `;
    this.shaderKey = "stridedSlice";
    this.size = util_exports.sizeFromShape(this.outputShape);
  }
  getUserCode() {
    const rank = this.outputShape.length;
    let newCoords = "";
    if (rank === 1) {
      newCoords = "coords * uniforms.strides + uniforms.begin";
    } else {
      let outputAxis = 0;
      newCoords = this.outputShape.map((_2, i2) => {
        outputAxis++;
        return this.outputShape.length === 1 ? `coords * uniforms.strides[${i2}] + uniforms.begin[${i2}]` : `coords[${outputAxis - 1}] * uniforms.strides[${i2}] + uniforms.begin[${i2}]`;
      }).join(",");
    }
    const userCode = `
       ${getMainHeaderString()} {
         ${getGlobalIndexString()}
         if (index < uniforms.size) {
           let coords = getOutputCoords(globalId, index);
           setOutputFlat(index, getX(${newCoords}));
         }
       }
     `;
    return userCode;
  }
};
function stridedSlice5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { x: x2 } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  const { nonStrided, $begin, $strides, size: size2, newShape, outShape } = slice_util_exports.sliceInfo(x2.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  const $x = reshape6({ inputs: { x: x2 }, backend: backend22, attrs: { shape: newShape } });
  let result;
  if (nonStrided) {
    const sliced = slice5({ inputs: { x: $x }, backend: backend22, attrs: { begin: $begin, size: size2 } });
    result = reshape6({ inputs: { x: sliced }, backend: backend22, attrs: { shape: outShape } });
    backend22.disposeData(sliced.dataId);
  } else if (outShape.some((axis) => axis === 0)) {
    result = backend22.makeTensorInfo(outShape, x2.dtype, []);
  } else {
    const shouldExecuteOnCPU = backend22.shouldExecuteOnCPU([$x]);
    if (shouldExecuteOnCPU) {
      const xBufferInfo = backend22.tensorMap.get($x.dataId);
      const values = xBufferInfo.values;
      const xBuf = buffer($x.shape, $x.dtype, values);
      const resultValues = stridedSliceImplCPU2(outShape, xBuf, $strides, $begin);
      result = backend22.makeTensorInfo(outShape, $x.dtype, resultValues.values);
    } else {
      const program = new StridedSliceProgram2(outShape);
      const uniformData = [{ type: "int32", data: $begin }, { type: "int32", data: $strides }];
      result = backend22.runWebGPUProgram(program, [$x], $x.dtype, uniformData);
    }
  }
  const resultReshaped = reshape6({ inputs: { x: result }, backend: backend22, attrs: { shape: outShape } });
  backend22.disposeData($x.dataId);
  backend22.disposeData(result.dataId);
  return resultReshaped;
}
var stridedSliceConfig4 = {
  kernelName: StridedSlice,
  backendName: "webgpu",
  kernelFunc: stridedSlice5
};
function stringNGrams4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend22.readSync(data.dataId);
  const $dataSplits = backend22.readSync(dataSplits.dataId);
  const [nGrams, nGramsSplits] = stringNGramsImplCPU2($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend22.makeTensorInfo([nGrams.length], "string", nGrams),
    backend22.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig3 = {
  kernelName: StringNGrams,
  backendName: "webgpu",
  kernelFunc: stringNGrams4
};
var tanh5 = unaryKernelFunc3({ opType: UnaryOpType.TANH });
var tanhConfig4 = {
  kernelName: Tanh,
  backendName: "webgpu",
  kernelFunc: tanh5
};
var TileProgram2 = class {
  constructor(aShape, reps) {
    this.variableNames = ["A"];
    this.workGroupSize = [64, 1, 1];
    const outputShape = new Array(aShape.length);
    for (let i2 = 0; i2 < outputShape.length; i2++) {
      outputShape[i2] = aShape[i2] * reps[i2];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.rank = this.outputShape.length;
    this.size = util_exports.sizeFromShape(this.outputShape);
    this.shaderKey = "tile";
  }
  getUserCode() {
    const sourceCoords = getSourceCoords5(this.rank, "uniforms.");
    const userCode = `
      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        if (index < uniforms.size) {
          let resRC = getOutputCoords(globalId, index);
          setOutputFlat(index, getA(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
};
function getSourceCoords5(rank, uniformPrefix = "") {
  if (rank >= 5) {
    throw Error(`Tile for rank ${rank} is not yet supported`);
  }
  if (rank === 1) {
    return `(resRC % ${uniformPrefix}aShape)`;
  }
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i2 = 0; i2 < rank; i2++) {
    sourceCoords.push(`(${currentCoords[i2]} % ${uniformPrefix}aShape[${i2}])`);
  }
  return sourceCoords.join();
}
function tile6(params) {
  const { inputs, backend: backend22, attrs } = params;
  const { x: x2 } = inputs;
  const { reps } = attrs;
  if (backend22.shouldExecuteOnCPU([x2]) || x2.dtype === "string" || x2.shape.length >= 5) {
    const data = backend22.readSync(x2.dataId);
    const value = x2.dtype === "string" ? data.map((d2) => util_exports.decodeString(d2)) : data;
    const buf = buffer(x2.shape, x2.dtype, value);
    const outBuf = tileImplCPU2(buf, reps);
    return backend22.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  const program = new TileProgram2(x2.shape, reps);
  const output = backend22.runWebGPUProgram(program, [x2], x2.dtype);
  return output;
}
var tileConfig4 = {
  kernelName: Tile,
  backendName: "webgpu",
  kernelFunc: tile6
};
var TransformProgram2 = class {
  constructor(outShape) {
    this.variableNames = ["Image", "Transforms"];
    this.uniforms = "interpolationModeId : i32; fillModeId : i32; fillValue : f32;";
    this.workGroupSize = [64, 1, 1];
    this.outputShape = outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
    this.shaderKey = "transform";
  }
  getUserCode() {
    const userCode = `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${getMainHeaderString()} {
            ${getGlobalIndexString()}
            let coords = getOutputCoords(globalId, index);
            if (coordsInBounds4D(coords, uniforms.outShape)) {
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(coords[0], coords[1], coords[2], coords[3], outputValue);
            }
          }
        `;
    return userCode;
  }
};
function transform5(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { image: image32, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image32.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [
    batch,
    outHeight,
    outWidth,
    numChannels
  ];
  const program = new TransformProgram2(outShape);
  const interpolationModeId = interpolation === "nearest" ? 1 : 2;
  let fillModeId;
  switch (fillMode) {
    case "constant":
      fillModeId = 1;
      break;
    case "reflect":
      fillModeId = 2;
      break;
    case "wrap":
      fillModeId = 3;
      break;
    case "nearest":
      fillModeId = 4;
      break;
    default:
      fillModeId = 1;
      break;
  }
  const uniformData = [
    { type: "int32", data: [interpolationModeId] },
    { type: "int32", data: [fillModeId] },
    { type: "float32", data: [fillValue] }
  ];
  return backend22.runWebGPUProgram(program, [image32, transforms], "float32", uniformData);
}
var transformConfig4 = {
  kernelName: Transform,
  backendName: "webgpu",
  kernelFunc: transform5
};
function unpack4(args) {
  const { inputs, backend: backend22, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const x2 = value;
  const xRank = x2.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(xRank - 1);
  let outIndex = 0;
  for (let i2 = 0; i2 < xRank; i2++) {
    if (i2 !== axis) {
      outShape[outIndex++] = x2.shape[i2];
    }
  }
  const toDispose = [];
  const begin = new Array(xRank).fill(0);
  const size2 = x2.shape.slice();
  size2[axis] = 1;
  const res2 = new Array(num);
  for (let i2 = 0; i2 < res2.length; i2++) {
    begin[axis] = i2;
    const sliced = slice5({ inputs: { x: x2 }, backend: backend22, attrs: { begin, size: size2 } });
    const reshaped = reshape6({ inputs: { x: sliced }, backend: backend22, attrs: { shape: outShape } });
    res2[i2] = reshaped;
    toDispose.push(sliced);
  }
  toDispose.forEach((t2) => backend22.disposeData(t2.dataId));
  return res2;
}
var unpackConfig4 = {
  kernelName: Unpack,
  backendName: "webgpu",
  kernelFunc: unpack4
};
var kernelConfigs4 = [
  _fusedMatMulConfig3,
  absConfig4,
  addConfig4,
  addNConfig4,
  argMaxConfig4,
  argMinConfig3,
  avgPoolConfig4,
  batchMatMulConfig4,
  batchToSpaceNDConfig4,
  castConfig4,
  ceilConfig4,
  clipByValueConfig3,
  complexConfig3,
  concatConfig4,
  conv2DConfig4,
  conv2DBackpropInputConfig4,
  cosConfig4,
  coshConfig4,
  cropAndResizeConfig4,
  depthToSpaceConfig4,
  depthwiseConv2dNativeConfig4,
  einsumConfig3,
  eluConfig4,
  equalConfig4,
  expandDimsConfig4,
  expConfig4,
  expm1Config3,
  fillConfig4,
  flipLeftRightConfig4,
  fromPixelsConfig2,
  floorConfig4,
  floorDivConfig4,
  fusedBatchNormConfig2,
  fusedConv2DConfig4,
  fusedDepthwiseConv2DConfig4,
  gatherNdConfig4,
  gatherV2Config4,
  greaterConfig4,
  greaterEqualConfig4,
  identityConfig4,
  imagConfig3,
  lessConfig4,
  lessEqualConfig4,
  logConfig4,
  logicalAndConfig4,
  logicalNotConfig3,
  maxConfig4,
  maximumConfig4,
  maxPoolConfig4,
  meanConfig4,
  minConfig4,
  minimumConfig4,
  mirrorPadConfig4,
  multiplyConfig4,
  negConfig4,
  nonMaxSuppressionV3Config4,
  nonMaxSuppressionV5Config4,
  notEqualConfig4,
  onesLikeConfig4,
  packConfig4,
  padV2Config4,
  preluConfig4,
  prodConfig4,
  powConfig4,
  rangeConfig4,
  realConfig3,
  realDivConfig4,
  reluConfig4,
  relu6Config4,
  reshapeConfig4,
  resizeBilinearConfig4,
  resizeNearestNeighborConfig3,
  rotateWithOffsetConfig4,
  rsqrtConfig4,
  scatterNdConfig4,
  selectConfig4,
  sigmoidConfig4,
  sinConfig4,
  sinhConfig3,
  sliceConfig4,
  stridedSliceConfig4,
  stringNGramsConfig3,
  softmaxConfig4,
  spaceToBatchNDConfig4,
  splitVConfig4,
  sparseToDenseConfig3,
  sqrtConfig4,
  squareConfig4,
  squaredDifferenceConfig4,
  subConfig4,
  sumConfig4,
  tanhConfig4,
  tileConfig4,
  transformConfig4,
  transposeConfig4,
  unpackConfig4,
  zerosLikeConfig4
];
for (const kernelConfig of kernelConfigs4) {
  registerKernel(kernelConfig);
}
var BufferManager = class {
  constructor(device) {
    this.device = device;
    this.numUsedBuffers = 0;
    this.numFreeBuffers = 0;
    this.freeBuffers = new Map();
    this.usedBuffers = new Map();
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
  acquireBuffer(byteSize, usage) {
    const key = getBufferKey(byteSize, usage);
    if (!this.freeBuffers.has(key)) {
      this.freeBuffers.set(key, []);
    }
    if (!this.usedBuffers.has(key)) {
      this.usedBuffers.set(key, []);
    }
    this.numBytesUsed += byteSize;
    this.numUsedBuffers++;
    if (this.freeBuffers.get(key).length > 0) {
      this.numFreeBuffers--;
      const newBuffer2 = this.freeBuffers.get(key).shift();
      this.usedBuffers.get(key).push(newBuffer2);
      return newBuffer2;
    }
    this.numBytesAllocated += byteSize;
    const newBuffer = this.device.createBuffer({ size: byteSize, usage });
    this.usedBuffers.get(key).push(newBuffer);
    return newBuffer;
  }
  releaseBuffer(buffer2, byteSize, usage) {
    if (this.freeBuffers == null) {
      return;
    }
    const key = getBufferKey(byteSize, usage);
    if (!this.freeBuffers.has(key)) {
      this.freeBuffers.set(key, []);
    }
    this.freeBuffers.get(key).push(buffer2);
    this.numFreeBuffers++;
    this.numUsedBuffers--;
    const bufferList = this.usedBuffers.get(key);
    const bufferIndex = bufferList.indexOf(buffer2);
    if (bufferIndex < 0) {
      throw new Error("Cannot release a buffer that was never provided by this buffer manager");
    }
    bufferList.splice(bufferIndex, 1);
    this.numBytesUsed -= byteSize;
  }
  getNumUsedBuffers() {
    return this.numUsedBuffers;
  }
  getNumFreeBuffers() {
    return this.numFreeBuffers;
  }
  reset() {
    this.freeBuffers = new Map();
    this.usedBuffers = new Map();
    this.numUsedBuffers = 0;
    this.numFreeBuffers = 0;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
  dispose() {
    if (this.freeBuffers == null && this.usedBuffers == null) {
      return;
    }
    this.freeBuffers.forEach((buffers, key) => {
      buffers.forEach((buff) => {
        buff.destroy();
      });
    });
    this.usedBuffers.forEach((buffers, key) => {
      buffers.forEach((buff) => {
        buff.destroy();
      });
    });
    this.freeBuffers = null;
    this.usedBuffers = null;
    this.numUsedBuffers = 0;
    this.numFreeBuffers = 0;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
};
function getBufferKey(byteSize, usage) {
  return `${byteSize}_${usage}`;
}
var FromPixelsProgram2 = class {
  constructor() {
    this.outputShape = [0];
    this.variableNames = [];
    this.workGroupSize = [256, 1, 1];
    this.lastUniformData = [];
    this.inputTexture = null;
    this.layout = null;
    this.lastPixelSize = { width: 0, height: 0 };
    this.disposed = false;
    this.shaderKey = "fromPixels";
    this.useImport = false;
  }
  updateOutputShape(outputShape) {
    if (util_exports.arraysEqual(this.outputShape, outputShape)) {
      return;
    }
    this.outputShape = outputShape;
    this.workPerThread = outputShape[2];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
  }
  makeFromPixelsSource() {
    const textureLoad = this.useImport ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
    const textureType = this.useImport ? "texture_external" : "texture_2d<f32>";
    return `
      [[binding(1), group(0)]] var src: ${textureType};

      ${getMainHeaderString()} {
        ${getGlobalIndexString()}
        let flatIndexBase = index * uniforms.numChannels;
        let coords = getCoordsFromFlatIndex(flatIndexBase);
        let values = ${textureLoad};
        for (var i = 0; i < uniforms.numChannels; i = i + 1) {
          let flatIndex = flatIndexBase + i;
          if (flatIndex < uniforms.size) {
            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
  }
  getUserCode() {
    return this.makeFromPixelsSource();
  }
  setPipeline(pipeline) {
    this.pipeline = pipeline;
  }
  setUniform(device, uniformData) {
    if (!this.uniform) {
      const uniformBuffer = device.createBuffer({
        size: uniformData.length * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.uniform = uniformBuffer;
    }
    if (!uniformData || uniformData.length === this.lastUniformData.length && uniformData.every((v2, i2) => v2 === this.lastUniformData[i2])) {
      return;
    }
    device.queue.writeBuffer(this.uniform, 0, new Uint32Array(uniformData));
    this.lastUniformData = uniformData;
  }
  makeInputTexture(device, pixelWidth, pixelHeight) {
    if (!this.inputTexture || this.lastPixelSize.width !== pixelWidth || this.lastPixelSize.height !== pixelHeight) {
      if (this.inputTexture) {
        this.inputTexture.destroy();
      }
      this.inputTexture = device.createTexture({
        size: [pixelWidth, pixelHeight],
        format: "rgba8unorm",
        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      this.lastPixelSize.width = pixelWidth;
      this.lastPixelSize.height = pixelHeight;
    }
    return this.inputTexture;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (this.uniform) {
      this.uniform.destroy();
    }
    if (this.inputTexture) {
      this.inputTexture.destroy();
    }
    this.disposed = true;
  }
  getLayout(device) {
    if (this.layout === null) {
      this.layout = this.createTextureLayout(device);
    }
    return this.layout;
  }
  createTextureLayout(device) {
    const bindGroupLayoutEntries = [];
    bindGroupLayoutEntries.push({
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: { type: "storage" }
    });
    bindGroupLayoutEntries.push({ binding: 1, visibility: GPUShaderStage.COMPUTE, texture: {} });
    bindGroupLayoutEntries.push({ binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {} });
    const fromPixelBindGroupLayout = device.createBindGroupLayout({ entries: bindGroupLayoutEntries });
    const fromPixelPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [fromPixelBindGroupLayout] });
    return {
      bindGroupLayout: fromPixelBindGroupLayout,
      pipelineLayout: fromPixelPipelineLayout
    };
  }
};
var FromPixelsImportProgram = class extends FromPixelsProgram2 {
  constructor() {
    super(...arguments);
    this.layout = null;
    this.useImport = true;
  }
  getUserCode() {
    return this.makeFromPixelsSource();
  }
  getLayout(device) {
    if (this.layout === null) {
      this.layout = this.createTextureImportLayout(device);
    }
    return this.layout;
  }
  createTextureImportLayout(device) {
    const bindGroupLayoutEntries = [];
    bindGroupLayoutEntries.push({
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: { type: "storage" }
    });
    bindGroupLayoutEntries.push({
      binding: 1,
      visibility: GPUShaderStage.COMPUTE,
      externalTexture: {}
    });
    bindGroupLayoutEntries.push({ binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {} });
    const fromPixelImportBindGroupLayout = device.createBindGroupLayout({ entries: bindGroupLayoutEntries });
    const fromPixelImportPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [fromPixelImportBindGroupLayout] });
    return {
      bindGroupLayout: fromPixelImportBindGroupLayout,
      pipelineLayout: fromPixelImportPipelineLayout
    };
  }
};
var CPU_HANDOFF_SIZE_THRESHOLD2 = env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");
var WebGPUBackend = class extends KernelBackend {
  constructor(device, supportTimeQuery = false) {
    super();
    this.commandQueueOwnedIds = new WeakSet();
    this.tensorDisposalQueue = [];
    this.uniformDisposalQueue = [];
    this.disposed = false;
    this.uploadWaitMs = 0;
    this.downloadWaitMs = 0;
    this.dispatchNumberInEncoder = 0;
    if (!isWebGPUSupported()) {
      throw new Error("WebGPU is not supported on this device");
    }
    this.layoutCache = {};
    this.pipelineCache = {};
    this.device = device;
    this.queue = device.queue;
    this.currentCommandEncoder = null;
    this.currentComputePass = null;
    this.supportTimeQuery = supportTimeQuery;
    this.bufferManager = new BufferManager(this.device);
    this.tensorMap = new DataStorage(this, engine());
    if (this.supportTimeQuery) {
      this.querySet = this.device.createQuerySet({
        type: "timestamp",
        count: 2
      });
    }
    if (env().getBool("WEBGPU_USE_PROFILE_TOOL")) {
      this.dummyCanvas = document.createElement("canvas");
      this.dummyCanvas.width = 1;
      this.dummyCanvas.height = 1;
      this.dummyContext = this.dummyCanvas.getContext("webgpu");
      this.dummyContext.configure({
        device,
        format: "bgra8unorm"
      });
      document.body.appendChild(this.dummyCanvas);
    }
  }
  nextDataId() {
    return WebGPUBackend.nextDataId++;
  }
  floatPrecision() {
    return 32;
  }
  defaultGpuBufferUsage() {
    return GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
  }
  flushDisposalQueue() {
    this.tensorDisposalQueue.forEach((d2) => {
      this.maybeReleaseBuffer(d2);
      this.tensorMap.delete(d2);
    });
    this.uniformDisposalQueue.forEach((d2) => this.bufferManager.releaseBuffer(d2.buffer, d2.byteSize, d2.usage));
    this.tensorDisposalQueue = [];
    this.uniformDisposalQueue = [];
  }
  disposeData(dataId, force = false) {
    if (this.tensorMap.has(dataId)) {
      const data = this.tensorMap.get(dataId);
      data.refCount--;
      if (!force && data.refCount > 0) {
        return false;
      }
      if (this.commandQueueOwnedIds.has(dataId)) {
        this.tensorDisposalQueue.push(dataId);
        return false;
      } else {
        this.maybeReleaseBuffer(dataId);
      }
      const { complexTensorInfos } = this.tensorMap.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, true);
        this.disposeData(complexTensorInfos.imag.dataId, true);
      }
      this.tensorMap.delete(dataId);
    }
    return true;
  }
  memory() {
    return {
      numBytesInGPU: this.bufferManager.numBytesUsed,
      numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,
      unreliable: false
    };
  }
  getBufferManager() {
    return this.bufferManager;
  }
  acquireBuffer(byteSize, usage = this.defaultGpuBufferUsage()) {
    return this.bufferManager.acquireBuffer(byteSize, usage);
  }
  maybeReleaseBuffer(dataId) {
    const info = this.tensorMap.get(dataId);
    if (info != null && info.bufferInfo.buffer != null) {
      this.bufferManager.releaseBuffer(info.bufferInfo.buffer, info.bufferInfo.byteSize, info.bufferInfo.usage);
      info.bufferInfo.buffer = null;
    }
  }
  refCount(dataId) {
    if (this.tensorMap.has(dataId)) {
      const tensorData = this.tensorMap.get(dataId);
      return tensorData.refCount;
    }
    return 0;
  }
  incRef(dataId) {
    const tensorData = this.tensorMap.get(dataId);
    tensorData.refCount++;
  }
  decRef(dataId) {
    if (this.tensorMap.has(dataId)) {
      const tensorData = this.tensorMap.get(dataId);
      tensorData.refCount--;
    }
  }
  write(values, shape, dtype) {
    if (dtype === "complex64" && values != null) {
      throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
    }
    const dataId = { id: this.nextDataId() };
    const byteSize = util_exports.sizeFromShape(shape) * GPUBytesPerElement(dtype);
    if (dtype === "bool" && values instanceof Uint8Array) {
      values = Int32Array.from(values);
    }
    this.tensorMap.set(dataId, {
      dtype,
      values,
      bufferInfo: { byteSize, usage: this.defaultGpuBufferUsage() },
      refCount: 1
    });
    return dataId;
  }
  move(dataId, values, shape, dtype, refCount) {
    if (dtype === "complex64") {
      throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
    }
    const byteSize = util_exports.sizeFromShape(shape) * GPUBytesPerElement(dtype);
    this.tensorMap.set(dataId, {
      dtype,
      values,
      bufferInfo: { byteSize, usage: this.defaultGpuBufferUsage() },
      refCount
    });
  }
  submitQueue() {
    this.ensureComputePassEnded();
    this.queue.submit([this.currentCommandEncoder.finish()]);
    this.currentCommandEncoder = null;
    this.dispatchNumberInEncoder = 0;
    this.commandQueueOwnedIds = new WeakSet();
    this.flushDisposalQueue();
  }
  getBuffer(dataId) {
    this.uploadToGPU(dataId);
    return this.tensorMap.get(dataId).bufferInfo.buffer;
  }
  getFromPixelsProgram(type) {
    switch (type) {
      case "copyExternal": {
        if (!this.fromPixelProgram) {
          this.fromPixelProgram = new FromPixelsProgram2();
        }
        return this.fromPixelProgram;
      }
      case "import": {
        if (!this.fromPixelImportProgram) {
          this.fromPixelImportProgram = new FromPixelsImportProgram();
        }
        return this.fromPixelImportProgram;
      }
      default:
        util_exports.assert(false, () => `Unsupported fromPixels shape`);
        return void 0;
    }
  }
  ensureCommandEncoderReady() {
    if (!this.currentCommandEncoder) {
      this.currentCommandEncoder = this.device.createCommandEncoder();
    }
  }
  ensureComputePassEnded() {
    if (this.currentComputePass) {
      this.currentComputePass.endPass();
      this.currentComputePass = null;
    }
  }
  getComputePass() {
    if (!this.currentComputePass) {
      this.currentComputePass = this.currentCommandEncoder.beginComputePass();
    }
    return this.currentComputePass;
  }
  async getBufferData(info) {
    if (info.values != null) {
      return info.values;
    }
    const staging = this.acquireBuffer(info.bufferInfo.byteSize, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
    this.ensureCommandEncoderReady();
    this.ensureComputePassEnded();
    this.currentCommandEncoder.copyBufferToBuffer(info.bufferInfo.buffer, 0, staging, 0, info.bufferInfo.byteSize);
    this.submitQueue();
    await staging.mapAsync(GPUMapMode.READ);
    const values = staging.getMappedRange().slice(0);
    staging.unmap();
    if (staging != null) {
      this.bufferManager.releaseBuffer(staging, info.bufferInfo.byteSize, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
    }
    if (env().getBool("WEBGPU_USE_PROFILE_TOOL")) {
      util_exports.assert(this.dummyContext !== void 0, () => `Fail to get context for profiling tool`);
      this.dummyContext.getCurrentTexture();
    }
    return values;
  }
  convertAndCacheOnCPU(dataId, data) {
    const info = this.tensorMap.get(dataId);
    this.maybeReleaseBuffer(dataId);
    info.values = data;
    return info.values;
  }
  readSync(dataId) {
    const texData = this.tensorMap.get(dataId);
    const { values } = texData;
    if (values == null) {
      throw new Error("WebGPU readSync is only available for CPU-resident tensors.");
    }
    return values;
  }
  async read(dataId) {
    if (!this.tensorMap.has(dataId)) {
      throw new Error(`Tensor ${dataId} was not registered!`);
    }
    const info = this.tensorMap.get(dataId);
    const { values } = info;
    if (values != null) {
      return this.convertAndCacheOnCPU(dataId, values);
    }
    let vals;
    if (info.dtype === "complex64") {
      const ps = await Promise.all([
        this.read(info.complexTensorInfos.real.dataId),
        this.read(info.complexTensorInfos.imag.dataId)
      ]);
      const realValues = ps[0];
      const imagValues = ps[1];
      vals = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
    } else {
      const data = await this.getBufferData(info);
      vals = ArrayBufferToTypedArray(data, info.dtype);
    }
    this.convertAndCacheOnCPU(dataId, vals);
    return vals;
  }
  bufferSync(t2) {
    const data = this.readSync(t2.dataId);
    let decodedData = data;
    if (t2.dtype === "string") {
      try {
        decodedData = data.map((d2) => util_exports.decodeString(d2));
      } catch (_a) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    }
    return buffer(t2.shape, t2.dtype, decodedData);
  }
  async time(f2) {
    const oldActiveTimers = this.activeTimers;
    const newActiveTimers = [];
    let outerMostTime = false;
    if (this.programTimersStack == null) {
      this.programTimersStack = newActiveTimers;
      outerMostTime = true;
    } else {
      this.activeTimers.push(newActiveTimers);
    }
    this.activeTimers = newActiveTimers;
    f2();
    const flattenedActiveTimerQueries = util_exports.flatten(this.activeTimers.map((d2) => d2.query)).filter((d2) => d2 != null);
    const flattenedActiveTimerNames = util_exports.flatten(this.activeTimers.map((d2) => d2.name)).filter((d2) => d2 != null);
    this.activeTimers = oldActiveTimers;
    if (outerMostTime) {
      this.programTimersStack = null;
    }
    const res2 = {
      uploadWaitMs: this.uploadWaitMs,
      downloadWaitMs: this.downloadWaitMs,
      kernelMs: null,
      wallMs: null
    };
    const kernelMs = await Promise.all(flattenedActiveTimerQueries);
    res2["kernelMs"] = util_exports.sum(kernelMs);
    res2["getExtraProfileInfo"] = () => kernelMs.map((d2, i2) => ({ name: flattenedActiveTimerNames[i2], ms: d2 })).map((d2) => `${d2.name}: ${d2.ms}`).join(", ");
    this.uploadWaitMs = 0;
    this.downloadWaitMs = 0;
    return res2;
  }
  getAndSavePipeline(key, getPipeline) {
    if (!(key in this.pipelineCache)) {
      this.pipelineCache[key] = getPipeline();
    }
    return this.pipelineCache[key];
  }
  makeTensorInfo(shape, dtype, values) {
    let dataId;
    if (dtype === "string" && values != null && values.length > 0 && util_exports.isString(values[0])) {
      const encodedValues = values.map((d2) => util_exports.encodeString(d2));
      dataId = this.write(encodedValues, shape, dtype);
    } else {
      dataId = this.write(values, shape, dtype);
    }
    return { dataId, shape, dtype };
  }
  tensorToBinding(tensor2) {
    if (!tensor2) {
      return null;
    }
    const tensorData = this.tensorMap.get(tensor2.dataId);
    return {
      offset: 0,
      size: tensorData.bufferInfo.byteSize,
      buffer: tensorData.bufferInfo.buffer
    };
  }
  async getQueryTime(query) {
    if (this.supportTimeQuery) {
      return this.getTimeFromQuerySet(query);
    } else {
      return 0;
    }
  }
  uploadToGPU(dataId) {
    const info = this.tensorMap.get(dataId);
    if (info.bufferInfo.buffer != null) {
      return;
    }
    info.bufferInfo.buffer = this.acquireBuffer(info.bufferInfo.byteSize);
    if (info.values) {
      this.queue.writeBuffer(info.bufferInfo.buffer, 0, info.values);
    }
  }
  makeUniformsDataView(data) {
    const dimensionsBuffer = this.acquireBuffer(data.byteLength, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
    this.queue.writeBuffer(dimensionsBuffer, 0, data);
    return { offset: 0, size: data.byteLength, buffer: dimensionsBuffer };
  }
  arrayToDataView(arrays, length) {
    const BYTES_PER_ELEMENT = 4;
    const uniformDataView = new DataView(new ArrayBuffer(length * BYTES_PER_ELEMENT));
    let dataViewIndex = 0;
    arrays.forEach((array2) => {
      const arrayData = array2.data;
      if (array2.type !== "int32" && array2.type !== "float32" && array2.type !== "uint32") {
        throw new Error(`${array2.type} not supported!`);
      }
      if (array2.type === "int32") {
        arrayData.forEach((d2) => {
          uniformDataView.setInt32(dataViewIndex * BYTES_PER_ELEMENT, d2, true);
          dataViewIndex++;
        });
      } else if (array2.type === "uint32") {
        arrayData.forEach((d2) => {
          uniformDataView.setUint32(dataViewIndex * BYTES_PER_ELEMENT, d2, true);
          dataViewIndex++;
        });
      } else {
        arrayData.forEach((d2) => {
          uniformDataView.setFloat32(dataViewIndex * BYTES_PER_ELEMENT, d2, true);
          dataViewIndex++;
        });
      }
    });
    return uniformDataView;
  }
  computePadding(uniformsWithType) {
    let currentOffset = 0;
    let padding2 = 0;
    let dataViewIndex = 0;
    const dimUniformsData = [];
    uniformsWithType.forEach((d2, i2) => {
      if (d2.data.length === 0) {
        d2.data = [1];
      }
      let baseAlignment;
      switch (d2.data.length) {
        case 0:
          baseAlignment = 1;
          break;
        case 1:
          baseAlignment = 1;
          break;
        case 2:
          baseAlignment = 2;
          break;
        case 3:
          baseAlignment = 4;
          break;
        case 4:
          baseAlignment = 4;
          break;
        default:
          util_exports.assert(false, () => `Unsupported ${d2.data.length}D shape`);
      }
      padding2 = Math.ceil(currentOffset / baseAlignment) * baseAlignment - currentOffset;
      for (let p22 = 0; p22 < padding2; ++p22) {
        dimUniformsData.push({ type: d2.type, data: [0] });
        dataViewIndex++;
      }
      dimUniformsData.push({ type: d2.type, data: d2.data });
      dataViewIndex = dataViewIndex + d2.data.length;
      currentOffset += d2.data.length + padding2;
    });
    return this.arrayToDataView(dimUniformsData, dataViewIndex);
  }
  createLayout(inputEntrySize) {
    const bindGroupLayoutEntries = [];
    bindGroupLayoutEntries.push({
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: { type: "storage" }
    });
    for (let i2 = 0; i2 < inputEntrySize; i2++) {
      bindGroupLayoutEntries.push({
        binding: i2 + 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: "read-only-storage" }
      });
    }
    bindGroupLayoutEntries.push({
      binding: inputEntrySize + 1,
      visibility: GPUShaderStage.COMPUTE,
      buffer: { type: "uniform" }
    });
    const bindGroupLayout = this.device.createBindGroupLayout({ entries: bindGroupLayoutEntries });
    const pipelineLayout = this.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
    return { bindGroupLayout, pipelineLayout };
  }
  getCachedOrCreateLayout(inputEntrySize) {
    if (!(inputEntrySize in this.layoutCache)) {
      this.layoutCache[inputEntrySize] = this.createLayout(inputEntrySize);
    }
    return this.layoutCache[inputEntrySize];
  }
  runWebGPUProgram(program, inputs, outputDtype, programUniforms) {
    const output = this.makeTensorInfo(program.outputShape, outputDtype);
    const outData = this.tensorMap.get(output.dataId);
    if (util_exports.sizeFromShape(output.shape) === 0) {
      outData.values = util_exports.getTypedArrayFromDType(output.dtype, 0);
      return output;
    }
    let uniformsWithType = [{ type: "float32", data: [NaN] }];
    const bufferShapes = inputs.concat(output).map((d2) => d2.shape);
    const uniformsType = "int32";
    bufferShapes.map((d2) => {
      uniformsWithType.push({ type: uniformsType, data: d2 });
    });
    const strides = util_exports.computeStrides(output.shape);
    uniformsWithType.push({ type: uniformsType, data: strides });
    if (program.size != null) {
      uniformsWithType.push({ type: uniformsType, data: [program.size] });
    }
    uniformsWithType.push({ type: "uint32", data: program.dispatch });
    if (programUniforms) {
      uniformsWithType = [...uniformsWithType, ...programUniforms];
    }
    let uniforms = null;
    const uniformsDataView = this.computePadding(uniformsWithType);
    const uniformsByteLength = uniformsDataView.byteLength;
    uniforms = this.makeUniformsDataView(uniformsDataView);
    const inputsData = inputs.map((input2, i2) => {
      if (input2.dtype === "complex64") {
        throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
      }
      this.uploadToGPU(input2.dataId);
      return {
        dtype: this.tensorMap.get(input2.dataId).dtype,
        shape: input2.shape,
        name: program.variableNames[i2]
      };
    });
    this.uploadToGPU(output.dataId);
    const bufferTypes = inputsData.map((d2) => d2.dtype).concat(output.dtype);
    const broadcastDims = inputsData.map((d2) => backend_util_exports.getBroadcastDims(d2.shape, output.shape));
    const inputShapesEqualsOutShape = inputsData.map((d2) => util_exports.arraysEqual(d2.shape, output.shape)).join("_");
    const broadcastDimsKey = broadcastDims.map((d2) => d2.join("_")).join(";");
    const key = makeShaderKey2(program, bufferShapes, bufferTypes, broadcastDimsKey, inputShapesEqualsOutShape);
    const { bindGroupLayout, pipelineLayout } = this.getCachedOrCreateLayout(program.variableNames.length);
    const pipeline = this.getAndSavePipeline(key, () => {
      return compileProgram2(this.device, program, pipelineLayout, inputsData, output);
    });
    const shouldTimeProgram = this.activeTimers != null;
    const bg = makeBindGroup(this.device, bindGroupLayout, inputs.map((t2) => this.tensorToBinding(t2)), this.tensorToBinding(output), uniforms);
    this.ensureCommandEncoderReady();
    const pass = this.getComputePass();
    if (shouldTimeProgram) {
      if (this.supportTimeQuery) {
        pass.writeTimestamp(this.querySet, 0);
      }
    }
    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bg);
    pass.dispatch(program.dispatch[0], program.dispatch[1], program.dispatch[2]);
    if (shouldTimeProgram) {
      if (this.supportTimeQuery) {
        pass.writeTimestamp(this.querySet, 1);
      }
    }
    this.dispatchNumberInEncoder++;
    inputs.forEach((input2) => {
      this.commandQueueOwnedIds.add(input2.dataId);
    });
    this.commandQueueOwnedIds.add(output.dataId);
    if (uniforms) {
      const uniformInfo = {
        byteSize: uniformsByteLength,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        buffer: uniforms.buffer
      };
      this.uniformDisposalQueue.push(uniformInfo);
    }
    if (env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchNumberInEncoder) {
      this.submitQueue();
    }
    if (shouldTimeProgram) {
      this.activeTimers.push({
        name: program.constructor.name,
        query: this.getQueryTime(this.querySet)
      });
    }
    return output;
  }
  runFromPixelsProgram(program, output, layout, externalResource, outputId) {
    const bindGroup = this.device.createBindGroup({
      layout: layout.bindGroupLayout,
      entries: [
        {
          binding: 0,
          resource: {
            buffer: output
          }
        },
        {
          binding: 1,
          resource: externalResource
        },
        {
          binding: 2,
          resource: {
            buffer: program.uniform
          }
        }
      ]
    });
    this.ensureCommandEncoderReady();
    const passEncoder = this.getComputePass();
    const shouldTimeProgram = this.activeTimers != null;
    if (shouldTimeProgram) {
      if (this.supportTimeQuery) {
        passEncoder.writeTimestamp(this.querySet, 0);
      }
    }
    passEncoder.setPipeline(program.pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.dispatch(program.dispatch[0], program.dispatch[1], program.dispatch[2]);
    if (shouldTimeProgram) {
      if (this.supportTimeQuery) {
        passEncoder.writeTimestamp(this.querySet, 1);
      }
    }
    this.commandQueueOwnedIds.add(outputId);
    this.submitQueue();
    if (shouldTimeProgram) {
      this.activeTimers.push({
        name: program.constructor.name,
        query: this.getQueryTime(this.querySet)
      });
    }
  }
  async getTimeFromQuerySet(querySet) {
    const queryBuffer = this.acquireBuffer(16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE);
    const dst = this.acquireBuffer(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    this.ensureCommandEncoderReady();
    this.ensureComputePassEnded();
    this.currentCommandEncoder.resolveQuerySet(querySet, 0, 2, queryBuffer, 0);
    this.currentCommandEncoder.copyBufferToBuffer(queryBuffer, 0, dst, 0, 16);
    this.submitQueue();
    await dst.mapAsync(GPUMapMode.READ);
    const arrayBuf = new BigUint64Array(dst.getMappedRange());
    const timeElapsedNanos = Number(arrayBuf[1] - arrayBuf[0]);
    dst.unmap();
    this.bufferManager.releaseBuffer(dst, 16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    this.bufferManager.releaseBuffer(queryBuffer, 16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE);
    return timeElapsedNanos / 1e6;
  }
  shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD2) {
    return env().getBool("WEBGPU_CPU_FORWARD") && inputs.every((input2) => this.tensorMap.get(input2.dataId).bufferInfo.buffer == null && util_exports.sizeFromShape(input2.shape) < sizeThreshold);
  }
  numDataIds() {
    return this.tensorMap.numDataIds() - this.tensorDisposalQueue.length;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    this.bufferManager.dispose();
    if (this.fromPixelProgram) {
      this.fromPixelProgram.dispose();
    }
    if (this.fromPixelImportProgram) {
      this.fromPixelImportProgram.dispose();
    }
    this.disposed = true;
  }
};
WebGPUBackend.nextDataId = 0;
var webgpu_exports = {};
__export2(webgpu_exports, {
  WebGPUBackend: () => WebGPUBackend,
  webgpu_util: () => webgpu_util_exports
});
if (device_util_exports.isBrowser() && isWebGPUSupported()) {
  registerBackend("webgpu", async () => {
    env().set("CHECK_COMPUTATION_FOR_ERRORS", false);
    const gpuDescriptor = {
      powerPreference: env().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance"
    };
    const adapter = await navigator.gpu.requestAdapter(gpuDescriptor);
    let deviceDescriptor = {};
    const supportTimeQuery = adapter.features.has("timestamp-query");
    if (supportTimeQuery) {
      deviceDescriptor = { requiredFeatures: ["timestamp-query"] };
    } else {
      console.warn(`This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.`);
    }
    const device = await adapter.requestDevice(deviceDescriptor);
    return new WebGPUBackend(device, supportTimeQuery);
  }, 3);
}
var version9 = "3.9.0";
var version22 = "3.9.0";
var version32 = "3.9.0";
var version42 = "3.9.0";
var version52 = "3.9.0";
var version62 = "3.9.0";
var version72 = "3.9.0";
var version82 = "3.9.0";
var version92 = {
  tfjs: version9,
  "tfjs-core": version22,
  "tfjs-data": version32,
  "tfjs-layers": version42,
  "tfjs-converter": version52,
  "tfjs-backend-cpu": version62,
  "tfjs-backend-webgl": version72,
  "tfjs-backend-wasm": version82
};
var version6 = "2.3.3";
var vertexIdentity = `
  precision highp float;
  attribute vec2 pos;
  attribute vec2 uv;
  varying vec2 vUv;
  uniform float flipY;
  void main(void) {
    vUv = uv;
    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);
  }
`;
var colorMatrixWithAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];
    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];
  }
`;
var colorMatrixWithoutAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];
    gl_FragColor.a = c.a;
  }
`;
var pixelate = `
  precision highp float;
  varying vec2 vUv;
  uniform vec2 size;
  uniform sampler2D texture;
  vec2 pixelate(vec2 coord, vec2 size) {
    return floor( coord / size ) * size;
  }
  void main(void) {
    gl_FragColor = vec4(0.0);
    vec2 coord = pixelate(vUv, size);
    gl_FragColor += texture2D(texture, coord);
  }
`;
var blur = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  void main(void) {
    gl_FragColor = vec4(0.0);
    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;
    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;
    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;
  }
`;
var convolution = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  uniform float m[9];
  void main(void) {
    vec4 c11 = texture2D(texture, vUv - px); // top left
    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center
    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right
    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left
    vec4 c22 = texture2D(texture, vUv); // mid center
    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right
    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left
    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center
    vec4 c33 = texture2D(texture, vUv + px ); // bottom right
    gl_FragColor = 
    c11 * m[0] + c12 * m[1] + c22 * m[2] +
    c21 * m[3] + c22 * m[4] + c23 * m[5] +
    c31 * m[6] + c32 * m[7] + c33 * m[8];
    gl_FragColor.a = c22.a;
  }
`;
var collect = (source, prefix, collection) => {
  const r2 = new RegExp("\\b" + prefix + " \\w+ (\\w+)", "ig");
  source.replace(r2, (match4, name) => {
    collection[name] = 0;
    return match4;
  });
};
var GLProgram = class {
  constructor(gl, vertexSource, fragmentSource) {
    __publicField(this, "uniform", {});
    __publicField(this, "attribute", {});
    __publicField(this, "gl");
    __publicField(this, "id");
    __publicField(this, "compile", (source, type) => {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))
        throw new Error(`filter: gl compile failed: ${this.gl.getShaderInfoLog(shader)}`);
      return shader;
    });
    this.gl = gl;
    const vertexShader = this.compile(vertexSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compile(fragmentSource, this.gl.FRAGMENT_SHADER);
    this.id = this.gl.createProgram();
    this.gl.attachShader(this.id, vertexShader);
    this.gl.attachShader(this.id, fragmentShader);
    this.gl.linkProgram(this.id);
    if (!this.gl.getProgramParameter(this.id, this.gl.LINK_STATUS))
      throw new Error(`filter: gl link failed: ${this.gl.getProgramInfoLog(this.id)}`);
    this.gl.useProgram(this.id);
    collect(vertexSource, "attribute", this.attribute);
    for (const a6 in this.attribute)
      this.attribute[a6] = this.gl.getAttribLocation(this.id, a6);
    collect(vertexSource, "uniform", this.uniform);
    collect(fragmentSource, "uniform", this.uniform);
    for (const u2 in this.uniform)
      this.uniform[u2] = this.gl.getUniformLocation(this.id, u2);
  }
};
function GLImageFilter(params = {}) {
  let drawCount = 0;
  let sourceTexture = null;
  let lastInChain = false;
  let currentFramebufferIndex = -1;
  let tempFramebuffers = [null, null];
  let filterChain = [];
  let vertexBuffer = null;
  let currentProgram = null;
  const canvas3 = params["canvas"] || typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(100, 100) : document.createElement("canvas");
  const shaderProgramCache = {};
  const DRAW = { INTERMEDIATE: 1 };
  const gl = canvas3.getContext("webgl");
  if (!gl)
    throw new Error("filter: cannot get webgl context");
  function resize(width, height) {
    if (width === canvas3.width && height === canvas3.height)
      return;
    canvas3.width = width;
    canvas3.height = height;
    if (!vertexBuffer) {
      const vertices = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0]);
      vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    }
    gl.viewport(0, 0, canvas3.width, canvas3.height);
    tempFramebuffers = [null, null];
  }
  function createFramebufferTexture(width, height) {
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    const renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return { fbo, texture };
  }
  function getTempFramebuffer(index) {
    tempFramebuffers[index] = tempFramebuffers[index] || createFramebufferTexture(canvas3.width, canvas3.height);
    return tempFramebuffers[index];
  }
  function draw2(flags = 0) {
    var _a, _b;
    if (!currentProgram)
      return;
    let source = null;
    let target = null;
    let flipY = false;
    if (drawCount === 0)
      source = sourceTexture;
    else
      source = ((_a = getTempFramebuffer(currentFramebufferIndex)) == null ? void 0 : _a.texture) || null;
    drawCount++;
    if (lastInChain && !(flags & DRAW.INTERMEDIATE)) {
      target = null;
      flipY = drawCount % 2 === 0;
    } else {
      currentFramebufferIndex = (currentFramebufferIndex + 1) % 2;
      target = ((_b = getTempFramebuffer(currentFramebufferIndex)) == null ? void 0 : _b.fbo) || null;
    }
    gl.bindTexture(gl.TEXTURE_2D, source);
    gl.bindFramebuffer(gl.FRAMEBUFFER, target);
    gl.uniform1f(currentProgram.uniform["flipY"], flipY ? -1 : 1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  function compileShader(fragmentSource) {
    if (shaderProgramCache[fragmentSource]) {
      currentProgram = shaderProgramCache[fragmentSource];
      gl.useProgram((currentProgram == null ? void 0 : currentProgram.id) || null);
      return currentProgram;
    }
    currentProgram = new GLProgram(gl, vertexIdentity, fragmentSource);
    const floatSize = Float32Array.BYTES_PER_ELEMENT;
    const vertSize = 4 * floatSize;
    gl.enableVertexAttribArray(currentProgram.attribute["pos"]);
    gl.vertexAttribPointer(currentProgram.attribute["pos"], 2, gl.FLOAT, false, vertSize, 0 * floatSize);
    gl.enableVertexAttribArray(currentProgram.attribute["uv"]);
    gl.vertexAttribPointer(currentProgram.attribute["uv"], 2, gl.FLOAT, false, vertSize, 2 * floatSize);
    shaderProgramCache[fragmentSource] = currentProgram;
    return currentProgram;
  }
  const filter = {
    colorMatrix: (matrix) => {
      const m2 = new Float32Array(matrix);
      m2[4] /= 255;
      m2[9] /= 255;
      m2[14] /= 255;
      m2[19] /= 255;
      const shader = m2[18] === 1 && m2[3] === 0 && m2[8] === 0 && m2[13] === 0 && m2[15] === 0 && m2[16] === 0 && m2[17] === 0 && m2[19] === 0 ? colorMatrixWithoutAlpha : colorMatrixWithAlpha;
      const program = compileShader(shader);
      gl.uniform1fv(program == null ? void 0 : program.uniform["m"], m2);
      draw2();
    },
    brightness: (brightness) => {
      const b2 = (brightness || 0) + 1;
      filter.colorMatrix([
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    saturation: (amount) => {
      const x2 = (amount || 0) * 2 / 3 + 1;
      const y2 = (x2 - 1) * -0.5;
      filter.colorMatrix([
        x2,
        y2,
        y2,
        0,
        0,
        y2,
        x2,
        y2,
        0,
        0,
        y2,
        y2,
        x2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    desaturate: () => {
      filter.saturation(-1);
    },
    contrast: (amount) => {
      const v2 = (amount || 0) + 1;
      const o2 = -128 * (v2 - 1);
      filter.colorMatrix([
        v2,
        0,
        0,
        0,
        o2,
        0,
        v2,
        0,
        0,
        o2,
        0,
        0,
        v2,
        0,
        o2,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    negative: () => {
      filter.contrast(-2);
    },
    hue: (rotation) => {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cos5 = Math.cos(rotation);
      const sin5 = Math.sin(rotation);
      const lumR = 0.213;
      const lumG = 0.715;
      const lumB = 0.072;
      filter.colorMatrix([
        lumR + cos5 * (1 - lumR) + sin5 * -lumR,
        lumG + cos5 * -lumG + sin5 * -lumG,
        lumB + cos5 * -lumB + sin5 * (1 - lumB),
        0,
        0,
        lumR + cos5 * -lumR + sin5 * 0.143,
        lumG + cos5 * (1 - lumG) + sin5 * 0.14,
        lumB + cos5 * -lumB + sin5 * -0.283,
        0,
        0,
        lumR + cos5 * -lumR + sin5 * -(1 - lumR),
        lumG + cos5 * -lumG + sin5 * lumG,
        lumB + cos5 * (1 - lumB) + sin5 * lumB,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    desaturateLuminance: () => {
      filter.colorMatrix([
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    sepia: () => {
      filter.colorMatrix([
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    brownie: () => {
      filter.colorMatrix([
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    vintagePinhole: () => {
      filter.colorMatrix([
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    kodachrome: () => {
      filter.colorMatrix([
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    technicolor: () => {
      filter.colorMatrix([
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    polaroid: () => {
      filter.colorMatrix([
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    shiftToBGR: () => {
      filter.colorMatrix([
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    convolution: (matrix) => {
      const m2 = new Float32Array(matrix);
      const pixelSizeX = 1 / canvas3.width;
      const pixelSizeY = 1 / canvas3.height;
      const program = compileShader(convolution);
      gl.uniform1fv(program == null ? void 0 : program.uniform["m"], m2);
      gl.uniform2f(program == null ? void 0 : program.uniform["px"], pixelSizeX, pixelSizeY);
      draw2();
    },
    detectEdges: () => {
      filter.convolution.call(this, [
        0,
        1,
        0,
        1,
        -4,
        1,
        0,
        1,
        0
      ]);
    },
    sobelX: () => {
      filter.convolution.call(this, [
        -1,
        0,
        1,
        -2,
        0,
        2,
        -1,
        0,
        1
      ]);
    },
    sobelY: () => {
      filter.convolution.call(this, [
        -1,
        -2,
        -1,
        0,
        0,
        0,
        1,
        2,
        1
      ]);
    },
    sharpen: (amount) => {
      const a6 = amount || 1;
      filter.convolution.call(this, [
        0,
        -1 * a6,
        0,
        -1 * a6,
        1 + 4 * a6,
        -1 * a6,
        0,
        -1 * a6,
        0
      ]);
    },
    emboss: (size2) => {
      const s2 = size2 || 1;
      filter.convolution.call(this, [
        -2 * s2,
        -1 * s2,
        0,
        -1 * s2,
        1,
        1 * s2,
        0,
        1 * s2,
        2 * s2
      ]);
    },
    blur: (size2) => {
      const blurSizeX = size2 / 7 / canvas3.width;
      const blurSizeY = size2 / 7 / canvas3.height;
      const program = compileShader(blur);
      gl.uniform2f(program == null ? void 0 : program.uniform["px"], 0, blurSizeY);
      draw2(DRAW.INTERMEDIATE);
      gl.uniform2f(program == null ? void 0 : program.uniform["px"], blurSizeX, 0);
      draw2();
    },
    pixelate: (size2) => {
      const blurSizeX = size2 / canvas3.width;
      const blurSizeY = size2 / canvas3.height;
      const program = compileShader(pixelate);
      gl.uniform2f(program == null ? void 0 : program.uniform["size"], blurSizeX, blurSizeY);
      draw2();
    }
  };
  this.add = function(name) {
    const args = Array.prototype.slice.call(arguments, 1);
    const func2 = filter[name];
    filterChain.push({ func: func2, args });
  };
  this.reset = function() {
    filterChain = [];
  };
  this.get = function() {
    return filterChain;
  };
  this.apply = function(image7) {
    resize(image7.width, image7.height);
    drawCount = 0;
    if (!sourceTexture)
      sourceTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image7);
    for (let i2 = 0; i2 < filterChain.length; i2++) {
      lastInChain = i2 === filterChain.length - 1;
      const f2 = filterChain[i2];
      f2.func.apply(this, f2.args || []);
    }
    return canvas3;
  };
  this.draw = function(image7) {
    this.add("brightness", 0);
    return this.apply(image7);
  };
}
var env2 = {
  browser: void 0,
  node: void 0,
  worker: void 0,
  platform: void 0,
  agent: void 0,
  initial: true,
  backends: [],
  offscreen: void 0,
  filter: void 0,
  tfjs: {
    version: void 0
  },
  wasm: {
    supported: void 0,
    backend: void 0,
    simd: void 0,
    multithread: void 0
  },
  webgl: {
    supported: void 0,
    backend: void 0,
    version: void 0,
    renderer: void 0
  },
  webgpu: {
    supported: void 0,
    backend: void 0,
    adapter: void 0
  },
  kernels: [],
  Canvas: void 0,
  Image: void 0,
  ImageData: void 0
};
async function backendInfo() {
  var _a;
  env2.backends = Object.keys(engine().registryFactory);
  env2.wasm.supported = typeof WebAssembly !== "undefined";
  env2.wasm.backend = env2.backends.includes("wasm");
  if (env2.wasm.supported && env2.wasm.backend && getBackend() === "wasm") {
    env2.wasm.simd = await env().getAsync("WASM_HAS_SIMD_SUPPORT");
    env2.wasm.multithread = await env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
  }
  const c2 = canvas(100, 100);
  const ctx = c2 ? c2.getContext("webgl2") : void 0;
  env2.webgl.supported = typeof ctx !== "undefined";
  env2.webgl.backend = env2.backends.includes("webgl");
  if (env2.webgl.supported && env2.webgl.backend && (getBackend() === "webgl" || getBackend() === "humangl")) {
    const gl = backend().gpgpu !== "undefined" ? await backend().getGPGPUContext().gl : null;
    if (gl) {
      env2.webgl.version = gl.getParameter(gl.VERSION);
      env2.webgl.renderer = gl.getParameter(gl.RENDERER);
    }
  }
  env2.webgpu.supported = env2.browser && typeof navigator["gpu"] !== "undefined";
  env2.webgpu.backend = env2.backends.includes("webgpu");
  if (env2.webgpu.supported)
    env2.webgpu.adapter = (_a = await navigator["gpu"].requestAdapter()) == null ? void 0 : _a.name;
  env2.kernels = getKernelsForBackend(getBackend()).map((kernel) => kernel.kernelName.toLowerCase());
}
async function get3() {
  env2.browser = typeof navigator !== "undefined";
  env2.node = typeof process !== "undefined";
  env2.tfjs.version = version;
  env2.offscreen = typeof env2.offscreen === "undefined" ? typeof OffscreenCanvas !== "undefined" : env2.offscreen;
  if (typeof navigator !== "undefined") {
    const raw = navigator.userAgent.match(/\(([^()]+)\)/g);
    if (raw && raw[0]) {
      const platformMatch = raw[0].match(/\(([^()]+)\)/g);
      env2.platform = platformMatch && platformMatch[0] ? platformMatch[0].replace(/\(|\)/g, "") : "";
      env2.agent = navigator.userAgent.replace(raw[0], "");
      if (env2.platform[1])
        env2.agent = env2.agent.replace(raw[1], "");
      env2.agent = env2.agent.replace(/  /g, " ");
    }
  } else if (typeof process !== "undefined") {
    env2.platform = `${process.platform} ${process.arch}`;
    env2.agent = `NodeJS ${process.version}`;
  }
  env2.worker = env2.browser && env2.offscreen ? typeof WorkerGlobalScope !== "undefined" : void 0;
  await backendInfo();
}
async function set(obj) {
  env2 = mergeDeep(env2, obj);
}
var maxSize = 2048;
var inCanvas = null;
var outCanvas = null;
var tmpCanvas = null;
var fx;
function canvas(width, height) {
  let c2;
  if (env2.browser) {
    if (env2.offscreen) {
      c2 = new OffscreenCanvas(width, height);
    } else {
      if (typeof document === "undefined")
        throw new Error("attempted to run in web worker but offscreenCanvas is not supported");
      c2 = document.createElement("canvas");
      c2.width = width;
      c2.height = height;
    }
  } else {
    if (typeof env2.Canvas !== "undefined")
      c2 = new env2.Canvas(width, height);
    else if (typeof globalThis.Canvas !== "undefined")
      c2 = new globalThis.Canvas(width, height);
  }
  return c2;
}
function copy(input2, output) {
  const outputCanvas = output || canvas(input2.width, input2.height);
  const ctx = outputCanvas.getContext("2d");
  ctx.drawImage(input2, 0, 0);
  return outputCanvas;
}
function process2(input2, config3, getTensor2 = true) {
  if (!input2) {
    if (config3.debug)
      log("input is missing");
    return { tensor: null, canvas: null };
  }
  if (!(input2 instanceof Tensor) && !(typeof Image !== "undefined" && input2 instanceof Image) && !(typeof env2.Canvas !== "undefined" && input2 instanceof env2.Canvas) && !(typeof globalThis.Canvas !== "undefined" && input2 instanceof globalThis.Canvas) && !(typeof ImageData !== "undefined" && input2 instanceof ImageData) && !(typeof ImageBitmap !== "undefined" && input2 instanceof ImageBitmap) && !(typeof HTMLImageElement !== "undefined" && input2 instanceof HTMLImageElement) && !(typeof HTMLMediaElement !== "undefined" && input2 instanceof HTMLMediaElement) && !(typeof HTMLVideoElement !== "undefined" && input2 instanceof HTMLVideoElement) && !(typeof HTMLCanvasElement !== "undefined" && input2 instanceof HTMLCanvasElement) && !(typeof OffscreenCanvas !== "undefined" && input2 instanceof OffscreenCanvas)) {
    throw new Error("input type is not recognized");
  }
  if (input2 instanceof Tensor) {
    if (input2["isDisposedInternal"]) {
      throw new Error("input tensor is disposed");
    } else if (!input2.shape || input2.shape.length !== 4 || input2.shape[0] !== 1 || input2.shape[3] !== 3) {
      throw new Error(`input tensor shape must be [1, height, width, 3] and instead was ${input2["shape"]}`);
    } else {
      return { tensor: clone(input2), canvas: config3.filter.return ? outCanvas : null };
    }
  } else {
    if (typeof input2["readyState"] !== "undefined" && input2["readyState"] <= 2) {
      if (config3.debug)
        log("input stream is not ready");
      return { tensor: null, canvas: inCanvas };
    }
    const originalWidth = input2["naturalWidth"] || input2["videoWidth"] || input2["width"] || input2["shape"] && input2["shape"][1] > 0;
    const originalHeight = input2["naturalHeight"] || input2["videoHeight"] || input2["height"] || input2["shape"] && input2["shape"][2] > 0;
    if (!originalWidth || !originalHeight) {
      if (config3.debug)
        log("cannot determine input dimensions");
      return { tensor: null, canvas: inCanvas };
    }
    let targetWidth = originalWidth;
    let targetHeight = originalHeight;
    if (targetWidth > maxSize) {
      targetWidth = maxSize;
      targetHeight = Math.trunc(targetWidth * originalHeight / originalWidth);
    }
    if (targetHeight > maxSize) {
      targetHeight = maxSize;
      targetWidth = Math.trunc(targetHeight * originalWidth / originalHeight);
    }
    if ((config3.filter.width || 0) > 0)
      targetWidth = config3.filter.width;
    else if ((config3.filter.height || 0) > 0)
      targetWidth = originalWidth * ((config3.filter.height || 0) / originalHeight);
    if ((config3.filter.height || 0) > 0)
      targetHeight = config3.filter.height;
    else if ((config3.filter.width || 0) > 0)
      targetHeight = originalHeight * ((config3.filter.width || 0) / originalWidth);
    if (!targetWidth || !targetHeight)
      throw new Error("input cannot determine dimension");
    if (!inCanvas || (inCanvas == null ? void 0 : inCanvas.width) !== targetWidth || (inCanvas == null ? void 0 : inCanvas.height) !== targetHeight)
      inCanvas = canvas(targetWidth, targetHeight);
    const inCtx = inCanvas.getContext("2d");
    if (typeof ImageData !== "undefined" && input2 instanceof ImageData) {
      inCtx.putImageData(input2, 0, 0);
    } else {
      if (config3.filter.flip && typeof inCtx.translate !== "undefined") {
        inCtx.translate(originalWidth, 0);
        inCtx.scale(-1, 1);
        inCtx.drawImage(input2, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas == null ? void 0 : inCanvas.width, inCanvas == null ? void 0 : inCanvas.height);
        inCtx.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        inCtx.drawImage(input2, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas == null ? void 0 : inCanvas.width, inCanvas == null ? void 0 : inCanvas.height);
      }
    }
    if (!outCanvas || inCanvas.width !== outCanvas.width || (inCanvas == null ? void 0 : inCanvas.height) !== (outCanvas == null ? void 0 : outCanvas.height))
      outCanvas = canvas(inCanvas.width, inCanvas.height);
    if (config3.filter.enabled && env2.webgl.supported) {
      if (!fx)
        fx = env2.browser ? new GLImageFilter({ canvas: outCanvas }) : null;
      env2.filter = !!fx;
      if (!fx)
        return { tensor: null, canvas: inCanvas };
      fx.reset();
      if (config3.filter.brightness !== 0)
        fx.add("brightness", config3.filter.brightness);
      if (config3.filter.contrast !== 0)
        fx.add("contrast", config3.filter.contrast);
      if (config3.filter.sharpness !== 0)
        fx.add("sharpen", config3.filter.sharpness);
      if (config3.filter.blur !== 0)
        fx.add("blur", config3.filter.blur);
      if (config3.filter.saturation !== 0)
        fx.add("saturation", config3.filter.saturation);
      if (config3.filter.hue !== 0)
        fx.add("hue", config3.filter.hue);
      if (config3.filter.negative)
        fx.add("negative");
      if (config3.filter.sepia)
        fx.add("sepia");
      if (config3.filter.vintage)
        fx.add("brownie");
      if (config3.filter.sepia)
        fx.add("sepia");
      if (config3.filter.kodachrome)
        fx.add("kodachrome");
      if (config3.filter.technicolor)
        fx.add("technicolor");
      if (config3.filter.polaroid)
        fx.add("polaroid");
      if (config3.filter.pixelate !== 0)
        fx.add("pixelate", config3.filter.pixelate);
      if (fx.get() > 0)
        outCanvas = fx.apply(inCanvas);
      else
        outCanvas = fx.draw(inCanvas);
    } else {
      copy(inCanvas, outCanvas);
      if (fx)
        fx = null;
      env2.filter = !!fx;
    }
    if (!getTensor2)
      return { tensor: null, canvas: outCanvas };
    if (!outCanvas)
      throw new Error("cannot create output canvas");
    let pixels;
    let depth = 3;
    if (typeof ImageData !== "undefined" && input2 instanceof ImageData || input2["data"] && input2["width"] && input2["height"]) {
      if (env2.browser && browser_exports) {
        pixels = browser_exports ? browser_exports.fromPixels(input2) : null;
      } else {
        depth = input2["data"].length / input2["height"] / input2["width"];
        const arr = new Uint8Array(input2["data"]["buffer"]);
        pixels = tensor(arr, [input2["height"], input2["width"], depth], "int32");
      }
    } else {
      if (!tmpCanvas || outCanvas.width !== tmpCanvas.width || (outCanvas == null ? void 0 : outCanvas.height) !== (tmpCanvas == null ? void 0 : tmpCanvas.height))
        tmpCanvas = canvas(outCanvas.width, outCanvas.height);
      if (browser_exports && env2.browser) {
        if (config3.backend === "webgl" || config3.backend === "humangl" || config3.backend === "webgpu") {
          pixels = browser_exports.fromPixels(outCanvas);
        } else {
          tmpCanvas = copy(outCanvas);
          pixels = browser_exports.fromPixels(tmpCanvas);
        }
      } else {
        const tempCanvas = copy(outCanvas);
        const tempCtx = tempCanvas.getContext("2d");
        const tempData = tempCtx.getImageData(0, 0, targetWidth, targetHeight);
        depth = tempData.data.length / targetWidth / targetHeight;
        const arr = new Uint8Array(tempData.data.buffer);
        pixels = tensor(arr, [targetWidth, targetHeight, depth]);
      }
    }
    if (depth === 4) {
      const rgb2 = slice3d(pixels, [0, 0, 0], [-1, -1, 3]);
      dispose(pixels);
      pixels = rgb2;
    }
    if (!pixels)
      throw new Error("cannot create tensor from input");
    const casted = cast(pixels, "float32");
    const tensor2 = expandDims(casted, 0);
    dispose([pixels, casted]);
    return { tensor: tensor2, canvas: config3.filter.return ? outCanvas : null };
  }
}
var lastInputSum = 0;
var lastCacheDiff = 1;
var benchmarked = 0;
var checksum = async (input2) => {
  const resizeFact = 48;
  const reduced = image.resizeBilinear(input2, [Math.trunc((input2.shape[1] || 1) / resizeFact), Math.trunc((input2.shape[2] || 1) / resizeFact)]);
  const tfSum = async () => {
    const sumT = sum2(reduced);
    const sum0 = await sumT.data();
    dispose(sumT);
    return sum0[0];
  };
  const jsSum = async () => {
    const reducedData = await reduced.data();
    let sum0 = 0;
    for (let i2 = 0; i2 < reducedData.length / 3; i2++)
      sum0 += reducedData[3 * i2 + 2];
    return sum0;
  };
  if (benchmarked === 0) {
    const t0 = performance.now();
    await jsSum();
    const t1 = performance.now();
    await tfSum();
    const t2 = performance.now();
    benchmarked = t1 - t0 < t2 - t1 ? 1 : 2;
  }
  const res2 = benchmarked === 1 ? await jsSum() : await tfSum();
  dispose(reduced);
  return res2;
};
async function skip(config3, input2) {
  if (config3.cacheSensitivity === 0)
    return false;
  const sum7 = await checksum(input2);
  const diff = 100 * (Math.max(sum7, lastInputSum) / Math.min(sum7, lastInputSum) - 1);
  lastInputSum = sum7;
  let skipFrame = diff < Math.max(config3.cacheSensitivity, lastCacheDiff);
  lastCacheDiff = diff > 10 * config3.cacheSensitivity ? 0 : diff;
  skipFrame = skipFrame && lastCacheDiff > 0;
  return skipFrame;
}
var meshAnnotations = {
  silhouette: [
    10,
    338,
    297,
    332,
    284,
    251,
    389,
    356,
    454,
    323,
    361,
    288,
    397,
    365,
    379,
    378,
    400,
    377,
    152,
    148,
    176,
    149,
    150,
    136,
    172,
    58,
    132,
    93,
    234,
    127,
    162,
    21,
    54,
    103,
    67,
    109
  ],
  lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],
  lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],
  lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],
  lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],
  rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],
  rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],
  rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],
  rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],
  rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],
  rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],
  rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],
  rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],
  rightEyebrowLower: [35, 124, 46, 53, 52, 65],
  rightEyeIris: [473, 474, 475, 476, 477],
  leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],
  leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],
  leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],
  leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],
  leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],
  leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],
  leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],
  leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],
  leftEyebrowLower: [265, 353, 276, 283, 282, 295],
  leftEyeIris: [468, 469, 470, 471, 472],
  midwayBetweenEyes: [168],
  noseTip: [1],
  noseBottom: [2],
  noseRightCorner: [98],
  noseLeftCorner: [327],
  rightCheek: [205],
  leftCheek: [425]
};
var meshLandmarks = {
  count: 468,
  mouth: 13,
  symmetryLine: [13, meshAnnotations["midwayBetweenEyes"][0]]
};
var blazeFaceLandmarks = {
  leftEye: 0,
  rightEye: 1,
  nose: 2,
  mouth: 3,
  leftEar: 4,
  rightEar: 5,
  symmetryLine: [3, 2]
};
var MESH_TO_IRIS_INDICES_MAP = [
  { key: "EyeUpper0", indices: [9, 10, 11, 12, 13, 14, 15] },
  { key: "EyeUpper1", indices: [25, 26, 27, 28, 29, 30, 31] },
  { key: "EyeUpper2", indices: [41, 42, 43, 44, 45, 46, 47] },
  { key: "EyeLower0", indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] },
  { key: "EyeLower1", indices: [16, 17, 18, 19, 20, 21, 22, 23, 24] },
  { key: "EyeLower2", indices: [32, 33, 34, 35, 36, 37, 38, 39, 40] },
  { key: "EyeLower3", indices: [54, 55, 56, 57, 58, 59, 60, 61, 62] }
];
var UV468 = [
  [0.499976992607117, 0.652534008026123],
  [0.500025987625122, 0.547487020492554],
  [0.499974012374878, 0.602371990680695],
  [0.482113003730774, 0.471979022026062],
  [0.500150978565216, 0.527155995368958],
  [0.499909996986389, 0.498252987861633],
  [0.499523013830185, 0.40106201171875],
  [0.289712011814117, 0.380764007568359],
  [0.499954998493195, 0.312398016452789],
  [0.499987006187439, 0.269918978214264],
  [0.500023007392883, 0.107050001621246],
  [0.500023007392883, 0.666234016418457],
  [0.5000159740448, 0.679224014282227],
  [0.500023007392883, 0.692348003387451],
  [0.499976992607117, 0.695277988910675],
  [0.499976992607117, 0.70593398809433],
  [0.499976992607117, 0.719385027885437],
  [0.499976992607117, 0.737019002437592],
  [0.499967992305756, 0.781370997428894],
  [0.499816000461578, 0.562981009483337],
  [0.473773002624512, 0.573909997940063],
  [0.104906998574734, 0.254140973091125],
  [0.365929991006851, 0.409575998783112],
  [0.338757991790771, 0.41302502155304],
  [0.311120003461838, 0.409460008144379],
  [0.274657994508743, 0.389131009578705],
  [0.393361985683441, 0.403706014156342],
  [0.345234006643295, 0.344011008739471],
  [0.370094001293182, 0.346076011657715],
  [0.319321990013123, 0.347265005111694],
  [0.297903001308441, 0.353591024875641],
  [0.24779200553894, 0.410809993743896],
  [0.396889001131058, 0.842755019664764],
  [0.280097991228104, 0.375599980354309],
  [0.106310002505779, 0.399955987930298],
  [0.2099249958992, 0.391353011131287],
  [0.355807989835739, 0.534406006336212],
  [0.471751004457474, 0.65040397644043],
  [0.474155008792877, 0.680191993713379],
  [0.439785003662109, 0.657229006290436],
  [0.414617002010345, 0.66654098033905],
  [0.450374007225037, 0.680860996246338],
  [0.428770989179611, 0.682690978050232],
  [0.374971002340317, 0.727805018424988],
  [0.486716985702515, 0.547628998756409],
  [0.485300987958908, 0.527395009994507],
  [0.257764995098114, 0.314490020275116],
  [0.401223003864288, 0.455172002315521],
  [0.429818987846375, 0.548614978790283],
  [0.421351999044418, 0.533740997314453],
  [0.276895999908447, 0.532056987285614],
  [0.483370006084442, 0.499586999416351],
  [0.33721199631691, 0.282882988452911],
  [0.296391993761063, 0.293242990970612],
  [0.169294998049736, 0.193813979625702],
  [0.447580009698868, 0.302609980106354],
  [0.392390012741089, 0.353887975215912],
  [0.354490011930466, 0.696784019470215],
  [0.067304998636246, 0.730105042457581],
  [0.442739009857178, 0.572826027870178],
  [0.457098007202148, 0.584792017936707],
  [0.381974011659622, 0.694710969924927],
  [0.392388999462128, 0.694203019142151],
  [0.277076005935669, 0.271932005882263],
  [0.422551989555359, 0.563233017921448],
  [0.385919004678726, 0.281364023685455],
  [0.383103013038635, 0.255840003490448],
  [0.331431001424789, 0.119714021682739],
  [0.229923993349075, 0.232002973556519],
  [0.364500999450684, 0.189113974571228],
  [0.229622006416321, 0.299540996551514],
  [0.173287004232407, 0.278747975826263],
  [0.472878992557526, 0.666198015213013],
  [0.446828007698059, 0.668527007102966],
  [0.422762006521225, 0.673889994621277],
  [0.445307999849319, 0.580065965652466],
  [0.388103008270264, 0.693961024284363],
  [0.403039008378983, 0.706539988517761],
  [0.403629004955292, 0.693953037261963],
  [0.460041999816895, 0.557139039039612],
  [0.431158006191254, 0.692366003990173],
  [0.452181994915009, 0.692366003990173],
  [0.475387006998062, 0.692366003990173],
  [0.465828001499176, 0.779190003871918],
  [0.472328990697861, 0.736225962638855],
  [0.473087012767792, 0.717857003211975],
  [0.473122000694275, 0.704625964164734],
  [0.473033010959625, 0.695277988910675],
  [0.427942007780075, 0.695277988910675],
  [0.426479011774063, 0.703539967536926],
  [0.423162013292313, 0.711845993995667],
  [0.4183090031147, 0.720062971115112],
  [0.390094995498657, 0.639572978019714],
  [0.013953999616206, 0.560034036636353],
  [0.499913990497589, 0.58014702796936],
  [0.413199990987778, 0.69539999961853],
  [0.409626007080078, 0.701822996139526],
  [0.468080013990402, 0.601534962654114],
  [0.422728985548019, 0.585985004901886],
  [0.463079988956451, 0.593783974647522],
  [0.37211999297142, 0.47341400384903],
  [0.334562003612518, 0.496073007583618],
  [0.411671012639999, 0.546965003013611],
  [0.242175996303558, 0.14767599105835],
  [0.290776997804642, 0.201445996761322],
  [0.327338010072708, 0.256527006626129],
  [0.399509996175766, 0.748921036720276],
  [0.441727995872498, 0.261676013469696],
  [0.429764986038208, 0.187834024429321],
  [0.412198007106781, 0.108901023864746],
  [0.288955003023148, 0.398952007293701],
  [0.218936994671822, 0.435410976409912],
  [0.41278201341629, 0.398970007896423],
  [0.257135003805161, 0.355440020561218],
  [0.427684992551804, 0.437960982322693],
  [0.448339998722076, 0.536936044692993],
  [0.178560003638268, 0.45755398273468],
  [0.247308000922203, 0.457193970680237],
  [0.286267012357712, 0.467674970626831],
  [0.332827985286713, 0.460712015628815],
  [0.368755996227264, 0.447206974029541],
  [0.398963987827301, 0.432654976844788],
  [0.476410001516342, 0.405806005001068],
  [0.189241006970406, 0.523923993110657],
  [0.228962004184723, 0.348950982093811],
  [0.490725994110107, 0.562400996685028],
  [0.404670000076294, 0.485132992267609],
  [0.019469000399113, 0.401564002037048],
  [0.426243007183075, 0.420431017875671],
  [0.396993011236191, 0.548797011375427],
  [0.266469985246658, 0.376977026462555],
  [0.439121007919312, 0.51895797252655],
  [0.032313998788595, 0.644356966018677],
  [0.419054001569748, 0.387154996395111],
  [0.462783008813858, 0.505746960639954],
  [0.238978996872902, 0.779744982719421],
  [0.198220998048782, 0.831938028335571],
  [0.107550002634525, 0.540755033493042],
  [0.183610007166862, 0.740257024765015],
  [0.134409993886948, 0.333683013916016],
  [0.385764002799988, 0.883153975009918],
  [0.490967005491257, 0.579378008842468],
  [0.382384985685349, 0.508572995662689],
  [0.174399003386497, 0.397670984268188],
  [0.318785011768341, 0.39623498916626],
  [0.343364000320435, 0.400596976280212],
  [0.396100014448166, 0.710216999053955],
  [0.187885001301765, 0.588537991046906],
  [0.430987000465393, 0.944064974784851],
  [0.318993002176285, 0.898285031318665],
  [0.266247987747192, 0.869701027870178],
  [0.500023007392883, 0.190576016902924],
  [0.499976992607117, 0.954452991485596],
  [0.366169989109039, 0.398822009563446],
  [0.393207013607025, 0.39553701877594],
  [0.410373002290726, 0.391080021858215],
  [0.194993004202843, 0.342101991176605],
  [0.388664990663528, 0.362284004688263],
  [0.365961998701096, 0.355970978736877],
  [0.343364000320435, 0.355356991291046],
  [0.318785011768341, 0.35834002494812],
  [0.301414996385574, 0.363156020641327],
  [0.058132998645306, 0.319076001644135],
  [0.301414996385574, 0.387449026107788],
  [0.499987989664078, 0.618434011936188],
  [0.415838003158569, 0.624195992946625],
  [0.445681989192963, 0.566076993942261],
  [0.465844005346298, 0.620640993118286],
  [0.49992299079895, 0.351523995399475],
  [0.288718998432159, 0.819945991039276],
  [0.335278987884521, 0.852819979190826],
  [0.440512001514435, 0.902418971061707],
  [0.128294005990028, 0.791940987110138],
  [0.408771991729736, 0.373893976211548],
  [0.455606997013092, 0.451801002025604],
  [0.499877005815506, 0.908990025520325],
  [0.375436991453171, 0.924192011356354],
  [0.11421000212431, 0.615022003650665],
  [0.448662012815475, 0.695277988910675],
  [0.4480200111866, 0.704632043838501],
  [0.447111994028091, 0.715808033943176],
  [0.444831997156143, 0.730794012546539],
  [0.430011987686157, 0.766808986663818],
  [0.406787008047104, 0.685672998428345],
  [0.400738000869751, 0.681069016456604],
  [0.392399996519089, 0.677703022956848],
  [0.367855995893478, 0.663918972015381],
  [0.247923001646996, 0.601333022117615],
  [0.452769994735718, 0.420849978923798],
  [0.43639200925827, 0.359887003898621],
  [0.416164010763168, 0.368713974952698],
  [0.413385987281799, 0.692366003990173],
  [0.228018000721931, 0.683571994304657],
  [0.468268007040024, 0.352671027183533],
  [0.411361992359161, 0.804327011108398],
  [0.499989002943039, 0.469825029373169],
  [0.479153990745544, 0.442654013633728],
  [0.499974012374878, 0.439637005329132],
  [0.432112008333206, 0.493588984012604],
  [0.499886006116867, 0.866917014122009],
  [0.49991300702095, 0.821729004383087],
  [0.456548988819122, 0.819200992584229],
  [0.344549000263214, 0.745438992977142],
  [0.37890899181366, 0.574010014533997],
  [0.374292999505997, 0.780184984207153],
  [0.319687992334366, 0.570737957954407],
  [0.357154995203018, 0.604269981384277],
  [0.295284003019333, 0.621580958366394],
  [0.447750002145767, 0.862477004528046],
  [0.410986006259918, 0.508723020553589],
  [0.31395098567009, 0.775308012962341],
  [0.354128003120422, 0.812552988529205],
  [0.324548006057739, 0.703992962837219],
  [0.189096003770828, 0.646299958229065],
  [0.279776990413666, 0.71465802192688],
  [0.1338230073452, 0.682700991630554],
  [0.336768001317978, 0.644733011722565],
  [0.429883986711502, 0.466521978378296],
  [0.455527991056442, 0.548622965812683],
  [0.437114000320435, 0.558896005153656],
  [0.467287987470627, 0.529924988746643],
  [0.414712011814117, 0.335219979286194],
  [0.37704598903656, 0.322777986526489],
  [0.344107985496521, 0.320150971412659],
  [0.312875986099243, 0.32233202457428],
  [0.283526003360748, 0.333190023899078],
  [0.241245999932289, 0.382785975933075],
  [0.102986000478268, 0.468762993812561],
  [0.267612010240555, 0.424560010433197],
  [0.297879010438919, 0.433175981044769],
  [0.333433985710144, 0.433878004550934],
  [0.366427004337311, 0.426115989685059],
  [0.396012008190155, 0.416696012020111],
  [0.420121014118195, 0.41022801399231],
  [0.007561000064015, 0.480777025222778],
  [0.432949006557465, 0.569517970085144],
  [0.458638995885849, 0.479089021682739],
  [0.473466008901596, 0.545744001865387],
  [0.476087987422943, 0.563830018043518],
  [0.468472003936768, 0.555056989192963],
  [0.433990985155106, 0.582361996173859],
  [0.483518004417419, 0.562983989715576],
  [0.482482999563217, 0.57784903049469],
  [0.42645001411438, 0.389798998832703],
  [0.438998997211456, 0.39649498462677],
  [0.450067013502121, 0.400434017181396],
  [0.289712011814117, 0.368252992630005],
  [0.276670008897781, 0.363372981548309],
  [0.517862021923065, 0.471948027610779],
  [0.710287988185883, 0.380764007568359],
  [0.526226997375488, 0.573909997940063],
  [0.895093023777008, 0.254140973091125],
  [0.634069979190826, 0.409575998783112],
  [0.661242008209229, 0.41302502155304],
  [0.688880026340485, 0.409460008144379],
  [0.725341975688934, 0.389131009578705],
  [0.606630027294159, 0.40370500087738],
  [0.654766023159027, 0.344011008739471],
  [0.629905998706818, 0.346076011657715],
  [0.680678009986877, 0.347265005111694],
  [0.702096998691559, 0.353591024875641],
  [0.75221198797226, 0.410804986953735],
  [0.602918028831482, 0.842862963676453],
  [0.719901978969574, 0.375599980354309],
  [0.893692970275879, 0.399959981441498],
  [0.790081977844238, 0.391354024410248],
  [0.643998026847839, 0.534487962722778],
  [0.528249025344849, 0.65040397644043],
  [0.525849997997284, 0.680191040039062],
  [0.560214996337891, 0.657229006290436],
  [0.585384011268616, 0.66654098033905],
  [0.549625992774963, 0.680860996246338],
  [0.57122802734375, 0.682691991329193],
  [0.624852001667023, 0.72809898853302],
  [0.513050019741058, 0.547281980514526],
  [0.51509702205658, 0.527251958847046],
  [0.742246985435486, 0.314507007598877],
  [0.598631024360657, 0.454979002475739],
  [0.570338010787964, 0.548575043678284],
  [0.578631997108459, 0.533622980117798],
  [0.723087012767792, 0.532054007053375],
  [0.516445994377136, 0.499638974666595],
  [0.662801027297974, 0.282917976379395],
  [0.70362401008606, 0.293271005153656],
  [0.830704987049103, 0.193813979625702],
  [0.552385985851288, 0.302568018436432],
  [0.607609987258911, 0.353887975215912],
  [0.645429015159607, 0.696707010269165],
  [0.932694971561432, 0.730105042457581],
  [0.557260990142822, 0.572826027870178],
  [0.542901992797852, 0.584792017936707],
  [0.6180260181427, 0.694710969924927],
  [0.607590973377228, 0.694203019142151],
  [0.722943007946014, 0.271963000297546],
  [0.577413976192474, 0.563166975975037],
  [0.614082992076874, 0.281386971473694],
  [0.616907000541687, 0.255886018276215],
  [0.668509006500244, 0.119913995265961],
  [0.770092010498047, 0.232020974159241],
  [0.635536015033722, 0.189248979091644],
  [0.77039098739624, 0.299556016921997],
  [0.826722025871277, 0.278755009174347],
  [0.527121007442474, 0.666198015213013],
  [0.553171992301941, 0.668527007102966],
  [0.577238023281097, 0.673889994621277],
  [0.554691970348358, 0.580065965652466],
  [0.611896991729736, 0.693961024284363],
  [0.59696102142334, 0.706539988517761],
  [0.596370995044708, 0.693953037261963],
  [0.539958000183105, 0.557139039039612],
  [0.568841993808746, 0.692366003990173],
  [0.547818005084991, 0.692366003990173],
  [0.52461302280426, 0.692366003990173],
  [0.534089982509613, 0.779141008853912],
  [0.527670979499817, 0.736225962638855],
  [0.526912987232208, 0.717857003211975],
  [0.526877999305725, 0.704625964164734],
  [0.526966989040375, 0.695277988910675],
  [0.572058022022247, 0.695277988910675],
  [0.573521018028259, 0.703539967536926],
  [0.57683801651001, 0.711845993995667],
  [0.581691026687622, 0.720062971115112],
  [0.609944999217987, 0.639909982681274],
  [0.986046016216278, 0.560034036636353],
  [0.5867999792099, 0.69539999961853],
  [0.590372025966644, 0.701822996139526],
  [0.531915009021759, 0.601536989212036],
  [0.577268004417419, 0.585934996604919],
  [0.536915004253387, 0.593786001205444],
  [0.627542972564697, 0.473352015018463],
  [0.665585994720459, 0.495950996875763],
  [0.588353991508484, 0.546862006187439],
  [0.757824003696442, 0.14767599105835],
  [0.709249973297119, 0.201507985591888],
  [0.672684013843536, 0.256581008434296],
  [0.600408971309662, 0.74900496006012],
  [0.55826598405838, 0.261672019958496],
  [0.570303976535797, 0.187870979309082],
  [0.588165998458862, 0.109044015407562],
  [0.711045026779175, 0.398952007293701],
  [0.781069993972778, 0.435405015945435],
  [0.587247014045715, 0.398931980133057],
  [0.742869973182678, 0.355445981025696],
  [0.572156012058258, 0.437651991844177],
  [0.55186802148819, 0.536570012569427],
  [0.821442008018494, 0.457556009292603],
  [0.752701997756958, 0.457181990146637],
  [0.71375697851181, 0.467626988887787],
  [0.66711300611496, 0.460672974586487],
  [0.631101012229919, 0.447153985500336],
  [0.6008620262146, 0.432473003864288],
  [0.523481011390686, 0.405627012252808],
  [0.810747981071472, 0.523926019668579],
  [0.771045982837677, 0.348959028720856],
  [0.509127020835876, 0.562718033790588],
  [0.595292985439301, 0.485023975372314],
  [0.980530977249146, 0.401564002037048],
  [0.573499977588654, 0.420000016689301],
  [0.602994978427887, 0.548687994480133],
  [0.733529984951019, 0.376977026462555],
  [0.560611009597778, 0.519016981124878],
  [0.967685997486115, 0.644356966018677],
  [0.580985009670258, 0.387160003185272],
  [0.537728011608124, 0.505385041236877],
  [0.760966002941132, 0.779752969741821],
  [0.801778972148895, 0.831938028335571],
  [0.892440974712372, 0.54076099395752],
  [0.816350996494293, 0.740260004997253],
  [0.865594983100891, 0.333687007427216],
  [0.614073991775513, 0.883246004581451],
  [0.508952975273132, 0.579437971115112],
  [0.617941975593567, 0.508316040039062],
  [0.825608015060425, 0.397674977779388],
  [0.681214988231659, 0.39623498916626],
  [0.656635999679565, 0.400596976280212],
  [0.603900015354156, 0.710216999053955],
  [0.81208598613739, 0.588539004325867],
  [0.56801301240921, 0.944564998149872],
  [0.681007981300354, 0.898285031318665],
  [0.733752012252808, 0.869701027870178],
  [0.633830010890961, 0.398822009563446],
  [0.606792986392975, 0.39553701877594],
  [0.589659988880157, 0.391062021255493],
  [0.805015981197357, 0.342108011245728],
  [0.611334979534149, 0.362284004688263],
  [0.634037971496582, 0.355970978736877],
  [0.656635999679565, 0.355356991291046],
  [0.681214988231659, 0.35834002494812],
  [0.698584973812103, 0.363156020641327],
  [0.941866993904114, 0.319076001644135],
  [0.698584973812103, 0.387449026107788],
  [0.584177017211914, 0.624107003211975],
  [0.554318010807037, 0.566076993942261],
  [0.534153997898102, 0.62064003944397],
  [0.711217999458313, 0.819975018501282],
  [0.664629995822906, 0.852871000766754],
  [0.559099972248077, 0.902631998062134],
  [0.871706008911133, 0.791940987110138],
  [0.591234028339386, 0.373893976211548],
  [0.544341027736664, 0.451583981513977],
  [0.624562978744507, 0.924192011356354],
  [0.88577002286911, 0.615028977394104],
  [0.551338016986847, 0.695277988910675],
  [0.551980018615723, 0.704632043838501],
  [0.552887976169586, 0.715808033943176],
  [0.555167973041534, 0.730794012546539],
  [0.569944024085999, 0.767035007476807],
  [0.593203008174896, 0.685675978660583],
  [0.599261999130249, 0.681069016456604],
  [0.607599973678589, 0.677703022956848],
  [0.631937980651855, 0.663500010967255],
  [0.752032995223999, 0.601315021514893],
  [0.547226011753082, 0.420395016670227],
  [0.563543975353241, 0.359827995300293],
  [0.583841025829315, 0.368713974952698],
  [0.586614012718201, 0.692366003990173],
  [0.771915018558502, 0.683578014373779],
  [0.531597018241882, 0.352482974529266],
  [0.588370978832245, 0.804440975189209],
  [0.52079701423645, 0.442565023899078],
  [0.567984998226166, 0.493479013442993],
  [0.543282985687256, 0.819254994392395],
  [0.655317008495331, 0.745514988899231],
  [0.621008992195129, 0.574018001556396],
  [0.625559985637665, 0.78031200170517],
  [0.680198013782501, 0.570719003677368],
  [0.64276397228241, 0.604337990283966],
  [0.704662978649139, 0.621529996395111],
  [0.552012026309967, 0.862591981887817],
  [0.589071989059448, 0.508637011051178],
  [0.685944974422455, 0.775357007980347],
  [0.645735025405884, 0.812640011310577],
  [0.675342977046967, 0.703978002071381],
  [0.810858011245728, 0.646304965019226],
  [0.72012197971344, 0.714666962623596],
  [0.866151988506317, 0.682704985141754],
  [0.663187026977539, 0.644596993923187],
  [0.570082008838654, 0.466325998306274],
  [0.544561982154846, 0.548375964164734],
  [0.562758982181549, 0.558784961700439],
  [0.531987011432648, 0.530140042304993],
  [0.585271000862122, 0.335177004337311],
  [0.622952997684479, 0.32277899980545],
  [0.655896008014679, 0.320163011550903],
  [0.687132000923157, 0.322345972061157],
  [0.716481983661652, 0.333200991153717],
  [0.758756995201111, 0.382786989212036],
  [0.897013008594513, 0.468769013881683],
  [0.732392013072968, 0.424547016620636],
  [0.70211398601532, 0.433162987232208],
  [0.66652500629425, 0.433866024017334],
  [0.633504986763, 0.426087975502014],
  [0.603875994682312, 0.416586995124817],
  [0.579657971858978, 0.409945011138916],
  [0.992439985275269, 0.480777025222778],
  [0.567192018032074, 0.569419980049133],
  [0.54136598110199, 0.478899002075195],
  [0.526564002037048, 0.546118021011353],
  [0.523913025856018, 0.563830018043518],
  [0.531529009342194, 0.555056989192963],
  [0.566035985946655, 0.582329034805298],
  [0.51631098985672, 0.563053965568542],
  [0.5174720287323, 0.577877044677734],
  [0.573594987392426, 0.389806985855103],
  [0.560697972774506, 0.395331978797913],
  [0.549755990505219, 0.399751007556915],
  [0.710287988185883, 0.368252992630005],
  [0.723330020904541, 0.363372981548309]
];
var TRI468 = [
  127,
  34,
  139,
  11,
  0,
  37,
  232,
  231,
  120,
  72,
  37,
  39,
  128,
  121,
  47,
  232,
  121,
  128,
  104,
  69,
  67,
  175,
  171,
  148,
  157,
  154,
  155,
  118,
  50,
  101,
  73,
  39,
  40,
  9,
  151,
  108,
  48,
  115,
  131,
  194,
  204,
  211,
  74,
  40,
  185,
  80,
  42,
  183,
  40,
  92,
  186,
  230,
  229,
  118,
  202,
  212,
  214,
  83,
  18,
  17,
  76,
  61,
  146,
  160,
  29,
  30,
  56,
  157,
  173,
  106,
  204,
  194,
  135,
  214,
  192,
  203,
  165,
  98,
  21,
  71,
  68,
  51,
  45,
  4,
  144,
  24,
  23,
  77,
  146,
  91,
  205,
  50,
  187,
  201,
  200,
  18,
  91,
  106,
  182,
  90,
  91,
  181,
  85,
  84,
  17,
  206,
  203,
  36,
  148,
  171,
  140,
  92,
  40,
  39,
  193,
  189,
  244,
  159,
  158,
  28,
  247,
  246,
  161,
  236,
  3,
  196,
  54,
  68,
  104,
  193,
  168,
  8,
  117,
  228,
  31,
  189,
  193,
  55,
  98,
  97,
  99,
  126,
  47,
  100,
  166,
  79,
  218,
  155,
  154,
  26,
  209,
  49,
  131,
  135,
  136,
  150,
  47,
  126,
  217,
  223,
  52,
  53,
  45,
  51,
  134,
  211,
  170,
  140,
  67,
  69,
  108,
  43,
  106,
  91,
  230,
  119,
  120,
  226,
  130,
  247,
  63,
  53,
  52,
  238,
  20,
  242,
  46,
  70,
  156,
  78,
  62,
  96,
  46,
  53,
  63,
  143,
  34,
  227,
  173,
  155,
  133,
  123,
  117,
  111,
  44,
  125,
  19,
  236,
  134,
  51,
  216,
  206,
  205,
  154,
  153,
  22,
  39,
  37,
  167,
  200,
  201,
  208,
  36,
  142,
  100,
  57,
  212,
  202,
  20,
  60,
  99,
  28,
  158,
  157,
  35,
  226,
  113,
  160,
  159,
  27,
  204,
  202,
  210,
  113,
  225,
  46,
  43,
  202,
  204,
  62,
  76,
  77,
  137,
  123,
  116,
  41,
  38,
  72,
  203,
  129,
  142,
  64,
  98,
  240,
  49,
  102,
  64,
  41,
  73,
  74,
  212,
  216,
  207,
  42,
  74,
  184,
  169,
  170,
  211,
  170,
  149,
  176,
  105,
  66,
  69,
  122,
  6,
  168,
  123,
  147,
  187,
  96,
  77,
  90,
  65,
  55,
  107,
  89,
  90,
  180,
  101,
  100,
  120,
  63,
  105,
  104,
  93,
  137,
  227,
  15,
  86,
  85,
  129,
  102,
  49,
  14,
  87,
  86,
  55,
  8,
  9,
  100,
  47,
  121,
  145,
  23,
  22,
  88,
  89,
  179,
  6,
  122,
  196,
  88,
  95,
  96,
  138,
  172,
  136,
  215,
  58,
  172,
  115,
  48,
  219,
  42,
  80,
  81,
  195,
  3,
  51,
  43,
  146,
  61,
  171,
  175,
  199,
  81,
  82,
  38,
  53,
  46,
  225,
  144,
  163,
  110,
  246,
  33,
  7,
  52,
  65,
  66,
  229,
  228,
  117,
  34,
  127,
  234,
  107,
  108,
  69,
  109,
  108,
  151,
  48,
  64,
  235,
  62,
  78,
  191,
  129,
  209,
  126,
  111,
  35,
  143,
  163,
  161,
  246,
  117,
  123,
  50,
  222,
  65,
  52,
  19,
  125,
  141,
  221,
  55,
  65,
  3,
  195,
  197,
  25,
  7,
  33,
  220,
  237,
  44,
  70,
  71,
  139,
  122,
  193,
  245,
  247,
  130,
  33,
  71,
  21,
  162,
  153,
  158,
  159,
  170,
  169,
  150,
  188,
  174,
  196,
  216,
  186,
  92,
  144,
  160,
  161,
  2,
  97,
  167,
  141,
  125,
  241,
  164,
  167,
  37,
  72,
  38,
  12,
  145,
  159,
  160,
  38,
  82,
  13,
  63,
  68,
  71,
  226,
  35,
  111,
  158,
  153,
  154,
  101,
  50,
  205,
  206,
  92,
  165,
  209,
  198,
  217,
  165,
  167,
  97,
  220,
  115,
  218,
  133,
  112,
  243,
  239,
  238,
  241,
  214,
  135,
  169,
  190,
  173,
  133,
  171,
  208,
  32,
  125,
  44,
  237,
  86,
  87,
  178,
  85,
  86,
  179,
  84,
  85,
  180,
  83,
  84,
  181,
  201,
  83,
  182,
  137,
  93,
  132,
  76,
  62,
  183,
  61,
  76,
  184,
  57,
  61,
  185,
  212,
  57,
  186,
  214,
  207,
  187,
  34,
  143,
  156,
  79,
  239,
  237,
  123,
  137,
  177,
  44,
  1,
  4,
  201,
  194,
  32,
  64,
  102,
  129,
  213,
  215,
  138,
  59,
  166,
  219,
  242,
  99,
  97,
  2,
  94,
  141,
  75,
  59,
  235,
  24,
  110,
  228,
  25,
  130,
  226,
  23,
  24,
  229,
  22,
  23,
  230,
  26,
  22,
  231,
  112,
  26,
  232,
  189,
  190,
  243,
  221,
  56,
  190,
  28,
  56,
  221,
  27,
  28,
  222,
  29,
  27,
  223,
  30,
  29,
  224,
  247,
  30,
  225,
  238,
  79,
  20,
  166,
  59,
  75,
  60,
  75,
  240,
  147,
  177,
  215,
  20,
  79,
  166,
  187,
  147,
  213,
  112,
  233,
  244,
  233,
  128,
  245,
  128,
  114,
  188,
  114,
  217,
  174,
  131,
  115,
  220,
  217,
  198,
  236,
  198,
  131,
  134,
  177,
  132,
  58,
  143,
  35,
  124,
  110,
  163,
  7,
  228,
  110,
  25,
  356,
  389,
  368,
  11,
  302,
  267,
  452,
  350,
  349,
  302,
  303,
  269,
  357,
  343,
  277,
  452,
  453,
  357,
  333,
  332,
  297,
  175,
  152,
  377,
  384,
  398,
  382,
  347,
  348,
  330,
  303,
  304,
  270,
  9,
  336,
  337,
  278,
  279,
  360,
  418,
  262,
  431,
  304,
  408,
  409,
  310,
  415,
  407,
  270,
  409,
  410,
  450,
  348,
  347,
  422,
  430,
  434,
  313,
  314,
  17,
  306,
  307,
  375,
  387,
  388,
  260,
  286,
  414,
  398,
  335,
  406,
  418,
  364,
  367,
  416,
  423,
  358,
  327,
  251,
  284,
  298,
  281,
  5,
  4,
  373,
  374,
  253,
  307,
  320,
  321,
  425,
  427,
  411,
  421,
  313,
  18,
  321,
  405,
  406,
  320,
  404,
  405,
  315,
  16,
  17,
  426,
  425,
  266,
  377,
  400,
  369,
  322,
  391,
  269,
  417,
  465,
  464,
  386,
  257,
  258,
  466,
  260,
  388,
  456,
  399,
  419,
  284,
  332,
  333,
  417,
  285,
  8,
  346,
  340,
  261,
  413,
  441,
  285,
  327,
  460,
  328,
  355,
  371,
  329,
  392,
  439,
  438,
  382,
  341,
  256,
  429,
  420,
  360,
  364,
  394,
  379,
  277,
  343,
  437,
  443,
  444,
  283,
  275,
  440,
  363,
  431,
  262,
  369,
  297,
  338,
  337,
  273,
  375,
  321,
  450,
  451,
  349,
  446,
  342,
  467,
  293,
  334,
  282,
  458,
  461,
  462,
  276,
  353,
  383,
  308,
  324,
  325,
  276,
  300,
  293,
  372,
  345,
  447,
  382,
  398,
  362,
  352,
  345,
  340,
  274,
  1,
  19,
  456,
  248,
  281,
  436,
  427,
  425,
  381,
  256,
  252,
  269,
  391,
  393,
  200,
  199,
  428,
  266,
  330,
  329,
  287,
  273,
  422,
  250,
  462,
  328,
  258,
  286,
  384,
  265,
  353,
  342,
  387,
  259,
  257,
  424,
  431,
  430,
  342,
  353,
  276,
  273,
  335,
  424,
  292,
  325,
  307,
  366,
  447,
  345,
  271,
  303,
  302,
  423,
  266,
  371,
  294,
  455,
  460,
  279,
  278,
  294,
  271,
  272,
  304,
  432,
  434,
  427,
  272,
  407,
  408,
  394,
  430,
  431,
  395,
  369,
  400,
  334,
  333,
  299,
  351,
  417,
  168,
  352,
  280,
  411,
  325,
  319,
  320,
  295,
  296,
  336,
  319,
  403,
  404,
  330,
  348,
  349,
  293,
  298,
  333,
  323,
  454,
  447,
  15,
  16,
  315,
  358,
  429,
  279,
  14,
  15,
  316,
  285,
  336,
  9,
  329,
  349,
  350,
  374,
  380,
  252,
  318,
  402,
  403,
  6,
  197,
  419,
  318,
  319,
  325,
  367,
  364,
  365,
  435,
  367,
  397,
  344,
  438,
  439,
  272,
  271,
  311,
  195,
  5,
  281,
  273,
  287,
  291,
  396,
  428,
  199,
  311,
  271,
  268,
  283,
  444,
  445,
  373,
  254,
  339,
  263,
  466,
  249,
  282,
  334,
  296,
  449,
  347,
  346,
  264,
  447,
  454,
  336,
  296,
  299,
  338,
  10,
  151,
  278,
  439,
  455,
  292,
  407,
  415,
  358,
  371,
  355,
  340,
  345,
  372,
  390,
  249,
  466,
  346,
  347,
  280,
  442,
  443,
  282,
  19,
  94,
  370,
  441,
  442,
  295,
  248,
  419,
  197,
  263,
  255,
  359,
  440,
  275,
  274,
  300,
  383,
  368,
  351,
  412,
  465,
  263,
  467,
  466,
  301,
  368,
  389,
  380,
  374,
  386,
  395,
  378,
  379,
  412,
  351,
  419,
  436,
  426,
  322,
  373,
  390,
  388,
  2,
  164,
  393,
  370,
  462,
  461,
  164,
  0,
  267,
  302,
  11,
  12,
  374,
  373,
  387,
  268,
  12,
  13,
  293,
  300,
  301,
  446,
  261,
  340,
  385,
  384,
  381,
  330,
  266,
  425,
  426,
  423,
  391,
  429,
  355,
  437,
  391,
  327,
  326,
  440,
  457,
  438,
  341,
  382,
  362,
  459,
  457,
  461,
  434,
  430,
  394,
  414,
  463,
  362,
  396,
  369,
  262,
  354,
  461,
  457,
  316,
  403,
  402,
  315,
  404,
  403,
  314,
  405,
  404,
  313,
  406,
  405,
  421,
  418,
  406,
  366,
  401,
  361,
  306,
  408,
  407,
  291,
  409,
  408,
  287,
  410,
  409,
  432,
  436,
  410,
  434,
  416,
  411,
  264,
  368,
  383,
  309,
  438,
  457,
  352,
  376,
  401,
  274,
  275,
  4,
  421,
  428,
  262,
  294,
  327,
  358,
  433,
  416,
  367,
  289,
  455,
  439,
  462,
  370,
  326,
  2,
  326,
  370,
  305,
  460,
  455,
  254,
  449,
  448,
  255,
  261,
  446,
  253,
  450,
  449,
  252,
  451,
  450,
  256,
  452,
  451,
  341,
  453,
  452,
  413,
  464,
  463,
  441,
  413,
  414,
  258,
  442,
  441,
  257,
  443,
  442,
  259,
  444,
  443,
  260,
  445,
  444,
  467,
  342,
  445,
  459,
  458,
  250,
  289,
  392,
  290,
  290,
  328,
  460,
  376,
  433,
  435,
  250,
  290,
  392,
  411,
  416,
  433,
  341,
  463,
  464,
  453,
  464,
  465,
  357,
  465,
  412,
  343,
  412,
  399,
  360,
  363,
  440,
  437,
  399,
  456,
  420,
  456,
  363,
  401,
  435,
  288,
  372,
  383,
  353,
  339,
  255,
  249,
  448,
  261,
  255,
  133,
  243,
  190,
  133,
  155,
  112,
  33,
  246,
  247,
  33,
  130,
  25,
  398,
  384,
  286,
  362,
  398,
  414,
  362,
  463,
  341,
  263,
  359,
  467,
  263,
  249,
  255,
  466,
  467,
  260,
  75,
  60,
  166,
  238,
  239,
  79,
  162,
  127,
  139,
  72,
  11,
  37,
  121,
  232,
  120,
  73,
  72,
  39,
  114,
  128,
  47,
  233,
  232,
  128,
  103,
  104,
  67,
  152,
  175,
  148,
  173,
  157,
  155,
  119,
  118,
  101,
  74,
  73,
  40,
  107,
  9,
  108,
  49,
  48,
  131,
  32,
  194,
  211,
  184,
  74,
  185,
  191,
  80,
  183,
  185,
  40,
  186,
  119,
  230,
  118,
  210,
  202,
  214,
  84,
  83,
  17,
  77,
  76,
  146,
  161,
  160,
  30,
  190,
  56,
  173,
  182,
  106,
  194,
  138,
  135,
  192,
  129,
  203,
  98,
  54,
  21,
  68,
  5,
  51,
  4,
  145,
  144,
  23,
  90,
  77,
  91,
  207,
  205,
  187,
  83,
  201,
  18,
  181,
  91,
  182,
  180,
  90,
  181,
  16,
  85,
  17,
  205,
  206,
  36,
  176,
  148,
  140,
  165,
  92,
  39,
  245,
  193,
  244,
  27,
  159,
  28,
  30,
  247,
  161,
  174,
  236,
  196,
  103,
  54,
  104,
  55,
  193,
  8,
  111,
  117,
  31,
  221,
  189,
  55,
  240,
  98,
  99,
  142,
  126,
  100,
  219,
  166,
  218,
  112,
  155,
  26,
  198,
  209,
  131,
  169,
  135,
  150,
  114,
  47,
  217,
  224,
  223,
  53,
  220,
  45,
  134,
  32,
  211,
  140,
  109,
  67,
  108,
  146,
  43,
  91,
  231,
  230,
  120,
  113,
  226,
  247,
  105,
  63,
  52,
  241,
  238,
  242,
  124,
  46,
  156,
  95,
  78,
  96,
  70,
  46,
  63,
  116,
  143,
  227,
  116,
  123,
  111,
  1,
  44,
  19,
  3,
  236,
  51,
  207,
  216,
  205,
  26,
  154,
  22,
  165,
  39,
  167,
  199,
  200,
  208,
  101,
  36,
  100,
  43,
  57,
  202,
  242,
  20,
  99,
  56,
  28,
  157,
  124,
  35,
  113,
  29,
  160,
  27,
  211,
  204,
  210,
  124,
  113,
  46,
  106,
  43,
  204,
  96,
  62,
  77,
  227,
  137,
  116,
  73,
  41,
  72,
  36,
  203,
  142,
  235,
  64,
  240,
  48,
  49,
  64,
  42,
  41,
  74,
  214,
  212,
  207,
  183,
  42,
  184,
  210,
  169,
  211,
  140,
  170,
  176,
  104,
  105,
  69,
  193,
  122,
  168,
  50,
  123,
  187,
  89,
  96,
  90,
  66,
  65,
  107,
  179,
  89,
  180,
  119,
  101,
  120,
  68,
  63,
  104,
  234,
  93,
  227,
  16,
  15,
  85,
  209,
  129,
  49,
  15,
  14,
  86,
  107,
  55,
  9,
  120,
  100,
  121,
  153,
  145,
  22,
  178,
  88,
  179,
  197,
  6,
  196,
  89,
  88,
  96,
  135,
  138,
  136,
  138,
  215,
  172,
  218,
  115,
  219,
  41,
  42,
  81,
  5,
  195,
  51,
  57,
  43,
  61,
  208,
  171,
  199,
  41,
  81,
  38,
  224,
  53,
  225,
  24,
  144,
  110,
  105,
  52,
  66,
  118,
  229,
  117,
  227,
  34,
  234,
  66,
  107,
  69,
  10,
  109,
  151,
  219,
  48,
  235,
  183,
  62,
  191,
  142,
  129,
  126,
  116,
  111,
  143,
  7,
  163,
  246,
  118,
  117,
  50,
  223,
  222,
  52,
  94,
  19,
  141,
  222,
  221,
  65,
  196,
  3,
  197,
  45,
  220,
  44,
  156,
  70,
  139,
  188,
  122,
  245,
  139,
  71,
  162,
  145,
  153,
  159,
  149,
  170,
  150,
  122,
  188,
  196,
  206,
  216,
  92,
  163,
  144,
  161,
  164,
  2,
  167,
  242,
  141,
  241,
  0,
  164,
  37,
  11,
  72,
  12,
  144,
  145,
  160,
  12,
  38,
  13,
  70,
  63,
  71,
  31,
  226,
  111,
  157,
  158,
  154,
  36,
  101,
  205,
  203,
  206,
  165,
  126,
  209,
  217,
  98,
  165,
  97,
  237,
  220,
  218,
  237,
  239,
  241,
  210,
  214,
  169,
  140,
  171,
  32,
  241,
  125,
  237,
  179,
  86,
  178,
  180,
  85,
  179,
  181,
  84,
  180,
  182,
  83,
  181,
  194,
  201,
  182,
  177,
  137,
  132,
  184,
  76,
  183,
  185,
  61,
  184,
  186,
  57,
  185,
  216,
  212,
  186,
  192,
  214,
  187,
  139,
  34,
  156,
  218,
  79,
  237,
  147,
  123,
  177,
  45,
  44,
  4,
  208,
  201,
  32,
  98,
  64,
  129,
  192,
  213,
  138,
  235,
  59,
  219,
  141,
  242,
  97,
  97,
  2,
  141,
  240,
  75,
  235,
  229,
  24,
  228,
  31,
  25,
  226,
  230,
  23,
  229,
  231,
  22,
  230,
  232,
  26,
  231,
  233,
  112,
  232,
  244,
  189,
  243,
  189,
  221,
  190,
  222,
  28,
  221,
  223,
  27,
  222,
  224,
  29,
  223,
  225,
  30,
  224,
  113,
  247,
  225,
  99,
  60,
  240,
  213,
  147,
  215,
  60,
  20,
  166,
  192,
  187,
  213,
  243,
  112,
  244,
  244,
  233,
  245,
  245,
  128,
  188,
  188,
  114,
  174,
  134,
  131,
  220,
  174,
  217,
  236,
  236,
  198,
  134,
  215,
  177,
  58,
  156,
  143,
  124,
  25,
  110,
  7,
  31,
  228,
  25,
  264,
  356,
  368,
  0,
  11,
  267,
  451,
  452,
  349,
  267,
  302,
  269,
  350,
  357,
  277,
  350,
  452,
  357,
  299,
  333,
  297,
  396,
  175,
  377,
  381,
  384,
  382,
  280,
  347,
  330,
  269,
  303,
  270,
  151,
  9,
  337,
  344,
  278,
  360,
  424,
  418,
  431,
  270,
  304,
  409,
  272,
  310,
  407,
  322,
  270,
  410,
  449,
  450,
  347,
  432,
  422,
  434,
  18,
  313,
  17,
  291,
  306,
  375,
  259,
  387,
  260,
  424,
  335,
  418,
  434,
  364,
  416,
  391,
  423,
  327,
  301,
  251,
  298,
  275,
  281,
  4,
  254,
  373,
  253,
  375,
  307,
  321,
  280,
  425,
  411,
  200,
  421,
  18,
  335,
  321,
  406,
  321,
  320,
  405,
  314,
  315,
  17,
  423,
  426,
  266,
  396,
  377,
  369,
  270,
  322,
  269,
  413,
  417,
  464,
  385,
  386,
  258,
  248,
  456,
  419,
  298,
  284,
  333,
  168,
  417,
  8,
  448,
  346,
  261,
  417,
  413,
  285,
  326,
  327,
  328,
  277,
  355,
  329,
  309,
  392,
  438,
  381,
  382,
  256,
  279,
  429,
  360,
  365,
  364,
  379,
  355,
  277,
  437,
  282,
  443,
  283,
  281,
  275,
  363,
  395,
  431,
  369,
  299,
  297,
  337,
  335,
  273,
  321,
  348,
  450,
  349,
  359,
  446,
  467,
  283,
  293,
  282,
  250,
  458,
  462,
  300,
  276,
  383,
  292,
  308,
  325,
  283,
  276,
  293,
  264,
  372,
  447,
  346,
  352,
  340,
  354,
  274,
  19,
  363,
  456,
  281,
  426,
  436,
  425,
  380,
  381,
  252,
  267,
  269,
  393,
  421,
  200,
  428,
  371,
  266,
  329,
  432,
  287,
  422,
  290,
  250,
  328,
  385,
  258,
  384,
  446,
  265,
  342,
  386,
  387,
  257,
  422,
  424,
  430,
  445,
  342,
  276,
  422,
  273,
  424,
  306,
  292,
  307,
  352,
  366,
  345,
  268,
  271,
  302,
  358,
  423,
  371,
  327,
  294,
  460,
  331,
  279,
  294,
  303,
  271,
  304,
  436,
  432,
  427,
  304,
  272,
  408,
  395,
  394,
  431,
  378,
  395,
  400,
  296,
  334,
  299,
  6,
  351,
  168,
  376,
  352,
  411,
  307,
  325,
  320,
  285,
  295,
  336,
  320,
  319,
  404,
  329,
  330,
  349,
  334,
  293,
  333,
  366,
  323,
  447,
  316,
  15,
  315,
  331,
  358,
  279,
  317,
  14,
  316,
  8,
  285,
  9,
  277,
  329,
  350,
  253,
  374,
  252,
  319,
  318,
  403,
  351,
  6,
  419,
  324,
  318,
  325,
  397,
  367,
  365,
  288,
  435,
  397,
  278,
  344,
  439,
  310,
  272,
  311,
  248,
  195,
  281,
  375,
  273,
  291,
  175,
  396,
  199,
  312,
  311,
  268,
  276,
  283,
  445,
  390,
  373,
  339,
  295,
  282,
  296,
  448,
  449,
  346,
  356,
  264,
  454,
  337,
  336,
  299,
  337,
  338,
  151,
  294,
  278,
  455,
  308,
  292,
  415,
  429,
  358,
  355,
  265,
  340,
  372,
  388,
  390,
  466,
  352,
  346,
  280,
  295,
  442,
  282,
  354,
  19,
  370,
  285,
  441,
  295,
  195,
  248,
  197,
  457,
  440,
  274,
  301,
  300,
  368,
  417,
  351,
  465,
  251,
  301,
  389,
  385,
  380,
  386,
  394,
  395,
  379,
  399,
  412,
  419,
  410,
  436,
  322,
  387,
  373,
  388,
  326,
  2,
  393,
  354,
  370,
  461,
  393,
  164,
  267,
  268,
  302,
  12,
  386,
  374,
  387,
  312,
  268,
  13,
  298,
  293,
  301,
  265,
  446,
  340,
  380,
  385,
  381,
  280,
  330,
  425,
  322,
  426,
  391,
  420,
  429,
  437,
  393,
  391,
  326,
  344,
  440,
  438,
  458,
  459,
  461,
  364,
  434,
  394,
  428,
  396,
  262,
  274,
  354,
  457,
  317,
  316,
  402,
  316,
  315,
  403,
  315,
  314,
  404,
  314,
  313,
  405,
  313,
  421,
  406,
  323,
  366,
  361,
  292,
  306,
  407,
  306,
  291,
  408,
  291,
  287,
  409,
  287,
  432,
  410,
  427,
  434,
  411,
  372,
  264,
  383,
  459,
  309,
  457,
  366,
  352,
  401,
  1,
  274,
  4,
  418,
  421,
  262,
  331,
  294,
  358,
  435,
  433,
  367,
  392,
  289,
  439,
  328,
  462,
  326,
  94,
  2,
  370,
  289,
  305,
  455,
  339,
  254,
  448,
  359,
  255,
  446,
  254,
  253,
  449,
  253,
  252,
  450,
  252,
  256,
  451,
  256,
  341,
  452,
  414,
  413,
  463,
  286,
  441,
  414,
  286,
  258,
  441,
  258,
  257,
  442,
  257,
  259,
  443,
  259,
  260,
  444,
  260,
  467,
  445,
  309,
  459,
  250,
  305,
  289,
  290,
  305,
  290,
  460,
  401,
  376,
  435,
  309,
  250,
  392,
  376,
  411,
  433,
  453,
  341,
  464,
  357,
  453,
  465,
  343,
  357,
  412,
  437,
  343,
  399,
  344,
  360,
  440,
  420,
  437,
  456,
  360,
  420,
  363,
  361,
  401,
  288,
  265,
  372,
  353,
  390,
  339,
  249,
  339,
  448,
  255
];
var VTX68 = [
  127,
  234,
  132,
  58,
  172,
  150,
  149,
  148,
  152,
  377,
  378,
  379,
  397,
  288,
  361,
  454,
  356,
  70,
  63,
  105,
  66,
  107,
  336,
  296,
  334,
  293,
  300,
  168,
  6,
  195,
  4,
  98,
  97,
  2,
  326,
  327,
  33,
  160,
  158,
  133,
  153,
  144,
  362,
  385,
  387,
  263,
  373,
  380,
  57,
  40,
  37,
  0,
  267,
  270,
  287,
  321,
  314,
  17,
  84,
  91,
  78,
  81,
  13,
  311,
  308,
  402,
  14,
  178
];
var VTX33 = [33, 133, 362, 263, 1, 62, 308, 159, 145, 386, 374, 6, 102, 331, 2, 13, 14, 70, 105, 107, 336, 334, 300, 54, 10, 284, 50, 280, 234, 454, 58, 288, 152];
var VTX7 = [33, 133, 362, 263, 1, 78, 308];
var UV68 = VTX68.map((x2) => UV468[x2]);
var UV33 = VTX33.map((x2) => UV468[x2]);
var UV7 = VTX7.map((x2) => UV468[x2]);
var createBox = (startEndTensor) => ({ startPoint: slice(startEndTensor, [0, 0], [-1, 2]), endPoint: slice(startEndTensor, [0, 2], [-1, 2]) });
var getBoxSize = (box5) => [Math.abs(box5.endPoint[0] - box5.startPoint[0]), Math.abs(box5.endPoint[1] - box5.startPoint[1])];
var getBoxCenter = (box5) => [box5.startPoint[0] + (box5.endPoint[0] - box5.startPoint[0]) / 2, box5.startPoint[1] + (box5.endPoint[1] - box5.startPoint[1]) / 2];
var getClampedBox = (box5, input2) => box5 ? [
  Math.trunc(Math.max(0, box5.startPoint[0])),
  Math.trunc(Math.max(0, box5.startPoint[1])),
  Math.trunc(Math.min(input2.shape[2] || 0, box5.endPoint[0]) - Math.max(0, box5.startPoint[0])),
  Math.trunc(Math.min(input2.shape[1] || 0, box5.endPoint[1]) - Math.max(0, box5.startPoint[1]))
] : [0, 0, 0, 0];
var getRawBox = (box5, input2) => box5 ? [
  box5.startPoint[0] / (input2.shape[2] || 0),
  box5.startPoint[1] / (input2.shape[1] || 0),
  (box5.endPoint[0] - box5.startPoint[0]) / (input2.shape[2] || 0),
  (box5.endPoint[1] - box5.startPoint[1]) / (input2.shape[1] || 0)
] : [0, 0, 0, 0];
var scaleBoxCoordinates = (box5, factor) => {
  const startPoint = [box5.startPoint[0] * factor[0], box5.startPoint[1] * factor[1]];
  const endPoint = [box5.endPoint[0] * factor[0], box5.endPoint[1] * factor[1]];
  return { startPoint, endPoint };
};
var cutBoxFromImageAndResize = (box5, image7, cropSize) => {
  const h2 = image7.shape[1];
  const w2 = image7.shape[2];
  return image.cropAndResize(image7, [[box5.startPoint[1] / h2, box5.startPoint[0] / w2, box5.endPoint[1] / h2, box5.endPoint[0] / w2]], [0], cropSize);
};
var enlargeBox = (box5, factor = 1.5) => {
  const center = getBoxCenter(box5);
  const size2 = getBoxSize(box5);
  const halfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
  return { startPoint: [center[0] - halfSize[0], center[1] - halfSize[1]], endPoint: [center[0] + halfSize[0], center[1] + halfSize[1]], landmarks: box5.landmarks };
};
var squarifyBox = (box5) => {
  const centers = getBoxCenter(box5);
  const size2 = getBoxSize(box5);
  const halfSize = Math.max(...size2) / 2;
  return { startPoint: [Math.round(centers[0] - halfSize), Math.round(centers[1] - halfSize)], endPoint: [Math.round(centers[0] + halfSize), Math.round(centers[1] + halfSize)], landmarks: box5.landmarks };
};
var calculateLandmarksBoundingBox = (landmarks) => {
  const xs = landmarks.map((d2) => d2[0]);
  const ys = landmarks.map((d2) => d2[1]);
  return { startPoint: [Math.min(...xs), Math.min(...ys)], endPoint: [Math.max(...xs), Math.max(...ys)], landmarks };
};
var IDENTITY_MATRIX = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
var normalizeRadians = (angle2) => angle2 - 2 * Math.PI * Math.floor((angle2 + Math.PI) / (2 * Math.PI));
var computeRotation = (point1, point2) => normalizeRadians(Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]));
var buildTranslationMatrix = (x2, y2) => [[1, 0, x2], [0, 1, y2], [0, 0, 1]];
var dot4 = (v1, v2) => {
  let product = 0;
  for (let i2 = 0; i2 < v1.length; i2++)
    product += v1[i2] * v2[i2];
  return product;
};
var getColumnFrom2DArr = (arr, columnIndex) => {
  const column = [];
  for (let i2 = 0; i2 < arr.length; i2++)
    column.push(arr[i2][columnIndex]);
  return column;
};
var multiplyTransformMatrices = (mat1, mat2) => {
  const product = [];
  const size2 = mat1.length;
  for (let row = 0; row < size2; row++) {
    product.push([]);
    for (let col = 0; col < size2; col++)
      product[row].push(dot4(mat1[row], getColumnFrom2DArr(mat2, col)));
  }
  return product;
};
var buildRotationMatrix = (rotation, center) => {
  const cosA = Math.cos(rotation);
  const sinA = Math.sin(rotation);
  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
  const translationMatrix = buildTranslationMatrix(center[0], center[1]);
  const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);
  const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);
  return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);
};
var invertTransformMatrix = (matrix) => {
  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
  const translationComponent = [matrix[0][2], matrix[1][2]];
  const invertedTranslation = [-dot4(rotationComponent[0], translationComponent), -dot4(rotationComponent[1], translationComponent)];
  return [rotationComponent[0].concat(invertedTranslation[0]), rotationComponent[1].concat(invertedTranslation[1]), [0, 0, 1]];
};
var rotatePoint = (homogeneousCoordinate, rotationMatrix) => [dot4(homogeneousCoordinate, rotationMatrix[0]), dot4(homogeneousCoordinate, rotationMatrix[1])];
function generateAnchors(inputSize8) {
  const spec = { strides: [inputSize8 / 16, inputSize8 / 8], anchors: [2, 6] };
  const anchors4 = [];
  for (let i2 = 0; i2 < spec.strides.length; i2++) {
    const stride = spec.strides[i2];
    const gridRows = Math.floor((inputSize8 + stride - 1) / stride);
    const gridCols = Math.floor((inputSize8 + stride - 1) / stride);
    const anchorsNum = spec.anchors[i2];
    for (let gridY = 0; gridY < gridRows; gridY++) {
      const anchorY = stride * (gridY + 0.5);
      for (let gridX = 0; gridX < gridCols; gridX++) {
        const anchorX = stride * (gridX + 0.5);
        for (let n2 = 0; n2 < anchorsNum; n2++)
          anchors4.push([anchorX, anchorY]);
      }
    }
  }
  return anchors4;
}
function transformRawCoords(rawCoords, box5, angle2, rotationMatrix, inputSize8) {
  const boxSize = getBoxSize({ startPoint: box5.startPoint, endPoint: box5.endPoint });
  const coordsScaled = rawCoords.map((coord) => [
    boxSize[0] / inputSize8 * (coord[0] - inputSize8 / 2),
    boxSize[1] / inputSize8 * (coord[1] - inputSize8 / 2),
    coord[2] || 0
  ]);
  const coordsRotationMatrix = angle2 !== 0 ? buildRotationMatrix(angle2, [0, 0]) : IDENTITY_MATRIX;
  const coordsRotated = angle2 !== 0 ? coordsScaled.map((coord) => [...rotatePoint(coord, coordsRotationMatrix), coord[2]]) : coordsScaled;
  const inverseRotationMatrix = angle2 !== 0 ? invertTransformMatrix(rotationMatrix) : IDENTITY_MATRIX;
  const boxCenter = [...getBoxCenter({ startPoint: box5.startPoint, endPoint: box5.endPoint }), 1];
  return coordsRotated.map((coord) => [
    Math.round(coord[0] + dot4(boxCenter, inverseRotationMatrix[0])),
    Math.round(coord[1] + dot4(boxCenter, inverseRotationMatrix[1])),
    Math.round(coord[2] || 0)
  ]);
}
function correctFaceRotation(box5, input2, inputSize8) {
  const symmetryLine = box5.landmarks.length >= meshLandmarks.count ? meshLandmarks.symmetryLine : blazeFaceLandmarks.symmetryLine;
  const angle2 = computeRotation(box5.landmarks[symmetryLine[0]], box5.landmarks[symmetryLine[1]]);
  const faceCenter = getBoxCenter({ startPoint: box5.startPoint, endPoint: box5.endPoint });
  const faceCenterNormalized = [faceCenter[0] / input2.shape[2], faceCenter[1] / input2.shape[1]];
  const rotated = image.rotateWithOffset(input2, angle2, 0, faceCenterNormalized);
  const rotationMatrix = buildRotationMatrix(-angle2, faceCenter);
  const cut = cutBoxFromImageAndResize({ startPoint: box5.startPoint, endPoint: box5.endPoint }, rotated, [inputSize8, inputSize8]);
  const face5 = div(cut, 255);
  dispose(cut);
  dispose(rotated);
  return [angle2, rotationMatrix, face5];
}
var keypointsCount = 6;
var model2;
var anchorsData = [];
var anchors = null;
var inputSize = 0;
var size = () => inputSize;
async function load(config3) {
  var _a;
  if (env2.initial)
    model2 = null;
  if (!model2) {
    model2 = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.face.detector) == null ? void 0 : _a.modelPath) || ""));
    if (!model2 || !model2["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model2["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model2["modelUrl"]);
  inputSize = model2.inputs[0].shape ? model2.inputs[0].shape[2] : 0;
  if (inputSize === -1)
    inputSize = 64;
  anchorsData = generateAnchors(inputSize);
  anchors = tensor2d(anchorsData);
  return model2;
}
function decodeBounds(boxOutputs) {
  const boxStarts = slice(boxOutputs, [0, 1], [-1, 2]);
  const centers = add2(boxStarts, anchors);
  const boxSizes = slice(boxOutputs, [0, 3], [-1, 2]);
  const boxSizesNormalized = div(boxSizes, inputSize);
  const centersNormalized = div(centers, inputSize);
  const halfBoxSize = div(boxSizesNormalized, 2);
  const starts = sub(centersNormalized, halfBoxSize);
  const ends = add2(centersNormalized, halfBoxSize);
  const startNormalized = mul(starts, inputSize);
  const endNormalized = mul(ends, inputSize);
  const concatAxis = 1;
  return concat2d([startNormalized, endNormalized], concatAxis);
}
async function getBoxes(inputImage, config3) {
  var _a, _b, _c, _d;
  if (!inputImage || inputImage["isDisposedInternal"] || inputImage.shape.length !== 4 || inputImage.shape[1] < 1 || inputImage.shape[2] < 1)
    return { boxes: [] };
  const [batch, boxes, scores] = tidy(() => {
    const resizedImage = image.resizeBilinear(inputImage, [inputSize, inputSize]);
    const normalizedImage = sub(div(resizedImage, 127.5), 0.5);
    const res2 = model2 == null ? void 0 : model2.execute(normalizedImage);
    let batchOut;
    if (Array.isArray(res2)) {
      const sorted = res2.sort((a6, b2) => a6.size - b2.size);
      const concat384 = concat([sorted[0], sorted[2]], 2);
      const concat512 = concat([sorted[1], sorted[3]], 2);
      const concat6 = concat([concat512, concat384], 1);
      batchOut = squeeze(concat6, 0);
    } else {
      batchOut = squeeze(res2);
    }
    const boxesOut = decodeBounds(batchOut);
    const logits = slice(batchOut, [0, 0], [-1, 1]);
    const scoresOut = squeeze(sigmoid(logits));
    return [batchOut, boxesOut, scoresOut];
  });
  const nmsTensor = await image.nonMaxSuppressionAsync(boxes, scores, ((_a = config3.face.detector) == null ? void 0 : _a.maxDetected) || 0, ((_b = config3.face.detector) == null ? void 0 : _b.iouThreshold) || 0, ((_c = config3.face.detector) == null ? void 0 : _c.minConfidence) || 0);
  const nms = await nmsTensor.array();
  dispose(nmsTensor);
  const annotatedBoxes = [];
  const scoresData = await scores.data();
  for (let i2 = 0; i2 < nms.length; i2++) {
    const confidence = scoresData[nms[i2]];
    if (confidence > (((_d = config3.face.detector) == null ? void 0 : _d.minConfidence) || 0)) {
      const boundingBox = slice(boxes, [nms[i2], 0], [1, -1]);
      const landmarks = tidy(() => reshape(squeeze(slice(batch, [nms[i2], keypointsCount - 1], [1, -1])), [keypointsCount, -1]));
      annotatedBoxes.push({ box: createBox(boundingBox), landmarks, anchor: anchorsData[nms[i2]], confidence });
      dispose(boundingBox);
    }
  }
  dispose(batch);
  dispose(boxes);
  dispose(scores);
  return {
    boxes: annotatedBoxes,
    scaleFactor: [inputImage.shape[2] / inputSize, inputImage.shape[1] / inputSize]
  };
}
var model3;
var inputSize2 = 0;
var irisEnlarge = 2.3;
var leftOutline = meshAnnotations["leftEyeLower0"];
var rightOutline = meshAnnotations["rightEyeLower0"];
var eyeLandmarks = {
  leftBounds: [leftOutline[0], leftOutline[leftOutline.length - 1]],
  rightBounds: [rightOutline[0], rightOutline[rightOutline.length - 1]]
};
var irisLandmarks = {
  upperCenter: 3,
  lowerCenter: 4,
  index: 71,
  numCoordinates: 76
};
async function load2(config3) {
  var _a;
  if (env2.initial)
    model3 = null;
  if (!model3) {
    model3 = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.face.iris) == null ? void 0 : _a.modelPath) || ""));
    if (!model3 || !model3["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model3["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model3["modelUrl"]);
  inputSize2 = model3.inputs[0].shape ? model3.inputs[0].shape[2] : 0;
  if (inputSize2 === -1)
    inputSize2 = 64;
  return model3;
}
function replaceRawCoordinates(rawCoords, newCoords, prefix, keys) {
  for (let i2 = 0; i2 < MESH_TO_IRIS_INDICES_MAP.length; i2++) {
    const { key, indices } = MESH_TO_IRIS_INDICES_MAP[i2];
    const originalIndices = meshAnnotations[`${prefix}${key}`];
    if (!keys || keys.includes(key)) {
      for (let j2 = 0; j2 < indices.length; j2++) {
        const index = indices[j2];
        rawCoords[originalIndices[j2]] = [
          newCoords[index][0],
          newCoords[index][1],
          (newCoords[index][2] + rawCoords[originalIndices[j2]][2]) / 2
        ];
      }
    }
  }
}
var getLeftToRightEyeDepthDifference = (rawCoords) => {
  const leftEyeZ = rawCoords[eyeLandmarks.leftBounds[0]][2];
  const rightEyeZ = rawCoords[eyeLandmarks.rightBounds[0]][2];
  return leftEyeZ - rightEyeZ;
};
var getEyeBox = (rawCoords, face5, eyeInnerCornerIndex, eyeOuterCornerIndex, flip = false, meshSize) => {
  const box5 = squarifyBox(enlargeBox(calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), irisEnlarge));
  const boxSize = getBoxSize(box5);
  let crop2 = image.cropAndResize(face5, [[
    box5.startPoint[1] / meshSize,
    box5.startPoint[0] / meshSize,
    box5.endPoint[1] / meshSize,
    box5.endPoint[0] / meshSize
  ]], [0], [inputSize2, inputSize2]);
  if (flip && env2.kernels.includes("flipleftright")) {
    const flipped = image.flipLeftRight(crop2);
    dispose(crop2);
    crop2 = flipped;
  }
  return { box: box5, boxSize, crop: crop2 };
};
var getEyeCoords = (eyeData, eyeBox, eyeBoxSize, flip = false) => {
  const eyeRawCoords = [];
  for (let i2 = 0; i2 < irisLandmarks.numCoordinates; i2++) {
    const x2 = eyeData[i2 * 3];
    const y2 = eyeData[i2 * 3 + 1];
    const z2 = eyeData[i2 * 3 + 2];
    eyeRawCoords.push([
      (flip ? 1 - x2 / inputSize2 : x2 / inputSize2) * eyeBoxSize[0] + eyeBox.startPoint[0],
      y2 / inputSize2 * eyeBoxSize[1] + eyeBox.startPoint[1],
      z2
    ]);
  }
  return { rawCoords: eyeRawCoords, iris: eyeRawCoords.slice(irisLandmarks.index) };
};
var getAdjustedIrisCoords = (rawCoords, irisCoords, direction) => {
  const upperCenterZ = rawCoords[meshAnnotations[`${direction}EyeUpper0`][irisLandmarks.upperCenter]][2];
  const lowerCenterZ = rawCoords[meshAnnotations[`${direction}EyeLower0`][irisLandmarks.lowerCenter]][2];
  const averageZ = (upperCenterZ + lowerCenterZ) / 2;
  return irisCoords.map((coord, i2) => {
    let z2 = averageZ;
    if (i2 === 2) {
      z2 = upperCenterZ;
    } else if (i2 === 4) {
      z2 = lowerCenterZ;
    }
    return [coord[0], coord[1], z2];
  });
};
async function augmentIris(rawCoords, face5, config3, meshSize) {
  if (!model3) {
    if (config3.debug)
      log("face mesh iris detection requested, but model is not loaded");
    return rawCoords;
  }
  const { box: leftEyeBox, boxSize: leftEyeBoxSize, crop: leftEyeCrop } = getEyeBox(rawCoords, face5, eyeLandmarks.leftBounds[0], eyeLandmarks.leftBounds[1], true, meshSize);
  const { box: rightEyeBox, boxSize: rightEyeBoxSize, crop: rightEyeCrop } = getEyeBox(rawCoords, face5, eyeLandmarks.rightBounds[0], eyeLandmarks.rightBounds[1], true, meshSize);
  const combined = concat([leftEyeCrop, rightEyeCrop]);
  dispose(leftEyeCrop);
  dispose(rightEyeCrop);
  const eyePredictions = model3.predict(combined);
  dispose(combined);
  const eyePredictionsData = await eyePredictions.data();
  dispose(eyePredictions);
  const leftEyeData = eyePredictionsData.slice(0, irisLandmarks.numCoordinates * 3);
  const { rawCoords: leftEyeRawCoords, iris: leftIrisRawCoords } = getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true);
  const rightEyeData = eyePredictionsData.slice(irisLandmarks.numCoordinates * 3);
  const { rawCoords: rightEyeRawCoords, iris: rightIrisRawCoords } = getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize);
  const leftToRightEyeDepthDifference = getLeftToRightEyeDepthDifference(rawCoords);
  if (Math.abs(leftToRightEyeDepthDifference) < 30) {
    replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left", null);
    replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right", null);
  } else if (leftToRightEyeDepthDifference < 1) {
    replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left", ["EyeUpper0", "EyeLower0"]);
  } else {
    replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right", ["EyeUpper0", "EyeLower0"]);
  }
  const adjustedLeftIrisCoords = getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, "left");
  const adjustedRightIrisCoords = getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, "right");
  const newCoords = rawCoords.concat(adjustedLeftIrisCoords).concat(adjustedRightIrisCoords);
  return newCoords;
}
var boxCache = [];
var model4 = null;
var inputSize3 = 0;
var skipped = Number.MAX_SAFE_INTEGER;
var detectedFaces = 0;
async function predict(input2, config3) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
  if (!config3.skipFrame || (detectedFaces !== ((_a = config3.face.detector) == null ? void 0 : _a.maxDetected) || !((_b = config3.face.mesh) == null ? void 0 : _b.enabled)) && skipped > (((_c = config3.face.detector) == null ? void 0 : _c.skipFrames) || 0)) {
    const newBoxes2 = await getBoxes(input2, config3);
    boxCache = [];
    for (const possible of newBoxes2.boxes) {
      const startPoint = await possible.box.startPoint.data();
      const endPoint = await possible.box.endPoint.data();
      const landmarks = await possible.landmarks.array();
      boxCache.push({ startPoint, endPoint, landmarks, confidence: possible.confidence });
    }
    newBoxes2.boxes.forEach((prediction) => dispose([prediction.box.startPoint, prediction.box.endPoint, prediction.landmarks]));
    for (let i2 = 0; i2 < boxCache.length; i2++) {
      const scaledBox = scaleBoxCoordinates({ startPoint: boxCache[i2].startPoint, endPoint: boxCache[i2].endPoint }, newBoxes2.scaleFactor);
      const enlargedBox = enlargeBox(scaledBox);
      const squarifiedBox = squarifyBox(enlargedBox);
      boxCache[i2] = { ...squarifiedBox, confidence: boxCache[i2].confidence, landmarks: boxCache[i2].landmarks };
    }
    skipped = 0;
  } else {
    skipped++;
  }
  const faces = [];
  const newBoxes = [];
  let id = 0;
  for (let box5 of boxCache) {
    let angle2 = 0;
    let rotationMatrix;
    const face5 = {
      id: id++,
      mesh: [],
      meshRaw: [],
      box: [0, 0, 0, 0],
      boxRaw: [0, 0, 0, 0],
      score: 0,
      boxScore: 0,
      faceScore: 0,
      annotations: {}
    };
    if (((_d = config3.face.detector) == null ? void 0 : _d.rotation) && ((_e2 = config3.face.mesh) == null ? void 0 : _e2.enabled) && env2.kernels.includes("rotatewithoffset")) {
      [angle2, rotationMatrix, face5.tensor] = correctFaceRotation(box5, input2, inputSize3);
    } else {
      rotationMatrix = IDENTITY_MATRIX;
      const cut = cutBoxFromImageAndResize({ startPoint: box5.startPoint, endPoint: box5.endPoint }, input2, ((_f = config3.face.mesh) == null ? void 0 : _f.enabled) ? [inputSize3, inputSize3] : [size(), size()]);
      face5.tensor = div(cut, 255);
      dispose(cut);
    }
    face5.boxScore = Math.round(100 * box5.confidence) / 100;
    if (!((_g = config3.face.mesh) == null ? void 0 : _g.enabled)) {
      face5.box = getClampedBox(box5, input2);
      face5.boxRaw = getRawBox(box5, input2);
      face5.score = Math.round(100 * box5.confidence || 0) / 100;
      face5.mesh = box5.landmarks.map((pt) => [
        (box5.startPoint[0] + box5.endPoint[0]) / 2 + (box5.endPoint[0] + box5.startPoint[0]) * pt[0] / size(),
        (box5.startPoint[1] + box5.endPoint[1]) / 2 + (box5.endPoint[1] + box5.startPoint[1]) * pt[1] / size()
      ]);
      face5.meshRaw = face5.mesh.map((pt) => [pt[0] / (input2.shape[2] || 0), pt[1] / (input2.shape[1] || 0), (pt[2] || 0) / inputSize3]);
      for (const key of Object.keys(blazeFaceLandmarks))
        face5.annotations[key] = [face5.mesh[blazeFaceLandmarks[key]]];
    } else if (!model4) {
      if (config3.debug)
        log("face mesh detection requested, but model is not loaded");
    } else {
      const [contours, confidence, contourCoords] = model4.execute(face5.tensor);
      dispose(contours);
      const faceConfidence = (await confidence.data())[0];
      dispose(confidence);
      const coordsReshaped = reshape(contourCoords, [-1, 3]);
      let rawCoords = await coordsReshaped.array();
      dispose(contourCoords);
      dispose(coordsReshaped);
      if (faceConfidence < (((_h = config3.face.detector) == null ? void 0 : _h.minConfidence) || 1)) {
        box5.confidence = faceConfidence;
      } else {
        if ((_i = config3.face.iris) == null ? void 0 : _i.enabled)
          rawCoords = await augmentIris(rawCoords, face5.tensor, config3, inputSize3);
        face5.mesh = transformRawCoords(rawCoords, box5, angle2, rotationMatrix, inputSize3);
        face5.meshRaw = face5.mesh.map((pt) => [pt[0] / (input2.shape[2] || 0), pt[1] / (input2.shape[1] || 0), (pt[2] || 0) / inputSize3]);
        box5 = { ...enlargeBox(calculateLandmarksBoundingBox(face5.mesh), 1.5), confidence: box5.confidence };
        for (const key of Object.keys(meshAnnotations))
          face5.annotations[key] = meshAnnotations[key].map((index) => face5.mesh[index]);
        if (((_j = config3.face.detector) == null ? void 0 : _j.rotation) && config3.face.mesh.enabled && ((_k = config3.face.description) == null ? void 0 : _k.enabled) && env2.kernels.includes("rotatewithoffset")) {
          dispose(face5.tensor);
          [angle2, rotationMatrix, face5.tensor] = correctFaceRotation(box5, input2, inputSize3);
        }
        face5.box = getClampedBox(box5, input2);
        face5.boxRaw = getRawBox(box5, input2);
        face5.score = Math.round(100 * faceConfidence || 100 * box5.confidence || 0) / 100;
        face5.faceScore = Math.round(100 * faceConfidence) / 100;
        box5 = { ...squarifyBox(box5), confidence: box5.confidence, faceConfidence };
      }
    }
    faces.push(face5);
    newBoxes.push(box5);
  }
  if ((_l = config3.face.mesh) == null ? void 0 : _l.enabled)
    boxCache = newBoxes.filter((a6) => {
      var _a2;
      return a6.confidence > (((_a2 = config3.face.detector) == null ? void 0 : _a2.minConfidence) || 0);
    });
  detectedFaces = faces.length;
  return faces;
}
async function load3(config3) {
  var _a;
  if (env2.initial)
    model4 = null;
  if (!model4) {
    model4 = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.face.mesh) == null ? void 0 : _a.modelPath) || ""));
    if (!model4 || !model4["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model4["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model4["modelUrl"]);
  inputSize3 = model4.inputs[0].shape ? model4.inputs[0].shape[2] : 0;
  if (inputSize3 === -1)
    inputSize3 = 64;
  return model4;
}
var triangulation = TRI468;
var uvmap = UV468;
var model5;
var last = [];
var lastCount = 0;
var skipped2 = Number.MAX_SAFE_INTEGER;
async function load4(config3) {
  var _a, _b;
  const modelUrl = join(config3.modelBasePath, ((_a = config3.face.description) == null ? void 0 : _a.modelPath) || "");
  if (env2.initial)
    model5 = null;
  if (!model5) {
    model5 = await loadGraphModel(modelUrl);
    if (!model5)
      log("load model failed:", ((_b = config3.face.description) == null ? void 0 : _b.modelPath) || "");
    else if (config3.debug)
      log("load model:", modelUrl);
  } else if (config3.debug)
    log("cached model:", modelUrl);
  return model5;
}
function enhance(input2) {
  const image7 = tidy(() => {
    const tensor2 = input2.image || input2.tensor || input2;
    if (!(tensor2 instanceof Tensor))
      return null;
    const box5 = [[0.05, 0.15, 0.85, 0.85]];
    if (!(model5 == null ? void 0 : model5.inputs[0].shape))
      return null;
    const crop2 = tensor2.shape.length === 3 ? image.cropAndResize(expandDims(tensor2, 0), box5, [0], [model5.inputs[0].shape[2], model5.inputs[0].shape[1]]) : image.cropAndResize(tensor2, box5, [0], [model5.inputs[0].shape[2], model5.inputs[0].shape[1]]);
    const norm2 = mul(crop2, 255);
    return norm2;
  });
  return image7;
}
async function predict2(image7, config3, idx, count3) {
  var _a, _b, _c;
  if (!model5)
    return null;
  if (skipped2 < (((_a = config3.face.description) == null ? void 0 : _a.skipFrames) || 0) && config3.skipFrame && lastCount === count3 && ((_b = last[idx]) == null ? void 0 : _b.age) && ((_c = last[idx]) == null ? void 0 : _c.age) > 0) {
    skipped2++;
    return last[idx];
  }
  skipped2 = 0;
  return new Promise(async (resolve) => {
    var _a2, _b2;
    const enhanced = enhance(image7);
    let resT;
    const obj = {
      age: 0,
      gender: "unknown",
      genderScore: 0,
      descriptor: []
    };
    if ((_a2 = config3.face.description) == null ? void 0 : _a2.enabled)
      resT = await (model5 == null ? void 0 : model5.predict(enhanced));
    dispose(enhanced);
    if (resT) {
      const gender = await resT.find((t2) => t2.shape[1] === 1).data();
      const confidence = Math.trunc(200 * Math.abs(gender[0] - 0.5)) / 100;
      if (confidence > (((_b2 = config3.face.description) == null ? void 0 : _b2.minConfidence) || 0)) {
        obj.gender = gender[0] <= 0.5 ? "female" : "male";
        obj.genderScore = Math.min(0.99, confidence);
      }
      const argmax2 = argMax(resT.find((t2) => t2.shape[1] === 100), 1);
      const age = (await argmax2.data())[0];
      dispose(argmax2);
      const all6 = await resT.find((t2) => t2.shape[1] === 100).data();
      obj.age = Math.round(all6[age - 1] > all6[age + 1] ? 10 * age - 100 * all6[age - 1] : 10 * age + 100 * all6[age + 1]) / 10;
      const desc = resT.find((t2) => t2.shape[1] === 1024);
      const descriptor = await desc.data();
      obj.descriptor = [...descriptor];
      resT.forEach((t2) => dispose(t2));
    }
    last[idx] = obj;
    lastCount = count3;
    resolve(obj);
  });
}
var annotations = ["angry", "disgust", "fear", "happy", "sad", "surprise", "neutral"];
var model6;
var last2 = [];
var lastCount2 = 0;
var skipped3 = Number.MAX_SAFE_INTEGER;
var rgb = [0.2989, 0.587, 0.114];
async function load5(config3) {
  var _a;
  if (env2.initial)
    model6 = null;
  if (!model6) {
    model6 = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.face.emotion) == null ? void 0 : _a.modelPath) || ""));
    if (!model6 || !model6["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model6["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model6["modelUrl"]);
  return model6;
}
async function predict3(image7, config3, idx, count3) {
  var _a;
  if (!model6)
    return null;
  if (skipped3 < (((_a = config3.face.emotion) == null ? void 0 : _a.skipFrames) || 0) && config3.skipFrame && lastCount2 === count3 && last2[idx] && last2[idx].length > 0) {
    skipped3++;
    return last2[idx];
  }
  skipped3 = 0;
  return new Promise(async (resolve) => {
    var _a2, _b;
    const resize = image.resizeBilinear(image7, [(model6 == null ? void 0 : model6.inputs[0].shape) ? model6.inputs[0].shape[2] : 0, (model6 == null ? void 0 : model6.inputs[0].shape) ? model6.inputs[0].shape[1] : 0], false);
    const [red, green, blue] = split(resize, 3, 3);
    dispose(resize);
    const redNorm = mul(red, rgb[0]);
    const greenNorm = mul(green, rgb[1]);
    const blueNorm = mul(blue, rgb[2]);
    dispose(red);
    dispose(green);
    dispose(blue);
    const grayscale = addN([redNorm, greenNorm, blueNorm]);
    dispose(redNorm);
    dispose(greenNorm);
    dispose(blueNorm);
    const normalize = tidy(() => mul(sub(grayscale, 0.5), 2));
    dispose(grayscale);
    const obj = [];
    if ((_a2 = config3.face.emotion) == null ? void 0 : _a2.enabled) {
      const emotionT = await (model6 == null ? void 0 : model6.predict(normalize));
      const data = await emotionT.data();
      dispose(emotionT);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data[i2] > (((_b = config3.face.emotion) == null ? void 0 : _b.minConfidence) || 0))
          obj.push({ score: Math.min(0.99, Math.trunc(100 * data[i2]) / 100), emotion: annotations[i2] });
      }
      obj.sort((a6, b2) => b2.score - a6.score);
    }
    dispose(normalize);
    last2[idx] = obj;
    lastCount2 = count3;
    resolve(obj);
  });
}
var partNames = [
  "nose",
  "leftEye",
  "rightEye",
  "leftEar",
  "rightEar",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle"
];
var count2 = partNames.length;
var partIds = partNames.reduce((result, jointName, i2) => {
  result[jointName] = i2;
  return result;
}, {});
var connectedPartNames = [
  ["leftHip", "leftShoulder"],
  ["leftElbow", "leftShoulder"],
  ["leftElbow", "leftWrist"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["rightHip", "rightShoulder"],
  ["rightElbow", "rightShoulder"],
  ["rightElbow", "rightWrist"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"],
  ["leftShoulder", "rightShoulder"],
  ["leftHip", "rightHip"]
];
var connectedPartIndices = connectedPartNames.map(([jointNameA, jointNameB]) => [partIds[jointNameA], partIds[jointNameB]]);
var poseChain = [
  ["nose", "leftEye"],
  ["leftEye", "leftEar"],
  ["nose", "rightEye"],
  ["rightEye", "rightEar"],
  ["nose", "leftShoulder"],
  ["leftShoulder", "leftElbow"],
  ["leftElbow", "leftWrist"],
  ["leftShoulder", "leftHip"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["nose", "rightShoulder"],
  ["rightShoulder", "rightElbow"],
  ["rightElbow", "rightWrist"],
  ["rightShoulder", "rightHip"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"]
];
function getBoundingBox(keypoints2) {
  const coord = keypoints2.reduce(({ maxX, maxY, minX, minY }, { position: { x: x2, y: y2 } }) => ({
    maxX: Math.max(maxX, x2),
    maxY: Math.max(maxY, y2),
    minX: Math.min(minX, x2),
    minY: Math.min(minY, y2)
  }), {
    maxX: Number.NEGATIVE_INFINITY,
    maxY: Number.NEGATIVE_INFINITY,
    minX: Number.POSITIVE_INFINITY,
    minY: Number.POSITIVE_INFINITY
  });
  return [coord.minX, coord.minY, coord.maxX - coord.minX, coord.maxY - coord.minY];
}
function scalePoses(poses, [height, width], [inputResolutionHeight, inputResolutionWidth]) {
  const scaleY = height / inputResolutionHeight;
  const scaleX = width / inputResolutionWidth;
  const scalePose = (pose, i2) => ({
    id: i2,
    score: pose.score,
    boxRaw: [pose.box[0] / inputResolutionWidth, pose.box[1] / inputResolutionHeight, pose.box[2] / inputResolutionWidth, pose.box[3] / inputResolutionHeight],
    box: [Math.trunc(pose.box[0] * scaleX), Math.trunc(pose.box[1] * scaleY), Math.trunc(pose.box[2] * scaleX), Math.trunc(pose.box[3] * scaleY)],
    keypoints: pose.keypoints.map(({ score, part, position }) => ({
      score,
      part,
      position: [Math.trunc(position.x * scaleX), Math.trunc(position.y * scaleY)],
      positionRaw: [position.x / inputResolutionHeight, position.y / inputResolutionHeight]
    }))
  });
  const scaledPoses = poses.map((pose, i2) => scalePose(pose, i2));
  return scaledPoses;
}
var MaxHeap = class {
  constructor(maxSize2, getElementValue) {
    __publicField(this, "priorityQueue");
    __publicField(this, "numberOfElements");
    __publicField(this, "getElementValue");
    this.priorityQueue = new Array(maxSize2);
    this.numberOfElements = -1;
    this.getElementValue = getElementValue;
  }
  enqueue(x2) {
    this.priorityQueue[++this.numberOfElements] = x2;
    this.swim(this.numberOfElements);
  }
  dequeue() {
    const max7 = this.priorityQueue[0];
    this.exchange(0, this.numberOfElements--);
    this.sink(0);
    this.priorityQueue[this.numberOfElements + 1] = null;
    return max7;
  }
  empty() {
    return this.numberOfElements === -1;
  }
  size() {
    return this.numberOfElements + 1;
  }
  all() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }
  max() {
    return this.priorityQueue[0];
  }
  swim(k3) {
    while (k3 > 0 && this.less(Math.floor(k3 / 2), k3)) {
      this.exchange(k3, Math.floor(k3 / 2));
      k3 = Math.floor(k3 / 2);
    }
  }
  sink(k3) {
    while (2 * k3 <= this.numberOfElements) {
      let j2 = 2 * k3;
      if (j2 < this.numberOfElements && this.less(j2, j2 + 1))
        j2++;
      if (!this.less(k3, j2))
        break;
      this.exchange(k3, j2);
      k3 = j2;
    }
  }
  getValueAt(i2) {
    return this.getElementValue(this.priorityQueue[i2]);
  }
  less(i2, j2) {
    return this.getValueAt(i2) < this.getValueAt(j2);
  }
  exchange(i2, j2) {
    const t2 = this.priorityQueue[i2];
    this.priorityQueue[i2] = this.priorityQueue[j2];
    this.priorityQueue[j2] = t2;
  }
};
function getOffsetPoint(y2, x2, keypoint, offsets) {
  return {
    y: offsets.get(y2, x2, keypoint),
    x: offsets.get(y2, x2, keypoint + count2)
  };
}
function getImageCoords(part, outputStride2, offsets) {
  const { heatmapY, heatmapX, id: keypoint } = part;
  const { y: y2, x: x2 } = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);
  return {
    x: part.heatmapX * outputStride2 + x2,
    y: part.heatmapY * outputStride2 + y2
  };
}
function clamp22(a6, min7, max7) {
  if (a6 < min7)
    return min7;
  if (a6 > max7)
    return max7;
  return a6;
}
function squaredDistance(y1, x1, y2, x2) {
  const dy = y2 - y1;
  const dx = x2 - x1;
  return dy * dy + dx * dx;
}
function addVectors(a6, b2) {
  return { x: a6.x + b2.x, y: a6.y + b2.y };
}
var model7;
var poseNetOutputs = ["MobilenetV1/offset_2/BiasAdd", "MobilenetV1/heatmap_2/BiasAdd", "MobilenetV1/displacement_fwd_2/BiasAdd", "MobilenetV1/displacement_bwd_2/BiasAdd"];
var localMaximumRadius = 1;
var outputStride = 16;
var squaredNmsRadius = 50 ** 2;
function traverse(edgeId, sourceKeypoint, targetId, scores, offsets, displacements, offsetRefineStep = 2) {
  const getDisplacement = (point2) => ({
    y: displacements.get(point2.y, point2.x, edgeId),
    x: displacements.get(point2.y, point2.x, displacements.shape[2] / 2 + edgeId)
  });
  const getStridedIndexNearPoint = (point2, height2, width2) => ({
    y: clamp22(Math.round(point2.y / outputStride), 0, height2 - 1),
    x: clamp22(Math.round(point2.x / outputStride), 0, width2 - 1)
  });
  const [height, width] = scores.shape;
  const sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, height, width);
  const displacement = getDisplacement(sourceKeypointIndices);
  const displacedPoint = addVectors(sourceKeypoint.position, displacement);
  let targetKeypoint = displacedPoint;
  for (let i2 = 0; i2 < offsetRefineStep; i2++) {
    const targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
    const offsetPoint = getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetId, offsets);
    targetKeypoint = addVectors({ x: targetKeypointIndices.x * outputStride, y: targetKeypointIndices.y * outputStride }, { x: offsetPoint.x, y: offsetPoint.y });
  }
  const targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
  const score = scores.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetId);
  return { position: targetKeypoint, part: partNames[targetId], score };
}
function decodePose(root, scores, offsets, displacementsFwd, displacementsBwd) {
  const tuples = poseChain.map(([parentJoinName, childJoinName]) => [partIds[parentJoinName], partIds[childJoinName]]);
  const edgesFwd = tuples.map(([, childJointId]) => childJointId);
  const edgesBwd = tuples.map(([parentJointId]) => parentJointId);
  const numParts = scores.shape[2];
  const numEdges = edgesFwd.length;
  const keypoints2 = new Array(numParts);
  const rootPoint = getImageCoords(root.part, outputStride, offsets);
  keypoints2[root.part.id] = {
    score: root.score,
    part: partNames[root.part.id],
    position: rootPoint
  };
  for (let edge = numEdges - 1; edge >= 0; --edge) {
    const sourceId = edgesFwd[edge];
    const targetId = edgesBwd[edge];
    if (keypoints2[sourceId] && !keypoints2[targetId]) {
      keypoints2[targetId] = traverse(edge, keypoints2[sourceId], targetId, scores, offsets, displacementsBwd);
    }
  }
  for (let edge = 0; edge < numEdges; ++edge) {
    const sourceId = edgesBwd[edge];
    const targetId = edgesFwd[edge];
    if (keypoints2[sourceId] && !keypoints2[targetId]) {
      keypoints2[targetId] = traverse(edge, keypoints2[sourceId], targetId, scores, offsets, displacementsFwd);
    }
  }
  return keypoints2;
}
function scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores) {
  const [height, width] = scores.shape;
  let localMaximum = true;
  const yStart = Math.max(heatmapY - localMaximumRadius, 0);
  const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
  for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
    const xStart = Math.max(heatmapX - localMaximumRadius, 0);
    const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
    for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
      if (scores.get(yCurrent, xCurrent, keypointId) > score) {
        localMaximum = false;
        break;
      }
    }
    if (!localMaximum)
      break;
  }
  return localMaximum;
}
function buildPartWithScoreQueue(minConfidence2, scores) {
  const [height, width, numKeypoints] = scores.shape;
  const queue = new MaxHeap(height * width * numKeypoints, ({ score }) => score);
  for (let heatmapY = 0; heatmapY < height; ++heatmapY) {
    for (let heatmapX = 0; heatmapX < width; ++heatmapX) {
      for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {
        const score = scores.get(heatmapY, heatmapX, keypointId);
        if (score < minConfidence2)
          continue;
        if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores))
          queue.enqueue({ score, part: { heatmapY, heatmapX, id: keypointId } });
      }
    }
  }
  return queue;
}
function withinRadius(poses, { x: x2, y: y2 }, keypointId) {
  return poses.some(({ keypoints: keypoints2 }) => {
    var _a;
    const correspondingKeypoint = (_a = keypoints2[keypointId]) == null ? void 0 : _a.position;
    if (!correspondingKeypoint)
      return false;
    return squaredDistance(y2, x2, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
  });
}
function getInstanceScore(existingPoses, keypoints2) {
  const notOverlappedKeypointScores = keypoints2.reduce((result, { position, score }, keypointId) => {
    if (!withinRadius(existingPoses, position, keypointId))
      result += score;
    return result;
  }, 0);
  return notOverlappedKeypointScores / keypoints2.length;
}
function decode(offsets, scores, displacementsFwd, displacementsBwd, maxDetected, minConfidence2) {
  const poses = [];
  const queue = buildPartWithScoreQueue(minConfidence2, scores);
  while (poses.length < maxDetected && !queue.empty()) {
    const root = queue.dequeue();
    const rootImageCoords = getImageCoords(root.part, outputStride, offsets);
    if (withinRadius(poses, rootImageCoords, root.part.id))
      continue;
    let keypoints2 = decodePose(root, scores, offsets, displacementsFwd, displacementsBwd);
    keypoints2 = keypoints2.filter((a6) => a6.score > minConfidence2);
    const score = getInstanceScore(poses, keypoints2);
    const box5 = getBoundingBox(keypoints2);
    if (score > minConfidence2)
      poses.push({ keypoints: keypoints2, box: box5, score: Math.round(100 * score) / 100 });
  }
  return poses;
}
async function predict4(input2, config3) {
  const res2 = tidy(() => {
    if (!model7.inputs[0].shape)
      return [];
    const resized = image.resizeBilinear(input2, [model7.inputs[0].shape[2], model7.inputs[0].shape[1]]);
    const normalized = sub(div(cast(resized, "float32"), 127.5), 1);
    const results = model7.execute(normalized, poseNetOutputs);
    const results3d = results.map((y2) => squeeze(y2, [0]));
    results3d[1] = results3d[1].sigmoid();
    return results3d;
  });
  const buffers = await Promise.all(res2.map((tensor2) => tensor2.buffer()));
  for (const t2 of res2)
    dispose(t2);
  const decoded = await decode(buffers[0], buffers[1], buffers[2], buffers[3], config3.body.maxDetected, config3.body.minConfidence);
  if (!model7.inputs[0].shape)
    return [];
  const scaled = scalePoses(decoded, [input2.shape[1], input2.shape[2]], [model7.inputs[0].shape[2], model7.inputs[0].shape[1]]);
  return scaled;
}
async function load6(config3) {
  if (!model7 || env2.initial) {
    model7 = await loadGraphModel(join(config3.modelBasePath, config3.body.modelPath || ""));
    if (!model7 || !model7["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model7["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model7["modelUrl"]);
  return model7;
}
function getBoxSize2(box5) {
  return [
    Math.abs(box5.endPoint[0] - box5.startPoint[0]),
    Math.abs(box5.endPoint[1] - box5.startPoint[1])
  ];
}
function getBoxCenter2(box5) {
  return [
    box5.startPoint[0] + (box5.endPoint[0] - box5.startPoint[0]) / 2,
    box5.startPoint[1] + (box5.endPoint[1] - box5.startPoint[1]) / 2
  ];
}
function cutBoxFromImageAndResize2(box5, image7, cropSize) {
  const h2 = image7.shape[1];
  const w2 = image7.shape[2];
  const boxes = [[
    box5.startPoint[1] / h2,
    box5.startPoint[0] / w2,
    box5.endPoint[1] / h2,
    box5.endPoint[0] / w2
  ]];
  return image.cropAndResize(image7, boxes, [0], cropSize);
}
function scaleBoxCoordinates2(box5, factor) {
  const startPoint = [box5.startPoint[0] * factor[0], box5.startPoint[1] * factor[1]];
  const endPoint = [box5.endPoint[0] * factor[0], box5.endPoint[1] * factor[1]];
  const palmLandmarks = box5.palmLandmarks.map((coord) => {
    const scaledCoord = [coord[0] * factor[0], coord[1] * factor[1]];
    return scaledCoord;
  });
  return { startPoint, endPoint, palmLandmarks, confidence: box5.confidence };
}
function enlargeBox2(box5, factor = 1.5) {
  const center = getBoxCenter2(box5);
  const size2 = getBoxSize2(box5);
  const newHalfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
  const startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];
  const endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];
  return { startPoint, endPoint, palmLandmarks: box5.palmLandmarks };
}
function squarifyBox2(box5) {
  const centers = getBoxCenter2(box5);
  const size2 = getBoxSize2(box5);
  const maxEdge = Math.max(...size2);
  const halfSize = maxEdge / 2;
  const startPoint = [centers[0] - halfSize, centers[1] - halfSize];
  const endPoint = [centers[0] + halfSize, centers[1] + halfSize];
  return { startPoint, endPoint, palmLandmarks: box5.palmLandmarks };
}
var anchors2 = [
  { x: 0.015625, y: 0.015625 },
  { x: 0.015625, y: 0.015625 },
  { x: 0.046875, y: 0.015625 },
  { x: 0.046875, y: 0.015625 },
  { x: 0.078125, y: 0.015625 },
  { x: 0.078125, y: 0.015625 },
  { x: 0.109375, y: 0.015625 },
  { x: 0.109375, y: 0.015625 },
  { x: 0.140625, y: 0.015625 },
  { x: 0.140625, y: 0.015625 },
  { x: 0.171875, y: 0.015625 },
  { x: 0.171875, y: 0.015625 },
  { x: 0.203125, y: 0.015625 },
  { x: 0.203125, y: 0.015625 },
  { x: 0.234375, y: 0.015625 },
  { x: 0.234375, y: 0.015625 },
  { x: 0.265625, y: 0.015625 },
  { x: 0.265625, y: 0.015625 },
  { x: 0.296875, y: 0.015625 },
  { x: 0.296875, y: 0.015625 },
  { x: 0.328125, y: 0.015625 },
  { x: 0.328125, y: 0.015625 },
  { x: 0.359375, y: 0.015625 },
  { x: 0.359375, y: 0.015625 },
  { x: 0.390625, y: 0.015625 },
  { x: 0.390625, y: 0.015625 },
  { x: 0.421875, y: 0.015625 },
  { x: 0.421875, y: 0.015625 },
  { x: 0.453125, y: 0.015625 },
  { x: 0.453125, y: 0.015625 },
  { x: 0.484375, y: 0.015625 },
  { x: 0.484375, y: 0.015625 },
  { x: 0.515625, y: 0.015625 },
  { x: 0.515625, y: 0.015625 },
  { x: 0.546875, y: 0.015625 },
  { x: 0.546875, y: 0.015625 },
  { x: 0.578125, y: 0.015625 },
  { x: 0.578125, y: 0.015625 },
  { x: 0.609375, y: 0.015625 },
  { x: 0.609375, y: 0.015625 },
  { x: 0.640625, y: 0.015625 },
  { x: 0.640625, y: 0.015625 },
  { x: 0.671875, y: 0.015625 },
  { x: 0.671875, y: 0.015625 },
  { x: 0.703125, y: 0.015625 },
  { x: 0.703125, y: 0.015625 },
  { x: 0.734375, y: 0.015625 },
  { x: 0.734375, y: 0.015625 },
  { x: 0.765625, y: 0.015625 },
  { x: 0.765625, y: 0.015625 },
  { x: 0.796875, y: 0.015625 },
  { x: 0.796875, y: 0.015625 },
  { x: 0.828125, y: 0.015625 },
  { x: 0.828125, y: 0.015625 },
  { x: 0.859375, y: 0.015625 },
  { x: 0.859375, y: 0.015625 },
  { x: 0.890625, y: 0.015625 },
  { x: 0.890625, y: 0.015625 },
  { x: 0.921875, y: 0.015625 },
  { x: 0.921875, y: 0.015625 },
  { x: 0.953125, y: 0.015625 },
  { x: 0.953125, y: 0.015625 },
  { x: 0.984375, y: 0.015625 },
  { x: 0.984375, y: 0.015625 },
  { x: 0.015625, y: 0.046875 },
  { x: 0.015625, y: 0.046875 },
  { x: 0.046875, y: 0.046875 },
  { x: 0.046875, y: 0.046875 },
  { x: 0.078125, y: 0.046875 },
  { x: 0.078125, y: 0.046875 },
  { x: 0.109375, y: 0.046875 },
  { x: 0.109375, y: 0.046875 },
  { x: 0.140625, y: 0.046875 },
  { x: 0.140625, y: 0.046875 },
  { x: 0.171875, y: 0.046875 },
  { x: 0.171875, y: 0.046875 },
  { x: 0.203125, y: 0.046875 },
  { x: 0.203125, y: 0.046875 },
  { x: 0.234375, y: 0.046875 },
  { x: 0.234375, y: 0.046875 },
  { x: 0.265625, y: 0.046875 },
  { x: 0.265625, y: 0.046875 },
  { x: 0.296875, y: 0.046875 },
  { x: 0.296875, y: 0.046875 },
  { x: 0.328125, y: 0.046875 },
  { x: 0.328125, y: 0.046875 },
  { x: 0.359375, y: 0.046875 },
  { x: 0.359375, y: 0.046875 },
  { x: 0.390625, y: 0.046875 },
  { x: 0.390625, y: 0.046875 },
  { x: 0.421875, y: 0.046875 },
  { x: 0.421875, y: 0.046875 },
  { x: 0.453125, y: 0.046875 },
  { x: 0.453125, y: 0.046875 },
  { x: 0.484375, y: 0.046875 },
  { x: 0.484375, y: 0.046875 },
  { x: 0.515625, y: 0.046875 },
  { x: 0.515625, y: 0.046875 },
  { x: 0.546875, y: 0.046875 },
  { x: 0.546875, y: 0.046875 },
  { x: 0.578125, y: 0.046875 },
  { x: 0.578125, y: 0.046875 },
  { x: 0.609375, y: 0.046875 },
  { x: 0.609375, y: 0.046875 },
  { x: 0.640625, y: 0.046875 },
  { x: 0.640625, y: 0.046875 },
  { x: 0.671875, y: 0.046875 },
  { x: 0.671875, y: 0.046875 },
  { x: 0.703125, y: 0.046875 },
  { x: 0.703125, y: 0.046875 },
  { x: 0.734375, y: 0.046875 },
  { x: 0.734375, y: 0.046875 },
  { x: 0.765625, y: 0.046875 },
  { x: 0.765625, y: 0.046875 },
  { x: 0.796875, y: 0.046875 },
  { x: 0.796875, y: 0.046875 },
  { x: 0.828125, y: 0.046875 },
  { x: 0.828125, y: 0.046875 },
  { x: 0.859375, y: 0.046875 },
  { x: 0.859375, y: 0.046875 },
  { x: 0.890625, y: 0.046875 },
  { x: 0.890625, y: 0.046875 },
  { x: 0.921875, y: 0.046875 },
  { x: 0.921875, y: 0.046875 },
  { x: 0.953125, y: 0.046875 },
  { x: 0.953125, y: 0.046875 },
  { x: 0.984375, y: 0.046875 },
  { x: 0.984375, y: 0.046875 },
  { x: 0.015625, y: 0.078125 },
  { x: 0.015625, y: 0.078125 },
  { x: 0.046875, y: 0.078125 },
  { x: 0.046875, y: 0.078125 },
  { x: 0.078125, y: 0.078125 },
  { x: 0.078125, y: 0.078125 },
  { x: 0.109375, y: 0.078125 },
  { x: 0.109375, y: 0.078125 },
  { x: 0.140625, y: 0.078125 },
  { x: 0.140625, y: 0.078125 },
  { x: 0.171875, y: 0.078125 },
  { x: 0.171875, y: 0.078125 },
  { x: 0.203125, y: 0.078125 },
  { x: 0.203125, y: 0.078125 },
  { x: 0.234375, y: 0.078125 },
  { x: 0.234375, y: 0.078125 },
  { x: 0.265625, y: 0.078125 },
  { x: 0.265625, y: 0.078125 },
  { x: 0.296875, y: 0.078125 },
  { x: 0.296875, y: 0.078125 },
  { x: 0.328125, y: 0.078125 },
  { x: 0.328125, y: 0.078125 },
  { x: 0.359375, y: 0.078125 },
  { x: 0.359375, y: 0.078125 },
  { x: 0.390625, y: 0.078125 },
  { x: 0.390625, y: 0.078125 },
  { x: 0.421875, y: 0.078125 },
  { x: 0.421875, y: 0.078125 },
  { x: 0.453125, y: 0.078125 },
  { x: 0.453125, y: 0.078125 },
  { x: 0.484375, y: 0.078125 },
  { x: 0.484375, y: 0.078125 },
  { x: 0.515625, y: 0.078125 },
  { x: 0.515625, y: 0.078125 },
  { x: 0.546875, y: 0.078125 },
  { x: 0.546875, y: 0.078125 },
  { x: 0.578125, y: 0.078125 },
  { x: 0.578125, y: 0.078125 },
  { x: 0.609375, y: 0.078125 },
  { x: 0.609375, y: 0.078125 },
  { x: 0.640625, y: 0.078125 },
  { x: 0.640625, y: 0.078125 },
  { x: 0.671875, y: 0.078125 },
  { x: 0.671875, y: 0.078125 },
  { x: 0.703125, y: 0.078125 },
  { x: 0.703125, y: 0.078125 },
  { x: 0.734375, y: 0.078125 },
  { x: 0.734375, y: 0.078125 },
  { x: 0.765625, y: 0.078125 },
  { x: 0.765625, y: 0.078125 },
  { x: 0.796875, y: 0.078125 },
  { x: 0.796875, y: 0.078125 },
  { x: 0.828125, y: 0.078125 },
  { x: 0.828125, y: 0.078125 },
  { x: 0.859375, y: 0.078125 },
  { x: 0.859375, y: 0.078125 },
  { x: 0.890625, y: 0.078125 },
  { x: 0.890625, y: 0.078125 },
  { x: 0.921875, y: 0.078125 },
  { x: 0.921875, y: 0.078125 },
  { x: 0.953125, y: 0.078125 },
  { x: 0.953125, y: 0.078125 },
  { x: 0.984375, y: 0.078125 },
  { x: 0.984375, y: 0.078125 },
  { x: 0.015625, y: 0.109375 },
  { x: 0.015625, y: 0.109375 },
  { x: 0.046875, y: 0.109375 },
  { x: 0.046875, y: 0.109375 },
  { x: 0.078125, y: 0.109375 },
  { x: 0.078125, y: 0.109375 },
  { x: 0.109375, y: 0.109375 },
  { x: 0.109375, y: 0.109375 },
  { x: 0.140625, y: 0.109375 },
  { x: 0.140625, y: 0.109375 },
  { x: 0.171875, y: 0.109375 },
  { x: 0.171875, y: 0.109375 },
  { x: 0.203125, y: 0.109375 },
  { x: 0.203125, y: 0.109375 },
  { x: 0.234375, y: 0.109375 },
  { x: 0.234375, y: 0.109375 },
  { x: 0.265625, y: 0.109375 },
  { x: 0.265625, y: 0.109375 },
  { x: 0.296875, y: 0.109375 },
  { x: 0.296875, y: 0.109375 },
  { x: 0.328125, y: 0.109375 },
  { x: 0.328125, y: 0.109375 },
  { x: 0.359375, y: 0.109375 },
  { x: 0.359375, y: 0.109375 },
  { x: 0.390625, y: 0.109375 },
  { x: 0.390625, y: 0.109375 },
  { x: 0.421875, y: 0.109375 },
  { x: 0.421875, y: 0.109375 },
  { x: 0.453125, y: 0.109375 },
  { x: 0.453125, y: 0.109375 },
  { x: 0.484375, y: 0.109375 },
  { x: 0.484375, y: 0.109375 },
  { x: 0.515625, y: 0.109375 },
  { x: 0.515625, y: 0.109375 },
  { x: 0.546875, y: 0.109375 },
  { x: 0.546875, y: 0.109375 },
  { x: 0.578125, y: 0.109375 },
  { x: 0.578125, y: 0.109375 },
  { x: 0.609375, y: 0.109375 },
  { x: 0.609375, y: 0.109375 },
  { x: 0.640625, y: 0.109375 },
  { x: 0.640625, y: 0.109375 },
  { x: 0.671875, y: 0.109375 },
  { x: 0.671875, y: 0.109375 },
  { x: 0.703125, y: 0.109375 },
  { x: 0.703125, y: 0.109375 },
  { x: 0.734375, y: 0.109375 },
  { x: 0.734375, y: 0.109375 },
  { x: 0.765625, y: 0.109375 },
  { x: 0.765625, y: 0.109375 },
  { x: 0.796875, y: 0.109375 },
  { x: 0.796875, y: 0.109375 },
  { x: 0.828125, y: 0.109375 },
  { x: 0.828125, y: 0.109375 },
  { x: 0.859375, y: 0.109375 },
  { x: 0.859375, y: 0.109375 },
  { x: 0.890625, y: 0.109375 },
  { x: 0.890625, y: 0.109375 },
  { x: 0.921875, y: 0.109375 },
  { x: 0.921875, y: 0.109375 },
  { x: 0.953125, y: 0.109375 },
  { x: 0.953125, y: 0.109375 },
  { x: 0.984375, y: 0.109375 },
  { x: 0.984375, y: 0.109375 },
  { x: 0.015625, y: 0.140625 },
  { x: 0.015625, y: 0.140625 },
  { x: 0.046875, y: 0.140625 },
  { x: 0.046875, y: 0.140625 },
  { x: 0.078125, y: 0.140625 },
  { x: 0.078125, y: 0.140625 },
  { x: 0.109375, y: 0.140625 },
  { x: 0.109375, y: 0.140625 },
  { x: 0.140625, y: 0.140625 },
  { x: 0.140625, y: 0.140625 },
  { x: 0.171875, y: 0.140625 },
  { x: 0.171875, y: 0.140625 },
  { x: 0.203125, y: 0.140625 },
  { x: 0.203125, y: 0.140625 },
  { x: 0.234375, y: 0.140625 },
  { x: 0.234375, y: 0.140625 },
  { x: 0.265625, y: 0.140625 },
  { x: 0.265625, y: 0.140625 },
  { x: 0.296875, y: 0.140625 },
  { x: 0.296875, y: 0.140625 },
  { x: 0.328125, y: 0.140625 },
  { x: 0.328125, y: 0.140625 },
  { x: 0.359375, y: 0.140625 },
  { x: 0.359375, y: 0.140625 },
  { x: 0.390625, y: 0.140625 },
  { x: 0.390625, y: 0.140625 },
  { x: 0.421875, y: 0.140625 },
  { x: 0.421875, y: 0.140625 },
  { x: 0.453125, y: 0.140625 },
  { x: 0.453125, y: 0.140625 },
  { x: 0.484375, y: 0.140625 },
  { x: 0.484375, y: 0.140625 },
  { x: 0.515625, y: 0.140625 },
  { x: 0.515625, y: 0.140625 },
  { x: 0.546875, y: 0.140625 },
  { x: 0.546875, y: 0.140625 },
  { x: 0.578125, y: 0.140625 },
  { x: 0.578125, y: 0.140625 },
  { x: 0.609375, y: 0.140625 },
  { x: 0.609375, y: 0.140625 },
  { x: 0.640625, y: 0.140625 },
  { x: 0.640625, y: 0.140625 },
  { x: 0.671875, y: 0.140625 },
  { x: 0.671875, y: 0.140625 },
  { x: 0.703125, y: 0.140625 },
  { x: 0.703125, y: 0.140625 },
  { x: 0.734375, y: 0.140625 },
  { x: 0.734375, y: 0.140625 },
  { x: 0.765625, y: 0.140625 },
  { x: 0.765625, y: 0.140625 },
  { x: 0.796875, y: 0.140625 },
  { x: 0.796875, y: 0.140625 },
  { x: 0.828125, y: 0.140625 },
  { x: 0.828125, y: 0.140625 },
  { x: 0.859375, y: 0.140625 },
  { x: 0.859375, y: 0.140625 },
  { x: 0.890625, y: 0.140625 },
  { x: 0.890625, y: 0.140625 },
  { x: 0.921875, y: 0.140625 },
  { x: 0.921875, y: 0.140625 },
  { x: 0.953125, y: 0.140625 },
  { x: 0.953125, y: 0.140625 },
  { x: 0.984375, y: 0.140625 },
  { x: 0.984375, y: 0.140625 },
  { x: 0.015625, y: 0.171875 },
  { x: 0.015625, y: 0.171875 },
  { x: 0.046875, y: 0.171875 },
  { x: 0.046875, y: 0.171875 },
  { x: 0.078125, y: 0.171875 },
  { x: 0.078125, y: 0.171875 },
  { x: 0.109375, y: 0.171875 },
  { x: 0.109375, y: 0.171875 },
  { x: 0.140625, y: 0.171875 },
  { x: 0.140625, y: 0.171875 },
  { x: 0.171875, y: 0.171875 },
  { x: 0.171875, y: 0.171875 },
  { x: 0.203125, y: 0.171875 },
  { x: 0.203125, y: 0.171875 },
  { x: 0.234375, y: 0.171875 },
  { x: 0.234375, y: 0.171875 },
  { x: 0.265625, y: 0.171875 },
  { x: 0.265625, y: 0.171875 },
  { x: 0.296875, y: 0.171875 },
  { x: 0.296875, y: 0.171875 },
  { x: 0.328125, y: 0.171875 },
  { x: 0.328125, y: 0.171875 },
  { x: 0.359375, y: 0.171875 },
  { x: 0.359375, y: 0.171875 },
  { x: 0.390625, y: 0.171875 },
  { x: 0.390625, y: 0.171875 },
  { x: 0.421875, y: 0.171875 },
  { x: 0.421875, y: 0.171875 },
  { x: 0.453125, y: 0.171875 },
  { x: 0.453125, y: 0.171875 },
  { x: 0.484375, y: 0.171875 },
  { x: 0.484375, y: 0.171875 },
  { x: 0.515625, y: 0.171875 },
  { x: 0.515625, y: 0.171875 },
  { x: 0.546875, y: 0.171875 },
  { x: 0.546875, y: 0.171875 },
  { x: 0.578125, y: 0.171875 },
  { x: 0.578125, y: 0.171875 },
  { x: 0.609375, y: 0.171875 },
  { x: 0.609375, y: 0.171875 },
  { x: 0.640625, y: 0.171875 },
  { x: 0.640625, y: 0.171875 },
  { x: 0.671875, y: 0.171875 },
  { x: 0.671875, y: 0.171875 },
  { x: 0.703125, y: 0.171875 },
  { x: 0.703125, y: 0.171875 },
  { x: 0.734375, y: 0.171875 },
  { x: 0.734375, y: 0.171875 },
  { x: 0.765625, y: 0.171875 },
  { x: 0.765625, y: 0.171875 },
  { x: 0.796875, y: 0.171875 },
  { x: 0.796875, y: 0.171875 },
  { x: 0.828125, y: 0.171875 },
  { x: 0.828125, y: 0.171875 },
  { x: 0.859375, y: 0.171875 },
  { x: 0.859375, y: 0.171875 },
  { x: 0.890625, y: 0.171875 },
  { x: 0.890625, y: 0.171875 },
  { x: 0.921875, y: 0.171875 },
  { x: 0.921875, y: 0.171875 },
  { x: 0.953125, y: 0.171875 },
  { x: 0.953125, y: 0.171875 },
  { x: 0.984375, y: 0.171875 },
  { x: 0.984375, y: 0.171875 },
  { x: 0.015625, y: 0.203125 },
  { x: 0.015625, y: 0.203125 },
  { x: 0.046875, y: 0.203125 },
  { x: 0.046875, y: 0.203125 },
  { x: 0.078125, y: 0.203125 },
  { x: 0.078125, y: 0.203125 },
  { x: 0.109375, y: 0.203125 },
  { x: 0.109375, y: 0.203125 },
  { x: 0.140625, y: 0.203125 },
  { x: 0.140625, y: 0.203125 },
  { x: 0.171875, y: 0.203125 },
  { x: 0.171875, y: 0.203125 },
  { x: 0.203125, y: 0.203125 },
  { x: 0.203125, y: 0.203125 },
  { x: 0.234375, y: 0.203125 },
  { x: 0.234375, y: 0.203125 },
  { x: 0.265625, y: 0.203125 },
  { x: 0.265625, y: 0.203125 },
  { x: 0.296875, y: 0.203125 },
  { x: 0.296875, y: 0.203125 },
  { x: 0.328125, y: 0.203125 },
  { x: 0.328125, y: 0.203125 },
  { x: 0.359375, y: 0.203125 },
  { x: 0.359375, y: 0.203125 },
  { x: 0.390625, y: 0.203125 },
  { x: 0.390625, y: 0.203125 },
  { x: 0.421875, y: 0.203125 },
  { x: 0.421875, y: 0.203125 },
  { x: 0.453125, y: 0.203125 },
  { x: 0.453125, y: 0.203125 },
  { x: 0.484375, y: 0.203125 },
  { x: 0.484375, y: 0.203125 },
  { x: 0.515625, y: 0.203125 },
  { x: 0.515625, y: 0.203125 },
  { x: 0.546875, y: 0.203125 },
  { x: 0.546875, y: 0.203125 },
  { x: 0.578125, y: 0.203125 },
  { x: 0.578125, y: 0.203125 },
  { x: 0.609375, y: 0.203125 },
  { x: 0.609375, y: 0.203125 },
  { x: 0.640625, y: 0.203125 },
  { x: 0.640625, y: 0.203125 },
  { x: 0.671875, y: 0.203125 },
  { x: 0.671875, y: 0.203125 },
  { x: 0.703125, y: 0.203125 },
  { x: 0.703125, y: 0.203125 },
  { x: 0.734375, y: 0.203125 },
  { x: 0.734375, y: 0.203125 },
  { x: 0.765625, y: 0.203125 },
  { x: 0.765625, y: 0.203125 },
  { x: 0.796875, y: 0.203125 },
  { x: 0.796875, y: 0.203125 },
  { x: 0.828125, y: 0.203125 },
  { x: 0.828125, y: 0.203125 },
  { x: 0.859375, y: 0.203125 },
  { x: 0.859375, y: 0.203125 },
  { x: 0.890625, y: 0.203125 },
  { x: 0.890625, y: 0.203125 },
  { x: 0.921875, y: 0.203125 },
  { x: 0.921875, y: 0.203125 },
  { x: 0.953125, y: 0.203125 },
  { x: 0.953125, y: 0.203125 },
  { x: 0.984375, y: 0.203125 },
  { x: 0.984375, y: 0.203125 },
  { x: 0.015625, y: 0.234375 },
  { x: 0.015625, y: 0.234375 },
  { x: 0.046875, y: 0.234375 },
  { x: 0.046875, y: 0.234375 },
  { x: 0.078125, y: 0.234375 },
  { x: 0.078125, y: 0.234375 },
  { x: 0.109375, y: 0.234375 },
  { x: 0.109375, y: 0.234375 },
  { x: 0.140625, y: 0.234375 },
  { x: 0.140625, y: 0.234375 },
  { x: 0.171875, y: 0.234375 },
  { x: 0.171875, y: 0.234375 },
  { x: 0.203125, y: 0.234375 },
  { x: 0.203125, y: 0.234375 },
  { x: 0.234375, y: 0.234375 },
  { x: 0.234375, y: 0.234375 },
  { x: 0.265625, y: 0.234375 },
  { x: 0.265625, y: 0.234375 },
  { x: 0.296875, y: 0.234375 },
  { x: 0.296875, y: 0.234375 },
  { x: 0.328125, y: 0.234375 },
  { x: 0.328125, y: 0.234375 },
  { x: 0.359375, y: 0.234375 },
  { x: 0.359375, y: 0.234375 },
  { x: 0.390625, y: 0.234375 },
  { x: 0.390625, y: 0.234375 },
  { x: 0.421875, y: 0.234375 },
  { x: 0.421875, y: 0.234375 },
  { x: 0.453125, y: 0.234375 },
  { x: 0.453125, y: 0.234375 },
  { x: 0.484375, y: 0.234375 },
  { x: 0.484375, y: 0.234375 },
  { x: 0.515625, y: 0.234375 },
  { x: 0.515625, y: 0.234375 },
  { x: 0.546875, y: 0.234375 },
  { x: 0.546875, y: 0.234375 },
  { x: 0.578125, y: 0.234375 },
  { x: 0.578125, y: 0.234375 },
  { x: 0.609375, y: 0.234375 },
  { x: 0.609375, y: 0.234375 },
  { x: 0.640625, y: 0.234375 },
  { x: 0.640625, y: 0.234375 },
  { x: 0.671875, y: 0.234375 },
  { x: 0.671875, y: 0.234375 },
  { x: 0.703125, y: 0.234375 },
  { x: 0.703125, y: 0.234375 },
  { x: 0.734375, y: 0.234375 },
  { x: 0.734375, y: 0.234375 },
  { x: 0.765625, y: 0.234375 },
  { x: 0.765625, y: 0.234375 },
  { x: 0.796875, y: 0.234375 },
  { x: 0.796875, y: 0.234375 },
  { x: 0.828125, y: 0.234375 },
  { x: 0.828125, y: 0.234375 },
  { x: 0.859375, y: 0.234375 },
  { x: 0.859375, y: 0.234375 },
  { x: 0.890625, y: 0.234375 },
  { x: 0.890625, y: 0.234375 },
  { x: 0.921875, y: 0.234375 },
  { x: 0.921875, y: 0.234375 },
  { x: 0.953125, y: 0.234375 },
  { x: 0.953125, y: 0.234375 },
  { x: 0.984375, y: 0.234375 },
  { x: 0.984375, y: 0.234375 },
  { x: 0.015625, y: 0.265625 },
  { x: 0.015625, y: 0.265625 },
  { x: 0.046875, y: 0.265625 },
  { x: 0.046875, y: 0.265625 },
  { x: 0.078125, y: 0.265625 },
  { x: 0.078125, y: 0.265625 },
  { x: 0.109375, y: 0.265625 },
  { x: 0.109375, y: 0.265625 },
  { x: 0.140625, y: 0.265625 },
  { x: 0.140625, y: 0.265625 },
  { x: 0.171875, y: 0.265625 },
  { x: 0.171875, y: 0.265625 },
  { x: 0.203125, y: 0.265625 },
  { x: 0.203125, y: 0.265625 },
  { x: 0.234375, y: 0.265625 },
  { x: 0.234375, y: 0.265625 },
  { x: 0.265625, y: 0.265625 },
  { x: 0.265625, y: 0.265625 },
  { x: 0.296875, y: 0.265625 },
  { x: 0.296875, y: 0.265625 },
  { x: 0.328125, y: 0.265625 },
  { x: 0.328125, y: 0.265625 },
  { x: 0.359375, y: 0.265625 },
  { x: 0.359375, y: 0.265625 },
  { x: 0.390625, y: 0.265625 },
  { x: 0.390625, y: 0.265625 },
  { x: 0.421875, y: 0.265625 },
  { x: 0.421875, y: 0.265625 },
  { x: 0.453125, y: 0.265625 },
  { x: 0.453125, y: 0.265625 },
  { x: 0.484375, y: 0.265625 },
  { x: 0.484375, y: 0.265625 },
  { x: 0.515625, y: 0.265625 },
  { x: 0.515625, y: 0.265625 },
  { x: 0.546875, y: 0.265625 },
  { x: 0.546875, y: 0.265625 },
  { x: 0.578125, y: 0.265625 },
  { x: 0.578125, y: 0.265625 },
  { x: 0.609375, y: 0.265625 },
  { x: 0.609375, y: 0.265625 },
  { x: 0.640625, y: 0.265625 },
  { x: 0.640625, y: 0.265625 },
  { x: 0.671875, y: 0.265625 },
  { x: 0.671875, y: 0.265625 },
  { x: 0.703125, y: 0.265625 },
  { x: 0.703125, y: 0.265625 },
  { x: 0.734375, y: 0.265625 },
  { x: 0.734375, y: 0.265625 },
  { x: 0.765625, y: 0.265625 },
  { x: 0.765625, y: 0.265625 },
  { x: 0.796875, y: 0.265625 },
  { x: 0.796875, y: 0.265625 },
  { x: 0.828125, y: 0.265625 },
  { x: 0.828125, y: 0.265625 },
  { x: 0.859375, y: 0.265625 },
  { x: 0.859375, y: 0.265625 },
  { x: 0.890625, y: 0.265625 },
  { x: 0.890625, y: 0.265625 },
  { x: 0.921875, y: 0.265625 },
  { x: 0.921875, y: 0.265625 },
  { x: 0.953125, y: 0.265625 },
  { x: 0.953125, y: 0.265625 },
  { x: 0.984375, y: 0.265625 },
  { x: 0.984375, y: 0.265625 },
  { x: 0.015625, y: 0.296875 },
  { x: 0.015625, y: 0.296875 },
  { x: 0.046875, y: 0.296875 },
  { x: 0.046875, y: 0.296875 },
  { x: 0.078125, y: 0.296875 },
  { x: 0.078125, y: 0.296875 },
  { x: 0.109375, y: 0.296875 },
  { x: 0.109375, y: 0.296875 },
  { x: 0.140625, y: 0.296875 },
  { x: 0.140625, y: 0.296875 },
  { x: 0.171875, y: 0.296875 },
  { x: 0.171875, y: 0.296875 },
  { x: 0.203125, y: 0.296875 },
  { x: 0.203125, y: 0.296875 },
  { x: 0.234375, y: 0.296875 },
  { x: 0.234375, y: 0.296875 },
  { x: 0.265625, y: 0.296875 },
  { x: 0.265625, y: 0.296875 },
  { x: 0.296875, y: 0.296875 },
  { x: 0.296875, y: 0.296875 },
  { x: 0.328125, y: 0.296875 },
  { x: 0.328125, y: 0.296875 },
  { x: 0.359375, y: 0.296875 },
  { x: 0.359375, y: 0.296875 },
  { x: 0.390625, y: 0.296875 },
  { x: 0.390625, y: 0.296875 },
  { x: 0.421875, y: 0.296875 },
  { x: 0.421875, y: 0.296875 },
  { x: 0.453125, y: 0.296875 },
  { x: 0.453125, y: 0.296875 },
  { x: 0.484375, y: 0.296875 },
  { x: 0.484375, y: 0.296875 },
  { x: 0.515625, y: 0.296875 },
  { x: 0.515625, y: 0.296875 },
  { x: 0.546875, y: 0.296875 },
  { x: 0.546875, y: 0.296875 },
  { x: 0.578125, y: 0.296875 },
  { x: 0.578125, y: 0.296875 },
  { x: 0.609375, y: 0.296875 },
  { x: 0.609375, y: 0.296875 },
  { x: 0.640625, y: 0.296875 },
  { x: 0.640625, y: 0.296875 },
  { x: 0.671875, y: 0.296875 },
  { x: 0.671875, y: 0.296875 },
  { x: 0.703125, y: 0.296875 },
  { x: 0.703125, y: 0.296875 },
  { x: 0.734375, y: 0.296875 },
  { x: 0.734375, y: 0.296875 },
  { x: 0.765625, y: 0.296875 },
  { x: 0.765625, y: 0.296875 },
  { x: 0.796875, y: 0.296875 },
  { x: 0.796875, y: 0.296875 },
  { x: 0.828125, y: 0.296875 },
  { x: 0.828125, y: 0.296875 },
  { x: 0.859375, y: 0.296875 },
  { x: 0.859375, y: 0.296875 },
  { x: 0.890625, y: 0.296875 },
  { x: 0.890625, y: 0.296875 },
  { x: 0.921875, y: 0.296875 },
  { x: 0.921875, y: 0.296875 },
  { x: 0.953125, y: 0.296875 },
  { x: 0.953125, y: 0.296875 },
  { x: 0.984375, y: 0.296875 },
  { x: 0.984375, y: 0.296875 },
  { x: 0.015625, y: 0.328125 },
  { x: 0.015625, y: 0.328125 },
  { x: 0.046875, y: 0.328125 },
  { x: 0.046875, y: 0.328125 },
  { x: 0.078125, y: 0.328125 },
  { x: 0.078125, y: 0.328125 },
  { x: 0.109375, y: 0.328125 },
  { x: 0.109375, y: 0.328125 },
  { x: 0.140625, y: 0.328125 },
  { x: 0.140625, y: 0.328125 },
  { x: 0.171875, y: 0.328125 },
  { x: 0.171875, y: 0.328125 },
  { x: 0.203125, y: 0.328125 },
  { x: 0.203125, y: 0.328125 },
  { x: 0.234375, y: 0.328125 },
  { x: 0.234375, y: 0.328125 },
  { x: 0.265625, y: 0.328125 },
  { x: 0.265625, y: 0.328125 },
  { x: 0.296875, y: 0.328125 },
  { x: 0.296875, y: 0.328125 },
  { x: 0.328125, y: 0.328125 },
  { x: 0.328125, y: 0.328125 },
  { x: 0.359375, y: 0.328125 },
  { x: 0.359375, y: 0.328125 },
  { x: 0.390625, y: 0.328125 },
  { x: 0.390625, y: 0.328125 },
  { x: 0.421875, y: 0.328125 },
  { x: 0.421875, y: 0.328125 },
  { x: 0.453125, y: 0.328125 },
  { x: 0.453125, y: 0.328125 },
  { x: 0.484375, y: 0.328125 },
  { x: 0.484375, y: 0.328125 },
  { x: 0.515625, y: 0.328125 },
  { x: 0.515625, y: 0.328125 },
  { x: 0.546875, y: 0.328125 },
  { x: 0.546875, y: 0.328125 },
  { x: 0.578125, y: 0.328125 },
  { x: 0.578125, y: 0.328125 },
  { x: 0.609375, y: 0.328125 },
  { x: 0.609375, y: 0.328125 },
  { x: 0.640625, y: 0.328125 },
  { x: 0.640625, y: 0.328125 },
  { x: 0.671875, y: 0.328125 },
  { x: 0.671875, y: 0.328125 },
  { x: 0.703125, y: 0.328125 },
  { x: 0.703125, y: 0.328125 },
  { x: 0.734375, y: 0.328125 },
  { x: 0.734375, y: 0.328125 },
  { x: 0.765625, y: 0.328125 },
  { x: 0.765625, y: 0.328125 },
  { x: 0.796875, y: 0.328125 },
  { x: 0.796875, y: 0.328125 },
  { x: 0.828125, y: 0.328125 },
  { x: 0.828125, y: 0.328125 },
  { x: 0.859375, y: 0.328125 },
  { x: 0.859375, y: 0.328125 },
  { x: 0.890625, y: 0.328125 },
  { x: 0.890625, y: 0.328125 },
  { x: 0.921875, y: 0.328125 },
  { x: 0.921875, y: 0.328125 },
  { x: 0.953125, y: 0.328125 },
  { x: 0.953125, y: 0.328125 },
  { x: 0.984375, y: 0.328125 },
  { x: 0.984375, y: 0.328125 },
  { x: 0.015625, y: 0.359375 },
  { x: 0.015625, y: 0.359375 },
  { x: 0.046875, y: 0.359375 },
  { x: 0.046875, y: 0.359375 },
  { x: 0.078125, y: 0.359375 },
  { x: 0.078125, y: 0.359375 },
  { x: 0.109375, y: 0.359375 },
  { x: 0.109375, y: 0.359375 },
  { x: 0.140625, y: 0.359375 },
  { x: 0.140625, y: 0.359375 },
  { x: 0.171875, y: 0.359375 },
  { x: 0.171875, y: 0.359375 },
  { x: 0.203125, y: 0.359375 },
  { x: 0.203125, y: 0.359375 },
  { x: 0.234375, y: 0.359375 },
  { x: 0.234375, y: 0.359375 },
  { x: 0.265625, y: 0.359375 },
  { x: 0.265625, y: 0.359375 },
  { x: 0.296875, y: 0.359375 },
  { x: 0.296875, y: 0.359375 },
  { x: 0.328125, y: 0.359375 },
  { x: 0.328125, y: 0.359375 },
  { x: 0.359375, y: 0.359375 },
  { x: 0.359375, y: 0.359375 },
  { x: 0.390625, y: 0.359375 },
  { x: 0.390625, y: 0.359375 },
  { x: 0.421875, y: 0.359375 },
  { x: 0.421875, y: 0.359375 },
  { x: 0.453125, y: 0.359375 },
  { x: 0.453125, y: 0.359375 },
  { x: 0.484375, y: 0.359375 },
  { x: 0.484375, y: 0.359375 },
  { x: 0.515625, y: 0.359375 },
  { x: 0.515625, y: 0.359375 },
  { x: 0.546875, y: 0.359375 },
  { x: 0.546875, y: 0.359375 },
  { x: 0.578125, y: 0.359375 },
  { x: 0.578125, y: 0.359375 },
  { x: 0.609375, y: 0.359375 },
  { x: 0.609375, y: 0.359375 },
  { x: 0.640625, y: 0.359375 },
  { x: 0.640625, y: 0.359375 },
  { x: 0.671875, y: 0.359375 },
  { x: 0.671875, y: 0.359375 },
  { x: 0.703125, y: 0.359375 },
  { x: 0.703125, y: 0.359375 },
  { x: 0.734375, y: 0.359375 },
  { x: 0.734375, y: 0.359375 },
  { x: 0.765625, y: 0.359375 },
  { x: 0.765625, y: 0.359375 },
  { x: 0.796875, y: 0.359375 },
  { x: 0.796875, y: 0.359375 },
  { x: 0.828125, y: 0.359375 },
  { x: 0.828125, y: 0.359375 },
  { x: 0.859375, y: 0.359375 },
  { x: 0.859375, y: 0.359375 },
  { x: 0.890625, y: 0.359375 },
  { x: 0.890625, y: 0.359375 },
  { x: 0.921875, y: 0.359375 },
  { x: 0.921875, y: 0.359375 },
  { x: 0.953125, y: 0.359375 },
  { x: 0.953125, y: 0.359375 },
  { x: 0.984375, y: 0.359375 },
  { x: 0.984375, y: 0.359375 },
  { x: 0.015625, y: 0.390625 },
  { x: 0.015625, y: 0.390625 },
  { x: 0.046875, y: 0.390625 },
  { x: 0.046875, y: 0.390625 },
  { x: 0.078125, y: 0.390625 },
  { x: 0.078125, y: 0.390625 },
  { x: 0.109375, y: 0.390625 },
  { x: 0.109375, y: 0.390625 },
  { x: 0.140625, y: 0.390625 },
  { x: 0.140625, y: 0.390625 },
  { x: 0.171875, y: 0.390625 },
  { x: 0.171875, y: 0.390625 },
  { x: 0.203125, y: 0.390625 },
  { x: 0.203125, y: 0.390625 },
  { x: 0.234375, y: 0.390625 },
  { x: 0.234375, y: 0.390625 },
  { x: 0.265625, y: 0.390625 },
  { x: 0.265625, y: 0.390625 },
  { x: 0.296875, y: 0.390625 },
  { x: 0.296875, y: 0.390625 },
  { x: 0.328125, y: 0.390625 },
  { x: 0.328125, y: 0.390625 },
  { x: 0.359375, y: 0.390625 },
  { x: 0.359375, y: 0.390625 },
  { x: 0.390625, y: 0.390625 },
  { x: 0.390625, y: 0.390625 },
  { x: 0.421875, y: 0.390625 },
  { x: 0.421875, y: 0.390625 },
  { x: 0.453125, y: 0.390625 },
  { x: 0.453125, y: 0.390625 },
  { x: 0.484375, y: 0.390625 },
  { x: 0.484375, y: 0.390625 },
  { x: 0.515625, y: 0.390625 },
  { x: 0.515625, y: 0.390625 },
  { x: 0.546875, y: 0.390625 },
  { x: 0.546875, y: 0.390625 },
  { x: 0.578125, y: 0.390625 },
  { x: 0.578125, y: 0.390625 },
  { x: 0.609375, y: 0.390625 },
  { x: 0.609375, y: 0.390625 },
  { x: 0.640625, y: 0.390625 },
  { x: 0.640625, y: 0.390625 },
  { x: 0.671875, y: 0.390625 },
  { x: 0.671875, y: 0.390625 },
  { x: 0.703125, y: 0.390625 },
  { x: 0.703125, y: 0.390625 },
  { x: 0.734375, y: 0.390625 },
  { x: 0.734375, y: 0.390625 },
  { x: 0.765625, y: 0.390625 },
  { x: 0.765625, y: 0.390625 },
  { x: 0.796875, y: 0.390625 },
  { x: 0.796875, y: 0.390625 },
  { x: 0.828125, y: 0.390625 },
  { x: 0.828125, y: 0.390625 },
  { x: 0.859375, y: 0.390625 },
  { x: 0.859375, y: 0.390625 },
  { x: 0.890625, y: 0.390625 },
  { x: 0.890625, y: 0.390625 },
  { x: 0.921875, y: 0.390625 },
  { x: 0.921875, y: 0.390625 },
  { x: 0.953125, y: 0.390625 },
  { x: 0.953125, y: 0.390625 },
  { x: 0.984375, y: 0.390625 },
  { x: 0.984375, y: 0.390625 },
  { x: 0.015625, y: 0.421875 },
  { x: 0.015625, y: 0.421875 },
  { x: 0.046875, y: 0.421875 },
  { x: 0.046875, y: 0.421875 },
  { x: 0.078125, y: 0.421875 },
  { x: 0.078125, y: 0.421875 },
  { x: 0.109375, y: 0.421875 },
  { x: 0.109375, y: 0.421875 },
  { x: 0.140625, y: 0.421875 },
  { x: 0.140625, y: 0.421875 },
  { x: 0.171875, y: 0.421875 },
  { x: 0.171875, y: 0.421875 },
  { x: 0.203125, y: 0.421875 },
  { x: 0.203125, y: 0.421875 },
  { x: 0.234375, y: 0.421875 },
  { x: 0.234375, y: 0.421875 },
  { x: 0.265625, y: 0.421875 },
  { x: 0.265625, y: 0.421875 },
  { x: 0.296875, y: 0.421875 },
  { x: 0.296875, y: 0.421875 },
  { x: 0.328125, y: 0.421875 },
  { x: 0.328125, y: 0.421875 },
  { x: 0.359375, y: 0.421875 },
  { x: 0.359375, y: 0.421875 },
  { x: 0.390625, y: 0.421875 },
  { x: 0.390625, y: 0.421875 },
  { x: 0.421875, y: 0.421875 },
  { x: 0.421875, y: 0.421875 },
  { x: 0.453125, y: 0.421875 },
  { x: 0.453125, y: 0.421875 },
  { x: 0.484375, y: 0.421875 },
  { x: 0.484375, y: 0.421875 },
  { x: 0.515625, y: 0.421875 },
  { x: 0.515625, y: 0.421875 },
  { x: 0.546875, y: 0.421875 },
  { x: 0.546875, y: 0.421875 },
  { x: 0.578125, y: 0.421875 },
  { x: 0.578125, y: 0.421875 },
  { x: 0.609375, y: 0.421875 },
  { x: 0.609375, y: 0.421875 },
  { x: 0.640625, y: 0.421875 },
  { x: 0.640625, y: 0.421875 },
  { x: 0.671875, y: 0.421875 },
  { x: 0.671875, y: 0.421875 },
  { x: 0.703125, y: 0.421875 },
  { x: 0.703125, y: 0.421875 },
  { x: 0.734375, y: 0.421875 },
  { x: 0.734375, y: 0.421875 },
  { x: 0.765625, y: 0.421875 },
  { x: 0.765625, y: 0.421875 },
  { x: 0.796875, y: 0.421875 },
  { x: 0.796875, y: 0.421875 },
  { x: 0.828125, y: 0.421875 },
  { x: 0.828125, y: 0.421875 },
  { x: 0.859375, y: 0.421875 },
  { x: 0.859375, y: 0.421875 },
  { x: 0.890625, y: 0.421875 },
  { x: 0.890625, y: 0.421875 },
  { x: 0.921875, y: 0.421875 },
  { x: 0.921875, y: 0.421875 },
  { x: 0.953125, y: 0.421875 },
  { x: 0.953125, y: 0.421875 },
  { x: 0.984375, y: 0.421875 },
  { x: 0.984375, y: 0.421875 },
  { x: 0.015625, y: 0.453125 },
  { x: 0.015625, y: 0.453125 },
  { x: 0.046875, y: 0.453125 },
  { x: 0.046875, y: 0.453125 },
  { x: 0.078125, y: 0.453125 },
  { x: 0.078125, y: 0.453125 },
  { x: 0.109375, y: 0.453125 },
  { x: 0.109375, y: 0.453125 },
  { x: 0.140625, y: 0.453125 },
  { x: 0.140625, y: 0.453125 },
  { x: 0.171875, y: 0.453125 },
  { x: 0.171875, y: 0.453125 },
  { x: 0.203125, y: 0.453125 },
  { x: 0.203125, y: 0.453125 },
  { x: 0.234375, y: 0.453125 },
  { x: 0.234375, y: 0.453125 },
  { x: 0.265625, y: 0.453125 },
  { x: 0.265625, y: 0.453125 },
  { x: 0.296875, y: 0.453125 },
  { x: 0.296875, y: 0.453125 },
  { x: 0.328125, y: 0.453125 },
  { x: 0.328125, y: 0.453125 },
  { x: 0.359375, y: 0.453125 },
  { x: 0.359375, y: 0.453125 },
  { x: 0.390625, y: 0.453125 },
  { x: 0.390625, y: 0.453125 },
  { x: 0.421875, y: 0.453125 },
  { x: 0.421875, y: 0.453125 },
  { x: 0.453125, y: 0.453125 },
  { x: 0.453125, y: 0.453125 },
  { x: 0.484375, y: 0.453125 },
  { x: 0.484375, y: 0.453125 },
  { x: 0.515625, y: 0.453125 },
  { x: 0.515625, y: 0.453125 },
  { x: 0.546875, y: 0.453125 },
  { x: 0.546875, y: 0.453125 },
  { x: 0.578125, y: 0.453125 },
  { x: 0.578125, y: 0.453125 },
  { x: 0.609375, y: 0.453125 },
  { x: 0.609375, y: 0.453125 },
  { x: 0.640625, y: 0.453125 },
  { x: 0.640625, y: 0.453125 },
  { x: 0.671875, y: 0.453125 },
  { x: 0.671875, y: 0.453125 },
  { x: 0.703125, y: 0.453125 },
  { x: 0.703125, y: 0.453125 },
  { x: 0.734375, y: 0.453125 },
  { x: 0.734375, y: 0.453125 },
  { x: 0.765625, y: 0.453125 },
  { x: 0.765625, y: 0.453125 },
  { x: 0.796875, y: 0.453125 },
  { x: 0.796875, y: 0.453125 },
  { x: 0.828125, y: 0.453125 },
  { x: 0.828125, y: 0.453125 },
  { x: 0.859375, y: 0.453125 },
  { x: 0.859375, y: 0.453125 },
  { x: 0.890625, y: 0.453125 },
  { x: 0.890625, y: 0.453125 },
  { x: 0.921875, y: 0.453125 },
  { x: 0.921875, y: 0.453125 },
  { x: 0.953125, y: 0.453125 },
  { x: 0.953125, y: 0.453125 },
  { x: 0.984375, y: 0.453125 },
  { x: 0.984375, y: 0.453125 },
  { x: 0.015625, y: 0.484375 },
  { x: 0.015625, y: 0.484375 },
  { x: 0.046875, y: 0.484375 },
  { x: 0.046875, y: 0.484375 },
  { x: 0.078125, y: 0.484375 },
  { x: 0.078125, y: 0.484375 },
  { x: 0.109375, y: 0.484375 },
  { x: 0.109375, y: 0.484375 },
  { x: 0.140625, y: 0.484375 },
  { x: 0.140625, y: 0.484375 },
  { x: 0.171875, y: 0.484375 },
  { x: 0.171875, y: 0.484375 },
  { x: 0.203125, y: 0.484375 },
  { x: 0.203125, y: 0.484375 },
  { x: 0.234375, y: 0.484375 },
  { x: 0.234375, y: 0.484375 },
  { x: 0.265625, y: 0.484375 },
  { x: 0.265625, y: 0.484375 },
  { x: 0.296875, y: 0.484375 },
  { x: 0.296875, y: 0.484375 },
  { x: 0.328125, y: 0.484375 },
  { x: 0.328125, y: 0.484375 },
  { x: 0.359375, y: 0.484375 },
  { x: 0.359375, y: 0.484375 },
  { x: 0.390625, y: 0.484375 },
  { x: 0.390625, y: 0.484375 },
  { x: 0.421875, y: 0.484375 },
  { x: 0.421875, y: 0.484375 },
  { x: 0.453125, y: 0.484375 },
  { x: 0.453125, y: 0.484375 },
  { x: 0.484375, y: 0.484375 },
  { x: 0.484375, y: 0.484375 },
  { x: 0.515625, y: 0.484375 },
  { x: 0.515625, y: 0.484375 },
  { x: 0.546875, y: 0.484375 },
  { x: 0.546875, y: 0.484375 },
  { x: 0.578125, y: 0.484375 },
  { x: 0.578125, y: 0.484375 },
  { x: 0.609375, y: 0.484375 },
  { x: 0.609375, y: 0.484375 },
  { x: 0.640625, y: 0.484375 },
  { x: 0.640625, y: 0.484375 },
  { x: 0.671875, y: 0.484375 },
  { x: 0.671875, y: 0.484375 },
  { x: 0.703125, y: 0.484375 },
  { x: 0.703125, y: 0.484375 },
  { x: 0.734375, y: 0.484375 },
  { x: 0.734375, y: 0.484375 },
  { x: 0.765625, y: 0.484375 },
  { x: 0.765625, y: 0.484375 },
  { x: 0.796875, y: 0.484375 },
  { x: 0.796875, y: 0.484375 },
  { x: 0.828125, y: 0.484375 },
  { x: 0.828125, y: 0.484375 },
  { x: 0.859375, y: 0.484375 },
  { x: 0.859375, y: 0.484375 },
  { x: 0.890625, y: 0.484375 },
  { x: 0.890625, y: 0.484375 },
  { x: 0.921875, y: 0.484375 },
  { x: 0.921875, y: 0.484375 },
  { x: 0.953125, y: 0.484375 },
  { x: 0.953125, y: 0.484375 },
  { x: 0.984375, y: 0.484375 },
  { x: 0.984375, y: 0.484375 },
  { x: 0.015625, y: 0.515625 },
  { x: 0.015625, y: 0.515625 },
  { x: 0.046875, y: 0.515625 },
  { x: 0.046875, y: 0.515625 },
  { x: 0.078125, y: 0.515625 },
  { x: 0.078125, y: 0.515625 },
  { x: 0.109375, y: 0.515625 },
  { x: 0.109375, y: 0.515625 },
  { x: 0.140625, y: 0.515625 },
  { x: 0.140625, y: 0.515625 },
  { x: 0.171875, y: 0.515625 },
  { x: 0.171875, y: 0.515625 },
  { x: 0.203125, y: 0.515625 },
  { x: 0.203125, y: 0.515625 },
  { x: 0.234375, y: 0.515625 },
  { x: 0.234375, y: 0.515625 },
  { x: 0.265625, y: 0.515625 },
  { x: 0.265625, y: 0.515625 },
  { x: 0.296875, y: 0.515625 },
  { x: 0.296875, y: 0.515625 },
  { x: 0.328125, y: 0.515625 },
  { x: 0.328125, y: 0.515625 },
  { x: 0.359375, y: 0.515625 },
  { x: 0.359375, y: 0.515625 },
  { x: 0.390625, y: 0.515625 },
  { x: 0.390625, y: 0.515625 },
  { x: 0.421875, y: 0.515625 },
  { x: 0.421875, y: 0.515625 },
  { x: 0.453125, y: 0.515625 },
  { x: 0.453125, y: 0.515625 },
  { x: 0.484375, y: 0.515625 },
  { x: 0.484375, y: 0.515625 },
  { x: 0.515625, y: 0.515625 },
  { x: 0.515625, y: 0.515625 },
  { x: 0.546875, y: 0.515625 },
  { x: 0.546875, y: 0.515625 },
  { x: 0.578125, y: 0.515625 },
  { x: 0.578125, y: 0.515625 },
  { x: 0.609375, y: 0.515625 },
  { x: 0.609375, y: 0.515625 },
  { x: 0.640625, y: 0.515625 },
  { x: 0.640625, y: 0.515625 },
  { x: 0.671875, y: 0.515625 },
  { x: 0.671875, y: 0.515625 },
  { x: 0.703125, y: 0.515625 },
  { x: 0.703125, y: 0.515625 },
  { x: 0.734375, y: 0.515625 },
  { x: 0.734375, y: 0.515625 },
  { x: 0.765625, y: 0.515625 },
  { x: 0.765625, y: 0.515625 },
  { x: 0.796875, y: 0.515625 },
  { x: 0.796875, y: 0.515625 },
  { x: 0.828125, y: 0.515625 },
  { x: 0.828125, y: 0.515625 },
  { x: 0.859375, y: 0.515625 },
  { x: 0.859375, y: 0.515625 },
  { x: 0.890625, y: 0.515625 },
  { x: 0.890625, y: 0.515625 },
  { x: 0.921875, y: 0.515625 },
  { x: 0.921875, y: 0.515625 },
  { x: 0.953125, y: 0.515625 },
  { x: 0.953125, y: 0.515625 },
  { x: 0.984375, y: 0.515625 },
  { x: 0.984375, y: 0.515625 },
  { x: 0.015625, y: 0.546875 },
  { x: 0.015625, y: 0.546875 },
  { x: 0.046875, y: 0.546875 },
  { x: 0.046875, y: 0.546875 },
  { x: 0.078125, y: 0.546875 },
  { x: 0.078125, y: 0.546875 },
  { x: 0.109375, y: 0.546875 },
  { x: 0.109375, y: 0.546875 },
  { x: 0.140625, y: 0.546875 },
  { x: 0.140625, y: 0.546875 },
  { x: 0.171875, y: 0.546875 },
  { x: 0.171875, y: 0.546875 },
  { x: 0.203125, y: 0.546875 },
  { x: 0.203125, y: 0.546875 },
  { x: 0.234375, y: 0.546875 },
  { x: 0.234375, y: 0.546875 },
  { x: 0.265625, y: 0.546875 },
  { x: 0.265625, y: 0.546875 },
  { x: 0.296875, y: 0.546875 },
  { x: 0.296875, y: 0.546875 },
  { x: 0.328125, y: 0.546875 },
  { x: 0.328125, y: 0.546875 },
  { x: 0.359375, y: 0.546875 },
  { x: 0.359375, y: 0.546875 },
  { x: 0.390625, y: 0.546875 },
  { x: 0.390625, y: 0.546875 },
  { x: 0.421875, y: 0.546875 },
  { x: 0.421875, y: 0.546875 },
  { x: 0.453125, y: 0.546875 },
  { x: 0.453125, y: 0.546875 },
  { x: 0.484375, y: 0.546875 },
  { x: 0.484375, y: 0.546875 },
  { x: 0.515625, y: 0.546875 },
  { x: 0.515625, y: 0.546875 },
  { x: 0.546875, y: 0.546875 },
  { x: 0.546875, y: 0.546875 },
  { x: 0.578125, y: 0.546875 },
  { x: 0.578125, y: 0.546875 },
  { x: 0.609375, y: 0.546875 },
  { x: 0.609375, y: 0.546875 },
  { x: 0.640625, y: 0.546875 },
  { x: 0.640625, y: 0.546875 },
  { x: 0.671875, y: 0.546875 },
  { x: 0.671875, y: 0.546875 },
  { x: 0.703125, y: 0.546875 },
  { x: 0.703125, y: 0.546875 },
  { x: 0.734375, y: 0.546875 },
  { x: 0.734375, y: 0.546875 },
  { x: 0.765625, y: 0.546875 },
  { x: 0.765625, y: 0.546875 },
  { x: 0.796875, y: 0.546875 },
  { x: 0.796875, y: 0.546875 },
  { x: 0.828125, y: 0.546875 },
  { x: 0.828125, y: 0.546875 },
  { x: 0.859375, y: 0.546875 },
  { x: 0.859375, y: 0.546875 },
  { x: 0.890625, y: 0.546875 },
  { x: 0.890625, y: 0.546875 },
  { x: 0.921875, y: 0.546875 },
  { x: 0.921875, y: 0.546875 },
  { x: 0.953125, y: 0.546875 },
  { x: 0.953125, y: 0.546875 },
  { x: 0.984375, y: 0.546875 },
  { x: 0.984375, y: 0.546875 },
  { x: 0.015625, y: 0.578125 },
  { x: 0.015625, y: 0.578125 },
  { x: 0.046875, y: 0.578125 },
  { x: 0.046875, y: 0.578125 },
  { x: 0.078125, y: 0.578125 },
  { x: 0.078125, y: 0.578125 },
  { x: 0.109375, y: 0.578125 },
  { x: 0.109375, y: 0.578125 },
  { x: 0.140625, y: 0.578125 },
  { x: 0.140625, y: 0.578125 },
  { x: 0.171875, y: 0.578125 },
  { x: 0.171875, y: 0.578125 },
  { x: 0.203125, y: 0.578125 },
  { x: 0.203125, y: 0.578125 },
  { x: 0.234375, y: 0.578125 },
  { x: 0.234375, y: 0.578125 },
  { x: 0.265625, y: 0.578125 },
  { x: 0.265625, y: 0.578125 },
  { x: 0.296875, y: 0.578125 },
  { x: 0.296875, y: 0.578125 },
  { x: 0.328125, y: 0.578125 },
  { x: 0.328125, y: 0.578125 },
  { x: 0.359375, y: 0.578125 },
  { x: 0.359375, y: 0.578125 },
  { x: 0.390625, y: 0.578125 },
  { x: 0.390625, y: 0.578125 },
  { x: 0.421875, y: 0.578125 },
  { x: 0.421875, y: 0.578125 },
  { x: 0.453125, y: 0.578125 },
  { x: 0.453125, y: 0.578125 },
  { x: 0.484375, y: 0.578125 },
  { x: 0.484375, y: 0.578125 },
  { x: 0.515625, y: 0.578125 },
  { x: 0.515625, y: 0.578125 },
  { x: 0.546875, y: 0.578125 },
  { x: 0.546875, y: 0.578125 },
  { x: 0.578125, y: 0.578125 },
  { x: 0.578125, y: 0.578125 },
  { x: 0.609375, y: 0.578125 },
  { x: 0.609375, y: 0.578125 },
  { x: 0.640625, y: 0.578125 },
  { x: 0.640625, y: 0.578125 },
  { x: 0.671875, y: 0.578125 },
  { x: 0.671875, y: 0.578125 },
  { x: 0.703125, y: 0.578125 },
  { x: 0.703125, y: 0.578125 },
  { x: 0.734375, y: 0.578125 },
  { x: 0.734375, y: 0.578125 },
  { x: 0.765625, y: 0.578125 },
  { x: 0.765625, y: 0.578125 },
  { x: 0.796875, y: 0.578125 },
  { x: 0.796875, y: 0.578125 },
  { x: 0.828125, y: 0.578125 },
  { x: 0.828125, y: 0.578125 },
  { x: 0.859375, y: 0.578125 },
  { x: 0.859375, y: 0.578125 },
  { x: 0.890625, y: 0.578125 },
  { x: 0.890625, y: 0.578125 },
  { x: 0.921875, y: 0.578125 },
  { x: 0.921875, y: 0.578125 },
  { x: 0.953125, y: 0.578125 },
  { x: 0.953125, y: 0.578125 },
  { x: 0.984375, y: 0.578125 },
  { x: 0.984375, y: 0.578125 },
  { x: 0.015625, y: 0.609375 },
  { x: 0.015625, y: 0.609375 },
  { x: 0.046875, y: 0.609375 },
  { x: 0.046875, y: 0.609375 },
  { x: 0.078125, y: 0.609375 },
  { x: 0.078125, y: 0.609375 },
  { x: 0.109375, y: 0.609375 },
  { x: 0.109375, y: 0.609375 },
  { x: 0.140625, y: 0.609375 },
  { x: 0.140625, y: 0.609375 },
  { x: 0.171875, y: 0.609375 },
  { x: 0.171875, y: 0.609375 },
  { x: 0.203125, y: 0.609375 },
  { x: 0.203125, y: 0.609375 },
  { x: 0.234375, y: 0.609375 },
  { x: 0.234375, y: 0.609375 },
  { x: 0.265625, y: 0.609375 },
  { x: 0.265625, y: 0.609375 },
  { x: 0.296875, y: 0.609375 },
  { x: 0.296875, y: 0.609375 },
  { x: 0.328125, y: 0.609375 },
  { x: 0.328125, y: 0.609375 },
  { x: 0.359375, y: 0.609375 },
  { x: 0.359375, y: 0.609375 },
  { x: 0.390625, y: 0.609375 },
  { x: 0.390625, y: 0.609375 },
  { x: 0.421875, y: 0.609375 },
  { x: 0.421875, y: 0.609375 },
  { x: 0.453125, y: 0.609375 },
  { x: 0.453125, y: 0.609375 },
  { x: 0.484375, y: 0.609375 },
  { x: 0.484375, y: 0.609375 },
  { x: 0.515625, y: 0.609375 },
  { x: 0.515625, y: 0.609375 },
  { x: 0.546875, y: 0.609375 },
  { x: 0.546875, y: 0.609375 },
  { x: 0.578125, y: 0.609375 },
  { x: 0.578125, y: 0.609375 },
  { x: 0.609375, y: 0.609375 },
  { x: 0.609375, y: 0.609375 },
  { x: 0.640625, y: 0.609375 },
  { x: 0.640625, y: 0.609375 },
  { x: 0.671875, y: 0.609375 },
  { x: 0.671875, y: 0.609375 },
  { x: 0.703125, y: 0.609375 },
  { x: 0.703125, y: 0.609375 },
  { x: 0.734375, y: 0.609375 },
  { x: 0.734375, y: 0.609375 },
  { x: 0.765625, y: 0.609375 },
  { x: 0.765625, y: 0.609375 },
  { x: 0.796875, y: 0.609375 },
  { x: 0.796875, y: 0.609375 },
  { x: 0.828125, y: 0.609375 },
  { x: 0.828125, y: 0.609375 },
  { x: 0.859375, y: 0.609375 },
  { x: 0.859375, y: 0.609375 },
  { x: 0.890625, y: 0.609375 },
  { x: 0.890625, y: 0.609375 },
  { x: 0.921875, y: 0.609375 },
  { x: 0.921875, y: 0.609375 },
  { x: 0.953125, y: 0.609375 },
  { x: 0.953125, y: 0.609375 },
  { x: 0.984375, y: 0.609375 },
  { x: 0.984375, y: 0.609375 },
  { x: 0.015625, y: 0.640625 },
  { x: 0.015625, y: 0.640625 },
  { x: 0.046875, y: 0.640625 },
  { x: 0.046875, y: 0.640625 },
  { x: 0.078125, y: 0.640625 },
  { x: 0.078125, y: 0.640625 },
  { x: 0.109375, y: 0.640625 },
  { x: 0.109375, y: 0.640625 },
  { x: 0.140625, y: 0.640625 },
  { x: 0.140625, y: 0.640625 },
  { x: 0.171875, y: 0.640625 },
  { x: 0.171875, y: 0.640625 },
  { x: 0.203125, y: 0.640625 },
  { x: 0.203125, y: 0.640625 },
  { x: 0.234375, y: 0.640625 },
  { x: 0.234375, y: 0.640625 },
  { x: 0.265625, y: 0.640625 },
  { x: 0.265625, y: 0.640625 },
  { x: 0.296875, y: 0.640625 },
  { x: 0.296875, y: 0.640625 },
  { x: 0.328125, y: 0.640625 },
  { x: 0.328125, y: 0.640625 },
  { x: 0.359375, y: 0.640625 },
  { x: 0.359375, y: 0.640625 },
  { x: 0.390625, y: 0.640625 },
  { x: 0.390625, y: 0.640625 },
  { x: 0.421875, y: 0.640625 },
  { x: 0.421875, y: 0.640625 },
  { x: 0.453125, y: 0.640625 },
  { x: 0.453125, y: 0.640625 },
  { x: 0.484375, y: 0.640625 },
  { x: 0.484375, y: 0.640625 },
  { x: 0.515625, y: 0.640625 },
  { x: 0.515625, y: 0.640625 },
  { x: 0.546875, y: 0.640625 },
  { x: 0.546875, y: 0.640625 },
  { x: 0.578125, y: 0.640625 },
  { x: 0.578125, y: 0.640625 },
  { x: 0.609375, y: 0.640625 },
  { x: 0.609375, y: 0.640625 },
  { x: 0.640625, y: 0.640625 },
  { x: 0.640625, y: 0.640625 },
  { x: 0.671875, y: 0.640625 },
  { x: 0.671875, y: 0.640625 },
  { x: 0.703125, y: 0.640625 },
  { x: 0.703125, y: 0.640625 },
  { x: 0.734375, y: 0.640625 },
  { x: 0.734375, y: 0.640625 },
  { x: 0.765625, y: 0.640625 },
  { x: 0.765625, y: 0.640625 },
  { x: 0.796875, y: 0.640625 },
  { x: 0.796875, y: 0.640625 },
  { x: 0.828125, y: 0.640625 },
  { x: 0.828125, y: 0.640625 },
  { x: 0.859375, y: 0.640625 },
  { x: 0.859375, y: 0.640625 },
  { x: 0.890625, y: 0.640625 },
  { x: 0.890625, y: 0.640625 },
  { x: 0.921875, y: 0.640625 },
  { x: 0.921875, y: 0.640625 },
  { x: 0.953125, y: 0.640625 },
  { x: 0.953125, y: 0.640625 },
  { x: 0.984375, y: 0.640625 },
  { x: 0.984375, y: 0.640625 },
  { x: 0.015625, y: 0.671875 },
  { x: 0.015625, y: 0.671875 },
  { x: 0.046875, y: 0.671875 },
  { x: 0.046875, y: 0.671875 },
  { x: 0.078125, y: 0.671875 },
  { x: 0.078125, y: 0.671875 },
  { x: 0.109375, y: 0.671875 },
  { x: 0.109375, y: 0.671875 },
  { x: 0.140625, y: 0.671875 },
  { x: 0.140625, y: 0.671875 },
  { x: 0.171875, y: 0.671875 },
  { x: 0.171875, y: 0.671875 },
  { x: 0.203125, y: 0.671875 },
  { x: 0.203125, y: 0.671875 },
  { x: 0.234375, y: 0.671875 },
  { x: 0.234375, y: 0.671875 },
  { x: 0.265625, y: 0.671875 },
  { x: 0.265625, y: 0.671875 },
  { x: 0.296875, y: 0.671875 },
  { x: 0.296875, y: 0.671875 },
  { x: 0.328125, y: 0.671875 },
  { x: 0.328125, y: 0.671875 },
  { x: 0.359375, y: 0.671875 },
  { x: 0.359375, y: 0.671875 },
  { x: 0.390625, y: 0.671875 },
  { x: 0.390625, y: 0.671875 },
  { x: 0.421875, y: 0.671875 },
  { x: 0.421875, y: 0.671875 },
  { x: 0.453125, y: 0.671875 },
  { x: 0.453125, y: 0.671875 },
  { x: 0.484375, y: 0.671875 },
  { x: 0.484375, y: 0.671875 },
  { x: 0.515625, y: 0.671875 },
  { x: 0.515625, y: 0.671875 },
  { x: 0.546875, y: 0.671875 },
  { x: 0.546875, y: 0.671875 },
  { x: 0.578125, y: 0.671875 },
  { x: 0.578125, y: 0.671875 },
  { x: 0.609375, y: 0.671875 },
  { x: 0.609375, y: 0.671875 },
  { x: 0.640625, y: 0.671875 },
  { x: 0.640625, y: 0.671875 },
  { x: 0.671875, y: 0.671875 },
  { x: 0.671875, y: 0.671875 },
  { x: 0.703125, y: 0.671875 },
  { x: 0.703125, y: 0.671875 },
  { x: 0.734375, y: 0.671875 },
  { x: 0.734375, y: 0.671875 },
  { x: 0.765625, y: 0.671875 },
  { x: 0.765625, y: 0.671875 },
  { x: 0.796875, y: 0.671875 },
  { x: 0.796875, y: 0.671875 },
  { x: 0.828125, y: 0.671875 },
  { x: 0.828125, y: 0.671875 },
  { x: 0.859375, y: 0.671875 },
  { x: 0.859375, y: 0.671875 },
  { x: 0.890625, y: 0.671875 },
  { x: 0.890625, y: 0.671875 },
  { x: 0.921875, y: 0.671875 },
  { x: 0.921875, y: 0.671875 },
  { x: 0.953125, y: 0.671875 },
  { x: 0.953125, y: 0.671875 },
  { x: 0.984375, y: 0.671875 },
  { x: 0.984375, y: 0.671875 },
  { x: 0.015625, y: 0.703125 },
  { x: 0.015625, y: 0.703125 },
  { x: 0.046875, y: 0.703125 },
  { x: 0.046875, y: 0.703125 },
  { x: 0.078125, y: 0.703125 },
  { x: 0.078125, y: 0.703125 },
  { x: 0.109375, y: 0.703125 },
  { x: 0.109375, y: 0.703125 },
  { x: 0.140625, y: 0.703125 },
  { x: 0.140625, y: 0.703125 },
  { x: 0.171875, y: 0.703125 },
  { x: 0.171875, y: 0.703125 },
  { x: 0.203125, y: 0.703125 },
  { x: 0.203125, y: 0.703125 },
  { x: 0.234375, y: 0.703125 },
  { x: 0.234375, y: 0.703125 },
  { x: 0.265625, y: 0.703125 },
  { x: 0.265625, y: 0.703125 },
  { x: 0.296875, y: 0.703125 },
  { x: 0.296875, y: 0.703125 },
  { x: 0.328125, y: 0.703125 },
  { x: 0.328125, y: 0.703125 },
  { x: 0.359375, y: 0.703125 },
  { x: 0.359375, y: 0.703125 },
  { x: 0.390625, y: 0.703125 },
  { x: 0.390625, y: 0.703125 },
  { x: 0.421875, y: 0.703125 },
  { x: 0.421875, y: 0.703125 },
  { x: 0.453125, y: 0.703125 },
  { x: 0.453125, y: 0.703125 },
  { x: 0.484375, y: 0.703125 },
  { x: 0.484375, y: 0.703125 },
  { x: 0.515625, y: 0.703125 },
  { x: 0.515625, y: 0.703125 },
  { x: 0.546875, y: 0.703125 },
  { x: 0.546875, y: 0.703125 },
  { x: 0.578125, y: 0.703125 },
  { x: 0.578125, y: 0.703125 },
  { x: 0.609375, y: 0.703125 },
  { x: 0.609375, y: 0.703125 },
  { x: 0.640625, y: 0.703125 },
  { x: 0.640625, y: 0.703125 },
  { x: 0.671875, y: 0.703125 },
  { x: 0.671875, y: 0.703125 },
  { x: 0.703125, y: 0.703125 },
  { x: 0.703125, y: 0.703125 },
  { x: 0.734375, y: 0.703125 },
  { x: 0.734375, y: 0.703125 },
  { x: 0.765625, y: 0.703125 },
  { x: 0.765625, y: 0.703125 },
  { x: 0.796875, y: 0.703125 },
  { x: 0.796875, y: 0.703125 },
  { x: 0.828125, y: 0.703125 },
  { x: 0.828125, y: 0.703125 },
  { x: 0.859375, y: 0.703125 },
  { x: 0.859375, y: 0.703125 },
  { x: 0.890625, y: 0.703125 },
  { x: 0.890625, y: 0.703125 },
  { x: 0.921875, y: 0.703125 },
  { x: 0.921875, y: 0.703125 },
  { x: 0.953125, y: 0.703125 },
  { x: 0.953125, y: 0.703125 },
  { x: 0.984375, y: 0.703125 },
  { x: 0.984375, y: 0.703125 },
  { x: 0.015625, y: 0.734375 },
  { x: 0.015625, y: 0.734375 },
  { x: 0.046875, y: 0.734375 },
  { x: 0.046875, y: 0.734375 },
  { x: 0.078125, y: 0.734375 },
  { x: 0.078125, y: 0.734375 },
  { x: 0.109375, y: 0.734375 },
  { x: 0.109375, y: 0.734375 },
  { x: 0.140625, y: 0.734375 },
  { x: 0.140625, y: 0.734375 },
  { x: 0.171875, y: 0.734375 },
  { x: 0.171875, y: 0.734375 },
  { x: 0.203125, y: 0.734375 },
  { x: 0.203125, y: 0.734375 },
  { x: 0.234375, y: 0.734375 },
  { x: 0.234375, y: 0.734375 },
  { x: 0.265625, y: 0.734375 },
  { x: 0.265625, y: 0.734375 },
  { x: 0.296875, y: 0.734375 },
  { x: 0.296875, y: 0.734375 },
  { x: 0.328125, y: 0.734375 },
  { x: 0.328125, y: 0.734375 },
  { x: 0.359375, y: 0.734375 },
  { x: 0.359375, y: 0.734375 },
  { x: 0.390625, y: 0.734375 },
  { x: 0.390625, y: 0.734375 },
  { x: 0.421875, y: 0.734375 },
  { x: 0.421875, y: 0.734375 },
  { x: 0.453125, y: 0.734375 },
  { x: 0.453125, y: 0.734375 },
  { x: 0.484375, y: 0.734375 },
  { x: 0.484375, y: 0.734375 },
  { x: 0.515625, y: 0.734375 },
  { x: 0.515625, y: 0.734375 },
  { x: 0.546875, y: 0.734375 },
  { x: 0.546875, y: 0.734375 },
  { x: 0.578125, y: 0.734375 },
  { x: 0.578125, y: 0.734375 },
  { x: 0.609375, y: 0.734375 },
  { x: 0.609375, y: 0.734375 },
  { x: 0.640625, y: 0.734375 },
  { x: 0.640625, y: 0.734375 },
  { x: 0.671875, y: 0.734375 },
  { x: 0.671875, y: 0.734375 },
  { x: 0.703125, y: 0.734375 },
  { x: 0.703125, y: 0.734375 },
  { x: 0.734375, y: 0.734375 },
  { x: 0.734375, y: 0.734375 },
  { x: 0.765625, y: 0.734375 },
  { x: 0.765625, y: 0.734375 },
  { x: 0.796875, y: 0.734375 },
  { x: 0.796875, y: 0.734375 },
  { x: 0.828125, y: 0.734375 },
  { x: 0.828125, y: 0.734375 },
  { x: 0.859375, y: 0.734375 },
  { x: 0.859375, y: 0.734375 },
  { x: 0.890625, y: 0.734375 },
  { x: 0.890625, y: 0.734375 },
  { x: 0.921875, y: 0.734375 },
  { x: 0.921875, y: 0.734375 },
  { x: 0.953125, y: 0.734375 },
  { x: 0.953125, y: 0.734375 },
  { x: 0.984375, y: 0.734375 },
  { x: 0.984375, y: 0.734375 },
  { x: 0.015625, y: 0.765625 },
  { x: 0.015625, y: 0.765625 },
  { x: 0.046875, y: 0.765625 },
  { x: 0.046875, y: 0.765625 },
  { x: 0.078125, y: 0.765625 },
  { x: 0.078125, y: 0.765625 },
  { x: 0.109375, y: 0.765625 },
  { x: 0.109375, y: 0.765625 },
  { x: 0.140625, y: 0.765625 },
  { x: 0.140625, y: 0.765625 },
  { x: 0.171875, y: 0.765625 },
  { x: 0.171875, y: 0.765625 },
  { x: 0.203125, y: 0.765625 },
  { x: 0.203125, y: 0.765625 },
  { x: 0.234375, y: 0.765625 },
  { x: 0.234375, y: 0.765625 },
  { x: 0.265625, y: 0.765625 },
  { x: 0.265625, y: 0.765625 },
  { x: 0.296875, y: 0.765625 },
  { x: 0.296875, y: 0.765625 },
  { x: 0.328125, y: 0.765625 },
  { x: 0.328125, y: 0.765625 },
  { x: 0.359375, y: 0.765625 },
  { x: 0.359375, y: 0.765625 },
  { x: 0.390625, y: 0.765625 },
  { x: 0.390625, y: 0.765625 },
  { x: 0.421875, y: 0.765625 },
  { x: 0.421875, y: 0.765625 },
  { x: 0.453125, y: 0.765625 },
  { x: 0.453125, y: 0.765625 },
  { x: 0.484375, y: 0.765625 },
  { x: 0.484375, y: 0.765625 },
  { x: 0.515625, y: 0.765625 },
  { x: 0.515625, y: 0.765625 },
  { x: 0.546875, y: 0.765625 },
  { x: 0.546875, y: 0.765625 },
  { x: 0.578125, y: 0.765625 },
  { x: 0.578125, y: 0.765625 },
  { x: 0.609375, y: 0.765625 },
  { x: 0.609375, y: 0.765625 },
  { x: 0.640625, y: 0.765625 },
  { x: 0.640625, y: 0.765625 },
  { x: 0.671875, y: 0.765625 },
  { x: 0.671875, y: 0.765625 },
  { x: 0.703125, y: 0.765625 },
  { x: 0.703125, y: 0.765625 },
  { x: 0.734375, y: 0.765625 },
  { x: 0.734375, y: 0.765625 },
  { x: 0.765625, y: 0.765625 },
  { x: 0.765625, y: 0.765625 },
  { x: 0.796875, y: 0.765625 },
  { x: 0.796875, y: 0.765625 },
  { x: 0.828125, y: 0.765625 },
  { x: 0.828125, y: 0.765625 },
  { x: 0.859375, y: 0.765625 },
  { x: 0.859375, y: 0.765625 },
  { x: 0.890625, y: 0.765625 },
  { x: 0.890625, y: 0.765625 },
  { x: 0.921875, y: 0.765625 },
  { x: 0.921875, y: 0.765625 },
  { x: 0.953125, y: 0.765625 },
  { x: 0.953125, y: 0.765625 },
  { x: 0.984375, y: 0.765625 },
  { x: 0.984375, y: 0.765625 },
  { x: 0.015625, y: 0.796875 },
  { x: 0.015625, y: 0.796875 },
  { x: 0.046875, y: 0.796875 },
  { x: 0.046875, y: 0.796875 },
  { x: 0.078125, y: 0.796875 },
  { x: 0.078125, y: 0.796875 },
  { x: 0.109375, y: 0.796875 },
  { x: 0.109375, y: 0.796875 },
  { x: 0.140625, y: 0.796875 },
  { x: 0.140625, y: 0.796875 },
  { x: 0.171875, y: 0.796875 },
  { x: 0.171875, y: 0.796875 },
  { x: 0.203125, y: 0.796875 },
  { x: 0.203125, y: 0.796875 },
  { x: 0.234375, y: 0.796875 },
  { x: 0.234375, y: 0.796875 },
  { x: 0.265625, y: 0.796875 },
  { x: 0.265625, y: 0.796875 },
  { x: 0.296875, y: 0.796875 },
  { x: 0.296875, y: 0.796875 },
  { x: 0.328125, y: 0.796875 },
  { x: 0.328125, y: 0.796875 },
  { x: 0.359375, y: 0.796875 },
  { x: 0.359375, y: 0.796875 },
  { x: 0.390625, y: 0.796875 },
  { x: 0.390625, y: 0.796875 },
  { x: 0.421875, y: 0.796875 },
  { x: 0.421875, y: 0.796875 },
  { x: 0.453125, y: 0.796875 },
  { x: 0.453125, y: 0.796875 },
  { x: 0.484375, y: 0.796875 },
  { x: 0.484375, y: 0.796875 },
  { x: 0.515625, y: 0.796875 },
  { x: 0.515625, y: 0.796875 },
  { x: 0.546875, y: 0.796875 },
  { x: 0.546875, y: 0.796875 },
  { x: 0.578125, y: 0.796875 },
  { x: 0.578125, y: 0.796875 },
  { x: 0.609375, y: 0.796875 },
  { x: 0.609375, y: 0.796875 },
  { x: 0.640625, y: 0.796875 },
  { x: 0.640625, y: 0.796875 },
  { x: 0.671875, y: 0.796875 },
  { x: 0.671875, y: 0.796875 },
  { x: 0.703125, y: 0.796875 },
  { x: 0.703125, y: 0.796875 },
  { x: 0.734375, y: 0.796875 },
  { x: 0.734375, y: 0.796875 },
  { x: 0.765625, y: 0.796875 },
  { x: 0.765625, y: 0.796875 },
  { x: 0.796875, y: 0.796875 },
  { x: 0.796875, y: 0.796875 },
  { x: 0.828125, y: 0.796875 },
  { x: 0.828125, y: 0.796875 },
  { x: 0.859375, y: 0.796875 },
  { x: 0.859375, y: 0.796875 },
  { x: 0.890625, y: 0.796875 },
  { x: 0.890625, y: 0.796875 },
  { x: 0.921875, y: 0.796875 },
  { x: 0.921875, y: 0.796875 },
  { x: 0.953125, y: 0.796875 },
  { x: 0.953125, y: 0.796875 },
  { x: 0.984375, y: 0.796875 },
  { x: 0.984375, y: 0.796875 },
  { x: 0.015625, y: 0.828125 },
  { x: 0.015625, y: 0.828125 },
  { x: 0.046875, y: 0.828125 },
  { x: 0.046875, y: 0.828125 },
  { x: 0.078125, y: 0.828125 },
  { x: 0.078125, y: 0.828125 },
  { x: 0.109375, y: 0.828125 },
  { x: 0.109375, y: 0.828125 },
  { x: 0.140625, y: 0.828125 },
  { x: 0.140625, y: 0.828125 },
  { x: 0.171875, y: 0.828125 },
  { x: 0.171875, y: 0.828125 },
  { x: 0.203125, y: 0.828125 },
  { x: 0.203125, y: 0.828125 },
  { x: 0.234375, y: 0.828125 },
  { x: 0.234375, y: 0.828125 },
  { x: 0.265625, y: 0.828125 },
  { x: 0.265625, y: 0.828125 },
  { x: 0.296875, y: 0.828125 },
  { x: 0.296875, y: 0.828125 },
  { x: 0.328125, y: 0.828125 },
  { x: 0.328125, y: 0.828125 },
  { x: 0.359375, y: 0.828125 },
  { x: 0.359375, y: 0.828125 },
  { x: 0.390625, y: 0.828125 },
  { x: 0.390625, y: 0.828125 },
  { x: 0.421875, y: 0.828125 },
  { x: 0.421875, y: 0.828125 },
  { x: 0.453125, y: 0.828125 },
  { x: 0.453125, y: 0.828125 },
  { x: 0.484375, y: 0.828125 },
  { x: 0.484375, y: 0.828125 },
  { x: 0.515625, y: 0.828125 },
  { x: 0.515625, y: 0.828125 },
  { x: 0.546875, y: 0.828125 },
  { x: 0.546875, y: 0.828125 },
  { x: 0.578125, y: 0.828125 },
  { x: 0.578125, y: 0.828125 },
  { x: 0.609375, y: 0.828125 },
  { x: 0.609375, y: 0.828125 },
  { x: 0.640625, y: 0.828125 },
  { x: 0.640625, y: 0.828125 },
  { x: 0.671875, y: 0.828125 },
  { x: 0.671875, y: 0.828125 },
  { x: 0.703125, y: 0.828125 },
  { x: 0.703125, y: 0.828125 },
  { x: 0.734375, y: 0.828125 },
  { x: 0.734375, y: 0.828125 },
  { x: 0.765625, y: 0.828125 },
  { x: 0.765625, y: 0.828125 },
  { x: 0.796875, y: 0.828125 },
  { x: 0.796875, y: 0.828125 },
  { x: 0.828125, y: 0.828125 },
  { x: 0.828125, y: 0.828125 },
  { x: 0.859375, y: 0.828125 },
  { x: 0.859375, y: 0.828125 },
  { x: 0.890625, y: 0.828125 },
  { x: 0.890625, y: 0.828125 },
  { x: 0.921875, y: 0.828125 },
  { x: 0.921875, y: 0.828125 },
  { x: 0.953125, y: 0.828125 },
  { x: 0.953125, y: 0.828125 },
  { x: 0.984375, y: 0.828125 },
  { x: 0.984375, y: 0.828125 },
  { x: 0.015625, y: 0.859375 },
  { x: 0.015625, y: 0.859375 },
  { x: 0.046875, y: 0.859375 },
  { x: 0.046875, y: 0.859375 },
  { x: 0.078125, y: 0.859375 },
  { x: 0.078125, y: 0.859375 },
  { x: 0.109375, y: 0.859375 },
  { x: 0.109375, y: 0.859375 },
  { x: 0.140625, y: 0.859375 },
  { x: 0.140625, y: 0.859375 },
  { x: 0.171875, y: 0.859375 },
  { x: 0.171875, y: 0.859375 },
  { x: 0.203125, y: 0.859375 },
  { x: 0.203125, y: 0.859375 },
  { x: 0.234375, y: 0.859375 },
  { x: 0.234375, y: 0.859375 },
  { x: 0.265625, y: 0.859375 },
  { x: 0.265625, y: 0.859375 },
  { x: 0.296875, y: 0.859375 },
  { x: 0.296875, y: 0.859375 },
  { x: 0.328125, y: 0.859375 },
  { x: 0.328125, y: 0.859375 },
  { x: 0.359375, y: 0.859375 },
  { x: 0.359375, y: 0.859375 },
  { x: 0.390625, y: 0.859375 },
  { x: 0.390625, y: 0.859375 },
  { x: 0.421875, y: 0.859375 },
  { x: 0.421875, y: 0.859375 },
  { x: 0.453125, y: 0.859375 },
  { x: 0.453125, y: 0.859375 },
  { x: 0.484375, y: 0.859375 },
  { x: 0.484375, y: 0.859375 },
  { x: 0.515625, y: 0.859375 },
  { x: 0.515625, y: 0.859375 },
  { x: 0.546875, y: 0.859375 },
  { x: 0.546875, y: 0.859375 },
  { x: 0.578125, y: 0.859375 },
  { x: 0.578125, y: 0.859375 },
  { x: 0.609375, y: 0.859375 },
  { x: 0.609375, y: 0.859375 },
  { x: 0.640625, y: 0.859375 },
  { x: 0.640625, y: 0.859375 },
  { x: 0.671875, y: 0.859375 },
  { x: 0.671875, y: 0.859375 },
  { x: 0.703125, y: 0.859375 },
  { x: 0.703125, y: 0.859375 },
  { x: 0.734375, y: 0.859375 },
  { x: 0.734375, y: 0.859375 },
  { x: 0.765625, y: 0.859375 },
  { x: 0.765625, y: 0.859375 },
  { x: 0.796875, y: 0.859375 },
  { x: 0.796875, y: 0.859375 },
  { x: 0.828125, y: 0.859375 },
  { x: 0.828125, y: 0.859375 },
  { x: 0.859375, y: 0.859375 },
  { x: 0.859375, y: 0.859375 },
  { x: 0.890625, y: 0.859375 },
  { x: 0.890625, y: 0.859375 },
  { x: 0.921875, y: 0.859375 },
  { x: 0.921875, y: 0.859375 },
  { x: 0.953125, y: 0.859375 },
  { x: 0.953125, y: 0.859375 },
  { x: 0.984375, y: 0.859375 },
  { x: 0.984375, y: 0.859375 },
  { x: 0.015625, y: 0.890625 },
  { x: 0.015625, y: 0.890625 },
  { x: 0.046875, y: 0.890625 },
  { x: 0.046875, y: 0.890625 },
  { x: 0.078125, y: 0.890625 },
  { x: 0.078125, y: 0.890625 },
  { x: 0.109375, y: 0.890625 },
  { x: 0.109375, y: 0.890625 },
  { x: 0.140625, y: 0.890625 },
  { x: 0.140625, y: 0.890625 },
  { x: 0.171875, y: 0.890625 },
  { x: 0.171875, y: 0.890625 },
  { x: 0.203125, y: 0.890625 },
  { x: 0.203125, y: 0.890625 },
  { x: 0.234375, y: 0.890625 },
  { x: 0.234375, y: 0.890625 },
  { x: 0.265625, y: 0.890625 },
  { x: 0.265625, y: 0.890625 },
  { x: 0.296875, y: 0.890625 },
  { x: 0.296875, y: 0.890625 },
  { x: 0.328125, y: 0.890625 },
  { x: 0.328125, y: 0.890625 },
  { x: 0.359375, y: 0.890625 },
  { x: 0.359375, y: 0.890625 },
  { x: 0.390625, y: 0.890625 },
  { x: 0.390625, y: 0.890625 },
  { x: 0.421875, y: 0.890625 },
  { x: 0.421875, y: 0.890625 },
  { x: 0.453125, y: 0.890625 },
  { x: 0.453125, y: 0.890625 },
  { x: 0.484375, y: 0.890625 },
  { x: 0.484375, y: 0.890625 },
  { x: 0.515625, y: 0.890625 },
  { x: 0.515625, y: 0.890625 },
  { x: 0.546875, y: 0.890625 },
  { x: 0.546875, y: 0.890625 },
  { x: 0.578125, y: 0.890625 },
  { x: 0.578125, y: 0.890625 },
  { x: 0.609375, y: 0.890625 },
  { x: 0.609375, y: 0.890625 },
  { x: 0.640625, y: 0.890625 },
  { x: 0.640625, y: 0.890625 },
  { x: 0.671875, y: 0.890625 },
  { x: 0.671875, y: 0.890625 },
  { x: 0.703125, y: 0.890625 },
  { x: 0.703125, y: 0.890625 },
  { x: 0.734375, y: 0.890625 },
  { x: 0.734375, y: 0.890625 },
  { x: 0.765625, y: 0.890625 },
  { x: 0.765625, y: 0.890625 },
  { x: 0.796875, y: 0.890625 },
  { x: 0.796875, y: 0.890625 },
  { x: 0.828125, y: 0.890625 },
  { x: 0.828125, y: 0.890625 },
  { x: 0.859375, y: 0.890625 },
  { x: 0.859375, y: 0.890625 },
  { x: 0.890625, y: 0.890625 },
  { x: 0.890625, y: 0.890625 },
  { x: 0.921875, y: 0.890625 },
  { x: 0.921875, y: 0.890625 },
  { x: 0.953125, y: 0.890625 },
  { x: 0.953125, y: 0.890625 },
  { x: 0.984375, y: 0.890625 },
  { x: 0.984375, y: 0.890625 },
  { x: 0.015625, y: 0.921875 },
  { x: 0.015625, y: 0.921875 },
  { x: 0.046875, y: 0.921875 },
  { x: 0.046875, y: 0.921875 },
  { x: 0.078125, y: 0.921875 },
  { x: 0.078125, y: 0.921875 },
  { x: 0.109375, y: 0.921875 },
  { x: 0.109375, y: 0.921875 },
  { x: 0.140625, y: 0.921875 },
  { x: 0.140625, y: 0.921875 },
  { x: 0.171875, y: 0.921875 },
  { x: 0.171875, y: 0.921875 },
  { x: 0.203125, y: 0.921875 },
  { x: 0.203125, y: 0.921875 },
  { x: 0.234375, y: 0.921875 },
  { x: 0.234375, y: 0.921875 },
  { x: 0.265625, y: 0.921875 },
  { x: 0.265625, y: 0.921875 },
  { x: 0.296875, y: 0.921875 },
  { x: 0.296875, y: 0.921875 },
  { x: 0.328125, y: 0.921875 },
  { x: 0.328125, y: 0.921875 },
  { x: 0.359375, y: 0.921875 },
  { x: 0.359375, y: 0.921875 },
  { x: 0.390625, y: 0.921875 },
  { x: 0.390625, y: 0.921875 },
  { x: 0.421875, y: 0.921875 },
  { x: 0.421875, y: 0.921875 },
  { x: 0.453125, y: 0.921875 },
  { x: 0.453125, y: 0.921875 },
  { x: 0.484375, y: 0.921875 },
  { x: 0.484375, y: 0.921875 },
  { x: 0.515625, y: 0.921875 },
  { x: 0.515625, y: 0.921875 },
  { x: 0.546875, y: 0.921875 },
  { x: 0.546875, y: 0.921875 },
  { x: 0.578125, y: 0.921875 },
  { x: 0.578125, y: 0.921875 },
  { x: 0.609375, y: 0.921875 },
  { x: 0.609375, y: 0.921875 },
  { x: 0.640625, y: 0.921875 },
  { x: 0.640625, y: 0.921875 },
  { x: 0.671875, y: 0.921875 },
  { x: 0.671875, y: 0.921875 },
  { x: 0.703125, y: 0.921875 },
  { x: 0.703125, y: 0.921875 },
  { x: 0.734375, y: 0.921875 },
  { x: 0.734375, y: 0.921875 },
  { x: 0.765625, y: 0.921875 },
  { x: 0.765625, y: 0.921875 },
  { x: 0.796875, y: 0.921875 },
  { x: 0.796875, y: 0.921875 },
  { x: 0.828125, y: 0.921875 },
  { x: 0.828125, y: 0.921875 },
  { x: 0.859375, y: 0.921875 },
  { x: 0.859375, y: 0.921875 },
  { x: 0.890625, y: 0.921875 },
  { x: 0.890625, y: 0.921875 },
  { x: 0.921875, y: 0.921875 },
  { x: 0.921875, y: 0.921875 },
  { x: 0.953125, y: 0.921875 },
  { x: 0.953125, y: 0.921875 },
  { x: 0.984375, y: 0.921875 },
  { x: 0.984375, y: 0.921875 },
  { x: 0.015625, y: 0.953125 },
  { x: 0.015625, y: 0.953125 },
  { x: 0.046875, y: 0.953125 },
  { x: 0.046875, y: 0.953125 },
  { x: 0.078125, y: 0.953125 },
  { x: 0.078125, y: 0.953125 },
  { x: 0.109375, y: 0.953125 },
  { x: 0.109375, y: 0.953125 },
  { x: 0.140625, y: 0.953125 },
  { x: 0.140625, y: 0.953125 },
  { x: 0.171875, y: 0.953125 },
  { x: 0.171875, y: 0.953125 },
  { x: 0.203125, y: 0.953125 },
  { x: 0.203125, y: 0.953125 },
  { x: 0.234375, y: 0.953125 },
  { x: 0.234375, y: 0.953125 },
  { x: 0.265625, y: 0.953125 },
  { x: 0.265625, y: 0.953125 },
  { x: 0.296875, y: 0.953125 },
  { x: 0.296875, y: 0.953125 },
  { x: 0.328125, y: 0.953125 },
  { x: 0.328125, y: 0.953125 },
  { x: 0.359375, y: 0.953125 },
  { x: 0.359375, y: 0.953125 },
  { x: 0.390625, y: 0.953125 },
  { x: 0.390625, y: 0.953125 },
  { x: 0.421875, y: 0.953125 },
  { x: 0.421875, y: 0.953125 },
  { x: 0.453125, y: 0.953125 },
  { x: 0.453125, y: 0.953125 },
  { x: 0.484375, y: 0.953125 },
  { x: 0.484375, y: 0.953125 },
  { x: 0.515625, y: 0.953125 },
  { x: 0.515625, y: 0.953125 },
  { x: 0.546875, y: 0.953125 },
  { x: 0.546875, y: 0.953125 },
  { x: 0.578125, y: 0.953125 },
  { x: 0.578125, y: 0.953125 },
  { x: 0.609375, y: 0.953125 },
  { x: 0.609375, y: 0.953125 },
  { x: 0.640625, y: 0.953125 },
  { x: 0.640625, y: 0.953125 },
  { x: 0.671875, y: 0.953125 },
  { x: 0.671875, y: 0.953125 },
  { x: 0.703125, y: 0.953125 },
  { x: 0.703125, y: 0.953125 },
  { x: 0.734375, y: 0.953125 },
  { x: 0.734375, y: 0.953125 },
  { x: 0.765625, y: 0.953125 },
  { x: 0.765625, y: 0.953125 },
  { x: 0.796875, y: 0.953125 },
  { x: 0.796875, y: 0.953125 },
  { x: 0.828125, y: 0.953125 },
  { x: 0.828125, y: 0.953125 },
  { x: 0.859375, y: 0.953125 },
  { x: 0.859375, y: 0.953125 },
  { x: 0.890625, y: 0.953125 },
  { x: 0.890625, y: 0.953125 },
  { x: 0.921875, y: 0.953125 },
  { x: 0.921875, y: 0.953125 },
  { x: 0.953125, y: 0.953125 },
  { x: 0.953125, y: 0.953125 },
  { x: 0.984375, y: 0.953125 },
  { x: 0.984375, y: 0.953125 },
  { x: 0.015625, y: 0.984375 },
  { x: 0.015625, y: 0.984375 },
  { x: 0.046875, y: 0.984375 },
  { x: 0.046875, y: 0.984375 },
  { x: 0.078125, y: 0.984375 },
  { x: 0.078125, y: 0.984375 },
  { x: 0.109375, y: 0.984375 },
  { x: 0.109375, y: 0.984375 },
  { x: 0.140625, y: 0.984375 },
  { x: 0.140625, y: 0.984375 },
  { x: 0.171875, y: 0.984375 },
  { x: 0.171875, y: 0.984375 },
  { x: 0.203125, y: 0.984375 },
  { x: 0.203125, y: 0.984375 },
  { x: 0.234375, y: 0.984375 },
  { x: 0.234375, y: 0.984375 },
  { x: 0.265625, y: 0.984375 },
  { x: 0.265625, y: 0.984375 },
  { x: 0.296875, y: 0.984375 },
  { x: 0.296875, y: 0.984375 },
  { x: 0.328125, y: 0.984375 },
  { x: 0.328125, y: 0.984375 },
  { x: 0.359375, y: 0.984375 },
  { x: 0.359375, y: 0.984375 },
  { x: 0.390625, y: 0.984375 },
  { x: 0.390625, y: 0.984375 },
  { x: 0.421875, y: 0.984375 },
  { x: 0.421875, y: 0.984375 },
  { x: 0.453125, y: 0.984375 },
  { x: 0.453125, y: 0.984375 },
  { x: 0.484375, y: 0.984375 },
  { x: 0.484375, y: 0.984375 },
  { x: 0.515625, y: 0.984375 },
  { x: 0.515625, y: 0.984375 },
  { x: 0.546875, y: 0.984375 },
  { x: 0.546875, y: 0.984375 },
  { x: 0.578125, y: 0.984375 },
  { x: 0.578125, y: 0.984375 },
  { x: 0.609375, y: 0.984375 },
  { x: 0.609375, y: 0.984375 },
  { x: 0.640625, y: 0.984375 },
  { x: 0.640625, y: 0.984375 },
  { x: 0.671875, y: 0.984375 },
  { x: 0.671875, y: 0.984375 },
  { x: 0.703125, y: 0.984375 },
  { x: 0.703125, y: 0.984375 },
  { x: 0.734375, y: 0.984375 },
  { x: 0.734375, y: 0.984375 },
  { x: 0.765625, y: 0.984375 },
  { x: 0.765625, y: 0.984375 },
  { x: 0.796875, y: 0.984375 },
  { x: 0.796875, y: 0.984375 },
  { x: 0.828125, y: 0.984375 },
  { x: 0.828125, y: 0.984375 },
  { x: 0.859375, y: 0.984375 },
  { x: 0.859375, y: 0.984375 },
  { x: 0.890625, y: 0.984375 },
  { x: 0.890625, y: 0.984375 },
  { x: 0.921875, y: 0.984375 },
  { x: 0.921875, y: 0.984375 },
  { x: 0.953125, y: 0.984375 },
  { x: 0.953125, y: 0.984375 },
  { x: 0.984375, y: 0.984375 },
  { x: 0.984375, y: 0.984375 },
  { x: 0.03125, y: 0.03125 },
  { x: 0.03125, y: 0.03125 },
  { x: 0.09375, y: 0.03125 },
  { x: 0.09375, y: 0.03125 },
  { x: 0.15625, y: 0.03125 },
  { x: 0.15625, y: 0.03125 },
  { x: 0.21875, y: 0.03125 },
  { x: 0.21875, y: 0.03125 },
  { x: 0.28125, y: 0.03125 },
  { x: 0.28125, y: 0.03125 },
  { x: 0.34375, y: 0.03125 },
  { x: 0.34375, y: 0.03125 },
  { x: 0.40625, y: 0.03125 },
  { x: 0.40625, y: 0.03125 },
  { x: 0.46875, y: 0.03125 },
  { x: 0.46875, y: 0.03125 },
  { x: 0.53125, y: 0.03125 },
  { x: 0.53125, y: 0.03125 },
  { x: 0.59375, y: 0.03125 },
  { x: 0.59375, y: 0.03125 },
  { x: 0.65625, y: 0.03125 },
  { x: 0.65625, y: 0.03125 },
  { x: 0.71875, y: 0.03125 },
  { x: 0.71875, y: 0.03125 },
  { x: 0.78125, y: 0.03125 },
  { x: 0.78125, y: 0.03125 },
  { x: 0.84375, y: 0.03125 },
  { x: 0.84375, y: 0.03125 },
  { x: 0.90625, y: 0.03125 },
  { x: 0.90625, y: 0.03125 },
  { x: 0.96875, y: 0.03125 },
  { x: 0.96875, y: 0.03125 },
  { x: 0.03125, y: 0.09375 },
  { x: 0.03125, y: 0.09375 },
  { x: 0.09375, y: 0.09375 },
  { x: 0.09375, y: 0.09375 },
  { x: 0.15625, y: 0.09375 },
  { x: 0.15625, y: 0.09375 },
  { x: 0.21875, y: 0.09375 },
  { x: 0.21875, y: 0.09375 },
  { x: 0.28125, y: 0.09375 },
  { x: 0.28125, y: 0.09375 },
  { x: 0.34375, y: 0.09375 },
  { x: 0.34375, y: 0.09375 },
  { x: 0.40625, y: 0.09375 },
  { x: 0.40625, y: 0.09375 },
  { x: 0.46875, y: 0.09375 },
  { x: 0.46875, y: 0.09375 },
  { x: 0.53125, y: 0.09375 },
  { x: 0.53125, y: 0.09375 },
  { x: 0.59375, y: 0.09375 },
  { x: 0.59375, y: 0.09375 },
  { x: 0.65625, y: 0.09375 },
  { x: 0.65625, y: 0.09375 },
  { x: 0.71875, y: 0.09375 },
  { x: 0.71875, y: 0.09375 },
  { x: 0.78125, y: 0.09375 },
  { x: 0.78125, y: 0.09375 },
  { x: 0.84375, y: 0.09375 },
  { x: 0.84375, y: 0.09375 },
  { x: 0.90625, y: 0.09375 },
  { x: 0.90625, y: 0.09375 },
  { x: 0.96875, y: 0.09375 },
  { x: 0.96875, y: 0.09375 },
  { x: 0.03125, y: 0.15625 },
  { x: 0.03125, y: 0.15625 },
  { x: 0.09375, y: 0.15625 },
  { x: 0.09375, y: 0.15625 },
  { x: 0.15625, y: 0.15625 },
  { x: 0.15625, y: 0.15625 },
  { x: 0.21875, y: 0.15625 },
  { x: 0.21875, y: 0.15625 },
  { x: 0.28125, y: 0.15625 },
  { x: 0.28125, y: 0.15625 },
  { x: 0.34375, y: 0.15625 },
  { x: 0.34375, y: 0.15625 },
  { x: 0.40625, y: 0.15625 },
  { x: 0.40625, y: 0.15625 },
  { x: 0.46875, y: 0.15625 },
  { x: 0.46875, y: 0.15625 },
  { x: 0.53125, y: 0.15625 },
  { x: 0.53125, y: 0.15625 },
  { x: 0.59375, y: 0.15625 },
  { x: 0.59375, y: 0.15625 },
  { x: 0.65625, y: 0.15625 },
  { x: 0.65625, y: 0.15625 },
  { x: 0.71875, y: 0.15625 },
  { x: 0.71875, y: 0.15625 },
  { x: 0.78125, y: 0.15625 },
  { x: 0.78125, y: 0.15625 },
  { x: 0.84375, y: 0.15625 },
  { x: 0.84375, y: 0.15625 },
  { x: 0.90625, y: 0.15625 },
  { x: 0.90625, y: 0.15625 },
  { x: 0.96875, y: 0.15625 },
  { x: 0.96875, y: 0.15625 },
  { x: 0.03125, y: 0.21875 },
  { x: 0.03125, y: 0.21875 },
  { x: 0.09375, y: 0.21875 },
  { x: 0.09375, y: 0.21875 },
  { x: 0.15625, y: 0.21875 },
  { x: 0.15625, y: 0.21875 },
  { x: 0.21875, y: 0.21875 },
  { x: 0.21875, y: 0.21875 },
  { x: 0.28125, y: 0.21875 },
  { x: 0.28125, y: 0.21875 },
  { x: 0.34375, y: 0.21875 },
  { x: 0.34375, y: 0.21875 },
  { x: 0.40625, y: 0.21875 },
  { x: 0.40625, y: 0.21875 },
  { x: 0.46875, y: 0.21875 },
  { x: 0.46875, y: 0.21875 },
  { x: 0.53125, y: 0.21875 },
  { x: 0.53125, y: 0.21875 },
  { x: 0.59375, y: 0.21875 },
  { x: 0.59375, y: 0.21875 },
  { x: 0.65625, y: 0.21875 },
  { x: 0.65625, y: 0.21875 },
  { x: 0.71875, y: 0.21875 },
  { x: 0.71875, y: 0.21875 },
  { x: 0.78125, y: 0.21875 },
  { x: 0.78125, y: 0.21875 },
  { x: 0.84375, y: 0.21875 },
  { x: 0.84375, y: 0.21875 },
  { x: 0.90625, y: 0.21875 },
  { x: 0.90625, y: 0.21875 },
  { x: 0.96875, y: 0.21875 },
  { x: 0.96875, y: 0.21875 },
  { x: 0.03125, y: 0.28125 },
  { x: 0.03125, y: 0.28125 },
  { x: 0.09375, y: 0.28125 },
  { x: 0.09375, y: 0.28125 },
  { x: 0.15625, y: 0.28125 },
  { x: 0.15625, y: 0.28125 },
  { x: 0.21875, y: 0.28125 },
  { x: 0.21875, y: 0.28125 },
  { x: 0.28125, y: 0.28125 },
  { x: 0.28125, y: 0.28125 },
  { x: 0.34375, y: 0.28125 },
  { x: 0.34375, y: 0.28125 },
  { x: 0.40625, y: 0.28125 },
  { x: 0.40625, y: 0.28125 },
  { x: 0.46875, y: 0.28125 },
  { x: 0.46875, y: 0.28125 },
  { x: 0.53125, y: 0.28125 },
  { x: 0.53125, y: 0.28125 },
  { x: 0.59375, y: 0.28125 },
  { x: 0.59375, y: 0.28125 },
  { x: 0.65625, y: 0.28125 },
  { x: 0.65625, y: 0.28125 },
  { x: 0.71875, y: 0.28125 },
  { x: 0.71875, y: 0.28125 },
  { x: 0.78125, y: 0.28125 },
  { x: 0.78125, y: 0.28125 },
  { x: 0.84375, y: 0.28125 },
  { x: 0.84375, y: 0.28125 },
  { x: 0.90625, y: 0.28125 },
  { x: 0.90625, y: 0.28125 },
  { x: 0.96875, y: 0.28125 },
  { x: 0.96875, y: 0.28125 },
  { x: 0.03125, y: 0.34375 },
  { x: 0.03125, y: 0.34375 },
  { x: 0.09375, y: 0.34375 },
  { x: 0.09375, y: 0.34375 },
  { x: 0.15625, y: 0.34375 },
  { x: 0.15625, y: 0.34375 },
  { x: 0.21875, y: 0.34375 },
  { x: 0.21875, y: 0.34375 },
  { x: 0.28125, y: 0.34375 },
  { x: 0.28125, y: 0.34375 },
  { x: 0.34375, y: 0.34375 },
  { x: 0.34375, y: 0.34375 },
  { x: 0.40625, y: 0.34375 },
  { x: 0.40625, y: 0.34375 },
  { x: 0.46875, y: 0.34375 },
  { x: 0.46875, y: 0.34375 },
  { x: 0.53125, y: 0.34375 },
  { x: 0.53125, y: 0.34375 },
  { x: 0.59375, y: 0.34375 },
  { x: 0.59375, y: 0.34375 },
  { x: 0.65625, y: 0.34375 },
  { x: 0.65625, y: 0.34375 },
  { x: 0.71875, y: 0.34375 },
  { x: 0.71875, y: 0.34375 },
  { x: 0.78125, y: 0.34375 },
  { x: 0.78125, y: 0.34375 },
  { x: 0.84375, y: 0.34375 },
  { x: 0.84375, y: 0.34375 },
  { x: 0.90625, y: 0.34375 },
  { x: 0.90625, y: 0.34375 },
  { x: 0.96875, y: 0.34375 },
  { x: 0.96875, y: 0.34375 },
  { x: 0.03125, y: 0.40625 },
  { x: 0.03125, y: 0.40625 },
  { x: 0.09375, y: 0.40625 },
  { x: 0.09375, y: 0.40625 },
  { x: 0.15625, y: 0.40625 },
  { x: 0.15625, y: 0.40625 },
  { x: 0.21875, y: 0.40625 },
  { x: 0.21875, y: 0.40625 },
  { x: 0.28125, y: 0.40625 },
  { x: 0.28125, y: 0.40625 },
  { x: 0.34375, y: 0.40625 },
  { x: 0.34375, y: 0.40625 },
  { x: 0.40625, y: 0.40625 },
  { x: 0.40625, y: 0.40625 },
  { x: 0.46875, y: 0.40625 },
  { x: 0.46875, y: 0.40625 },
  { x: 0.53125, y: 0.40625 },
  { x: 0.53125, y: 0.40625 },
  { x: 0.59375, y: 0.40625 },
  { x: 0.59375, y: 0.40625 },
  { x: 0.65625, y: 0.40625 },
  { x: 0.65625, y: 0.40625 },
  { x: 0.71875, y: 0.40625 },
  { x: 0.71875, y: 0.40625 },
  { x: 0.78125, y: 0.40625 },
  { x: 0.78125, y: 0.40625 },
  { x: 0.84375, y: 0.40625 },
  { x: 0.84375, y: 0.40625 },
  { x: 0.90625, y: 0.40625 },
  { x: 0.90625, y: 0.40625 },
  { x: 0.96875, y: 0.40625 },
  { x: 0.96875, y: 0.40625 },
  { x: 0.03125, y: 0.46875 },
  { x: 0.03125, y: 0.46875 },
  { x: 0.09375, y: 0.46875 },
  { x: 0.09375, y: 0.46875 },
  { x: 0.15625, y: 0.46875 },
  { x: 0.15625, y: 0.46875 },
  { x: 0.21875, y: 0.46875 },
  { x: 0.21875, y: 0.46875 },
  { x: 0.28125, y: 0.46875 },
  { x: 0.28125, y: 0.46875 },
  { x: 0.34375, y: 0.46875 },
  { x: 0.34375, y: 0.46875 },
  { x: 0.40625, y: 0.46875 },
  { x: 0.40625, y: 0.46875 },
  { x: 0.46875, y: 0.46875 },
  { x: 0.46875, y: 0.46875 },
  { x: 0.53125, y: 0.46875 },
  { x: 0.53125, y: 0.46875 },
  { x: 0.59375, y: 0.46875 },
  { x: 0.59375, y: 0.46875 },
  { x: 0.65625, y: 0.46875 },
  { x: 0.65625, y: 0.46875 },
  { x: 0.71875, y: 0.46875 },
  { x: 0.71875, y: 0.46875 },
  { x: 0.78125, y: 0.46875 },
  { x: 0.78125, y: 0.46875 },
  { x: 0.84375, y: 0.46875 },
  { x: 0.84375, y: 0.46875 },
  { x: 0.90625, y: 0.46875 },
  { x: 0.90625, y: 0.46875 },
  { x: 0.96875, y: 0.46875 },
  { x: 0.96875, y: 0.46875 },
  { x: 0.03125, y: 0.53125 },
  { x: 0.03125, y: 0.53125 },
  { x: 0.09375, y: 0.53125 },
  { x: 0.09375, y: 0.53125 },
  { x: 0.15625, y: 0.53125 },
  { x: 0.15625, y: 0.53125 },
  { x: 0.21875, y: 0.53125 },
  { x: 0.21875, y: 0.53125 },
  { x: 0.28125, y: 0.53125 },
  { x: 0.28125, y: 0.53125 },
  { x: 0.34375, y: 0.53125 },
  { x: 0.34375, y: 0.53125 },
  { x: 0.40625, y: 0.53125 },
  { x: 0.40625, y: 0.53125 },
  { x: 0.46875, y: 0.53125 },
  { x: 0.46875, y: 0.53125 },
  { x: 0.53125, y: 0.53125 },
  { x: 0.53125, y: 0.53125 },
  { x: 0.59375, y: 0.53125 },
  { x: 0.59375, y: 0.53125 },
  { x: 0.65625, y: 0.53125 },
  { x: 0.65625, y: 0.53125 },
  { x: 0.71875, y: 0.53125 },
  { x: 0.71875, y: 0.53125 },
  { x: 0.78125, y: 0.53125 },
  { x: 0.78125, y: 0.53125 },
  { x: 0.84375, y: 0.53125 },
  { x: 0.84375, y: 0.53125 },
  { x: 0.90625, y: 0.53125 },
  { x: 0.90625, y: 0.53125 },
  { x: 0.96875, y: 0.53125 },
  { x: 0.96875, y: 0.53125 },
  { x: 0.03125, y: 0.59375 },
  { x: 0.03125, y: 0.59375 },
  { x: 0.09375, y: 0.59375 },
  { x: 0.09375, y: 0.59375 },
  { x: 0.15625, y: 0.59375 },
  { x: 0.15625, y: 0.59375 },
  { x: 0.21875, y: 0.59375 },
  { x: 0.21875, y: 0.59375 },
  { x: 0.28125, y: 0.59375 },
  { x: 0.28125, y: 0.59375 },
  { x: 0.34375, y: 0.59375 },
  { x: 0.34375, y: 0.59375 },
  { x: 0.40625, y: 0.59375 },
  { x: 0.40625, y: 0.59375 },
  { x: 0.46875, y: 0.59375 },
  { x: 0.46875, y: 0.59375 },
  { x: 0.53125, y: 0.59375 },
  { x: 0.53125, y: 0.59375 },
  { x: 0.59375, y: 0.59375 },
  { x: 0.59375, y: 0.59375 },
  { x: 0.65625, y: 0.59375 },
  { x: 0.65625, y: 0.59375 },
  { x: 0.71875, y: 0.59375 },
  { x: 0.71875, y: 0.59375 },
  { x: 0.78125, y: 0.59375 },
  { x: 0.78125, y: 0.59375 },
  { x: 0.84375, y: 0.59375 },
  { x: 0.84375, y: 0.59375 },
  { x: 0.90625, y: 0.59375 },
  { x: 0.90625, y: 0.59375 },
  { x: 0.96875, y: 0.59375 },
  { x: 0.96875, y: 0.59375 },
  { x: 0.03125, y: 0.65625 },
  { x: 0.03125, y: 0.65625 },
  { x: 0.09375, y: 0.65625 },
  { x: 0.09375, y: 0.65625 },
  { x: 0.15625, y: 0.65625 },
  { x: 0.15625, y: 0.65625 },
  { x: 0.21875, y: 0.65625 },
  { x: 0.21875, y: 0.65625 },
  { x: 0.28125, y: 0.65625 },
  { x: 0.28125, y: 0.65625 },
  { x: 0.34375, y: 0.65625 },
  { x: 0.34375, y: 0.65625 },
  { x: 0.40625, y: 0.65625 },
  { x: 0.40625, y: 0.65625 },
  { x: 0.46875, y: 0.65625 },
  { x: 0.46875, y: 0.65625 },
  { x: 0.53125, y: 0.65625 },
  { x: 0.53125, y: 0.65625 },
  { x: 0.59375, y: 0.65625 },
  { x: 0.59375, y: 0.65625 },
  { x: 0.65625, y: 0.65625 },
  { x: 0.65625, y: 0.65625 },
  { x: 0.71875, y: 0.65625 },
  { x: 0.71875, y: 0.65625 },
  { x: 0.78125, y: 0.65625 },
  { x: 0.78125, y: 0.65625 },
  { x: 0.84375, y: 0.65625 },
  { x: 0.84375, y: 0.65625 },
  { x: 0.90625, y: 0.65625 },
  { x: 0.90625, y: 0.65625 },
  { x: 0.96875, y: 0.65625 },
  { x: 0.96875, y: 0.65625 },
  { x: 0.03125, y: 0.71875 },
  { x: 0.03125, y: 0.71875 },
  { x: 0.09375, y: 0.71875 },
  { x: 0.09375, y: 0.71875 },
  { x: 0.15625, y: 0.71875 },
  { x: 0.15625, y: 0.71875 },
  { x: 0.21875, y: 0.71875 },
  { x: 0.21875, y: 0.71875 },
  { x: 0.28125, y: 0.71875 },
  { x: 0.28125, y: 0.71875 },
  { x: 0.34375, y: 0.71875 },
  { x: 0.34375, y: 0.71875 },
  { x: 0.40625, y: 0.71875 },
  { x: 0.40625, y: 0.71875 },
  { x: 0.46875, y: 0.71875 },
  { x: 0.46875, y: 0.71875 },
  { x: 0.53125, y: 0.71875 },
  { x: 0.53125, y: 0.71875 },
  { x: 0.59375, y: 0.71875 },
  { x: 0.59375, y: 0.71875 },
  { x: 0.65625, y: 0.71875 },
  { x: 0.65625, y: 0.71875 },
  { x: 0.71875, y: 0.71875 },
  { x: 0.71875, y: 0.71875 },
  { x: 0.78125, y: 0.71875 },
  { x: 0.78125, y: 0.71875 },
  { x: 0.84375, y: 0.71875 },
  { x: 0.84375, y: 0.71875 },
  { x: 0.90625, y: 0.71875 },
  { x: 0.90625, y: 0.71875 },
  { x: 0.96875, y: 0.71875 },
  { x: 0.96875, y: 0.71875 },
  { x: 0.03125, y: 0.78125 },
  { x: 0.03125, y: 0.78125 },
  { x: 0.09375, y: 0.78125 },
  { x: 0.09375, y: 0.78125 },
  { x: 0.15625, y: 0.78125 },
  { x: 0.15625, y: 0.78125 },
  { x: 0.21875, y: 0.78125 },
  { x: 0.21875, y: 0.78125 },
  { x: 0.28125, y: 0.78125 },
  { x: 0.28125, y: 0.78125 },
  { x: 0.34375, y: 0.78125 },
  { x: 0.34375, y: 0.78125 },
  { x: 0.40625, y: 0.78125 },
  { x: 0.40625, y: 0.78125 },
  { x: 0.46875, y: 0.78125 },
  { x: 0.46875, y: 0.78125 },
  { x: 0.53125, y: 0.78125 },
  { x: 0.53125, y: 0.78125 },
  { x: 0.59375, y: 0.78125 },
  { x: 0.59375, y: 0.78125 },
  { x: 0.65625, y: 0.78125 },
  { x: 0.65625, y: 0.78125 },
  { x: 0.71875, y: 0.78125 },
  { x: 0.71875, y: 0.78125 },
  { x: 0.78125, y: 0.78125 },
  { x: 0.78125, y: 0.78125 },
  { x: 0.84375, y: 0.78125 },
  { x: 0.84375, y: 0.78125 },
  { x: 0.90625, y: 0.78125 },
  { x: 0.90625, y: 0.78125 },
  { x: 0.96875, y: 0.78125 },
  { x: 0.96875, y: 0.78125 },
  { x: 0.03125, y: 0.84375 },
  { x: 0.03125, y: 0.84375 },
  { x: 0.09375, y: 0.84375 },
  { x: 0.09375, y: 0.84375 },
  { x: 0.15625, y: 0.84375 },
  { x: 0.15625, y: 0.84375 },
  { x: 0.21875, y: 0.84375 },
  { x: 0.21875, y: 0.84375 },
  { x: 0.28125, y: 0.84375 },
  { x: 0.28125, y: 0.84375 },
  { x: 0.34375, y: 0.84375 },
  { x: 0.34375, y: 0.84375 },
  { x: 0.40625, y: 0.84375 },
  { x: 0.40625, y: 0.84375 },
  { x: 0.46875, y: 0.84375 },
  { x: 0.46875, y: 0.84375 },
  { x: 0.53125, y: 0.84375 },
  { x: 0.53125, y: 0.84375 },
  { x: 0.59375, y: 0.84375 },
  { x: 0.59375, y: 0.84375 },
  { x: 0.65625, y: 0.84375 },
  { x: 0.65625, y: 0.84375 },
  { x: 0.71875, y: 0.84375 },
  { x: 0.71875, y: 0.84375 },
  { x: 0.78125, y: 0.84375 },
  { x: 0.78125, y: 0.84375 },
  { x: 0.84375, y: 0.84375 },
  { x: 0.84375, y: 0.84375 },
  { x: 0.90625, y: 0.84375 },
  { x: 0.90625, y: 0.84375 },
  { x: 0.96875, y: 0.84375 },
  { x: 0.96875, y: 0.84375 },
  { x: 0.03125, y: 0.90625 },
  { x: 0.03125, y: 0.90625 },
  { x: 0.09375, y: 0.90625 },
  { x: 0.09375, y: 0.90625 },
  { x: 0.15625, y: 0.90625 },
  { x: 0.15625, y: 0.90625 },
  { x: 0.21875, y: 0.90625 },
  { x: 0.21875, y: 0.90625 },
  { x: 0.28125, y: 0.90625 },
  { x: 0.28125, y: 0.90625 },
  { x: 0.34375, y: 0.90625 },
  { x: 0.34375, y: 0.90625 },
  { x: 0.40625, y: 0.90625 },
  { x: 0.40625, y: 0.90625 },
  { x: 0.46875, y: 0.90625 },
  { x: 0.46875, y: 0.90625 },
  { x: 0.53125, y: 0.90625 },
  { x: 0.53125, y: 0.90625 },
  { x: 0.59375, y: 0.90625 },
  { x: 0.59375, y: 0.90625 },
  { x: 0.65625, y: 0.90625 },
  { x: 0.65625, y: 0.90625 },
  { x: 0.71875, y: 0.90625 },
  { x: 0.71875, y: 0.90625 },
  { x: 0.78125, y: 0.90625 },
  { x: 0.78125, y: 0.90625 },
  { x: 0.84375, y: 0.90625 },
  { x: 0.84375, y: 0.90625 },
  { x: 0.90625, y: 0.90625 },
  { x: 0.90625, y: 0.90625 },
  { x: 0.96875, y: 0.90625 },
  { x: 0.96875, y: 0.90625 },
  { x: 0.03125, y: 0.96875 },
  { x: 0.03125, y: 0.96875 },
  { x: 0.09375, y: 0.96875 },
  { x: 0.09375, y: 0.96875 },
  { x: 0.15625, y: 0.96875 },
  { x: 0.15625, y: 0.96875 },
  { x: 0.21875, y: 0.96875 },
  { x: 0.21875, y: 0.96875 },
  { x: 0.28125, y: 0.96875 },
  { x: 0.28125, y: 0.96875 },
  { x: 0.34375, y: 0.96875 },
  { x: 0.34375, y: 0.96875 },
  { x: 0.40625, y: 0.96875 },
  { x: 0.40625, y: 0.96875 },
  { x: 0.46875, y: 0.96875 },
  { x: 0.46875, y: 0.96875 },
  { x: 0.53125, y: 0.96875 },
  { x: 0.53125, y: 0.96875 },
  { x: 0.59375, y: 0.96875 },
  { x: 0.59375, y: 0.96875 },
  { x: 0.65625, y: 0.96875 },
  { x: 0.65625, y: 0.96875 },
  { x: 0.71875, y: 0.96875 },
  { x: 0.71875, y: 0.96875 },
  { x: 0.78125, y: 0.96875 },
  { x: 0.78125, y: 0.96875 },
  { x: 0.84375, y: 0.96875 },
  { x: 0.84375, y: 0.96875 },
  { x: 0.90625, y: 0.96875 },
  { x: 0.90625, y: 0.96875 },
  { x: 0.96875, y: 0.96875 },
  { x: 0.96875, y: 0.96875 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 }
];
var HandDetector = class {
  constructor(model142) {
    __publicField(this, "model");
    __publicField(this, "anchors");
    __publicField(this, "anchorsTensor");
    __publicField(this, "inputSize");
    __publicField(this, "inputSizeTensor");
    __publicField(this, "doubleInputSizeTensor");
    this.model = model142;
    this.anchors = anchors2.map((anchor) => [anchor.x, anchor.y]);
    this.anchorsTensor = tensor2d(this.anchors);
    this.inputSize = this.model && this.model.inputs && this.model.inputs[0].shape ? this.model.inputs[0].shape[2] : 0;
    this.inputSizeTensor = tensor1d([this.inputSize, this.inputSize]);
    this.doubleInputSizeTensor = tensor1d([this.inputSize * 2, this.inputSize * 2]);
  }
  normalizeBoxes(boxes) {
    return tidy(() => {
      const boxOffsets = slice(boxes, [0, 0], [-1, 2]);
      const boxSizes = slice(boxes, [0, 2], [-1, 2]);
      const boxCenterPoints = add2(div(boxOffsets, this.inputSizeTensor), this.anchorsTensor);
      const halfBoxSizes = div(boxSizes, this.doubleInputSizeTensor);
      const startPoints = mul(sub(boxCenterPoints, halfBoxSizes), this.inputSizeTensor);
      const endPoints = mul(add2(boxCenterPoints, halfBoxSizes), this.inputSizeTensor);
      return concat2d([startPoints, endPoints], 1);
    });
  }
  normalizeLandmarks(rawPalmLandmarks, index) {
    return tidy(() => {
      const landmarks = add2(div(reshape(rawPalmLandmarks, [-1, 7, 2]), this.inputSizeTensor), this.anchors[index]);
      return mul(landmarks, this.inputSizeTensor);
    });
  }
  async getBoxes(input2, config3) {
    const t2 = {};
    t2.batched = this.model.predict(input2);
    t2.predictions = squeeze(t2.batched);
    t2.scores = tidy(() => squeeze(sigmoid(slice(t2.predictions, [0, 0], [-1, 1]))));
    const scores = await t2.scores.data();
    t2.boxes = slice(t2.predictions, [0, 1], [-1, 4]);
    t2.norm = this.normalizeBoxes(t2.boxes);
    t2.nms = await image.nonMaxSuppressionAsync(t2.norm, t2.scores, 3 * config3.hand.maxDetected, config3.hand.iouThreshold, config3.hand.minConfidence);
    const nms = await t2.nms.array();
    const hands = [];
    for (const index of nms) {
      const palmBox = slice(t2.norm, [index, 0], [1, -1]);
      const palmLandmarks = tidy(() => reshape(this.normalizeLandmarks(slice(t2.predictions, [index, 5], [1, 14]), index), [-1, 2]));
      hands.push({ box: palmBox, palmLandmarks, confidence: scores[index] });
    }
    for (const tensor2 of Object.keys(t2))
      dispose(t2[tensor2]);
    return hands;
  }
  async estimateHandBounds(input2, config3) {
    const inputHeight = input2.shape[1];
    const inputWidth = input2.shape[2];
    const image7 = tidy(() => sub(div(image.resizeBilinear(input2, [this.inputSize, this.inputSize]), 127.5), 1));
    const predictions = await this.getBoxes(image7, config3);
    dispose(image7);
    const hands = [];
    if (!predictions || predictions.length === 0)
      return hands;
    for (const prediction of predictions) {
      const boxes = await prediction.box.data();
      const startPoint = boxes.slice(0, 2);
      const endPoint = boxes.slice(2, 4);
      const palmLandmarks = await prediction.palmLandmarks.array();
      dispose(prediction.box);
      dispose(prediction.palmLandmarks);
      hands.push(scaleBoxCoordinates2({ startPoint, endPoint, palmLandmarks, confidence: prediction.confidence }, [inputWidth / this.inputSize, inputHeight / this.inputSize]));
    }
    return hands;
  }
};
function normalizeRadians2(angle2) {
  return angle2 - 2 * Math.PI * Math.floor((angle2 + Math.PI) / (2 * Math.PI));
}
function computeRotation2(point1, point2) {
  const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);
  return normalizeRadians2(radians);
}
var buildTranslationMatrix2 = (x2, y2) => [[1, 0, x2], [0, 1, y2], [0, 0, 1]];
function dot5(v1, v2) {
  let product = 0;
  for (let i2 = 0; i2 < v1.length; i2++) {
    product += v1[i2] * v2[i2];
  }
  return product;
}
function getColumnFrom2DArr2(arr, columnIndex) {
  const column = [];
  for (let i2 = 0; i2 < arr.length; i2++) {
    column.push(arr[i2][columnIndex]);
  }
  return column;
}
function multiplyTransformMatrices2(mat1, mat2) {
  const product = [];
  const size2 = mat1.length;
  for (let row = 0; row < size2; row++) {
    product.push([]);
    for (let col = 0; col < size2; col++) {
      product[row].push(dot5(mat1[row], getColumnFrom2DArr2(mat2, col)));
    }
  }
  return product;
}
function buildRotationMatrix2(rotation, center) {
  const cosA = Math.cos(rotation);
  const sinA = Math.sin(rotation);
  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
  const translationMatrix = buildTranslationMatrix2(center[0], center[1]);
  const translationTimesRotation = multiplyTransformMatrices2(translationMatrix, rotationMatrix);
  const negativeTranslationMatrix = buildTranslationMatrix2(-center[0], -center[1]);
  return multiplyTransformMatrices2(translationTimesRotation, negativeTranslationMatrix);
}
function invertTransformMatrix2(matrix) {
  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
  const translationComponent = [matrix[0][2], matrix[1][2]];
  const invertedTranslation = [
    -dot5(rotationComponent[0], translationComponent),
    -dot5(rotationComponent[1], translationComponent)
  ];
  return [
    rotationComponent[0].concat(invertedTranslation[0]),
    rotationComponent[1].concat(invertedTranslation[1]),
    [0, 0, 1]
  ];
}
function rotatePoint2(homogeneousCoordinate, rotationMatrix) {
  return [
    dot5(homogeneousCoordinate, rotationMatrix[0]),
    dot5(homogeneousCoordinate, rotationMatrix[1])
  ];
}
var palmBoxEnlargeFactor = 5;
var handBoxEnlargeFactor = 1.65;
var palmLandmarkIds = [0, 5, 9, 13, 17, 1, 2];
var palmLandmarksPalmBase = 0;
var palmLandmarksMiddleFingerBase = 2;
var HandPipeline = class {
  constructor(handDetector, handPoseModel2) {
    __publicField(this, "handDetector");
    __publicField(this, "handPoseModel");
    __publicField(this, "inputSize");
    __publicField(this, "storedBoxes");
    __publicField(this, "skipped");
    __publicField(this, "detectedHands");
    this.handDetector = handDetector;
    this.handPoseModel = handPoseModel2;
    this.inputSize = this.handPoseModel && this.handPoseModel.inputs[0].shape ? this.handPoseModel.inputs[0].shape[2] : 0;
    this.storedBoxes = [];
    this.skipped = 0;
    this.detectedHands = 0;
  }
  calculateLandmarksBoundingBox(landmarks) {
    const xs = landmarks.map((d2) => d2[0]);
    const ys = landmarks.map((d2) => d2[1]);
    const startPoint = [Math.min(...xs), Math.min(...ys)];
    const endPoint = [Math.max(...xs), Math.max(...ys)];
    return { startPoint, endPoint };
  }
  getBoxForPalmLandmarks(palmLandmarks, rotationMatrix) {
    const rotatedPalmLandmarks = palmLandmarks.map((coord) => rotatePoint2([...coord, 1], rotationMatrix));
    const boxAroundPalm = this.calculateLandmarksBoundingBox(rotatedPalmLandmarks);
    return enlargeBox2(squarifyBox2(boxAroundPalm), palmBoxEnlargeFactor);
  }
  getBoxForHandLandmarks(landmarks) {
    const boundingBox = this.calculateLandmarksBoundingBox(landmarks);
    const boxAroundHand = enlargeBox2(squarifyBox2(boundingBox), handBoxEnlargeFactor);
    boxAroundHand.palmLandmarks = [];
    for (let i2 = 0; i2 < palmLandmarkIds.length; i2++) {
      boxAroundHand.palmLandmarks.push(landmarks[palmLandmarkIds[i2]].slice(0, 2));
    }
    return boxAroundHand;
  }
  transformRawCoords(rawCoords, box22, angle2, rotationMatrix) {
    const boxSize = getBoxSize2(box22);
    const scaleFactor = [boxSize[0] / this.inputSize, boxSize[1] / this.inputSize, (boxSize[0] + boxSize[1]) / this.inputSize / 2];
    const coordsScaled = rawCoords.map((coord) => [
      scaleFactor[0] * (coord[0] - this.inputSize / 2),
      scaleFactor[1] * (coord[1] - this.inputSize / 2),
      scaleFactor[2] * coord[2]
    ]);
    const coordsRotationMatrix = buildRotationMatrix2(angle2, [0, 0]);
    const coordsRotated = coordsScaled.map((coord) => {
      const rotated = rotatePoint2(coord, coordsRotationMatrix);
      return [...rotated, coord[2]];
    });
    const inverseRotationMatrix = invertTransformMatrix2(rotationMatrix);
    const boxCenter = [...getBoxCenter2(box22), 1];
    const originalBoxCenter = [
      dot5(boxCenter, inverseRotationMatrix[0]),
      dot5(boxCenter, inverseRotationMatrix[1])
    ];
    return coordsRotated.map((coord) => [
      Math.trunc(coord[0] + originalBoxCenter[0]),
      Math.trunc(coord[1] + originalBoxCenter[1]),
      Math.trunc(coord[2])
    ]);
  }
  async estimateHands(image7, config3) {
    let useFreshBox = false;
    let boxes;
    if (this.skipped === 0 || this.skipped > config3.hand.skipFrames || !config3.hand.landmarks || !config3.skipFrame) {
      boxes = await this.handDetector.estimateHandBounds(image7, config3);
      this.skipped = 0;
    }
    if (config3.skipFrame)
      this.skipped++;
    if (boxes && boxes.length > 0 && (boxes.length !== this.detectedHands && this.detectedHands !== config3.hand.maxDetected || !config3.hand.landmarks)) {
      this.detectedHands = 0;
      this.storedBoxes = [...boxes];
      if (this.storedBoxes.length > 0)
        useFreshBox = true;
    }
    const hands = [];
    for (let i2 = 0; i2 < this.storedBoxes.length; i2++) {
      const currentBox = this.storedBoxes[i2];
      if (!currentBox)
        continue;
      if (config3.hand.landmarks) {
        const angle2 = config3.hand.rotation ? computeRotation2(currentBox.palmLandmarks[palmLandmarksPalmBase], currentBox.palmLandmarks[palmLandmarksMiddleFingerBase]) : 0;
        const palmCenter = getBoxCenter2(currentBox);
        const palmCenterNormalized = [palmCenter[0] / image7.shape[2], palmCenter[1] / image7.shape[1]];
        const rotatedImage = config3.hand.rotation && env2.kernels.includes("rotatewithoffset") ? image.rotateWithOffset(image7, angle2, 0, palmCenterNormalized) : image7.clone();
        const rotationMatrix = buildRotationMatrix2(-angle2, palmCenter);
        const newBox = useFreshBox ? this.getBoxForPalmLandmarks(currentBox.palmLandmarks, rotationMatrix) : currentBox;
        const croppedInput = cutBoxFromImageAndResize2(newBox, rotatedImage, [this.inputSize, this.inputSize]);
        const handImage = div(croppedInput, 255);
        dispose(croppedInput);
        dispose(rotatedImage);
        const [confidenceT, keypoints2] = await this.handPoseModel.predict(handImage);
        dispose(handImage);
        const confidence = (await confidenceT.data())[0];
        dispose(confidenceT);
        if (confidence >= config3.hand.minConfidence / 4) {
          const keypointsReshaped = reshape(keypoints2, [-1, 3]);
          const rawCoords = await keypointsReshaped.array();
          dispose(keypoints2);
          dispose(keypointsReshaped);
          const coords9 = this.transformRawCoords(rawCoords, newBox, angle2, rotationMatrix);
          const nextBoundingBox = this.getBoxForHandLandmarks(coords9);
          this.storedBoxes[i2] = { ...nextBoundingBox, confidence };
          const result = {
            landmarks: coords9,
            confidence,
            boxConfidence: currentBox.confidence,
            fingerConfidence: confidence,
            box: { topLeft: nextBoundingBox.startPoint, bottomRight: nextBoundingBox.endPoint }
          };
          hands.push(result);
        } else {
          this.storedBoxes[i2] = null;
        }
        dispose(keypoints2);
      } else {
        const enlarged = enlargeBox2(squarifyBox2(currentBox), handBoxEnlargeFactor);
        const result = {
          confidence: currentBox.confidence,
          boxConfidence: currentBox.confidence,
          fingerConfidence: 0,
          box: { topLeft: enlarged.startPoint, bottomRight: enlarged.endPoint },
          landmarks: []
        };
        hands.push(result);
      }
    }
    this.storedBoxes = this.storedBoxes.filter((a6) => a6 !== null);
    this.detectedHands = hands.length;
    if (hands.length > config3.hand.maxDetected)
      hands.length = config3.hand.maxDetected;
    return hands;
  }
};
var Finger = {
  thumb: 0,
  index: 1,
  middle: 2,
  ring: 3,
  pinky: 4,
  all: [0, 1, 2, 3, 4],
  nameMapping: { 0: "thumb", 1: "index", 2: "middle", 3: "ring", 4: "pinky" },
  pointsMapping: {
    0: [[0, 1], [1, 2], [2, 3], [3, 4]],
    1: [[0, 5], [5, 6], [6, 7], [7, 8]],
    2: [[0, 9], [9, 10], [10, 11], [11, 12]],
    3: [[0, 13], [13, 14], [14, 15], [15, 16]],
    4: [[0, 17], [17, 18], [18, 19], [19, 20]]
  },
  getName: (value) => Finger.nameMapping[value],
  getPoints: (value) => Finger.pointsMapping[value]
};
var FingerCurl = {
  none: 0,
  half: 1,
  full: 2,
  nameMapping: { 0: "none", 1: "half", 2: "full" },
  getName: (value) => FingerCurl.nameMapping[value]
};
var FingerDirection = {
  verticalUp: 0,
  verticalDown: 1,
  horizontalLeft: 2,
  horizontalRight: 3,
  diagonalUpRight: 4,
  diagonalUpLeft: 5,
  diagonalDownRight: 6,
  diagonalDownLeft: 7,
  nameMapping: { 0: "verticalUp", 1: "verticalDown", 2: "horizontalLeft", 3: "horizontalRight", 4: "diagonalUpRight", 5: "diagonalUpLeft", 6: "diagonalDownRight", 7: "diagonalDownLeft" },
  getName: (value) => FingerDirection.nameMapping[value]
};
var FingerGesture = class {
  constructor(name) {
    __publicField(this, "name");
    __publicField(this, "curls");
    __publicField(this, "directions");
    __publicField(this, "weights");
    __publicField(this, "weightsRelative");
    this.name = name;
    this.curls = {};
    this.directions = {};
    this.weights = [1, 1, 1, 1, 1];
    this.weightsRelative = [1, 1, 1, 1, 1];
  }
  addCurl(finger, curl, confidence) {
    if (typeof this.curls[finger] === "undefined")
      this.curls[finger] = [];
    this.curls[finger].push([curl, confidence]);
  }
  addDirection(finger, position, confidence) {
    if (!this.directions[finger])
      this.directions[finger] = [];
    this.directions[finger].push([position, confidence]);
  }
  setWeight(finger, weight) {
    this.weights[finger] = weight;
    const total = this.weights.reduce((a6, b2) => a6 + b2, 0);
    this.weightsRelative = this.weights.map((el) => el * 5 / total);
  }
  matchAgainst(detectedCurls, detectedDirections) {
    let confidence = 0;
    for (const fingerIdx in detectedCurls) {
      const detectedCurl = detectedCurls[fingerIdx];
      const expectedCurls = this.curls[fingerIdx];
      if (typeof expectedCurls === "undefined") {
        confidence += this.weightsRelative[fingerIdx];
        continue;
      }
      for (const [expectedCurl, score] of expectedCurls) {
        if (detectedCurl === expectedCurl) {
          confidence += score * this.weightsRelative[fingerIdx];
          break;
        }
      }
    }
    for (const fingerIdx in detectedDirections) {
      const detectedDirection = detectedDirections[fingerIdx];
      const expectedDirections = this.directions[fingerIdx];
      if (typeof expectedDirections === "undefined") {
        confidence += this.weightsRelative[fingerIdx];
        continue;
      }
      for (const [expectedDirection, score] of expectedDirections) {
        if (detectedDirection === expectedDirection) {
          confidence += score * this.weightsRelative[fingerIdx];
          break;
        }
      }
    }
    return confidence / 10;
  }
};
var ThumbsUp = new FingerGesture("thumbs up");
ThumbsUp.addCurl(Finger.thumb, FingerCurl.none, 1);
ThumbsUp.addDirection(Finger.thumb, FingerDirection.verticalUp, 1);
ThumbsUp.addDirection(Finger.thumb, FingerDirection.diagonalUpLeft, 0.25);
ThumbsUp.addDirection(Finger.thumb, FingerDirection.diagonalUpRight, 0.25);
for (const finger of [Finger.index, Finger.middle, Finger.ring, Finger.pinky]) {
  ThumbsUp.addCurl(finger, FingerCurl.full, 1);
  ThumbsUp.addDirection(finger, FingerDirection.horizontalLeft, 1);
  ThumbsUp.addDirection(finger, FingerDirection.horizontalRight, 1);
}
var Victory = new FingerGesture("victory");
Victory.addCurl(Finger.thumb, FingerCurl.half, 0.5);
Victory.addCurl(Finger.thumb, FingerCurl.none, 0.5);
Victory.addDirection(Finger.thumb, FingerDirection.verticalUp, 1);
Victory.addDirection(Finger.thumb, FingerDirection.diagonalUpLeft, 1);
Victory.addCurl(Finger.index, FingerCurl.none, 1);
Victory.addDirection(Finger.index, FingerDirection.verticalUp, 0.75);
Victory.addDirection(Finger.index, FingerDirection.diagonalUpLeft, 1);
Victory.addCurl(Finger.middle, FingerCurl.none, 1);
Victory.addDirection(Finger.middle, FingerDirection.verticalUp, 1);
Victory.addDirection(Finger.middle, FingerDirection.diagonalUpLeft, 0.75);
Victory.addCurl(Finger.ring, FingerCurl.full, 1);
Victory.addDirection(Finger.ring, FingerDirection.verticalUp, 0.2);
Victory.addDirection(Finger.ring, FingerDirection.diagonalUpLeft, 1);
Victory.addDirection(Finger.ring, FingerDirection.horizontalLeft, 0.2);
Victory.addCurl(Finger.pinky, FingerCurl.full, 1);
Victory.addDirection(Finger.pinky, FingerDirection.verticalUp, 0.2);
Victory.addDirection(Finger.pinky, FingerDirection.diagonalUpLeft, 1);
Victory.addDirection(Finger.pinky, FingerDirection.horizontalLeft, 0.2);
Victory.setWeight(Finger.index, 2);
Victory.setWeight(Finger.middle, 2);
var fingergesture_default = [ThumbsUp, Victory];
var minConfidence = 0.7;
var options = {
  HALF_CURL_START_LIMIT: 60,
  NO_CURL_START_LIMIT: 130,
  DISTANCE_VOTE_POWER: 1.1,
  SINGLE_ANGLE_VOTE_POWER: 0.9,
  TOTAL_ANGLE_VOTE_POWER: 1.6
};
function calculateSlope(point1x, point1y, point2x, point2y) {
  const value = (point1y - point2y) / (point1x - point2x);
  let slope = Math.atan(value) * 180 / Math.PI;
  if (slope <= 0)
    slope = -slope;
  else if (slope > 0)
    slope = 180 - slope;
  return slope;
}
function getSlopes(point1, point2) {
  if (!point1 || !point2)
    return [0, 0];
  const slopeXY = calculateSlope(point1[0], point1[1], point2[0], point2[1]);
  if (point1.length === 2)
    return slopeXY;
  const slopeYZ = calculateSlope(point1[1], point1[2], point2[1], point2[2]);
  return [slopeXY, slopeYZ];
}
function angleOrientationAt(angle2, weightageAt = 1) {
  let isVertical = 0;
  let isDiagonal = 0;
  let isHorizontal = 0;
  if (angle2 >= 75 && angle2 <= 105)
    isVertical = 1 * weightageAt;
  else if (angle2 >= 25 && angle2 <= 155)
    isDiagonal = 1 * weightageAt;
  else
    isHorizontal = 1 * weightageAt;
  return [isVertical, isDiagonal, isHorizontal];
}
function estimateFingerCurl(startPoint, midPoint, endPoint) {
  const start_mid_x_dist = startPoint[0] - midPoint[0];
  const start_end_x_dist = startPoint[0] - endPoint[0];
  const mid_end_x_dist = midPoint[0] - endPoint[0];
  const start_mid_y_dist = startPoint[1] - midPoint[1];
  const start_end_y_dist = startPoint[1] - endPoint[1];
  const mid_end_y_dist = midPoint[1] - endPoint[1];
  const start_mid_z_dist = startPoint[2] - midPoint[2];
  const start_end_z_dist = startPoint[2] - endPoint[2];
  const mid_end_z_dist = midPoint[2] - endPoint[2];
  const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist + start_mid_z_dist * start_mid_z_dist);
  const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist + start_end_z_dist * start_end_z_dist);
  const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist + mid_end_z_dist * mid_end_z_dist);
  let cos_in = (mid_end_dist * mid_end_dist + start_mid_dist * start_mid_dist - start_end_dist * start_end_dist) / (2 * mid_end_dist * start_mid_dist);
  if (cos_in > 1)
    cos_in = 1;
  else if (cos_in < -1)
    cos_in = -1;
  let angleOfCurve = Math.acos(cos_in);
  angleOfCurve = 57.2958 * angleOfCurve % 180;
  let fingerCurl;
  if (angleOfCurve > options.NO_CURL_START_LIMIT)
    fingerCurl = FingerCurl.none;
  else if (angleOfCurve > options.HALF_CURL_START_LIMIT)
    fingerCurl = FingerCurl.half;
  else
    fingerCurl = FingerCurl.full;
  return fingerCurl;
}
function estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
  let estimatedDirection;
  if (max_dist_x === Math.abs(start_end_x_dist)) {
    if (start_end_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  } else if (max_dist_x === Math.abs(start_mid_x_dist)) {
    if (start_mid_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  } else {
    if (mid_end_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  }
  return estimatedDirection;
}
function estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y) {
  let estimatedDirection;
  if (max_dist_y === Math.abs(start_end_y_dist)) {
    if (start_end_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  } else if (max_dist_y === Math.abs(start_mid_y_dist)) {
    if (start_mid_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  } else {
    if (mid_end_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  }
  return estimatedDirection;
}
function estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
  let estimatedDirection;
  const reqd_vertical_direction = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
  const reqd_horizontal_direction = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  if (reqd_vertical_direction === FingerDirection.verticalUp) {
    if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
      estimatedDirection = FingerDirection.diagonalUpLeft;
    else
      estimatedDirection = FingerDirection.diagonalUpRight;
  } else {
    if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
      estimatedDirection = FingerDirection.diagonalDownLeft;
    else
      estimatedDirection = FingerDirection.diagonalDownRight;
  }
  return estimatedDirection;
}
function calculateFingerDirection(startPoint, midPoint, endPoint, fingerSlopes) {
  const start_mid_x_dist = startPoint[0] - midPoint[0];
  const start_end_x_dist = startPoint[0] - endPoint[0];
  const mid_end_x_dist = midPoint[0] - endPoint[0];
  const start_mid_y_dist = startPoint[1] - midPoint[1];
  const start_end_y_dist = startPoint[1] - endPoint[1];
  const mid_end_y_dist = midPoint[1] - endPoint[1];
  const max_dist_x = Math.max(Math.abs(start_mid_x_dist), Math.abs(start_end_x_dist), Math.abs(mid_end_x_dist));
  const max_dist_y = Math.max(Math.abs(start_mid_y_dist), Math.abs(start_end_y_dist), Math.abs(mid_end_y_dist));
  let voteVertical = 0;
  let voteDiagonal = 0;
  let voteHorizontal = 0;
  const start_end_x_y_dist_ratio = max_dist_y / (max_dist_x + 1e-5);
  if (start_end_x_y_dist_ratio > 1.5)
    voteVertical += options.DISTANCE_VOTE_POWER;
  else if (start_end_x_y_dist_ratio > 0.66)
    voteDiagonal += options.DISTANCE_VOTE_POWER;
  else
    voteHorizontal += options.DISTANCE_VOTE_POWER;
  const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist);
  const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist);
  const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist);
  const max_dist = Math.max(start_mid_dist, start_end_dist, mid_end_dist);
  let calc_start_point_x = startPoint[0];
  let calc_start_point_y = startPoint[1];
  let calc_end_point_x = endPoint[0];
  let calc_end_point_y = endPoint[1];
  if (max_dist === start_mid_dist) {
    calc_end_point_x = endPoint[0];
    calc_end_point_y = endPoint[1];
  } else if (max_dist === mid_end_dist) {
    calc_start_point_x = midPoint[0];
    calc_start_point_y = midPoint[1];
  }
  const calcStartPoint = [calc_start_point_x, calc_start_point_y];
  const calcEndPoint = [calc_end_point_x, calc_end_point_y];
  const totalAngle = getSlopes(calcStartPoint, calcEndPoint);
  const votes = angleOrientationAt(totalAngle, options.TOTAL_ANGLE_VOTE_POWER);
  voteVertical += votes[0];
  voteDiagonal += votes[1];
  voteHorizontal += votes[2];
  for (const fingerSlope of fingerSlopes) {
    const fingerVotes = angleOrientationAt(fingerSlope, options.SINGLE_ANGLE_VOTE_POWER);
    voteVertical += fingerVotes[0];
    voteDiagonal += fingerVotes[1];
    voteHorizontal += fingerVotes[2];
  }
  let estimatedDirection;
  if (voteVertical === Math.max(voteVertical, voteDiagonal, voteHorizontal)) {
    estimatedDirection = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
  } else if (voteHorizontal === Math.max(voteDiagonal, voteHorizontal)) {
    estimatedDirection = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  } else {
    estimatedDirection = estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  }
  return estimatedDirection;
}
function estimate(landmarks) {
  const slopesXY = [];
  const slopesYZ = [];
  const fingerCurls = [];
  const fingerDirections = [];
  if (!landmarks)
    return { curls: fingerCurls, directions: fingerDirections };
  for (const finger of Finger.all) {
    const points = Finger.getPoints(finger);
    const slopeAtXY = [];
    const slopeAtYZ = [];
    for (const point2 of points) {
      const point1 = landmarks[point2[0]];
      const point22 = landmarks[point2[1]];
      const slopes = getSlopes(point1, point22);
      const slopeXY = slopes[0];
      const slopeYZ = slopes[1];
      slopeAtXY.push(slopeXY);
      slopeAtYZ.push(slopeYZ);
    }
    slopesXY.push(slopeAtXY);
    slopesYZ.push(slopeAtYZ);
  }
  for (const finger of Finger.all) {
    const pointIndexAt = finger === Finger.thumb ? 1 : 0;
    const fingerPointsAt = Finger.getPoints(finger);
    const startPoint = landmarks[fingerPointsAt[pointIndexAt][0]];
    const midPoint = landmarks[fingerPointsAt[pointIndexAt + 1][1]];
    const endPoint = landmarks[fingerPointsAt[3][1]];
    const fingerCurled = estimateFingerCurl(startPoint, midPoint, endPoint);
    const fingerPosition = calculateFingerDirection(startPoint, midPoint, endPoint, slopesXY[finger].slice(pointIndexAt));
    fingerCurls[finger] = fingerCurled;
    fingerDirections[finger] = fingerPosition;
  }
  return { curls: fingerCurls, directions: fingerDirections };
}
function analyze(keypoints2) {
  if (!keypoints2 || keypoints2.length === 0)
    return null;
  const estimatorRes = estimate(keypoints2);
  const landmarks = {};
  for (const fingerIdx of Finger.all) {
    landmarks[Finger.getName(fingerIdx)] = {
      curl: FingerCurl.getName(estimatorRes.curls[fingerIdx]),
      direction: FingerDirection.getName(estimatorRes.directions[fingerIdx])
    };
  }
  return landmarks;
}
function match(keypoints2) {
  const poses = [];
  if (!keypoints2 || keypoints2.length === 0)
    return poses;
  const estimatorRes = estimate(keypoints2);
  for (const gesture3 of fingergesture_default) {
    const confidence = gesture3.matchAgainst(estimatorRes.curls, estimatorRes.directions);
    if (confidence >= minConfidence)
      poses.push({ name: gesture3.name, confidence });
  }
  return poses;
}
var meshAnnotations2 = {
  thumb: [1, 2, 3, 4],
  index: [5, 6, 7, 8],
  middle: [9, 10, 11, 12],
  ring: [13, 14, 15, 16],
  pinky: [17, 18, 19, 20],
  palm: [0]
};
var handDetectorModel;
var handPoseModel;
var handPipeline;
async function predict5(input2, config3) {
  const predictions = await handPipeline.estimateHands(input2, config3);
  if (!predictions)
    return [];
  const hands = [];
  for (let i2 = 0; i2 < predictions.length; i2++) {
    const annotations2 = {};
    if (predictions[i2].landmarks) {
      for (const key of Object.keys(meshAnnotations2)) {
        annotations2[key] = meshAnnotations2[key].map((index) => predictions[i2].landmarks[index]);
      }
    }
    const keypoints2 = predictions[i2].landmarks;
    let box5 = [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0, 0];
    let boxRaw = [0, 0, 0, 0];
    if (keypoints2 && keypoints2.length > 0) {
      for (const pt of keypoints2) {
        if (pt[0] < box5[0])
          box5[0] = pt[0];
        if (pt[1] < box5[1])
          box5[1] = pt[1];
        if (pt[0] > box5[2])
          box5[2] = pt[0];
        if (pt[1] > box5[3])
          box5[3] = pt[1];
      }
      box5[2] -= box5[0];
      box5[3] -= box5[1];
      boxRaw = [box5[0] / (input2.shape[2] || 0), box5[1] / (input2.shape[1] || 0), box5[2] / (input2.shape[2] || 0), box5[3] / (input2.shape[1] || 0)];
    } else {
      box5 = predictions[i2].box ? [
        Math.trunc(Math.max(0, predictions[i2].box.topLeft[0])),
        Math.trunc(Math.max(0, predictions[i2].box.topLeft[1])),
        Math.trunc(Math.min(input2.shape[2] || 0, predictions[i2].box.bottomRight[0]) - Math.max(0, predictions[i2].box.topLeft[0])),
        Math.trunc(Math.min(input2.shape[1] || 0, predictions[i2].box.bottomRight[1]) - Math.max(0, predictions[i2].box.topLeft[1]))
      ] : [0, 0, 0, 0];
      boxRaw = [
        predictions[i2].box.topLeft[0] / (input2.shape[2] || 0),
        predictions[i2].box.topLeft[1] / (input2.shape[1] || 0),
        (predictions[i2].box.bottomRight[0] - predictions[i2].box.topLeft[0]) / (input2.shape[2] || 0),
        (predictions[i2].box.bottomRight[1] - predictions[i2].box.topLeft[1]) / (input2.shape[1] || 0)
      ];
    }
    const landmarks = analyze(keypoints2);
    hands.push({
      id: i2,
      score: Math.round(100 * predictions[i2].confidence) / 100,
      boxScore: Math.round(100 * predictions[i2].boxConfidence) / 100,
      fingerScore: Math.round(100 * predictions[i2].fingerConfidence) / 100,
      label: "hand",
      box: box5,
      boxRaw,
      keypoints: keypoints2,
      annotations: annotations2,
      landmarks
    });
  }
  return hands;
}
async function load7(config3) {
  var _a, _b, _c, _d, _e2, _f;
  if (env2.initial) {
    handDetectorModel = null;
    handPoseModel = null;
  }
  if (!handDetectorModel || !handPoseModel) {
    [handDetectorModel, handPoseModel] = await Promise.all([
      config3.hand.enabled ? loadGraphModel(join(config3.modelBasePath, ((_a = config3.hand.detector) == null ? void 0 : _a.modelPath) || ""), { fromTFHub: (((_b = config3.hand.detector) == null ? void 0 : _b.modelPath) || "").includes("tfhub.dev") }) : null,
      config3.hand.landmarks ? loadGraphModel(join(config3.modelBasePath, ((_c = config3.hand.skeleton) == null ? void 0 : _c.modelPath) || ""), { fromTFHub: (((_d = config3.hand.skeleton) == null ? void 0 : _d.modelPath) || "").includes("tfhub.dev") }) : null
    ]);
    if (config3.hand.enabled) {
      if (!handDetectorModel || !handDetectorModel["modelUrl"])
        log("load model failed:", ((_e2 = config3.hand.detector) == null ? void 0 : _e2.modelPath) || "");
      else if (config3.debug)
        log("load model:", handDetectorModel["modelUrl"]);
      if (!handPoseModel || !handPoseModel["modelUrl"])
        log("load model failed:", ((_f = config3.hand.skeleton) == null ? void 0 : _f.modelPath) || "");
      else if (config3.debug)
        log("load model:", handPoseModel["modelUrl"]);
    }
  } else {
    if (config3.debug)
      log("cached model:", handDetectorModel["modelUrl"]);
    if (config3.debug)
      log("cached model:", handPoseModel["modelUrl"]);
  }
  const handDetector = new HandDetector(handDetectorModel);
  handPipeline = new HandPipeline(handDetector, handPoseModel);
  return [handDetectorModel, handPoseModel];
}
function calc(keypoints2, outputSize2 = [1, 1]) {
  const coords9 = [keypoints2.map((pt) => pt[0]), keypoints2.map((pt) => pt[1])];
  const min7 = [Math.min(...coords9[0]), Math.min(...coords9[1])];
  const max7 = [Math.max(...coords9[0]), Math.max(...coords9[1])];
  const box5 = [min7[0], min7[1], max7[0] - min7[0], max7[1] - min7[1]];
  const boxRaw = [box5[0] / outputSize2[0], box5[1] / outputSize2[1], box5[2] / outputSize2[0], box5[3] / outputSize2[1]];
  return { box: box5, boxRaw };
}
function square4(keypoints2, outputSize2 = [1, 1]) {
  const coords9 = [keypoints2.map((pt) => pt[0]), keypoints2.map((pt) => pt[1])];
  const min7 = [Math.min(...coords9[0]), Math.min(...coords9[1])];
  const max7 = [Math.max(...coords9[0]), Math.max(...coords9[1])];
  const center = [(min7[0] + max7[0]) / 2, (min7[1] + max7[1]) / 2];
  const dist = Math.max(center[0] - min7[0], center[1] - min7[1], -center[0] + max7[0], -center[1] + max7[1]);
  const box5 = [Math.trunc(center[0] - dist), Math.trunc(center[1] - dist), Math.trunc(2 * dist), Math.trunc(2 * dist)];
  const boxRaw = [box5[0] / outputSize2[0], box5[1] / outputSize2[1], box5[2] / outputSize2[0], box5[3] / outputSize2[1]];
  return { box: box5, boxRaw };
}
function scale2(box5, scaleFact) {
  const dist = [box5[2] * scaleFact, box5[3] * scaleFact];
  const newBox = [
    box5[0] - (dist[0] - box5[2]) / 2,
    box5[1] - (dist[1] - box5[3]) / 2,
    dist[0],
    dist[1]
  ];
  return newBox;
}
function crop(box5) {
  const yxBox = [Math.max(0, box5[1]), Math.max(0, box5[0]), Math.min(1, box5[3] + box5[1]), Math.min(1, box5[2] + box5[0])];
  return yxBox;
}
var models = [null, null];
var modelOutputNodes = ["StatefulPartitionedCall/Postprocessor/Slice", "StatefulPartitionedCall/Postprocessor/ExpandDims_1"];
var inputSize4 = [[0, 0], [0, 0]];
var classes = ["hand", "fist", "pinch", "point", "face", "tip", "pinchtip"];
var faceIndex = 4;
var boxExpandFact = 1.6;
var maxDetectorResolution = 512;
var detectorExpandFact = 1.4;
var skipped4 = 0;
var outputSize = [0, 0];
var cache = {
  boxes: [],
  hands: []
};
var fingerMap = {
  thumb: [1, 2, 3, 4],
  index: [5, 6, 7, 8],
  middle: [9, 10, 11, 12],
  ring: [13, 14, 15, 16],
  pinky: [17, 18, 19, 20],
  palm: [0]
};
async function loadDetect(config3) {
  var _a;
  if (env2.initial)
    models[0] = null;
  if (!models[0]) {
    fakeOps(["tensorlistreserve", "enter", "tensorlistfromtensor", "merge", "loopcond", "switch", "exit", "tensorliststack", "nextiteration", "tensorlistsetitem", "tensorlistgetitem", "reciprocal", "shape", "split", "where"], config3);
    models[0] = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.hand.detector) == null ? void 0 : _a.modelPath) || ""));
    const inputs = Object.values(models[0].modelSignature["inputs"]);
    inputSize4[0][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize4[0][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    if (!models[0] || !models[0]["modelUrl"])
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", models[0]["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", models[0]["modelUrl"]);
  return models[0];
}
async function loadSkeleton(config3) {
  var _a;
  if (env2.initial)
    models[1] = null;
  if (!models[1]) {
    models[1] = await loadGraphModel(join(config3.modelBasePath, ((_a = config3.hand.skeleton) == null ? void 0 : _a.modelPath) || ""));
    const inputs = Object.values(models[1].modelSignature["inputs"]);
    inputSize4[1][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize4[1][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    if (!models[1] || !models[1]["modelUrl"])
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", models[1]["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", models[1]["modelUrl"]);
  return models[1];
}
async function detectHands(input2, config3) {
  const hands = [];
  if (!input2 || !models[0])
    return hands;
  const t2 = {};
  const ratio = (input2.shape[2] || 1) / (input2.shape[1] || 1);
  const height = Math.min(Math.round((input2.shape[1] || 0) / 8) * 8, maxDetectorResolution);
  const width = Math.round(height * ratio / 8) * 8;
  t2.resize = image.resizeBilinear(input2, [height, width]);
  t2.cast = cast(t2.resize, "int32");
  [t2.rawScores, t2.rawBoxes] = await models[0].executeAsync(t2.cast, modelOutputNodes);
  t2.boxes = squeeze(t2.rawBoxes, [0, 2]);
  t2.scores = squeeze(t2.rawScores, [0]);
  const classScores = unstack(t2.scores, 1);
  dispose(classScores[faceIndex]);
  classScores.splice(faceIndex, 1);
  t2.filtered = stack(classScores, 1);
  dispose(classScores);
  t2.max = max(t2.filtered, 1);
  t2.argmax = argMax(t2.filtered, 1);
  let id = 0;
  t2.nms = await image.nonMaxSuppressionAsync(t2.boxes, t2.max, config3.hand.maxDetected, config3.hand.iouThreshold, config3.hand.minConfidence);
  const nms = await t2.nms.data();
  const scores = await t2.max.data();
  const classNum = await t2.argmax.data();
  for (const nmsIndex of Array.from(nms)) {
    const boxSlice = slice(t2.boxes, nmsIndex, 1);
    const boxYX = await boxSlice.data();
    dispose(boxSlice);
    const boxData = [boxYX[1], boxYX[0], boxYX[3] - boxYX[1], boxYX[2] - boxYX[0]];
    const boxRaw = scale2(boxData, detectorExpandFact);
    const boxCrop = crop(boxRaw);
    const boxFull = [Math.trunc(boxData[0] * outputSize[0]), Math.trunc(boxData[1] * outputSize[1]), Math.trunc(boxData[2] * outputSize[0]), Math.trunc(boxData[3] * outputSize[1])];
    const score = scores[nmsIndex];
    const label = classes[classNum[nmsIndex]];
    const hand3 = { id: id++, score, box: boxFull, boxRaw, boxCrop, label };
    hands.push(hand3);
  }
  Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
  hands.sort((a6, b2) => b2.score - a6.score);
  if (hands.length > (config3.hand.maxDetected || 1))
    hands.length = config3.hand.maxDetected || 1;
  return hands;
}
async function detectFingers(input2, h2, config3) {
  const hand3 = {
    id: h2.id,
    score: Math.round(100 * h2.score) / 100,
    boxScore: Math.round(100 * h2.score) / 100,
    fingerScore: 0,
    box: h2.box,
    boxRaw: h2.boxRaw,
    label: h2.label,
    keypoints: [],
    landmarks: {},
    annotations: {}
  };
  if (input2 && models[1] && config3.hand.landmarks && h2.score > (config3.hand.minConfidence || 0)) {
    const t2 = {};
    t2.crop = image.cropAndResize(input2, [h2.boxCrop], [0], [inputSize4[1][0], inputSize4[1][1]], "bilinear");
    t2.cast = cast(t2.crop, "float32");
    t2.div = div(t2.cast, 255);
    [t2.score, t2.keypoints] = models[1].execute(t2.div);
    const rawScore = (await t2.score.data())[0];
    const score = (100 - Math.trunc(100 / (1 + Math.exp(rawScore)))) / 100;
    if (score >= (config3.hand.minConfidence || 0)) {
      hand3.fingerScore = score;
      t2.reshaped = reshape(t2.keypoints, [-1, 3]);
      const coordsData = await t2.reshaped.array();
      const coordsRaw = coordsData.map((kpt4) => [kpt4[0] / inputSize4[1][1], kpt4[1] / inputSize4[1][0], kpt4[2] || 0]);
      const coordsNorm = coordsRaw.map((kpt4) => [kpt4[0] * h2.boxRaw[2], kpt4[1] * h2.boxRaw[3], kpt4[2] || 0]);
      hand3.keypoints = coordsNorm.map((kpt4) => [
        outputSize[0] * (kpt4[0] + h2.boxRaw[0]),
        outputSize[1] * (kpt4[1] + h2.boxRaw[1]),
        kpt4[2] || 0
      ]);
      hand3.landmarks = analyze(hand3.keypoints);
      for (const key of Object.keys(fingerMap)) {
        hand3.annotations[key] = fingerMap[key].map((index) => hand3.landmarks && hand3.keypoints[index] ? hand3.keypoints[index] : null);
      }
    }
    Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
  }
  return hand3;
}
async function predict6(input2, config3) {
  var _a, _b;
  if (!models[0] || !models[1] || !((_a = models[0]) == null ? void 0 : _a.inputs[0].shape) || !((_b = models[1]) == null ? void 0 : _b.inputs[0].shape))
    return [];
  outputSize = [input2.shape[2] || 0, input2.shape[1] || 0];
  skipped4++;
  if (config3.skipFrame && skipped4 <= (config3.hand.skipFrames || 0)) {
    return cache.hands;
  }
  return new Promise(async (resolve) => {
    if (config3.skipFrame && skipped4 < 5 * (config3.hand.skipFrames || 0) && cache.hands.length > 0) {
      cache.hands = await Promise.all(cache.boxes.map((handBox) => detectFingers(input2, handBox, config3)));
    } else {
      cache.boxes = await detectHands(input2, config3);
      cache.hands = await Promise.all(cache.boxes.map((handBox) => detectFingers(input2, handBox, config3)));
      skipped4 = 0;
    }
    const oldCache = [...cache.boxes];
    cache.boxes.length = 0;
    if (config3.cacheSensitivity > 0) {
      for (let i2 = 0; i2 < cache.hands.length; i2++) {
        const boxKpt = square4(cache.hands[i2].keypoints, outputSize);
        if (boxKpt.box[2] / (input2.shape[2] || 1) > 0.05 && boxKpt.box[3] / (input2.shape[1] || 1) > 0.05 && cache.hands[i2].fingerScore && cache.hands[i2].fingerScore > (config3.hand.minConfidence || 0)) {
          const boxScale = scale2(boxKpt.box, boxExpandFact);
          const boxScaleRaw = scale2(boxKpt.boxRaw, boxExpandFact);
          const boxCrop = crop(boxScaleRaw);
          cache.boxes.push({ ...oldCache[i2], box: boxScale, boxRaw: boxScaleRaw, boxCrop });
        }
      }
    }
    resolve(cache.hands);
  });
}
var blazeposecoords_exports = {};
__export(blazeposecoords_exports, {
  connected: () => connected,
  kpt: () => kpt
});
var kpt = [
  "nose",
  "leftEyeInside",
  "leftEye",
  "leftEyeOutside",
  "rightEyeInside",
  "rightEye",
  "rightEyeOutside",
  "leftEar",
  "rightEar",
  "leftMouth",
  "rightMouth",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftPalm",
  "rightPalm",
  "leftIndex",
  "rightIndex",
  "leftPinky",
  "rightPinky",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle",
  "leftHeel",
  "rightHeel",
  "leftFoot",
  "rightFoot",
  "bodyCenter",
  "bodyTop",
  "leftThumb",
  "leftHand",
  "rightThumb",
  "rightHand"
];
var connected = {
  leftLeg: ["leftHip", "leftKnee", "leftAnkle", "leftHeel", "leftFoot"],
  rightLeg: ["rightHip", "rightKnee", "rightAnkle", "rightHeel", "rightFoot"],
  torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
  leftArm: ["leftShoulder", "leftElbow", "leftWrist", "leftPalm"],
  rightArm: ["rightShoulder", "rightElbow", "rightWrist", "rightPalm"],
  leftHand: [],
  rightHand: [],
  head: []
};
var env3 = { initial: true };
var models2 = [null, null];
var inputSize5 = [[0, 0], [0, 0]];
var skipped5 = Number.MAX_SAFE_INTEGER;
var outputNodes;
var cache2 = null;
var padding = [[0, 0], [0, 0], [0, 0], [0, 0]];
async function loadDetect2(config3) {
  var _a, _b;
  if (env3.initial)
    models2[0] = null;
  if (!models2[0] && ((_a = config3.body.detector) == null ? void 0 : _a.modelPath) || "") {
    models2[0] = await loadGraphModel(join(config3.modelBasePath, ((_b = config3.body.detector) == null ? void 0 : _b.modelPath) || ""));
    const inputs = Object.values(models2[0].modelSignature["inputs"]);
    inputSize5[0][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize5[0][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    if (!models2[0] || !models2[0]["modelUrl"])
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", models2[0]["modelUrl"]);
  } else if (config3.debug && models2[0])
    log("cached model:", models2[0]["modelUrl"]);
  return models2[0];
}
async function loadPose(config3) {
  var _a;
  if (env3.initial)
    models2[1] = null;
  if (!models2[1]) {
    models2[1] = await loadGraphModel(join(config3.modelBasePath, config3.body.modelPath || ""));
    const inputs = Object.values(models2[1].modelSignature["inputs"]);
    inputSize5[1][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize5[1][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    if ((_a = config3.body.modelPath) == null ? void 0 : _a.includes("lite"))
      outputNodes = ["ld_3d", "output_segmentation", "output_heatmap", "world_3d", "output_poseflag"];
    else
      outputNodes = ["Identity", "Identity_2", "Identity_3", "Identity_4", "Identity_1"];
    if (!models2[1] || !models2[1]["modelUrl"])
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", models2[1]["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", models2[1]["modelUrl"]);
  return models2[1];
}
function calculateBoxes(keypoints2, outputSize2) {
  const x2 = keypoints2.map((a6) => a6.position[0]);
  const y2 = keypoints2.map((a6) => a6.position[1]);
  const keypointsBox = [Math.min(...x2), Math.min(...y2), Math.max(...x2) - Math.min(...x2), Math.max(...y2) - Math.min(...y2)];
  const keypointsBoxRaw = [keypointsBox[0] / outputSize2[0], keypointsBox[1] / outputSize2[1], keypointsBox[2] / outputSize2[0], keypointsBox[3] / outputSize2[1]];
  return { keypointsBox, keypointsBoxRaw };
}
async function prepareImage(input2) {
  const t2 = {};
  if (!input2.shape || !input2.shape[1] || !input2.shape[2])
    return input2;
  padding = [
    [0, 0],
    [input2.shape[2] > input2.shape[1] ? Math.trunc((input2.shape[2] - input2.shape[1]) / 2) : 0, input2.shape[2] > input2.shape[1] ? Math.trunc((input2.shape[2] - input2.shape[1]) / 2) : 0],
    [input2.shape[1] > input2.shape[2] ? Math.trunc((input2.shape[1] - input2.shape[2]) / 2) : 0, input2.shape[1] > input2.shape[2] ? Math.trunc((input2.shape[1] - input2.shape[2]) / 2) : 0],
    [0, 0]
  ];
  t2.pad = pad(input2, padding);
  t2.resize = image.resizeBilinear(t2.pad, [inputSize5[1][0], inputSize5[1][1]]);
  const final = div(t2.resize, 255);
  Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
  return final;
}
function rescaleKeypoints(keypoints2, outputSize2) {
  for (const kpt4 of keypoints2) {
    kpt4.position = [
      kpt4.position[0] * (outputSize2[0] + padding[2][0] + padding[2][1]) / outputSize2[0] - padding[2][0],
      kpt4.position[1] * (outputSize2[1] + padding[1][0] + padding[1][1]) / outputSize2[1] - padding[1][0],
      kpt4.position[2]
    ];
    kpt4.positionRaw = [
      kpt4.position[0] / outputSize2[0],
      kpt4.position[1] / outputSize2[1],
      kpt4.position[2]
    ];
  }
  return keypoints2;
}
async function detectParts(input2, config3, outputSize2) {
  var _a;
  const t2 = {};
  t2.input = await prepareImage(input2);
  [t2.ld, t2.segmentation, t2.heatmap, t2.world, t2.poseflag] = await ((_a = models2[1]) == null ? void 0 : _a.execute(t2.input, outputNodes));
  const points = await t2.ld.data();
  const keypointsRelative = [];
  const depth = 5;
  for (let i2 = 0; i2 < points.length / depth; i2++) {
    const score = (100 - Math.trunc(100 / (1 + Math.exp(points[depth * i2 + 3])))) / 100;
    const positionRaw = [points[depth * i2 + 0] / inputSize5[1][0], points[depth * i2 + 1] / inputSize5[1][1], points[depth * i2 + 2] + 0];
    const position = [Math.trunc(outputSize2[0] * positionRaw[0]), Math.trunc(outputSize2[1] * positionRaw[1]), positionRaw[2]];
    keypointsRelative.push({ part: kpt[i2], positionRaw, position, score });
  }
  const avgScore = Math.round(100 * keypointsRelative.reduce((prev, curr) => prev += curr.score, 0) / keypointsRelative.length) / 100;
  if (avgScore < (config3.body.minConfidence || 0))
    return null;
  const keypoints2 = rescaleKeypoints(keypointsRelative, outputSize2);
  const boxes = calculateBoxes(keypoints2, [outputSize2[0], outputSize2[1]]);
  Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
  const annotations2 = {};
  for (const [name, indexes] of Object.entries(connected)) {
    const pt = [];
    for (let i2 = 0; i2 < indexes.length - 1; i2++) {
      const pt0 = keypoints2.find((kpt4) => kpt4.part === indexes[i2]);
      const pt1 = keypoints2.find((kpt4) => kpt4.part === indexes[i2 + 1]);
      if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
        pt.push([pt0.position, pt1.position]);
    }
    annotations2[name] = pt;
  }
  return { id: 0, score: avgScore, box: boxes.keypointsBox, boxRaw: boxes.keypointsBoxRaw, keypoints: keypoints2, annotations: annotations2 };
}
async function predict7(input2, config3) {
  const outputSize2 = [input2.shape[2] || 0, input2.shape[1] || 0];
  if (skipped5 < (config3.body.skipFrames || 0) && config3.skipFrame) {
    skipped5++;
  } else {
    cache2 = await detectParts(input2, config3, outputSize2);
    skipped5 = 0;
  }
  if (cache2)
    return [cache2];
  return [];
}
var efficientposecoords_exports = {};
__export(efficientposecoords_exports, {
  connected: () => connected2,
  kpt: () => kpt2
});
var kpt2 = [
  "head",
  "neck",
  "rightShoulder",
  "rightElbow",
  "rightWrist",
  "chest",
  "leftShoulder",
  "leftElbow",
  "leftWrist",
  "bodyCenter",
  "rightHip",
  "rightKnee",
  "rightAnkle",
  "leftHip",
  "leftKnee",
  "leftAnkle"
];
var connected2 = {
  leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
  rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
  torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
  leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
  rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
  head: []
};
var model8;
var cache3 = { id: 0, keypoints: [], box: [0, 0, 0, 0], boxRaw: [0, 0, 0, 0], score: 0, annotations: {} };
var skipped6 = Number.MAX_SAFE_INTEGER;
async function load8(config3) {
  if (env2.initial)
    model8 = null;
  if (!model8) {
    model8 = await loadGraphModel(join(config3.modelBasePath, config3.body.modelPath || ""));
    if (!model8 || !model8["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model8["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model8["modelUrl"]);
  return model8;
}
function max2d(inputs, minScore) {
  const [width, height] = inputs.shape;
  return tidy(() => {
    const mod4 = (a6, b2) => sub(a6, mul(div(a6, scalar(b2, "int32")), scalar(b2, "int32")));
    const reshaped = reshape(inputs, [height * width]);
    const newScore = max(reshaped, 0).dataSync()[0];
    if (newScore > minScore) {
      const coordinates = argMax(reshaped, 0);
      const x2 = mod4(coordinates, width).dataSync()[0];
      const y2 = div(coordinates, scalar(width, "int32")).dataSync()[0];
      return [x2, y2, newScore];
    }
    return [0, 0, newScore];
  });
}
async function predict8(image7, config3) {
  var _a;
  if (skipped6 < (((_a = config3.body) == null ? void 0 : _a.skipFrames) || 0) && config3.skipFrame && Object.keys(cache3.keypoints).length > 0) {
    skipped6++;
    return [cache3];
  }
  skipped6 = 0;
  return new Promise(async (resolve) => {
    var _a2;
    const tensor2 = tidy(() => {
      if (!(model8 == null ? void 0 : model8.inputs[0].shape))
        return null;
      const resize = image.resizeBilinear(image7, [model8.inputs[0].shape[2], model8.inputs[0].shape[1]], false);
      const enhance2 = mul(resize, 2);
      const norm2 = enhance2.sub(1);
      return norm2;
    });
    let resT;
    if (config3.body.enabled)
      resT = await (model8 == null ? void 0 : model8.predict(tensor2));
    dispose(tensor2);
    if (resT) {
      cache3.keypoints.length = 0;
      const squeeze2 = resT.squeeze();
      dispose(resT);
      const stack2 = squeeze2.unstack(2);
      dispose(squeeze2);
      for (let id = 0; id < stack2.length; id++) {
        const [x22, y22, partScore] = max2d(stack2[id], config3.body.minConfidence);
        if (partScore > (((_a2 = config3.body) == null ? void 0 : _a2.minConfidence) || 0)) {
          cache3.keypoints.push({
            score: Math.round(100 * partScore) / 100,
            part: kpt2[id],
            positionRaw: [
              x22 / model8.inputs[0].shape[2],
              y22 / model8.inputs[0].shape[1]
            ],
            position: [
              Math.round(image7.shape[2] * x22 / model8.inputs[0].shape[2]),
              Math.round(image7.shape[1] * y22 / model8.inputs[0].shape[1])
            ]
          });
        }
      }
      stack2.forEach((s2) => dispose(s2));
    }
    cache3.score = cache3.keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
    const x2 = cache3.keypoints.map((a6) => a6.position[0]);
    const y2 = cache3.keypoints.map((a6) => a6.position[1]);
    cache3.box = [
      Math.min(...x2),
      Math.min(...y2),
      Math.max(...x2) - Math.min(...x2),
      Math.max(...y2) - Math.min(...y2)
    ];
    const xRaw = cache3.keypoints.map((a6) => a6.positionRaw[0]);
    const yRaw = cache3.keypoints.map((a6) => a6.positionRaw[1]);
    cache3.boxRaw = [
      Math.min(...xRaw),
      Math.min(...yRaw),
      Math.max(...xRaw) - Math.min(...xRaw),
      Math.max(...yRaw) - Math.min(...yRaw)
    ];
    for (const [name, indexes] of Object.entries(connected2)) {
      const pt = [];
      for (let i2 = 0; i2 < indexes.length - 1; i2++) {
        const pt0 = cache3.keypoints.find((kpt4) => kpt4.part === indexes[i2]);
        const pt1 = cache3.keypoints.find((kpt4) => kpt4.part === indexes[i2 + 1]);
        if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
          pt.push([pt0.position, pt1.position]);
      }
      cache3.annotations[name] = pt;
    }
    resolve([cache3]);
  });
}
var movenetcoords_exports = {};
__export(movenetcoords_exports, {
  connected: () => connected3,
  kpt: () => kpt3,
  pairs: () => pairs
});
var kpt3 = [
  "nose",
  "leftEye",
  "rightEye",
  "leftEar",
  "rightEar",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle"
];
var pairs = [
  ["leftEye", "rightEye"],
  ["leftEar", "rightEar"],
  ["leftShoulder", "rightShoulder"],
  ["leftElbow", "rightElbow"],
  ["leftWrist", "rightWrist"],
  ["leftHip", "rightHip"],
  ["leftKnee", "rightKnee"],
  ["leftAnkle", "rightAnkle"]
];
var connected3 = {
  leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
  rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
  torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
  leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
  rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
  head: []
};
var model9;
var inputSize6 = 0;
var boxExpandFact2 = 1.5;
var cache4 = {
  boxes: [],
  bodies: []
};
var skipped7 = Number.MAX_SAFE_INTEGER;
var keypoints = [];
async function load9(config3) {
  if (env2.initial)
    model9 = null;
  if (!model9) {
    fakeOps(["size"], config3);
    model9 = await loadGraphModel(join(config3.modelBasePath, config3.body.modelPath || ""));
    if (!model9 || !model9["modelUrl"])
      log("load model failed:", config3.body.modelPath);
    else if (config3.debug)
      log("load model:", model9["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model9["modelUrl"]);
  inputSize6 = model9.inputs[0].shape ? model9.inputs[0].shape[2] : 0;
  if (inputSize6 === -1)
    inputSize6 = 256;
  return model9;
}
function fixSides() {
  for (const pair of pairs) {
    let left = keypoints.find((kp) => kp.part === pair[0]);
    let right = keypoints.find((kp) => kp.part === pair[1]);
    if (left && right) {
      if (left.position[0] > right.position[0]) {
        const tmp2 = left;
        left = right;
        right = tmp2;
      }
    }
  }
}
async function parseSinglePose(res2, config3, image7, inputBox) {
  const kpt4 = res2[0][0];
  keypoints.length = 0;
  let score = 0;
  for (let id = 0; id < kpt4.length; id++) {
    score = kpt4[id][2];
    if (score > config3.body.minConfidence) {
      const positionRaw = [
        (inputBox[3] - inputBox[1]) * kpt4[id][1] + inputBox[1],
        (inputBox[2] - inputBox[0]) * kpt4[id][0] + inputBox[0]
      ];
      keypoints.push({
        score: Math.round(100 * score) / 100,
        part: kpt3[id],
        positionRaw,
        position: [
          Math.round((image7.shape[2] || 0) * positionRaw[0]),
          Math.round((image7.shape[1] || 0) * positionRaw[1])
        ]
      });
    }
  }
  fixSides();
  score = keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
  const bodies = [];
  const newBox = calc(keypoints.map((pt) => pt.position), [image7.shape[2], image7.shape[1]]);
  const annotations2 = {};
  for (const [name, indexes] of Object.entries(connected3)) {
    const pt = [];
    for (let i2 = 0; i2 < indexes.length - 1; i2++) {
      const pt0 = keypoints.find((kp) => kp.part === indexes[i2]);
      const pt1 = keypoints.find((kp) => kp.part === indexes[i2 + 1]);
      if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
        pt.push([pt0.position, pt1.position]);
    }
    annotations2[name] = pt;
  }
  bodies.push({ id: 0, score, box: newBox.box, boxRaw: newBox.boxRaw, keypoints, annotations: annotations2 });
  return bodies;
}
async function parseMultiPose(res2, config3, image7, inputBox) {
  const bodies = [];
  for (let id = 0; id < res2[0].length; id++) {
    const kpt4 = res2[0][id];
    const totalScore = Math.round(100 * kpt4[51 + 4]) / 100;
    if (totalScore > config3.body.minConfidence) {
      keypoints.length = 0;
      for (let i2 = 0; i2 < 17; i2++) {
        const score = kpt4[3 * i2 + 2];
        if (score > config3.body.minConfidence) {
          const positionRaw = [
            (inputBox[3] - inputBox[1]) * kpt4[3 * i2 + 1] + inputBox[1],
            (inputBox[2] - inputBox[0]) * kpt4[3 * i2 + 0] + inputBox[0]
          ];
          keypoints.push({
            part: kpt3[i2],
            score: Math.round(100 * score) / 100,
            positionRaw,
            position: [Math.round((image7.shape[2] || 0) * positionRaw[0]), Math.round((image7.shape[1] || 0) * positionRaw[1])]
          });
        }
      }
      fixSides();
      const newBox = calc(keypoints.map((pt) => pt.position), [image7.shape[2], image7.shape[1]]);
      const annotations2 = {};
      for (const [name, indexes] of Object.entries(connected3)) {
        const pt = [];
        for (let i2 = 0; i2 < indexes.length - 1; i2++) {
          const pt0 = keypoints.find((kp) => kp.part === indexes[i2]);
          const pt1 = keypoints.find((kp) => kp.part === indexes[i2 + 1]);
          if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
            pt.push([pt0.position, pt1.position]);
        }
        annotations2[name] = pt;
      }
      bodies.push({ id, score: totalScore, box: newBox.box, boxRaw: newBox.boxRaw, keypoints: [...keypoints], annotations: annotations2 });
    }
  }
  bodies.sort((a6, b2) => b2.score - a6.score);
  if (bodies.length > config3.body.maxDetected)
    bodies.length = config3.body.maxDetected;
  return bodies;
}
async function predict9(input2, config3) {
  if (!model9 || !(model9 == null ? void 0 : model9.inputs[0].shape))
    return [];
  if (!config3.skipFrame)
    cache4.boxes.length = 0;
  skipped7++;
  if (config3.skipFrame && skipped7 <= (config3.body.skipFrames || 0)) {
    return cache4.bodies;
  }
  return new Promise(async (resolve) => {
    const t2 = {};
    skipped7 = 0;
    cache4.bodies = [];
    if (cache4.boxes.length >= (config3.body.maxDetected || 0)) {
      for (let i2 = 0; i2 < cache4.boxes.length; i2++) {
        t2.crop = image.cropAndResize(input2, [cache4.boxes[i2]], [0], [inputSize6, inputSize6], "bilinear");
        t2.cast = cast(t2.crop, "int32");
        t2.res = await (model9 == null ? void 0 : model9.predict(t2.cast));
        const res2 = await t2.res.array();
        const newBodies = t2.res.shape[2] === 17 ? await parseSinglePose(res2, config3, input2, cache4.boxes[i2]) : await parseMultiPose(res2, config3, input2, cache4.boxes[i2]);
        cache4.bodies = cache4.bodies.concat(newBodies);
        Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
      }
    }
    if (cache4.bodies.length !== config3.body.maxDetected) {
      t2.resized = image.resizeBilinear(input2, [inputSize6, inputSize6], false);
      t2.cast = cast(t2.resized, "int32");
      t2.res = await (model9 == null ? void 0 : model9.predict(t2.cast));
      const res2 = await t2.res.array();
      cache4.bodies = t2.res.shape[2] === 17 ? await parseSinglePose(res2, config3, input2, [0, 0, 1, 1]) : await parseMultiPose(res2, config3, input2, [0, 0, 1, 1]);
      Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
    }
    cache4.boxes.length = 0;
    for (let i2 = 0; i2 < cache4.bodies.length; i2++) {
      if (cache4.bodies[i2].keypoints.length > kpt3.length / 2) {
        const scaledBox = scale2(cache4.bodies[i2].boxRaw, boxExpandFact2);
        const cropBox = crop(scaledBox);
        cache4.boxes.push(cropBox);
      }
    }
    resolve(cache4.bodies);
  });
}
var labels = [
  { class: 1, label: "person" },
  { class: 2, label: "bicycle" },
  { class: 3, label: "car" },
  { class: 4, label: "motorcycle" },
  { class: 5, label: "airplane" },
  { class: 6, label: "bus" },
  { class: 7, label: "train" },
  { class: 8, label: "truck" },
  { class: 9, label: "boat" },
  { class: 10, label: "traffic light" },
  { class: 11, label: "fire hydrant" },
  { class: 12, label: "stop sign" },
  { class: 13, label: "parking meter" },
  { class: 14, label: "bench" },
  { class: 15, label: "bird" },
  { class: 16, label: "cat" },
  { class: 17, label: "dog" },
  { class: 18, label: "horse" },
  { class: 19, label: "sheep" },
  { class: 20, label: "cow" },
  { class: 21, label: "elephant" },
  { class: 22, label: "bear" },
  { class: 23, label: "zebra" },
  { class: 24, label: "giraffe" },
  { class: 25, label: "backpack" },
  { class: 26, label: "umbrella" },
  { class: 27, label: "handbag" },
  { class: 28, label: "tie" },
  { class: 29, label: "suitcase" },
  { class: 30, label: "frisbee" },
  { class: 31, label: "skis" },
  { class: 32, label: "snowboard" },
  { class: 33, label: "sports ball" },
  { class: 34, label: "kite" },
  { class: 35, label: "baseball bat" },
  { class: 36, label: "baseball glove" },
  { class: 37, label: "skateboard" },
  { class: 38, label: "surfboard" },
  { class: 39, label: "tennis racket" },
  { class: 40, label: "bottle" },
  { class: 41, label: "wine glass" },
  { class: 42, label: "cup" },
  { class: 43, label: "fork" },
  { class: 44, label: "knife" },
  { class: 45, label: "spoon" },
  { class: 46, label: "bowl" },
  { class: 47, label: "banana" },
  { class: 48, label: "apple" },
  { class: 49, label: "sandwich" },
  { class: 50, label: "orange" },
  { class: 51, label: "broccoli" },
  { class: 52, label: "carrot" },
  { class: 53, label: "hot dog" },
  { class: 54, label: "pizza" },
  { class: 55, label: "donut" },
  { class: 56, label: "cake" },
  { class: 57, label: "chair" },
  { class: 58, label: "couch" },
  { class: 59, label: "potted plant" },
  { class: 60, label: "bed" },
  { class: 61, label: "dining table" },
  { class: 62, label: "toilet" },
  { class: 63, label: "tv" },
  { class: 64, label: "laptop" },
  { class: 65, label: "mouse" },
  { class: 66, label: "remote" },
  { class: 67, label: "keyboard" },
  { class: 68, label: "cell phone" },
  { class: 69, label: "microwave" },
  { class: 70, label: "oven" },
  { class: 71, label: "toaster" },
  { class: 72, label: "sink" },
  { class: 73, label: "refrigerator" },
  { class: 74, label: "book" },
  { class: 75, label: "clock" },
  { class: 76, label: "vase" },
  { class: 77, label: "scissors" },
  { class: 78, label: "teddy bear" },
  { class: 79, label: "hair drier" },
  { class: 80, label: "toothbrush" }
];
var model10;
var last3 = [];
var skipped8 = Number.MAX_SAFE_INTEGER;
var scaleBox = 2.5;
async function load10(config3) {
  if (!model10 || env2.initial) {
    model10 = await loadGraphModel(join(config3.modelBasePath, config3.object.modelPath || ""));
    const inputs = Object.values(model10.modelSignature["inputs"]);
    model10.inputSize = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : null;
    if (!model10.inputSize)
      throw new Error(`cannot determine model inputSize: ${config3.object.modelPath}`);
    if (!model10 || !model10.modelUrl)
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", model10.modelUrl);
  } else if (config3.debug)
    log("cached model:", model10.modelUrl);
  return model10;
}
async function process3(res2, inputSize8, outputShape, config3) {
  let id = 0;
  let results = [];
  for (const strideSize of [1, 2, 4]) {
    tidy(async () => {
      var _a, _b;
      const baseSize = strideSize * 13;
      const scoresT = (_a = res2.find((a6) => a6.shape[1] === baseSize ** 2 && a6.shape[2] === labels.length)) == null ? void 0 : _a.squeeze();
      const featuresT = (_b = res2.find((a6) => a6.shape[1] === baseSize ** 2 && a6.shape[2] < labels.length)) == null ? void 0 : _b.squeeze();
      const boxesMax = featuresT.reshape([-1, 4, featuresT.shape[1] / 4]);
      const boxIdx = await boxesMax.argMax(2).array();
      const scores = await scoresT.array();
      for (let i2 = 0; i2 < scoresT.shape[0]; i2++) {
        for (let j2 = 0; j2 < scoresT.shape[1]; j2++) {
          const score = scores[i2][j2];
          if (score > config3.object.minConfidence && j2 !== 61) {
            const cx = (0.5 + Math.trunc(i2 % baseSize)) / baseSize;
            const cy = (0.5 + Math.trunc(i2 / baseSize)) / baseSize;
            const boxOffset = boxIdx[i2].map((a6) => a6 * (baseSize / strideSize / inputSize8));
            const [x2, y2] = [
              cx - scaleBox / strideSize * boxOffset[0],
              cy - scaleBox / strideSize * boxOffset[1]
            ];
            const [w2, h2] = [
              cx + scaleBox / strideSize * boxOffset[2] - x2,
              cy + scaleBox / strideSize * boxOffset[3] - y2
            ];
            let boxRaw = [x2, y2, w2, h2];
            boxRaw = boxRaw.map((a6) => Math.max(0, Math.min(a6, 1)));
            const box5 = [
              boxRaw[0] * outputShape[0],
              boxRaw[1] * outputShape[1],
              boxRaw[2] * outputShape[0],
              boxRaw[3] * outputShape[1]
            ];
            const result = {
              id: id++,
              score: Math.round(100 * score) / 100,
              class: j2 + 1,
              label: labels[j2].label,
              box: box5.map((a6) => Math.trunc(a6)),
              boxRaw
            };
            results.push(result);
          }
        }
      }
    });
  }
  res2.forEach((t2) => dispose(t2));
  const nmsBoxes = results.map((a6) => [a6.boxRaw[1], a6.boxRaw[0], a6.boxRaw[3], a6.boxRaw[2]]);
  const nmsScores = results.map((a6) => a6.score);
  let nmsIdx = [];
  if (nmsBoxes && nmsBoxes.length > 0) {
    const nms = await image.nonMaxSuppressionAsync(nmsBoxes, nmsScores, config3.object.maxDetected, config3.object.iouThreshold, config3.object.minConfidence);
    nmsIdx = await nms.data();
    dispose(nms);
  }
  results = results.filter((_val, idx) => nmsIdx.includes(idx)).sort((a6, b2) => b2.score - a6.score);
  return results;
}
async function predict10(image7, config3) {
  if (skipped8 < (config3.object.skipFrames || 0) && config3.skipFrame && last3.length > 0) {
    skipped8++;
    return last3;
  }
  skipped8 = 0;
  if (!env2.kernels.includes("mod") || !env2.kernels.includes("sparsetodense"))
    return last3;
  return new Promise(async (resolve) => {
    const outputSize2 = [image7.shape[2], image7.shape[1]];
    const resize = image.resizeBilinear(image7, [model10.inputSize, model10.inputSize], false);
    const norm2 = div(resize, 255);
    const transpose6 = norm2.transpose([0, 3, 1, 2]);
    dispose(norm2);
    dispose(resize);
    let objectT;
    if (config3.object.enabled)
      objectT = await model10.predict(transpose6);
    dispose(transpose6);
    const obj = await process3(objectT, model10.inputSize, outputSize2, config3);
    last3 = obj;
    resolve(obj);
  });
}
var model11;
var inputSize7 = 0;
var last4 = [];
var skipped9 = Number.MAX_SAFE_INTEGER;
async function load11(config3) {
  if (env2.initial)
    model11 = null;
  if (!model11) {
    fakeOps(["floormod"], config3);
    model11 = await loadGraphModel(join(config3.modelBasePath, config3.object.modelPath || ""));
    const inputs = Object.values(model11.modelSignature["inputs"]);
    inputSize7 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    if (!model11 || !model11["modelUrl"])
      log("load model failed:", config3.object.modelPath);
    else if (config3.debug)
      log("load model:", model11["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model11["modelUrl"]);
  return model11;
}
async function process4(res2, outputShape, config3) {
  if (!res2)
    return [];
  const results = [];
  const detections = await res2.array();
  const squeezeT = squeeze(res2);
  dispose(res2);
  const arr = split(squeezeT, 6, 1);
  dispose(squeezeT);
  const stackT = stack([arr[1], arr[0], arr[3], arr[2]], 1);
  const boxesT = squeeze(stackT);
  dispose(stackT);
  const scoresT = squeeze(arr[4]);
  const classesT = squeeze(arr[5]);
  arr.forEach((t2) => dispose(t2));
  const nmsT = await image.nonMaxSuppressionAsync(boxesT, scoresT, config3.object.maxDetected, config3.object.iouThreshold, config3.object.minConfidence);
  dispose(boxesT);
  dispose(scoresT);
  dispose(classesT);
  const nms = await nmsT.data();
  dispose(nmsT);
  let i2 = 0;
  for (const id of nms) {
    const score = Math.trunc(100 * detections[0][id][4]) / 100;
    const classVal = detections[0][id][5];
    const label = labels[classVal].label;
    const [x2, y2] = [
      detections[0][id][0] / inputSize7,
      detections[0][id][1] / inputSize7
    ];
    const boxRaw = [
      x2,
      y2,
      detections[0][id][2] / inputSize7 - x2,
      detections[0][id][3] / inputSize7 - y2
    ];
    const box5 = [
      Math.trunc(boxRaw[0] * outputShape[0]),
      Math.trunc(boxRaw[1] * outputShape[1]),
      Math.trunc(boxRaw[2] * outputShape[0]),
      Math.trunc(boxRaw[3] * outputShape[1])
    ];
    results.push({ id: i2++, score, class: classVal, label, box: box5, boxRaw });
  }
  return results;
}
async function predict11(input2, config3) {
  if (skipped9 < (config3.object.skipFrames || 0) && config3.skipFrame && last4.length > 0) {
    skipped9++;
    return last4;
  }
  skipped9 = 0;
  if (!env2.kernels.includes("mod") || !env2.kernels.includes("sparsetodense"))
    return last4;
  return new Promise(async (resolve) => {
    const outputSize2 = [input2.shape[2], input2.shape[1]];
    const resize = image.resizeBilinear(input2, [inputSize7, inputSize7]);
    const objectT = config3.object.enabled ? model11 == null ? void 0 : model11.execute(resize, ["tower_0/detections"]) : null;
    dispose(resize);
    const obj = await process4(objectT, outputSize2, config3);
    last4 = obj;
    resolve(obj);
  });
}
var model12;
var busy = false;
async function load12(config3) {
  if (!model12 || env2.initial) {
    model12 = await loadGraphModel(join(config3.modelBasePath, config3.segmentation.modelPath || ""));
    if (!model12 || !model12["modelUrl"])
      log("load model failed:", config3.segmentation.modelPath);
    else if (config3.debug)
      log("load model:", model12["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model12["modelUrl"]);
  return model12;
}
async function process5(input2, background, config3) {
  var _a, _b;
  if (busy)
    return { data: [], canvas: null, alpha: null };
  busy = true;
  if (!model12)
    await load12(config3);
  const inputImage = process2(input2, config3);
  const width = ((_a = inputImage.canvas) == null ? void 0 : _a.width) || 0;
  const height = ((_b = inputImage.canvas) == null ? void 0 : _b.height) || 0;
  if (!inputImage.tensor)
    return { data: [], canvas: null, alpha: null };
  const t2 = {};
  t2.resize = image.resizeBilinear(inputImage.tensor, [model12.inputs[0].shape ? model12.inputs[0].shape[1] : 0, model12.inputs[0].shape ? model12.inputs[0].shape[2] : 0], false);
  dispose(inputImage.tensor);
  t2.norm = div(t2.resize, 255);
  t2.res = model12.predict(t2.norm);
  t2.squeeze = squeeze(t2.res, 0);
  if (t2.squeeze.shape[2] === 2) {
    t2.softmax = softmax(t2.squeeze);
    [t2.bg, t2.fg] = unstack(t2.softmax, 2);
    t2.expand = expandDims(t2.fg, 2);
    t2.pad = expandDims(t2.expand, 0);
    t2.crop = image.cropAndResize(t2.pad, [[0, 0, 0.5, 0.5]], [0], [width, height]);
    t2.data = squeeze(t2.crop, 0);
  } else {
    t2.data = image.resizeBilinear(t2.squeeze, [height, width]);
  }
  const data = Array.from(await t2.data.data());
  if (env2.node && !env2.Canvas && typeof ImageData === "undefined") {
    if (config3.debug)
      log("canvas support missing");
    Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
    return { data, canvas: null, alpha: null };
  }
  const alphaCanvas = canvas(width, height);
  await browser_exports.toPixels(t2.data, alphaCanvas);
  const alphaCtx = alphaCanvas.getContext("2d");
  if (config3.segmentation.blur && config3.segmentation.blur > 0)
    alphaCtx.filter = `blur(${config3.segmentation.blur}px)`;
  const alphaData = alphaCtx.getImageData(0, 0, width, height);
  const compositeCanvas = canvas(width, height);
  const compositeCtx = compositeCanvas.getContext("2d");
  if (inputImage.canvas)
    compositeCtx.drawImage(inputImage.canvas, 0, 0);
  compositeCtx.globalCompositeOperation = "darken";
  if (config3.segmentation.blur && config3.segmentation.blur > 0)
    compositeCtx.filter = `blur(${config3.segmentation.blur}px)`;
  compositeCtx.drawImage(alphaCanvas, 0, 0);
  compositeCtx.globalCompositeOperation = "source-over";
  compositeCtx.filter = "none";
  const compositeData = compositeCtx.getImageData(0, 0, width, height);
  for (let i2 = 0; i2 < width * height; i2++)
    compositeData.data[4 * i2 + 3] = alphaData.data[4 * i2 + 0];
  compositeCtx.putImageData(compositeData, 0, 0);
  let mergedCanvas = null;
  if (background && compositeCanvas) {
    mergedCanvas = canvas(width, height);
    const bgImage = process2(background, config3);
    dispose(bgImage.tensor);
    const ctxMerge = mergedCanvas.getContext("2d");
    ctxMerge.drawImage(bgImage.canvas, 0, 0, mergedCanvas.width, mergedCanvas.height);
    ctxMerge.drawImage(compositeCanvas, 0, 0);
  }
  Object.keys(t2).forEach((tensor2) => dispose(t2[tensor2]));
  busy = false;
  return { data, canvas: mergedCanvas || compositeCanvas, alpha: alphaCanvas };
}
var model13;
var skipped10 = Number.MAX_SAFE_INTEGER;
async function load13(config3) {
  if (env2.initial)
    model13 = null;
  if (!model13) {
    model13 = await loadGraphModel(join(config3.modelBasePath, config3.face.agegenderrace.modelPath));
    if (!model13 || !model13["modelUrl"])
      log("load model failed:", config3.face.agegenderrace.modelPath);
    else if (config3.debug)
      log("load model:", model13["modelUrl"]);
  } else if (config3.debug)
    log("cached model:", model13["modelUrl"]);
  return model13;
}
var Models = class {
  constructor() {
    __publicField(this, "age", null);
    __publicField(this, "agegenderrace", null);
    __publicField(this, "blazeposedetect", null);
    __publicField(this, "blazepose", null);
    __publicField(this, "centernet", null);
    __publicField(this, "efficientpose", null);
    __publicField(this, "embedding", null);
    __publicField(this, "emotion", null);
    __publicField(this, "facedetect", null);
    __publicField(this, "faceiris", null);
    __publicField(this, "facemesh", null);
    __publicField(this, "faceres", null);
    __publicField(this, "gender", null);
    __publicField(this, "handpose", null);
    __publicField(this, "handskeleton", null);
    __publicField(this, "handtrack", null);
    __publicField(this, "movenet", null);
    __publicField(this, "nanodet", null);
    __publicField(this, "posenet", null);
    __publicField(this, "segmentation", null);
  }
};
function reset(instance) {
  for (const model142 of Object.keys(instance.models))
    instance.models[model142] = null;
}
async function load14(instance) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2, _r, _s, _t, _u, _v, _w, _x2, _y2, _z2, _A, _B, _C, _D;
  if (env2.initial)
    reset(instance);
  if (instance.config.hand.enabled) {
    if (!instance.models.handpose && ((_b = (_a = instance.config.hand.detector) == null ? void 0 : _a.modelPath) == null ? void 0 : _b.includes("handdetect")))
      [instance.models.handpose, instance.models.handskeleton] = await load7(instance.config);
    if (!instance.models.handskeleton && instance.config.hand.landmarks && ((_d = (_c = instance.config.hand.detector) == null ? void 0 : _c.modelPath) == null ? void 0 : _d.includes("handdetect")))
      [instance.models.handpose, instance.models.handskeleton] = await load7(instance.config);
  }
  if (instance.config.face.enabled && !instance.models.facedetect)
    instance.models.facedetect = load(instance.config);
  if (instance.config.face.enabled && ((_e2 = instance.config.face.mesh) == null ? void 0 : _e2.enabled) && !instance.models.facemesh)
    instance.models.facemesh = load3(instance.config);
  if (instance.config.face.enabled && ((_f = instance.config.face.iris) == null ? void 0 : _f.enabled) && !instance.models.faceiris)
    instance.models.faceiris = load2(instance.config);
  if (instance.config.hand.enabled && !instance.models.handtrack && ((_h = (_g = instance.config.hand.detector) == null ? void 0 : _g.modelPath) == null ? void 0 : _h.includes("handtrack")))
    instance.models.handtrack = loadDetect(instance.config);
  if (instance.config.hand.enabled && instance.config.hand.landmarks && !instance.models.handskeleton && ((_j = (_i = instance.config.hand.detector) == null ? void 0 : _i.modelPath) == null ? void 0 : _j.includes("handtrack")))
    instance.models.handskeleton = loadSkeleton(instance.config);
  if (instance.config.body.enabled && !instance.models.posenet && ((_l = (_k = instance.config.body) == null ? void 0 : _k.modelPath) == null ? void 0 : _l.includes("posenet")))
    instance.models.posenet = load6(instance.config);
  if (instance.config.body.enabled && !instance.models.efficientpose && ((_n = (_m = instance.config.body) == null ? void 0 : _m.modelPath) == null ? void 0 : _n.includes("efficientpose")))
    instance.models.efficientpose = load8(instance.config);
  if (instance.config.body.enabled && !instance.models.blazepose && ((_p = (_o = instance.config.body) == null ? void 0 : _o.modelPath) == null ? void 0 : _p.includes("blazepose")))
    instance.models.blazepose = loadPose(instance.config);
  if (instance.config.body.enabled && !instance.models.blazeposedetect && ((_q2 = instance.config.body.detector) == null ? void 0 : _q2.modelPath) && ((_s = (_r = instance.config.body) == null ? void 0 : _r.modelPath) == null ? void 0 : _s.includes("blazepose")))
    instance.models.blazeposedetect = loadDetect2(instance.config);
  if (instance.config.body.enabled && !instance.models.efficientpose && ((_u = (_t = instance.config.body) == null ? void 0 : _t.modelPath) == null ? void 0 : _u.includes("efficientpose")))
    instance.models.efficientpose = load8(instance.config);
  if (instance.config.body.enabled && !instance.models.movenet && ((_w = (_v = instance.config.body) == null ? void 0 : _v.modelPath) == null ? void 0 : _w.includes("movenet")))
    instance.models.movenet = load9(instance.config);
  if (instance.config.object.enabled && !instance.models.nanodet && ((_y2 = (_x2 = instance.config.object) == null ? void 0 : _x2.modelPath) == null ? void 0 : _y2.includes("nanodet")))
    instance.models.nanodet = load10(instance.config);
  if (instance.config.object.enabled && !instance.models.centernet && ((_A = (_z2 = instance.config.object) == null ? void 0 : _z2.modelPath) == null ? void 0 : _A.includes("centernet")))
    instance.models.centernet = load11(instance.config);
  if (instance.config.face.enabled && ((_B = instance.config.face.emotion) == null ? void 0 : _B.enabled) && !instance.models.emotion)
    instance.models.emotion = load5(instance.config);
  if (instance.config.face.enabled && ((_C = instance.config.face.description) == null ? void 0 : _C.enabled) && !instance.models.faceres)
    instance.models.faceres = load4(instance.config);
  if (instance.config.segmentation.enabled && !instance.models.segmentation)
    instance.models.segmentation = load12(instance.config);
  if (instance.config.face.enabled && ((_D = instance.config.face["agegenderrace"]) == null ? void 0 : _D.enabled) && !instance.models.agegenderrace)
    instance.models.agegenderrace = load13(instance.config);
  for await (const model142 of Object.keys(instance.models)) {
    if (instance.models[model142] && typeof instance.models[model142] !== "undefined")
      instance.models[model142] = await instance.models[model142];
  }
}
async function validate2(instance) {
  const simpleOps = ["const", "placeholder", "noop", "pad", "squeeze", "add", "sub", "mul", "div"];
  for (const defined of Object.keys(instance.models)) {
    if (instance.models[defined]) {
      let models5 = [];
      if (Array.isArray(instance.models[defined])) {
        models5 = instance.models[defined].filter((model142) => model142 !== null).map((model142) => model142 && model142.executor ? model142 : model142.model);
      } else {
        models5 = [instance.models[defined]];
      }
      for (const model142 of models5) {
        if (!model142) {
          if (instance.config.debug)
            log("model marked as loaded but not defined:", defined);
          continue;
        }
        const ops = [];
        const executor = model142 == null ? void 0 : model142.executor;
        if (executor && executor.graph.nodes) {
          for (const kernel of Object.values(executor.graph.nodes)) {
            const op2 = kernel.op.toLowerCase();
            if (!ops.includes(op2))
              ops.push(op2);
          }
        } else {
          if (!executor && instance.config.debug)
            log("model signature not determined:", defined);
        }
        const missing = [];
        for (const op2 of ops) {
          if (!simpleOps.includes(op2) && !instance.env.kernels.includes(op2) && !instance.env.kernels.includes(op2.replace("_", "")) && !instance.env.kernels.includes(op2.replace("native", "")) && !instance.env.kernels.includes(op2.replace("v2", ""))) {
            missing.push(op2);
          }
        }
        if (missing.length > 0 && instance.config.debug)
          log("model validation:", defined, missing);
      }
    }
  }
}
var config2 = {
  name: "humangl",
  priority: 999,
  canvas: null,
  gl: null,
  extensions: [],
  webGLattr: {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: false,
    desynchronized: true
  }
};
function extensions() {
  const gl = config2.gl;
  if (!gl)
    return;
  config2.extensions = gl.getSupportedExtensions();
}
async function register(instance) {
  var _a;
  if (instance.config.backend !== "humangl")
    return;
  if (config2.name in engine().registry && (!config2.gl || !config2.gl.getParameter(config2.gl.VERSION))) {
    log("error: humangl backend invalid context");
    reset(instance);
  }
  if (!findBackend(config2.name)) {
    try {
      config2.canvas = await canvas(100, 100);
    } catch (err) {
      log("error: cannot create canvas:", err);
      return;
    }
    try {
      config2.gl = (_a = config2.canvas) == null ? void 0 : _a.getContext("webgl2", config2.webGLattr);
      if (config2.canvas) {
        config2.canvas.addEventListener("webglcontextlost", async (e2) => {
          log("error: humangl:", e2.type);
          log("possible browser memory leak using webgl or conflict with multiple backend registrations");
          instance.emit("error");
          throw new Error("browser webgl error");
        });
        config2.canvas.addEventListener("webglcontextrestored", (e2) => {
          log("error: humangl context restored:", e2);
        });
        config2.canvas.addEventListener("webglcontextcreationerror", (e2) => {
          log("error: humangl context create:", e2);
        });
      }
    } catch (err) {
      log("error: cannot get WebGL context:", err);
      return;
    }
    try {
      setWebGLContext(2, config2.gl);
    } catch (err) {
      log("error: cannot set WebGL context:", err);
      return;
    }
    try {
      const ctx = new GPGPUContext(config2.gl);
      registerBackend(config2.name, () => new MathBackendWebGL(ctx), config2.priority);
    } catch (err) {
      log("error: cannot register WebGL backend:", err);
      return;
    }
    try {
      const kernels = getKernelsForBackend("webgl");
      kernels.forEach((kernelConfig) => {
        const newKernelConfig = { ...kernelConfig, backendName: config2.name };
        registerKernel(newKernelConfig);
      });
    } catch (err) {
      log("error: cannot update WebGL backend registration:", err);
      return;
    }
    const current = backend().getGPGPUContext ? backend().getGPGPUContext().gl : null;
    if (current) {
      log(`humangl webgl version:${current.getParameter(current.VERSION)} renderer:${current.getParameter(current.RENDERER)}`);
    } else {
      log("error: no current gl context:", current, config2.gl);
      return;
    }
    try {
      ENV.set("WEBGL_VERSION", 2);
    } catch (err) {
      log("error: cannot set WebGL backend flags:", err);
      return;
    }
    extensions();
    log("backend registered:", config2.name);
  }
}
async function check(instance, force = false) {
  instance.state = "backend";
  if (force || env2.initial || instance.config.backend && instance.config.backend.length > 0 && getBackend() !== instance.config.backend) {
    const timeStamp = now2();
    if (instance.config.backend && instance.config.backend.length > 0) {
      if (typeof window === "undefined" && typeof WorkerGlobalScope !== "undefined" && instance.config.debug) {
        if (instance.config.debug)
          log("running inside web worker");
      }
      if (env2.browser && instance.config.backend === "tensorflow") {
        if (instance.config.debug)
          log("override: backend set to tensorflow while running in browser");
        instance.config.backend = "humangl";
      }
      if (env2.node && (instance.config.backend === "webgl" || instance.config.backend === "humangl")) {
        if (instance.config.debug)
          log(`override: backend set to ${instance.config.backend} while running in nodejs`);
        instance.config.backend = "tensorflow";
      }
      if (env2.browser && instance.config.backend === "webgpu") {
        if (typeof navigator === "undefined" || typeof navigator["gpu"] === "undefined") {
          log("override: backend set to webgpu but browser does not support webgpu");
          instance.config.backend = "humangl";
        } else {
          const adapter = await navigator["gpu"].requestAdapter();
          if (instance.config.debug)
            log("enumerated webgpu adapter:", adapter);
        }
      }
      if (instance.config.backend === "humangl")
        await register(instance);
      const available = Object.keys(engine().registryFactory);
      if (instance.config.debug)
        log("available backends:", available);
      if (!available.includes(instance.config.backend)) {
        log(`error: backend ${instance.config.backend} not found in registry`);
        instance.config.backend = env2.node ? "tensorflow" : "webgl";
        if (instance.config.debug)
          log(`override: setting backend ${instance.config.backend}`);
      }
      if (instance.config.debug)
        log("setting backend:", instance.config.backend);
      if (instance.config.backend === "wasm") {
        if (instance.config.debug)
          log("wasm path:", instance.config.wasmPath);
        if (typeof (tfjs_esm_exports == null ? void 0 : tfjs_esm_exports.setWasmPaths) !== "undefined")
          await setWasmPaths(instance.config.wasmPath);
        else
          throw new Error("wasm backend is not loaded");
        const simd = await env().getAsync("WASM_HAS_SIMD_SUPPORT");
        const mt = await env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
        if (instance.config.debug)
          log(`wasm execution: ${simd ? "SIMD" : "no SIMD"} ${mt ? "multithreaded" : "singlethreaded"}`);
        if (instance.config.debug && !simd)
          log("warning: wasm simd support is not enabled");
      }
      try {
        await setBackend(instance.config.backend);
        await ready();
      } catch (err) {
        log("error: cannot set backend:", instance.config.backend, err);
        return false;
      }
    }
    if (getBackend() === "humangl") {
      ENV.set("CHECK_COMPUTATION_FOR_ERRORS", false);
      ENV.set("WEBGL_CPU_FORWARD", true);
      ENV.set("WEBGL_PACK_DEPTHWISECONV", false);
      ENV.set("WEBGL_USE_SHAPES_UNIFORMS", true);
      ENV.set("CPU_HANDOFF_SIZE_THRESHOLD", 256);
      if (typeof instance.config["deallocate"] !== "undefined" && instance.config["deallocate"]) {
        log("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:", true);
        ENV.set("WEBGL_DELETE_TEXTURE_THRESHOLD", 0);
      }
      if (backend().getGPGPUContext) {
        const gl = await backend().getGPGPUContext().gl;
        if (instance.config.debug)
          log(`gl version:${gl.getParameter(gl.VERSION)} renderer:${gl.getParameter(gl.RENDERER)}`);
      }
    }
    if (getBackend() === "webgpu") {
      ENV.set("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", 512);
      ENV.set("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", 0);
      ENV.set("WEBGPU_CPU_FORWARD", true);
    }
    enableProdMode();
    await ready();
    instance.performance.backend = Math.trunc(now2() - timeStamp);
    instance.config.backend = getBackend();
    get3();
    instance.env = env2;
  }
  return true;
}
function fakeOps(kernelNames, config3) {
  for (const kernelName of kernelNames) {
    const kernelConfig = {
      kernelName,
      backendName: config3.backend,
      kernelFunc: () => {
        if (config3.debug)
          log("kernelFunc", kernelName, config3.backend);
      }
    };
    registerKernel(kernelConfig);
  }
  env2.kernels = getKernelsForBackend(getBackend()).map((kernel) => kernel.kernelName.toLowerCase());
}
var options2 = {
  color: "rgba(173, 216, 230, 0.6)",
  labelColor: "rgba(173, 216, 230, 1)",
  shadowColor: "black",
  font: 'small-caps 14px "Segoe UI"',
  lineHeight: 18,
  lineWidth: 4,
  pointSize: 2,
  roundRect: 8,
  drawPoints: false,
  drawLabels: true,
  drawBoxes: true,
  drawPolygons: true,
  drawGaze: true,
  fillPolygons: false,
  useDepth: true,
  useCurves: false,
  bufferedOutput: true
};
var getCanvasContext = (input2) => {
  if (input2 && input2.getContext)
    return input2.getContext("2d");
  throw new Error("invalid canvas");
};
var rad2deg = (theta) => Math.round(theta * 180 / Math.PI);
function point(ctx, x2, y2, z2 = 0, localOptions) {
  ctx.fillStyle = localOptions.useDepth && z2 ? `rgba(${127.5 + 2 * z2}, ${127.5 - 2 * z2}, 255, 0.3)` : localOptions.color;
  ctx.beginPath();
  ctx.arc(x2, y2, localOptions.pointSize, 0, 2 * Math.PI);
  ctx.fill();
}
function rect(ctx, x2, y2, width, height, localOptions) {
  ctx.beginPath();
  if (localOptions.useCurves) {
    const cx = (x2 + x2 + width) / 2;
    const cy = (y2 + y2 + height) / 2;
    ctx.ellipse(cx, cy, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    ctx.lineWidth = localOptions.lineWidth;
    ctx.moveTo(x2 + localOptions.roundRect, y2);
    ctx.lineTo(x2 + width - localOptions.roundRect, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + localOptions.roundRect);
    ctx.lineTo(x2 + width, y2 + height - localOptions.roundRect);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - localOptions.roundRect, y2 + height);
    ctx.lineTo(x2 + localOptions.roundRect, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - localOptions.roundRect);
    ctx.lineTo(x2, y2 + localOptions.roundRect);
    ctx.quadraticCurveTo(x2, y2, x2 + localOptions.roundRect, y2);
    ctx.closePath();
  }
  ctx.stroke();
}
function lines(ctx, points = [], localOptions) {
  if (points === void 0 || points.length === 0)
    return;
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1]);
  for (const pt of points) {
    const z2 = pt[2] || 0;
    ctx.strokeStyle = localOptions.useDepth && z2 ? `rgba(${127.5 + 2 * z2}, ${127.5 - 2 * z2}, 255, 0.3)` : localOptions.color;
    ctx.fillStyle = localOptions.useDepth && z2 ? `rgba(${127.5 + 2 * z2}, ${127.5 - 2 * z2}, 255, 0.3)` : localOptions.color;
    ctx.lineTo(pt[0], Math.round(pt[1]));
  }
  ctx.stroke();
  if (localOptions.fillPolygons) {
    ctx.closePath();
    ctx.fill();
  }
}
function curves(ctx, points = [], localOptions) {
  if (points === void 0 || points.length === 0)
    return;
  if (!localOptions.useCurves || points.length <= 2) {
    lines(ctx, points, localOptions);
    return;
  }
  ctx.moveTo(points[0][0], points[0][1]);
  for (let i2 = 0; i2 < points.length - 2; i2++) {
    const xc = (points[i2][0] + points[i2 + 1][0]) / 2;
    const yc = (points[i2][1] + points[i2 + 1][1]) / 2;
    ctx.quadraticCurveTo(points[i2][0], points[i2][1], xc, yc);
  }
  ctx.quadraticCurveTo(points[points.length - 2][0], points[points.length - 2][1], points[points.length - 1][0], points[points.length - 1][1]);
  ctx.stroke();
  if (localOptions.fillPolygons) {
    ctx.closePath();
    ctx.fill();
  }
}
function arrow(ctx, from, to, radius = 5) {
  let angle2;
  let x2;
  let y2;
  ctx.beginPath();
  ctx.moveTo(from[0], from[1]);
  ctx.lineTo(to[0], to[1]);
  angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  x2 = radius * Math.cos(angle2) + to[0];
  y2 = radius * Math.sin(angle2) + to[1];
  ctx.moveTo(x2, y2);
  angle2 += 1 / 3 * (2 * Math.PI);
  x2 = radius * Math.cos(angle2) + to[0];
  y2 = radius * Math.sin(angle2) + to[1];
  ctx.lineTo(x2, y2);
  angle2 += 1 / 3 * (2 * Math.PI);
  x2 = radius * Math.cos(angle2) + to[0];
  y2 = radius * Math.sin(angle2) + to[1];
  ctx.lineTo(x2, y2);
  ctx.closePath();
  ctx.stroke();
  ctx.fill();
}
async function gesture(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  ctx.font = localOptions.font;
  ctx.fillStyle = localOptions.color;
  let i2 = 1;
  for (let j2 = 0; j2 < result.length; j2++) {
    let where2 = [];
    let what = [];
    [where2, what] = Object.entries(result[j2]);
    if (what.length > 1 && what[1].length > 0) {
      const who = where2[1] > 0 ? `#${where2[1]}` : "";
      const label = `${where2[0]} ${who}: ${what[1]}`;
      if (localOptions.shadowColor && localOptions.shadowColor !== "") {
        ctx.fillStyle = localOptions.shadowColor;
        ctx.fillText(label, 8, 2 + i2 * localOptions.lineHeight);
      }
      ctx.fillStyle = localOptions.labelColor;
      ctx.fillText(label, 6, 0 + i2 * localOptions.lineHeight);
      i2 += 1;
    }
  }
}
async function face(inCanvas2, result, drawOptions) {
  var _a, _b, _c, _d, _e2;
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  for (const f2 of result) {
    ctx.font = localOptions.font;
    ctx.strokeStyle = localOptions.color;
    ctx.fillStyle = localOptions.color;
    if (localOptions.drawBoxes)
      rect(ctx, f2.box[0], f2.box[1], f2.box[2], f2.box[3], localOptions);
    const labels2 = [];
    labels2.push(`face: ${Math.trunc(100 * f2.score)}%`);
    if (f2.genderScore)
      labels2.push(`${f2.gender || ""} ${Math.trunc(100 * f2.genderScore)}%`);
    if (f2.age)
      labels2.push(`age: ${f2.age || ""}`);
    if (f2.iris)
      labels2.push(`distance: ${f2.iris}`);
    if (f2.emotion && f2.emotion.length > 0) {
      const emotion3 = f2.emotion.map((a6) => `${Math.trunc(100 * a6.score)}% ${a6.emotion}`);
      if (emotion3.length > 3)
        emotion3.length = 3;
      labels2.push(emotion3.join(" "));
    }
    if (f2.rotation && f2.rotation.angle && f2.rotation.gaze) {
      if (f2.rotation.angle.roll)
        labels2.push(`roll: ${rad2deg(f2.rotation.angle.roll)}\xB0 yaw:${rad2deg(f2.rotation.angle.yaw)}\xB0 pitch:${rad2deg(f2.rotation.angle.pitch)}\xB0`);
      if (f2.rotation.gaze.bearing)
        labels2.push(`gaze: ${rad2deg(f2.rotation.gaze.bearing)}\xB0`);
    }
    if (labels2.length === 0)
      labels2.push("face");
    ctx.fillStyle = localOptions.color;
    for (let i2 = labels2.length - 1; i2 >= 0; i2--) {
      const x2 = Math.max(f2.box[0], 0);
      const y2 = i2 * localOptions.lineHeight + f2.box[1];
      if (localOptions.shadowColor && localOptions.shadowColor !== "") {
        ctx.fillStyle = localOptions.shadowColor;
        ctx.fillText(labels2[i2], x2 + 5, y2 + 16);
      }
      ctx.fillStyle = localOptions.labelColor;
      ctx.fillText(labels2[i2], x2 + 4, y2 + 15);
    }
    ctx.lineWidth = 1;
    if (f2.mesh && f2.mesh.length > 0) {
      if (localOptions.drawPoints) {
        for (const pt of f2.mesh)
          point(ctx, pt[0], pt[1], pt[2], localOptions);
      }
      if (localOptions.drawPolygons) {
        ctx.lineWidth = 1;
        if (f2.mesh.length > 450) {
          for (let i2 = 0; i2 < TRI468.length / 3; i2++) {
            const points = [
              TRI468[i2 * 3 + 0],
              TRI468[i2 * 3 + 1],
              TRI468[i2 * 3 + 2]
            ].map((index) => f2.mesh[index]);
            lines(ctx, points, localOptions);
          }
        }
        if (f2.annotations && f2.annotations["leftEyeIris"] && f2.annotations["leftEyeIris"][0]) {
          ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
          ctx.beginPath();
          const sizeX = Math.abs(f2.annotations["leftEyeIris"][3][0] - f2.annotations["leftEyeIris"][1][0]) / 2;
          const sizeY = Math.abs(f2.annotations["leftEyeIris"][4][1] - f2.annotations["leftEyeIris"][2][1]) / 2;
          ctx.ellipse(f2.annotations["leftEyeIris"][0][0], f2.annotations["leftEyeIris"][0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (localOptions.fillPolygons) {
            ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
            ctx.fill();
          }
        }
        if (f2.annotations && f2.annotations["rightEyeIris"] && f2.annotations["rightEyeIris"][0]) {
          ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
          ctx.beginPath();
          const sizeX = Math.abs(f2.annotations["rightEyeIris"][3][0] - f2.annotations["rightEyeIris"][1][0]) / 2;
          const sizeY = Math.abs(f2.annotations["rightEyeIris"][4][1] - f2.annotations["rightEyeIris"][2][1]) / 2;
          ctx.ellipse(f2.annotations["rightEyeIris"][0][0], f2.annotations["rightEyeIris"][0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (localOptions.fillPolygons) {
            ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
            ctx.fill();
          }
        }
        if (localOptions.drawGaze && ((_a = f2.rotation) == null ? void 0 : _a.angle)) {
          ctx.strokeStyle = "pink";
          const valX = f2.box[0] + f2.box[2] / 2 - f2.box[3] * rad2deg(f2.rotation.angle.yaw) / 90;
          const valY = f2.box[1] + f2.box[3] / 2 + f2.box[2] * rad2deg(f2.rotation.angle.pitch) / 90;
          const pathV = new Path2D(`
            M ${f2.box[0] + f2.box[2] / 2} ${f2.box[1]}
            C
              ${valX} ${f2.box[1]},
              ${valX} ${f2.box[1] + f2.box[3]},
              ${f2.box[0] + f2.box[2] / 2} ${f2.box[1] + f2.box[3]}
          `);
          const pathH = new Path2D(`
            M ${f2.box[0]} ${f2.box[1] + f2.box[3] / 2}
            C 
              ${f2.box[0]} ${valY},
              ${f2.box[0] + f2.box[2]} ${valY},
              ${f2.box[0] + f2.box[2]} ${f2.box[1] + f2.box[3] / 2}
          `);
          ctx.stroke(pathH);
          ctx.stroke(pathV);
        }
        if (localOptions.drawGaze && ((_c = (_b = f2.rotation) == null ? void 0 : _b.gaze) == null ? void 0 : _c.strength) && ((_e2 = (_d = f2.rotation) == null ? void 0 : _d.gaze) == null ? void 0 : _e2.bearing) && f2.annotations["leftEyeIris"] && f2.annotations["rightEyeIris"] && f2.annotations["leftEyeIris"][0] && f2.annotations["rightEyeIris"][0]) {
          ctx.strokeStyle = "pink";
          ctx.fillStyle = "pink";
          const leftGaze = [
            f2.annotations["leftEyeIris"][0][0] + Math.sin(f2.rotation.gaze.bearing) * f2.rotation.gaze.strength * f2.box[3],
            f2.annotations["leftEyeIris"][0][1] + Math.cos(f2.rotation.gaze.bearing) * f2.rotation.gaze.strength * f2.box[2]
          ];
          arrow(ctx, [f2.annotations["leftEyeIris"][0][0], f2.annotations["leftEyeIris"][0][1]], [leftGaze[0], leftGaze[1]], 4);
          const rightGaze = [
            f2.annotations["rightEyeIris"][0][0] + Math.sin(f2.rotation.gaze.bearing) * f2.rotation.gaze.strength * f2.box[3],
            f2.annotations["rightEyeIris"][0][1] + Math.cos(f2.rotation.gaze.bearing) * f2.rotation.gaze.strength * f2.box[2]
          ];
          arrow(ctx, [f2.annotations["rightEyeIris"][0][0], f2.annotations["rightEyeIris"][0][1]], [rightGaze[0], rightGaze[1]], 4);
        }
      }
    }
  }
}
async function body(inCanvas2, result, drawOptions) {
  var _a;
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  ctx.lineJoin = "round";
  for (let i2 = 0; i2 < result.length; i2++) {
    ctx.strokeStyle = localOptions.color;
    ctx.fillStyle = localOptions.color;
    ctx.lineWidth = localOptions.lineWidth;
    ctx.font = localOptions.font;
    if (localOptions.drawBoxes && result[i2].box && ((_a = result[i2].box) == null ? void 0 : _a.length) === 4) {
      rect(ctx, result[i2].box[0], result[i2].box[1], result[i2].box[2], result[i2].box[3], localOptions);
      if (localOptions.drawLabels) {
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(`body ${100 * result[i2].score}%`, result[i2].box[0] + 3, 1 + result[i2].box[1] + localOptions.lineHeight, result[i2].box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(`body ${100 * result[i2].score}%`, result[i2].box[0] + 2, 0 + result[i2].box[1] + localOptions.lineHeight, result[i2].box[2]);
      }
    }
    if (localOptions.drawPoints && result[i2].keypoints) {
      for (let pt = 0; pt < result[i2].keypoints.length; pt++) {
        ctx.fillStyle = localOptions.useDepth && result[i2].keypoints[pt].position[2] ? `rgba(${127.5 + 2 * (result[i2].keypoints[pt].position[2] || 0)}, ${127.5 - 2 * (result[i2].keypoints[pt].position[2] || 0)}, 255, 0.5)` : localOptions.color;
        point(ctx, result[i2].keypoints[pt].position[0], result[i2].keypoints[pt].position[1], 0, localOptions);
      }
    }
    if (localOptions.drawLabels && result[i2].keypoints) {
      ctx.font = localOptions.font;
      for (const pt of result[i2].keypoints) {
        ctx.fillStyle = localOptions.useDepth && pt.position[2] ? `rgba(${127.5 + 2 * pt.position[2]}, ${127.5 - 2 * pt.position[2]}, 255, 0.5)` : localOptions.color;
        ctx.fillText(`${pt.part} ${Math.trunc(100 * pt.score)}%`, pt.position[0] + 4, pt.position[1] + 4);
      }
    }
    if (localOptions.drawPolygons && result[i2].keypoints && result[i2].annotations) {
      for (const part of Object.values(result[i2].annotations)) {
        for (const connected4 of part)
          curves(ctx, connected4, localOptions);
      }
    }
  }
}
async function hand(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (const h2 of result) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, h2.box[0], h2.box[1], h2.box[2], h2.box[3], localOptions);
      if (localOptions.drawLabels) {
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(`hand:${Math.trunc(100 * h2.score)}%`, h2.box[0] + 3, 1 + h2.box[1] + localOptions.lineHeight, h2.box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(`hand:${Math.trunc(100 * h2.score)}%`, h2.box[0] + 2, 0 + h2.box[1] + localOptions.lineHeight, h2.box[2]);
      }
      ctx.stroke();
    }
    if (localOptions.drawPoints) {
      if (h2.keypoints && h2.keypoints.length > 0) {
        for (const pt of h2.keypoints) {
          ctx.fillStyle = localOptions.useDepth ? `rgba(${127.5 + 2 * (pt[2] || 0)}, ${127.5 - 2 * (pt[2] || 0)}, 255, 0.5)` : localOptions.color;
          point(ctx, pt[0], pt[1], 0, localOptions);
        }
      }
    }
    if (localOptions.drawLabels && h2.annotations) {
      const addHandLabel = (part, title) => {
        if (!part || part.length === 0 || !part[0])
          return;
        ctx.fillStyle = localOptions.useDepth ? `rgba(${127.5 + 2 * part[part.length - 1][2]}, ${127.5 - 2 * part[part.length - 1][2]}, 255, 0.5)` : localOptions.color;
        ctx.fillText(title, part[part.length - 1][0] + 4, part[part.length - 1][1] + 4);
      };
      ctx.font = localOptions.font;
      addHandLabel(h2.annotations["index"], "index");
      addHandLabel(h2.annotations["middle"], "middle");
      addHandLabel(h2.annotations["ring"], "ring");
      addHandLabel(h2.annotations["pinky"], "pinky");
      addHandLabel(h2.annotations["thumb"], "thumb");
      addHandLabel(h2.annotations["palm"], "palm");
    }
    if (localOptions.drawPolygons && h2.annotations) {
      const addHandLine = (part) => {
        if (!part || part.length === 0 || !part[0])
          return;
        for (let i2 = 0; i2 < part.length; i2++) {
          ctx.beginPath();
          ctx.strokeStyle = localOptions.useDepth ? `rgba(${127.5 + 2 * part[i2][2]}, ${127.5 - 2 * part[i2][2]}, 255, 0.5)` : localOptions.color;
          ctx.moveTo(part[i2 > 0 ? i2 - 1 : 0][0], part[i2 > 0 ? i2 - 1 : 0][1]);
          ctx.lineTo(part[i2][0], part[i2][1]);
          ctx.stroke();
        }
      };
      ctx.lineWidth = localOptions.lineWidth;
      addHandLine(h2.annotations["index"]);
      addHandLine(h2.annotations["middle"]);
      addHandLine(h2.annotations["ring"]);
      addHandLine(h2.annotations["pinky"]);
      addHandLine(h2.annotations["thumb"]);
    }
  }
}
async function object(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (const h2 of result) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, h2.box[0], h2.box[1], h2.box[2], h2.box[3], localOptions);
      if (localOptions.drawLabels) {
        const label = `${h2.label} ${Math.round(100 * h2.score)}%`;
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(label, h2.box[0] + 3, 1 + h2.box[1] + localOptions.lineHeight, h2.box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(label, h2.box[0] + 2, 0 + h2.box[1] + localOptions.lineHeight, h2.box[2]);
      }
      ctx.stroke();
    }
  }
}
async function person(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options2, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (let i2 = 0; i2 < result.length; i2++) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, result[i2].box[0], result[i2].box[1], result[i2].box[2], result[i2].box[3], localOptions);
      if (localOptions.drawLabels) {
        const label = `person #${i2}`;
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(label, result[i2].box[0] + 3, 1 + result[i2].box[1] + localOptions.lineHeight, result[i2].box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(label, result[i2].box[0] + 2, 0 + result[i2].box[1] + localOptions.lineHeight, result[i2].box[2]);
      }
      ctx.stroke();
    }
  }
}
async function canvas2(input2, output) {
  if (!input2 || !output)
    return;
  const ctx = getCanvasContext(output);
  ctx.drawImage(input2, 0, 0);
}
async function all5(inCanvas2, result, drawOptions) {
  if (!result || !result.performance || !result || !inCanvas2)
    return null;
  const timestamp = now2();
  const localOptions = mergeDeep(options2, drawOptions);
  const promise = Promise.all([
    face(inCanvas2, result.face, localOptions),
    body(inCanvas2, result.body, localOptions),
    hand(inCanvas2, result.hand, localOptions),
    object(inCanvas2, result.object, localOptions),
    gesture(inCanvas2, result.gesture, localOptions)
  ]);
  result.performance.draw = Math.trunc(now2() - timestamp);
  return promise;
}
var calculateGaze = (face5) => {
  const radians = (pt1, pt2) => Math.atan2(pt1[1] - pt2[1], pt1[0] - pt2[0]);
  if (!face5.annotations["rightEyeIris"] || !face5.annotations["leftEyeIris"])
    return { bearing: 0, strength: 0 };
  const offsetIris = [0, -0.1];
  const eyeRatio = 1;
  const left = face5.mesh[33][2] > face5.mesh[263][2];
  const irisCenter = left ? face5.mesh[473] : face5.mesh[468];
  const eyeCenter = left ? [(face5.mesh[133][0] + face5.mesh[33][0]) / 2, (face5.mesh[133][1] + face5.mesh[33][1]) / 2] : [(face5.mesh[263][0] + face5.mesh[362][0]) / 2, (face5.mesh[263][1] + face5.mesh[362][1]) / 2];
  const eyeSize = left ? [face5.mesh[133][0] - face5.mesh[33][0], face5.mesh[23][1] - face5.mesh[27][1]] : [face5.mesh[263][0] - face5.mesh[362][0], face5.mesh[253][1] - face5.mesh[257][1]];
  const eyeDiff = [
    (eyeCenter[0] - irisCenter[0]) / eyeSize[0] - offsetIris[0],
    eyeRatio * (irisCenter[1] - eyeCenter[1]) / eyeSize[1] - offsetIris[1]
  ];
  let strength = Math.sqrt(eyeDiff[0] ** 2 + eyeDiff[1] ** 2);
  strength = Math.min(strength, face5.boxRaw[2] / 2, face5.boxRaw[3] / 2);
  const bearing = (radians([0, 0], eyeDiff) + Math.PI / 2) % Math.PI;
  return { bearing, strength };
};
var calculateFaceAngle = (face5, imageSize) => {
  const normalize = (v2) => {
    const length = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);
    v2[0] /= length;
    v2[1] /= length;
    v2[2] /= length;
    return v2;
  };
  const subVectors = (a6, b2) => {
    const x2 = a6[0] - b2[0];
    const y2 = a6[1] - b2[1];
    const z2 = a6[2] - b2[2];
    return [x2, y2, z2];
  };
  const crossVectors = (a6, b2) => {
    const x2 = a6[1] * b2[2] - a6[2] * b2[1];
    const y2 = a6[2] * b2[0] - a6[0] * b2[2];
    const z2 = a6[0] * b2[1] - a6[1] * b2[0];
    return [x2, y2, z2];
  };
  const rotationMatrixToEulerAngle = (r2) => {
    const [r00, r01, r02, r10, r11, r12, r20, r21, r22] = r2;
    let thetaX;
    let thetaY;
    let thetaZ;
    if (r10 < 1) {
      if (r10 > -1) {
        thetaZ = Math.asin(r10);
        thetaY = Math.atan2(-r20, r00);
        thetaX = Math.atan2(-r12, r11);
      } else {
        thetaZ = -Math.PI / 2;
        thetaY = -Math.atan2(r21, r22);
        thetaX = 0;
      }
    } else {
      thetaZ = Math.PI / 2;
      thetaY = Math.atan2(r21, r22);
      thetaX = 0;
    }
    if (isNaN(thetaX))
      thetaX = 0;
    if (isNaN(thetaY))
      thetaY = 0;
    if (isNaN(thetaZ))
      thetaZ = 0;
    return { pitch: 2 * -thetaX, yaw: 2 * -thetaY, roll: 2 * -thetaZ };
  };
  const meshToEulerAngle = (mesh2) => {
    const radians = (a12, a22, b1, b2) => Math.atan2(b2 - a22, b1 - a12);
    const angle22 = {
      pitch: radians(mesh2[10][1], mesh2[10][2], mesh2[152][1], mesh2[152][2]),
      yaw: radians(mesh2[33][0], mesh2[33][2], mesh2[263][0], mesh2[263][2]),
      roll: radians(mesh2[33][0], mesh2[33][1], mesh2[263][0], mesh2[263][1])
    };
    return angle22;
  };
  const mesh = face5.meshRaw;
  if (!mesh || mesh.length < 300)
    return { angle: { pitch: 0, yaw: 0, roll: 0 }, matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1], gaze: { bearing: 0, strength: 0 } };
  const size2 = Math.max(face5.boxRaw[2] * imageSize[0], face5.boxRaw[3] * imageSize[1]) / 1.5;
  const pts = [mesh[10], mesh[152], mesh[234], mesh[454]].map((pt) => [
    pt[0] * imageSize[0] / size2,
    pt[1] * imageSize[1] / size2,
    pt[2]
  ]);
  const y_axis = normalize(subVectors(pts[1], pts[0]));
  let x_axis = normalize(subVectors(pts[3], pts[2]));
  const z_axis = normalize(crossVectors(x_axis, y_axis));
  x_axis = crossVectors(y_axis, z_axis);
  const matrix = [
    x_axis[0],
    x_axis[1],
    x_axis[2],
    y_axis[0],
    y_axis[1],
    y_axis[2],
    z_axis[0],
    z_axis[1],
    z_axis[2]
  ];
  const angle2 = rotationMatrixToEulerAngle(matrix);
  const gaze = mesh.length === 478 ? calculateGaze(face5) : { bearing: 0, strength: 0 };
  return { angle: angle2, matrix, gaze };
};
var detectFace = async (parent, input2) => {
  var _a, _b, _c, _d;
  let timeStamp;
  let ageRes;
  let gearRes;
  let genderRes;
  let emotionRes;
  let embeddingRes;
  let descRes;
  const faceRes = [];
  parent.state = "run:face";
  timeStamp = now2();
  const faces = await predict(input2, parent.config);
  parent.performance.face = Math.trunc(now2() - timeStamp);
  if (!input2.shape || input2.shape.length !== 4)
    return [];
  if (!faces)
    return [];
  for (let i2 = 0; i2 < faces.length; i2++) {
    parent.analyze("Get Face");
    if (!faces[i2].tensor || faces[i2].tensor["isDisposedInternal"]) {
      log("Face object is disposed:", faces[i2].tensor);
      continue;
    }
    const rotation = calculateFaceAngle(faces[i2], [input2.shape[2], input2.shape[1]]);
    parent.analyze("Start Emotion:");
    if (parent.config.async) {
      emotionRes = parent.config.face.emotion.enabled ? predict3(faces[i2].tensor || tensor([]), parent.config, i2, faces.length) : {};
    } else {
      parent.state = "run:emotion";
      timeStamp = now2();
      emotionRes = parent.config.face.emotion.enabled ? await predict3(faces[i2].tensor || tensor([]), parent.config, i2, faces.length) : {};
      parent.performance.emotion = Math.trunc(now2() - timeStamp);
    }
    parent.analyze("End Emotion:");
    parent.analyze("Start Description:");
    if (parent.config.async) {
      descRes = parent.config.face.description.enabled ? predict2(faces[i2].tensor || tensor([]), parent.config, i2, faces.length) : [];
    } else {
      parent.state = "run:description";
      timeStamp = now2();
      descRes = parent.config.face.description.enabled ? await predict2(faces[i2].tensor || tensor([]), parent.config, i2, faces.length) : [];
      parent.performance.embedding = Math.trunc(now2() - timeStamp);
    }
    parent.analyze("End Description:");
    if (parent.config.async) {
      [ageRes, genderRes, emotionRes, embeddingRes, descRes, gearRes] = await Promise.all([ageRes, genderRes, emotionRes, embeddingRes, descRes, gearRes]);
    }
    parent.analyze("Finish Face:");
    if (!parent.config.face.iris.enabled && ((_b = (_a = faces[i2]) == null ? void 0 : _a.annotations) == null ? void 0 : _b.leftEyeIris) && ((_d = (_c = faces[i2]) == null ? void 0 : _c.annotations) == null ? void 0 : _d.rightEyeIris)) {
      delete faces[i2].annotations.leftEyeIris;
      delete faces[i2].annotations.rightEyeIris;
    }
    const irisSize = faces[i2].annotations && faces[i2].annotations.leftEyeIris && faces[i2].annotations.leftEyeIris[0] && faces[i2].annotations.rightEyeIris && faces[i2].annotations.rightEyeIris[0] && faces[i2].annotations.leftEyeIris.length > 0 && faces[i2].annotations.rightEyeIris.length > 0 && faces[i2].annotations.leftEyeIris[0] !== null && faces[i2].annotations.rightEyeIris[0] !== null ? Math.max(Math.abs(faces[i2].annotations.leftEyeIris[3][0] - faces[i2].annotations.leftEyeIris[1][0]), Math.abs(faces[i2].annotations.rightEyeIris[4][1] - faces[i2].annotations.rightEyeIris[2][1])) / input2.shape[2] : 0;
    const tensor2 = parent.config.face.detector.return ? squeeze(faces[i2].tensor) : null;
    dispose(faces[i2].tensor);
    if (faces[i2].tensor)
      delete faces[i2].tensor;
    faceRes.push({
      ...faces[i2],
      id: i2,
      age: descRes.age,
      gender: descRes.gender,
      genderScore: descRes.genderScore,
      embedding: descRes.descriptor,
      emotion: emotionRes,
      iris: irisSize !== 0 ? Math.trunc(500 / irisSize / 11.7) / 100 : 0,
      rotation,
      tensor: tensor2
    });
    parent.analyze("End Face");
  }
  parent.analyze("End FaceMesh:");
  if (parent.config.async) {
    if (parent.performance.face)
      delete parent.performance.face;
    if (parent.performance.age)
      delete parent.performance.age;
    if (parent.performance.gender)
      delete parent.performance.gender;
    if (parent.performance.emotion)
      delete parent.performance.emotion;
  }
  return faceRes;
};
var body2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i2 = 0; i2 < res2.length; i2++) {
    const leftWrist = res2[i2].keypoints.find((a6) => a6.part === "leftWrist");
    const rightWrist = res2[i2].keypoints.find((a6) => a6.part === "rightWrist");
    const nose = res2[i2].keypoints.find((a6) => a6.part === "nose");
    if (nose && leftWrist && rightWrist && leftWrist.position[1] < nose.position[1] && rightWrist.position[1] < nose.position[1])
      gestures.push({ body: i2, gesture: "i give up" });
    else if (nose && leftWrist && leftWrist.position[1] < nose.position[1])
      gestures.push({ body: i2, gesture: "raise left hand" });
    else if (nose && rightWrist && rightWrist.position[1] < nose.position[1])
      gestures.push({ body: i2, gesture: "raise right hand" });
    const leftShoulder = res2[i2].keypoints.find((a6) => a6.part === "leftShoulder");
    const rightShoulder = res2[i2].keypoints.find((a6) => a6.part === "rightShoulder");
    if (leftShoulder && rightShoulder)
      gestures.push({ body: i2, gesture: `leaning ${leftShoulder.position[1] > rightShoulder.position[1] ? "left" : "right"}` });
  }
  return gestures;
};
var face2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i2 = 0; i2 < res2.length; i2++) {
    if (res2[i2].mesh && res2[i2].mesh.length > 450) {
      const eyeFacing = res2[i2].mesh[33][2] - res2[i2].mesh[263][2];
      if (Math.abs(eyeFacing) < 10)
        gestures.push({ face: i2, gesture: "facing center" });
      else
        gestures.push({ face: i2, gesture: `facing ${eyeFacing < 0 ? "left" : "right"}` });
      const openLeft = Math.abs(res2[i2].mesh[374][1] - res2[i2].mesh[386][1]) / Math.abs(res2[i2].mesh[443][1] - res2[i2].mesh[450][1]);
      if (openLeft < 0.2)
        gestures.push({ face: i2, gesture: "blink left eye" });
      const openRight = Math.abs(res2[i2].mesh[145][1] - res2[i2].mesh[159][1]) / Math.abs(res2[i2].mesh[223][1] - res2[i2].mesh[230][1]);
      if (openRight < 0.2)
        gestures.push({ face: i2, gesture: "blink right eye" });
      const mouthOpen = Math.min(100, 500 * Math.abs(res2[i2].mesh[13][1] - res2[i2].mesh[14][1]) / Math.abs(res2[i2].mesh[10][1] - res2[i2].mesh[152][1]));
      if (mouthOpen > 10)
        gestures.push({ face: i2, gesture: `mouth ${Math.trunc(mouthOpen)}% open` });
      const chinDepth = res2[i2].mesh[152][2];
      if (Math.abs(chinDepth) > 10)
        gestures.push({ face: i2, gesture: `head ${chinDepth < 0 ? "up" : "down"}` });
    }
  }
  return gestures;
};
var iris3 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i2 = 0; i2 < res2.length; i2++) {
    if (!res2[i2].annotations || !res2[i2].annotations.leftEyeIris || !res2[i2].annotations.leftEyeIris[0] || !res2[i2].annotations.rightEyeIris || !res2[i2].annotations.rightEyeIris[0])
      continue;
    const sizeXLeft = res2[i2].annotations.leftEyeIris[3][0] - res2[i2].annotations.leftEyeIris[1][0];
    const sizeYLeft = res2[i2].annotations.leftEyeIris[4][1] - res2[i2].annotations.leftEyeIris[2][1];
    const areaLeft = Math.abs(sizeXLeft * sizeYLeft);
    const sizeXRight = res2[i2].annotations.rightEyeIris[3][0] - res2[i2].annotations.rightEyeIris[1][0];
    const sizeYRight = res2[i2].annotations.rightEyeIris[4][1] - res2[i2].annotations.rightEyeIris[2][1];
    const areaRight = Math.abs(sizeXRight * sizeYRight);
    let center = false;
    const difference = Math.abs(areaLeft - areaRight) / Math.max(areaLeft, areaRight);
    if (difference < 0.25) {
      center = true;
      gestures.push({ iris: i2, gesture: "facing center" });
    }
    const rightIrisCenterX = Math.abs(res2[i2].mesh[33][0] - res2[i2].annotations.rightEyeIris[0][0]) / res2[i2].box[2];
    const leftIrisCenterX = Math.abs(res2[i2].mesh[263][0] - res2[i2].annotations.leftEyeIris[0][0]) / res2[i2].box[2];
    if (leftIrisCenterX > 0.06 || rightIrisCenterX > 0.06)
      center = false;
    if (leftIrisCenterX > 0.06)
      gestures.push({ iris: i2, gesture: "looking right" });
    if (rightIrisCenterX > 0.06)
      gestures.push({ iris: i2, gesture: "looking left" });
    const rightIrisCenterY = Math.abs(res2[i2].mesh[145][1] - res2[i2].annotations.rightEyeIris[0][1]) / res2[i2].box[3];
    const leftIrisCenterY = Math.abs(res2[i2].mesh[374][1] - res2[i2].annotations.leftEyeIris[0][1]) / res2[i2].box[3];
    if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01 || leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
      center = false;
    if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01)
      gestures.push({ iris: i2, gesture: "looking down" });
    if (leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
      gestures.push({ iris: i2, gesture: "looking up" });
    if (center)
      gestures.push({ iris: i2, gesture: "looking center" });
  }
  return gestures;
};
var hand2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i2 = 0; i2 < res2.length; i2++) {
    const fingers = [];
    if (res2[i2]["annotations"]) {
      for (const [finger, pos] of Object.entries(res2[i2]["annotations"])) {
        if (finger !== "palmBase" && Array.isArray(pos) && pos[0])
          fingers.push({ name: finger.toLowerCase(), position: pos[0] });
      }
    }
    if (fingers && fingers.length > 0) {
      const closest = fingers.reduce((best, a6) => best.position[2] < a6.position[2] ? best : a6);
      gestures.push({ hand: i2, gesture: `${closest.name} forward` });
      const highest = fingers.reduce((best, a6) => best.position[1] < a6.position[1] ? best : a6);
      gestures.push({ hand: i2, gesture: `${highest.name} up` });
    }
    if (res2[i2]["keypoints"]) {
      const poses = match(res2[i2]["keypoints"]);
      for (const pose of poses)
        gestures.push({ hand: i2, gesture: pose.name });
    }
  }
  return gestures;
};
var bufferedResult = { face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0 };
function calc2(newResult, config3) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2, _r, _s, _t, _u, _v, _w, _x2, _y2, _z2, _A;
  const t0 = performance.now();
  if (!newResult)
    return { face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0 };
  const elapsed = Date.now() - newResult.timestamp;
  const bufferedFactor = elapsed < 1e3 ? 8 - Math.log(elapsed + 1) : 1;
  bufferedResult.canvas = newResult.canvas;
  if (!bufferedResult.body || newResult.body.length !== bufferedResult.body.length) {
    bufferedResult.body = JSON.parse(JSON.stringify(newResult.body));
  } else {
    for (let i2 = 0; i2 < newResult.body.length; i2++) {
      const box5 = newResult.body[i2].box.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.body[i2].box[j2] + b2) / bufferedFactor);
      const boxRaw = newResult.body[i2].boxRaw.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.body[i2].boxRaw[j2] + b2) / bufferedFactor);
      const keypoints2 = newResult.body[i2].keypoints.map((keypoint, j2) => ({
        score: keypoint.score,
        part: keypoint.part,
        position: [
          bufferedResult.body[i2].keypoints[j2] ? ((bufferedFactor - 1) * bufferedResult.body[i2].keypoints[j2].position[0] + keypoint.position[0]) / bufferedFactor : keypoint.position[0],
          bufferedResult.body[i2].keypoints[j2] ? ((bufferedFactor - 1) * bufferedResult.body[i2].keypoints[j2].position[1] + keypoint.position[1]) / bufferedFactor : keypoint.position[1]
        ],
        positionRaw: [
          bufferedResult.body[i2].keypoints[j2] ? ((bufferedFactor - 1) * bufferedResult.body[i2].keypoints[j2].positionRaw[0] + keypoint.positionRaw[0]) / bufferedFactor : keypoint.position[0],
          bufferedResult.body[i2].keypoints[j2] ? ((bufferedFactor - 1) * bufferedResult.body[i2].keypoints[j2].positionRaw[1] + keypoint.positionRaw[1]) / bufferedFactor : keypoint.position[1]
        ]
      }));
      const annotations2 = {};
      let coords9 = { connected: {} };
      if ((_b = (_a = config3.body) == null ? void 0 : _a.modelPath) == null ? void 0 : _b.includes("efficientpose"))
        coords9 = efficientposecoords_exports;
      else if ((_d = (_c = config3.body) == null ? void 0 : _c.modelPath) == null ? void 0 : _d.includes("blazepose"))
        coords9 = blazeposecoords_exports;
      else if ((_f = (_e2 = config3.body) == null ? void 0 : _e2.modelPath) == null ? void 0 : _f.includes("movenet"))
        coords9 = movenetcoords_exports;
      for (const [name, indexes] of Object.entries(coords9.connected)) {
        const pt = [];
        for (let j2 = 0; j2 < indexes.length - 1; j2++) {
          const pt0 = keypoints2.find((kp) => kp.part === indexes[j2]);
          const pt1 = keypoints2.find((kp) => kp.part === indexes[j2 + 1]);
          if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
            pt.push([pt0.position, pt1.position]);
        }
        annotations2[name] = pt;
      }
      bufferedResult.body[i2] = { ...newResult.body[i2], box: box5, boxRaw, keypoints: keypoints2, annotations: annotations2 };
    }
  }
  if (!bufferedResult.hand || newResult.hand.length !== bufferedResult.hand.length) {
    bufferedResult.hand = JSON.parse(JSON.stringify(newResult.hand));
  } else {
    for (let i2 = 0; i2 < newResult.hand.length; i2++) {
      const box5 = newResult.hand[i2].box.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.hand[i2].box[j2] + b2) / bufferedFactor);
      const boxRaw = newResult.hand[i2].boxRaw.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.hand[i2].boxRaw[j2] + b2) / bufferedFactor);
      if (bufferedResult.hand[i2].keypoints.length !== newResult.hand[i2].keypoints.length)
        bufferedResult.hand[i2].keypoints = newResult.hand[i2].keypoints;
      const keypoints2 = newResult.hand[i2].keypoints && newResult.hand[i2].keypoints.length > 0 ? newResult.hand[i2].keypoints.map((landmark, j2) => landmark.map((coord, k3) => ((bufferedFactor - 1) * (bufferedResult.hand[i2].keypoints[j2][k3] || 1) + (coord || 0)) / bufferedFactor)) : [];
      let annotations2 = {};
      if (Object.keys(bufferedResult.hand[i2].annotations).length !== Object.keys(newResult.hand[i2].annotations).length) {
        bufferedResult.hand[i2].annotations = newResult.hand[i2].annotations;
        annotations2 = bufferedResult.hand[i2].annotations;
      } else if (newResult.hand[i2].annotations) {
        for (const key of Object.keys(newResult.hand[i2].annotations)) {
          annotations2[key] = newResult.hand[i2].annotations[key] && newResult.hand[i2].annotations[key][0] ? newResult.hand[i2].annotations[key].map((val, j2) => val.map((coord, k3) => ((bufferedFactor - 1) * bufferedResult.hand[i2].annotations[key][j2][k3] + coord) / bufferedFactor)) : null;
        }
      }
      bufferedResult.hand[i2] = { ...newResult.hand[i2], box: box5, boxRaw, keypoints: keypoints2, annotations: annotations2 };
    }
  }
  if (!bufferedResult.face || newResult.face.length !== bufferedResult.face.length) {
    bufferedResult.face = JSON.parse(JSON.stringify(newResult.face));
  } else {
    for (let i2 = 0; i2 < newResult.face.length; i2++) {
      const box5 = newResult.face[i2].box.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.face[i2].box[j2] + b2) / bufferedFactor);
      const boxRaw = newResult.face[i2].boxRaw.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.face[i2].boxRaw[j2] + b2) / bufferedFactor);
      const rotation = { matrix: [0, 0, 0, 0, 0, 0, 0, 0, 0], angle: { roll: 0, yaw: 0, pitch: 0 }, gaze: { bearing: 0, strength: 0 } };
      rotation.matrix = (_g = newResult.face[i2].rotation) == null ? void 0 : _g.matrix;
      rotation.angle = {
        roll: ((bufferedFactor - 1) * (((_i = (_h = bufferedResult.face[i2].rotation) == null ? void 0 : _h.angle) == null ? void 0 : _i.roll) || 0) + (((_k = (_j = newResult.face[i2].rotation) == null ? void 0 : _j.angle) == null ? void 0 : _k.roll) || 0)) / bufferedFactor,
        yaw: ((bufferedFactor - 1) * (((_m = (_l = bufferedResult.face[i2].rotation) == null ? void 0 : _l.angle) == null ? void 0 : _m.yaw) || 0) + (((_o = (_n = newResult.face[i2].rotation) == null ? void 0 : _n.angle) == null ? void 0 : _o.yaw) || 0)) / bufferedFactor,
        pitch: ((bufferedFactor - 1) * (((_q2 = (_p = bufferedResult.face[i2].rotation) == null ? void 0 : _p.angle) == null ? void 0 : _q2.pitch) || 0) + (((_s = (_r = newResult.face[i2].rotation) == null ? void 0 : _r.angle) == null ? void 0 : _s.pitch) || 0)) / bufferedFactor
      };
      rotation.gaze = {
        bearing: ((bufferedFactor - 1) * (((_u = (_t = bufferedResult.face[i2].rotation) == null ? void 0 : _t.gaze) == null ? void 0 : _u.bearing) || 0) + (((_w = (_v = newResult.face[i2].rotation) == null ? void 0 : _v.gaze) == null ? void 0 : _w.bearing) || 0)) / bufferedFactor,
        strength: ((bufferedFactor - 1) * (((_y2 = (_x2 = bufferedResult.face[i2].rotation) == null ? void 0 : _x2.gaze) == null ? void 0 : _y2.strength) || 0) + (((_A = (_z2 = newResult.face[i2].rotation) == null ? void 0 : _z2.gaze) == null ? void 0 : _A.strength) || 0)) / bufferedFactor
      };
      bufferedResult.face[i2] = { ...newResult.face[i2], rotation, box: box5, boxRaw };
    }
  }
  if (!bufferedResult.object || newResult.object.length !== bufferedResult.object.length) {
    bufferedResult.object = JSON.parse(JSON.stringify(newResult.object));
  } else {
    for (let i2 = 0; i2 < newResult.object.length; i2++) {
      const box5 = newResult.object[i2].box.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.object[i2].box[j2] + b2) / bufferedFactor);
      const boxRaw = newResult.object[i2].boxRaw.map((b2, j2) => ((bufferedFactor - 1) * bufferedResult.object[i2].boxRaw[j2] + b2) / bufferedFactor);
      bufferedResult.object[i2] = { ...newResult.object[i2], box: box5, boxRaw };
    }
  }
  if (newResult.persons) {
    const newPersons = newResult.persons;
    if (!bufferedResult.persons || newPersons.length !== bufferedResult.persons.length) {
      bufferedResult.persons = JSON.parse(JSON.stringify(newPersons));
    } else {
      for (let i2 = 0; i2 < newPersons.length; i2++) {
        bufferedResult.persons[i2].box = newPersons[i2].box.map((box5, j2) => ((bufferedFactor - 1) * bufferedResult.persons[i2].box[j2] + box5) / bufferedFactor);
      }
    }
  }
  if (newResult.gesture)
    bufferedResult.gesture = newResult.gesture;
  const t1 = performance.now();
  if (newResult.performance)
    bufferedResult.performance = { ...newResult.performance, interpolate: Math.round(t1 - t0) };
  return bufferedResult;
}
function distance(descriptor1, descriptor2, options3 = { order: 2 }) {
  let sum7 = 0;
  for (let i2 = 0; i2 < descriptor1.length; i2++) {
    const diff = options3.order === 2 ? descriptor1[i2] - descriptor2[i2] : Math.abs(descriptor1[i2] - descriptor2[i2]);
    sum7 += options3.order === 2 ? diff * diff : diff ** options3.order;
  }
  return sum7;
}
function similarity(descriptor1, descriptor2, options3 = { order: 2 }) {
  const dist = distance(descriptor1, descriptor2, options3);
  const invert = options3.order === 2 ? Math.sqrt(dist) : dist ** (1 / options3.order);
  return Math.max(0, 100 - invert) / 100;
}
function match2(descriptor, descriptors, options3 = { order: 2, threshold: 0 }) {
  if (!Array.isArray(descriptor) || !Array.isArray(descriptors) || descriptor.length < 64 || descriptors.length === 0 || descriptor.length !== descriptors[0].length) {
    return { index: -1, distance: Number.POSITIVE_INFINITY, similarity: 0 };
  }
  let best = Number.MAX_SAFE_INTEGER;
  let index = -1;
  for (let i2 = 0; i2 < descriptors.length; i2++) {
    const res2 = distance(descriptor, descriptors[i2], { order: options3.order });
    if (res2 < best) {
      best = res2;
      index = i2;
    }
    if (best < options3.threshold)
      break;
  }
  best = options3.order === 2 ? Math.sqrt(best) : best ** (1 / options3.order);
  return { index, distance: best, similarity: Math.max(0, 100 - best) / 100 };
}
function join2(faces, bodies, hands, gestures, shape) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  let id = 0;
  const persons2 = [];
  for (const face5 of faces) {
    const person2 = { id: id++, face: face5, body: null, hands: { left: null, right: null }, gestures: [], box: [0, 0, 0, 0] };
    for (const body4 of bodies) {
      if (face5.box[0] > body4.box[0] && face5.box[0] < body4.box[0] + body4.box[2] && face5.box[1] + face5.box[3] > body4.box[1] && face5.box[1] + face5.box[3] < body4.box[1] + body4.box[3]) {
        person2.body = body4;
      }
    }
    if (person2.body) {
      for (const hand3 of hands) {
        if (hand3.box[0] + hand3.box[2] > person2.body.box[0] && hand3.box[0] + hand3.box[2] < person2.body.box[0] + person2.body.box[2] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
          if (person2.hands)
            person2.hands.left = hand3;
        }
        if (hand3.box[0] < person2.body.box[0] + person2.body.box[2] && hand3.box[0] > person2.body.box[0] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
          if (person2.hands)
            person2.hands.right = hand3;
        }
      }
    }
    for (const gesture3 of gestures) {
      if (gesture3["face"] !== void 0 && gesture3["face"] === face5.id)
        (_a = person2.gestures) == null ? void 0 : _a.push(gesture3);
      else if (gesture3["iris"] !== void 0 && gesture3["iris"] === face5.id)
        (_b = person2.gestures) == null ? void 0 : _b.push(gesture3);
      else if (gesture3["body"] !== void 0 && gesture3["body"] === ((_c = person2.body) == null ? void 0 : _c.id))
        (_d = person2.gestures) == null ? void 0 : _d.push(gesture3);
      else if (gesture3["hand"] !== void 0 && gesture3["hand"] === ((_f = (_e2 = person2.hands) == null ? void 0 : _e2.left) == null ? void 0 : _f.id))
        (_g = person2.gestures) == null ? void 0 : _g.push(gesture3);
      else if (gesture3["hand"] !== void 0 && gesture3["hand"] === ((_i = (_h = person2.hands) == null ? void 0 : _h.right) == null ? void 0 : _i.id))
        (_j = person2.gestures) == null ? void 0 : _j.push(gesture3);
    }
    const x2 = [];
    const y2 = [];
    const extractXY = (box5) => {
      if (box5 && box5.length === 4) {
        x2.push(box5[0], box5[0] + box5[2]);
        y2.push(box5[1], box5[1] + box5[3]);
      }
    };
    extractXY((_k = person2.face) == null ? void 0 : _k.box);
    extractXY((_l = person2.body) == null ? void 0 : _l.box);
    extractXY((_n = (_m = person2.hands) == null ? void 0 : _m.left) == null ? void 0 : _n.box);
    extractXY((_p = (_o = person2.hands) == null ? void 0 : _o.right) == null ? void 0 : _p.box);
    const minX = Math.min(...x2);
    const minY = Math.min(...y2);
    person2.box = [minX, minY, Math.max(...x2) - minX, Math.max(...y2) - minY];
    if (shape && shape[1] && shape[2])
      person2.boxRaw = [person2.box[0] / shape[2], person2.box[1] / shape[1], person2.box[2] / shape[2], person2.box[3] / shape[1]];
    persons2.push(person2);
  }
  return persons2;
}
var face3 = `
/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA
AAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu
bmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob
IxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo
KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E
AB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE
EQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH
SElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1
tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB
AQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET
IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla
Y2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML
Xp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF
PUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/
AJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z
5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9
zZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO
tHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6
8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W
wA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk
EtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6
GhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT
A7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep
rBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb
LCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ
ih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K
KAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l
pBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x
UqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4
HaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr
xL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS
NO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD
1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX
+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3
GBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K
q4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0
nhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm
uic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH
ArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV
wF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8
87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P
FQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD
YNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv
JmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ
QmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el
UJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681
ly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly
CK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc
UDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF
63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x
XY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2
ZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk
Xb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK
cBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef
eNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4
/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5
rl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru
/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A
zviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO
I4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1
jfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ
GRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG
cZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb
WmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis
ZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH
ckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi
lbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO
xuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK
JtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX
PaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c
W0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t
C6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk
4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn
xHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW
vHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi
qr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV
hamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F
j4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6
wqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm
oy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ
k7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg
nQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP
1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1
H1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ
1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx
zSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt
fFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp
Oxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj
VtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy
rFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe
5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D
d/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69
MlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ
Fbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ
MA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP
ByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn
0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU
yOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is
pNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz
TSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu
uCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem
gGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk
HvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy
s9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu
m6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb
0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz
9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN
DNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n
R6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk
nmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu
6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd
9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb
Sms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S
MSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz
FEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8
VSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx
Y0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ
mupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+
5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh
05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd
ua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ
5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR
Mqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8
1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4
B9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag
Bc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA
3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn
3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx
1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU
tzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6
f3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA
bvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ
zyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup
6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM
350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0
/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a
YfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ
agBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO
mAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl
mOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR
nqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo
EPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt
4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ
ScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p
iMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj
PQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l
c6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1
8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3
ylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY
euPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==`;
var body3 = `
/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk
JyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF
RUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA
AhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA
AQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA
AAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA
AhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj
+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt
Fh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR
PLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl
mZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp
+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa
zhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D
h1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2
ex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67
d4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y
Rv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP
Ld3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC
vy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi
eSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/
Mx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+
r3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO
O0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s
tfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN
TmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc
0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj
q83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w
+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s
d8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t
cI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4
Yibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe
bzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi
KxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6
rNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ
9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf
Jvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V
bxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q
Vbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM
lorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/
/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme
E4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv
fauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6
jkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN
+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk
Rvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK
cGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop
yW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn
E8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX
12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW
iI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS
RWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf
0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx
DS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL
G8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK
xC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ
a9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4
ZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6
tvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+
fJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE
erk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR
Md5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9
lcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD
j8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV
5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt
Cu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/
+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c
vUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p
jrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0
77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP
Sel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8
5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe
Y0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R
Hwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV
rWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU
z7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8
to6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X
y8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt
stcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/
w9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT
DpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l
XV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t
ydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS
34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX
e09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn
26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf
3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q
6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P
NbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO
yZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN
3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8
2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h
dqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx
kr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t
DHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb
eFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc
1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka
c258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE
xEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu
s5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK
0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9
dM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt
PXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T
Md/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T
adq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b
SVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt
pdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm
vfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr
EejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N
vwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh
ZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I
tkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW
d43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe
N4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218
8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG
PNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY
V1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw
w18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT
Ex5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1
axqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/
tDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I
mbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe
XRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1
izjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2
crFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4
OadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2
r8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx
zc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz
+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v
Mevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu
ryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095
YZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE
9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8
mNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O
uSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O
fft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6
Olty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT
uTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3
6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1
Mb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF
feH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq
xVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v
ed7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ
mtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz
mWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP
B39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0
5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1
mkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt
mxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO
1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq
ZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q
ky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7
ROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK
GEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i
tMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T
+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+
O8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO
esd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es
vPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz
XV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1
+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY
36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL
q555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY
3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz
p7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr
1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV
xUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt
pCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS
fP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH
mMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z
1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+
n3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d
MRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df
zXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl
J2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs
zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH
DpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ
dHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR
tER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j
admFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC
b2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X
qdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh
ydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O
8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L
T7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0
Za1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr
vNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer
rWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL
oNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq
j/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh
odZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8
8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1
lNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+
oza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL
knU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK
EtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N
mtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm
9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N
IpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W
MYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2
+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql
o+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37
O99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE
TE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1
L7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4
izsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt
1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb
V5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum
L37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12
CvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE
ebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo
Gvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu
L8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh
5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3
6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9
XO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM
feKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj
SZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF
XaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr
79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h
yeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT
OC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223
2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt
adohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y
cnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX
DpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p
7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso
S24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l
bPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe
vVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG
H6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7
x3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz
5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY
q+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn
vLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2
IjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK
z0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ
YYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON
ZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW
ekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf
cjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c
biuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO
CkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw
y1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi
QXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E
bL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r
tv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t
LRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP
RqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm
s7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el
XX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1
vK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq
qrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v
VYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0
ZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q
mT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm
6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG
f63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo
dPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22
gtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M
MoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb
c2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX
6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn
1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK
fOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ
EqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u
7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT
qPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa
S2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf
Lp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU
IiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O
8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c
vU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx
5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V
KTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm
2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu
j8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB
TTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9
RUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL
CWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA
AAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8
cTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj
qKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF
0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK
ZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK
66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu
XT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9
XOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN
M2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv
VrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK
7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI
3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m
XY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m
1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A
JUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC
EgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9
8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL
OrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H
M+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA
TsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8
elpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp
BjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS
CRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r
rcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY
jbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW
UsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB
KUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb
Sz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL
+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v
T471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM
sfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj
FontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl
5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q
7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv
6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa
0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/
AOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM
d8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5
6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP
bFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu
LJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy
wt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX
0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK
3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn
KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0
vobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t
zya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps
uOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi
Fdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2
O3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z
aK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz
0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb
T/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l
qMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t
trJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn
mvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa
eq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe
PwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of
TdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O
1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG
f/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi
0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY
5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc
V2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L
/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM
t/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd
VknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD
KLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R
fwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3
Vxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ
DJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ
3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv
x7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
weqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI
6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew
PnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk
j3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm
OqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/
AKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez
N9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ
92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp
+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue
V9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv
avHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0
vQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP
8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt
n1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw
nUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3
7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P
0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U
x8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG
0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L
faQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ
QKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA
BAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A
tLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv
9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr
jn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm
b7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB
ACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk
dEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1
rMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+
x+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA
AAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr
YvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4
5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V
kK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg
BIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA
AAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g
Wbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx
OEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2
H/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF
+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V
h6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA
EgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu
ZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml
HMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl
n0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN
3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi
/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00
+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC
UACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2
M2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp
5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn
N1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS
OjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL
/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo
stLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3
GyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA
AAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4
qmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy
WEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a
fJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI
rTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2
rz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc
3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3
Tur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA
AAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx
skA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F
o7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx
NO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h
2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te
pSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7
cvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7
mZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA
AAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA
hGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J
qx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI
XRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy
RHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX
qNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX
kaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P
ya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC
ExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA
lAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA
AAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o
b9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP
y6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae
kzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu
9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ
k7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1
8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp
DXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh
nyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ
AAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA
AAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO
yvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5
PM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii
IpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r
O3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE
yTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX
6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2
JgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS
AAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA
AAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx
Wa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI
6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5
K2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7
Vv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id
PW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ
2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4
eF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7
piVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR
ACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ
JQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i
UiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61
rZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq
ZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2
f0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO
IjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts
bAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA
AAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA
BAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2
SbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T
lBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/
2Q==`;
async function warmupBitmap(instance) {
  const b64toBlob = (base64, type = "application/octet-stream") => fetch(`data:${type};base64,${base64}`).then((res22) => res22.blob());
  let blob;
  let res2;
  switch (instance.config.warmup) {
    case "face":
      blob = await b64toBlob(face3);
      break;
    case "body":
    case "full":
      blob = await b64toBlob(body3);
      break;
    default:
      blob = null;
  }
  if (blob) {
    const bitmap = await createImageBitmap(blob);
    res2 = await instance.detect(bitmap, instance.config);
    bitmap.close();
  }
  return res2;
}
async function warmupCanvas(instance) {
  return new Promise((resolve) => {
    let src;
    switch (instance.config.warmup) {
      case "face":
        src = "data:image/jpeg;base64," + face3;
        break;
      case "full":
      case "body":
        src = "data:image/jpeg;base64," + body3;
        break;
      default:
        src = null;
    }
    let img;
    if (typeof Image !== "undefined")
      img = new Image();
    else if (env2.Image)
      img = new env2.Image();
    img.onload = async () => {
      const canvas3 = canvas(img.naturalWidth, img.naturalHeight);
      if (!canvas3) {
        log("Warmup: Canvas not found");
        resolve({});
      } else {
        const ctx = canvas3.getContext("2d");
        if (ctx)
          ctx.drawImage(img, 0, 0);
        const tensor2 = await instance.image(canvas3);
        const res2 = await instance.detect(tensor2.tensor, instance.config);
        resolve(res2);
      }
    };
    if (src)
      img.src = src;
    else
      resolve(null);
  });
}
async function warmupNode(instance) {
  const atob2 = (str) => Buffer.from(str, "base64");
  let img;
  if (instance.config.warmup === "face")
    img = atob2(face3);
  if (instance.config.warmup === "body" || instance.config.warmup === "full")
    img = atob2(body3);
  if (!img)
    return null;
  let res2;
  if (false) {
    const data = (void 0).decodeJpeg(img);
    const expanded = data.expandDims(0);
    instance.tf.dispose(data);
    res2 = await instance.detect(expanded, instance.config);
    instance.tf.dispose(expanded);
  } else {
    if (instance.config.debug)
      log("Warmup tfjs-node not loaded");
  }
  return res2;
}
async function warmup(instance, userConfig) {
  const t0 = now2();
  instance.state = "warmup";
  if (userConfig)
    instance.config = mergeDeep(instance.config, userConfig);
  if (!instance.config.warmup || instance.config.warmup === "none")
    return { error: "null" };
  let res2;
  return new Promise(async (resolve) => {
    if (typeof createImageBitmap === "function")
      res2 = await warmupBitmap(instance);
    else if (typeof Image !== "undefined" || env2.Canvas !== void 0)
      res2 = await warmupCanvas(instance);
    else
      res2 = await warmupNode(instance);
    const t1 = now2();
    if (instance.config.debug)
      log("Warmup", instance.config.warmup, Math.round(t1 - t0), "ms");
    instance.emit("warmup");
    resolve(res2);
  });
}
var _numTensors;
var _analyzeMemoryLeaks;
var _checkSanity;
var _sanity;
var Human = class {
  constructor(userConfig) {
    __publicField(this, "version");
    __publicField(this, "config");
    __publicField(this, "result");
    __publicField(this, "state");
    __publicField(this, "process");
    __publicField(this, "tf");
    __publicField(this, "env");
    __publicField(this, "draw");
    __publicField(this, "models");
    __publicField(this, "events");
    __publicField(this, "faceTriangulation");
    __publicField(this, "faceUVMap");
    __publicField(this, "performance");
    __privateAdd(this, _numTensors, void 0);
    __privateAdd(this, _analyzeMemoryLeaks, void 0);
    __privateAdd(this, _checkSanity, void 0);
    __publicField(this, "gl");
    __publicField(this, "analyze", (...msg) => {
      if (!__privateGet(this, _analyzeMemoryLeaks))
        return;
      const currentTensors = this.tf.engine().state.numTensors;
      const previousTensors = __privateGet(this, _numTensors);
      __privateSet(this, _numTensors, currentTensors);
      const leaked = currentTensors - previousTensors;
      if (leaked !== 0)
        log(...msg, leaked);
    });
    __privateAdd(this, _sanity, (input2) => {
      if (!__privateGet(this, _checkSanity))
        return null;
      if (!input2)
        return "input is not defined";
      if (this.env.node && !(input2 instanceof Tensor))
        return "input must be a tensor";
      try {
        this.tf.getBackend();
      } catch (e2) {
        return "backend not loaded";
      }
      return null;
    });
    __publicField(this, "similarity", similarity);
    __publicField(this, "distance", distance);
    __publicField(this, "match", match2);
    __publicField(this, "emit", (event) => {
      var _a;
      if (this.events && this.events.dispatchEvent)
        (_a = this.events) == null ? void 0 : _a.dispatchEvent(new Event(event));
    });
    get3();
    this.env = env2;
    config.wasmPath = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${version}/dist/`;
    config.modelBasePath = this.env.browser ? "../models/" : "file://models/";
    config.backend = this.env.browser ? "humangl" : "tensorflow";
    this.version = version6;
    Object.defineProperty(this, "version", { value: version6 });
    this.config = JSON.parse(JSON.stringify(config));
    Object.seal(this.config);
    if (userConfig)
      this.config = mergeDeep(this.config, userConfig);
    this.tf = tfjs_esm_exports;
    this.state = "idle";
    __privateSet(this, _numTensors, 0);
    __privateSet(this, _analyzeMemoryLeaks, false);
    __privateSet(this, _checkSanity, false);
    this.performance = { backend: 0, load: 0, image: 0, frames: 0, cached: 0, changed: 0, total: 0, draw: 0 };
    this.events = typeof EventTarget !== "undefined" ? new EventTarget() : void 0;
    this.models = new Models();
    this.draw = {
      options: options2,
      canvas: (input2, output) => canvas2(input2, output),
      face: (output, result, options3) => face(output, result, options3),
      body: (output, result, options3) => body(output, result, options3),
      hand: (output, result, options3) => hand(output, result, options3),
      gesture: (output, result, options3) => gesture(output, result, options3),
      object: (output, result, options3) => object(output, result, options3),
      person: (output, result, options3) => person(output, result, options3),
      all: (output, result, options3) => all5(output, result, options3)
    };
    this.result = { face: [], body: [], hand: [], gesture: [], object: [], performance: {}, timestamp: 0, persons: [] };
    this.process = { tensor: null, canvas: null };
    this.faceTriangulation = triangulation;
    this.faceUVMap = uvmap;
    this.gl = config2;
    this.emit("create");
  }
  reset() {
    const currentBackend = this.config.backend;
    this.config = JSON.parse(JSON.stringify(config));
    this.config.backend = currentBackend;
  }
  validate(userConfig) {
    return validate(config, userConfig || this.config);
  }
  image(input2, getTensor2 = true) {
    return process2(input2, this.config, getTensor2);
  }
  async segmentation(input2, background) {
    return process5(input2, background, this.config);
  }
  enhance(input2) {
    return enhance(input2);
  }
  async init() {
    await check(this, true);
    await this.tf.ready();
    set(this.env);
  }
  async load(userConfig) {
    this.state = "load";
    const timeStamp = now2();
    const count3 = Object.values(this.models).filter((model142) => model142).length;
    if (userConfig)
      this.config = mergeDeep(this.config, userConfig);
    if (env2.initial) {
      if (this.config.debug)
        log(`version: ${this.version}`);
      if (this.config.debug)
        log(`tfjs version: ${this.tf.version_core}`);
      if (!await check(this))
        log("error: backend check failed");
      await ready();
      if (this.env.browser) {
        if (this.config.debug)
          log("configuration:", this.config);
        if (this.config.debug)
          log("tf flags:", this.tf.ENV.flags);
      }
    }
    await load14(this);
    if (env2.initial && this.config.debug)
      log("tf engine state:", this.tf.engine().state.numBytes, "bytes", this.tf.engine().state.numTensors, "tensors");
    env2.initial = false;
    const loaded = Object.values(this.models).filter((model142) => model142).length;
    if (loaded !== count3) {
      await validate2(this);
      this.emit("load");
    }
    const current = Math.trunc(now2() - timeStamp);
    if (current > (this.performance.load || 0))
      this.performance.load = current;
  }
  next(result = this.result) {
    return calc2(result, this.config);
  }
  async warmup(userConfig) {
    return warmup(this, userConfig);
  }
  async detect(input2, userConfig) {
    this.state = "detect";
    return new Promise(async (resolve) => {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2, _r, _s, _t, _u, _v;
      this.state = "config";
      let timeStamp;
      let elapsedTime;
      this.config = mergeDeep(this.config, userConfig);
      this.state = "check";
      const error = __privateGet(this, _sanity).call(this, input2);
      if (error) {
        log(error, input2);
        resolve({ error });
      }
      const timeStart = now2();
      await check(this);
      await this.load();
      timeStamp = now2();
      this.state = "image";
      const img = process2(input2, this.config);
      this.process = img;
      this.performance.image = Math.trunc(now2() - timeStamp);
      this.analyze("Get Image:");
      if (!img.tensor) {
        if (this.config.debug)
          log("could not convert input to tensor");
        resolve({ error: "could not convert input to tensor" });
        return;
      }
      this.emit("image");
      timeStamp = now2();
      this.config.skipFrame = await skip(this.config, img.tensor);
      if (!this.performance.frames)
        this.performance.frames = 0;
      if (!this.performance.cached)
        this.performance.cached = 0;
      this.performance.frames++;
      if (this.config.skipFrame)
        this.performance.cached++;
      this.performance.changed = Math.trunc(now2() - timeStamp);
      this.analyze("Check Changed:");
      let faceRes = [];
      let bodyRes = [];
      let handRes = [];
      let objectRes = [];
      this.state = "detect:face";
      if (this.config.async) {
        faceRes = this.config.face.enabled ? detectFace(this, img.tensor) : [];
        if (this.performance.face)
          delete this.performance.face;
      } else {
        timeStamp = now2();
        faceRes = this.config.face.enabled ? await detectFace(this, img.tensor) : [];
        elapsedTime = Math.trunc(now2() - timeStamp);
        if (elapsedTime > 0)
          this.performance.face = elapsedTime;
      }
      if (this.config.async && (this.config.body.maxDetected === -1 || this.config.hand.maxDetected === -1))
        faceRes = await faceRes;
      this.analyze("Start Body:");
      this.state = "detect:body";
      const bodyConfig = this.config.body.maxDetected === -1 ? mergeDeep(this.config, { body: { maxDetected: this.config.face.enabled ? 1 * faceRes.length : 1 } }) : this.config;
      if (this.config.async) {
        if ((_a = this.config.body.modelPath) == null ? void 0 : _a.includes("posenet"))
          bodyRes = this.config.body.enabled ? predict4(img.tensor, bodyConfig) : [];
        else if ((_b = this.config.body.modelPath) == null ? void 0 : _b.includes("blazepose"))
          bodyRes = this.config.body.enabled ? predict7(img.tensor, bodyConfig) : [];
        else if ((_c = this.config.body.modelPath) == null ? void 0 : _c.includes("efficientpose"))
          bodyRes = this.config.body.enabled ? predict8(img.tensor, bodyConfig) : [];
        else if ((_d = this.config.body.modelPath) == null ? void 0 : _d.includes("movenet"))
          bodyRes = this.config.body.enabled ? predict9(img.tensor, bodyConfig) : [];
        if (this.performance.body)
          delete this.performance.body;
      } else {
        timeStamp = now2();
        if ((_e2 = this.config.body.modelPath) == null ? void 0 : _e2.includes("posenet"))
          bodyRes = this.config.body.enabled ? await predict4(img.tensor, bodyConfig) : [];
        else if ((_f = this.config.body.modelPath) == null ? void 0 : _f.includes("blazepose"))
          bodyRes = this.config.body.enabled ? await predict7(img.tensor, bodyConfig) : [];
        else if ((_g = this.config.body.modelPath) == null ? void 0 : _g.includes("efficientpose"))
          bodyRes = this.config.body.enabled ? await predict8(img.tensor, bodyConfig) : [];
        else if ((_h = this.config.body.modelPath) == null ? void 0 : _h.includes("movenet"))
          bodyRes = this.config.body.enabled ? await predict9(img.tensor, bodyConfig) : [];
        elapsedTime = Math.trunc(now2() - timeStamp);
        if (elapsedTime > 0)
          this.performance.body = elapsedTime;
      }
      this.analyze("End Body:");
      this.analyze("Start Hand:");
      this.state = "detect:hand";
      const handConfig = this.config.hand.maxDetected === -1 ? mergeDeep(this.config, { hand: { maxDetected: this.config.face.enabled ? 2 * faceRes.length : 1 } }) : this.config;
      if (this.config.async) {
        if ((_j = (_i = this.config.hand.detector) == null ? void 0 : _i.modelPath) == null ? void 0 : _j.includes("handdetect"))
          handRes = this.config.hand.enabled ? predict5(img.tensor, handConfig) : [];
        else if ((_l = (_k = this.config.hand.detector) == null ? void 0 : _k.modelPath) == null ? void 0 : _l.includes("handtrack"))
          handRes = this.config.hand.enabled ? predict6(img.tensor, handConfig) : [];
        if (this.performance.hand)
          delete this.performance.hand;
      } else {
        timeStamp = now2();
        if ((_n = (_m = this.config.hand.detector) == null ? void 0 : _m.modelPath) == null ? void 0 : _n.includes("handdetect"))
          handRes = this.config.hand.enabled ? await predict5(img.tensor, handConfig) : [];
        else if ((_p = (_o = this.config.hand.detector) == null ? void 0 : _o.modelPath) == null ? void 0 : _p.includes("handtrack"))
          handRes = this.config.hand.enabled ? await predict6(img.tensor, handConfig) : [];
        elapsedTime = Math.trunc(now2() - timeStamp);
        if (elapsedTime > 0)
          this.performance.hand = elapsedTime;
      }
      this.analyze("End Hand:");
      this.analyze("Start Object:");
      this.state = "detect:object";
      if (this.config.async) {
        if ((_q2 = this.config.object.modelPath) == null ? void 0 : _q2.includes("nanodet"))
          objectRes = this.config.object.enabled ? predict10(img.tensor, this.config) : [];
        else if ((_r = this.config.object.modelPath) == null ? void 0 : _r.includes("centernet"))
          objectRes = this.config.object.enabled ? predict11(img.tensor, this.config) : [];
        if (this.performance.object)
          delete this.performance.object;
      } else {
        timeStamp = now2();
        if ((_s = this.config.object.modelPath) == null ? void 0 : _s.includes("nanodet"))
          objectRes = this.config.object.enabled ? await predict10(img.tensor, this.config) : [];
        else if ((_t = this.config.object.modelPath) == null ? void 0 : _t.includes("centernet"))
          objectRes = this.config.object.enabled ? await predict11(img.tensor, this.config) : [];
        elapsedTime = Math.trunc(now2() - timeStamp);
        if (elapsedTime > 0)
          this.performance.object = elapsedTime;
      }
      this.analyze("End Object:");
      this.state = "detect:await";
      if (this.config.async)
        [faceRes, bodyRes, handRes, objectRes] = await Promise.all([faceRes, bodyRes, handRes, objectRes]);
      this.state = "detect:gesture";
      let gestureRes = [];
      if (this.config.gesture.enabled) {
        timeStamp = now2();
        gestureRes = [...face2(faceRes), ...body2(bodyRes), ...hand2(handRes), ...iris3(faceRes)];
        if (!this.config.async)
          this.performance.gesture = Math.trunc(now2() - timeStamp);
        else if (this.performance.gesture)
          delete this.performance.gesture;
      }
      this.performance.total = Math.trunc(now2() - timeStart);
      const shape = ((_v = (_u = this.process) == null ? void 0 : _u.tensor) == null ? void 0 : _v.shape) || [];
      this.result = {
        face: faceRes,
        body: bodyRes,
        hand: handRes,
        gesture: gestureRes,
        object: objectRes,
        performance: this.performance,
        canvas: this.process.canvas,
        timestamp: Date.now(),
        get persons() {
          return join2(faceRes, bodyRes, handRes, gestureRes, shape);
        }
      };
      dispose(img.tensor);
      this.emit("detect");
      this.state = "idle";
      resolve(this.result);
    });
  }
};
_numTensors = new WeakMap();
_analyzeMemoryLeaks = new WeakMap();
_checkSanity = new WeakMap();
_sanity = new WeakMap();

// src/vrm-calculate.ts
var leanBody = 0;
var posLeftWrist;
var posRightWrist;
var angle = (pt1, pt2) => {
  if (!pt1 || !pt2 || pt1.length < 2 || pt2.length < 2)
    return 0;
  const radians = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
  return radians;
};
async function updateBody(vrm2, res2) {
  const body4 = res2 && res2.body ? res2.body[0] : null;
  if (!body4)
    return;
  const part = (what) => {
    const found = body4.keypoints.find((a6) => a6.part === what);
    const pos = found ? found.positionRaw : null;
    return pos;
  };
  const posLeftShoulder = part("leftShoulder");
  const posRightShoulder = part("rightShoulder");
  leanBody = angle(posRightShoulder, posLeftShoulder);
  if (posLeftShoulder && posRightShoulder)
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Chest).rotation.z = leanBody;
  const posRightElbow = part("rightElbow");
  if (posRightShoulder && posRightElbow)
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName.RightUpperArm).rotation.y = angle(posRightElbow, posRightShoulder);
  const posLeftElbow = part("leftElbow");
  if (posLeftShoulder && posLeftElbow)
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName.LeftUpperArm).rotation.y = angle(posLeftShoulder, posLeftElbow);
  posRightWrist = part("rightWrist");
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.RightLowerArm).rotation.y = posRightWrist && posRightElbow && posRightShoulder ? angle(posRightWrist, posRightElbow) - angle(posRightElbow, posRightShoulder) : 0;
  posLeftWrist = part("leftWrist");
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.LeftLowerArm).rotation.y = posLeftWrist && posLeftElbow ? angle(posLeftElbow, posLeftWrist) - angle(posLeftShoulder, posLeftElbow) : 0;
  const posRightHip = part("rightHip");
  const posRightKnee = part("rightKnee");
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.RightUpperLeg).rotation.z = posRightHip && posRightKnee ? angle(posRightHip, posRightKnee) - Math.PI / 2 : 0;
  const posLeftHip = part("leftHip");
  const posLeftKnee = part("leftKnee");
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.LeftUpperLeg).rotation.z = posLeftHip && posLeftKnee ? angle(posLeftHip, posLeftKnee) - Math.PI / 2 : 0;
}
async function updateHands(vrm2, res2) {
  const hands = res2 && res2.hand ? res2.hand : [];
  for (const hand3 of hands) {
    const distanceLeft = posLeftWrist ? Math.sqrt((hand3.boxRaw[0] - posLeftWrist[0]) ** 2) + (hand3.boxRaw[1] - posLeftWrist[1]) ** 2 : Number.MAX_VALUE;
    const distanceRight = posRightWrist ? Math.sqrt((hand3.boxRaw[0] - posRightWrist[0]) ** 2) + (hand3.boxRaw[1] - posRightWrist[1]) ** 2 : Number.MAX_VALUE;
    if (distanceLeft > 1 && distanceRight > 1)
      continue;
    const left = distanceLeft < distanceRight;
    const handSize = Math.sqrt((hand3.box[2] || 1) ** 2 + (hand3.box[3] || 1) ** 2) / Math.PI;
    const handRotation = (hand3.annotations.pinky[0][2] - hand3.annotations.thumb[0][2]) / handSize;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[left ? "LeftHand" : "RightHand"]).rotation.z = -handRotation * Math.PI / 2;
    const getCurl = (finger) => {
      let val2 = 0;
      if (hand3.landmarks[finger].curl === "half")
        val2 = Math.PI / 8;
      else if (hand3.landmarks[finger].curl === "full")
        val2 = Math.PI / 4;
      return val2;
    };
    let val;
    val = getCurl("index");
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}IndexIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}IndexProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}IndexDistal`]).rotation.z = val;
    val = getCurl("middle");
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleDistal`]).rotation.z = val;
    val = getCurl("ring");
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}RingIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}RingProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}RingDistal`]).rotation.z = val;
    val = getCurl("pinky");
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}LittleIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}LittleProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}LittleDistal`]).rotation.z = val;
    val = getCurl("thumb");
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbIntermediate`]).rotation.x = 2 * -val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbProximal`]).rotation.x = 2 * -val;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbDistal`]).rotation.x = 2 * -val;
    const q2 = angle(hand3.annotations.index[3], hand3.annotations.palm[0]) - Math.PI / 2;
    vrm2.humanoid.getBoneNode(h.HumanoidBoneName[`${left ? "Left" : "Right"}Hand`]).rotation.y = q2;
  }
}
async function updateFace(vrm2, res2) {
  var _a, _b, _c;
  const face4 = res2 && res2.face ? res2.face[0] : null;
  if (!face4)
    return;
  const faceAngle = ((_a = face4.rotation) == null ? void 0 : _a.angle) || { roll: 0, yaw: 0, pitch: 0 };
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Head).rotation.x = -faceAngle.pitch / 2;
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Head).rotation.y = -faceAngle.yaw / 2;
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Head).rotation.z = faceAngle.roll / 2 - leanBody;
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Neck).rotation.x = -faceAngle.pitch / 2;
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Neck).rotation.y = -faceAngle.yaw / 2;
  vrm2.humanoid.getBoneNode(h.HumanoidBoneName.Neck).rotation.z = (faceAngle.roll / 2 - leanBody) / 2;
  if (face4.mesh.length > 300) {
    const blinkL = 3 * (Math.abs(face4.mesh[374][1] - face4.mesh[386][1]) / Math.abs(face4.mesh[443][1] - face4.mesh[450][1]) - 0.15);
    const blinkR = 3 * (Math.abs(face4.mesh[145][1] - face4.mesh[159][1]) / Math.abs(face4.mesh[223][1] - face4.mesh[230][1]) - 0.15);
    vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.BlinkL, 1 - blinkL);
    vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.BlinkR, 1 - blinkR);
  }
  vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Fun, 0);
  vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Angry, 0);
  vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Sorrow, 0);
  vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Neutral, 0);
  const emotion = (_b = face4.emotion) == null ? void 0 : _b.reduce((prev, curr) => prev.score > curr.score ? prev : curr);
  switch ((emotion == null ? void 0 : emotion.emotion) || "") {
    case "happy":
      vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Fun, 1);
      break;
    case "angry":
      vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Angry, 1);
      break;
    case "sad":
      vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Sorrow, 1);
      break;
    default:
      vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.Neutral, 1);
  }
  if (face4.mesh.length > 300) {
    const mouth = Math.min(1, 5 * Math.abs(face4.mesh[13][1] - face4.mesh[14][1]) / Math.abs(face4.mesh[10][1] - face4.mesh[152][1]));
    vrm2.blendShapeProxy.setValue(h.BlendShapePresetName.O, mouth);
  }
  const gaze = (_c = face4.rotation) == null ? void 0 : _c.gaze;
  if (gaze) {
    const target = new Object3D();
    if (gaze)
      target.position.x = 10 * gaze.strength * Math.sin(gaze.bearing);
    if (gaze)
      target.position.y = 10 * gaze.strength * Math.cos(gaze.bearing);
    vrm2.lookAt.target = target;
  }
}
async function update(vrm2, res2) {
  if (!vrm2 || !vrm2.humanoid)
    return;
  await updateBody(vrm2, res2);
  await updateFace(vrm2, res2);
  await updateHands(vrm2, res2);
}

// src/human-vrm.ts
var model14 = "../assets/victoria-jeans.vrm";
var vrm;
var renderer;
var camera;
var scene;
var light;
var clock;
var stats;
var human;
var res;
var humanConfig = {
  modelBasePath: "https://vladmandic.github.io/human/models",
  face: {
    enabled: true,
    detector: { return: false, rotation: true },
    mesh: { enabled: true },
    iris: { enabled: true },
    description: { enabled: false },
    emotion: { enabled: true }
  },
  body: { enabled: true },
  hand: { enabled: true },
  object: { enabled: false },
  gesture: { enabled: false },
  segmentation: { enabled: false }
};
async function log3(...msg) {
  console.log(...msg);
  const div3 = document.getElementById("log");
  div3.innerText = msg.join(" ");
}
async function setupScene() {
  const canvas3 = document.getElementById("canvas");
  renderer = new WebGLRenderer({ antialias: true, alpha: true, canvas: canvas3 });
  renderer.setClearColor(0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  camera = new PerspectiveCamera(22, canvas3.width / canvas3.height, 0.1, 20);
  camera.position.set(0, 0.9, 15);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.screenSpacePanning = true;
  controls.target.set(0, 0.9, 0);
  controls.enabled = true;
  controls.update();
  scene = new Scene();
  light = new DirectionalLight(16777215);
  light.position.set(1, 1, 1).normalize();
  scene.add(light);
  const gridHelper = new GridHelper(100, 100);
  scene.add(gridHelper);
  const loader = new TextureLoader();
  loader.load("../assets/background.jpg", (texture) => scene.background = texture);
  clock = new Clock();
  stats = stats_module_default();
  document.body.appendChild(stats.dom);
  renderer.render(scene, camera);
}
async function loadVRM(f2) {
  const loader = new GLTFLoader();
  return new Promise((resolve, reject) => {
    loader.load(f2, (gltf) => {
      Le.removeUnnecessaryJoints(gltf.scene);
      ye.from(gltf).then((vrmInstance) => resolve(vrmInstance));
    }, () => {
    }, (error) => {
      log3("error:", error);
      reject(error);
    });
  });
}
async function initHuman() {
  human = new Human(humanConfig);
  log3(`human ${human.version}`);
  await human.load();
  await human.warmup();
}
async function animateFrame() {
  const deltaTime = clock.getDelta();
  const interpolated = human.next(res);
  const detected = document.getElementById("detected");
  const ctx = detected.getContext("2d");
  const video = document.getElementById("video");
  ctx == null ? void 0 : ctx.drawImage(video, 0, 0, 640, 480);
  human.draw.all(detected, interpolated);
  light.position.set(Math.sin(Math.PI * clock.elapsedTime), Math.cos(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime) + Math.cos(Math.PI * clock.elapsedTime)).normalize();
  await update(vrm, interpolated);
  vrm.update(deltaTime);
  renderer.render(scene, camera);
  stats.update();
  requestAnimationFrame(animateFrame);
}
async function detectionLoop() {
  const video = document.getElementById("video");
  res = await human.detect(video);
  if (!video.paused)
    requestAnimationFrame(detectionLoop);
}
async function initWebCam() {
  if (!navigator.mediaDevices)
    return;
  const video = document.getElementById("video");
  const constraints = { audio: false, video: { facingMode: "user", resizeMode: "none", width: { ideal: 640 } } };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  window.addEventListener("click", () => {
    if (video.paused) {
      video.play();
      detectionLoop();
    } else {
      video.pause();
    }
  });
  const videoReady = new Promise((resolve) => {
    video.onloadeddata = () => resolve(true);
  });
  video.srcObject = stream;
  await videoReady;
  video.play();
}
async function startupAnimation() {
  const wait = async (t2) => new Promise((resolve) => setTimeout(() => resolve(true), t2));
  if (!vrm.humanoid || !vrm.blendShapeProxy)
    return;
  while (clock.elapsedTime < Math.PI) {
    const deltaTime = clock.getDelta();
    vrm.humanoid.getBoneNode(h.HumanoidBoneName.Hips).rotation.y = clock.elapsedTime;
    vrm.humanoid.getBoneNode(h.HumanoidBoneName.LeftUpperArm).rotation.x = clock.elapsedTime / 2;
    vrm.humanoid.getBoneNode(h.HumanoidBoneName.RightUpperArm).rotation.x = clock.elapsedTime / 2;
    vrm.humanoid.getBoneNode(h.HumanoidBoneName.LeftUpperArm).rotation.y = clock.elapsedTime / 3;
    vrm.humanoid.getBoneNode(h.HumanoidBoneName.RightUpperArm).rotation.y = -clock.elapsedTime / 3;
    vrm.blendShapeProxy.setValue(h.BlendShapePresetName.Blink, Math.PI - clock.elapsedTime);
    light.position.set(Math.cos(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime) + Math.cos(Math.PI * clock.elapsedTime)).normalize();
    camera.position.set(0, 0.9, 10 * (1 - clock.elapsedTime / Math.PI) + 5);
    vrm.update(deltaTime);
    renderer.render(scene, camera);
    await wait(10);
  }
}
async function main() {
  await setupScene();
  vrm = await loadVRM(model14);
  log3("vrm model:", model14);
  scene.add(vrm.scene);
  if (!vrm.humanoid)
    return;
  renderer.render(scene, camera);
  await initHuman();
  await initWebCam();
  log3("vrm schema", h);
  log3("vrm scene:", vrm);
  log3("vrm pose:", vrm.humanoid.getPose());
  window["light"] = light;
  window["camera"] = camera;
  window["human"] = human;
  window["vrm"] = vrm;
  window["VRMSchema"] = h;
  await startupAnimation();
  animateFrame();
  detectionLoop();
  log3("");
}
window.onload = main;
/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=human-vrm.esm.js.map
