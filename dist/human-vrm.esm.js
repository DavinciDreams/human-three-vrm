/*
  Human-VRM
  homepage: <https://github.com/vladmandic/human-vrm>
  author: <https://github.com/vladmandic>'
*/

// node_modules/.pnpm/three@0.135.0/node_modules/three/build/three.module.js
var REVISION = "135";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
var EventDispatcher = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i10 = 0, l10 = array.length; i10 < l10; i10++) {
        array[i10].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = [];
for (let i10 = 0; i10 < 256; i10++) {
  _lut[i10] = (i10 < 16 ? "0" : "") + i10.toString(16);
}
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d02 = Math.random() * 4294967295 | 0;
  const d12 = Math.random() * 4294967295 | 0;
  const d22 = Math.random() * 4294967295 | 0;
  const d32 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d02 & 255] + _lut[d02 >> 8 & 255] + _lut[d02 >> 16 & 255] + _lut[d02 >> 24 & 255] + "-" + _lut[d12 & 255] + _lut[d12 >> 8 & 255] + "-" + _lut[d12 >> 16 & 15 | 64] + _lut[d12 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d32 & 255] + _lut[d32 >> 8 & 255] + _lut[d32 >> 16 & 255] + _lut[d32 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n10, m10) {
  return (n10 % m10 + m10) % m10;
}
function mapLinear(x10, a12, a22, b12, b22) {
  return b12 + (x10 - a12) * (b22 - b12) / (a22 - a12);
}
function inverseLerp(x10, y10, value) {
  if (x10 !== y10) {
    return (value - x10) / (y10 - x10);
  } else {
    return 0;
  }
}
function lerp(x10, y10, t) {
  return (1 - t) * x10 + t * y10;
}
function damp(x10, y10, lambda, dt2) {
  return lerp(x10, y10, 1 - Math.exp(-lambda * dt2));
}
function pingpong(x10, length = 1) {
  return length - Math.abs(euclideanModulo(x10, length * 2) - length);
}
function smoothstep(x10, min, max) {
  if (x10 <= min)
    return 0;
  if (x10 >= max)
    return 1;
  x10 = (x10 - min) / (max - min);
  return x10 * x10 * (3 - 2 * x10);
}
function smootherstep(x10, min, max) {
  if (x10 <= min)
    return 0;
  if (x10 >= max)
    return 1;
  x10 = (x10 - min) / (max - min);
  return x10 * x10 * x10 * (x10 * (x10 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s10) {
  if (s10 !== void 0)
    _seed = s10 % 2147483647;
  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q10, a10, b10, c10, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b10 / 2);
  const s22 = sin(b10 / 2);
  const c13 = cos((a10 + c10) / 2);
  const s13 = sin((a10 + c10) / 2);
  const c1_3 = cos((a10 - c10) / 2);
  const s1_3 = sin((a10 - c10) / 2);
  const c3_1 = cos((c10 - a10) / 2);
  const s3_1 = sin((c10 - a10) / 2);
  switch (order) {
    case "XYX":
      q10.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
      break;
    case "YZY":
      q10.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q10.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q10.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
      break;
    case "YXY":
      q10.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q10.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
var Vector2 = class {
  constructor(x10 = 0, y10 = 0) {
    this.x = x10;
    this.y = y10;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x10, y10) {
    this.x = x10;
    this.y = y10;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x10) {
    this.x = x10;
    return this;
  }
  setY(y10) {
    this.y = y10;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v10) {
    this.x = v10.x;
    this.y = v10.y;
    return this;
  }
  add(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v10, w10);
    }
    this.x += v10.x;
    this.y += v10.y;
    return this;
  }
  addScalar(s10) {
    this.x += s10;
    this.y += s10;
    return this;
  }
  addVectors(a10, b10) {
    this.x = a10.x + b10.x;
    this.y = a10.y + b10.y;
    return this;
  }
  addScaledVector(v10, s10) {
    this.x += v10.x * s10;
    this.y += v10.y * s10;
    return this;
  }
  sub(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v10, w10);
    }
    this.x -= v10.x;
    this.y -= v10.y;
    return this;
  }
  subScalar(s10) {
    this.x -= s10;
    this.y -= s10;
    return this;
  }
  subVectors(a10, b10) {
    this.x = a10.x - b10.x;
    this.y = a10.y - b10.y;
    return this;
  }
  multiply(v10) {
    this.x *= v10.x;
    this.y *= v10.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v10) {
    this.x /= v10.x;
    this.y /= v10.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m10) {
    const x10 = this.x, y10 = this.y;
    const e = m10.elements;
    this.x = e[0] * x10 + e[3] * y10 + e[6];
    this.y = e[1] * x10 + e[4] * y10 + e[7];
    return this;
  }
  min(v10) {
    this.x = Math.min(this.x, v10.x);
    this.y = Math.min(this.y, v10.y);
    return this;
  }
  max(v10) {
    this.x = Math.max(this.x, v10.x);
    this.y = Math.max(this.y, v10.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v10) {
    return this.x * v10.x + this.y * v10.y;
  }
  cross(v10) {
    return this.x * v10.y - this.y * v10.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle2 = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle2;
  }
  distanceTo(v10) {
    return Math.sqrt(this.distanceToSquared(v10));
  }
  distanceToSquared(v10) {
    const dx2 = this.x - v10.x, dy2 = this.y - v10.y;
    return dx2 * dx2 + dy2 * dy2;
  }
  manhattanDistanceTo(v10) {
    return Math.abs(this.x - v10.x) + Math.abs(this.y - v10.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v10, alpha2) {
    this.x += (v10.x - this.x) * alpha2;
    this.y += (v10.y - this.y) * alpha2;
    return this;
  }
  lerpVectors(v12, v22, alpha2) {
    this.x = v12.x + (v22.x - v12.x) * alpha2;
    this.y = v12.y + (v22.y - v12.y) * alpha2;
    return this;
  }
  equals(v10) {
    return v10.x === this.x && v10.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  }
  rotateAround(center, angle2) {
    const c10 = Math.cos(angle2), s10 = Math.sin(angle2);
    const x10 = this.x - center.x;
    const y10 = this.y - center.y;
    this.x = x10 * c10 - y10 * s10 + center.x;
    this.y = x10 * s10 + y10 * c10 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m10) {
    const te2 = this.elements;
    const me2 = m10.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m10) {
    const me2 = m10.elements;
    this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
    return this;
  }
  multiply(m10) {
    return this.multiplyMatrices(this, m10);
  }
  premultiply(m10) {
    return this.multiplyMatrices(m10, this);
  }
  multiplyMatrices(a10, b10) {
    const ae3 = a10.elements;
    const be = b10.elements;
    const te2 = this.elements;
    const a11 = ae3[0], a12 = ae3[3], a13 = ae3[6];
    const a21 = ae3[1], a22 = ae3[4], a23 = ae3[7];
    const a31 = ae3[2], a32 = ae3[5], a33 = ae3[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s10) {
    const te2 = this.elements;
    te2[0] *= s10;
    te2[3] *= s10;
    te2[6] *= s10;
    te2[1] *= s10;
    te2[4] *= s10;
    te2[7] *= s10;
    te2[2] *= s10;
    te2[5] *= s10;
    te2[8] *= s10;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a10 = te2[0], b10 = te2[1], c10 = te2[2], d10 = te2[3], e = te2[4], f10 = te2[5], g10 = te2[6], h10 = te2[7], i10 = te2[8];
    return a10 * e * i10 - a10 * f10 * h10 - b10 * d10 * i10 + b10 * f10 * g10 + c10 * d10 * h10 - c10 * e * g10;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m10 = this.elements;
    tmp2 = m10[1];
    m10[1] = m10[3];
    m10[3] = tmp2;
    tmp2 = m10[2];
    m10[2] = m10[6];
    m10[6] = tmp2;
    tmp2 = m10[5];
    m10[5] = m10[7];
    m10[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r10) {
    const m10 = this.elements;
    r10[0] = m10[0];
    r10[1] = m10[3];
    r10[2] = m10[6];
    r10[3] = m10[1];
    r10[4] = m10[4];
    r10[5] = m10[7];
    r10[6] = m10[2];
    r10[7] = m10[5];
    r10[8] = m10[8];
    return this;
  }
  setUvTransform(tx2, ty2, sx2, sy2, rotation, cx2, cy2) {
    const c10 = Math.cos(rotation);
    const s10 = Math.sin(rotation);
    this.set(sx2 * c10, sx2 * s10, -sx2 * (c10 * cx2 + s10 * cy2) + cx2 + tx2, -sy2 * s10, sy2 * c10, -sy2 * (-s10 * cx2 + c10 * cy2) + cy2 + ty2, 0, 0, 1);
    return this;
  }
  scale(sx2, sy2) {
    const te2 = this.elements;
    te2[0] *= sx2;
    te2[3] *= sx2;
    te2[6] *= sx2;
    te2[1] *= sy2;
    te2[4] *= sy2;
    te2[7] *= sy2;
    return this;
  }
  rotate(theta) {
    const c10 = Math.cos(theta);
    const s10 = Math.sin(theta);
    const te2 = this.elements;
    const a11 = te2[0], a12 = te2[3], a13 = te2[6];
    const a21 = te2[1], a22 = te2[4], a23 = te2[7];
    te2[0] = c10 * a11 + s10 * a21;
    te2[3] = c10 * a12 + s10 * a22;
    te2[6] = c10 * a13 + s10 * a23;
    te2[1] = -s10 * a11 + c10 * a21;
    te2[4] = -s10 * a12 + c10 * a22;
    te2[7] = -s10 * a13 + c10 * a23;
    return this;
  }
  translate(tx2, ty2) {
    const te2 = this.elements;
    te2[0] += tx2 * te2[2];
    te2[3] += tx2 * te2[5];
    te2[6] += tx2 * te2[8];
    te2[1] += ty2 * te2[2];
    te2[4] += ty2 * te2[5];
    te2[7] += ty2 * te2[8];
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i10 = 0; i10 < 9; i10++) {
      if (te2[i10] !== me2[i10])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.elements[i10] = array[i10 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i10 = 1, l10 = array.length; i10 < l10; ++i10) {
    if (array[i10] > max)
      max = array[i10];
  }
  return max;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function hashString(str, seed = 0) {
  let h12 = 3735928559 ^ seed, h22 = 1103547991 ^ seed;
  for (let i10 = 0, ch; i10 < str.length; i10++) {
    ch = str.charCodeAt(i10);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h22 = Math.imul(h22 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h22 ^ h22 >>> 13, 3266489909);
  h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h22) + (h12 >>> 0);
}
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas3;
    if (image instanceof HTMLCanvasElement) {
      canvas3 = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas3 = _canvas;
    }
    if (canvas3.width > 2048 || canvas3.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas3.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas3.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i10 = 0, l10 = image.length; i10 < l10; i10++) {
            if (image[i10].isDataTexture) {
              url.push(serializeImage(image[i10].image));
            } else {
              url.push(serializeImage(image[i10]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv2) {
    if (this.mapping !== UVMapping)
      return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x10 = 0, y10 = 0, z10 = 0, w10 = 1) {
    this.x = x10;
    this.y = y10;
    this.z = z10;
    this.w = w10;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x10, y10, z10, w10) {
    this.x = x10;
    this.y = y10;
    this.z = z10;
    this.w = w10;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x10) {
    this.x = x10;
    return this;
  }
  setY(y10) {
    this.y = y10;
    return this;
  }
  setZ(z10) {
    this.z = z10;
    return this;
  }
  setW(w10) {
    this.w = w10;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v10) {
    this.x = v10.x;
    this.y = v10.y;
    this.z = v10.z;
    this.w = v10.w !== void 0 ? v10.w : 1;
    return this;
  }
  add(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v10, w10);
    }
    this.x += v10.x;
    this.y += v10.y;
    this.z += v10.z;
    this.w += v10.w;
    return this;
  }
  addScalar(s10) {
    this.x += s10;
    this.y += s10;
    this.z += s10;
    this.w += s10;
    return this;
  }
  addVectors(a10, b10) {
    this.x = a10.x + b10.x;
    this.y = a10.y + b10.y;
    this.z = a10.z + b10.z;
    this.w = a10.w + b10.w;
    return this;
  }
  addScaledVector(v10, s10) {
    this.x += v10.x * s10;
    this.y += v10.y * s10;
    this.z += v10.z * s10;
    this.w += v10.w * s10;
    return this;
  }
  sub(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v10, w10);
    }
    this.x -= v10.x;
    this.y -= v10.y;
    this.z -= v10.z;
    this.w -= v10.w;
    return this;
  }
  subScalar(s10) {
    this.x -= s10;
    this.y -= s10;
    this.z -= s10;
    this.w -= s10;
    return this;
  }
  subVectors(a10, b10) {
    this.x = a10.x - b10.x;
    this.y = a10.y - b10.y;
    this.z = a10.z - b10.z;
    this.w = a10.w - b10.w;
    return this;
  }
  multiply(v10) {
    this.x *= v10.x;
    this.y *= v10.y;
    this.z *= v10.z;
    this.w *= v10.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m10) {
    const x10 = this.x, y10 = this.y, z10 = this.z, w10 = this.w;
    const e = m10.elements;
    this.x = e[0] * x10 + e[4] * y10 + e[8] * z10 + e[12] * w10;
    this.y = e[1] * x10 + e[5] * y10 + e[9] * z10 + e[13] * w10;
    this.z = e[2] * x10 + e[6] * y10 + e[10] * z10 + e[14] * w10;
    this.w = e[3] * x10 + e[7] * y10 + e[11] * z10 + e[15] * w10;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q10) {
    this.w = 2 * Math.acos(q10.w);
    const s10 = Math.sqrt(1 - q10.w * q10.w);
    if (s10 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q10.x / s10;
      this.y = q10.y / s10;
      this.z = q10.z / s10;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m10) {
    let angle2, x10, y10, z10;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m10.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle2 = Math.PI;
      const xx2 = (m11 + 1) / 2;
      const yy2 = (m22 + 1) / 2;
      const zz2 = (m33 + 1) / 2;
      const xy2 = (m12 + m21) / 4;
      const xz2 = (m13 + m31) / 4;
      const yz2 = (m23 + m32) / 4;
      if (xx2 > yy2 && xx2 > zz2) {
        if (xx2 < epsilon) {
          x10 = 0;
          y10 = 0.707106781;
          z10 = 0.707106781;
        } else {
          x10 = Math.sqrt(xx2);
          y10 = xy2 / x10;
          z10 = xz2 / x10;
        }
      } else if (yy2 > zz2) {
        if (yy2 < epsilon) {
          x10 = 0.707106781;
          y10 = 0;
          z10 = 0.707106781;
        } else {
          y10 = Math.sqrt(yy2);
          x10 = xy2 / y10;
          z10 = yz2 / y10;
        }
      } else {
        if (zz2 < epsilon) {
          x10 = 0.707106781;
          y10 = 0.707106781;
          z10 = 0;
        } else {
          z10 = Math.sqrt(zz2);
          x10 = xz2 / z10;
          y10 = yz2 / z10;
        }
      }
      this.set(x10, y10, z10, angle2);
      return this;
    }
    let s10 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s10) < 1e-3)
      s10 = 1;
    this.x = (m32 - m23) / s10;
    this.y = (m13 - m31) / s10;
    this.z = (m21 - m12) / s10;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v10) {
    this.x = Math.min(this.x, v10.x);
    this.y = Math.min(this.y, v10.y);
    this.z = Math.min(this.z, v10.z);
    this.w = Math.min(this.w, v10.w);
    return this;
  }
  max(v10) {
    this.x = Math.max(this.x, v10.x);
    this.y = Math.max(this.y, v10.y);
    this.z = Math.max(this.z, v10.z);
    this.w = Math.max(this.w, v10.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v10) {
    return this.x * v10.x + this.y * v10.y + this.z * v10.z + this.w * v10.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v10, alpha2) {
    this.x += (v10.x - this.x) * alpha2;
    this.y += (v10.y - this.y) * alpha2;
    this.z += (v10.z - this.z) * alpha2;
    this.w += (v10.w - this.w) * alpha2;
    return this;
  }
  lerpVectors(v12, v22, alpha2) {
    this.x = v12.x + (v22.x - v12.x) * alpha2;
    this.y = v12.y + (v22.y - v12.y) * alpha2;
    this.z = v12.z + (v22.z - v12.z) * alpha2;
    this.w = v12.w + (v22.w - v12.w) * alpha2;
    return this;
  }
  equals(v10) {
    return v10.x === this.x && v10.y === this.y && v10.z === this.z && v10.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    this.w = attribute.getW(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options4 = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    this.texture = new Texture(void 0, options4.mapping, options4.wrapS, options4.wrapT, options4.magFilter, options4.minFilter, options4.format, options4.type, options4.anisotropy, options4.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.image = { width, height, depth: 1 };
    this.texture.generateMipmaps = options4.generateMipmaps !== void 0 ? options4.generateMipmaps : false;
    this.texture.internalFormat = options4.internalFormat !== void 0 ? options4.internalFormat : null;
    this.texture.minFilter = options4.minFilter !== void 0 ? options4.minFilter : LinearFilter;
    this.depthBuffer = options4.depthBuffer !== void 0 ? options4.depthBuffer : true;
    this.stencilBuffer = options4.stencilBuffer !== void 0 ? options4.stencilBuffer : false;
    this.depthTexture = options4.depthTexture !== void 0 ? options4.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = { ...this.texture.image };
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
  constructor(width, height, count2) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];
    for (let i10 = 0; i10 < count2; i10++) {
      this.texture[i10] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i10 = 0, il2 = this.texture.length; i10 < il2; i10++) {
        this.texture[i10].image.width = width;
        this.texture[i10].image.height = height;
        this.texture[i10].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;
    for (let i10 = 0, il2 = source.texture.length; i10 < il2; i10++) {
      this.texture[i10] = source.texture[i10].clone();
    }
    return this;
  }
};
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options4 = {}) {
    super(width, height, options4);
    this.samples = 4;
    this.ignoreDepthForMultisampleCopy = options4.ignoreDepth !== void 0 ? options4.ignoreDepth : true;
    this.useRenderToTexture = options4.useRenderToTexture !== void 0 ? options4.useRenderToTexture : false;
    this.useRenderbuffer = this.useRenderToTexture === false;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    this.useRenderToTexture = source.useRenderToTexture;
    this.useRenderbuffer = source.useRenderbuffer;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x10 = 0, y10 = 0, z10 = 0, w10 = 1) {
    this._x = x10;
    this._y = y10;
    this._z = z10;
    this._w = w10;
  }
  static slerp(qa2, qb2, qm2, t) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm2.slerpQuaternions(qa2, qb2, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x02 = src0[srcOffset0 + 0], y02 = src0[srcOffset0 + 1], z02 = src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];
    const x12 = src1[srcOffset1 + 0], y12 = src1[srcOffset1 + 1], z12 = src1[srcOffset1 + 2], w12 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x02;
      dst[dstOffset + 1] = y02;
      dst[dstOffset + 2] = z02;
      dst[dstOffset + 3] = w02;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x12;
      dst[dstOffset + 1] = y12;
      dst[dstOffset + 2] = z12;
      dst[dstOffset + 3] = w12;
      return;
    }
    if (w02 !== w12 || x02 !== x12 || y02 !== y12 || z02 !== z12) {
      let s10 = 1 - t;
      const cos = x02 * x12 + y02 * y12 + z02 * z12 + w02 * w12, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s10 = Math.sin(s10 * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x02 = x02 * s10 + x12 * tDir;
      y02 = y02 * s10 + y12 * tDir;
      z02 = z02 * s10 + z12 * tDir;
      w02 = w02 * s10 + w12 * tDir;
      if (s10 === 1 - t) {
        const f10 = 1 / Math.sqrt(x02 * x02 + y02 * y02 + z02 * z02 + w02 * w02);
        x02 *= f10;
        y02 *= f10;
        z02 *= f10;
        w02 *= f10;
      }
    }
    dst[dstOffset] = x02;
    dst[dstOffset + 1] = y02;
    dst[dstOffset + 2] = z02;
    dst[dstOffset + 3] = w02;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x02 = src0[srcOffset0];
    const y02 = src0[srcOffset0 + 1];
    const z02 = src0[srcOffset0 + 2];
    const w02 = src0[srcOffset0 + 3];
    const x12 = src1[srcOffset1];
    const y12 = src1[srcOffset1 + 1];
    const z12 = src1[srcOffset1 + 2];
    const w12 = src1[srcOffset1 + 3];
    dst[dstOffset] = x02 * w12 + w02 * x12 + y02 * z12 - z02 * y12;
    dst[dstOffset + 1] = y02 * w12 + w02 * y12 + z02 * x12 - x02 * z12;
    dst[dstOffset + 2] = z02 * w12 + w02 * z12 + x02 * y12 - y02 * x12;
    dst[dstOffset + 3] = w02 * w12 - x02 * x12 - y02 * y12 - z02 * z12;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x10, y10, z10, w10) {
    this._x = x10;
    this._y = y10;
    this._z = z10;
    this._w = w10;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update2) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x10 = euler._x, y10 = euler._y, z10 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c12 = cos(x10 / 2);
    const c22 = cos(y10 / 2);
    const c32 = cos(z10 / 2);
    const s12 = sin(x10 / 2);
    const s22 = sin(y10 / 2);
    const s32 = sin(z10 / 2);
    switch (order) {
      case "XYZ":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "YXZ":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      case "ZXY":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "ZYX":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      case "YZX":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "XZY":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update2 !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle2) {
    const halfAngle = angle2 / 2, s10 = Math.sin(halfAngle);
    this._x = axis.x * s10;
    this._y = axis.y * s10;
    this._z = axis.z * s10;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m10) {
    const te2 = m10.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s10 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s10;
      this._x = (m32 - m23) * s10;
      this._y = (m13 - m31) * s10;
      this._z = (m21 - m12) * s10;
    } else if (m11 > m22 && m11 > m33) {
      const s10 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s10;
      this._x = 0.25 * s10;
      this._y = (m12 + m21) / s10;
      this._z = (m13 + m31) / s10;
    } else if (m22 > m33) {
      const s10 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s10;
      this._x = (m12 + m21) / s10;
      this._y = 0.25 * s10;
      this._z = (m23 + m32) / s10;
    } else {
      const s10 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s10;
      this._x = (m13 + m31) / s10;
      this._y = (m23 + m32) / s10;
      this._z = 0.25 * s10;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r10 = vFrom.dot(vTo) + 1;
    if (r10 < Number.EPSILON) {
      r10 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r10;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r10;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r10;
    }
    return this.normalize();
  }
  angleTo(q10) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q10), -1, 1)));
  }
  rotateTowards(q10, step) {
    const angle2 = this.angleTo(q10);
    if (angle2 === 0)
      return this;
    const t = Math.min(1, step / angle2);
    this.slerp(q10, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v10) {
    return this._x * v10._x + this._y * v10._y + this._z * v10._z + this._w * v10._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l10 = this.length();
    if (l10 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l10 = 1 / l10;
      this._x = this._x * l10;
      this._y = this._y * l10;
      this._z = this._z * l10;
      this._w = this._w * l10;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q10, p10) {
    if (p10 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q10, p10);
    }
    return this.multiplyQuaternions(this, q10);
  }
  premultiply(q10) {
    return this.multiplyQuaternions(q10, this);
  }
  multiplyQuaternions(a10, b10) {
    const qax = a10._x, qay = a10._y, qaz = a10._z, qaw = a10._w;
    const qbx = b10._x, qby = b10._y, qbz = b10._z, qbw = b10._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb2, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb2);
    const x10 = this._x, y10 = this._y, z10 = this._z, w10 = this._w;
    let cosHalfTheta = w10 * qb2._w + x10 * qb2._x + y10 * qb2._y + z10 * qb2._z;
    if (cosHalfTheta < 0) {
      this._w = -qb2._w;
      this._x = -qb2._x;
      this._y = -qb2._y;
      this._z = -qb2._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb2);
    }
    if (cosHalfTheta >= 1) {
      this._w = w10;
      this._x = x10;
      this._y = y10;
      this._z = z10;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s10 = 1 - t;
      this._w = s10 * w10 + t * this._w;
      this._x = s10 * x10 + t * this._x;
      this._y = s10 * y10 + t * this._y;
      this._z = s10 * z10 + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w10 * ratioA + this._w * ratioB;
    this._x = x10 * ratioA + this._x * ratioB;
    this._y = y10 * ratioA + this._y * ratioB;
    this._z = z10 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa2, qb2, t) {
    this.copy(qa2).slerp(qb2, t);
  }
  random() {
    const u12 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u12);
    const sqrtu1 = Math.sqrt(u12);
    const u22 = 2 * Math.PI * Math.random();
    const u32 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u22), sqrtu1 * Math.sin(u32), sqrtu1 * Math.cos(u32), sqrt1u1 * Math.sin(u22));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this._x = attribute.getX(index2);
    this._y = attribute.getY(index2);
    this._z = attribute.getZ(index2);
    this._w = attribute.getW(index2);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x10 = 0, y10 = 0, z10 = 0) {
    this.x = x10;
    this.y = y10;
    this.z = z10;
  }
  set(x10, y10, z10) {
    if (z10 === void 0)
      z10 = this.z;
    this.x = x10;
    this.y = y10;
    this.z = z10;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x10) {
    this.x = x10;
    return this;
  }
  setY(y10) {
    this.y = y10;
    return this;
  }
  setZ(z10) {
    this.z = z10;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v10) {
    this.x = v10.x;
    this.y = v10.y;
    this.z = v10.z;
    return this;
  }
  add(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v10, w10);
    }
    this.x += v10.x;
    this.y += v10.y;
    this.z += v10.z;
    return this;
  }
  addScalar(s10) {
    this.x += s10;
    this.y += s10;
    this.z += s10;
    return this;
  }
  addVectors(a10, b10) {
    this.x = a10.x + b10.x;
    this.y = a10.y + b10.y;
    this.z = a10.z + b10.z;
    return this;
  }
  addScaledVector(v10, s10) {
    this.x += v10.x * s10;
    this.y += v10.y * s10;
    this.z += v10.z * s10;
    return this;
  }
  sub(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v10, w10);
    }
    this.x -= v10.x;
    this.y -= v10.y;
    this.z -= v10.z;
    return this;
  }
  subScalar(s10) {
    this.x -= s10;
    this.y -= s10;
    this.z -= s10;
    return this;
  }
  subVectors(a10, b10) {
    this.x = a10.x - b10.x;
    this.y = a10.y - b10.y;
    this.z = a10.z - b10.z;
    return this;
  }
  multiply(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v10, w10);
    }
    this.x *= v10.x;
    this.y *= v10.y;
    this.z *= v10.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a10, b10) {
    this.x = a10.x * b10.x;
    this.y = a10.y * b10.y;
    this.z = a10.z * b10.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle2) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle2));
  }
  applyMatrix3(m10) {
    const x10 = this.x, y10 = this.y, z10 = this.z;
    const e = m10.elements;
    this.x = e[0] * x10 + e[3] * y10 + e[6] * z10;
    this.y = e[1] * x10 + e[4] * y10 + e[7] * z10;
    this.z = e[2] * x10 + e[5] * y10 + e[8] * z10;
    return this;
  }
  applyNormalMatrix(m10) {
    return this.applyMatrix3(m10).normalize();
  }
  applyMatrix4(m10) {
    const x10 = this.x, y10 = this.y, z10 = this.z;
    const e = m10.elements;
    const w10 = 1 / (e[3] * x10 + e[7] * y10 + e[11] * z10 + e[15]);
    this.x = (e[0] * x10 + e[4] * y10 + e[8] * z10 + e[12]) * w10;
    this.y = (e[1] * x10 + e[5] * y10 + e[9] * z10 + e[13]) * w10;
    this.z = (e[2] * x10 + e[6] * y10 + e[10] * z10 + e[14]) * w10;
    return this;
  }
  applyQuaternion(q10) {
    const x10 = this.x, y10 = this.y, z10 = this.z;
    const qx2 = q10.x, qy2 = q10.y, qz2 = q10.z, qw2 = q10.w;
    const ix2 = qw2 * x10 + qy2 * z10 - qz2 * y10;
    const iy2 = qw2 * y10 + qz2 * x10 - qx2 * z10;
    const iz2 = qw2 * z10 + qx2 * y10 - qy2 * x10;
    const iw2 = -qx2 * x10 - qy2 * y10 - qz2 * z10;
    this.x = ix2 * qw2 + iw2 * -qx2 + iy2 * -qz2 - iz2 * -qy2;
    this.y = iy2 * qw2 + iw2 * -qy2 + iz2 * -qx2 - ix2 * -qz2;
    this.z = iz2 * qw2 + iw2 * -qz2 + ix2 * -qy2 - iy2 * -qx2;
    return this;
  }
  project(camera2) {
    return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
  }
  unproject(camera2) {
    return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
  }
  transformDirection(m10) {
    const x10 = this.x, y10 = this.y, z10 = this.z;
    const e = m10.elements;
    this.x = e[0] * x10 + e[4] * y10 + e[8] * z10;
    this.y = e[1] * x10 + e[5] * y10 + e[9] * z10;
    this.z = e[2] * x10 + e[6] * y10 + e[10] * z10;
    return this.normalize();
  }
  divide(v10) {
    this.x /= v10.x;
    this.y /= v10.y;
    this.z /= v10.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v10) {
    this.x = Math.min(this.x, v10.x);
    this.y = Math.min(this.y, v10.y);
    this.z = Math.min(this.z, v10.z);
    return this;
  }
  max(v10) {
    this.x = Math.max(this.x, v10.x);
    this.y = Math.max(this.y, v10.y);
    this.z = Math.max(this.z, v10.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v10) {
    return this.x * v10.x + this.y * v10.y + this.z * v10.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v10, alpha2) {
    this.x += (v10.x - this.x) * alpha2;
    this.y += (v10.y - this.y) * alpha2;
    this.z += (v10.z - this.z) * alpha2;
    return this;
  }
  lerpVectors(v12, v22, alpha2) {
    this.x = v12.x + (v22.x - v12.x) * alpha2;
    this.y = v12.y + (v22.y - v12.y) * alpha2;
    this.z = v12.z + (v22.z - v12.z) * alpha2;
    return this;
  }
  cross(v10, w10) {
    if (w10 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v10, w10);
    }
    return this.crossVectors(this, v10);
  }
  crossVectors(a10, b10) {
    const ax2 = a10.x, ay2 = a10.y, az2 = a10.z;
    const bx2 = b10.x, by2 = b10.y, bz2 = b10.z;
    this.x = ay2 * bz2 - az2 * by2;
    this.y = az2 * bx2 - ax2 * bz2;
    this.z = ax2 * by2 - ay2 * bx2;
    return this;
  }
  projectOnVector(v10) {
    const denominator = v10.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v10.dot(this) / denominator;
    return this.copy(v10).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v10) {
    const denominator = Math.sqrt(this.lengthSq() * v10.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v10) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v10) {
    return Math.sqrt(this.distanceToSquared(v10));
  }
  distanceToSquared(v10) {
    const dx2 = this.x - v10.x, dy2 = this.y - v10.y, dz2 = this.z - v10.z;
    return dx2 * dx2 + dy2 * dy2 + dz2 * dz2;
  }
  manhattanDistanceTo(v10) {
    return Math.abs(this.x - v10.x) + Math.abs(this.y - v10.y) + Math.abs(this.z - v10.z);
  }
  setFromSpherical(s10) {
    return this.setFromSphericalCoords(s10.radius, s10.phi, s10.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c10) {
    return this.setFromCylindricalCoords(c10.radius, c10.theta, c10.y);
  }
  setFromCylindricalCoords(radius, theta, y10) {
    this.x = radius * Math.sin(theta);
    this.y = y10;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m10) {
    const e = m10.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m10) {
    const sx2 = this.setFromMatrixColumn(m10, 0).length();
    const sy2 = this.setFromMatrixColumn(m10, 1).length();
    const sz2 = this.setFromMatrixColumn(m10, 2).length();
    this.x = sx2;
    this.y = sy2;
    this.z = sz2;
    return this;
  }
  setFromMatrixColumn(m10, index2) {
    return this.fromArray(m10.elements, index2 * 4);
  }
  setFromMatrix3Column(m10, index2) {
    return this.fromArray(m10.elements, index2 * 3);
  }
  equals(v10) {
    return v10.x === this.x && v10.y === this.y && v10.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u10 = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f10 = Math.sqrt(1 - u10 ** 2);
    this.x = f10 * Math.cos(t);
    this.y = f10 * Math.sin(t);
    this.z = u10;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
Vector3.prototype.isVector3 = true;
var _vector$c = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i10 = 0, l10 = array.length; i10 < l10; i10 += 3) {
      const x10 = array[i10];
      const y10 = array[i10 + 1];
      const z10 = array[i10 + 2];
      if (x10 < minX)
        minX = x10;
      if (y10 < minY)
        minY = y10;
      if (z10 < minZ)
        minZ = z10;
      if (x10 > maxX)
        maxX = x10;
      if (y10 > maxY)
        maxY = y10;
      if (z10 > maxZ)
        maxZ = z10;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i10 = 0, l10 = attribute.count; i10 < l10; i10++) {
      const x10 = attribute.getX(i10);
      const y10 = attribute.getY(i10);
      const z10 = attribute.getZ(i10);
      if (x10 < minX)
        minX = x10;
      if (y10 < minY)
        minY = y10;
      if (z10 < minZ)
        minZ = z10;
      if (x10 > maxX)
        maxX = x10;
      if (y10 > maxY)
        maxY = y10;
      if (z10 > maxZ)
        maxZ = z10;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i10 = 0, il2 = points.length; i10 < il2; i10++) {
      this.expandByPoint(points[i10]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$b.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object2) {
    this.makeEmpty();
    return this.expandByObject(object2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object2) {
    object2.updateWorldMatrix(false, false);
    const geometry = object2.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object2.matrixWorld);
      this.union(_box$3);
    }
    const children = object2.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      this.expandByObject(children[i10]);
    }
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y || point2.z < this.min.z || point2.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point2, target) {
    return target.set((point2.x - this.min.x) / (this.max.x - this.min.x), (point2.y - this.min.y) / (this.max.y - this.min.y), (point2.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    const clampedPoint = _vector$b.copy(point2).clamp(this.min, this.max);
    return clampedPoint.sub(point2).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$b = /* @__PURE__ */ new Vector3();
var _box$3 = /* @__PURE__ */ new Box3();
var _v0$2 = /* @__PURE__ */ new Vector3();
var _v1$7 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v02, v12, v22, extents) {
  for (let i10 = 0, j10 = axes.length - 3; i10 <= j10; i10 += 3) {
    _testAxis.fromArray(axes, i10);
    const r10 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p02 = v02.dot(_testAxis);
    const p12 = v12.dot(_testAxis);
    const p22 = v22.dot(_testAxis);
    if (Math.max(-Math.max(p02, p12, p22), Math.min(p02, p12, p22)) > r10) {
      return false;
    }
  }
  return true;
}
var _box$2 = /* @__PURE__ */ new Box3();
var _v1$6 = /* @__PURE__ */ new Vector3();
var _toFarthestPoint = /* @__PURE__ */ new Vector3();
var _toPoint = /* @__PURE__ */ new Vector3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i10 = 0, il2 = points.length; i10 < il2; i10++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i10]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point2) {
    return point2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point2) {
    return point2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point2, target) {
    const deltaLengthSq = this.center.distanceToSquared(point2);
    target.copy(point2);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point2) {
    _toPoint.subVectors(point2, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal$1 = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v10) {
    this.direction.copy(v10).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point2, target) {
    target.subVectors(point2, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point2) {
    return Math.sqrt(this.distanceSqToPoint(point2));
  }
  distanceSqToPoint(point2) {
    const directionDistance = _vector$a.subVectors(point2, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point2);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point2);
  }
  distanceSqToSegment(v02, v12, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v02).add(v12).multiplyScalar(0.5);
    _segDir.copy(v12).sub(v02).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v02.distanceTo(v12) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b02 = _diff.dot(this.direction);
    const b12 = -_diff.dot(_segDir);
    const c10 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s02, s12, sqrDist, extDet;
    if (det > 0) {
      s02 = a01 * b12 - b02;
      s12 = a01 * b02 - b12;
      extDet = segExtent * det;
      if (s02 >= 0) {
        if (s12 >= -extDet) {
          if (s12 <= extDet) {
            const invDet = 1 / det;
            s02 *= invDet;
            s12 *= invDet;
            sqrDist = s02 * (s02 + a01 * s12 + 2 * b02) + s12 * (a01 * s02 + s12 + 2 * b12) + c10;
          } else {
            s12 = segExtent;
            s02 = Math.max(0, -(a01 * s12 + b02));
            sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c10;
          }
        } else {
          s12 = -segExtent;
          s02 = Math.max(0, -(a01 * s12 + b02));
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c10;
        }
      } else {
        if (s12 <= -extDet) {
          s02 = Math.max(0, -(-a01 * segExtent + b02));
          s12 = s02 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c10;
        } else if (s12 <= extDet) {
          s02 = 0;
          s12 = Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = s12 * (s12 + 2 * b12) + c10;
        } else {
          s02 = Math.max(0, -(a01 * segExtent + b02));
          s12 = s02 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c10;
        }
      }
    } else {
      s12 = a01 > 0 ? -segExtent : segExtent;
      s02 = Math.max(0, -(a01 * s12 + b02));
      sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c10;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s02).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s12).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d22 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d22 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d22);
    const t02 = tca - thc;
    const t12 = tca + thc;
    if (t02 < 0 && t12 < 0)
      return null;
    if (t02 < 0)
      return this.at(t12, target);
    return this.at(t02, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a10, b10, c10, backfaceCulling, target) {
    _edge1.subVectors(b10, a10);
    _edge2.subVectors(c10, a10);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a10);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m10) {
    const te2 = this.elements;
    const me2 = m10.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m10) {
    const te2 = this.elements, me2 = m10.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m10) {
    const me2 = m10.elements;
    this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m10) {
    const te2 = this.elements;
    const me2 = m10.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m10, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m10, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m10, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te2 = this.elements;
    const x10 = euler.x, y10 = euler.y, z10 = euler.z;
    const a10 = Math.cos(x10), b10 = Math.sin(x10);
    const c10 = Math.cos(y10), d10 = Math.sin(y10);
    const e = Math.cos(z10), f10 = Math.sin(z10);
    if (euler.order === "XYZ") {
      const ae3 = a10 * e, af = a10 * f10, be = b10 * e, bf = b10 * f10;
      te2[0] = c10 * e;
      te2[4] = -c10 * f10;
      te2[8] = d10;
      te2[1] = af + be * d10;
      te2[5] = ae3 - bf * d10;
      te2[9] = -b10 * c10;
      te2[2] = bf - ae3 * d10;
      te2[6] = be + af * d10;
      te2[10] = a10 * c10;
    } else if (euler.order === "YXZ") {
      const ce3 = c10 * e, cf = c10 * f10, de2 = d10 * e, df = d10 * f10;
      te2[0] = ce3 + df * b10;
      te2[4] = de2 * b10 - cf;
      te2[8] = a10 * d10;
      te2[1] = a10 * f10;
      te2[5] = a10 * e;
      te2[9] = -b10;
      te2[2] = cf * b10 - de2;
      te2[6] = df + ce3 * b10;
      te2[10] = a10 * c10;
    } else if (euler.order === "ZXY") {
      const ce3 = c10 * e, cf = c10 * f10, de2 = d10 * e, df = d10 * f10;
      te2[0] = ce3 - df * b10;
      te2[4] = -a10 * f10;
      te2[8] = de2 + cf * b10;
      te2[1] = cf + de2 * b10;
      te2[5] = a10 * e;
      te2[9] = df - ce3 * b10;
      te2[2] = -a10 * d10;
      te2[6] = b10;
      te2[10] = a10 * c10;
    } else if (euler.order === "ZYX") {
      const ae3 = a10 * e, af = a10 * f10, be = b10 * e, bf = b10 * f10;
      te2[0] = c10 * e;
      te2[4] = be * d10 - af;
      te2[8] = ae3 * d10 + bf;
      te2[1] = c10 * f10;
      te2[5] = bf * d10 + ae3;
      te2[9] = af * d10 - be;
      te2[2] = -d10;
      te2[6] = b10 * c10;
      te2[10] = a10 * c10;
    } else if (euler.order === "YZX") {
      const ac = a10 * c10, ad2 = a10 * d10, bc = b10 * c10, bd2 = b10 * d10;
      te2[0] = c10 * e;
      te2[4] = bd2 - ac * f10;
      te2[8] = bc * f10 + ad2;
      te2[1] = f10;
      te2[5] = a10 * e;
      te2[9] = -b10 * e;
      te2[2] = -d10 * e;
      te2[6] = ad2 * f10 + bc;
      te2[10] = ac - bd2 * f10;
    } else if (euler.order === "XZY") {
      const ac = a10 * c10, ad2 = a10 * d10, bc = b10 * c10, bd2 = b10 * d10;
      te2[0] = c10 * e;
      te2[4] = -f10;
      te2[8] = d10 * e;
      te2[1] = ac * f10 + bd2;
      te2[5] = a10 * e;
      te2[9] = ad2 * f10 - bc;
      te2[2] = bc * f10 - ad2;
      te2[6] = b10 * e;
      te2[10] = bd2 * f10 + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q10) {
    return this.compose(_zero, q10, _one);
  }
  lookAt(eye, target, up2) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up2, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up2.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up2, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m10, n10) {
    if (n10 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m10, n10);
    }
    return this.multiplyMatrices(this, m10);
  }
  premultiply(m10) {
    return this.multiplyMatrices(m10, this);
  }
  multiplyMatrices(a10, b10) {
    const ae3 = a10.elements;
    const be = b10.elements;
    const te2 = this.elements;
    const a11 = ae3[0], a12 = ae3[4], a13 = ae3[8], a14 = ae3[12];
    const a21 = ae3[1], a22 = ae3[5], a23 = ae3[9], a24 = ae3[13];
    const a31 = ae3[2], a32 = ae3[6], a33 = ae3[10], a34 = ae3[14];
    const a41 = ae3[3], a42 = ae3[7], a43 = ae3[11], a44 = ae3[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s10) {
    const te2 = this.elements;
    te2[0] *= s10;
    te2[4] *= s10;
    te2[8] *= s10;
    te2[12] *= s10;
    te2[1] *= s10;
    te2[5] *= s10;
    te2[9] *= s10;
    te2[13] *= s10;
    te2[2] *= s10;
    te2[6] *= s10;
    te2[10] *= s10;
    te2[14] *= s10;
    te2[3] *= s10;
    te2[7] *= s10;
    te2[11] *= s10;
    te2[15] *= s10;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp2;
    tmp2 = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp2;
    tmp2 = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp2;
    tmp2 = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp2;
    tmp2 = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp2;
    tmp2 = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp2;
    tmp2 = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp2;
    return this;
  }
  setPosition(x10, y10, z10) {
    const te2 = this.elements;
    if (x10.isVector3) {
      te2[12] = x10.x;
      te2[13] = x10.y;
      te2[14] = x10.z;
    } else {
      te2[12] = x10;
      te2[13] = y10;
      te2[14] = z10;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v10) {
    const te2 = this.elements;
    const x10 = v10.x, y10 = v10.y, z10 = v10.z;
    te2[0] *= x10;
    te2[4] *= y10;
    te2[8] *= z10;
    te2[1] *= x10;
    te2[5] *= y10;
    te2[9] *= z10;
    te2[2] *= x10;
    te2[6] *= y10;
    te2[10] *= z10;
    te2[3] *= x10;
    te2[7] *= y10;
    te2[11] *= z10;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x10, y10, z10) {
    this.set(1, 0, 0, x10, 0, 1, 0, y10, 0, 0, 1, z10, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c10 = Math.cos(theta), s10 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c10, -s10, 0, 0, s10, c10, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c10 = Math.cos(theta), s10 = Math.sin(theta);
    this.set(c10, 0, s10, 0, 0, 1, 0, 0, -s10, 0, c10, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c10 = Math.cos(theta), s10 = Math.sin(theta);
    this.set(c10, -s10, 0, 0, s10, c10, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle2) {
    const c10 = Math.cos(angle2);
    const s10 = Math.sin(angle2);
    const t = 1 - c10;
    const x10 = axis.x, y10 = axis.y, z10 = axis.z;
    const tx2 = t * x10, ty2 = t * y10;
    this.set(tx2 * x10 + c10, tx2 * y10 - s10 * z10, tx2 * z10 + s10 * y10, 0, tx2 * y10 + s10 * z10, ty2 * y10 + c10, ty2 * z10 - s10 * x10, 0, tx2 * z10 - s10 * y10, ty2 * z10 + s10 * x10, t * z10 * z10 + c10, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x10, y10, z10) {
    this.set(x10, 0, 0, 0, 0, y10, 0, 0, 0, 0, z10, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy2, xz2, yx2, yz2, zx2, zy2) {
    this.set(1, yx2, zx2, 0, xy2, 1, zy2, 0, xz2, yz2, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale2) {
    const te2 = this.elements;
    const x10 = quaternion._x, y10 = quaternion._y, z10 = quaternion._z, w10 = quaternion._w;
    const x22 = x10 + x10, y22 = y10 + y10, z22 = z10 + z10;
    const xx2 = x10 * x22, xy2 = x10 * y22, xz2 = x10 * z22;
    const yy2 = y10 * y22, yz2 = y10 * z22, zz2 = z10 * z22;
    const wx2 = w10 * x22, wy2 = w10 * y22, wz2 = w10 * z22;
    const sx2 = scale2.x, sy2 = scale2.y, sz2 = scale2.z;
    te2[0] = (1 - (yy2 + zz2)) * sx2;
    te2[1] = (xy2 + wz2) * sx2;
    te2[2] = (xz2 - wy2) * sx2;
    te2[3] = 0;
    te2[4] = (xy2 - wz2) * sy2;
    te2[5] = (1 - (xx2 + zz2)) * sy2;
    te2[6] = (yz2 + wx2) * sy2;
    te2[7] = 0;
    te2[8] = (xz2 + wy2) * sz2;
    te2[9] = (yz2 - wx2) * sz2;
    te2[10] = (1 - (xx2 + yy2)) * sz2;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale2) {
    const te2 = this.elements;
    let sx2 = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy2 = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz2 = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx2 = -sx2;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1$2.copy(this);
    const invSX = 1 / sx2;
    const invSY = 1 / sy2;
    const invSZ = 1 / sz2;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale2.x = sx2;
    scale2.y = sy2;
    scale2.z = sz2;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te2 = this.elements;
    const x10 = 2 * near / (right - left);
    const y10 = 2 * near / (top - bottom);
    const a10 = (right + left) / (right - left);
    const b10 = (top + bottom) / (top - bottom);
    const c10 = -(far + near) / (far - near);
    const d10 = -2 * far * near / (far - near);
    te2[0] = x10;
    te2[4] = 0;
    te2[8] = a10;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y10;
    te2[9] = b10;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c10;
    te2[14] = d10;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te2 = this.elements;
    const w10 = 1 / (right - left);
    const h10 = 1 / (top - bottom);
    const p10 = 1 / (far - near);
    const x10 = (right + left) * w10;
    const y10 = (top + bottom) * h10;
    const z10 = (far + near) * p10;
    te2[0] = 2 * w10;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x10;
    te2[1] = 0;
    te2[5] = 2 * h10;
    te2[9] = 0;
    te2[13] = -y10;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = -2 * p10;
    te2[14] = -z10;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i10 = 0; i10 < 16; i10++) {
      if (te2[i10] !== me2[i10])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i10 = 0; i10 < 16; i10++) {
      this.elements[i10] = array[i10 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
};
Matrix4.prototype.isMatrix4 = true;
var _v1$5 = /* @__PURE__ */ new Vector3();
var _m1$2 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix$1 = /* @__PURE__ */ new Matrix4();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x10 = 0, y10 = 0, z10 = 0, order = Euler.DefaultOrder) {
    this._x = x10;
    this._y = y10;
    this._z = z10;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x10, y10, z10, order = this._order) {
    this._x = x10;
    this._y = y10;
    this._z = z10;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m10, order = this._order, update2 = true) {
    const te2 = m10.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update2 === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q10, order, update2) {
    _matrix$1.makeRotationFromQuaternion(q10);
    return this.setFromRotationMatrix(_matrix$1, order, update2);
  }
  setFromVector3(v10, order = this._order) {
    return this.set(v10.x, v10.y, v10.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = /* @__PURE__ */ new Vector3();
var _q1 = /* @__PURE__ */ new Quaternion();
var _m1$1 = /* @__PURE__ */ new Matrix4();
var _target = /* @__PURE__ */ new Vector3();
var _position$3 = /* @__PURE__ */ new Vector3();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _quaternion$2 = /* @__PURE__ */ new Quaternion();
var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale2 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale2
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q10) {
    this.quaternion.premultiply(q10);
    return this;
  }
  setRotationFromAxisAngle(axis, angle2) {
    this.quaternion.setFromAxisAngle(axis, angle2);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m10) {
    this.quaternion.setFromRotationMatrix(m10);
  }
  setRotationFromQuaternion(q10) {
    this.quaternion.copy(q10);
  }
  rotateOnAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle2) {
    return this.rotateOnAxis(_xAxis, angle2);
  }
  rotateY(angle2) {
    return this.rotateOnAxis(_yAxis, angle2);
  }
  rotateZ(angle2) {
    return this.rotateOnAxis(_zAxis, angle2);
  }
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x10, y10, z10) {
    if (x10.isVector3) {
      _target.copy(x10);
    } else {
      _target.set(x10, y10, z10);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object2) {
    if (arguments.length > 1) {
      for (let i10 = 0; i10 < arguments.length; i10++) {
        this.add(arguments[i10]);
      }
      return this;
    }
    if (object2 === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object2);
      return this;
    }
    if (object2 && object2.isObject3D) {
      if (object2.parent !== null) {
        object2.parent.remove(object2);
      }
      object2.parent = this;
      this.children.push(object2);
      object2.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object2);
    }
    return this;
  }
  remove(object2) {
    if (arguments.length > 1) {
      for (let i10 = 0; i10 < arguments.length; i10++) {
        this.remove(arguments[i10]);
      }
      return this;
    }
    const index2 = this.children.indexOf(object2);
    if (index2 !== -1) {
      object2.parent = null;
      this.children.splice(index2, 1);
      object2.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i10 = 0; i10 < this.children.length; i10++) {
      const object2 = this.children[i10];
      object2.parent = null;
      object2.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object2) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object2.parent !== null) {
      object2.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object2.parent.matrixWorld);
    }
    object2.applyMatrix4(_m1$1);
    this.add(object2);
    object2.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i10 = 0, l10 = this.children.length; i10 < l10; i10++) {
      const child = this.children[i10];
      const object2 = child.getObjectByProperty(name, value);
      if (object2 !== void 0) {
        return object2;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      children[i10].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      children[i10].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      children[i10].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
        children[i10].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object2 = {};
    object2.uuid = this.uuid;
    object2.type = this.type;
    if (this.name !== "")
      object2.name = this.name;
    if (this.castShadow === true)
      object2.castShadow = true;
    if (this.receiveShadow === true)
      object2.receiveShadow = true;
    if (this.visible === false)
      object2.visible = false;
    if (this.frustumCulled === false)
      object2.frustumCulled = false;
    if (this.renderOrder !== 0)
      object2.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object2.userData = this.userData;
    object2.layers = this.layers.mask;
    object2.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object2.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object2.type = "InstancedMesh";
      object2.count = this.count;
      object2.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object2.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object2.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object2.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object2.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object2.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i10 = 0, l10 = shapes.length; i10 < l10; i10++) {
            const shape = shapes[i10];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object2.bindMode = this.bindMode;
      object2.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object2.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i10 = 0, l10 = this.material.length; i10 < l10; i10++) {
          uuids.push(serialize(meta.materials, this.material[i10]));
        }
        object2.material = uuids;
      } else {
        object2.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object2.children = [];
      for (let i10 = 0; i10 < this.children.length; i10++) {
        object2.children.push(this.children[i10].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object2.animations = [];
      for (let i10 = 0; i10 < this.animations.length; i10++) {
        const animation = this.animations[i10];
        object2.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object2;
    return output;
    function extractFromCache(cache7) {
      const values = [];
      for (const key in cache7) {
        const data = cache7[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i10 = 0; i10 < source.children.length; i10++) {
        const child = source.children[i10];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var _v3$1 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a10 = new Vector3(), b10 = new Vector3(), c10 = new Vector3()) {
    this.a = a10;
    this.b = b10;
    this.c = c10;
  }
  static getNormal(a10, b10, c10, target) {
    target.subVectors(c10, b10);
    _v0$1.subVectors(a10, b10);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point2, a10, b10, c10, target) {
    _v0$1.subVectors(c10, a10);
    _v1$3.subVectors(b10, a10);
    _v2$2.subVectors(point2, a10);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u10 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v10 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u10 - v10, v10, u10);
  }
  static containsPoint(point2, a10, b10, c10) {
    this.getBarycoord(point2, a10, b10, c10, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point2, p12, p22, p32, uv1, uv2, uv3, target) {
    this.getBarycoord(point2, p12, p22, p32, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a10, b10, c10, direction) {
    _v0$1.subVectors(c10, b10);
    _v1$3.subVectors(a10, b10);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a10, b10, c10) {
    this.a.copy(a10);
    this.b.copy(b10);
    this.c.copy(c10);
    return this;
  }
  setFromPointsAndIndices(points, i02, i12, i22) {
    this.a.copy(points[i02]);
    this.b.copy(points[i12]);
    this.c.copy(points[i22]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i02, i12, i22) {
    this.a.fromBufferAttribute(attribute, i02);
    this.b.fromBufferAttribute(attribute, i12);
    this.c.fromBufferAttribute(attribute, i22);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point2, target) {
    return Triangle.getBarycoord(point2, this.a, this.b, this.c, target);
  }
  getUV(point2, uv1, uv2, uv3, target) {
    return Triangle.getUV(point2, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point2) {
    return Triangle.containsPoint(point2, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p10, target) {
    const a10 = this.a, b10 = this.b, c10 = this.c;
    let v10, w10;
    _vab.subVectors(b10, a10);
    _vac.subVectors(c10, a10);
    _vap.subVectors(p10, a10);
    const d12 = _vab.dot(_vap);
    const d22 = _vac.dot(_vap);
    if (d12 <= 0 && d22 <= 0) {
      return target.copy(a10);
    }
    _vbp.subVectors(p10, b10);
    const d32 = _vab.dot(_vbp);
    const d42 = _vac.dot(_vbp);
    if (d32 >= 0 && d42 <= d32) {
      return target.copy(b10);
    }
    const vc = d12 * d42 - d32 * d22;
    if (vc <= 0 && d12 >= 0 && d32 <= 0) {
      v10 = d12 / (d12 - d32);
      return target.copy(a10).addScaledVector(_vab, v10);
    }
    _vcp.subVectors(p10, c10);
    const d52 = _vab.dot(_vcp);
    const d62 = _vac.dot(_vcp);
    if (d62 >= 0 && d52 <= d62) {
      return target.copy(c10);
    }
    const vb2 = d52 * d22 - d12 * d62;
    if (vb2 <= 0 && d22 >= 0 && d62 <= 0) {
      w10 = d22 / (d22 - d62);
      return target.copy(a10).addScaledVector(_vac, w10);
    }
    const va2 = d32 * d62 - d52 * d42;
    if (va2 <= 0 && d42 - d32 >= 0 && d52 - d62 >= 0) {
      _vbc.subVectors(c10, b10);
      w10 = (d42 - d32) / (d42 - d32 + (d52 - d62));
      return target.copy(b10).addScaledVector(_vbc, w10);
    }
    const denom = 1 / (va2 + vb2 + vc);
    v10 = vb2 * denom;
    w10 = vc * denom;
    return target.copy(a10).addScaledVector(_vab, v10).addScaledVector(_vac, w10);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.format = RGBAFormat;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.format !== RGBAFormat)
      data.format = this.format;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache7) {
      const values = [];
      for (const key in cache7) {
        const data2 = cache7[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.format = source.format;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n10 = srcPlanes.length;
      dstPlanes = new Array(n10);
      for (let i10 = 0; i10 !== n10; ++i10) {
        dstPlanes[i10] = srcPlanes[i10].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Material.prototype.isMaterial = true;
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p10, q10, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p10 + (q10 - p10) * 6 * t;
  if (t < 1 / 2)
    return q10;
  if (t < 2 / 3)
    return p10 + (q10 - p10) * 6 * (2 / 3 - t);
  return p10;
}
function SRGBToLinear(c10) {
  return c10 < 0.04045 ? c10 * 0.0773993808 : Math.pow(c10 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c10) {
  return c10 < 31308e-7 ? c10 * 12.92 : 1.055 * Math.pow(c10, 0.41666) - 0.055;
}
var Color = class {
  constructor(r10, g10, b10) {
    if (g10 === void 0 && b10 === void 0) {
      return this.set(r10);
    }
    return this.setRGB(r10, g10, b10);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r10, g10, b10) {
    this.r = r10;
    this.g = g10;
    this.b = b10;
    return this;
  }
  setHSL(h10, s10, l10) {
    h10 = euclideanModulo(h10, 1);
    s10 = clamp(s10, 0, 1);
    l10 = clamp(l10, 0, 1);
    if (s10 === 0) {
      this.r = this.g = this.b = l10;
    } else {
      const p10 = l10 <= 0.5 ? l10 * (1 + s10) : l10 + s10 - l10 * s10;
      const q10 = 2 * l10 - p10;
      this.r = hue2rgb(q10, p10, h10 + 1 / 3);
      this.g = hue2rgb(q10, p10, h10);
      this.b = hue2rgb(q10, p10, h10 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m10;
    if (m10 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m10[1];
      const components = m10[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h10 = parseFloat(color[1]) / 360;
            const s10 = parseInt(color[2], 10) / 100;
            const l10 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h10, s10, l10);
          }
          break;
      }
    } else if (m10 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m10[1];
      const size2 = hex.length;
      if (size2 === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size2 === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r10 = this.r, g10 = this.g, b10 = this.b;
    const max = Math.max(r10, g10, b10);
    const min = Math.min(r10, g10, b10);
    let hue2, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue2 = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r10:
          hue2 = (g10 - b10) / delta + (g10 < b10 ? 6 : 0);
          break;
        case g10:
          hue2 = (b10 - r10) / delta + 2;
          break;
        case b10:
          hue2 = (r10 - g10) / delta + 4;
          break;
      }
      hue2 /= 6;
    }
    target.h = hue2;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h10, s10, l10) {
    this.getHSL(_hslA);
    _hslA.h += h10;
    _hslA.s += s10;
    _hslA.l += l10;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s10) {
    this.r += s10;
    this.g += s10;
    this.b += s10;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s10) {
    this.r *= s10;
    this.g *= s10;
    this.b *= s10;
    return this;
  }
  lerp(color, alpha2) {
    this.r += (color.r - this.r) * alpha2;
    this.g += (color.g - this.g) * alpha2;
    this.b += (color.b - this.b) * alpha2;
    return this;
  }
  lerpColors(color1, color2, alpha2) {
    this.r = color1.r + (color2.r - color1.r) * alpha2;
    this.g = color1.g + (color2.g - color1.g) * alpha2;
    this.b = color1.b + (color2.b - color1.b) * alpha2;
    return this;
  }
  lerpHSL(color, alpha2) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h10 = lerp(_hslA.h, _hslB.h, alpha2);
    const s10 = lerp(_hslA.s, _hslB.s, alpha2);
    const l10 = lerp(_hslA.l, _hslB.l, alpha2);
    this.setHSL(h10, s10, l10);
    return this;
  }
  equals(c10) {
    return c10.r === this.r && c10.g === this.g && c10.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.r = attribute.getX(index2);
    this.g = attribute.getY(index2);
    this.b = attribute.getZ(index2);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$9 = /* @__PURE__ */ new Vector3();
var _vector2$1 = /* @__PURE__ */ new Vector2();
var BufferAttribute = class {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i10 = 0, l10 = this.itemSize; i10 < l10; i10++) {
      this.array[index1 + i10] = attribute.array[index2 + i10];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors) {
    const array = this.array;
    let offset = 0;
    for (let i10 = 0, l10 = colors.length; i10 < l10; i10++) {
      let color = colors[i10];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i10);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i10 = 0, l10 = vectors.length; i10 < l10; i10++) {
      let vector = vectors[i10];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i10);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i10 = 0, l10 = vectors.length; i10 < l10; i10++) {
      let vector = vectors[i10];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i10);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i10 = 0, l10 = vectors.length; i10 < l10; i10++) {
      let vector = vectors[i10];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i10);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m10) {
    if (this.itemSize === 2) {
      for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
        _vector2$1.fromBufferAttribute(this, i10);
        _vector2$1.applyMatrix3(m10);
        this.setXY(i10, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
        _vector$9.fromBufferAttribute(this, i10);
        _vector$9.applyMatrix3(m10);
        this.setXYZ(i10, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m10) {
    for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
      _vector$9.x = this.getX(i10);
      _vector$9.y = this.getY(i10);
      _vector$9.z = this.getZ(i10);
      _vector$9.applyMatrix4(m10);
      this.setXYZ(i10, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m10) {
    for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
      _vector$9.x = this.getX(i10);
      _vector$9.y = this.getY(i10);
      _vector$9.z = this.getZ(i10);
      _vector$9.applyNormalMatrix(m10);
      this.setXYZ(i10, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m10) {
    for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
      _vector$9.x = this.getX(i10);
      _vector$9.y = this.getY(i10);
      _vector$9.z = this.getZ(i10);
      _vector$9.transformDirection(m10);
      this.setXYZ(i10, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index2) {
    return this.array[index2 * this.itemSize];
  }
  setX(index2, x10) {
    this.array[index2 * this.itemSize] = x10;
    return this;
  }
  getY(index2) {
    return this.array[index2 * this.itemSize + 1];
  }
  setY(index2, y10) {
    this.array[index2 * this.itemSize + 1] = y10;
    return this;
  }
  getZ(index2) {
    return this.array[index2 * this.itemSize + 2];
  }
  setZ(index2, z10) {
    this.array[index2 * this.itemSize + 2] = z10;
    return this;
  }
  getW(index2) {
    return this.array[index2 * this.itemSize + 3];
  }
  setW(index2, w10) {
    this.array[index2 * this.itemSize + 3] = w10;
    return this;
  }
  setXY(index2, x10, y10) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x10;
    this.array[index2 + 1] = y10;
    return this;
  }
  setXYZ(index2, x10, y10, z10) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x10;
    this.array[index2 + 1] = y10;
    this.array[index2 + 2] = z10;
    return this;
  }
  setXYZW(index2, x10, y10, z10, w10) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x10;
    this.array[index2 + 1] = y10;
    this.array[index2 + 2] = z10;
    this.array[index2 + 3] = w10;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
};
BufferAttribute.prototype.isBufferAttribute = true;
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
};
var Float16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
};
var _id = 0;
var _m1 = /* @__PURE__ */ new Matrix4();
var _obj = /* @__PURE__ */ new Object3D();
var _offset = /* @__PURE__ */ new Vector3();
var _box$1 = /* @__PURE__ */ new Box3();
var _boxMorphTargets = /* @__PURE__ */ new Box3();
var _vector$8 = /* @__PURE__ */ new Vector3();
var BufferGeometry = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index2) {
    if (Array.isArray(index2)) {
      this.index = new (arrayMax(index2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
    } else {
      this.index = index2;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count2, materialIndex = 0) {
    this.groups.push({
      start,
      count: count2,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count2) {
    this.drawRange.start = start;
    this.drawRange.count = count2;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q10) {
    _m1.makeRotationFromQuaternion(q10);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle2) {
    _m1.makeRotationX(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle2) {
    _m1.makeRotationY(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle2) {
    _m1.makeRotationZ(angle2);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x10, y10, z10) {
    _m1.makeTranslation(x10, y10, z10);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x10, y10, z10) {
    _m1.makeScale(x10, y10, z10);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i10 = 0, l10 = points.length; i10 < l10; i10++) {
      const point2 = points[i10];
      position.push(point2.x, point2.y, point2.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i10 = 0, il2 = morphAttributesPosition.length; i10 < il2; i10++) {
          const morphAttribute = morphAttributesPosition[i10];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i10 = 0, il2 = morphAttributesPosition.length; i10 < il2; i10++) {
          const morphAttribute = morphAttributesPosition[i10];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i10 = 0, il2 = position.count; i10 < il2; i10++) {
        _vector$8.fromBufferAttribute(position, i10);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i10 = 0, il2 = morphAttributesPosition.length; i10 < il2; i10++) {
          const morphAttribute = morphAttributesPosition[i10];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j10 = 0, jl2 = morphAttribute.count; j10 < jl2; j10++) {
            _vector$8.fromBufferAttribute(morphAttribute, j10);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j10);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index2 = this.index;
    const attributes = this.attributes;
    if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index2.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i10 = 0; i10 < nVertices; i10++) {
      tan1[i10] = new Vector3();
      tan2[i10] = new Vector3();
    }
    const vA2 = new Vector3(), vB2 = new Vector3(), vC2 = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a10, b10, c10) {
      vA2.fromArray(positions, a10 * 3);
      vB2.fromArray(positions, b10 * 3);
      vC2.fromArray(positions, c10 * 3);
      uvA.fromArray(uvs, a10 * 2);
      uvB.fromArray(uvs, b10 * 2);
      uvC.fromArray(uvs, c10 * 2);
      vB2.sub(vA2);
      vC2.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r10 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r10))
        return;
      sdir.copy(vB2).multiplyScalar(uvC.y).addScaledVector(vC2, -uvB.y).multiplyScalar(r10);
      tdir.copy(vC2).multiplyScalar(uvB.x).addScaledVector(vB2, -uvC.x).multiplyScalar(r10);
      tan1[a10].add(sdir);
      tan1[b10].add(sdir);
      tan1[c10].add(sdir);
      tan2[a10].add(tdir);
      tan2[b10].add(tdir);
      tan2[c10].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i10 = 0, il2 = groups.length; i10 < il2; ++i10) {
      const group = groups[i10];
      const start = group.start;
      const count2 = group.count;
      for (let j10 = start, jl2 = start + count2; j10 < jl2; j10 += 3) {
        handleTriangle(indices[j10 + 0], indices[j10 + 1], indices[j10 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n10 = new Vector3(), n22 = new Vector3();
    function handleVertex(v10) {
      n10.fromArray(normals, v10 * 3);
      n22.copy(n10);
      const t = tan1[v10];
      tmp2.copy(t);
      tmp2.sub(n10.multiplyScalar(n10.dot(t))).normalize();
      tmp22.crossVectors(n22, t);
      const test = tmp22.dot(tan2[v10]);
      const w10 = test < 0 ? -1 : 1;
      tangents[v10 * 4] = tmp2.x;
      tangents[v10 * 4 + 1] = tmp2.y;
      tangents[v10 * 4 + 2] = tmp2.z;
      tangents[v10 * 4 + 3] = w10;
    }
    for (let i10 = 0, il2 = groups.length; i10 < il2; ++i10) {
      const group = groups[i10];
      const start = group.start;
      const count2 = group.count;
      for (let j10 = start, jl2 = start + count2; j10 < jl2; j10 += 3) {
        handleVertex(indices[j10 + 0]);
        handleVertex(indices[j10 + 1]);
        handleVertex(indices[j10 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index2 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i10 = 0, il2 = normalAttribute.count; i10 < il2; i10++) {
          normalAttribute.setXYZ(i10, 0, 0, 0);
        }
      }
      const pA2 = new Vector3(), pB2 = new Vector3(), pC2 = new Vector3();
      const nA2 = new Vector3(), nB2 = new Vector3(), nC2 = new Vector3();
      const cb2 = new Vector3(), ab2 = new Vector3();
      if (index2) {
        for (let i10 = 0, il2 = index2.count; i10 < il2; i10 += 3) {
          const vA2 = index2.getX(i10 + 0);
          const vB2 = index2.getX(i10 + 1);
          const vC2 = index2.getX(i10 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB2.fromBufferAttribute(positionAttribute, vB2);
          pC2.fromBufferAttribute(positionAttribute, vC2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB2.fromBufferAttribute(normalAttribute, vB2);
          nC2.fromBufferAttribute(normalAttribute, vC2);
          nA2.add(cb2);
          nB2.add(cb2);
          nC2.add(cb2);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB2, nB2.x, nB2.y, nB2.z);
          normalAttribute.setXYZ(vC2, nC2.x, nC2.y, nC2.z);
        }
      } else {
        for (let i10 = 0, il2 = positionAttribute.count; i10 < il2; i10 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i10 + 0);
          pB2.fromBufferAttribute(positionAttribute, i10 + 1);
          pC2.fromBufferAttribute(positionAttribute, i10 + 2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          normalAttribute.setXYZ(i10 + 0, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i10 + 1, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i10 + 2, cb2.x, cb2.y, cb2.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i10 = 0, j10 = attributeOffset; i10 < length; i10++, j10++) {
        attributeArray1[j10] = attributeArray2[i10];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i10 = 0, il2 = normals.count; i10 < il2; i10++) {
      _vector$8.fromBufferAttribute(normals, i10);
      _vector$8.normalize();
      normals.setXYZ(i10, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index2 = 0, index22 = 0;
      for (let i10 = 0, l10 = indices2.length; i10 < l10; i10++) {
        if (attribute.isInterleavedBufferAttribute) {
          index2 = indices2[i10] * attribute.data.stride + attribute.offset;
        } else {
          index2 = indices2[i10] * itemSize;
        }
        for (let j10 = 0; j10 < itemSize; j10++) {
          array2[index22++] = array[index2++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i10 = 0, il2 = morphAttribute.length; i10 < il2; i10++) {
        const attribute = morphAttribute[i10];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i10 = 0, l10 = groups.length; i10 < l10; i10++) {
      const group = groups[i10];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index2 = this.index;
    if (index2 !== null) {
      data.data.index = {
        type: index2.array.constructor.name,
        array: Array.prototype.slice.call(index2.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i10 = 0, il2 = attributeArray.length; i10 < il2; i10++) {
        const attribute = attributeArray[i10];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index2 = source.index;
    if (index2 !== null) {
      this.setIndex(index2.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i10 = 0, l10 = morphAttribute.length; i10 < l10; i10++) {
        array.push(morphAttribute[i10].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i10 = 0, l10 = groups.length; i10 < l10; i10++) {
      const group = groups[i10];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
BufferGeometry.prototype.isBufferGeometry = true;
var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
var _ray$2 = /* @__PURE__ */ new Ray();
var _sphere$3 = /* @__PURE__ */ new Sphere();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _tempA = /* @__PURE__ */ new Vector3();
var _tempB = /* @__PURE__ */ new Vector3();
var _tempC = /* @__PURE__ */ new Vector3();
var _morphA = /* @__PURE__ */ new Vector3();
var _morphB = /* @__PURE__ */ new Vector3();
var _morphC = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var _intersectionPoint = /* @__PURE__ */ new Vector3();
var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
var Mesh = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m10 = 0, ml2 = morphAttribute.length; m10 < ml2; m10++) {
            const name = morphAttribute[m10].name || String(m10);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m10;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv2 = geometry.attributes.uv;
      const uv22 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index2 !== null) {
        if (Array.isArray(material)) {
          for (let i10 = 0, il2 = groups.length; i10 < il2; i10++) {
            const group = groups[i10];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j10 = start, jl2 = end; j10 < jl2; j10 += 3) {
              const a10 = index2.getX(j10);
              const b10 = index2.getX(j10 + 1);
              const c10 = index2.getX(j10 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a10, b10, c10);
              if (intersection) {
                intersection.faceIndex = Math.floor(j10 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index2.count, drawRange.start + drawRange.count);
          for (let i10 = start, il2 = end; i10 < il2; i10 += 3) {
            const a10 = index2.getX(i10);
            const b10 = index2.getX(i10 + 1);
            const c10 = index2.getX(i10 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a10, b10, c10);
            if (intersection) {
              intersection.faceIndex = Math.floor(i10 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i10 = 0, il2 = groups.length; i10 < il2; i10++) {
            const group = groups[i10];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j10 = start, jl2 = end; j10 < jl2; j10 += 3) {
              const a10 = j10;
              const b10 = j10 + 1;
              const c10 = j10 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a10, b10, c10);
              if (intersection) {
                intersection.faceIndex = Math.floor(j10 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i10 = start, il2 = end; i10 < il2; i10 += 3) {
            const a10 = i10;
            const b10 = i10 + 1;
            const c10 = i10 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a10, b10, c10);
            if (intersection) {
              intersection.faceIndex = Math.floor(i10 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
};
Mesh.prototype.isMesh = true;
function checkIntersection(object2, material, raycaster, ray, pA2, pB2, pC2, point2) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC2, pB2, pA2, true, point2);
  } else {
    intersect = ray.intersectTriangle(pA2, pB2, pC2, material.side !== DoubleSide, point2);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point2);
  _intersectionPointWorld.applyMatrix4(object2.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far)
    return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object: object2
  };
}
function checkBufferGeometryIntersection(object2, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv2, uv22, a10, b10, c10) {
  _vA$1.fromBufferAttribute(position, a10);
  _vB$1.fromBufferAttribute(position, b10);
  _vC$1.fromBufferAttribute(position, c10);
  const morphInfluences = object2.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i10 = 0, il2 = morphPosition.length; i10 < il2; i10++) {
      const influence = morphInfluences[i10];
      const morphAttribute = morphPosition[i10];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a10);
      _tempB.fromBufferAttribute(morphAttribute, b10);
      _tempC.fromBufferAttribute(morphAttribute, c10);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object2.isSkinnedMesh) {
    object2.boneTransform(a10, _vA$1);
    object2.boneTransform(b10, _vB$1);
    object2.boneTransform(c10, _vC$1);
  }
  const intersection = checkIntersection(object2, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a10);
      _uvB$1.fromBufferAttribute(uv2, b10);
      _uvC$1.fromBufferAttribute(uv2, c10);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv22) {
      _uvA$1.fromBufferAttribute(uv22, a10);
      _uvB$1.fromBufferAttribute(uv22, b10);
      _uvC$1.fromBufferAttribute(uv22, c10);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face4 = {
      a: a10,
      b: b10,
      c: c10,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face4.normal);
    intersection.face = face4;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u10, v10, w10, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy2 = 0; iy2 < gridY1; iy2++) {
        const y10 = iy2 * segmentHeight - heightHalf;
        for (let ix2 = 0; ix2 < gridX1; ix2++) {
          const x10 = ix2 * segmentWidth - widthHalf;
          vector[u10] = x10 * udir;
          vector[v10] = y10 * vdir;
          vector[w10] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u10] = 0;
          vector[v10] = 0;
          vector[w10] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix2 / gridX);
          uvs.push(1 - iy2 / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy2 = 0; iy2 < gridY; iy2++) {
        for (let ix2 = 0; ix2 < gridX; ix2++) {
          const a10 = numberOfVertices + ix2 + gridX1 * iy2;
          const b10 = numberOfVertices + ix2 + gridX1 * (iy2 + 1);
          const c10 = numberOfVertices + (ix2 + 1) + gridX1 * (iy2 + 1);
          const d10 = numberOfVertices + (ix2 + 1) + gridX1 * iy2;
          indices.push(a10, b10, d10);
          indices.push(b10, c10, d10);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u10 in src) {
    dst[u10] = {};
    for (const p10 in src[u10]) {
      const property = src[u10][p10];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u10][p10] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u10][p10] = property.slice();
      } else {
        dst[u10][p10] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u10 = 0; u10 < uniforms.length; u10++) {
    const tmp2 = cloneUniforms(uniforms[u10]);
    for (const p10 in tmp2) {
      merged[p10] = tmp2[p10];
    }
  }
  return merged;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions2 = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions2[key] = true;
    }
    if (Object.keys(extensions2).length > 0)
      data.extensions = extensions2;
    return data;
  }
};
ShaderMaterial.prototype.isShaderMaterial = true;
var Camera = class extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera.prototype.isCamera = true;
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x10, y10, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x10;
    this.view.offsetY = y10;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
PerspectiveCamera.prototype.isPerspectiveCamera = true;
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer2, scene2) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer2.xr.enabled;
    const currentRenderTarget = renderer2.getRenderTarget();
    renderer2.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer2.setRenderTarget(renderTarget, 0);
    renderer2.render(scene2, cameraPX);
    renderer2.setRenderTarget(renderTarget, 1);
    renderer2.render(scene2, cameraNX);
    renderer2.setRenderTarget(renderTarget, 2);
    renderer2.render(scene2, cameraPY);
    renderer2.setRenderTarget(renderTarget, 3);
    renderer2.render(scene2, cameraNY);
    renderer2.setRenderTarget(renderTarget, 4);
    renderer2.render(scene2, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer2.setRenderTarget(renderTarget, 5);
    renderer2.render(scene2, cameraNZ);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size2, options4, dummy) {
    if (Number.isInteger(options4)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options4 = dummy;
    }
    super(size2, size2, options4);
    options4 = options4 || {};
    this.texture = new CubeTexture(void 0, options4.mapping, options4.wrapS, options4.wrapT, options4.magFilter, options4.minFilter, options4.format, options4.type, options4.anisotropy, options4.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options4.generateMipmaps !== void 0 ? options4.generateMipmaps : false;
    this.texture.minFilter = options4.minFilter !== void 0 ? options4.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer2, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    camera2.update(renderer2, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer2, color, depth, stencil) {
    const currentRenderTarget = renderer2.getRenderTarget();
    for (let i10 = 0; i10 < 6; i10++) {
      renderer2.setRenderTarget(this, i10);
      renderer2.clear(color, depth, stencil);
    }
    renderer2.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x10, y10, z10, w10) {
    this.normal.set(x10, y10, z10);
    this.constant = w10;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point2) {
    this.normal.copy(normal);
    this.constant = -point2.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a10, b10, c10) {
    const normal = _vector1.subVectors(c10, b10).cross(_vector2.subVectors(a10, b10)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a10);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point2) {
    return this.normal.dot(point2) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point2, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point2)).add(point2);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _sphere$2 = /* @__PURE__ */ new Sphere();
var _vector$7 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p02 = new Plane(), p12 = new Plane(), p22 = new Plane(), p32 = new Plane(), p42 = new Plane(), p52 = new Plane()) {
    this.planes = [p02, p12, p22, p32, p42, p52];
  }
  set(p02, p12, p22, p32, p42, p52) {
    const planes = this.planes;
    planes[0].copy(p02);
    planes[1].copy(p12);
    planes[2].copy(p22);
    planes[3].copy(p32);
    planes[4].copy(p42);
    planes[5].copy(p52);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i10 = 0; i10 < 6; i10++) {
      planes[i10].copy(frustum.planes[i10]);
    }
    return this;
  }
  setFromProjectionMatrix(m10) {
    const planes = this.planes;
    const me2 = m10.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object2) {
    const geometry = object2.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object2.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i10 = 0; i10 < 6; i10++) {
      const distance2 = planes[i10].distanceToPoint(center);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i10 = 0; i10 < 6; i10++) {
      const plane = planes[i10];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point2) {
    const planes = this.planes;
    for (let i10 = 0; i10 < 6; i10++) {
      if (planes[i10].distanceToPoint(point2) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl2.createBuffer();
    gl2.bindBuffer(bufferType, buffer);
    gl2.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl2.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl2.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl2.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached3 = buffers.get(attribute);
      if (!cached3 || cached3.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update: update2
  };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy2 = 0; iy2 < gridY1; iy2++) {
      const y10 = iy2 * segment_height - height_half;
      for (let ix2 = 0; ix2 < gridX1; ix2++) {
        const x10 = ix2 * segment_width - width_half;
        vertices.push(x10, -y10, 0);
        normals.push(0, 0, 1);
        uvs.push(ix2 / gridX);
        uvs.push(1 - iy2 / gridY);
      }
    }
    for (let iy2 = 0; iy2 < gridY; iy2++) {
      for (let ix2 = 0; ix2 < gridX; ix2++) {
        const a10 = ix2 + gridX1 * iy2;
        const b10 = ix2 + gridX1 * (iy2 + 1);
        const c10 = ix2 + 1 + gridX1 * (iy2 + 1);
        const d10 = ix2 + 1 + gridX1 * iy2;
        indices.push(a10, b10, d10);
        indices.push(b10, c10, d10);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 0 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer2, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene2) {
    let forceClear = false;
    let background = scene2.isScene === true ? scene2.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr2 = renderer2.xr;
    const session = xr2.getSession && xr2.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer2.autoClear || forceClear) {
      renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer3, scene3, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl2, extensions2, attributes, capabilities) {
  const maxVertexAttributes = gl2.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions2.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object2, material, program, geometry, index2) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index2);
      if (updateBuffers)
        saveCache(geometry, index2);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object2.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index2 !== null) {
      attributes.update(index2, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object2, material, program, geometry);
      if (index2 !== null) {
        gl2.bindBuffer(34963, attributes.get(index2).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl2.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i10 = 0; i10 < maxVertexAttributes; i10++) {
      newAttributes[i10] = 0;
      enabledAttributes[i10] = 0;
      attributeDivisors[i10] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index2) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index2)
      return true;
    return false;
  }
  function saveCache(geometry, index2) {
    const cache7 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache7[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache7;
    currentState.attributesNum = attributesNum;
    currentState.index = index2;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i10 = 0, il2 = newAttributes.length; i10 < il2; i10++) {
      newAttributes[i10] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl2.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl2 : extensions2.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i10 = 0, il2 = enabledAttributes.length; i10 < il2; i10++) {
      if (enabledAttributes[i10] !== newAttributes[i10]) {
        gl2.disableVertexAttribArray(i10);
        enabledAttributes[i10] = 0;
      }
    }
  }
  function vertexAttribPointer(index2, size2, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl2.vertexAttribIPointer(index2, size2, type, stride, offset);
    } else {
      gl2.vertexAttribPointer(index2, size2, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object2, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object2.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions2.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object2.instanceMatrix)
            geometryAttribute = object2.instanceMatrix;
          if (name === "instanceColor" && object2.instanceColor)
            geometryAttribute = object2.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size2 = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
                enableAttributeAndDivisor(programAttribute.location + i10, data.meshPerAttribute);
              }
              if (object2.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
                enableAttribute(programAttribute.location + i10);
              }
            }
            gl2.bindBuffer(34962, buffer);
            for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
              vertexAttribPointer(programAttribute.location + i10, size2 / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size2 / programAttribute.locationSize * i10) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
                enableAttributeAndDivisor(programAttribute.location + i10, geometryAttribute.meshPerAttribute);
              }
              if (object2.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
                enableAttribute(programAttribute.location + i10);
              }
            }
            gl2.bindBuffer(34962, buffer);
            for (let i10 = 0; i10 < programAttribute.locationSize; i10++) {
              vertexAttribPointer(programAttribute.location + i10, size2 / programAttribute.locationSize, type, normalized, size2 * bytesPerElement, size2 / programAttribute.locationSize * i10 * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl2.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl2.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl2.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl2.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset2();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset2() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset: reset2,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl2, extensions2, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count2) {
    gl2.drawArrays(mode, start, count2);
    info.update(count2, mode, 1);
  }
  function renderInstances(start, count2, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions2.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count2, primcount);
    info.update(count2, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl2, extensions2, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions2.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions2.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl2.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl2.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl2.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl2.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl2.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl2 instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions2.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl2.getParameter(34930);
  const maxVertexTextures = gl2.getParameter(35660);
  const maxTextureSize = gl2.getParameter(3379);
  const maxCubemapSize = gl2.getParameter(34076);
  const maxAttributes = gl2.getParameter(34921);
  const maxVertexUniforms = gl2.getParameter(36347);
  const maxVaryings = gl2.getParameter(36348);
  const maxFragmentUniforms = gl2.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions2.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl2.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera2) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera2, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera2, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
      for (let i10 = 0; i10 !== lGlobal; ++i10) {
        dstArray[i10] = globalState[i10];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera2, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i10 = 0, i42 = dstOffset; i10 !== nPlanes; ++i10, i42 += 4) {
          plane.copy(planes[i10]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i42);
          dstArray[i42 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer2) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer2.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer2, texture);
            cubemaps.set(texture, renderTarget);
            renderer2.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x10, y10, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x10;
    this.view.offsetY = y10;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx2 = (this.right - this.left) / (2 * this.zoom);
    const dy2 = (this.top - this.bottom) / (2 * this.zoom);
    const cx2 = (this.right + this.left) / 2;
    const cy2 = (this.top + this.bottom) / 2;
    let left = cx2 - dx2;
    let right = cx2 + dx2;
    let top = cy2 + dy2;
    let bottom = cy2 - dy2;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var MAX_SAMPLES = 20;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
var PMREMGenerator = class {
  constructor(renderer2) {
    this._renderer = renderer2;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene2, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene2, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i10 = 0; i10 < _lodPlanes.length; i10++) {
      _lodPlanes[i10].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene2, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer2 = this._renderer;
    const originalAutoClear = renderer2.autoClear;
    const outputEncoding = renderer2.outputEncoding;
    const toneMapping = renderer2.toneMapping;
    renderer2.getClearColor(_clearColor);
    renderer2.toneMapping = NoToneMapping;
    renderer2.outputEncoding = LinearEncoding;
    renderer2.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene2.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene2.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i10 = 0; i10 < 6; i10++) {
      const col = i10 % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i10], 0);
        cubeCamera.lookAt(forwardSign[i10], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i10]);
        cubeCamera.lookAt(0, forwardSign[i10], 0);
      } else {
        cubeCamera.up.set(0, upSign[i10], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i10]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i10 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer2.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer2.render(backgroundBox, cubeCamera);
      }
      renderer2.render(scene2, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer2.toneMapping = toneMapping;
    renderer2.outputEncoding = outputEncoding;
    renderer2.autoClear = originalAutoClear;
    scene2.background = background;
  }
  _setEncoding(uniform, texture) {
    uniform.value = ENCODINGS[texture.encoding];
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    this._setEncoding(uniforms["inputEncoding"], texture);
    this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer2.setRenderTarget(cubeUVRenderTarget);
    renderer2.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const autoClear = renderer2.autoClear;
    renderer2.autoClear = false;
    for (let i10 = 1; i10 < TOTAL_LODS; i10++) {
      const sigma = Math.sqrt(_sigmas[i10] * _sigmas[i10] - _sigmas[i10 - 1] * _sigmas[i10 - 1]);
      const poleAxis = _axisDirections[(i10 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i10 - 1, i10, sigma, poleAxis);
    }
    renderer2.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer2 = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i10 = 0; i10 < MAX_SAMPLES; ++i10) {
      const x11 = i10 / sigmaPixels;
      const weight = Math.exp(-x11 * x11 / 2);
      weights.push(weight);
      if (i10 == 0) {
        sum += weight;
      } else if (i10 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i10 = 0; i10 < weights.length; i10++) {
      weights[i10] = weights[i10] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
    this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
    const outputSize2 = _sizeLods[lodOut];
    const x10 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize2);
    const y10 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize2 * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x10, y10, 3 * outputSize2, 2 * outputSize2);
    renderer2.setRenderTarget(targetOut);
    renderer2.render(blurMesh, _flatCamera);
  }
};
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i10 = 0; i10 < TOTAL_LODS; i10++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i10 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i10 - LOD_MAX + LOD_MIN - 1];
    } else if (i10 == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex2 = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face4 = 0; face4 < cubeFaces; face4++) {
      const x10 = face4 % 3 * 2 / 3 - 1;
      const y10 = face4 > 2 ? 0 : -1;
      const coordinates = [
        x10,
        y10,
        0,
        x10 + 2 / 3,
        y10,
        0,
        x10 + 2 / 3,
        y10 + 1,
        0,
        x10,
        y10,
        0,
        x10 + 2 / 3,
        y10 + 1,
        0,
        x10,
        y10 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face4);
      uv2.set(uv1, uvSize * vertices * face4);
      const fill = [face4, face4, face4, face4, face4, face4];
      faceIndex2.set(fill, faceIndexSize * vertices * face4);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex2, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x10, y10, width, height) {
  target.viewport.set(x10, y10, width, height);
  target.scissor.set(x10, y10, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { "n": maxSamples },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "texelSize": { value: texelSize },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function WebGLCubeUVMaps(renderer2) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (cubeUVmaps.has(texture)) {
          return cubeUVmaps.get(texture).texture;
        } else {
          const image = texture.image;
          if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
            const currentRenderTarget = renderer2.getRenderTarget();
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer2);
            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
            cubeUVmaps.set(texture, renderTarget);
            renderer2.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return renderTarget.texture;
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count2 = 0;
    const length = 6;
    for (let i10 = 0; i10 < length; i10++) {
      if (image[i10] !== void 0)
        count2++;
    }
    return count2 === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl2) {
  const extensions2 = {};
  function getExtension(name) {
    if (extensions2[name] !== void 0) {
      return extensions2[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl2.getExtension(name);
    }
    extensions2[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl2, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object2, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update2(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i10 = 0, l10 = array.length; i10 < l10; i10++) {
        attributes.update(array[i10], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i10 = 0, l10 = array.length; i10 < l10; i10 += 3) {
        const a10 = array[i10 + 0];
        const b10 = array[i10 + 1];
        const c10 = array[i10 + 2];
        indices.push(a10, b10, b10, c10, c10, a10);
      }
    } else {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i10 = 0, l10 = array.length / 3 - 1; i10 < l10; i10 += 3) {
        const a10 = i10 + 0;
        const b10 = i10 + 1;
        const c10 = i10 + 2;
        indices.push(a10, b10, b10, c10, c10, a10);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update: update2,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl2, extensions2, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count2) {
    gl2.drawElements(mode, count2, type, start * bytesPerElement);
    info.update(count2, mode, 1);
  }
  function renderInstances(start, count2, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions2.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count2, type, start * bytesPerElement, primcount);
    info.update(count2, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl2) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update2(count2, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count2 / 3);
        break;
      case 1:
        render.lines += instanceCount * (count2 / 2);
        break;
      case 3:
        render.lines += instanceCount * (count2 - 1);
        break;
      case 2:
        render.lines += instanceCount * count2;
        break;
      case 0:
        render.points += instanceCount * count2;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset2() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset: reset2,
    update: update2
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function numericalSort(a10, b10) {
  return a10[0] - b10[0];
}
function absNumericalSort(a10, b10) {
  return Math.abs(b10[1]) - Math.abs(a10[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl2, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector3();
  const workInfluences = [];
  for (let i10 = 0; i10 < 8; i10++) {
    workInfluences[i10] = [i10, 0];
  }
  function update2(object2, geometry, material, program) {
    const objectInfluences = object2.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const numberOfMorphTargets = geometry.morphAttributes.position.length;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== numberOfMorphTargets) {
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal || [];
        const numberOfVertices = geometry.attributes.position.count;
        const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
        let width = numberOfVertices * numberOfVertexData;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
        const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
        texture.format = RGBAFormat;
        texture.type = FloatType;
        const vertexDataStride = numberOfVertexData * 4;
        for (let i10 = 0; i10 < numberOfMorphTargets; i10++) {
          const morphTarget = morphTargets[i10];
          const morphNormal = morphNormals[i10];
          const offset = width * height * 4 * i10;
          for (let j10 = 0; j10 < morphTarget.count; j10++) {
            morph.fromBufferAttribute(morphTarget, j10);
            if (morphTarget.normalized === true)
              denormalize(morph, morphTarget);
            const stride = j10 * vertexDataStride;
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j10);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
          }
        }
        entry = {
          count: numberOfMorphTargets,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
      }
      let morphInfluencesSum = 0;
      for (let i10 = 0; i10 < objectInfluences.length; i10++) {
        morphInfluencesSum += objectInfluences[i10];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i10 = 0; i10 < length; i10++) {
          influences[i10] = [i10, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i10 = 0; i10 < length; i10++) {
        const influence = influences[i10];
        influence[0] = i10;
        influence[1] = objectInfluences[i10];
      }
      influences.sort(absNumericalSort);
      for (let i10 = 0; i10 < 8; i10++) {
        if (i10 < length && influences[i10][1]) {
          workInfluences[i10][0] = influences[i10][0];
          workInfluences[i10][1] = influences[i10][1];
        } else {
          workInfluences[i10][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i10][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i10 = 0; i10 < 8; i10++) {
        const influence = workInfluences[i10];
        const index2 = influence[0];
        const value = influence[1];
        if (index2 !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i10) !== morphTargets[index2]) {
            geometry.setAttribute("morphTarget" + i10, morphTargets[index2]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i10) !== morphNormals[index2]) {
            geometry.setAttribute("morphNormal" + i10, morphNormals[index2]);
          }
          morphInfluences[i10] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i10) === true) {
            geometry.deleteAttribute("morphTarget" + i10);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i10) === true) {
            geometry.deleteAttribute("morphNormal" + i10);
          }
          morphInfluences[i10] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update: update2
  };
}
function WebGLObjects(gl2, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update2(object2) {
    const frame = info.render.frame;
    const geometry = object2.geometry;
    const buffergeometry = geometries.get(object2, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object2.isInstancedMesh) {
      if (object2.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object2.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object2.instanceMatrix, 34962);
      if (object2.instanceColor !== null) {
        attributes.update(object2.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update2,
    dispose
  };
}
var DataTexture3D = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n10 = nBlocks * blockSize;
  let r10 = arrayCacheF32[n10];
  if (r10 === void 0) {
    r10 = new Float32Array(n10);
    arrayCacheF32[n10] = r10;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r10, 0);
    for (let i10 = 1, offset = 0; i10 !== nBlocks; ++i10) {
      offset += blockSize;
      array[i10].toArray(r10, offset);
    }
  }
  return r10;
}
function arraysEqual(a10, b10) {
  if (a10.length !== b10.length)
    return false;
  for (let i10 = 0, l10 = a10.length; i10 < l10; i10++) {
    if (a10[i10] !== b10[i10])
      return false;
  }
  return true;
}
function copyArray(a10, b10) {
  for (let i10 = 0, l10 = b10.length; i10 < l10; i10++) {
    a10[i10] = b10[i10];
  }
}
function allocTexUnits(textures, n10) {
  let r10 = arrayCacheI32[n10];
  if (r10 === void 0) {
    r10 = new Int32Array(n10);
    arrayCacheI32[n10] = r10;
  }
  for (let i10 = 0; i10 !== n10; ++i10) {
    r10[i10] = textures.allocateTextureUnit();
  }
  return r10;
}
function setValueV1f(gl2, v10) {
  const cache7 = this.cache;
  if (cache7[0] === v10)
    return;
  gl2.uniform1f(this.addr, v10);
  cache7[0] = v10;
}
function setValueV2f(gl2, v10) {
  const cache7 = this.cache;
  if (v10.x !== void 0) {
    if (cache7[0] !== v10.x || cache7[1] !== v10.y) {
      gl2.uniform2f(this.addr, v10.x, v10.y);
      cache7[0] = v10.x;
      cache7[1] = v10.y;
    }
  } else {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniform2fv(this.addr, v10);
    copyArray(cache7, v10);
  }
}
function setValueV3f(gl2, v10) {
  const cache7 = this.cache;
  if (v10.x !== void 0) {
    if (cache7[0] !== v10.x || cache7[1] !== v10.y || cache7[2] !== v10.z) {
      gl2.uniform3f(this.addr, v10.x, v10.y, v10.z);
      cache7[0] = v10.x;
      cache7[1] = v10.y;
      cache7[2] = v10.z;
    }
  } else if (v10.r !== void 0) {
    if (cache7[0] !== v10.r || cache7[1] !== v10.g || cache7[2] !== v10.b) {
      gl2.uniform3f(this.addr, v10.r, v10.g, v10.b);
      cache7[0] = v10.r;
      cache7[1] = v10.g;
      cache7[2] = v10.b;
    }
  } else {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniform3fv(this.addr, v10);
    copyArray(cache7, v10);
  }
}
function setValueV4f(gl2, v10) {
  const cache7 = this.cache;
  if (v10.x !== void 0) {
    if (cache7[0] !== v10.x || cache7[1] !== v10.y || cache7[2] !== v10.z || cache7[3] !== v10.w) {
      gl2.uniform4f(this.addr, v10.x, v10.y, v10.z, v10.w);
      cache7[0] = v10.x;
      cache7[1] = v10.y;
      cache7[2] = v10.z;
      cache7[3] = v10.w;
    }
  } else {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniform4fv(this.addr, v10);
    copyArray(cache7, v10);
  }
}
function setValueM2(gl2, v10) {
  const cache7 = this.cache;
  const elements = v10.elements;
  if (elements === void 0) {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniformMatrix2fv(this.addr, false, v10);
    copyArray(cache7, v10);
  } else {
    if (arraysEqual(cache7, elements))
      return;
    mat2array.set(elements);
    gl2.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache7, elements);
  }
}
function setValueM3(gl2, v10) {
  const cache7 = this.cache;
  const elements = v10.elements;
  if (elements === void 0) {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniformMatrix3fv(this.addr, false, v10);
    copyArray(cache7, v10);
  } else {
    if (arraysEqual(cache7, elements))
      return;
    mat3array.set(elements);
    gl2.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache7, elements);
  }
}
function setValueM4(gl2, v10) {
  const cache7 = this.cache;
  const elements = v10.elements;
  if (elements === void 0) {
    if (arraysEqual(cache7, v10))
      return;
    gl2.uniformMatrix4fv(this.addr, false, v10);
    copyArray(cache7, v10);
  } else {
    if (arraysEqual(cache7, elements))
      return;
    mat4array.set(elements);
    gl2.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache7, elements);
  }
}
function setValueV1i(gl2, v10) {
  const cache7 = this.cache;
  if (cache7[0] === v10)
    return;
  gl2.uniform1i(this.addr, v10);
  cache7[0] = v10;
}
function setValueV2i(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform2iv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueV3i(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform3iv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueV4i(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform4iv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueV1ui(gl2, v10) {
  const cache7 = this.cache;
  if (cache7[0] === v10)
    return;
  gl2.uniform1ui(this.addr, v10);
  cache7[0] = v10;
}
function setValueV2ui(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform2uiv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueV3ui(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform3uiv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueV4ui(gl2, v10) {
  const cache7 = this.cache;
  if (arraysEqual(cache7, v10))
    return;
  gl2.uniform4uiv(this.addr, v10);
  copyArray(cache7, v10);
}
function setValueT1(gl2, v10, textures) {
  const cache7 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache7[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache7[0] = unit;
  }
  textures.safeSetTexture2D(v10 || emptyTexture, unit);
}
function setValueT3D1(gl2, v10, textures) {
  const cache7 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache7[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache7[0] = unit;
  }
  textures.setTexture3D(v10 || emptyTexture3d, unit);
}
function setValueT6(gl2, v10, textures) {
  const cache7 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache7[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache7[0] = unit;
  }
  textures.safeSetTextureCube(v10 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl2, v10, textures) {
  const cache7 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache7[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache7[0] = unit;
  }
  textures.setTexture2DArray(v10 || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl2, v10) {
  gl2.uniform1fv(this.addr, v10);
}
function setValueV2fArray(gl2, v10) {
  const data = flatten(v10, this.size, 2);
  gl2.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl2, v10) {
  const data = flatten(v10, this.size, 3);
  gl2.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl2, v10) {
  const data = flatten(v10, this.size, 4);
  gl2.uniform4fv(this.addr, data);
}
function setValueM2Array(gl2, v10) {
  const data = flatten(v10, this.size, 4);
  gl2.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl2, v10) {
  const data = flatten(v10, this.size, 9);
  gl2.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl2, v10) {
  const data = flatten(v10, this.size, 16);
  gl2.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl2, v10) {
  gl2.uniform1iv(this.addr, v10);
}
function setValueV2iArray(gl2, v10) {
  gl2.uniform2iv(this.addr, v10);
}
function setValueV3iArray(gl2, v10) {
  gl2.uniform3iv(this.addr, v10);
}
function setValueV4iArray(gl2, v10) {
  gl2.uniform4iv(this.addr, v10);
}
function setValueV1uiArray(gl2, v10) {
  gl2.uniform1uiv(this.addr, v10);
}
function setValueV2uiArray(gl2, v10) {
  gl2.uniform2uiv(this.addr, v10);
}
function setValueV3uiArray(gl2, v10) {
  gl2.uniform3uiv(this.addr, v10);
}
function setValueV4uiArray(gl2, v10) {
  gl2.uniform4uiv(this.addr, v10);
}
function setValueT1Array(gl2, v10, textures) {
  const n10 = v10.length;
  const units = allocTexUnits(textures, n10);
  gl2.uniform1iv(this.addr, units);
  for (let i10 = 0; i10 !== n10; ++i10) {
    textures.safeSetTexture2D(v10[i10] || emptyTexture, units[i10]);
  }
}
function setValueT3DArray(gl2, v10, textures) {
  const n10 = v10.length;
  const units = allocTexUnits(textures, n10);
  gl2.uniform1iv(this.addr, units);
  for (let i10 = 0; i10 !== n10; ++i10) {
    textures.setTexture3D(v10[i10] || emptyTexture3d, units[i10]);
  }
}
function setValueT6Array(gl2, v10, textures) {
  const n10 = v10.length;
  const units = allocTexUnits(textures, n10);
  gl2.uniform1iv(this.addr, units);
  for (let i10 = 0; i10 !== n10; ++i10) {
    textures.safeSetTextureCube(v10[i10] || emptyCubeTexture, units[i10]);
  }
}
function setValueT2DArrayArray(gl2, v10, textures) {
  const n10 = v10.length;
  const units = allocTexUnits(textures, n10);
  gl2.uniform1iv(this.addr, units);
  for (let i10 = 0; i10 !== n10; ++i10) {
    textures.setTexture2DArray(v10[i10] || emptyTexture2dArray, units[i10]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
function SingleUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache7 = this.cache;
  if (data instanceof Float32Array && cache7.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache7, data);
};
function StructuredUniform(id2) {
  this.id = id2;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl2, value, textures) {
  const seq = this.seq;
  for (let i10 = 0, n10 = seq.length; i10 !== n10; ++i10) {
    const u10 = seq[i10];
    u10.setValue(gl2, value[u10.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match3 = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id2 = match3[1];
    const idIsIndex = match3[2] === "]", subscript = match3[3];
    if (idIsIndex)
      id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl2, program) {
  this.seq = [];
  this.map = {};
  const n10 = gl2.getProgramParameter(program, 35718);
  for (let i10 = 0; i10 < n10; ++i10) {
    const info = gl2.getActiveUniform(program, i10), addr = gl2.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl2, name, value, textures) {
  const u10 = this.map[name];
  if (u10 !== void 0)
    u10.setValue(gl2, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl2, object2, name) {
  const v10 = object2[name];
  if (v10 !== void 0)
    this.setValue(gl2, name, v10);
};
WebGLUniforms.upload = function(gl2, seq, values, textures) {
  for (let i10 = 0, n10 = seq.length; i10 !== n10; ++i10) {
    const u10 = seq[i10], v10 = values[u10.id];
    if (v10.needsUpdate !== false) {
      u10.setValue(gl2, v10.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r10 = [];
  for (let i10 = 0, n10 = seq.length; i10 !== n10; ++i10) {
    const u10 = seq[i10];
    if (u10.id in values)
      r10.push(u10);
  }
  return r10;
};
function WebGLShader(gl2, type, string) {
  const shader = gl2.createShader(type);
  gl2.shaderSource(shader, string);
  gl2.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string) {
  const lines2 = string.split("\n");
  for (let i10 = 0; i10 < lines2.length; i10++) {
    lines2[i10] = i10 + 1 + ": " + lines2[i10];
  }
  return lines2.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl2, shader, type) {
  const status = gl2.getShaderParameter(shader, 35713);
  const errors = gl2.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl2.getShaderSource(shader));
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl2, program) {
  const attributes = {};
  const n10 = gl2.getProgramParameter(program, 35721);
  for (let i10 = 0; i10 < n10; i10++) {
    const info = gl2.getActiveAttrib(program, i10);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl2.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match3, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match3, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match3, start, end, snippet);
}
function loopReplacer(match3, start, end, snippet) {
  let string = "";
  for (let i10 = parseInt(start); i10 < parseInt(end); i10++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i10 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i10);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
  const gl2 = renderer2.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer2.gammaFactor > 0 ? renderer2.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl2.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.format === RGBFormat ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", parameters.specularColorMapEncoding) : "",
      parameters.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", parameters.sheenColorMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl2, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl2, 35632, fragmentGlsl);
  gl2.attachShader(program, glVertexShader);
  gl2.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl2.bindAttribLocation(program, 0, "position");
  }
  gl2.linkProgram(program);
  if (renderer2.debug.checkShaderErrors) {
    const programLog = gl2.getProgramInfoLog(program).trim();
    const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl2.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl2.deleteShader(glVertexShader);
  gl2.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl2, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl2, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl2.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer2, cubemaps, cubeuvmaps, extensions2, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoat",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    ,
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "alphaTest",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "morphTargetsCount",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "format",
    "specularIntensityMap",
    "specularColorMap",
    "specularColorMapEncoding",
    "transmission",
    "transmissionMap",
    "thicknessMap",
    "sheen",
    "sheenColorMap",
    "sheenColorMapEncoding",
    "sheenRoughnessMap"
  ];
  function getMaxBones(object2) {
    const skeleton = object2.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene2, object2) {
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object2.isSkinnedMesh ? getMaxBones(object2) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer2.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object2.isInstancedMesh === true,
      instancingColor: object2.isInstancedMesh === true && object2.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer2.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      specularColorMapEncoding: getTextureEncodingFromMap(material.specularColorMap),
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!object2.geometry && !!object2.geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!object2.geometry && !!object2.geometry.attributes.color && object2.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object2.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: !!object2.geometry && !!object2.geometry.morphAttributes.position,
      morphNormals: !!object2.geometry && !!object2.geometry.morphAttributes.normal,
      morphTargetsCount: !!object2.geometry && !!object2.geometry.morphAttributes.position ? object2.geometry.morphAttributes.position.length : 0,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      format: material.format,
      dithering: material.dithering,
      shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer2.shadowMap.type,
      toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer2.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions2.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions2.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions2.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(hashString(parameters.fragmentShader));
      array.push(hashString(parameters.vertexShader));
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i10 = 0; i10 < parameterNames.length; i10++) {
        array.push(parameters[parameterNames[i10]]);
      }
      array.push(renderer2.outputEncoding);
      array.push(renderer2.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p10 = 0, pl2 = programs.length; p10 < pl2; p10++) {
      const preexistingProgram = programs[p10];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i10 = programs.indexOf(program);
      programs[i10] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object2) {
    let map = properties.get(object2);
    if (map === void 0) {
      map = {};
      properties.set(object2, map);
    }
    return map;
  }
  function remove(object2) {
    properties.delete(object2);
  }
  function update2(object2, key, value) {
    properties.get(object2)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update: update2,
    dispose
  };
}
function painterSortStable(a10, b10) {
  if (a10.groupOrder !== b10.groupOrder) {
    return a10.groupOrder - b10.groupOrder;
  } else if (a10.renderOrder !== b10.renderOrder) {
    return a10.renderOrder - b10.renderOrder;
  } else if (a10.program !== b10.program) {
    return a10.program.id - b10.program.id;
  } else if (a10.material.id !== b10.material.id) {
    return a10.material.id - b10.material.id;
  } else if (a10.z !== b10.z) {
    return a10.z - b10.z;
  } else {
    return a10.id - b10.id;
  }
}
function reversePainterSortStable(a10, b10) {
  if (a10.groupOrder !== b10.groupOrder) {
    return a10.groupOrder - b10.groupOrder;
  } else if (a10.renderOrder !== b10.renderOrder) {
    return a10.renderOrder - b10.renderOrder;
  } else if (a10.z !== b10.z) {
    return b10.z - a10.z;
  } else {
    return a10.id - b10.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object2, geometry, material, groupOrder, z10, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object2.id,
        object: object2,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object2.renderOrder,
        z: z10,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object2.id;
      renderItem.object = object2;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object2.renderOrder;
      renderItem.z = z10;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object2, geometry, material, groupOrder, z10, group) {
    const renderItem = getNextRenderItem(object2, geometry, material, groupOrder, z10, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object2, geometry, material, groupOrder, z10, group) {
    const renderItem = getNextRenderItem(object2, geometry, material, groupOrder, z10, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i10 = renderItemsIndex, il2 = renderItems.length; i10 < il2; i10++) {
      const renderItem = renderItems[i10];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene2, renderCallDepth) {
    let list;
    if (lists.has(scene2) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene2, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene2).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene2).push(list);
      } else {
        list = lists.get(scene2)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions2, capabilities) {
  const cache7 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i10 = 0; i10 < 9; i10++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r10 = 0, g10 = 0, b10 = 0;
    for (let i10 = 0; i10 < 9; i10++)
      state.probe[i10].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i10 = 0, l10 = lights.length; i10 < l10; i10++) {
      const light2 = lights[i10];
      const color = light2.color;
      const intensity = light2.intensity;
      const distance2 = light2.distance;
      const shadowMap = light2.shadow && light2.shadow.map ? light2.shadow.map.texture : null;
      if (light2.isAmbientLight) {
        r10 += color.r * intensity * scaleFactor;
        g10 += color.g * intensity * scaleFactor;
        b10 += color.b * intensity * scaleFactor;
      } else if (light2.isLightProbe) {
        for (let j10 = 0; j10 < 9; j10++) {
          state.probe[j10].addScaledVector(light2.sh.coefficients[j10], intensity);
        }
      } else if (light2.isDirectionalLight) {
        const uniforms = cache7.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light2.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = cache7.get(light2);
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance2;
        uniforms.coneCos = Math.cos(light2.angle);
        uniforms.penumbraCos = Math.cos(light2.angle * (1 - light2.penumbra));
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light2.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = cache7.get(light2);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = cache7.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        uniforms.distance = light2.distance;
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light2.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = cache7.get(light2);
        uniforms.skyColor.copy(light2.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light2.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions2.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions2.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r10;
    state.ambient[1] = g10;
    state.ambient[2] = b10;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera2) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera2.matrixWorldInverse;
    for (let i10 = 0, l10 = lights.length; i10 < l10; i10++) {
      const light2 = lights[i10];
      if (light2.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light2.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions2, capabilities) {
  const lights = new WebGLLights(extensions2, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light2) {
    lightsArray.push(light2);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera2) {
    lights.setupView(lightsArray, camera2);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions2, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene2, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene2) === false) {
      renderState = new WebGLRenderState(extensions2, capabilities);
      renderStates.set(scene2, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene2).length) {
        renderState = new WebGLRenderState(extensions2, capabilities);
        renderStates.get(scene2).push(renderState);
      } else {
        renderState = renderStates.get(scene2)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene2, camera2) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i10 = 0, il2 = lights.length; i10 < il2; i10++) {
      const light2 = lights[i10];
      const shadow = light2.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light2, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light2.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light2.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp2 = 0; vp2 < viewportCount; vp2++) {
        const viewport = shadow.getViewport(vp2);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light2, vp2);
        _frustum = shadow.getFrustum();
        renderObject(scene2, camera2, shadow.camera, light2, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera2);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera2) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object2, geometry, material, light2, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light2.isPointLight === true ? object2.customDistanceMaterial : object2.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light2.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light2.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light2.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object2, camera2, shadowCamera, light2, type) {
    if (object2.visible === false)
      return;
    const visible = object2.layers.test(camera2.layers);
    if (visible && (object2.isMesh || object2.isLine || object2.isPoints)) {
      if ((object2.castShadow || object2.receiveShadow && type === VSMShadowMap) && (!object2.frustumCulled || _frustum.intersectsObject(object2))) {
        object2.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object2.matrixWorld);
        const geometry = _objects.update(object2);
        const material = object2.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k10 = 0, kl2 = groups.length; k10 < kl2; k10++) {
            const group = groups[k10];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object2, geometry, groupMaterial, light2, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object2, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object2, geometry, material, light2, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object2, null);
        }
      }
    }
    const children = object2.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      renderObject(children[i10], camera2, shadowCamera, light2, type);
    }
  }
}
function WebGLState(gl2, extensions2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r10, g10, b10, a10, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r10 *= a10;
          g10 *= a10;
          b10 *= a10;
        }
        color.set(r10, g10, b10, a10);
        if (currentColorClear.equals(color) === false) {
          gl2.clearColor(r10, g10, b10, a10);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl2.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl2.depthFunc(512);
                break;
              case AlwaysDepth:
                gl2.depthFunc(519);
                break;
              case LessDepth:
                gl2.depthFunc(513);
                break;
              case LessEqualDepth:
                gl2.depthFunc(515);
                break;
              case EqualDepth:
                gl2.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl2.depthFunc(518);
                break;
              case GreaterDepth:
                gl2.depthFunc(516);
                break;
              case NotEqualDepth:
                gl2.depthFunc(517);
                break;
              default:
                gl2.depthFunc(515);
            }
          } else {
            gl2.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl2.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl2.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl2.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl2.getParameter(35661);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl2.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl2.getParameter(3088);
  const viewportParam = gl2.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count2) {
    const data = new Uint8Array(4);
    const texture = gl2.createTexture();
    gl2.bindTexture(type, texture);
    gl2.texParameteri(type, 10241, 9728);
    gl2.texParameteri(type, 10240, 9728);
    for (let i10 = 0; i10 < count2; i10++) {
      gl2.texImage2D(target + i10, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl2.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl2.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl2.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl2.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions2.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl2.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl2.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl2.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl2.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl2.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl2.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl2.frontFace(2304);
      } else {
        gl2.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl2.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl2.cullFace(1028);
        } else {
          gl2.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl2.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl2.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl2.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl2.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl2.compressedTexImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl2.texSubImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl2.texStorage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl2.texImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl2.texImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset2() {
    gl2.disable(3042);
    gl2.disable(2884);
    gl2.disable(2929);
    gl2.disable(32823);
    gl2.disable(3089);
    gl2.disable(2960);
    gl2.disable(32926);
    gl2.blendEquation(32774);
    gl2.blendFunc(1, 0);
    gl2.blendFuncSeparate(1, 0, 1, 0);
    gl2.colorMask(true, true, true, true);
    gl2.clearColor(0, 0, 0, 0);
    gl2.depthMask(true);
    gl2.depthFunc(513);
    gl2.clearDepth(1);
    gl2.stencilMask(4294967295);
    gl2.stencilFunc(519, 0, 4294967295);
    gl2.stencilOp(7680, 7680, 7680);
    gl2.clearStencil(0);
    gl2.cullFace(1029);
    gl2.frontFace(2305);
    gl2.polygonOffset(0, 0);
    gl2.activeTexture(33984);
    gl2.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl2.bindFramebuffer(36009, null);
      gl2.bindFramebuffer(36008, null);
    }
    gl2.useProgram(null);
    gl2.lineWidth(1);
    gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
    gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texSubImage2D,
    scissor,
    viewport,
    reset: reset2
  };
}
function WebGLTextures(_gl, extensions2, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const hasMultisampledRenderToTexture = extensions2.has("WEBGL_multisampled_render_to_texture");
  const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions2.get("WEBGL_multisampled_render_to_texture") : void 0;
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize2) {
    let scale2 = 1;
    if (image.width > maxSize2 || image.height > maxSize2) {
      scale2 = maxSize2 / Math.max(image.width, image.height);
    }
    if (scale2 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale2 * image.width);
        const height = floor(scale2 * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas3 = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas3.width = width;
        canvas3.height = height;
        const context = canvas3.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas3;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions2.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f10) {
    if (f10 === NearestFilter || f10 === NearestMipmapNearestFilter || f10 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i10 = 0; i10 < 6; i10++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i10]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i10]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i10 = 0, il2 = texture.length; i10 < il2; i10++) {
        const attachmentProperties = properties.get(texture[i10]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i10]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions2.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions2.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions2.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions2.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i10 = 0, il2 = mipmaps.length; i10 < il2; i10++) {
          mipmap = mipmaps[i10];
          state.texImage2D(3553, i10, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
      }
    } else if (texture.isCompressedTexture) {
      for (let i10 = 0, il2 = mipmaps.length; i10 < il2; i10++) {
        mipmap = mipmaps[i10];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i10, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i10, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
    } else {
      const levels = getMipLevels(texture, image, supportsMips);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      if (mipmaps.length > 0 && supportsMips) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i10 = 0, il2 = mipmaps.length; i10 < il2; i10++) {
          mipmap = mipmaps[i10];
          if (useTexStorage) {
            state.texSubImage2D(3553, i10, 0, 0, glFormat, glType, mipmap);
          } else {
            state.texImage2D(3553, i10, glInternalFormat, glFormat, glType, mipmap);
          }
        }
        texture.generateMipmaps = false;
      } else {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
          }
          state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        }
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i10 = 0; i10 < 6; i10++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i10] = resizeImage(texture.image[i10], false, true, maxCubemapSize);
      } else {
        cubeImage[i10] = isDataTexture ? texture.image[i10].image : texture.image[i10];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i10 = 0; i10 < 6; i10++) {
        mipmaps = cubeImage[i10].mipmaps;
        for (let j10 = 0; j10 < mipmaps.length; j10++) {
          const mipmap = mipmaps[j10];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i10, j10, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i10, j10, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
    } else {
      mipmaps = texture.mipmaps;
      for (let i10 = 0; i10 < 6; i10++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i10, 0, glInternalFormat, cubeImage[i10].width, cubeImage[i10].height, 0, glFormat, glType, cubeImage[i10].data);
          for (let j10 = 0; j10 < mipmaps.length; j10++) {
            const mipmap = mipmaps[j10];
            const mipmapImage = mipmap.image[i10].image;
            state.texImage2D(34069 + i10, j10 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i10, 0, glInternalFormat, glFormat, glType, cubeImage[i10]);
          for (let j10 = 0; j10 < mipmaps.length; j10++) {
            const mipmap = mipmaps[j10];
            state.texImage2D(34069 + i10, j10 + 1, glInternalFormat, glFormat, glType, mipmap.image[i10]);
          }
        }
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (renderTarget.useRenderToTexture) {
      MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || renderTarget.useRenderToTexture) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && renderTarget.useRenderbuffer) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && renderTarget.useRenderbuffer) {
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i10 = 0; i10 < 6; i10++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i10]);
          renderTargetProperties.__webglDepthbuffer[i10] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i10], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i10 = 0; i10 < 6; i10++) {
        renderTargetProperties.__webglFramebuffer[i10] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i10 = 0, il2 = textures.length; i10 < il2; i10++) {
            const attachmentProperties = properties.get(textures[i10]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (renderTarget.useRenderbuffer) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i10 = 0; i10 < 6; i10++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i10], renderTarget, texture, 36064, 34069 + i10);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i10 = 0, il2 = textures.length; i10 < il2; i10++) {
        const attachment = textures[i10];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i10, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i10 = 0, il2 = textures.length; i10 < il2; i10++) {
      const texture = textures[i10];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.useRenderbuffer) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask2 = 16384;
        const invalidationArray = [36064];
        const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        if (!renderTarget.ignoreDepthForMultisampleCopy) {
          if (renderTarget.depthBuffer)
            mask2 |= 256;
          if (renderTarget.stencilBuffer)
            mask2 |= 1024;
        }
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        if (renderTarget.ignoreDepthForMultisampleCopy) {
          _gl.invalidateFramebuffer(36008, [depthStyle]);
          _gl.invalidateFramebuffer(36009, [depthStyle]);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask2, 9728);
        _gl.invalidateFramebuffer(36008, invalidationArray);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl2, extensions2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p10) {
    let extension;
    if (p10 === UnsignedByteType)
      return 5121;
    if (p10 === UnsignedShort4444Type)
      return 32819;
    if (p10 === UnsignedShort5551Type)
      return 32820;
    if (p10 === UnsignedShort565Type)
      return 33635;
    if (p10 === ByteType)
      return 5120;
    if (p10 === ShortType)
      return 5122;
    if (p10 === UnsignedShortType)
      return 5123;
    if (p10 === IntType)
      return 5124;
    if (p10 === UnsignedIntType)
      return 5125;
    if (p10 === FloatType)
      return 5126;
    if (p10 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions2.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p10 === AlphaFormat)
      return 6406;
    if (p10 === RGBFormat)
      return 6407;
    if (p10 === RGBAFormat)
      return 6408;
    if (p10 === LuminanceFormat)
      return 6409;
    if (p10 === LuminanceAlphaFormat)
      return 6410;
    if (p10 === DepthFormat)
      return 6402;
    if (p10 === DepthStencilFormat)
      return 34041;
    if (p10 === RedFormat)
      return 6403;
    if (p10 === RedIntegerFormat)
      return 36244;
    if (p10 === RGFormat)
      return 33319;
    if (p10 === RGIntegerFormat)
      return 33320;
    if (p10 === RGBIntegerFormat)
      return 36248;
    if (p10 === RGBAIntegerFormat)
      return 36249;
    if (p10 === RGB_S3TC_DXT1_Format || p10 === RGBA_S3TC_DXT1_Format || p10 === RGBA_S3TC_DXT3_Format || p10 === RGBA_S3TC_DXT5_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p10 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p10 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p10 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p10 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p10 === RGB_PVRTC_4BPPV1_Format || p10 === RGB_PVRTC_2BPPV1_Format || p10 === RGBA_PVRTC_4BPPV1_Format || p10 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p10 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p10 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p10 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p10 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p10 === RGB_ETC1_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p10 === RGB_ETC2_Format || p10 === RGBA_ETC2_EAC_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p10 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p10 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p10 === RGBA_ASTC_4x4_Format || p10 === RGBA_ASTC_5x4_Format || p10 === RGBA_ASTC_5x5_Format || p10 === RGBA_ASTC_6x5_Format || p10 === RGBA_ASTC_6x6_Format || p10 === RGBA_ASTC_8x5_Format || p10 === RGBA_ASTC_8x6_Format || p10 === RGBA_ASTC_8x8_Format || p10 === RGBA_ASTC_10x5_Format || p10 === RGBA_ASTC_10x6_Format || p10 === RGBA_ASTC_10x8_Format || p10 === RGBA_ASTC_10x10_Format || p10 === RGBA_ASTC_12x10_Format || p10 === RGBA_ASTC_12x12_Format || p10 === SRGB8_ALPHA8_ASTC_4x4_Format || p10 === SRGB8_ALPHA8_ASTC_5x4_Format || p10 === SRGB8_ALPHA8_ASTC_5x5_Format || p10 === SRGB8_ALPHA8_ASTC_6x5_Format || p10 === SRGB8_ALPHA8_ASTC_6x6_Format || p10 === SRGB8_ALPHA8_ASTC_8x5_Format || p10 === SRGB8_ALPHA8_ASTC_8x6_Format || p10 === SRGB8_ALPHA8_ASTC_8x8_Format || p10 === SRGB8_ALPHA8_ASTC_10x5_Format || p10 === SRGB8_ALPHA8_ASTC_10x6_Format || p10 === SRGB8_ALPHA8_ASTC_10x8_Format || p10 === SRGB8_ALPHA8_ASTC_10x10_Format || p10 === SRGB8_ALPHA8_ASTC_12x10_Format || p10 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions2.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p10;
      } else {
        return null;
      }
    }
    if (p10 === RGBA_BPTC_Format) {
      extension = extensions2.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p10;
      } else {
        return null;
      }
    }
    if (p10 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions2.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
};
ArrayCamera.prototype.isArrayCamera = true;
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand3 = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand3 && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand3.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand3.joints[inputjoint.jointName] = joint2;
            hand3.add(joint2);
          }
          const joint = hand3.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand3.joints["index-finger-tip"];
        const thumbTip = hand3.joints["thumb-tip"];
        const distance2 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand3.inputState.pinching && distance2 > distanceToPinch + threshold) {
          hand3.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand3.inputState.pinching && distance2 <= distanceToPinch - threshold) {
          hand3.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand3 !== null) {
      hand3.visible = handPose !== null;
    }
    return this;
  }
};
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var WebXRManager = class extends EventDispatcher {
  constructor(renderer2, gl2) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    const hasMultisampledRenderToTexture = renderer2.extensions.has("WEBGL_multisampled_render_to_texture");
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let isMultisample = false;
    let xrFrame = null;
    const attributes = gl2.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const inputSourcesMap = /* @__PURE__ */ new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer2.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer2.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl2.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer2.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
        } else {
          isMultisample = attributes.antialias;
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33189;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
          }
          const projectionlayerInit = {
            colorFormat: attributes.alpha || isMultisample ? 32856 : 32849,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl2);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          if (isMultisample) {
            newRenderTarget = new WebGLMultisampleRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              ignoreDepth: glProjLayer.ignoreDepthValues,
              useRenderToTexture: hasMultisampledRenderToTexture
            });
          } else {
            newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
              format: attributes.alpha ? RGBAFormat : RGBFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              ignoreDepth: glProjLayer.ignoreDepthValues
            });
          }
        }
        this.setFoveation(0);
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i10 = 0; i10 < controllers.length; i10++) {
        inputSourcesMap.set(inputSources[i10], controllers[i10]);
      }
      for (let i10 = 0; i10 < event.removed.length; i10++) {
        const inputSource = event.removed[i10];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i10 = 0; i10 < event.added.length; i10++) {
        const inputSource = event.added[i10];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.translateX(xOffset);
      camera2.translateZ(zOffset);
      camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera2, parent) {
      if (parent === null) {
        camera2.matrixWorld.copy(camera2.matrix);
      } else {
        camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
      }
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
    }
    this.updateCamera = function(camera2) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera2.near;
      cameraVR.far = cameraR.far = cameraL.far = camera2.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera2.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i10 = 0; i10 < cameras2.length; i10++) {
        updateCamera(cameras2[i10], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera2.position.copy(cameraVR.position);
      camera2.quaternion.copy(cameraVR.quaternion);
      camera2.scale.copy(cameraVR.scale);
      camera2.matrix.copy(cameraVR.matrix);
      camera2.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera2.children;
      for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
        children[i10].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer2.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer2.setRenderTarget(newRenderTarget);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i10 = 0; i10 < views.length; i10++) {
          const view = views[i10];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i10 === 0) {
              renderer2.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
              renderer2.setRenderTarget(newRenderTarget);
            }
          }
          const camera2 = cameras[i10];
          camera2.matrix.fromArray(view.transform.matrix);
          camera2.projectionMatrix.fromArray(view.projectionMatrix);
          camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i10 === 0) {
            cameraVR.matrix.copy(camera2.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera2);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i10 = 0; i10 < controllers.length; i10++) {
        const controller = controllers[i10];
        const inputSource = inputSources[i10];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas3 = createElementNS("canvas");
  canvas3.style.display = "block";
  return canvas3;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _currentDrawBuffers = [];
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i10 = 0; i10 < contextNames.length; i10++) {
      const contextName = contextNames[i10];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions2, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions2 = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions2, parameters);
    extensions2.init(capabilities);
    utils = new WebGLUtils(_gl, extensions2, capabilities);
    state = new WebGLState(_gl, extensions2, capabilities);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions2, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions2, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions2, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions2, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions2, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions2, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions2;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr2 = new WebXRManager(_this, _gl);
  this.xr = xr2;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions2.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions2.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr2.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x10, y10, width, height) {
    if (x10.isVector4) {
      _viewport.set(x10.x, x10.y, x10.z, x10.w);
    } else {
      _viewport.set(x10, y10, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x10, y10, width, height) {
    if (x10.isVector4) {
      _scissor.set(x10.x, x10.y, x10.z, x10.w);
    } else {
      _scissor.set(x10, y10, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr2.dispose();
    xr2.removeEventListener("sessionstart", onXRSessionStart);
    xr2.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  this.renderBufferDirect = function(camera2, scene2, geometry, material, object2, group) {
    if (scene2 === null)
      scene2 = _emptyScene;
    const frontFaceCW = object2.isMesh && object2.matrixWorld.determinant() < 0;
    const program = setProgram(camera2, scene2, geometry, material, object2);
    state.setMaterial(material, frontFaceCW);
    let index2 = geometry.index;
    const position = geometry.attributes.position;
    if (index2 === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index2.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index2 = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object2, material, program, geometry, index2);
    let attribute;
    let renderer2 = bufferRenderer;
    if (index2 !== null) {
      attribute = attributes.get(index2);
      renderer2 = indexedBufferRenderer;
      renderer2.setIndex(attribute);
    }
    const dataCount = index2 !== null ? index2.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object2.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer2.setMode(1);
      } else {
        renderer2.setMode(4);
      }
    } else if (object2.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object2.isLineSegments) {
        renderer2.setMode(1);
      } else if (object2.isLineLoop) {
        renderer2.setMode(2);
      } else {
        renderer2.setMode(3);
      }
    } else if (object2.isPoints) {
      renderer2.setMode(0);
    } else if (object2.isSprite) {
      renderer2.setMode(4);
    }
    if (object2.isInstancedMesh) {
      renderer2.renderInstances(drawStart, drawCount, object2.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer2.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer2.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene2, camera2) {
    currentRenderState = renderStates.get(scene2);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene2.traverseVisible(function(object2) {
      if (object2.isLight && object2.layers.test(camera2.layers)) {
        currentRenderState.pushLight(object2);
        if (object2.castShadow) {
          currentRenderState.pushShadow(object2);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene2.traverse(function(object2) {
      const material = object2.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i10 = 0; i10 < material.length; i10++) {
            const material2 = material[i10];
            getProgram(material2, scene2, object2);
          }
        } else {
          getProgram(material, scene2, object2);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr2.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr2.addEventListener("sessionstart", onXRSessionStart);
  xr2.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene2, camera2) {
    if (camera2 !== void 0 && camera2.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene2.autoUpdate === true)
      scene2.updateMatrixWorld();
    if (camera2.parent === null)
      camera2.updateMatrixWorld();
    if (xr2.enabled === true && xr2.isPresenting === true) {
      if (xr2.cameraAutoUpdate === true)
        xr2.updateCamera(camera2);
      camera2 = xr2.getCamera();
    }
    if (scene2.isScene === true)
      scene2.onBeforeRender(_this, scene2, camera2, _currentRenderTarget);
    currentRenderState = renderStates.get(scene2, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
    currentRenderList = renderLists.get(scene2, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene2, camera2, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene2, camera2);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene2);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera2.isArrayCamera) {
      const cameras = camera2.cameras;
      for (let i10 = 0, l10 = cameras.length; i10 < l10; i10++) {
        const camera22 = cameras[i10];
        renderScene(currentRenderList, scene2, camera22, camera22.viewport);
      }
    } else {
      renderScene(currentRenderList, scene2, camera2);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene2.isScene === true)
      scene2.onAfterRender(_this, scene2, camera2);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object2, camera2, groupOrder, sortObjects) {
    if (object2.visible === false)
      return;
    const visible = object2.layers.test(camera2.layers);
    if (visible) {
      if (object2.isGroup) {
        groupOrder = object2.renderOrder;
      } else if (object2.isLOD) {
        if (object2.autoUpdate === true)
          object2.update(camera2);
      } else if (object2.isLight) {
        currentRenderState.pushLight(object2);
        if (object2.castShadow) {
          currentRenderState.pushShadow(object2);
        }
      } else if (object2.isSprite) {
        if (!object2.frustumCulled || _frustum.intersectsSprite(object2)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object2);
          const material = object2.material;
          if (material.visible) {
            currentRenderList.push(object2, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object2.isMesh || object2.isLine || object2.isPoints) {
        if (object2.isSkinnedMesh) {
          if (object2.skeleton.frame !== info.render.frame) {
            object2.skeleton.update();
            object2.skeleton.frame = info.render.frame;
          }
        }
        if (!object2.frustumCulled || _frustum.intersectsObject(object2)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object2);
          const material = object2.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i10 = 0, l10 = groups.length; i10 < l10; i10++) {
              const group = groups[i10];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object2, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object2, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object2.children;
    for (let i10 = 0, l10 = children.length; i10 < l10; i10++) {
      projectObject(children[i10], camera2, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene2, camera2, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera2);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene2, camera2);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene2, camera2);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene2, camera2);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene2, camera2);
  }
  function renderTransmissionPass(opaqueObjects, scene2, camera2) {
    if (_transmissionRenderTarget === null) {
      const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      _transmissionRenderTarget = new renderTargetType(1024, 1024, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping,
        useRenderToTexture: extensions2.has("WEBGL_multisampled_render_to_texture")
      });
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene2, camera2);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene2, camera2) {
    const overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
    for (let i10 = 0, l10 = renderList.length; i10 < l10; i10++) {
      const renderItem = renderList[i10];
      const object2 = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object2.layers.test(camera2.layers)) {
        renderObject(object2, scene2, camera2, geometry, material, group);
      }
    }
  }
  function renderObject(object2, scene2, camera2, geometry, material, group) {
    object2.onBeforeRender(_this, scene2, camera2, geometry, material, group);
    object2.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object2.matrixWorld);
    object2.normalMatrix.getNormalMatrix(object2.modelViewMatrix);
    material.onBeforeRender(_this, scene2, camera2, geometry, object2, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera2, scene2, geometry, material, object2, group);
    }
    object2.onAfterRender(_this, scene2, camera2, geometry, material, group);
  }
  function getProgram(material, scene2, object2) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object2);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
    materialProperties.fog = scene2.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object2, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
  }
  function setProgram(camera2, scene2, geometry, material, object2) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera2 !== _currentCamera) {
        const useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera2, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object2.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object2.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object2.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object2.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene2, object2);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera2) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera2) {
        _currentCamera = camera2;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object2.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
      }
    }
    if (object2.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object2, "bindMatrix");
      p_uniforms.setOptional(_gl, object2, "bindMatrixInverse");
      const skeleton = object2.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
      morphtargets.update(object2, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object2.receiveShadow) {
      materialProperties.receiveShadow = object2.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object2.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object2.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object2.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object2.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object2.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (renderTarget.useRenderToTexture) {
          console.warn("render-to-texture extension was disabled because an external texture was provided");
          renderTarget.useRenderToTexture = false;
          renderTarget.useRenderbuffer = true;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.useRenderbuffer) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      let needsUpdate = false;
      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures2 = renderTarget.texture;
          if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
            for (let i10 = 0, il2 = textures2.length; i10 < il2; i10++) {
              _currentDrawBuffers[i10] = 36064 + i10;
            }
            _currentDrawBuffers.length = textures2.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions2.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x10, y10, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions2.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions2.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions2.has("OES_texture_float") || extensions2.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x10 >= 0 && x10 <= renderTarget.width - width && (y10 >= 0 && y10 <= renderTarget.height - height)) {
            _gl.readPixels(x10, y10, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils.convert(texture.format);
    if (capabilities.isWebGL2) {
      if (glFormat === 6407)
        glFormat = 32849;
      if (glFormat === 6408)
        glFormat = 32856;
    }
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
WebGLRenderer.prototype.isWebGLRenderer = true;
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density = 25e-5) {
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near = 1, far = 1e3) {
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
};
Scene.prototype.isScene = true;
var InterleavedBuffer = class {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i10 = 0, l10 = this.stride; i10 < l10; i10++) {
      this.array[index1 + i10] = attribute.array[index2 + i10];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib2 = new this.constructor(array, this.stride);
    ib2.setUsage(this.usage);
    return ib2;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
InterleavedBuffer.prototype.isInterleavedBuffer = true;
var _vector$6 = /* @__PURE__ */ new Vector3();
var InterleavedBufferAttribute = class {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m10) {
    for (let i10 = 0, l10 = this.data.count; i10 < l10; i10++) {
      _vector$6.x = this.getX(i10);
      _vector$6.y = this.getY(i10);
      _vector$6.z = this.getZ(i10);
      _vector$6.applyMatrix4(m10);
      this.setXYZ(i10, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m10) {
    for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
      _vector$6.x = this.getX(i10);
      _vector$6.y = this.getY(i10);
      _vector$6.z = this.getZ(i10);
      _vector$6.applyNormalMatrix(m10);
      this.setXYZ(i10, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m10) {
    for (let i10 = 0, l10 = this.count; i10 < l10; i10++) {
      _vector$6.x = this.getX(i10);
      _vector$6.y = this.getY(i10);
      _vector$6.z = this.getZ(i10);
      _vector$6.transformDirection(m10);
      this.setXYZ(i10, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index2, x10) {
    this.data.array[index2 * this.data.stride + this.offset] = x10;
    return this;
  }
  setY(index2, y10) {
    this.data.array[index2 * this.data.stride + this.offset + 1] = y10;
    return this;
  }
  setZ(index2, z10) {
    this.data.array[index2 * this.data.stride + this.offset + 2] = z10;
    return this;
  }
  setW(index2, w10) {
    this.data.array[index2 * this.data.stride + this.offset + 3] = w10;
    return this;
  }
  getX(index2) {
    return this.data.array[index2 * this.data.stride + this.offset];
  }
  getY(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 1];
  }
  getZ(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 2];
  }
  getW(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 3];
  }
  setXY(index2, x10, y10) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x10;
    this.data.array[index2 + 1] = y10;
    return this;
  }
  setXYZ(index2, x10, y10, z10) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x10;
    this.data.array[index2 + 1] = y10;
    this.data.array[index2 + 2] = z10;
    return this;
  }
  setXYZW(index2, x10, y10, z10, w10) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x10;
    this.data.array[index2 + 1] = y10;
    this.data.array[index2 + 2] = z10;
    this.data.array[index2 + 3] = w10;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i10 = 0; i10 < this.count; i10++) {
        const index2 = i10 * this.data.stride + this.offset;
        for (let j10 = 0; j10 < this.itemSize; j10++) {
          array.push(this.data.array[index2 + j10]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i10 = 0; i10 < this.count; i10++) {
        const index2 = i10 * this.data.stride + this.offset;
        for (let j10 = 0; j10 < this.itemSize; j10++) {
          array.push(this.data.array[index2 + j10]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
var _vA = /* @__PURE__ */ new Vector3();
var _vB = /* @__PURE__ */ new Vector3();
var _vC = /* @__PURE__ */ new Vector3();
var _uvA = /* @__PURE__ */ new Vector2();
var _uvB = /* @__PURE__ */ new Vector2();
var _uvC = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance2 = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale2, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale2);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _basePosition = /* @__PURE__ */ new Vector3();
var _skinIndex = /* @__PURE__ */ new Vector4();
var _skinWeight = /* @__PURE__ */ new Vector4();
var _vector$5 = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix4();
var SkinnedMesh = class extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i10 = 0, l10 = skinWeight.count; i10 < l10; i10++) {
      vector.x = skinWeight.getX(i10);
      vector.y = skinWeight.getY(i10);
      vector.z = skinWeight.getZ(i10);
      vector.w = skinWeight.getW(i10);
      const scale2 = 1 / vector.manhattanLength();
      if (scale2 !== Infinity) {
        vector.multiplyScalar(scale2);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i10, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index2, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i10 = 0; i10 < 4; i10++) {
      const weight = _skinWeight.getComponent(i10);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i10);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
};
SkinnedMesh.prototype.isSkinnedMesh = true;
var Bone = class extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
};
Bone.prototype.isBone = true;
var DataTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { data, width, height };
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i10 = 0, il2 = this.bones.length; i10 < il2; i10++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i10 = 0, il2 = this.bones.length; i10 < il2; i10++) {
      const inverse = new Matrix4();
      if (this.bones[i10]) {
        inverse.copy(this.bones[i10].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i10 = 0, il2 = this.bones.length; i10 < il2; i10++) {
      const bone = this.bones[i10];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i10]).invert();
      }
    }
    for (let i10 = 0, il2 = this.bones.length; i10 < il2; i10++) {
      const bone = this.bones[i10];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i10 = 0, il2 = bones.length; i10 < il2; i10++) {
      const matrix = bones[i10] ? bones[i10].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i10]);
      _offsetMatrix.toArray(boneMatrices, i10 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4);
    size2 = ceilPowerOfTwo(size2);
    size2 = Math.max(size2, 4);
    const boneMatrices = new Float32Array(size2 * size2 * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size2;
    return this;
  }
  getBoneByName(name) {
    for (let i10 = 0, il2 = this.bones.length; i10 < il2; i10++) {
      const bone = this.bones[i10];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i10 = 0, l10 = json.bones.length; i10 < l10; i10++) {
      const uuid = json.bones[i10];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i10]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i10 = 0, l10 = bones.length; i10 < l10; i10++) {
      const bone = bones[i10];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i10];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
var InstancedBufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
};
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
var _instanceIntersects = [];
var _mesh = /* @__PURE__ */ new Mesh();
var InstancedMesh = class extends Mesh {
  constructor(geometry, material, count2) {
    super(geometry, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count2 * 16), 16);
    this.instanceColor = null;
    this.count = count2;
    this.frustumCulled = false;
  }
  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }
  getColorAt(index2, color) {
    color.fromArray(this.instanceColor.array, index2 * 3);
  }
  getMatrixAt(index2, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index2 * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i10 = 0, l10 = _instanceIntersects.length; i10 < l10; i10++) {
        const intersect = _instanceIntersects[i10];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index2, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index2 * 3);
  }
  setMatrixAt(index2, matrix) {
    matrix.toArray(this.instanceMatrix.array, index2 * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
InstancedMesh.prototype.isInstancedMesh = true;
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start$1 = /* @__PURE__ */ new Vector3();
var _end$1 = /* @__PURE__ */ new Vector3();
var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
var _ray$1 = /* @__PURE__ */ new Ray();
var _sphere$1 = /* @__PURE__ */ new Sphere();
var Line = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i10 = 1, l10 = positionAttribute.count; i10 < l10; i10++) {
          _start$1.fromBufferAttribute(positionAttribute, i10 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i10);
          lineDistances[i10] = lineDistances[i10 - 1];
          lineDistances[i10] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i10 = start, l10 = end - 1; i10 < l10; i10 += step) {
          const a10 = index2.getX(i10);
          const b10 = index2.getX(i10 + 1);
          vStart.fromBufferAttribute(positionAttribute, a10);
          vEnd.fromBufferAttribute(positionAttribute, b10);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i10,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i10 = start, l10 = end - 1; i10 < l10; i10 += step) {
          vStart.fromBufferAttribute(positionAttribute, i10);
          vEnd.fromBufferAttribute(positionAttribute, i10 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i10,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m10 = 0, ml2 = morphAttribute.length; m10 < ml2; m10++) {
            const name = morphAttribute[m10].name || String(m10);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m10;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Line.prototype.isLine = true;
var _start = /* @__PURE__ */ new Vector3();
var _end = /* @__PURE__ */ new Vector3();
var LineSegments = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i10 = 0, l10 = positionAttribute.count; i10 < l10; i10 += 2) {
          _start.fromBufferAttribute(positionAttribute, i10);
          _end.fromBufferAttribute(positionAttribute, i10 + 1);
          lineDistances[i10] = i10 === 0 ? 0 : lineDistances[i10 - 1];
          lineDistances[i10 + 1] = lineDistances[i10] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
};
LineSegments.prototype.isLineSegments = true;
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix = /* @__PURE__ */ new Matrix4();
var _ray = /* @__PURE__ */ new Ray();
var _sphere = /* @__PURE__ */ new Sphere();
var _position$2 = /* @__PURE__ */ new Vector3();
var Points = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i10 = start, il2 = end; i10 < il2; i10++) {
          const a10 = index2.getX(i10);
          _position$2.fromBufferAttribute(positionAttribute, a10);
          testPoint(_position$2, a10, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i10 = start, l10 = end; i10 < l10; i10++) {
          _position$2.fromBufferAttribute(positionAttribute, i10);
          testPoint(_position$2, i10, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m10 = 0, ml2 = morphAttribute.length; m10 < ml2; m10++) {
            const name = morphAttribute[m10].name || String(m10);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m10;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Points.prototype.isPoints = true;
function testPoint(point2, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object2) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point2);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point2, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index2,
      face: null,
      object: object2
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas3, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas3, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var _v0 = new Vector3();
var _v1$1 = new Vector3();
var _normal = new Vector3();
var _triangle = new Triangle();
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  getPointAt(u10, optionalTarget) {
    const t = this.getUtoTmapping(u10);
    return this.getPoint(t, optionalTarget);
  }
  getPoints(divisions = 5) {
    const points = [];
    for (let d10 = 0; d10 <= divisions; d10++) {
      points.push(this.getPoint(d10 / divisions));
    }
    return points;
  }
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d10 = 0; d10 <= divisions; d10++) {
      points.push(this.getPointAt(d10 / divisions));
    }
    return points;
  }
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache7 = [];
    let current, last10 = this.getPoint(0);
    let sum = 0;
    cache7.push(0);
    for (let p10 = 1; p10 <= divisions; p10++) {
      current = this.getPoint(p10 / divisions);
      sum += current.distanceTo(last10);
      cache7.push(sum);
      last10 = current;
    }
    this.cacheArcLengths = cache7;
    return cache7;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  getUtoTmapping(u10, distance2) {
    const arcLengths = this.getLengths();
    let i10 = 0;
    const il2 = arcLengths.length;
    let targetArcLength;
    if (distance2) {
      targetArcLength = distance2;
    } else {
      targetArcLength = u10 * arcLengths[il2 - 1];
    }
    let low = 0, high = il2 - 1, comparison;
    while (low <= high) {
      i10 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i10] - targetArcLength;
      if (comparison < 0) {
        low = i10 + 1;
      } else if (comparison > 0) {
        high = i10 - 1;
      } else {
        high = i10;
        break;
      }
    }
    i10 = high;
    if (arcLengths[i10] === targetArcLength) {
      return i10 / (il2 - 1);
    }
    const lengthBefore = arcLengths[i10];
    const lengthAfter = arcLengths[i10 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i10 + segmentFraction) / (il2 - 1);
    return t;
  }
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t12 = t - delta;
    let t22 = t + delta;
    if (t12 < 0)
      t12 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t12);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u10, optionalTarget) {
    const t = this.getUtoTmapping(u10);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i10 = 0; i10 <= segments; i10++) {
      const u10 = i10 / segments;
      tangents[i10] = this.getTangentAt(u10, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx2 = Math.abs(tangents[0].x);
    const ty2 = Math.abs(tangents[0].y);
    const tz2 = Math.abs(tangents[0].z);
    if (tx2 <= min) {
      min = tx2;
      normal.set(1, 0, 0);
    }
    if (ty2 <= min) {
      min = ty2;
      normal.set(0, 1, 0);
    }
    if (tz2 <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i10 = 1; i10 <= segments; i10++) {
      normals[i10] = normals[i10 - 1].clone();
      binormals[i10] = binormals[i10 - 1].clone();
      vec.crossVectors(tangents[i10 - 1], tangents[i10]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i10 - 1].dot(tangents[i10]), -1, 1));
        normals[i10].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i10].crossVectors(tangents[i10], normals[i10]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i10 = 1; i10 <= segments; i10++) {
        normals[i10].applyMatrix4(mat.makeRotationAxis(tangents[i10], theta * i10));
        binormals[i10].crossVectors(tangents[i10], normals[i10]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX2 = 0, aY2 = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX2;
    this.aY = aY2;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point2 = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle2 = this.aStartAngle + t * deltaAngle;
    let x10 = this.aX + this.xRadius * Math.cos(angle2);
    let y10 = this.aY + this.yRadius * Math.sin(angle2);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx2 = x10 - this.aX;
      const ty2 = y10 - this.aY;
      x10 = tx2 * cos - ty2 * sin + this.aX;
      y10 = tx2 * sin + ty2 * cos + this.aY;
    }
    return point2.set(x10, y10);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX2, aY2, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX2, aY2, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c02 = 0, c12 = 0, c22 = 0, c32 = 0;
  function init2(x02, x12, t02, t12) {
    c02 = x02;
    c12 = t02;
    c22 = -3 * x02 + 3 * x12 - 2 * t02 - t12;
    c32 = 2 * x02 - 2 * x12 + t02 + t12;
  }
  return {
    initCatmullRom: function(x02, x12, x22, x32, tension) {
      init2(x12, x22, tension * (x22 - x02), tension * (x32 - x12));
    },
    initNonuniformCatmullRom: function(x02, x12, x22, x32, dt0, dt1, dt2) {
      let t12 = (x12 - x02) / dt0 - (x22 - x02) / (dt0 + dt1) + (x22 - x12) / dt1;
      let t22 = (x22 - x12) / dt1 - (x32 - x12) / (dt1 + dt2) + (x32 - x22) / dt2;
      t12 *= dt1;
      t22 *= dt1;
      init2(x12, x22, t12, t22);
    },
    calc: function(t) {
      const t22 = t * t;
      const t32 = t22 * t;
      return c02 + c12 * t + c22 * t22 + c32 * t32;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const points = this.points;
    const l10 = points.length;
    const p10 = (l10 - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p10);
    let weight = p10 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l10) + 1) * l10;
    } else if (weight === 0 && intPoint === l10 - 1) {
      intPoint = l10 - 2;
      weight = 1;
    }
    let p02, p32;
    if (this.closed || intPoint > 0) {
      p02 = points[(intPoint - 1) % l10];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p02 = tmp;
    }
    const p12 = points[intPoint % l10];
    const p22 = points[(intPoint + 1) % l10];
    if (this.closed || intPoint + 2 < l10) {
      p32 = points[(intPoint + 2) % l10];
    } else {
      tmp.subVectors(points[l10 - 1], points[l10 - 2]).add(points[l10 - 1]);
      p32 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p02.distanceToSquared(p12), pow);
      let dt1 = Math.pow(p12.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p02.x, p12.x, p22.x, p32.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p02.y, p12.y, p22.y, p32.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p02.z, p12.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p02.x, p12.x, p22.x, p32.x, this.tension);
      py.initCatmullRom(p02.y, p12.y, p22.y, p32.y, this.tension);
      pz.initCatmullRom(p02.z, p12.z, p22.z, p32.z, this.tension);
    }
    point2.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i10 = 0, l10 = source.points.length; i10 < l10; i10++) {
      const point2 = source.points[i10];
      this.points.push(point2.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i10 = 0, l10 = this.points.length; i10 < l10; i10++) {
      const point2 = this.points[i10];
      data.points.push(point2.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i10 = 0, l10 = json.points.length; i10 < l10; i10++) {
      const point2 = json.points[i10];
      this.points.push(new Vector3().fromArray(point2));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t, p02, p12, p22, p32) {
  const v02 = (p22 - p02) * 0.5;
  const v12 = (p32 - p12) * 0.5;
  const t22 = t * t;
  const t32 = t * t22;
  return (2 * p12 - 2 * p22 + v02 + v12) * t32 + (-3 * p12 + 3 * p22 - 2 * v02 - v12) * t22 + v02 * t + p12;
}
function QuadraticBezierP0(t, p10) {
  const k10 = 1 - t;
  return k10 * k10 * p10;
}
function QuadraticBezierP1(t, p10) {
  return 2 * (1 - t) * t * p10;
}
function QuadraticBezierP2(t, p10) {
  return t * t * p10;
}
function QuadraticBezier(t, p02, p12, p22) {
  return QuadraticBezierP0(t, p02) + QuadraticBezierP1(t, p12) + QuadraticBezierP2(t, p22);
}
function CubicBezierP0(t, p10) {
  const k10 = 1 - t;
  return k10 * k10 * k10 * p10;
}
function CubicBezierP1(t, p10) {
  const k10 = 1 - t;
  return 3 * k10 * k10 * t * p10;
}
function CubicBezierP2(t, p10) {
  return 3 * (1 - t) * t * t * p10;
}
function CubicBezierP3(t, p10) {
  return t * t * t * p10;
}
function CubicBezier(t, p02, p12, p22, p32) {
  return CubicBezierP0(t, p02) + CubicBezierP1(t, p12) + CubicBezierP2(t, p22) + CubicBezierP3(t, p32);
}
var CubicBezierCurve = class extends Curve {
  constructor(v02 = new Vector2(), v12 = new Vector2(), v22 = new Vector2(), v32 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v02;
    this.v1 = v12;
    this.v2 = v22;
    this.v3 = v32;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v02 = this.v0, v12 = this.v1, v22 = this.v2, v32 = this.v3;
    point2.set(CubicBezier(t, v02.x, v12.x, v22.x, v32.x), CubicBezier(t, v02.y, v12.y, v22.y, v32.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v02 = new Vector3(), v12 = new Vector3(), v22 = new Vector3(), v32 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v02;
    this.v1 = v12;
    this.v2 = v22;
    this.v3 = v32;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v02 = this.v0, v12 = this.v1, v22 = this.v2, v32 = this.v3;
    point2.set(CubicBezier(t, v02.x, v12.x, v22.x, v32.x), CubicBezier(t, v02.y, v12.y, v22.y, v32.y), CubicBezier(t, v02.z, v12.z, v22.z, v32.z));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v12 = new Vector2(), v22 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v12;
    this.v2 = v22;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    if (t === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t).add(this.v1);
    }
    return point2;
  }
  getPointAt(u10, optionalTarget) {
    return this.getPoint(u10, optionalTarget);
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v12 = new Vector3(), v22 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v12;
    this.v2 = v22;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    if (t === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t).add(this.v1);
    }
    return point2;
  }
  getPointAt(u10, optionalTarget) {
    return this.getPoint(u10, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v02 = new Vector2(), v12 = new Vector2(), v22 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v02;
    this.v1 = v12;
    this.v2 = v22;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v02 = this.v0, v12 = this.v1, v22 = this.v2;
    point2.set(QuadraticBezier(t, v02.x, v12.x, v22.x), QuadraticBezier(t, v02.y, v12.y, v22.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v02 = new Vector3(), v12 = new Vector3(), v22 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v02;
    this.v1 = v12;
    this.v2 = v22;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v02 = this.v0, v12 = this.v1, v22 = this.v2;
    point2.set(QuadraticBezier(t, v02.x, v12.x, v22.x), QuadraticBezier(t, v02.y, v12.y, v22.y), QuadraticBezier(t, v02.z, v12.z, v22.z));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const points = this.points;
    const p10 = (points.length - 1) * t;
    const intPoint = Math.floor(p10);
    const weight = p10 - intPoint;
    const p02 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p12 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point2.set(CatmullRom(weight, p02.x, p12.x, p22.x, p32.x), CatmullRom(weight, p02.y, p12.y, p22.y, p32.y));
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i10 = 0, l10 = source.points.length; i10 < l10; i10++) {
      const point2 = source.points[i10];
      this.points.push(point2.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i10 = 0, l10 = this.points.length; i10 < l10; i10++) {
      const point2 = this.points[i10];
      data.points.push(point2.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i10 = 0, l10 = json.points.length; i10 < l10; i10++) {
      const point2 = json.points[i10];
      this.points.push(new Vector2().fromArray(point2));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t, optionalTarget) {
    const d10 = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i10 = 0;
    while (i10 < curveLengths.length) {
      if (curveLengths[i10] >= d10) {
        const diff = curveLengths[i10] - d10;
        const curve = this.curves[i10];
        const segmentLength = curve.getLength();
        const u10 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u10, optionalTarget);
      }
      i10++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i10 = 0, l10 = this.curves.length; i10 < l10; i10++) {
      sums += this.curves[i10].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i10 = 0; i10 <= divisions; i10++) {
      points.push(this.getPoint(i10 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last10;
    for (let i10 = 0, curves2 = this.curves; i10 < curves2.length; i10++) {
      const curve = curves2[i10];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j10 = 0; j10 < pts.length; j10++) {
        const point2 = pts[j10];
        if (last10 && last10.equals(point2))
          continue;
        points.push(point2);
        last10 = point2;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i10 = 0, l10 = source.curves.length; i10 < l10; i10++) {
      const curve = source.curves[i10];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i10 = 0, l10 = this.curves.length; i10 < l10; i10++) {
      const curve = this.curves[i10];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i10 = 0, l10 = json.curves.length; i10 < l10; i10++) {
      const curve = json.curves[i10];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i10 = 1, l10 = points.length; i10 < l10; i10++) {
      this.lineTo(points[i10].x, points[i10].y);
    }
    return this;
  }
  moveTo(x10, y10) {
    this.currentPoint.set(x10, y10);
    return this;
  }
  lineTo(x10, y10) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x10, y10));
    this.curves.push(curve);
    this.currentPoint.set(x10, y10);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX2, aY2) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX2, aY2));
    this.curves.push(curve);
    this.currentPoint.set(aX2, aY2);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX2, aY2) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX2, aY2));
    this.curves.push(curve);
    this.currentPoint.set(aX2, aY2);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX2, aY2, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x02 = this.currentPoint.x;
    const y02 = this.currentPoint.y;
    this.absarc(aX2 + x02, aY2 + y02, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX2, aY2, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX2, aY2, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX2, aY2, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x02 = this.currentPoint.x;
    const y02 = this.currentPoint.y;
    this.absellipse(aX2 + x02, aY2 + y02, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX2, aY2, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX2, aY2, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i10 = 0, l10 = this.holes.length; i10 < l10; i10++) {
      holesPts[i10] = this.holes[i10].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i10 = 0, l10 = source.holes.length; i10 < l10; i10++) {
      const hole = source.holes[i10];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i10 = 0, l10 = this.holes.length; i10 < l10; i10++) {
      const hole = this.holes[i10];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i10 = 0, l10 = json.holes.length; i10 < l10; i10++) {
      const hole = json.holes[i10];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x10, y10, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i10 = dim; i10 < outerLen; i10 += dim) {
        x10 = data[i10];
        y10 = data[i10 + 1];
        if (x10 < minX)
          minX = x10;
        if (y10 < minY)
          minY = y10;
        if (x10 > maxX)
          maxX = x10;
        if (y10 > maxY)
          maxY = y10;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i10, last10;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i10 = start; i10 < end; i10 += dim)
      last10 = insertNode(i10, data[i10], data[i10 + 1], last10);
  } else {
    for (i10 = end - dim; i10 >= start; i10 -= dim)
      last10 = insertNode(i10, data[i10], data[i10 + 1], last10);
  }
  if (last10 && equals(last10, last10.next)) {
    removeNode(last10);
    last10 = last10.next;
  }
  return last10;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p10 = start, again;
  do {
    again = false;
    if (!p10.steiner && (equals(p10, p10.next) || area(p10.prev, p10, p10.next) === 0)) {
      removeNode(p10);
      p10 = end = p10.prev;
      if (p10 === p10.next)
        break;
      again = true;
    } else {
      p10 = p10.next;
    }
  } while (again || p10 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a10 = ear.prev, b10 = ear, c10 = ear.next;
  if (area(a10, b10, c10) >= 0)
    return false;
  let p10 = ear.next.next;
  while (p10 !== ear.prev) {
    if (pointInTriangle(a10.x, a10.y, b10.x, b10.y, c10.x, c10.y, p10.x, p10.y) && area(p10.prev, p10, p10.next) >= 0)
      return false;
    p10 = p10.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a10 = ear.prev, b10 = ear, c10 = ear.next;
  if (area(a10, b10, c10) >= 0)
    return false;
  const minTX = a10.x < b10.x ? a10.x < c10.x ? a10.x : c10.x : b10.x < c10.x ? b10.x : c10.x, minTY = a10.y < b10.y ? a10.y < c10.y ? a10.y : c10.y : b10.y < c10.y ? b10.y : c10.y, maxTX = a10.x > b10.x ? a10.x > c10.x ? a10.x : c10.x : b10.x > c10.x ? b10.x : c10.x, maxTY = a10.y > b10.y ? a10.y > c10.y ? a10.y : c10.y : b10.y > c10.y ? b10.y : c10.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p10 = ear.prevZ, n10 = ear.nextZ;
  while (p10 && p10.z >= minZ && n10 && n10.z <= maxZ) {
    if (p10 !== ear.prev && p10 !== ear.next && pointInTriangle(a10.x, a10.y, b10.x, b10.y, c10.x, c10.y, p10.x, p10.y) && area(p10.prev, p10, p10.next) >= 0)
      return false;
    p10 = p10.prevZ;
    if (n10 !== ear.prev && n10 !== ear.next && pointInTriangle(a10.x, a10.y, b10.x, b10.y, c10.x, c10.y, n10.x, n10.y) && area(n10.prev, n10, n10.next) >= 0)
      return false;
    n10 = n10.nextZ;
  }
  while (p10 && p10.z >= minZ) {
    if (p10 !== ear.prev && p10 !== ear.next && pointInTriangle(a10.x, a10.y, b10.x, b10.y, c10.x, c10.y, p10.x, p10.y) && area(p10.prev, p10, p10.next) >= 0)
      return false;
    p10 = p10.prevZ;
  }
  while (n10 && n10.z <= maxZ) {
    if (n10 !== ear.prev && n10 !== ear.next && pointInTriangle(a10.x, a10.y, b10.x, b10.y, c10.x, c10.y, n10.x, n10.y) && area(n10.prev, n10, n10.next) >= 0)
      return false;
    n10 = n10.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p10 = start;
  do {
    const a10 = p10.prev, b10 = p10.next.next;
    if (!equals(a10, b10) && intersects(a10, p10, p10.next, b10) && locallyInside(a10, b10) && locallyInside(b10, a10)) {
      triangles.push(a10.i / dim);
      triangles.push(p10.i / dim);
      triangles.push(b10.i / dim);
      removeNode(p10);
      removeNode(p10.next);
      p10 = start = b10;
    }
    p10 = p10.next;
  } while (p10 !== start);
  return filterPoints(p10);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a10 = start;
  do {
    let b10 = a10.next.next;
    while (b10 !== a10.prev) {
      if (a10.i !== b10.i && isValidDiagonal(a10, b10)) {
        let c10 = splitPolygon(a10, b10);
        a10 = filterPoints(a10, a10.next);
        c10 = filterPoints(c10, c10.next);
        earcutLinked(a10, triangles, dim, minX, minY, invSize);
        earcutLinked(c10, triangles, dim, minX, minY, invSize);
        return;
      }
      b10 = b10.next;
    }
    a10 = a10.next;
  } while (a10 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i10, len, start, end, list;
  for (i10 = 0, len = holeIndices.length; i10 < len; i10++) {
    start = holeIndices[i10] * dim;
    end = i10 < len - 1 ? holeIndices[i10 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i10 = 0; i10 < queue.length; i10++) {
    eliminateHole(queue[i10], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a10, b10) {
  return a10.x - b10.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b10 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b10, b10.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p10 = outerNode;
  const hx2 = hole.x;
  const hy2 = hole.y;
  let qx2 = -Infinity, m10;
  do {
    if (hy2 <= p10.y && hy2 >= p10.next.y && p10.next.y !== p10.y) {
      const x10 = p10.x + (hy2 - p10.y) * (p10.next.x - p10.x) / (p10.next.y - p10.y);
      if (x10 <= hx2 && x10 > qx2) {
        qx2 = x10;
        if (x10 === hx2) {
          if (hy2 === p10.y)
            return p10;
          if (hy2 === p10.next.y)
            return p10.next;
        }
        m10 = p10.x < p10.next.x ? p10 : p10.next;
      }
    }
    p10 = p10.next;
  } while (p10 !== outerNode);
  if (!m10)
    return null;
  if (hx2 === qx2)
    return m10;
  const stop = m10, mx2 = m10.x, my2 = m10.y;
  let tanMin = Infinity, tan;
  p10 = m10;
  do {
    if (hx2 >= p10.x && p10.x >= mx2 && hx2 !== p10.x && pointInTriangle(hy2 < my2 ? hx2 : qx2, hy2, mx2, my2, hy2 < my2 ? qx2 : hx2, hy2, p10.x, p10.y)) {
      tan = Math.abs(hy2 - p10.y) / (hx2 - p10.x);
      if (locallyInside(p10, hole) && (tan < tanMin || tan === tanMin && (p10.x > m10.x || p10.x === m10.x && sectorContainsSector(m10, p10)))) {
        m10 = p10;
        tanMin = tan;
      }
    }
    p10 = p10.next;
  } while (p10 !== stop);
  return m10;
}
function sectorContainsSector(m10, p10) {
  return area(m10.prev, m10, p10.prev) < 0 && area(p10.next, m10, m10.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p10 = start;
  do {
    if (p10.z === null)
      p10.z = zOrder(p10.x, p10.y, minX, minY, invSize);
    p10.prevZ = p10.prev;
    p10.nextZ = p10.next;
    p10 = p10.next;
  } while (p10 !== start);
  p10.prevZ.nextZ = null;
  p10.prevZ = null;
  sortLinked(p10);
}
function sortLinked(list) {
  let i10, p10, q10, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p10 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p10) {
      numMerges++;
      q10 = p10;
      pSize = 0;
      for (i10 = 0; i10 < inSize; i10++) {
        pSize++;
        q10 = q10.nextZ;
        if (!q10)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q10) {
        if (pSize !== 0 && (qSize === 0 || !q10 || p10.z <= q10.z)) {
          e = p10;
          p10 = p10.nextZ;
          pSize--;
        } else {
          e = q10;
          q10 = q10.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p10 = q10;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x10, y10, minX, minY, invSize) {
  x10 = 32767 * (x10 - minX) * invSize;
  y10 = 32767 * (y10 - minY) * invSize;
  x10 = (x10 | x10 << 8) & 16711935;
  x10 = (x10 | x10 << 4) & 252645135;
  x10 = (x10 | x10 << 2) & 858993459;
  x10 = (x10 | x10 << 1) & 1431655765;
  y10 = (y10 | y10 << 8) & 16711935;
  y10 = (y10 | y10 << 4) & 252645135;
  y10 = (y10 | y10 << 2) & 858993459;
  y10 = (y10 | y10 << 1) & 1431655765;
  return x10 | y10 << 1;
}
function getLeftmost(start) {
  let p10 = start, leftmost = start;
  do {
    if (p10.x < leftmost.x || p10.x === leftmost.x && p10.y < leftmost.y)
      leftmost = p10;
    p10 = p10.next;
  } while (p10 !== start);
  return leftmost;
}
function pointInTriangle(ax2, ay2, bx2, by2, cx2, cy2, px3, py3) {
  return (cx2 - px3) * (ay2 - py3) - (ax2 - px3) * (cy2 - py3) >= 0 && (ax2 - px3) * (by2 - py3) - (bx2 - px3) * (ay2 - py3) >= 0 && (bx2 - px3) * (cy2 - py3) - (cx2 - px3) * (by2 - py3) >= 0;
}
function isValidDiagonal(a10, b10) {
  return a10.next.i !== b10.i && a10.prev.i !== b10.i && !intersectsPolygon(a10, b10) && (locallyInside(a10, b10) && locallyInside(b10, a10) && middleInside(a10, b10) && (area(a10.prev, a10, b10.prev) || area(a10, b10.prev, b10)) || equals(a10, b10) && area(a10.prev, a10, a10.next) > 0 && area(b10.prev, b10, b10.next) > 0);
}
function area(p10, q10, r10) {
  return (q10.y - p10.y) * (r10.x - q10.x) - (q10.x - p10.x) * (r10.y - q10.y);
}
function equals(p12, p22) {
  return p12.x === p22.x && p12.y === p22.y;
}
function intersects(p12, q12, p22, q22) {
  const o12 = sign(area(p12, q12, p22));
  const o22 = sign(area(p12, q12, q22));
  const o32 = sign(area(p22, q22, p12));
  const o42 = sign(area(p22, q22, q12));
  if (o12 !== o22 && o32 !== o42)
    return true;
  if (o12 === 0 && onSegment(p12, p22, q12))
    return true;
  if (o22 === 0 && onSegment(p12, q22, q12))
    return true;
  if (o32 === 0 && onSegment(p22, p12, q22))
    return true;
  if (o42 === 0 && onSegment(p22, q12, q22))
    return true;
  return false;
}
function onSegment(p10, q10, r10) {
  return q10.x <= Math.max(p10.x, r10.x) && q10.x >= Math.min(p10.x, r10.x) && q10.y <= Math.max(p10.y, r10.y) && q10.y >= Math.min(p10.y, r10.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a10, b10) {
  let p10 = a10;
  do {
    if (p10.i !== a10.i && p10.next.i !== a10.i && p10.i !== b10.i && p10.next.i !== b10.i && intersects(p10, p10.next, a10, b10))
      return true;
    p10 = p10.next;
  } while (p10 !== a10);
  return false;
}
function locallyInside(a10, b10) {
  return area(a10.prev, a10, a10.next) < 0 ? area(a10, b10, a10.next) >= 0 && area(a10, a10.prev, b10) >= 0 : area(a10, b10, a10.prev) < 0 || area(a10, a10.next, b10) < 0;
}
function middleInside(a10, b10) {
  let p10 = a10, inside = false;
  const px3 = (a10.x + b10.x) / 2, py3 = (a10.y + b10.y) / 2;
  do {
    if (p10.y > py3 !== p10.next.y > py3 && p10.next.y !== p10.y && px3 < (p10.next.x - p10.x) * (py3 - p10.y) / (p10.next.y - p10.y) + p10.x)
      inside = !inside;
    p10 = p10.next;
  } while (p10 !== a10);
  return inside;
}
function splitPolygon(a10, b10) {
  const a22 = new Node(a10.i, a10.x, a10.y), b22 = new Node(b10.i, b10.x, b10.y), an2 = a10.next, bp2 = b10.prev;
  a10.next = b10;
  b10.prev = a10;
  a22.next = an2;
  an2.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp2.next = b22;
  b22.prev = bp2;
  return b22;
}
function insertNode(i10, x10, y10, last10) {
  const p10 = new Node(i10, x10, y10);
  if (!last10) {
    p10.prev = p10;
    p10.next = p10;
  } else {
    p10.next = last10.next;
    p10.prev = last10;
    last10.next.prev = p10;
    last10.next = p10;
  }
  return p10;
}
function removeNode(p10) {
  p10.next.prev = p10.prev;
  p10.prev.next = p10.next;
  if (p10.prevZ)
    p10.prevZ.nextZ = p10.nextZ;
  if (p10.nextZ)
    p10.nextZ.prevZ = p10.prevZ;
}
function Node(i10, x10, y10) {
  this.i = i10;
  this.x = x10;
  this.y = y10;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i10 = start, j10 = end - dim; i10 < end; i10 += dim) {
    sum += (data[j10] - data[i10]) * (data[i10 + 1] + data[j10 + 1]);
    j10 = i10;
  }
  return sum;
}
var ShapeUtils = class {
  static area(contour) {
    const n10 = contour.length;
    let a10 = 0;
    for (let p10 = n10 - 1, q10 = 0; q10 < n10; p10 = q10++) {
      a10 += contour[p10].x * contour[q10].y - contour[q10].x * contour[p10].y;
    }
    return a10 * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i10 = 0; i10 < holes.length; i10++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i10].length;
      addContour(vertices, holes[i10]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i10 = 0; i10 < triangles.length; i10 += 3) {
      faces.push(triangles.slice(i10, i10 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l10 = points.length;
  if (l10 > 2 && points[l10 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i10 = 0; i10 < contour.length; i10++) {
    vertices.push(contour[i10].x);
    vertices.push(contour[i10].y);
  }
}
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options4 = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options4
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i10 = 0, l10 = shapes.length; i10 < l10; i10++) {
      const shape = shapes[i10];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options4.curveSegments !== void 0 ? options4.curveSegments : 12;
      const steps = options4.steps !== void 0 ? options4.steps : 1;
      let depth = options4.depth !== void 0 ? options4.depth : 1;
      let bevelEnabled = options4.bevelEnabled !== void 0 ? options4.bevelEnabled : true;
      let bevelThickness = options4.bevelThickness !== void 0 ? options4.bevelThickness : 0.2;
      let bevelSize = options4.bevelSize !== void 0 ? options4.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options4.bevelOffset !== void 0 ? options4.bevelOffset : 0;
      let bevelSegments = options4.bevelSegments !== void 0 ? options4.bevelSegments : 3;
      const extrudePath = options4.extrudePath;
      const uvgen = options4.UVGenerator !== void 0 ? options4.UVGenerator : WorldUVGenerator;
      if (options4.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options4.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
          const ahole = holes[h10];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h10] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
        const ahole = holes[h10];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt2, vec, size2) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size2).add(pt2);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i10 = 0, il2 = contour.length, j10 = il2 - 1, k10 = i10 + 1; i10 < il2; i10++, j10++, k10++) {
        if (j10 === il2)
          j10 = 0;
        if (k10 === il2)
          k10 = 0;
        contourMovements[i10] = getBevelVec(contour[i10], contour[j10], contour[k10]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
        const ahole = holes[h10];
        oneHoleMovements = [];
        for (let i10 = 0, il2 = ahole.length, j10 = il2 - 1, k10 = i10 + 1; i10 < il2; i10++, j10++, k10++) {
          if (j10 === il2)
            j10 = 0;
          if (k10 === il2)
            k10 = 0;
          oneHoleMovements[i10] = getBevelVec(ahole[i10], ahole[j10], ahole[k10]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b10 = 0; b10 < bevelSegments; b10++) {
        const t = b10 / bevelSegments;
        const z10 = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs3 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i10 = 0, il2 = contour.length; i10 < il2; i10++) {
          const vert = scalePt2(contour[i10], contourMovements[i10], bs3);
          v10(vert.x, vert.y, -z10);
        }
        for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
          const ahole = holes[h10];
          oneHoleMovements = holesMovements[h10];
          for (let i10 = 0, il2 = ahole.length; i10 < il2; i10++) {
            const vert = scalePt2(ahole[i10], oneHoleMovements[i10], bs3);
            v10(vert.x, vert.y, -z10);
          }
        }
      }
      const bs2 = bevelSize + bevelOffset;
      for (let i10 = 0; i10 < vlen; i10++) {
        const vert = bevelEnabled ? scalePt2(vertices[i10], verticesMovements[i10], bs2) : vertices[i10];
        if (!extrudeByPath) {
          v10(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v10(position2.x, position2.y, position2.z);
        }
      }
      for (let s10 = 1; s10 <= steps; s10++) {
        for (let i10 = 0; i10 < vlen; i10++) {
          const vert = bevelEnabled ? scalePt2(vertices[i10], verticesMovements[i10], bs2) : vertices[i10];
          if (!extrudeByPath) {
            v10(vert.x, vert.y, depth / steps * s10);
          } else {
            normal.copy(splineTube.normals[s10]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s10]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s10]).add(normal).add(binormal);
            v10(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b10 = bevelSegments - 1; b10 >= 0; b10--) {
        const t = b10 / bevelSegments;
        const z10 = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs3 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i10 = 0, il2 = contour.length; i10 < il2; i10++) {
          const vert = scalePt2(contour[i10], contourMovements[i10], bs3);
          v10(vert.x, vert.y, depth + z10);
        }
        for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
          const ahole = holes[h10];
          oneHoleMovements = holesMovements[h10];
          for (let i10 = 0, il2 = ahole.length; i10 < il2; i10++) {
            const vert = scalePt2(ahole[i10], oneHoleMovements[i10], bs3);
            if (!extrudeByPath) {
              v10(vert.x, vert.y, depth + z10);
            } else {
              v10(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z10);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i10 = 0; i10 < flen; i10++) {
            const face4 = faces[i10];
            f32(face4[2] + offset, face4[1] + offset, face4[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i10 = 0; i10 < flen; i10++) {
            const face4 = faces[i10];
            f32(face4[0] + offset, face4[1] + offset, face4[2] + offset);
          }
        } else {
          for (let i10 = 0; i10 < flen; i10++) {
            const face4 = faces[i10];
            f32(face4[2], face4[1], face4[0]);
          }
          for (let i10 = 0; i10 < flen; i10++) {
            const face4 = faces[i10];
            f32(face4[0] + vlen * steps, face4[1] + vlen * steps, face4[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h10 = 0, hl2 = holes.length; h10 < hl2; h10++) {
          const ahole = holes[h10];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i10 = contour2.length;
        while (--i10 >= 0) {
          const j10 = i10;
          let k10 = i10 - 1;
          if (k10 < 0)
            k10 = contour2.length - 1;
          for (let s10 = 0, sl2 = steps + bevelSegments * 2; s10 < sl2; s10++) {
            const slen1 = vlen * s10;
            const slen2 = vlen * (s10 + 1);
            const a10 = layeroffset + j10 + slen1, b10 = layeroffset + k10 + slen1, c10 = layeroffset + k10 + slen2, d10 = layeroffset + j10 + slen2;
            f42(a10, b10, c10, d10);
          }
        }
      }
      function v10(x10, y10, z10) {
        placeholder.push(x10);
        placeholder.push(y10);
        placeholder.push(z10);
      }
      function f32(a10, b10, c10) {
        addVertex(a10);
        addVertex(b10);
        addVertex(c10);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f42(a10, b10, c10, d10) {
        addVertex(a10);
        addVertex(b10);
        addVertex(d10);
        addVertex(b10);
        addVertex(c10);
        addVertex(d10);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index2) {
        verticesArray.push(placeholder[index2 * 3 + 0]);
        verticesArray.push(placeholder[index2 * 3 + 1]);
        verticesArray.push(placeholder[index2 * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options4 = this.parameters.options;
    return toJSON$1(shapes, options4, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j10 = 0, jl2 = data.shapes.length; j10 < jl2; j10++) {
      const shape = shapes[data.shapes[j10]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options4, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i10 = 0, l10 = shapes.length; i10 < l10; i10++) {
      const shape = shapes[i10];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options4.extrudePath !== void 0)
    data.options.extrudePath = options4.extrudePath.toJSON();
  return data;
}
var ShapeGeometry = class extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i10 = 0; i10 < shapes.length; i10++) {
        addShape(shapes[i10]);
        this.addGroup(groupStart, groupCount, i10);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i10 = 0, l10 = shapeHoles.length; i10 < l10; i10++) {
        const shapeHole = shapeHoles[i10];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i10] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i10 = 0, l10 = shapeHoles.length; i10 < l10; i10++) {
        const shapeHole = shapeHoles[i10];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i10 = 0, l10 = shapeVertices.length; i10 < l10; i10++) {
        const vertex2 = shapeVertices[i10];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i10 = 0, l10 = faces.length; i10 < l10; i10++) {
        const face4 = faces[i10];
        const a10 = face4[0] + indexOffset;
        const b10 = face4[1] + indexOffset;
        const c10 = face4[2] + indexOffset;
        indices.push(a10, b10, c10);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j10 = 0, jl2 = data.shapes.length; j10 < jl2; j10++) {
      const shape = shapes[data.shapes[j10]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i10 = 0, l10 = shapes.length; i10 < l10; i10++) {
      const shape = shapes[i10];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index2 = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy2 = 0; iy2 <= heightSegments; iy2++) {
      const verticesRow = [];
      const v10 = iy2 / heightSegments;
      let uOffset = 0;
      if (iy2 == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy2 == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix2 = 0; ix2 <= widthSegments; ix2++) {
        const u10 = ix2 / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u10 * phiLength) * Math.sin(thetaStart + v10 * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v10 * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u10 * phiLength) * Math.sin(thetaStart + v10 * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u10 + uOffset, 1 - v10);
        verticesRow.push(index2++);
      }
      grid.push(verticesRow);
    }
    for (let iy2 = 0; iy2 < heightSegments; iy2++) {
      for (let ix2 = 0; ix2 < widthSegments; ix2++) {
        const a10 = grid[iy2][ix2 + 1];
        const b10 = grid[iy2][ix2];
        const c10 = grid[iy2 + 1][ix2];
        const d10 = grid[iy2 + 1][ix2 + 1];
        if (iy2 !== 0 || thetaStart > 0)
          indices.push(a10, b10, d10);
        if (iy2 !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b10, c10, d10);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var MeshStandardMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
};
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var AnimationUtils = {
  arraySlice: function(array, from, to2) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to2 !== void 0 ? to2 : array.length));
    }
    return array.slice(from, to2);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object2) {
    return ArrayBuffer.isView(object2) && !(object2 instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i10, j10) {
      return times[i10] - times[j10];
    }
    const n10 = times.length;
    const result = new Array(n10);
    for (let i10 = 0; i10 !== n10; ++i10)
      result[i10] = i10;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i10 = 0, dstOffset = 0; dstOffset !== nValues; ++i10) {
      const srcOffset = order[i10] * stride;
      for (let j10 = 0; j10 !== stride; ++j10) {
        result[dstOffset++] = values[srcOffset + j10];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i10 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i10++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i10++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i10++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i10++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i10 = 0; i10 < clip.tracks.length; ++i10) {
      const track = clip.tracks[i10];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j10 = 0; j10 < track.times.length; ++j10) {
        const frame = track.times[j10] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j10]);
        for (let k10 = 0; k10 < valueSize; ++k10) {
          values.push(track.values[j10 * valueSize + k10]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i10 = 0; i10 < clip.tracks.length; ++i10) {
      if (minStartTime > clip.tracks[i10].times[0]) {
        minStartTime = clip.tracks[i10].times[0];
      }
    }
    for (let i10 = 0; i10 < clip.tracks.length; ++i10) {
      clip.tracks[i10].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i10 = 0; i10 < numTracks; ++i10) {
      const referenceTrack = referenceClip.tracks[i10];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j10 = 0; j10 < numTimes; ++j10) {
        const valueStart = j10 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k10 = 0; k10 < valueEnd; ++k10) {
            targetTrack.values[valueStart + k10] -= referenceValue[k10];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp2 = this.parameterPositions;
    let i12 = this._cachedIndex, t12 = pp2[i12], t02 = pp2[i12 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t12)) {
              for (let giveUpAt = i12 + 2; ; ) {
                if (t12 === void 0) {
                  if (t < t02)
                    break forward_scan;
                  i12 = pp2.length;
                  this._cachedIndex = i12;
                  return this.afterEnd_(i12 - 1, t, t02);
                }
                if (i12 === giveUpAt)
                  break;
                t02 = t12;
                t12 = pp2[++i12];
                if (t < t12) {
                  break seek;
                }
              }
              right = pp2.length;
              break linear_scan;
            }
          if (!(t >= t02)) {
            const t1global = pp2[1];
            if (t < t1global) {
              i12 = 2;
              t02 = t1global;
            }
            for (let giveUpAt = i12 - 2; ; ) {
              if (t02 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t12);
              }
              if (i12 === giveUpAt)
                break;
              t12 = t02;
              t02 = pp2[--i12 - 1];
              if (t >= t02) {
                break seek;
              }
            }
            right = i12;
            i12 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i12 < right) {
          const mid = i12 + right >>> 1;
          if (t < pp2[mid]) {
            right = mid;
          } else {
            i12 = mid + 1;
          }
        }
        t12 = pp2[i12];
        t02 = pp2[i12 - 1];
        if (t02 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t12);
        }
        if (t12 === void 0) {
          i12 = pp2.length;
          this._cachedIndex = i12;
          return this.afterEnd_(i12 - 1, t02, t);
        }
      }
      this._cachedIndex = i12;
      this.intervalChanged_(i12, t02, t12);
    }
    return this.interpolate_(i12, t02, t, t12);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
    for (let i10 = 0; i10 !== stride; ++i10) {
      result[i10] = values[offset + i10];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i12, t02, t12) {
    const pp2 = this.parameterPositions;
    let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp2[iPrev], tNext = pp2[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i12;
          tPrev = 2 * t02 - t12;
          break;
        case WrapAroundEnding:
          iPrev = pp2.length - 2;
          tPrev = t02 + pp2[iPrev] - pp2[iPrev + 1];
          break;
        default:
          iPrev = i12;
          tPrev = t12;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i12;
          tNext = 2 * t12 - t02;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t12 + pp2[1] - pp2[0];
          break;
        default:
          iNext = i12 - 1;
          tNext = t02;
      }
    }
    const halfDt = (t12 - t02) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t02 - tPrev);
    this._weightNext = halfDt / (tNext - t12);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o12 = i12 * stride, o02 = o12 - stride, oP2 = this._offsetPrev, oN2 = this._offsetNext, wP2 = this._weightPrev, wN2 = this._weightNext, p10 = (t - t02) / (t12 - t02), pp2 = p10 * p10, ppp = pp2 * p10;
    const sP2 = -wP2 * ppp + 2 * wP2 * pp2 - wP2 * p10;
    const s02 = (1 + wP2) * ppp + (-1.5 - 2 * wP2) * pp2 + (-0.5 + wP2) * p10 + 1;
    const s12 = (-1 - wN2) * ppp + (1.5 + wN2) * pp2 + 0.5 * p10;
    const sN2 = wN2 * ppp - wN2 * pp2;
    for (let i10 = 0; i10 !== stride; ++i10) {
      result[i10] = sP2 * values[oP2 + i10] + s02 * values[o02 + i10] + s12 * values[o12 + i10] + sN2 * values[oN2 + i10];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i12 * stride, offset0 = offset1 - stride, weight1 = (t - t02) / (t12 - t02), weight0 = 1 - weight1;
    for (let i10 = 0; i10 !== stride; ++i10) {
      result[i10] = values[offset0 + i10] * weight0 + values[offset1 + i10] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12) {
    return this.copySampleValue_(i12 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i10 = 0, n10 = times.length; i10 !== n10; ++i10) {
        times[i10] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i10 = 0, n10 = times.length; i10 !== n10; ++i10) {
        times[i10] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to2 = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to2 !== -1 && times[to2] > endTime) {
      --to2;
    }
    ++to2;
    if (from !== 0 || to2 !== nKeys) {
      if (from >= to2) {
        to2 = Math.max(to2, 1);
        from = to2 - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to2);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to2 * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i10 = 0; i10 !== nKeys; i10++) {
      const currTime = times[i10];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i10, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i10, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i10 = 0, n10 = values.length; i10 !== n10; ++i10) {
          const value = values[i10];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i10, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i10 = 1; i10 < lastIndex; ++i10) {
      let keep = false;
      const time = times[i10];
      const timeNext = times[i10 + 1];
      if (time !== timeNext && (i10 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i10 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j10 = 0; j10 !== stride; ++j10) {
            const value = values[offset + j10];
            if (value !== values[offsetP + j10] || value !== values[offsetN + j10]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i10 !== writeIndex) {
          times[writeIndex] = times[i10];
          const readOffset = i10 * stride, writeOffset = writeIndex * stride;
          for (let j10 = 0; j10 !== stride; ++j10) {
            values[writeOffset + j10] = values[readOffset + j10];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j10 = 0; j10 !== stride; ++j10) {
        values[writeOffset + j10] = values[readOffset + j10];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha2 = (t - t02) / (t12 - t02);
    let offset = i12 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha2);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i10 = 0, n10 = jsonTracks.length; i10 !== n10; ++i10) {
      tracks.push(parseKeyframeTrack(jsonTracks[i10]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i10 = 0, n10 = clipTracks.length; i10 !== n10; ++i10) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i10]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i10 = 0; i10 < numMorphTargets; i10++) {
      let times = [];
      let values = [];
      times.push((i10 + numMorphTargets - 1) % numMorphTargets, i10, (i10 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i10].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o10 = objectOrClipArray;
      clipArray = o10.geometry && o10.geometry.animations || o10.animations;
    }
    for (let i10 = 0; i10 < clipArray.length; i10++) {
      if (clipArray[i10].name === name) {
        return clipArray[i10];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i10 = 0, il2 = morphTargets.length; i10 < il2; i10++) {
      const morphTarget = morphTargets[i10];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h10 = 0; h10 < hierarchyTracks.length; h10++) {
      const animationKeys = hierarchyTracks[h10].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k10;
        for (k10 = 0; k10 < animationKeys.length; k10++) {
          if (animationKeys[k10].morphTargets) {
            for (let m10 = 0; m10 < animationKeys[k10].morphTargets.length; m10++) {
              morphTargetNames[animationKeys[k10].morphTargets[m10]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m10 = 0; m10 !== animationKeys[k10].morphTargets.length; ++m10) {
            const animationKey = animationKeys[k10];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h10].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i10 = 0, n10 = tracks.length; i10 !== n10; ++i10) {
      const track = this.tracks[i10];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i10 = 0; i10 < this.tracks.length; i10++) {
      this.tracks[i10].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i10 = 0; i10 < this.tracks.length; i10++) {
      valid = valid && this.tracks[i10].validate();
    }
    return valid;
  }
  optimize() {
    for (let i10 = 0; i10 < this.tracks.length; i10++) {
      this.tracks[i10].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i10 = 0; i10 < this.tracks.length; i10++) {
      tracks.push(this.tracks[i10].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index2 = handlers.indexOf(regex);
      if (index2 !== -1) {
        handlers.splice(index2, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i10 = 0, l10 = handlers.length; i10 < l10; i10 += 2) {
        const regex = handlers[i10];
        const loader = handlers[i10 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
var loading = {};
var FileLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached3 = Cache.get(url);
    if (cached3 !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached3);
        this.manager.itemEnd(url);
      }, 0);
      return cached3;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        return new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i10 = 0, il2 = callbacks.length; i10 < il2; i10++) {
                    const callback = callbacks[i10];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
      } else {
        throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((stream) => {
      const response = new Response(stream);
      switch (this.responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, this.mimeType);
          });
        case "json":
          return response.json();
        default:
          return response.text();
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i10 = 0, il2 = callbacks.length; i10 < il2; i10++) {
        const callback = callbacks[i10];
        if (callback.onLoad)
          callback.onLoad(data);
      }
      this.manager.itemEnd(url);
    }).catch((err) => {
      const callbacks = loading[url];
      delete loading[url];
      for (let i10 = 0, il2 = callbacks.length; i10 < il2; i10++) {
        const callback = callbacks[i10];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached3 = Cache.get(url);
    if (cached3 !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached3);
        scope.manager.itemEnd(url);
      }, 0);
      return cached3;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i10) {
      loader.load(urls[i10], function(image) {
        texture.images[i10] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i10 = 0; i10 < urls.length; ++i10) {
      loadTexture(i10);
    }
    return texture;
  }
};
var TextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera2) {
    this.camera = camera2;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light2) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light2.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light2.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object2 = {};
    if (this.bias !== 0)
      object2.bias = this.bias;
    if (this.normalBias !== 0)
      object2.normalBias = this.normalBias;
    if (this.radius !== 1)
      object2.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object2.mapSize = this.mapSize.toArray();
    object2.camera = this.camera.toJSON(false).object;
    delete object2.camera.matrix;
    return object2;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light2) {
    const camera2 = this.camera;
    const fov2 = RAD2DEG * 2 * light2.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light2.distance || camera2.far;
    if (fov2 !== camera2.fov || aspect2 !== camera2.aspect || far !== camera2.far) {
      camera2.fov = fov2;
      camera2.aspect = aspect2;
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    super.updateMatrices(light2);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance2 = 0, angle2 = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance2;
    this.angle = angle2;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light2, viewportIndex = 0) {
    const camera2 = this.camera;
    const shadowMatrix = this.matrix;
    const far = light2.distance || camera2.far;
    if (far !== camera2.far) {
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light2.matrixWorld);
    camera2.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera2.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera2.up.copy(this._cubeUps[viewportIndex]);
    camera2.lookAt(_lookTarget);
    camera2.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance2 = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance2;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].copy(coefficients[i10]);
    }
    return this;
  }
  zero() {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x10 = normal.x, y10 = normal.y, z10 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y10);
    target.addScaledVector(coeff[2], 0.488603 * z10);
    target.addScaledVector(coeff[3], 0.488603 * x10);
    target.addScaledVector(coeff[4], 1.092548 * (x10 * y10));
    target.addScaledVector(coeff[5], 1.092548 * (y10 * z10));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z10 * z10 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x10 * z10));
    target.addScaledVector(coeff[8], 0.546274 * (x10 * x10 - y10 * y10));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x10 = normal.x, y10 = normal.y, z10 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y10);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z10);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x10);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x10 * y10);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y10 * z10);
    target.addScaledVector(coeff[6], 0.743125 * z10 * z10 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x10 * z10);
    target.addScaledVector(coeff[8], 0.429043 * (x10 * x10 - y10 * y10));
    return target;
  }
  add(sh) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].add(sh.coefficients[i10]);
    }
    return this;
  }
  addScaledSH(sh, s10) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].addScaledVector(sh.coefficients[i10], s10);
    }
    return this;
  }
  scale(s10) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].multiplyScalar(s10);
    }
    return this;
  }
  lerp(sh, alpha2) {
    for (let i10 = 0; i10 < 9; i10++) {
      this.coefficients[i10].lerp(sh.coefficients[i10], alpha2);
    }
    return this;
  }
  equals(sh) {
    for (let i10 = 0; i10 < 9; i10++) {
      if (!this.coefficients[i10].equals(sh.coefficients[i10])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i10 = 0; i10 < 9; i10++) {
      coefficients[i10].fromArray(array, offset + i10 * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i10 = 0; i10 < 9; i10++) {
      coefficients[i10].toArray(array, offset + i10 * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x10 = normal.x, y10 = normal.y, z10 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y10;
    shBasis[2] = 0.488603 * z10;
    shBasis[3] = 0.488603 * x10;
    shBasis[4] = 1.092548 * x10 * y10;
    shBasis[5] = 1.092548 * y10 * z10;
    shBasis[6] = 0.315392 * (3 * z10 * z10 - 1);
    shBasis[7] = 1.092548 * x10 * z10;
    shBasis[8] = 0.546274 * (x10 * x10 - y10 * y10);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
LightProbe.prototype.isLightProbe = true;
var LoaderUtils = class {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s10 = "";
    for (let i10 = 0, il2 = array.length; i10 < il2; i10++) {
      s10 += String.fromCharCode(array[i10]);
    }
    try {
      return decodeURIComponent(escape(s10));
    } catch (e) {
      return s10;
    }
  }
  static extractUrlBase(url) {
    const index2 = url.lastIndexOf("/");
    if (index2 === -1)
      return "./";
    return url.substr(0, index2 + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
};
var InstancedBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
};
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
var ImageBitmapLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options4) {
    this.options = options4;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached3 = Cache.get(url);
    if (cached3 !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached3);
        scope.manager.itemEnd(url);
      }, 0);
      return cached3;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res2) {
      return res2.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
};
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c02 = Math.sqrt(Math.PI);
    const c12 = c02 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c02);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c12);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var Clock = class {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i10 = 1, l10 = this.filters.length; i10 < l10; i10++) {
        this.filters[i10 - 1].connect(this.filters[i10]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i10 = 1, l10 = this.filters.length; i10 < l10; i10++) {
        this.filters[i10 - 1].disconnect(this.filters[i10]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i10 = 0; i10 < data.length; i10++) {
      value += data[i10];
    }
    return value / data.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i10 = 0; i10 !== stride; ++i10) {
        buffer[offset + i10] = buffer[i10];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i10 = stride, e = stride + stride; i10 !== e; ++i10) {
      if (buffer[i10] !== buffer[i10 + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i10 = stride, e = originalValueOffset; i10 !== e; ++i10) {
      buffer[i10] = buffer[originalValueOffset + i10 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i10 = startIndex; i10 < endIndex; i10++) {
      this.buffer[i10] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i10 = 0; i10 < this.valueSize; i10++) {
      this.buffer[targetIndex + i10] = this.buffer[startIndex + i10];
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i10 = 0; i10 !== stride; ++i10) {
        buffer[dstOffset + i10] = buffer[srcOffset + i10];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s10 = 1 - t;
    for (let i10 = 0; i10 !== stride; ++i10) {
      const j10 = dstOffset + i10;
      buffer[j10] = buffer[j10] * s10 + buffer[srcOffset + i10] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i10 = 0; i10 !== stride; ++i10) {
      const j10 = dstOffset + i10;
      buffer[j10] = buffer[j10] + buffer[srcOffset + i10] * t;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i10 = this._targetGroup.nCachedObjects_, n10 = bindings.length; i10 !== n10; ++i10) {
      bindings[i10].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i10 = this._targetGroup.nCachedObjects_, n10 = bindings.length; i10 !== n10; ++i10) {
      bindings[i10].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i10 = this._targetGroup.nCachedObjects_, n10 = bindings.length; i10 !== n10; ++i10) {
      bindings[i10].unbind();
    }
  }
};
var PropertyBinding = class {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i10 = 0; i10 < children.length; i10++) {
          const childNode = children[i10];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i10 = 0, n10 = source.length; i10 !== n10; ++i10) {
      buffer[offset++] = source[i10];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i10 = 0, n10 = dest.length; i10 !== n10; ++i10) {
      dest[i10] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i10 = 0, n10 = dest.length; i10 !== n10; ++i10) {
      dest[i10] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i10 = 0, n10 = dest.length; i10 !== n10; ++i10) {
      dest[i10] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i10 = 0; i10 < targetObject.length; i10++) {
            if (targetObject[i10].name === objectIndex) {
              objectIndex = i10;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i10 = 0, n10 = arguments.length; i10 !== n10; ++i10) {
      indices[arguments[i10].uuid] = i10;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i10 = 0, n10 = arguments.length; i10 !== n10; ++i10) {
      const object2 = arguments[i10], uuid = object2.uuid;
      let index2 = indicesByUUID[uuid];
      if (index2 === void 0) {
        index2 = nObjects++;
        indicesByUUID[uuid] = index2;
        objects.push(object2);
        for (let j10 = 0, m10 = nBindings; j10 !== m10; ++j10) {
          bindings[j10].push(new PropertyBinding(object2, paths[j10], parsedPaths[j10]));
        }
      } else if (index2 < nCachedObjects) {
        knownObject = objects[index2];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index2;
        objects[index2] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object2;
        for (let j10 = 0, m10 = nBindings; j10 !== m10; ++j10) {
          const bindingsForPath = bindings[j10], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index2];
          bindingsForPath[index2] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object2, paths[j10], parsedPaths[j10]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index2] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i10 = 0, n10 = arguments.length; i10 !== n10; ++i10) {
      const object2 = arguments[i10], uuid = object2.uuid, index2 = indicesByUUID[uuid];
      if (index2 !== void 0 && index2 >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index2;
        objects[index2] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object2;
        for (let j10 = 0, m10 = nBindings; j10 !== m10; ++j10) {
          const bindingsForPath = bindings[j10], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
          bindingsForPath[index2] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i10 = 0, n10 = arguments.length; i10 !== n10; ++i10) {
      const object2 = arguments[i10], uuid = object2.uuid, index2 = indicesByUUID[uuid];
      if (index2 !== void 0) {
        delete indicesByUUID[uuid];
        if (index2 < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index2;
          objects[index2] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j10 = 0, m10 = nBindings; j10 !== m10; ++j10) {
            const bindingsForPath = bindings[j10], lastCached = bindingsForPath[firstActiveIndex], last10 = bindingsForPath[lastIndex];
            bindingsForPath[index2] = lastCached;
            bindingsForPath[firstActiveIndex] = last10;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index2;
          }
          objects[index2] = lastObject;
          objects.pop();
          for (let j10 = 0, m10 = nBindings; j10 !== m10; ++j10) {
            const bindingsForPath = bindings[j10];
            bindingsForPath[index2] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index2 = indicesByPath[path];
    const bindings = this._bindings;
    if (index2 !== void 0)
      return bindings[index2];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index2 = bindings.length;
    indicesByPath[path] = index2;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i10 = nCachedObjects, n10 = objects.length; i10 !== n10; ++i10) {
      const object2 = objects[i10];
      bindingsForPath[i10] = new PropertyBinding(object2, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path];
    if (index2 !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index2;
      bindings[index2] = lastBindings;
      bindings.pop();
      parsedPaths[index2] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index2] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i10 = 0; i10 !== nTracks; ++i10) {
      const interpolant = tracks[i10].createInterpolant(null);
      interpolants[i10] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    times[1] = now3 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j10 = 0, m10 = interpolants.length; j10 !== m10; ++j10) {
            interpolants[j10].evaluate(clipTime);
            propertyMixers[j10].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j10 = 0, m10 = interpolants.length; j10 !== m10; ++j10) {
            interpolants[j10].evaluate(clipTime);
            propertyMixers[j10].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now3 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    values[0] = weightNow;
    times[1] = now3 + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i10 = 0; i10 !== nTracks; ++i10) {
      const track = tracks[i10], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i10] = binding;
      } else {
        binding = bindings[i10];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i10].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i10] = binding;
      }
      interpolants[i10].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i10 = 0, n10 = bindings.length; i10 !== n10; ++i10) {
        const binding = bindings[i10];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i10 = 0, n10 = bindings.length; i10 !== n10; ++i10) {
        const binding = bindings[i10];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index2 = action._cacheIndex;
    return index2 !== null && index2 < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i10 = 0, n10 = bindings.length; i10 !== n10; ++i10) {
      const binding = bindings[i10];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i10 = nActions - 1; i10 >= 0; --i10) {
      actions[i10].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i10 = 0; i10 !== nActions; ++i10) {
      const action = actions[i10];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i10 = 0; i10 !== nBindings; ++i10) {
      bindings[i10].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i10 = 0; i10 < this._actions.length; i10++) {
      this._actions[i10].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i10 = 0, n10 = actionsToRemove.length; i10 !== n10; ++i10) {
        const action = actionsToRemove[i10];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib2 = super.clone(data);
    ib2.meshPerAttribute = this.meshPerAttribute;
    return ib2;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
};
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
var GLBufferAttribute = class {
  constructor(buffer, type, itemSize, elementSize, count2) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count2;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count2) {
    this.count = count2;
    return this;
  }
};
GLBufferAttribute.prototype.isGLBufferAttribute = true;
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v10) {
    return this.setFromCartesianCoords(v10.x, v10.y, v10.z);
  }
  setFromCartesianCoords(x10, y10, z10) {
    this.radius = Math.sqrt(x10 * x10 + y10 * y10 + z10 * z10);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x10, z10);
      this.phi = Math.acos(clamp(y10 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$4 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i10 = 0, il2 = points.length; i10 < il2; i10++) {
      this.expandByPoint(points[i10]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$4.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point2, target) {
    return target.set((point2.x - this.min.x) / (this.max.x - this.min.x), (point2.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    const clampedPoint = _vector$4.copy(point2).clamp(this.min, this.max);
    return clampedPoint.sub(point2).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point2, clampToLine) {
    _startP.subVectors(point2, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point2, clampToLine, target) {
    const t = this.closestPointToPointParameter(point2, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$2 = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix4();
var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object2) {
    const bones = getBoneList(object2);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i10 = 0; i10 < bones.length; i10++) {
      const bone = bones[i10];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object2;
    this.bones = bones;
    this.matrix = object2.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i10 = 0, j10 = 0; i10 < bones.length; i10++) {
      const bone = bones[i10];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j10, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j10 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j10 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object2) {
  const boneList = [];
  if (object2 && object2.isBone) {
    boneList.push(object2);
  }
  for (let i10 = 0; i10 < object2.children.length; i10++) {
    boneList.push.apply(boneList, getBoneList(object2.children[i10]));
  }
  return boneList;
}
var GridHelper = class extends LineSegments {
  constructor(size2 = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size2 / divisions;
    const halfSize = size2 / 2;
    const vertices = [], colors = [];
    for (let i10 = 0, j10 = 0, k10 = -halfSize; i10 <= divisions; i10++, k10 += step) {
      vertices.push(-halfSize, 0, k10, halfSize, 0, k10);
      vertices.push(k10, 0, -halfSize, k10, 0, halfSize);
      const color = i10 === center ? color1 : color2;
      color.toArray(colors, j10);
      j10 += 3;
      color.toArray(colors, j10);
      j10 += 3;
      color.toArray(colors, j10);
      j10 += 3;
      color.toArray(colors, j10);
      j10 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m10) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m10);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m10) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m10);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q10) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q10);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v10) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v10.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point2, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point2, a10, b10, c10, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point2, a10, b10, c10, target);
};
Triangle.normal = function(a10, b10, c10, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a10, b10, c10, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options4) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options4);
};
Shape.prototype.makeGeometry = function(options4) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options4);
};
Vector2.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector2.prototype.distanceToManhattan = function(v10) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v10);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m10) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m10);
};
Vector3.prototype.getScaleFromMatrix = function(m10) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m10);
};
Vector3.prototype.getColumnFromMatrix = function(index2, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index2);
};
Vector3.prototype.applyProjection = function(m10) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m10);
};
Vector3.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector3.prototype.distanceToManhattan = function(v10) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v10);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance2, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance2);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index2) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index2);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count2, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count2);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
  return this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer2, scene2) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer2, scene2);
};
CubeCamera.prototype.clear = function(renderer2, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer2, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/libs/stats.module.js
var Stats = function() {
  var mode = 0;
  var container = document.createElement("div");
  container.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  container.addEventListener("click", function(event) {
    event.preventDefault();
    showPanel(++mode % container.children.length);
  }, false);
  function addPanel(panel) {
    container.appendChild(panel.dom);
    return panel;
  }
  function showPanel(id2) {
    for (var i10 = 0; i10 < container.children.length; i10++) {
      container.children[i10].style.display = i10 === id2 ? "block" : "none";
    }
    mode = id2;
  }
  var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
  var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
  var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) {
    var memPanel = addPanel(new Stats.Panel("MB", "#f08", "#201"));
  }
  showPanel(0);
  return {
    REVISION: 16,
    dom: container,
    addPanel,
    showPanel,
    begin: function() {
      beginTime = (performance || Date).now();
    },
    end: function() {
      frames++;
      var time = (performance || Date).now();
      msPanel.update(time - beginTime, 200);
      if (time >= prevTime + 1e3) {
        fpsPanel.update(frames * 1e3 / (time - prevTime), 100);
        prevTime = time;
        frames = 0;
        if (memPanel) {
          var memory = performance.memory;
          memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
        }
      }
      return time;
    },
    update: function() {
      beginTime = this.end();
    },
    domElement: container,
    setMode: showPanel
  };
};
Stats.Panel = function(name, fg2, bg2) {
  var min = Infinity, max = 0, round = Math.round;
  var PR2 = round(window.devicePixelRatio || 1);
  var WIDTH = 80 * PR2, HEIGHT = 48 * PR2, TEXT_X = 3 * PR2, TEXT_Y = 2 * PR2, GRAPH_X = 3 * PR2, GRAPH_Y = 15 * PR2, GRAPH_WIDTH = 74 * PR2, GRAPH_HEIGHT = 30 * PR2;
  var canvas3 = document.createElement("canvas");
  canvas3.width = WIDTH;
  canvas3.height = HEIGHT;
  canvas3.style.cssText = "width:80px;height:48px";
  var context = canvas3.getContext("2d");
  context.font = "bold " + 9 * PR2 + "px Helvetica,Arial,sans-serif";
  context.textBaseline = "top";
  context.fillStyle = bg2;
  context.fillRect(0, 0, WIDTH, HEIGHT);
  context.fillStyle = fg2;
  context.fillText(name, TEXT_X, TEXT_Y);
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  context.fillStyle = bg2;
  context.globalAlpha = 0.9;
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  return {
    dom: canvas3,
    update: function(value, maxValue) {
      min = Math.min(min, value);
      max = Math.max(max, value);
      context.fillStyle = bg2;
      context.globalAlpha = 1;
      context.fillRect(0, 0, WIDTH, GRAPH_Y);
      context.fillStyle = fg2;
      context.fillText(round(value) + " " + name + " (" + round(min) + "-" + round(max) + ")", TEXT_X, TEXT_Y);
      context.drawImage(canvas3, GRAPH_X + PR2, GRAPH_Y, GRAPH_WIDTH - PR2, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR2, GRAPH_HEIGHT);
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR2, GRAPH_Y, PR2, GRAPH_HEIGHT);
      context.fillStyle = bg2;
      context.globalAlpha = 0.9;
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR2, GRAPH_Y, PR2, round((1 - value / maxValue) * GRAPH_HEIGHT));
    }
  };
};
var stats_module_default = Stats;

// node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object2, domElement) {
    super();
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object2;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object2.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update2() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale2;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale2 = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale2 = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle2) {
      sphericalDelta.theta -= angle2;
    }
    function rotateUp(angle2) {
      sphericalDelta.phi -= angle2;
    }
    const panLeft = function() {
      const v10 = new Vector3();
      return function panLeft2(distance2, objectMatrix) {
        v10.setFromMatrixColumn(objectMatrix, 0);
        v10.multiplyScalar(-distance2);
        panOffset.add(v10);
      };
    }();
    const panUp = function() {
      const v10 = new Vector3();
      return function panUp2(distance2, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v10.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v10.setFromMatrixColumn(objectMatrix, 0);
          v10.crossVectors(scope.object.up, v10);
        }
        v10.multiplyScalar(distance2);
        panOffset.add(v10);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x10 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y10 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x10, y10);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x10 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y10 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x10, y10);
      }
    }
    function handleTouchStartDolly() {
      const dx2 = pointers[0].pageX - pointers[1].pageX;
      const dy2 = pointers[0].pageY - pointers[1].pageY;
      const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      dollyStart.set(0, distance2);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x10 = 0.5 * (event.pageX + position.x);
        const y10 = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x10, y10);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x10 = 0.5 * (event.pageX + position.x);
        const y10 = 0.5 * (event.pageY + position.y);
        panEnd.set(x10, y10);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx2 = event.pageX - position.x;
      const dy2 = event.pageY - position.y;
      const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      dollyEnd.set(0, distance2);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i10 = 0; i10 < pointers.length; i10++) {
        if (pointers[i10].pointerId == event.pointerId) {
          pointers.splice(i10, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions2 = {};
    const plugins = {};
    if (typeof data === "string") {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions2[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        content = extensions2[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json = JSON.parse(content);
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i10 = 0; i10 < this.pluginCallbacks.length; i10++) {
      const plugin = this.pluginCallbacks[i10](parser);
      plugins[plugin.name] = plugin;
      extensions2[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i10 = 0; i10 < json.extensionsUsed.length; ++i10) {
        const extensionName = json.extensionsUsed[i10];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions2[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions2[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions2[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions2[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions2[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions2);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object2) {
      objects[key] = object2;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions2 = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions2.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light2) {
      return parser._getNodeRef(self2.cache, lightIndex, light2);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale2 = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale2, scale2);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture).then(function(texture) {
        texture.encoding = sRGBEncoding;
      }));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const source = json.images[extension.source];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index2) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index2];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function(res2) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count2 = extensionDef.count;
        const stride = extensionDef.byteStride;
        const result = new ArrayBuffer(count2 * stride);
        const source = new Uint8Array(res2[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count2, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if (transform.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshStandardSGMaterial = class extends MeshStandardMaterial {
  constructor(params) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;
    const specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    const glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    const specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    const glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    const lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.roughness += geometryRoughness;",
      "material.roughness = min( material.roughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    const uniforms = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v10) {
          uniforms.specular.value = v10;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v10) {
          uniforms.specularMap.value = v10;
          if (v10) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v10) {
          uniforms.glossiness.value = v10;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v10) {
          uniforms.glossinessMap.value = v10;
          if (v10) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
};
var GLTFMaterialsPbrSpecularGlossinessExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
    }
    materialParams.emissive = new Color(0, 0, 0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
    materialParams.specular = new Color(1, 1, 1);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === void 0 ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1;
    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
    material.aoMapIntensity = 1;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = 1;
    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
    material.envMapIntensity = 1;
    material.refractionRatio = 0.98;
    return material;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index2 * valueSize * 3 + valueSize;
    for (let i10 = 0; i10 !== valueSize; i10++) {
      result[i10] = values[offset + i10];
    }
    return result;
  }
};
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i12, t02, t, t12) {
  const result = this.resultBuffer;
  const values = this.sampleValues;
  const stride = this.valueSize;
  const stride2 = stride * 2;
  const stride3 = stride * 3;
  const td2 = t12 - t02;
  const p10 = (t - t02) / td2;
  const pp2 = p10 * p10;
  const ppp = pp2 * p10;
  const offset1 = i12 * stride3;
  const offset0 = offset1 - stride3;
  const s22 = -2 * ppp + 3 * pp2;
  const s32 = ppp - pp2;
  const s02 = 1 - s22;
  const s12 = s32 - pp2 + p10;
  for (let i10 = 0; i10 !== stride; i10++) {
    const p02 = values[offset0 + i10 + stride];
    const m02 = values[offset0 + i10 + stride2] * td2;
    const p12 = values[offset1 + i10 + stride];
    const m12 = values[offset1 + i10] * td2;
    result[i10] = s02 * p02 + s12 * m02 + s22 * p12 + s32 * m12;
  }
  return result;
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i12, t02, t, t12) {
    const result = super.interpolate_(i12, t02, t, t12);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache7) {
  if (cache7["DefaultMaterial"] === void 0) {
    cache7["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache7["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object2, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object2.userData.gltfExtensions = object2.userData.gltfExtensions || {};
      object2.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object2, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object2.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  for (let i10 = 0, il2 = targets.length; i10 < il2; i10++) {
    const target = targets[i10];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  for (let i10 = 0, il2 = targets.length; i10 < il2; i10++) {
    const target = targets[i10];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i10 = 0, il2 = meshDef.weights.length; i10 < il2; i10++) {
      mesh.morphTargetInfluences[i10] = meshDef.weights[i10];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i10 = 0, il2 = targetNames.length; i10 < il2; i10++) {
        mesh.morphTargetDictionary[targetNames[i10]] = i10;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i10 = 0, il2 = keys.length; i10 < il2; i10++) {
    attributesKey += keys[i10] + ":" + attributes[keys[i10]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
var GLTFParser = class {
  constructor(json = {}, options4 = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options4;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.textureCache = {};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions2) {
    this.extensions = extensions2;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions2 = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions2, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i10 = 0, il2 = joints.length; i10 < il2; i10++) {
        nodeDefs[joints[i10]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  _addNodeRef(cache7, index2) {
    if (index2 === void 0)
      return;
    if (cache7.refs[index2] === void 0) {
      cache7.refs[index2] = cache7.uses[index2] = 0;
    }
    cache7.refs[index2]++;
  }
  _getNodeRef(cache7, index2, object2) {
    if (cache7.refs[index2] <= 1)
      return object2;
    const ref = object2.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i10, child] of original.children.entries()) {
        updateMappings(child, clone.children[i10]);
      }
    };
    updateMappings(object2, ref);
    ref.name += "_instance_" + cache7.uses[index2]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions2 = Object.values(this.plugins);
    extensions2.push(this);
    for (let i10 = 0; i10 < extensions2.length; i10++) {
      const result = func(extensions2[i10]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions2 = Object.values(this.plugins);
    extensions2.unshift(this);
    const pending = [];
    for (let i10 = 0; i10 < extensions2.length; i10++) {
      const result = func(extensions2[i10]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  getDependency(type, index2) {
    const cacheKey = type + ":" + index2;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index2);
          break;
        case "node":
          dependency = this.loadNode(index2);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index2);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index2);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index2);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index2);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index2);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index2);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index2);
          break;
        case "animation":
          dependency = this.loadAnimation(index2);
          break;
        case "camera":
          dependency = this.loadCamera(index2);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index2) {
        return parser.getDependency(type, index2);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options4 = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options4.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib2 = parser.cache.get(ibCacheKey);
        if (!ib2) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib2 = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib2);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib2, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i10 = 0, il2 = sparseIndices.length; i10 < il2; i10++) {
          const index2 = sparseIndices[i10];
          bufferAttribute.setX(index2, sparseValues[i10 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index2, sparseValues[i10 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index2, sparseValues[i10 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index2, sparseValues[i10 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  loadTexture(textureIndex) {
    const json = this.json;
    const options4 = this.options;
    const textureDef = json.textures[textureIndex];
    const source = json.images[textureDef.source];
    let loader = this.textureLoader;
    if (source.uri) {
      const handler = options4.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  }
  loadTextureImage(textureIndex, source, loader) {
    const parser = this;
    const json = this.json;
    const options4 = this.options;
    const textureDef = json.textures[textureIndex];
    const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = source.uri || "";
    let isObjectURL = false;
    if (source.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: source.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options4.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  assignTexture(materialParams, mapName, mapDef) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions2 = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions2[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions2[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.format = RGBFormat;
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale2 = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale2, scale2);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions2[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions2, material, materialDef);
      return material;
    });
  }
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    let name = sanitizedName;
    for (let i10 = 1; this.nodeNamesUsed[name]; ++i10) {
      name = sanitizedName + "_" + i10;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }
  loadGeometries(primitives) {
    const parser = this;
    const extensions2 = this.extensions;
    const cache7 = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions2[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i10 = 0, il2 = primitives.length; i10 < il2; i10++) {
      const primitive = primitives[i10];
      const cacheKey = createPrimitiveKey(primitive);
      const cached3 = cache7[cacheKey];
      if (cached3) {
        pending.push(cached3.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache7[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions2 = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i10 = 0, il2 = primitives.length; i10 < il2; i10++) {
      const material = primitives[i10].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i10].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i10 = 0, il2 = geometries.length; i10 < il2; i10++) {
        const geometry = geometries[i10];
        const primitive = primitives[i10];
        let mesh;
        const material = materials[i10];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions2, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i10 = 0, il2 = meshes.length; i10 < il2; i10++) {
        parser.associations.set(meshes[i10], {
          meshes: meshIndex,
          primitives: i10
        });
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      parser.associations.set(group, { meshes: meshIndex });
      for (let i10 = 0, il2 = meshes.length; i10 < il2; i10++) {
        group.add(meshes[i10]);
      }
      return group;
    });
  }
  loadCamera(cameraIndex) {
    let camera2;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera2 = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera2 = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera2.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera2, cameraDef);
    return Promise.resolve(camera2);
  }
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = { joints: skinDef.joints };
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i10 = 0, il2 = animationDef.channels.length; i10 < il2; i10++) {
      const channel = animationDef.channels[i10];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node !== void 0 ? target.node : target.id;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i10 = 0, il2 = nodes.length; i10 < il2; i10++) {
        const node = nodes[i10];
        const inputAccessor = inputAccessors[i10];
        const outputAccessor = outputAccessors[i10];
        const sampler = samplers[i10];
        const target = targets[i10];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object2) {
            if (object2.morphTargetInfluences) {
              targetNames.push(object2.name ? object2.name : object2.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale2 = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j10 = 0, jl2 = outputArray.length; j10 < jl2; j10++) {
            scaled[j10] = outputArray[j10] * scale2;
          }
          outputArray = scaled;
        }
        for (let j10 = 0, jl2 = targetNames.length; j10 < jl2; j10++) {
          const track = new TypedKeyframeTrack(targetNames[j10] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o10) {
          if (!o10.isMesh)
            return;
          for (let i10 = 0, il2 = nodeDef.weights.length; i10 < il2; i10++) {
            o10.morphTargetInfluences[i10] = nodeDef.weights[i10];
          }
        });
      }
      return node;
    });
  }
  loadNode(nodeIndex) {
    const json = this.json;
    const extensions2 = this.extensions;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera2) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera2);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i10 = 0, il2 = objects.length; i10 < il2; i10++) {
          node.add(objects[i10]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions2, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
  }
  loadScene(sceneIndex) {
    const json = this.json;
    const extensions2 = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene2 = new Group();
    if (sceneDef.name)
      scene2.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene2, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions2, scene2, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i10 = 0, il2 = nodeIds.length; i10 < il2; i10++) {
      pending.push(buildNodeHierarchy(nodeIds[i10], scene2, json, parser));
    }
    return Promise.all(pending).then(function() {
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene2);
      return scene2;
    });
  }
};
function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId];
  return parser.getDependency("node", nodeId).then(function(node) {
    if (nodeDef.skin === void 0)
      return node;
    let skinEntry;
    return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i10 = 0, il2 = skinEntry.joints.length; i10 < il2; i10++) {
        pendingJoints.push(parser.getDependency("node", skinEntry.joints[i10]));
      }
      return Promise.all(pendingJoints);
    }).then(function(jointNodes) {
      node.traverse(function(mesh) {
        if (!mesh.isMesh)
          return;
        const bones = [];
        const boneInverses = [];
        for (let j10 = 0, jl2 = jointNodes.length; j10 < jl2; j10++) {
          const jointNode = jointNodes[j10];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== void 0) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j10 * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j10]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function(node) {
    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i10 = 0, il2 = children.length; i10 < il2; i10++) {
        const child = children[i10];
        pending.push(buildNodeHierarchy(child, node, json, parser));
      }
    }
    return Promise.all(pending);
  });
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i10 = 0, il2 = targets.length; i10 < il2; i10++) {
      const target = targets[i10];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
function toTrianglesDrawMode(geometry, drawMode) {
  let index2 = geometry.getIndex();
  if (index2 === null) {
    const indices = [];
    const position = geometry.getAttribute("position");
    if (position !== void 0) {
      for (let i10 = 0; i10 < position.count; i10++) {
        indices.push(i10);
      }
      geometry.setIndex(indices);
      index2 = geometry.getIndex();
    } else {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
      return geometry;
    }
  }
  const numberOfTriangles = index2.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    for (let i10 = 1; i10 <= numberOfTriangles; i10++) {
      newIndices.push(index2.getX(0));
      newIndices.push(index2.getX(i10));
      newIndices.push(index2.getX(i10 + 1));
    }
  } else {
    for (let i10 = 0; i10 < numberOfTriangles; i10++) {
      if (i10 % 2 === 0) {
        newIndices.push(index2.getX(i10));
        newIndices.push(index2.getX(i10 + 1));
        newIndices.push(index2.getX(i10 + 2));
      } else {
        newIndices.push(index2.getX(i10 + 2));
        newIndices.push(index2.getX(i10 + 1));
        newIndices.push(index2.getX(i10));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  }
  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}

// node_modules/.pnpm/@pixiv+three-vrm@0.6.10_1c0fd3ffb8aed43fd3c3a32e01fd986c/node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js
function n(e, t, n10, i10) {
  return new (n10 || (n10 = Promise))(function(r10, o10) {
    function s10(e10) {
      try {
        l10(i10.next(e10));
      } catch (e11) {
        o10(e11);
      }
    }
    function a10(e10) {
      try {
        l10(i10.throw(e10));
      } catch (e11) {
        o10(e11);
      }
    }
    function l10(e10) {
      var t10;
      e10.done ? r10(e10.value) : (t10 = e10.value, t10 instanceof n10 ? t10 : new n10(function(e11) {
        e11(t10);
      })).then(s10, a10);
    }
    l10((i10 = i10.apply(e, t || [])).next());
  });
}
function i(e) {
  Object.keys(e).forEach((t) => {
    const n10 = e[t];
    if (n10 == null ? void 0 : n10.isTexture) {
      n10.dispose();
    }
  }), e.dispose();
}
function r(e) {
  const t = e.geometry;
  t && t.dispose();
  const n10 = e.material;
  n10 && (Array.isArray(n10) ? n10.forEach((e10) => i(e10)) : n10 && i(n10));
}
var o;
!function(e) {
  e[e.NUMBER = 0] = "NUMBER", e[e.VECTOR2 = 1] = "VECTOR2", e[e.VECTOR3 = 2] = "VECTOR3", e[e.VECTOR4 = 3] = "VECTOR4", e[e.COLOR = 4] = "COLOR";
}(o || (o = {}));
var s = new Vector2();
var a = new Vector3();
var l = new Vector4();
var d = new Color();
var h = class extends Object3D {
  constructor(e) {
    super(), this.weight = 0, this.isBinary = false, this._binds = [], this._materialValues = [], this.name = `BlendShapeController_${e}`, this.type = "BlendShapeController", this.visible = false;
  }
  addBind(e) {
    const t = e.weight / 100;
    this._binds.push({ meshes: e.meshes, morphTargetIndex: e.morphTargetIndex, weight: t });
  }
  addMaterialValue(t) {
    const n10 = t.material, i10 = t.propertyName;
    let r10, s10, a10, l10, d10 = n10[i10];
    d10 && (d10 = t.defaultValue || d10, d10.isVector2 ? (r10 = o.VECTOR2, s10 = d10.clone(), a10 = new Vector2().fromArray(t.targetValue), l10 = a10.clone().sub(s10)) : d10.isVector3 ? (r10 = o.VECTOR3, s10 = d10.clone(), a10 = new Vector3().fromArray(t.targetValue), l10 = a10.clone().sub(s10)) : d10.isVector4 ? (r10 = o.VECTOR4, s10 = d10.clone(), a10 = new Vector4().fromArray([t.targetValue[2], t.targetValue[3], t.targetValue[0], t.targetValue[1]]), l10 = a10.clone().sub(s10)) : d10.isColor ? (r10 = o.COLOR, s10 = d10.clone(), a10 = new Color().fromArray(t.targetValue), l10 = a10.clone().sub(s10)) : (r10 = o.NUMBER, s10 = d10, a10 = t.targetValue[0], l10 = a10 - s10), this._materialValues.push({ material: n10, propertyName: i10, defaultValue: s10, targetValue: a10, deltaValue: l10, type: r10 }));
  }
  applyWeight() {
    const e = this.isBinary ? this.weight < 0.5 ? 0 : 1 : this.weight;
    this._binds.forEach((t) => {
      t.meshes.forEach((n10) => {
        n10.morphTargetInfluences && (n10.morphTargetInfluences[t.morphTargetIndex] += e * t.weight);
      });
    }), this._materialValues.forEach((t) => {
      if (t.material[t.propertyName] !== void 0) {
        if (t.type === o.NUMBER) {
          const n10 = t.deltaValue;
          t.material[t.propertyName] += n10 * e;
        } else if (t.type === o.VECTOR2) {
          const n10 = t.deltaValue;
          t.material[t.propertyName].add(s.copy(n10).multiplyScalar(e));
        } else if (t.type === o.VECTOR3) {
          const n10 = t.deltaValue;
          t.material[t.propertyName].add(a.copy(n10).multiplyScalar(e));
        } else if (t.type === o.VECTOR4) {
          const n10 = t.deltaValue;
          t.material[t.propertyName].add(l.copy(n10).multiplyScalar(e));
        } else if (t.type === o.COLOR) {
          const n10 = t.deltaValue;
          t.material[t.propertyName].add(d.copy(n10).multiplyScalar(e));
        }
        typeof t.material.shouldApplyUniforms == "boolean" && (t.material.shouldApplyUniforms = true);
      }
    });
  }
  clearAppliedWeight() {
    this._binds.forEach((e) => {
      e.meshes.forEach((t) => {
        t.morphTargetInfluences && (t.morphTargetInfluences[e.morphTargetIndex] = 0);
      });
    }), this._materialValues.forEach((e) => {
      if (e.material[e.propertyName] !== void 0) {
        if (e.type === o.NUMBER) {
          const t = e.defaultValue;
          e.material[e.propertyName] = t;
        } else if (e.type === o.VECTOR2) {
          const t = e.defaultValue;
          e.material[e.propertyName].copy(t);
        } else if (e.type === o.VECTOR3) {
          const t = e.defaultValue;
          e.material[e.propertyName].copy(t);
        } else if (e.type === o.VECTOR4) {
          const t = e.defaultValue;
          e.material[e.propertyName].copy(t);
        } else if (e.type === o.COLOR) {
          const t = e.defaultValue;
          e.material[e.propertyName].copy(t);
        }
        typeof e.material.shouldApplyUniforms == "boolean" && (e.material.shouldApplyUniforms = true);
      }
    });
  }
};
var u;
function c(e, t, n10) {
  const i10 = e.parser.json.nodes[t].mesh;
  if (i10 == null)
    return null;
  const r10 = e.parser.json.meshes[i10].primitives.length, o10 = [];
  return n10.traverse((e10) => {
    o10.length < r10 && e10.isMesh && o10.push(e10);
  }), o10;
}
function p(e) {
  return n(this, void 0, void 0, function* () {
    const t = yield e.parser.getDependencies("node"), n10 = /* @__PURE__ */ new Map();
    return t.forEach((t10, i10) => {
      const r10 = c(e, i10, t10);
      r10 != null && n10.set(i10, r10);
    }), n10;
  });
}
function m(e) {
  return e[0] !== "_" ? (console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`), e) : (e = e.substring(1), /[A-Z]/.test(e[0]) ? e[0].toLowerCase() + e.substring(1) : (console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`), e));
}
!function(e) {
  var t, n10, i10, r10, o10, s10;
  (t = e.BlendShapePresetName || (e.BlendShapePresetName = {})).A = "a", t.Angry = "angry", t.Blink = "blink", t.BlinkL = "blink_l", t.BlinkR = "blink_r", t.E = "e", t.Fun = "fun", t.I = "i", t.Joy = "joy", t.Lookdown = "lookdown", t.Lookleft = "lookleft", t.Lookright = "lookright", t.Lookup = "lookup", t.Neutral = "neutral", t.O = "o", t.Sorrow = "sorrow", t.U = "u", t.Unknown = "unknown", (n10 = e.FirstPersonLookAtTypeName || (e.FirstPersonLookAtTypeName = {})).BlendShape = "BlendShape", n10.Bone = "Bone", (i10 = e.HumanoidBoneName || (e.HumanoidBoneName = {})).Chest = "chest", i10.Head = "head", i10.Hips = "hips", i10.Jaw = "jaw", i10.LeftEye = "leftEye", i10.LeftFoot = "leftFoot", i10.LeftHand = "leftHand", i10.LeftIndexDistal = "leftIndexDistal", i10.LeftIndexIntermediate = "leftIndexIntermediate", i10.LeftIndexProximal = "leftIndexProximal", i10.LeftLittleDistal = "leftLittleDistal", i10.LeftLittleIntermediate = "leftLittleIntermediate", i10.LeftLittleProximal = "leftLittleProximal", i10.LeftLowerArm = "leftLowerArm", i10.LeftLowerLeg = "leftLowerLeg", i10.LeftMiddleDistal = "leftMiddleDistal", i10.LeftMiddleIntermediate = "leftMiddleIntermediate", i10.LeftMiddleProximal = "leftMiddleProximal", i10.LeftRingDistal = "leftRingDistal", i10.LeftRingIntermediate = "leftRingIntermediate", i10.LeftRingProximal = "leftRingProximal", i10.LeftShoulder = "leftShoulder", i10.LeftThumbDistal = "leftThumbDistal", i10.LeftThumbIntermediate = "leftThumbIntermediate", i10.LeftThumbProximal = "leftThumbProximal", i10.LeftToes = "leftToes", i10.LeftUpperArm = "leftUpperArm", i10.LeftUpperLeg = "leftUpperLeg", i10.Neck = "neck", i10.RightEye = "rightEye", i10.RightFoot = "rightFoot", i10.RightHand = "rightHand", i10.RightIndexDistal = "rightIndexDistal", i10.RightIndexIntermediate = "rightIndexIntermediate", i10.RightIndexProximal = "rightIndexProximal", i10.RightLittleDistal = "rightLittleDistal", i10.RightLittleIntermediate = "rightLittleIntermediate", i10.RightLittleProximal = "rightLittleProximal", i10.RightLowerArm = "rightLowerArm", i10.RightLowerLeg = "rightLowerLeg", i10.RightMiddleDistal = "rightMiddleDistal", i10.RightMiddleIntermediate = "rightMiddleIntermediate", i10.RightMiddleProximal = "rightMiddleProximal", i10.RightRingDistal = "rightRingDistal", i10.RightRingIntermediate = "rightRingIntermediate", i10.RightRingProximal = "rightRingProximal", i10.RightShoulder = "rightShoulder", i10.RightThumbDistal = "rightThumbDistal", i10.RightThumbIntermediate = "rightThumbIntermediate", i10.RightThumbProximal = "rightThumbProximal", i10.RightToes = "rightToes", i10.RightUpperArm = "rightUpperArm", i10.RightUpperLeg = "rightUpperLeg", i10.Spine = "spine", i10.UpperChest = "upperChest", (r10 = e.MetaAllowedUserName || (e.MetaAllowedUserName = {})).Everyone = "Everyone", r10.ExplicitlyLicensedPerson = "ExplicitlyLicensedPerson", r10.OnlyAuthor = "OnlyAuthor", (o10 = e.MetaUssageName || (e.MetaUssageName = {})).Allow = "Allow", o10.Disallow = "Disallow", (s10 = e.MetaLicenseName || (e.MetaLicenseName = {})).Cc0 = "CC0", s10.CcBy = "CC_BY", s10.CcByNc = "CC_BY_NC", s10.CcByNcNd = "CC_BY_NC_ND", s10.CcByNcSa = "CC_BY_NC_SA", s10.CcByNd = "CC_BY_ND", s10.CcBySa = "CC_BY_SA", s10.Other = "Other", s10.RedistributionProhibited = "Redistribution_Prohibited";
}(u || (u = {}));
var f = new Vector3();
var g = new Vector3();
function _(e, t) {
  return e.matrixWorld.decompose(f, t, g), t;
}
new Quaternion();
var v = class {
  constructor() {
    this._blendShapeGroups = {}, this._blendShapePresetMap = {}, this._unknownGroupNames = [];
  }
  get expressions() {
    return Object.keys(this._blendShapeGroups);
  }
  get blendShapePresetMap() {
    return this._blendShapePresetMap;
  }
  get unknownGroupNames() {
    return this._unknownGroupNames;
  }
  getBlendShapeGroup(e) {
    const t = this._blendShapePresetMap[e], n10 = t ? this._blendShapeGroups[t] : this._blendShapeGroups[e];
    if (n10)
      return n10;
    console.warn(`no blend shape found by ${e}`);
  }
  registerBlendShapeGroup(e, t, n10) {
    this._blendShapeGroups[e] = n10, t ? this._blendShapePresetMap[t] = e : this._unknownGroupNames.push(e);
  }
  getValue(e) {
    var t;
    const n10 = this.getBlendShapeGroup(e);
    return (t = n10 == null ? void 0 : n10.weight) !== null && t !== void 0 ? t : null;
  }
  setValue(e, t) {
    const n10 = this.getBlendShapeGroup(e);
    var i10;
    n10 && (n10.weight = (i10 = t, Math.max(Math.min(i10, 1), 0)));
  }
  getBlendShapeTrackName(e) {
    const t = this.getBlendShapeGroup(e);
    return t ? `${t.name}.weight` : null;
  }
  update() {
    Object.keys(this._blendShapeGroups).forEach((e) => {
      this._blendShapeGroups[e].clearAppliedWeight();
    }), Object.keys(this._blendShapeGroups).forEach((e) => {
      this._blendShapeGroups[e].applyWeight();
    });
  }
};
var T = class {
  import(e) {
    var t;
    return n(this, void 0, void 0, function* () {
      const i10 = (t = e.parser.json.extensions) === null || t === void 0 ? void 0 : t.VRM;
      if (!i10)
        return null;
      const r10 = i10.blendShapeMaster;
      if (!r10)
        return null;
      const o10 = new v(), s10 = r10.blendShapeGroups;
      if (!s10)
        return o10;
      const a10 = {};
      return yield Promise.all(s10.map((t10) => n(this, void 0, void 0, function* () {
        const i11 = t10.name;
        if (i11 === void 0)
          return void console.warn("VRMBlendShapeImporter: One of blendShapeGroups has no name");
        let r11;
        t10.presetName && t10.presetName !== u.BlendShapePresetName.Unknown && !a10[t10.presetName] && (r11 = t10.presetName, a10[t10.presetName] = i11);
        const s11 = new h(i11);
        e.scene.add(s11), s11.isBinary = t10.isBinary || false, t10.binds && t10.binds.forEach((i12) => n(this, void 0, void 0, function* () {
          if (i12.mesh === void 0 || i12.index === void 0)
            return;
          const r12 = [];
          e.parser.json.nodes.forEach((e10, t11) => {
            e10.mesh === i12.mesh && r12.push(t11);
          });
          const o11 = i12.index;
          yield Promise.all(r12.map((r13) => n(this, void 0, void 0, function* () {
            var a11;
            const l11 = yield function(e10, t11) {
              return n(this, void 0, void 0, function* () {
                const n10 = yield e10.parser.getDependency("node", t11);
                return c(e10, t11, n10);
              });
            }(e, r13);
            l11.every((e10) => Array.isArray(e10.morphTargetInfluences) && o11 < e10.morphTargetInfluences.length) ? s11.addBind({ meshes: l11, morphTargetIndex: o11, weight: (a11 = i12.weight) !== null && a11 !== void 0 ? a11 : 100 }) : console.warn(`VRMBlendShapeImporter: ${t10.name} attempts to index ${o11}th morph but not found.`);
          })));
        }));
        const l10 = t10.materialValues;
        l10 && l10.forEach((t11) => {
          if (t11.materialName === void 0 || t11.propertyName === void 0 || t11.targetValue === void 0)
            return;
          const n10 = [];
          e.scene.traverse((e10) => {
            if (e10.material) {
              const i12 = e10.material;
              Array.isArray(i12) ? n10.push(...i12.filter((e11) => e11.name === t11.materialName && n10.indexOf(e11) === -1)) : i12.name === t11.materialName && n10.indexOf(i12) === -1 && n10.push(i12);
            }
          }), n10.forEach((e10) => {
            s11.addMaterialValue({ material: e10, propertyName: m(t11.propertyName), targetValue: t11.targetValue });
          });
        }), o10.registerBlendShapeGroup(i11, r11, s11);
      }))), o10;
    });
  }
};
var y = Object.freeze(new Vector3(0, 0, -1));
var x = new Quaternion();
var S;
!function(e) {
  e[e.Auto = 0] = "Auto", e[e.Both = 1] = "Both", e[e.ThirdPersonOnly = 2] = "ThirdPersonOnly", e[e.FirstPersonOnly = 3] = "FirstPersonOnly";
}(S || (S = {}));
var M = class {
  constructor(e, t) {
    this.firstPersonFlag = M._parseFirstPersonFlag(e), this.primitives = t;
  }
  static _parseFirstPersonFlag(e) {
    switch (e) {
      case "Both":
        return S.Both;
      case "ThirdPersonOnly":
        return S.ThirdPersonOnly;
      case "FirstPersonOnly":
        return S.FirstPersonOnly;
      default:
        return S.Auto;
    }
  }
};
var E = class {
  constructor(e, t, n10) {
    this._meshAnnotations = [], this._firstPersonOnlyLayer = E._DEFAULT_FIRSTPERSON_ONLY_LAYER, this._thirdPersonOnlyLayer = E._DEFAULT_THIRDPERSON_ONLY_LAYER, this._initialized = false, this._firstPersonBone = e, this._firstPersonBoneOffset = t, this._meshAnnotations = n10;
  }
  get firstPersonBone() {
    return this._firstPersonBone;
  }
  get meshAnnotations() {
    return this._meshAnnotations;
  }
  getFirstPersonWorldDirection(e) {
    return e.copy(y).applyQuaternion(_(this._firstPersonBone, x));
  }
  get firstPersonOnlyLayer() {
    return this._firstPersonOnlyLayer;
  }
  get thirdPersonOnlyLayer() {
    return this._thirdPersonOnlyLayer;
  }
  getFirstPersonBoneOffset(e) {
    return e.copy(this._firstPersonBoneOffset);
  }
  getFirstPersonWorldPosition(t) {
    const n10 = this._firstPersonBoneOffset, i10 = new Vector4(n10.x, n10.y, n10.z, 1);
    return i10.applyMatrix4(this._firstPersonBone.matrixWorld), t.set(i10.x, i10.y, i10.z);
  }
  setup({ firstPersonOnlyLayer: e = E._DEFAULT_FIRSTPERSON_ONLY_LAYER, thirdPersonOnlyLayer: t = E._DEFAULT_THIRDPERSON_ONLY_LAYER } = {}) {
    this._initialized || (this._initialized = true, this._firstPersonOnlyLayer = e, this._thirdPersonOnlyLayer = t, this._meshAnnotations.forEach((e10) => {
      e10.firstPersonFlag === S.FirstPersonOnly ? e10.primitives.forEach((e11) => {
        e11.layers.set(this._firstPersonOnlyLayer);
      }) : e10.firstPersonFlag === S.ThirdPersonOnly ? e10.primitives.forEach((e11) => {
        e11.layers.set(this._thirdPersonOnlyLayer);
      }) : e10.firstPersonFlag === S.Auto && this._createHeadlessModel(e10.primitives);
    }));
  }
  _excludeTriangles(e, t, n10, i10) {
    let r10 = 0;
    if (t != null && t.length > 0)
      for (let o10 = 0; o10 < e.length; o10 += 3) {
        const s10 = e[o10], a10 = e[o10 + 1], l10 = e[o10 + 2], d10 = t[s10], h10 = n10[s10];
        if (d10[0] > 0 && i10.includes(h10[0]))
          continue;
        if (d10[1] > 0 && i10.includes(h10[1]))
          continue;
        if (d10[2] > 0 && i10.includes(h10[2]))
          continue;
        if (d10[3] > 0 && i10.includes(h10[3]))
          continue;
        const u10 = t[a10], c10 = n10[a10];
        if (u10[0] > 0 && i10.includes(c10[0]))
          continue;
        if (u10[1] > 0 && i10.includes(c10[1]))
          continue;
        if (u10[2] > 0 && i10.includes(c10[2]))
          continue;
        if (u10[3] > 0 && i10.includes(c10[3]))
          continue;
        const p10 = t[l10], m10 = n10[l10];
        p10[0] > 0 && i10.includes(m10[0]) || (p10[1] > 0 && i10.includes(m10[1]) || p10[2] > 0 && i10.includes(m10[2]) || p10[3] > 0 && i10.includes(m10[3]) || (e[r10++] = s10, e[r10++] = a10, e[r10++] = l10));
      }
    return r10;
  }
  _createErasedMesh(t, n10) {
    const i10 = new SkinnedMesh(t.geometry.clone(), t.material);
    i10.name = `${t.name}(erase)`, i10.frustumCulled = t.frustumCulled, i10.layers.set(this._firstPersonOnlyLayer);
    const r10 = i10.geometry, o10 = r10.getAttribute("skinIndex").array, s10 = [];
    for (let e = 0; e < o10.length; e += 4)
      s10.push([o10[e], o10[e + 1], o10[e + 2], o10[e + 3]]);
    const a10 = r10.getAttribute("skinWeight").array, l10 = [];
    for (let e = 0; e < a10.length; e += 4)
      l10.push([a10[e], a10[e + 1], a10[e + 2], a10[e + 3]]);
    const d10 = r10.getIndex();
    if (!d10)
      throw new Error("The geometry doesn't have an index buffer");
    const h10 = Array.from(d10.array), u10 = this._excludeTriangles(h10, l10, s10, n10), c10 = [];
    for (let e = 0; e < u10; e++)
      c10[e] = h10[e];
    return r10.setIndex(c10), t.onBeforeRender && (i10.onBeforeRender = t.onBeforeRender), i10.bind(new Skeleton(t.skeleton.bones, t.skeleton.boneInverses), new Matrix4()), i10;
  }
  _createHeadlessModelForSkinnedMesh(e, t) {
    const n10 = [];
    if (t.skeleton.bones.forEach((e10, t10) => {
      this._isEraseTarget(e10) && n10.push(t10);
    }), !n10.length)
      return t.layers.enable(this._thirdPersonOnlyLayer), void t.layers.enable(this._firstPersonOnlyLayer);
    t.layers.set(this._thirdPersonOnlyLayer);
    const i10 = this._createErasedMesh(t, n10);
    e.add(i10);
  }
  _createHeadlessModel(e) {
    e.forEach((e10) => {
      if (e10.type === "SkinnedMesh") {
        const t = e10;
        this._createHeadlessModelForSkinnedMesh(t.parent, t);
      } else
        this._isEraseTarget(e10) && e10.layers.set(this._thirdPersonOnlyLayer);
    });
  }
  _isEraseTarget(e) {
    return e === this._firstPersonBone || !!e.parent && this._isEraseTarget(e.parent);
  }
};
E._DEFAULT_FIRSTPERSON_ONLY_LAYER = 9, E._DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
var L = class {
  import(t, i10) {
    var r10;
    return n(this, void 0, void 0, function* () {
      const n10 = (r10 = t.parser.json.extensions) === null || r10 === void 0 ? void 0 : r10.VRM;
      if (!n10)
        return null;
      const o10 = n10.firstPerson;
      if (!o10)
        return null;
      const s10 = o10.firstPersonBone;
      let a10;
      if (a10 = s10 === void 0 || s10 === -1 ? i10.getBoneNode(u.HumanoidBoneName.Head) : yield t.parser.getDependency("node", s10), !a10)
        return console.warn("VRMFirstPersonImporter: Could not find firstPersonBone of the VRM"), null;
      const l10 = o10.firstPersonBoneOffset ? new Vector3(o10.firstPersonBoneOffset.x, o10.firstPersonBoneOffset.y, -o10.firstPersonBoneOffset.z) : new Vector3(0, 0.06, 0), d10 = [], h10 = yield p(t);
      return Array.from(h10.entries()).forEach(([e, n11]) => {
        const i11 = t.parser.json.nodes[e], r11 = o10.meshAnnotations ? o10.meshAnnotations.find((e10) => e10.mesh === i11.mesh) : void 0;
        d10.push(new M(r11 == null ? void 0 : r11.firstPersonFlag, n11));
      }), new E(a10, l10, d10);
    });
  }
};
var R = class {
  constructor(e, t) {
    this.node = e, this.humanLimit = t;
  }
};
function w(e) {
  return e.invert ? e.invert() : e.inverse(), e;
}
var P = new Vector3();
var A = new Quaternion();
var b = class {
  constructor(e, t) {
    this.restPose = {}, this.humanBones = this._createHumanBones(e), this.humanDescription = t, this.restPose = this.getPose();
  }
  getPose() {
    const e = {};
    return Object.keys(this.humanBones).forEach((t) => {
      const n10 = this.getBoneNode(t);
      if (!n10)
        return;
      if (e[t])
        return;
      P.set(0, 0, 0), A.identity();
      const i10 = this.restPose[t];
      (i10 == null ? void 0 : i10.position) && P.fromArray(i10.position).negate(), (i10 == null ? void 0 : i10.rotation) && w(A.fromArray(i10.rotation)), P.add(n10.position), A.premultiply(n10.quaternion), e[t] = { position: P.toArray(), rotation: A.toArray() };
    }, {}), e;
  }
  setPose(e) {
    Object.keys(e).forEach((t) => {
      const n10 = e[t], i10 = this.getBoneNode(t);
      if (!i10)
        return;
      const r10 = this.restPose[t];
      r10 && (n10.position && (i10.position.fromArray(n10.position), r10.position && i10.position.add(P.fromArray(r10.position))), n10.rotation && (i10.quaternion.fromArray(n10.rotation), r10.rotation && i10.quaternion.multiply(A.fromArray(r10.rotation))));
    });
  }
  resetPose() {
    Object.entries(this.restPose).forEach(([e, t]) => {
      const n10 = this.getBoneNode(e);
      n10 && ((t == null ? void 0 : t.position) && n10.position.fromArray(t.position), (t == null ? void 0 : t.rotation) && n10.quaternion.fromArray(t.rotation));
    });
  }
  getBone(e) {
    var t;
    return (t = this.humanBones[e][0]) !== null && t !== void 0 ? t : void 0;
  }
  getBones(e) {
    var t;
    return (t = this.humanBones[e]) !== null && t !== void 0 ? t : [];
  }
  getBoneNode(e) {
    var t, n10;
    return (n10 = (t = this.humanBones[e][0]) === null || t === void 0 ? void 0 : t.node) !== null && n10 !== void 0 ? n10 : null;
  }
  getBoneNodes(e) {
    var t, n10;
    return (n10 = (t = this.humanBones[e]) === null || t === void 0 ? void 0 : t.map((e10) => e10.node)) !== null && n10 !== void 0 ? n10 : [];
  }
  _createHumanBones(e) {
    const t = Object.values(u.HumanoidBoneName).reduce((e10, t10) => (e10[t10] = [], e10), {});
    return e.forEach((e10) => {
      t[e10.name].push(e10.bone);
    }), t;
  }
};
var I = class {
  import(t) {
    var i10;
    return n(this, void 0, void 0, function* () {
      const r10 = (i10 = t.parser.json.extensions) === null || i10 === void 0 ? void 0 : i10.VRM;
      if (!r10)
        return null;
      const o10 = r10.humanoid;
      if (!o10)
        return null;
      const s10 = [];
      o10.humanBones && (yield Promise.all(o10.humanBones.map((i11) => n(this, void 0, void 0, function* () {
        if (!i11.bone || i11.node == null)
          return;
        const n10 = yield t.parser.getDependency("node", i11.node);
        s10.push({ name: i11.bone, bone: new R(n10, { axisLength: i11.axisLength, center: i11.center && new Vector3(i11.center.x, i11.center.y, i11.center.z), max: i11.max && new Vector3(i11.max.x, i11.max.y, i11.max.z), min: i11.min && new Vector3(i11.min.x, i11.min.y, i11.min.z), useDefaultValues: i11.useDefaultValues }) });
      }))));
      const a10 = { armStretch: o10.armStretch, legStretch: o10.legStretch, upperArmTwist: o10.upperArmTwist, lowerArmTwist: o10.lowerArmTwist, upperLegTwist: o10.upperLegTwist, lowerLegTwist: o10.lowerLegTwist, feetSpacing: o10.feetSpacing, hasTranslationDoF: o10.hasTranslationDoF };
      return new b(s10, a10);
    });
  }
};
var O = class {
  constructor(e, t, n10) {
    this.curve = [0, 0, 0, 1, 1, 1, 1, 0], this.curveXRangeDegree = 90, this.curveYRangeDegree = 10, e !== void 0 && (this.curveXRangeDegree = e), t !== void 0 && (this.curveYRangeDegree = t), n10 !== void 0 && (this.curve = n10);
  }
  map(e) {
    const t = Math.min(Math.max(e, 0), this.curveXRangeDegree) / this.curveXRangeDegree;
    return this.curveYRangeDegree * ((e10, t10) => {
      if (e10.length < 8)
        throw new Error("evaluateCurve: Invalid curve detected! (Array length must be 8 at least)");
      if (e10.length % 4 != 0)
        throw new Error("evaluateCurve: Invalid curve detected! (Array length must be multiples of 4");
      let n10;
      for (n10 = 0; ; n10++) {
        if (e10.length <= 4 * n10)
          return e10[4 * n10 - 3];
        if (t10 <= e10[4 * n10])
          break;
      }
      const i10 = n10 - 1;
      if (i10 < 0)
        return e10[4 * i10 + 5];
      const r10 = e10[4 * i10], o10 = (t10 - r10) / (e10[4 * n10] - r10);
      return ((e11, t11, n11, i11, r11) => {
        const o11 = r11 * r11 * r11, s10 = r11 * r11;
        return e11 + (t11 - e11) * (-2 * o11 + 3 * s10) + n11 * (o11 - 2 * s10 + r11) + i11 * (o11 - s10);
      })(e10[4 * i10 + 1], e10[4 * n10 + 1], e10[4 * i10 + 3], e10[4 * n10 + 2], o10);
    })(this.curve, t);
  }
};
var C = class {
};
var N = class extends C {
  constructor(e, t, n10, i10) {
    super(), this.type = u.FirstPersonLookAtTypeName.BlendShape, this._curveHorizontal = t, this._curveVerticalDown = n10, this._curveVerticalUp = i10, this._blendShapeProxy = e;
  }
  name() {
    return u.FirstPersonLookAtTypeName.BlendShape;
  }
  lookAt(e) {
    const t = e.x, n10 = e.y;
    t < 0 ? (this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookup, 0), this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-t))) : (this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookdown, 0), this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookup, this._curveVerticalUp.map(t))), n10 < 0 ? (this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookleft, 0), this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookright, this._curveHorizontal.map(-n10))) : (this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookright, 0), this._blendShapeProxy.setValue(u.BlendShapePresetName.Lookleft, this._curveHorizontal.map(n10)));
  }
};
var D = Object.freeze(new Vector3(0, 0, -1));
var U = new Vector3();
var V = new Vector3();
var B = new Vector3();
var G = new Quaternion();
var H = class {
  constructor(t, n10) {
    this.autoUpdate = true, this._euler = new Euler(0, 0, 0, H.EULER_ORDER), this.firstPerson = t, this.applyer = n10;
  }
  getLookAtWorldDirection(e) {
    const t = _(this.firstPerson.firstPersonBone, G);
    return e.copy(D).applyEuler(this._euler).applyQuaternion(t);
  }
  lookAt(e) {
    this._calcEuler(this._euler, e), this.applyer && this.applyer.lookAt(this._euler);
  }
  update(e) {
    this.target && this.autoUpdate && (this.lookAt(this.target.getWorldPosition(U)), this.applyer && this.applyer.lookAt(this._euler));
  }
  _calcEuler(e, t) {
    const n10 = this.firstPerson.getFirstPersonWorldPosition(V), i10 = B.copy(t).sub(n10).normalize();
    return i10.applyQuaternion(w(_(this.firstPerson.firstPersonBone, G))), e.x = Math.atan2(i10.y, Math.sqrt(i10.x * i10.x + i10.z * i10.z)), e.y = Math.atan2(-i10.x, -i10.z), e;
  }
};
H.EULER_ORDER = "YXZ";
var F = new Euler(0, 0, 0, H.EULER_ORDER);
var k = class extends C {
  constructor(e, t, n10, i10, r10) {
    super(), this.type = u.FirstPersonLookAtTypeName.Bone, this._curveHorizontalInner = t, this._curveHorizontalOuter = n10, this._curveVerticalDown = i10, this._curveVerticalUp = r10, this._leftEye = e.getBoneNode(u.HumanoidBoneName.LeftEye), this._rightEye = e.getBoneNode(u.HumanoidBoneName.RightEye);
  }
  lookAt(e) {
    const t = e.x, n10 = e.y;
    this._leftEye && (F.x = t < 0 ? -this._curveVerticalDown.map(-t) : this._curveVerticalUp.map(t), F.y = n10 < 0 ? -this._curveHorizontalInner.map(-n10) : this._curveHorizontalOuter.map(n10), this._leftEye.quaternion.setFromEuler(F)), this._rightEye && (F.x = t < 0 ? -this._curveVerticalDown.map(-t) : this._curveVerticalUp.map(t), F.y = n10 < 0 ? -this._curveHorizontalOuter.map(-n10) : this._curveHorizontalInner.map(n10), this._rightEye.quaternion.setFromEuler(F));
  }
};
var W = Math.PI / 180;
var z = class {
  import(e, t, n10, i10) {
    var r10;
    const o10 = (r10 = e.parser.json.extensions) === null || r10 === void 0 ? void 0 : r10.VRM;
    if (!o10)
      return null;
    const s10 = o10.firstPerson;
    if (!s10)
      return null;
    const a10 = this._importApplyer(s10, n10, i10);
    return new H(t, a10 || void 0);
  }
  _importApplyer(e, t, n10) {
    const i10 = e.lookAtHorizontalInner, r10 = e.lookAtHorizontalOuter, o10 = e.lookAtVerticalDown, s10 = e.lookAtVerticalUp;
    switch (e.lookAtTypeName) {
      case u.FirstPersonLookAtTypeName.Bone:
        return i10 === void 0 || r10 === void 0 || o10 === void 0 || s10 === void 0 ? null : new k(n10, this._importCurveMapperBone(i10), this._importCurveMapperBone(r10), this._importCurveMapperBone(o10), this._importCurveMapperBone(s10));
      case u.FirstPersonLookAtTypeName.BlendShape:
        return r10 === void 0 || o10 === void 0 || s10 === void 0 ? null : new N(t, this._importCurveMapperBlendShape(r10), this._importCurveMapperBlendShape(o10), this._importCurveMapperBlendShape(s10));
      default:
        return null;
    }
  }
  _importCurveMapperBone(e) {
    return new O(typeof e.xRange == "number" ? W * e.xRange : void 0, typeof e.yRange == "number" ? W * e.yRange : void 0, e.curve);
  }
  _importCurveMapperBlendShape(e) {
    return new O(typeof e.xRange == "number" ? W * e.xRange : void 0, e.yRange, e.curve);
  }
};
var j = '// #define PHONG\n\n#ifdef BLENDMODE_CUTOUT\n  uniform float cutoff;\n#endif\n\nuniform vec3 color;\nuniform float colorAlpha;\nuniform vec3 shadeColor;\n#ifdef USE_SHADETEXTURE\n  uniform sampler2D shadeTexture;\n#endif\n\nuniform float receiveShadowRate;\n#ifdef USE_RECEIVESHADOWTEXTURE\n  uniform sampler2D receiveShadowTexture;\n#endif\n\nuniform float shadingGradeRate;\n#ifdef USE_SHADINGGRADETEXTURE\n  uniform sampler2D shadingGradeTexture;\n#endif\n\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\n\n#ifdef USE_RIMTEXTURE\n  uniform sampler2D rimTexture;\n#endif\nuniform vec3 rimColor;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\n\n#ifdef USE_SPHEREADD\n  uniform sampler2D sphereAdd;\n#endif\n\nuniform vec3 emissionColor;\n\nuniform vec3 outlineColor;\nuniform float outlineLightingMix;\n\n#ifdef USE_UVANIMMASKTEXTURE\n  uniform sampler2D uvAnimMaskTexture;\n#endif\n\nuniform float uvAnimOffsetX;\nuniform float uvAnimOffsetY;\nuniform float uvAnimTheta;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n#include <lights_pars_begin>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingGrade;\n  float receiveShadow;\n};\n\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126\n  // See: #21205, #21307, #21299\n  #if THREE_VRM_THREE_REVISION >= 126\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      S = normalize( S );\n      T = normalize( T );\n      vec3 N = normalize( surf_norm );\n\n      #ifdef DOUBLE_SIDED\n\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\n      #else\n\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n      mat3 tsn = mat3( S, T, N );\n      return normalize( tsn * mapN );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == lighting stuff ===========================================================\nfloat getLightIntensity(\n  const in IncidentLight directLight,\n  const in GeometricContext geometry,\n  const in float shadow,\n  const in float shadingGrade\n) {\n  float lightIntensity = dot( geometry.normal, directLight.direction );\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\n  lightIntensity = lightIntensity * shadow;\n  lightIntensity = lightIntensity * shadingGrade;\n  lightIntensity = lightIntensity * 2.0 - 1.0;\n  return shadeToony == 1.0\n    ? step( shadeShift, lightIntensity )\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\n}\n\nvec3 getLighting( const in vec3 lightColor ) {\n  vec3 lighting = lightColor;\n  lighting = mix(\n    lighting,\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\n    lightColorAttenuation\n  );\n\n  #if THREE_VRM_THREE_REVISION < 132\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lighting *= PI;\n    #endif\n  #endif\n\n  return lighting;\n}\n\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float lightIntensity,\n  const in vec3 lighting\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( lightIntensity * lighting ) );\n  #endif\n\n  return lighting * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\n}\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMMASKTEXTURE\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\n    #endif\n\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( color, colorAlpha );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissionColor;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    #if THREE_VRM_THREE_REVISION >= 137\n      vec4 sampledDiffuseColor = texture2D( map, uv );\n      #ifdef DECODE_VIDEO_TEXTURE\n        sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n      #endif\n      diffuseColor *= sampledDiffuseColor;\n    #else\n      // COMPAT: pre-r137\n      diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\n    #endif\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // -- MToon: alpha -----------------------------------------------------------\n  // #include <alphatest_fragment>\n  #ifdef BLENDMODE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef BLENDMODE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  #ifdef OBJECTSPACE_NORMALMAP\n\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = normal * faceDirection;\n\n      #else\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  #elif defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    #ifdef USE_TANGENT\n\n      normal = normalize( vTBN * mapN );\n\n    #else\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n      #else\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\n\n      #endif\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    #if THREE_VRM_THREE_REVISION >= 137\n      totalEmissiveRadiance *= texture2D( emissiveMap, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\n    #endif\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColor;\n  #ifdef USE_SHADETEXTURE\n    #if THREE_VRM_THREE_REVISION >= 137\n      material.shadeColor *= texture2D( shadeTexture, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\n    #endif\n  #endif\n\n  material.shadingGrade = 1.0;\n  #ifdef USE_SHADINGGRADETEXTURE\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\n  #endif\n\n  material.receiveShadow = receiveShadowRate;\n  #ifdef USE_RECEIVESHADOWTEXTURE\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\n  #endif\n\n  // #include <lights_fragment_begin>\n  GeometricContext geometry;\n\n  geometry.position = - vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n  IncidentLight directLight;\n  vec3 lightingSum = vec3( 0.0 );\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float atten, shadow, lightIntensity;\n  vec3 lighting;\n\n  #if ( NUM_POINT_LIGHTS > 0 )\n    PointLight pointLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n      pointLight = pointLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getPointLightInfo( pointLight, geometry, directLight );\n      #else\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 )\n    SpotLight spotLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #else\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 )\n    DirectionalLight directionalLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      directionalLight = directionalLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #else\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  // #if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n  #if THREE_VRM_THREE_REVISION >= 133\n    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  #else\n    irradiance += getLightProbeIrradiance( lightProbe, geometry );\n  #endif\n  #if ( NUM_HEMI_LIGHTS > 0 )\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n    }\n    #pragma unroll_loop_end\n  #endif\n  // #endif\n\n  // #include <lights_fragment_maps>\n  #ifdef USE_LIGHTMAP\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n    #if THREE_VRM_THREE_REVISION >= 137\n      vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n    #else\n      // COMPAT: pre-r137\n      vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n    #endif\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lightMapIrradiance *= PI;\n    #endif\n    irradiance += lightMapIrradiance;\n  #endif\n\n  // #include <lights_fragment_end>\n  // RE_IndirectDiffuse here\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Lambert( material.diffuseColor );\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  // The "comment out if you want to PBR absolutely" line\n  #ifndef DEBUG_LITSHADERATE\n    col = min(col, material.diffuseColor);\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\n    gl_FragColor = vec4(\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\n      diffuseColor.a\n    );\n    postCorrection();\n    return;\n  #endif\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: parametric rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\n  #ifdef USE_RIMTEXTURE\n    #if THREE_VRM_THREE_REVISION >= 137\n      rim *= texture2D( rimTexture, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\n    #endif\n  #endif\n  col += rim;\n\n  // -- MToon: additive matcap -------------------------------------------------\n  #ifdef USE_SPHEREADD\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      #if THREE_VRM_THREE_REVISION >= 137\n        vec3 matcap = texture2D( sphereAdd, sphereUv ).xyz;\n      #else\n        // COMPAT: pre-r137\n        vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\n      #endif\n      col += matcap;\n    }\n  #endif\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}';
var Y = (t, n10) => {
  const i10 = ((t10) => {
    if (parseInt(REVISION, 10) >= 136)
      switch (t10) {
        case LinearEncoding:
          return ["Linear", "( value )"];
        case sRGBEncoding:
          return ["sRGB", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t10), ["Linear", "( value )"];
      }
    else
      switch (t10) {
        case LinearEncoding:
          return ["Linear", "( value )"];
        case sRGBEncoding:
          return ["sRGB", "( value )"];
        case 3002:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case 3007:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
          throw new Error("unsupported encoding: " + t10);
      }
  })(n10);
  return "vec4 " + t + "( vec4 value ) { return " + i10[0] + "ToLinear" + i10[1] + "; }";
};
var X = 2 * Math.PI;
var q;
var Q;
var Z;
var $;
var J;
!function(e) {
  e[e.Off = 0] = "Off", e[e.Front = 1] = "Front", e[e.Back = 2] = "Back";
}(q || (q = {})), function(e) {
  e[e.None = 0] = "None", e[e.Normal = 1] = "Normal", e[e.LitShadeRate = 2] = "LitShadeRate", e[e.UV = 3] = "UV";
}(Q || (Q = {})), function(e) {
  e[e.FixedColor = 0] = "FixedColor", e[e.MixedLighting = 1] = "MixedLighting";
}(Z || (Z = {})), function(e) {
  e[e.None = 0] = "None", e[e.WorldCoordinates = 1] = "WorldCoordinates", e[e.ScreenCoordinates = 2] = "ScreenCoordinates";
}($ || ($ = {})), function(e) {
  e[e.Opaque = 0] = "Opaque", e[e.Cutout = 1] = "Cutout", e[e.Transparent = 2] = "Transparent", e[e.TransparentWithZWrite = 3] = "TransparentWithZWrite";
}(J || (J = {}));
var K = class extends ShaderMaterial {
  constructor(t = {}) {
    super(), this.isMToonMaterial = true, this.cutoff = 0.5, this.color = new Vector4(1, 1, 1, 1), this.shadeColor = new Vector4(0.97, 0.81, 0.86, 1), this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this.shadeTexture = null, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.receiveShadowRate = 1, this.receiveShadowTexture = null, this.shadingGradeRate = 1, this.shadingGradeTexture = null, this.shadeShift = 0, this.shadeToony = 0.9, this.lightColorAttenuation = 0, this.indirectLightIntensity = 0.1, this.rimTexture = null, this.rimColor = new Vector4(0, 0, 0, 1), this.rimLightingMix = 0, this.rimFresnelPower = 1, this.rimLift = 0, this.sphereAdd = null, this.emissionColor = new Vector4(0, 0, 0, 1), this.emissiveMap = null, this.outlineWidthTexture = null, this.outlineWidth = 0.5, this.outlineScaledMaxDistance = 1, this.outlineColor = new Vector4(0, 0, 0, 1), this.outlineLightingMix = 1, this.uvAnimMaskTexture = null, this.uvAnimScrollX = 0, this.uvAnimScrollY = 0, this.uvAnimRotation = 0, this.shouldApplyUniforms = true, this._debugMode = Q.None, this._blendMode = J.Opaque, this._outlineWidthMode = $.None, this._outlineColorMode = Z.FixedColor, this._cullMode = q.Back, this._outlineCullMode = q.Front, this._isOutline = false, this._uvAnimOffsetX = 0, this._uvAnimOffsetY = 0, this._uvAnimPhase = 0, this.encoding = t.encoding || LinearEncoding, this.encoding !== LinearEncoding && this.encoding !== sRGBEncoding && console.warn("The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead."), ["mToonVersion", "shadeTexture_ST", "bumpMap_ST", "receiveShadowTexture_ST", "shadingGradeTexture_ST", "rimTexture_ST", "sphereAdd_ST", "emissionMap_ST", "outlineWidthTexture_ST", "uvAnimMaskTexture_ST", "srcBlend", "dstBlend"].forEach((e) => {
      t[e] !== void 0 && delete t[e];
    }), t.fog = true, t.lights = true, t.clipping = true, parseInt(REVISION, 10) < 129 && (t.skinning = t.skinning || false), parseInt(REVISION, 10) < 131 && (t.morphTargets = t.morphTargets || false, t.morphNormals = t.morphNormals || false), t.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.normalmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { cutoff: { value: 0.5 }, color: { value: new Color(1, 1, 1) }, colorAlpha: { value: 1 }, shadeColor: { value: new Color(0.97, 0.81, 0.86) }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) }, shadeTexture: { value: null }, receiveShadowRate: { value: 1 }, receiveShadowTexture: { value: null }, shadingGradeRate: { value: 1 }, shadingGradeTexture: { value: null }, shadeShift: { value: 0 }, shadeToony: { value: 0.9 }, lightColorAttenuation: { value: 0 }, indirectLightIntensity: { value: 0.1 }, rimTexture: { value: null }, rimColor: { value: new Color(0, 0, 0) }, rimLightingMix: { value: 0 }, rimFresnelPower: { value: 1 }, rimLift: { value: 0 }, sphereAdd: { value: null }, emissionColor: { value: new Color(0, 0, 0) }, outlineWidthTexture: { value: null }, outlineWidth: { value: 0.5 }, outlineScaledMaxDistance: { value: 1 }, outlineColor: { value: new Color(0, 0, 0) }, outlineLightingMix: { value: 1 }, uvAnimMaskTexture: { value: null }, uvAnimOffsetX: { value: 0 }, uvAnimOffsetY: { value: 0 }, uvAnimTheta: { value: 0 } }]), this.setValues(t), this._updateShaderCode(), this._applyUniforms();
  }
  get mainTex() {
    return this.map;
  }
  set mainTex(e) {
    this.map = e;
  }
  get bumpMap() {
    return this.normalMap;
  }
  set bumpMap(e) {
    this.normalMap = e;
  }
  get bumpScale() {
    return this.normalScale.x;
  }
  set bumpScale(e) {
    this.normalScale.set(e, e);
  }
  get emissionMap() {
    return this.emissiveMap;
  }
  set emissionMap(e) {
    this.emissiveMap = e;
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(e) {
    this._blendMode = e, this.depthWrite = this._blendMode !== J.Transparent, this.transparent = this._blendMode === J.Transparent || this._blendMode === J.TransparentWithZWrite, this._updateShaderCode();
  }
  get debugMode() {
    return this._debugMode;
  }
  set debugMode(e) {
    this._debugMode = e, this._updateShaderCode();
  }
  get outlineWidthMode() {
    return this._outlineWidthMode;
  }
  set outlineWidthMode(e) {
    this._outlineWidthMode = e, this._updateShaderCode();
  }
  get outlineColorMode() {
    return this._outlineColorMode;
  }
  set outlineColorMode(e) {
    this._outlineColorMode = e, this._updateShaderCode();
  }
  get cullMode() {
    return this._cullMode;
  }
  set cullMode(e) {
    this._cullMode = e, this._updateCullFace();
  }
  get outlineCullMode() {
    return this._outlineCullMode;
  }
  set outlineCullMode(e) {
    this._outlineCullMode = e, this._updateCullFace();
  }
  get zWrite() {
    return this.depthWrite ? 1 : 0;
  }
  set zWrite(e) {
    this.depthWrite = 0.5 <= e;
  }
  get isOutline() {
    return this._isOutline;
  }
  set isOutline(e) {
    this._isOutline = e, this._updateShaderCode(), this._updateCullFace();
  }
  updateVRMMaterials(e) {
    this._uvAnimOffsetX = this._uvAnimOffsetX + e * this.uvAnimScrollX, this._uvAnimOffsetY = this._uvAnimOffsetY - e * this.uvAnimScrollY, this._uvAnimPhase = this._uvAnimPhase + e * this.uvAnimRotation, this._applyUniforms();
  }
  copy(e) {
    return super.copy(e), this.cutoff = e.cutoff, this.color.copy(e.color), this.shadeColor.copy(e.shadeColor), this.map = e.map, this.mainTex_ST.copy(e.mainTex_ST), this.shadeTexture = e.shadeTexture, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(this.normalScale), this.receiveShadowRate = e.receiveShadowRate, this.receiveShadowTexture = e.receiveShadowTexture, this.shadingGradeRate = e.shadingGradeRate, this.shadingGradeTexture = e.shadingGradeTexture, this.shadeShift = e.shadeShift, this.shadeToony = e.shadeToony, this.lightColorAttenuation = e.lightColorAttenuation, this.indirectLightIntensity = e.indirectLightIntensity, this.rimTexture = e.rimTexture, this.rimColor.copy(e.rimColor), this.rimLightingMix = e.rimLightingMix, this.rimFresnelPower = e.rimFresnelPower, this.rimLift = e.rimLift, this.sphereAdd = e.sphereAdd, this.emissionColor.copy(e.emissionColor), this.emissiveMap = e.emissiveMap, this.outlineWidthTexture = e.outlineWidthTexture, this.outlineWidth = e.outlineWidth, this.outlineScaledMaxDistance = e.outlineScaledMaxDistance, this.outlineColor.copy(e.outlineColor), this.outlineLightingMix = e.outlineLightingMix, this.uvAnimMaskTexture = e.uvAnimMaskTexture, this.uvAnimScrollX = e.uvAnimScrollX, this.uvAnimScrollY = e.uvAnimScrollY, this.uvAnimRotation = e.uvAnimRotation, this.debugMode = e.debugMode, this.blendMode = e.blendMode, this.outlineWidthMode = e.outlineWidthMode, this.outlineColorMode = e.outlineColorMode, this.cullMode = e.cullMode, this.outlineCullMode = e.outlineCullMode, this.isOutline = e.isOutline, this;
  }
  _applyUniforms() {
    this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX, this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY, this.uniforms.uvAnimTheta.value = X * this._uvAnimPhase, this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z), this.uniforms.colorAlpha.value = this.color.w, this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z), this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST), this.uniforms.shadeTexture.value = this.shadeTexture, this.uniforms.normalMap.value = this.normalMap, this.uniforms.normalScale.value.copy(this.normalScale), this.uniforms.receiveShadowRate.value = this.receiveShadowRate, this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture, this.uniforms.shadingGradeRate.value = this.shadingGradeRate, this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture, this.uniforms.shadeShift.value = this.shadeShift, this.uniforms.shadeToony.value = this.shadeToony, this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation, this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity, this.uniforms.rimTexture.value = this.rimTexture, this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z), this.uniforms.rimLightingMix.value = this.rimLightingMix, this.uniforms.rimFresnelPower.value = this.rimFresnelPower, this.uniforms.rimLift.value = this.rimLift, this.uniforms.sphereAdd.value = this.sphereAdd, this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z), this.uniforms.emissiveMap.value = this.emissiveMap, this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture, this.uniforms.outlineWidth.value = this.outlineWidth, this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance, this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z), this.uniforms.outlineLightingMix.value = this.outlineLightingMix, this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture, this.encoding === sRGBEncoding && (this.uniforms.color.value.convertSRGBToLinear(), this.uniforms.shadeColor.value.convertSRGBToLinear(), this.uniforms.rimColor.value.convertSRGBToLinear(), this.uniforms.emissionColor.value.convertSRGBToLinear(), this.uniforms.outlineColor.value.convertSRGBToLinear()), this._updateCullFace());
  }
  _updateShaderCode() {
    const t = this.outlineWidthTexture !== null, n10 = this.map !== null || this.shadeTexture !== null || this.receiveShadowTexture !== null || this.shadingGradeTexture !== null || this.rimTexture !== null || this.uvAnimMaskTexture !== null;
    if (this.defines = { THREE_VRM_THREE_REVISION: parseInt(REVISION, 10), OUTLINE: this._isOutline, BLENDMODE_OPAQUE: this._blendMode === J.Opaque, BLENDMODE_CUTOUT: this._blendMode === J.Cutout, BLENDMODE_TRANSPARENT: this._blendMode === J.Transparent || this._blendMode === J.TransparentWithZWrite, MTOON_USE_UV: t || n10, MTOON_UVS_VERTEX_ONLY: t && !n10, USE_SHADETEXTURE: this.shadeTexture !== null, USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null, USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null, USE_RIMTEXTURE: this.rimTexture !== null, USE_SPHEREADD: this.sphereAdd !== null, USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null, USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null, DEBUG_NORMAL: this._debugMode === Q.Normal, DEBUG_LITSHADERATE: this._debugMode === Q.LitShadeRate, DEBUG_UV: this._debugMode === Q.UV, OUTLINE_WIDTH_WORLD: this._outlineWidthMode === $.WorldCoordinates, OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === $.ScreenCoordinates, OUTLINE_COLOR_FIXED: this._outlineColorMode === Z.FixedColor, OUTLINE_COLOR_MIXED: this._outlineColorMode === Z.MixedLighting }, this.vertexShader = "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  #ifdef MTOON_UVS_VERTEX_ONLY\n    vec2 vUv;\n  #else\n    varying vec2 vUv;\n  #endif\n\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHTEXTURE\n  uniform sampler2D outlineWidthTexture;\n#endif\n\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    vUv = uv;\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHTEXTURE\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = j, parseInt(REVISION, 10) < 137) {
      const e = (this.shadeTexture !== null ? Y("shadeTextureTexelToLinear", this.shadeTexture.encoding) + "\n" : "") + (this.sphereAdd !== null ? Y("sphereAddTexelToLinear", this.sphereAdd.encoding) + "\n" : "") + (this.rimTexture !== null ? Y("rimTextureTexelToLinear", this.rimTexture.encoding) + "\n" : "");
      this.fragmentShader = e + j;
    }
    this.needsUpdate = true;
  }
  _updateCullFace() {
    this.isOutline ? this.outlineCullMode === q.Off ? this.side = DoubleSide : this.outlineCullMode === q.Front ? this.side = BackSide : this.outlineCullMode === q.Back && (this.side = FrontSide) : this.cullMode === q.Off ? this.side = DoubleSide : this.cullMode === q.Front ? this.side = BackSide : this.cullMode === q.Back && (this.side = FrontSide);
  }
};
var ee;
!function(e) {
  e[e.Opaque = 0] = "Opaque", e[e.Cutout = 1] = "Cutout", e[e.Transparent = 2] = "Transparent", e[e.TransparentWithZWrite = 3] = "TransparentWithZWrite";
}(ee || (ee = {}));
var te = class extends ShaderMaterial {
  constructor(t) {
    super(), this.isVRMUnlitMaterial = true, this.cutoff = 0.5, this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this._renderType = ee.Opaque, this.shouldApplyUniforms = true, t === void 0 && (t = {}), t.fog = true, t.clipping = true, parseInt(REVISION, 10) < 129 && (t.skinning = t.skinning || false), parseInt(REVISION, 10) < 131 && (t.morphTargets = t.morphTargets || false, t.morphNormals = t.morphNormals || false), t.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, { cutoff: { value: 0.5 }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) } }]), this.setValues(t), this._updateShaderCode(), this._applyUniforms();
  }
  get mainTex() {
    return this.map;
  }
  set mainTex(e) {
    this.map = e;
  }
  get renderType() {
    return this._renderType;
  }
  set renderType(e) {
    this._renderType = e, this.depthWrite = this._renderType !== ee.Transparent, this.transparent = this._renderType === ee.Transparent || this._renderType === ee.TransparentWithZWrite, this._updateShaderCode();
  }
  updateVRMMaterials(e) {
    this._applyUniforms();
  }
  copy(e) {
    return super.copy(e), this.cutoff = e.cutoff, this.map = e.map, this.mainTex_ST.copy(e.mainTex_ST), this.renderType = e.renderType, this;
  }
  _applyUniforms() {
    this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST));
  }
  _updateShaderCode() {
    this.defines = { RENDERTYPE_OPAQUE: this._renderType === ee.Opaque, RENDERTYPE_CUTOUT: this._renderType === ee.Cutout, RENDERTYPE_TRANSPARENT: this._renderType === ee.Transparent || this._renderType === ee.TransparentWithZWrite }, this.vertexShader = "#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef USE_MAP\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n  #include <skinbase_vertex>\n\n  #ifdef USE_ENVMAP\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n\n  #endif\n\n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n\n  #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n  #include <envmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = "#ifdef RENDERTYPE_CUTOUT\n  uniform float cutoff;\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n// #include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n// #include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4( 1.0 );\n\n  #include <logdepthbuf_fragment>\n\n  #include <map_fragment>\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // MToon: alpha\n  // #include <alphatest_fragment>\n  #ifdef RENDERTYPE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef RENDERTYPE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  // #include <specularmap_fragment>\n\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n  // accumulation (baked indirect lighting only)\n  #ifdef USE_LIGHTMAP\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  #else\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\n  #endif\n\n  // modulation\n  // #include <aomap_fragment>\n\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n  // #include <envmap_fragment>\n\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}", this.needsUpdate = true;
  }
};
var ne = class {
  constructor(t = {}) {
    this._encoding = t.encoding || LinearEncoding, this._encoding !== LinearEncoding && this._encoding !== sRGBEncoding && console.warn("The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead."), this._requestEnvMap = t.requestEnvMap;
  }
  convertGLTFMaterials(e) {
    var t;
    return n(this, void 0, void 0, function* () {
      const i10 = (t = e.parser.json.extensions) === null || t === void 0 ? void 0 : t.VRM;
      if (!i10)
        return null;
      const r10 = i10.materialProperties;
      if (!r10)
        return null;
      const o10 = yield p(e), s10 = {}, a10 = [];
      return yield Promise.all(Array.from(o10.entries()).map(([t10, i11]) => n(this, void 0, void 0, function* () {
        const o11 = e.parser.json.nodes[t10], l10 = e.parser.json.meshes[o11.mesh];
        yield Promise.all(i11.map((t11, i12) => n(this, void 0, void 0, function* () {
          const n10 = l10.primitives[i12];
          if (!n10)
            return;
          const o12 = t11.geometry, d10 = o12.index ? o12.index.count : o12.attributes.position.count / 3;
          Array.isArray(t11.material) || (t11.material = [t11.material], o12.addGroup(0, d10, 0));
          const h10 = n10.material;
          let u10, c10 = r10[h10];
          c10 || (console.warn(`VRMMaterialImporter: There are no material definition for material #${h10} on VRM extension.`), c10 = { shader: "VRM_USE_GLTFSHADER" }), s10[h10] ? u10 = s10[h10] : (u10 = yield this.createVRMMaterials(t11.material[0], c10, e), s10[h10] = u10, a10.push(u10.surface), u10.outline && a10.push(u10.outline)), t11.material[0] = u10.surface, this._requestEnvMap && u10.surface.isMeshStandardMaterial && this._requestEnvMap().then((e10) => {
            u10.surface.envMap = e10, u10.surface.needsUpdate = true;
          }), t11.renderOrder = c10.renderQueue || 2e3, u10.outline && (t11.material[1] = u10.outline, o12.addGroup(0, d10, 1));
        })));
      }))), a10;
    });
  }
  createVRMMaterials(e, t, i10) {
    return n(this, void 0, void 0, function* () {
      let n10, r10;
      if (t.shader === "VRM/MToon") {
        const o10 = yield this._extractMaterialProperties(e, t, i10);
        ["srcBlend", "dstBlend", "isFirstSetup"].forEach((e10) => {
          o10[e10] !== void 0 && delete o10[e10];
        }), ["mainTex", "shadeTexture", "emissionMap", "sphereAdd", "rimTexture"].forEach((e10) => {
          o10[e10] !== void 0 && (o10[e10].encoding = this._encoding);
        }), o10.encoding = this._encoding, n10 = new K(o10), o10.outlineWidthMode !== $.None && (o10.isOutline = true, r10 = new K(o10));
      } else if (t.shader === "VRM/UnlitTexture") {
        const r11 = yield this._extractMaterialProperties(e, t, i10);
        r11.renderType = ee.Opaque, n10 = new te(r11);
      } else if (t.shader === "VRM/UnlitCutout") {
        const r11 = yield this._extractMaterialProperties(e, t, i10);
        r11.renderType = ee.Cutout, n10 = new te(r11);
      } else if (t.shader === "VRM/UnlitTransparent") {
        const r11 = yield this._extractMaterialProperties(e, t, i10);
        r11.renderType = ee.Transparent, n10 = new te(r11);
      } else if (t.shader === "VRM/UnlitTransparentZWrite") {
        const r11 = yield this._extractMaterialProperties(e, t, i10);
        r11.renderType = ee.TransparentWithZWrite, n10 = new te(r11);
      } else
        t.shader !== "VRM_USE_GLTFSHADER" && console.warn(`Unknown shader detected: "${t.shader}"`), n10 = this._convertGLTFMaterial(e.clone());
      return n10.name = e.name, n10.userData = JSON.parse(JSON.stringify(e.userData)), n10.userData.vrmMaterialProperties = t, r10 && (r10.name = e.name + " (Outline)", r10.userData = JSON.parse(JSON.stringify(e.userData)), r10.userData.vrmMaterialProperties = t), { surface: n10, outline: r10 };
    });
  }
  _renameMaterialProperty(e) {
    return e[0] !== "_" ? (console.warn(`VRMMaterials: Given property name "${e}" might be invalid`), e) : (e = e.substring(1), /[A-Z]/.test(e[0]) ? e[0].toLowerCase() + e.substring(1) : (console.warn(`VRMMaterials: Given property name "${e}" might be invalid`), e));
  }
  _convertGLTFMaterial(t) {
    if (t.isMeshStandardMaterial) {
      const n10 = t;
      n10.map && (n10.map.encoding = this._encoding), n10.emissiveMap && (n10.emissiveMap.encoding = this._encoding), this._encoding === LinearEncoding && (n10.color.convertLinearToSRGB(), n10.emissive.convertLinearToSRGB());
    }
    if (t.isMeshBasicMaterial) {
      const n10 = t;
      n10.map && (n10.map.encoding = this._encoding), this._encoding === LinearEncoding && n10.color.convertLinearToSRGB();
    }
    return t;
  }
  _extractMaterialProperties(t, n10, i10) {
    const r10 = [], o10 = {};
    if (n10.textureProperties)
      for (const e of Object.keys(n10.textureProperties)) {
        const t10 = this._renameMaterialProperty(e), s10 = n10.textureProperties[e];
        r10.push(i10.parser.getDependency("texture", s10).then((e10) => {
          o10[t10] = e10;
        }));
      }
    if (n10.floatProperties)
      for (const e of Object.keys(n10.floatProperties)) {
        const t10 = this._renameMaterialProperty(e);
        o10[t10] = n10.floatProperties[e];
      }
    if (n10.vectorProperties)
      for (const t10 of Object.keys(n10.vectorProperties)) {
        let i11 = this._renameMaterialProperty(t10);
        ["_MainTex", "_ShadeTexture", "_BumpMap", "_ReceiveShadowTexture", "_ShadingGradeTexture", "_RimTexture", "_SphereAdd", "_EmissionMap", "_OutlineWidthTexture", "_UvAnimMaskTexture"].some((e) => t10 === e) && (i11 += "_ST"), o10[i11] = new Vector4(...n10.vectorProperties[t10]);
      }
    return parseInt(REVISION, 10) < 129 && (o10.skinning = t.skinning || false), parseInt(REVISION, 10) < 131 && (o10.morphTargets = t.morphTargets || false, o10.morphNormals = t.morphNormals || false), Promise.all(r10).then(() => o10);
  }
};
var ie = class {
  constructor(e) {
    var t;
    this.ignoreTexture = (t = e == null ? void 0 : e.ignoreTexture) !== null && t !== void 0 && t;
  }
  import(e) {
    var t;
    return n(this, void 0, void 0, function* () {
      const n10 = (t = e.parser.json.extensions) === null || t === void 0 ? void 0 : t.VRM;
      if (!n10)
        return null;
      const i10 = n10.meta;
      if (!i10)
        return null;
      let r10;
      return this.ignoreTexture || i10.texture == null || i10.texture === -1 || (r10 = yield e.parser.getDependency("texture", i10.texture)), { allowedUserName: i10.allowedUserName, author: i10.author, commercialUssageName: i10.commercialUssageName, contactInformation: i10.contactInformation, licenseName: i10.licenseName, otherLicenseUrl: i10.otherLicenseUrl, otherPermissionUrl: i10.otherPermissionUrl, reference: i10.reference, sexualUssageName: i10.sexualUssageName, texture: r10 != null ? r10 : void 0, title: i10.title, version: i10.version, violentUssageName: i10.violentUssageName };
    });
  }
};
var re = new Matrix4();
function oe(e) {
  return e.invert ? e.invert() : e.getInverse(re.copy(e)), e;
}
var se = class {
  constructor(t) {
    this._inverseCache = new Matrix4(), this._shouldUpdateInverse = true, this.matrix = t;
    const n10 = { set: (e, t10, n11) => (this._shouldUpdateInverse = true, e[t10] = n11, true) };
    this._originalElements = t.elements, t.elements = new Proxy(t.elements, n10);
  }
  get inverse() {
    return this._shouldUpdateInverse && (oe(this._inverseCache.copy(this.matrix)), this._shouldUpdateInverse = false), this._inverseCache;
  }
  revert() {
    this.matrix.elements = this._originalElements;
  }
};
var ae = Object.freeze(new Matrix4());
var le = Object.freeze(new Quaternion());
var de = new Vector3();
var he = new Vector3();
var ue = new Vector3();
var ce = new Quaternion();
var pe = new Matrix4();
var me = new Matrix4();
var fe = class {
  constructor(t, n10 = {}) {
    var i10, r10, o10, s10, a10, l10;
    if (this._currentTail = new Vector3(), this._prevTail = new Vector3(), this._nextTail = new Vector3(), this._boneAxis = new Vector3(), this._centerSpacePosition = new Vector3(), this._center = null, this._parentWorldRotation = new Quaternion(), this._initialLocalMatrix = new Matrix4(), this._initialLocalRotation = new Quaternion(), this._initialLocalChildPosition = new Vector3(), this.bone = t, this.bone.matrixAutoUpdate = false, this.radius = (i10 = n10.radius) !== null && i10 !== void 0 ? i10 : 0.02, this.stiffnessForce = (r10 = n10.stiffnessForce) !== null && r10 !== void 0 ? r10 : 1, this.gravityDir = n10.gravityDir ? new Vector3().copy(n10.gravityDir) : new Vector3().set(0, -1, 0), this.gravityPower = (o10 = n10.gravityPower) !== null && o10 !== void 0 ? o10 : 0, this.dragForce = (s10 = n10.dragForce) !== null && s10 !== void 0 ? s10 : 0.4, this.colliders = (a10 = n10.colliders) !== null && a10 !== void 0 ? a10 : [], this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this._initialLocalMatrix.copy(this.bone.matrix), this._initialLocalRotation.copy(this.bone.quaternion), this.bone.children.length === 0)
      this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);
    else {
      const e = this.bone.children[0];
      this._initialLocalChildPosition.copy(e.position);
    }
    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail), this._boneAxis.copy(this._initialLocalChildPosition).normalize(), this._centerSpaceBoneLength = de.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length(), this.center = (l10 = n10.center) !== null && l10 !== void 0 ? l10 : null;
  }
  get center() {
    return this._center;
  }
  set center(e) {
    var t;
    this._getMatrixCenterToWorld(pe), this._currentTail.applyMatrix4(pe), this._prevTail.applyMatrix4(pe), this._nextTail.applyMatrix4(pe), ((t = this._center) === null || t === void 0 ? void 0 : t.userData.inverseCacheProxy) && (this._center.userData.inverseCacheProxy.revert(), delete this._center.userData.inverseCacheProxy), this._center = e, this._center && (this._center.userData.inverseCacheProxy || (this._center.userData.inverseCacheProxy = new se(this._center.matrixWorld))), this._getMatrixWorldToCenter(pe), this._currentTail.applyMatrix4(pe), this._prevTail.applyMatrix4(pe), this._nextTail.applyMatrix4(pe), pe.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(pe), this._centerSpaceBoneLength = de.copy(this._initialLocalChildPosition).applyMatrix4(pe).sub(this._centerSpacePosition).length();
  }
  reset() {
    this.bone.quaternion.copy(this._initialLocalRotation), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail);
  }
  update(e) {
    if (e <= 0)
      return;
    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this.bone.parent ? _(this.bone.parent, this._parentWorldRotation) : this._parentWorldRotation.copy(le), this._getMatrixWorldToCenter(pe), pe.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(pe), this._getMatrixWorldToCenter(me), me.multiply(this._getParentMatrixWorld());
    const t = this.stiffnessForce * e, n10 = he.copy(this.gravityDir).multiplyScalar(this.gravityPower * e);
    this._nextTail.copy(this._currentTail).add(de.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.dragForce)).add(de.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(me).sub(this._centerSpacePosition).normalize().multiplyScalar(t)).add(n10), this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition), this._collision(this._nextTail), this._prevTail.copy(this._currentTail), this._currentTail.copy(this._nextTail);
    const i10 = oe(pe.copy(me.multiply(this._initialLocalMatrix))), r10 = ce.setFromUnitVectors(this._boneAxis, de.copy(this._nextTail).applyMatrix4(i10).normalize());
    this.bone.quaternion.copy(this._initialLocalRotation).multiply(r10), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);
  }
  _collision(e) {
    this.colliders.forEach((t) => {
      this._getMatrixWorldToCenter(pe), pe.multiply(t.matrixWorld);
      const n10 = de.setFromMatrixPosition(pe), i10 = t.geometry.boundingSphere.radius, r10 = this.radius + i10;
      if (e.distanceToSquared(n10) <= r10 * r10) {
        const t10 = he.subVectors(e, n10).normalize(), i11 = ue.addVectors(n10, t10.multiplyScalar(r10));
        e.copy(i11.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition));
      }
    });
  }
  _getMatrixCenterToWorld(e) {
    return this._center ? e.copy(this._center.matrixWorld) : e.identity(), e;
  }
  _getMatrixWorldToCenter(e) {
    return this._center ? e.copy(this._center.userData.inverseCacheProxy.inverse) : e.identity(), e;
  }
  _getParentMatrixWorld() {
    return this.bone.parent ? this.bone.parent.matrixWorld : ae;
  }
};
var ge = class {
  constructor(e, t) {
    this.colliderGroups = [], this.springBoneGroupList = [], this.colliderGroups = e, this.springBoneGroupList = t;
  }
  setCenter(e) {
    this.springBoneGroupList.forEach((t) => {
      t.forEach((t10) => {
        t10.center = e;
      });
    });
  }
  lateUpdate(e) {
    this.springBoneGroupList.forEach((t) => {
      t.forEach((t10) => {
        t10.update(e);
      });
    });
  }
  reset() {
    this.springBoneGroupList.forEach((e) => {
      e.forEach((e10) => {
        e10.reset();
      });
    });
  }
};
var _e = new Vector3();
var ve = new MeshBasicMaterial({ visible: false });
var Te = class {
  import(e) {
    var t;
    return n(this, void 0, void 0, function* () {
      const n10 = (t = e.parser.json.extensions) === null || t === void 0 ? void 0 : t.VRM;
      if (!n10)
        return null;
      const i10 = n10.secondaryAnimation;
      if (!i10)
        return null;
      const r10 = yield this._importColliderMeshGroups(e, i10), o10 = yield this._importSpringBoneGroupList(e, i10, r10);
      return new ge(r10, o10);
    });
  }
  _createSpringBone(e, t = {}) {
    return new fe(e, t);
  }
  _importSpringBoneGroupList(t, i10, r10) {
    return n(this, void 0, void 0, function* () {
      const o10 = i10.boneGroups || [], s10 = [];
      return yield Promise.all(o10.map((i11) => n(this, void 0, void 0, function* () {
        if (i11.stiffiness === void 0 || i11.gravityDir === void 0 || i11.gravityDir.x === void 0 || i11.gravityDir.y === void 0 || i11.gravityDir.z === void 0 || i11.gravityPower === void 0 || i11.dragForce === void 0 || i11.hitRadius === void 0 || i11.colliderGroups === void 0 || i11.bones === void 0 || i11.center === void 0)
          return;
        const o11 = i11.stiffiness, a10 = new Vector3(i11.gravityDir.x, i11.gravityDir.y, -i11.gravityDir.z), l10 = i11.gravityPower, d10 = i11.dragForce, h10 = i11.hitRadius, u10 = [];
        i11.colliderGroups.forEach((e) => {
          u10.push(...r10[e].colliders);
        });
        const c10 = [];
        yield Promise.all(i11.bones.map((e) => n(this, void 0, void 0, function* () {
          const n10 = yield t.parser.getDependency("node", e), r11 = i11.center !== -1 ? yield t.parser.getDependency("node", i11.center) : null;
          n10 && n10.traverse((e10) => {
            const t10 = this._createSpringBone(e10, { radius: h10, stiffnessForce: o11, gravityDir: a10, gravityPower: l10, dragForce: d10, colliders: u10, center: r11 });
            c10.push(t10);
          });
        }))), s10.push(c10);
      }))), s10;
    });
  }
  _importColliderMeshGroups(e, t) {
    return n(this, void 0, void 0, function* () {
      const i10 = t.colliderGroups;
      if (i10 === void 0)
        return [];
      const r10 = [];
      return i10.forEach((t10) => n(this, void 0, void 0, function* () {
        if (t10.node === void 0 || t10.colliders === void 0)
          return;
        const n10 = yield e.parser.getDependency("node", t10.node), i11 = [];
        t10.colliders.forEach((e10) => {
          if (e10.offset === void 0 || e10.offset.x === void 0 || e10.offset.y === void 0 || e10.offset.z === void 0 || e10.radius === void 0)
            return;
          const t11 = _e.set(e10.offset.x, e10.offset.y, -e10.offset.z), r11 = this._createColliderMesh(e10.radius, t11);
          n10.add(r11), i11.push(r11);
        });
        const o10 = { node: t10.node, colliders: i11 };
        r10.push(o10);
      })), r10;
    });
  }
  _createColliderMesh(t, n10) {
    const i10 = new Mesh(new SphereGeometry(t, 8, 4), ve);
    return i10.position.copy(n10), i10.name = "vrmColliderSphere", i10.geometry.computeBoundingSphere(), i10;
  }
};
var ye = class {
  constructor(e = {}) {
    this._metaImporter = e.metaImporter || new ie(), this._blendShapeImporter = e.blendShapeImporter || new T(), this._lookAtImporter = e.lookAtImporter || new z(), this._humanoidImporter = e.humanoidImporter || new I(), this._firstPersonImporter = e.firstPersonImporter || new L(), this._materialImporter = e.materialImporter || new ne(), this._springBoneImporter = e.springBoneImporter || new Te();
  }
  import(e) {
    return n(this, void 0, void 0, function* () {
      if (e.parser.json.extensions === void 0 || e.parser.json.extensions.VRM === void 0)
        throw new Error("Could not find VRM extension on the GLTF");
      const t = e.scene;
      t.updateMatrixWorld(false), t.traverse((e10) => {
        e10.isMesh && (e10.frustumCulled = false);
      });
      const n10 = (yield this._metaImporter.import(e)) || void 0, i10 = (yield this._materialImporter.convertGLTFMaterials(e)) || void 0, r10 = (yield this._humanoidImporter.import(e)) || void 0, o10 = r10 && (yield this._firstPersonImporter.import(e, r10)) || void 0, s10 = (yield this._blendShapeImporter.import(e)) || void 0, a10 = o10 && s10 && r10 && (yield this._lookAtImporter.import(e, o10, s10, r10)) || void 0, l10 = (yield this._springBoneImporter.import(e)) || void 0;
      return new xe({ scene: e.scene, meta: n10, materials: i10, humanoid: r10, firstPerson: o10, blendShapeProxy: s10, lookAt: a10, springBoneManager: l10 });
    });
  }
};
var xe = class {
  constructor(e) {
    this.scene = e.scene, this.humanoid = e.humanoid, this.blendShapeProxy = e.blendShapeProxy, this.firstPerson = e.firstPerson, this.lookAt = e.lookAt, this.materials = e.materials, this.springBoneManager = e.springBoneManager, this.meta = e.meta;
  }
  static from(e, t = {}) {
    return n(this, void 0, void 0, function* () {
      const n10 = new ye(t);
      return yield n10.import(e);
    });
  }
  update(e) {
    this.lookAt && this.lookAt.update(e), this.blendShapeProxy && this.blendShapeProxy.update(), this.springBoneManager && this.springBoneManager.lateUpdate(e), this.materials && this.materials.forEach((t) => {
      t.updateVRMMaterials && t.updateVRMMaterials(e);
    });
  }
  dispose() {
    var e, t;
    const n10 = this.scene;
    n10 && n10.traverse(r), (t = (e = this.meta) === null || e === void 0 ? void 0 : e.texture) === null || t === void 0 || t.dispose();
  }
};
var Se = new Vector2();
var Me = new OrthographicCamera(-1, 1, -1, 1, -1, 1);
var Ee = new MeshBasicMaterial({ color: 16777215, side: DoubleSide });
var Le = new Mesh(new PlaneGeometry(2, 2), Ee);
var Re = new Scene();
Re.add(Le);
var we = class {
  constructor() {
  }
};
we.extractThumbnailBlob = function(e, t, n10 = 512) {
  var i10;
  const r10 = (i10 = t.meta) === null || i10 === void 0 ? void 0 : i10.texture;
  if (!r10)
    throw new Error("extractThumbnailBlob: This VRM does not have a thumbnail");
  const o10 = e.getContext().canvas;
  e.getSize(Se);
  const s10 = Se.x, a10 = Se.y;
  return e.setSize(n10, n10, false), Ee.map = r10, e.render(Re, Me), Ee.map = null, o10 instanceof OffscreenCanvas ? o10.convertToBlob().finally(() => {
    e.setSize(s10, a10, false);
  }) : new Promise((t10, n11) => {
    o10.toBlob((i11) => {
      e.setSize(s10, a10, false), i11 == null ? n11("extractThumbnailBlob: Failed to create a blob") : t10(i11);
    });
  });
}, we.removeUnnecessaryJoints = function(t) {
  const n10 = /* @__PURE__ */ new Map();
  t.traverse((t10) => {
    if (t10.type !== "SkinnedMesh")
      return;
    const i10 = t10, r10 = i10.geometry.getAttribute("skinIndex");
    let o10 = n10.get(r10);
    if (!o10) {
      const t11 = [], s10 = [], a10 = {}, l10 = r10.array;
      for (let e = 0; e < l10.length; e++) {
        const n11 = l10[e];
        a10[n11] === void 0 && (a10[n11] = t11.length, t11.push(i10.skeleton.bones[n11]), s10.push(i10.skeleton.boneInverses[n11])), l10[e] = a10[n11];
      }
      r10.copyArray(l10), r10.needsUpdate = true, o10 = new Skeleton(t11, s10), n10.set(r10, o10);
    }
    i10.bind(o10, new Matrix4());
  });
}, we.removeUnnecessaryVertices = function(n10) {
  const i10 = /* @__PURE__ */ new Map();
  n10.traverse((n11) => {
    var r10, o10, s10, a10;
    if (!n11.isMesh)
      return;
    const l10 = n11, d10 = l10.geometry, h10 = d10.index;
    if (h10 == null)
      return;
    const u10 = i10.get(d10);
    if (u10 != null)
      return void (l10.geometry = u10);
    const c10 = new BufferGeometry();
    c10.name = d10.name, c10.morphTargetsRelative = d10.morphTargetsRelative, d10.groups.forEach((e) => {
      c10.addGroup(e.start, e.count, e.materialIndex);
    }), c10.boundingBox = (o10 = (r10 = d10.boundingBox) === null || r10 === void 0 ? void 0 : r10.clone()) !== null && o10 !== void 0 ? o10 : null, c10.boundingSphere = (a10 = (s10 = d10.boundingSphere) === null || s10 === void 0 ? void 0 : s10.clone()) !== null && a10 !== void 0 ? a10 : null, c10.setDrawRange(d10.drawRange.start, d10.drawRange.count), c10.userData = d10.userData, i10.set(d10, c10);
    const p10 = [], m10 = [];
    {
      const e = h10.array, n12 = new e.constructor(e.length);
      let i11 = 0;
      for (let t = 0; t < e.length; t++) {
        const r11 = e[t];
        let o11 = p10[r11];
        o11 == null && (p10[r11] = i11, m10[i11] = r11, o11 = i11, i11++), n12[t] = o11;
      }
      c10.setIndex(new BufferAttribute(n12, 1, false));
    }
    Object.keys(d10.attributes).forEach((e) => {
      const n12 = d10.attributes[e];
      if (n12.isInterleavedBufferAttribute)
        throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
      const i11 = n12.array, { itemSize: r11, normalized: o11 } = n12, s11 = new i11.constructor(m10.length * r11);
      m10.forEach((e10, t) => {
        for (let n13 = 0; n13 < r11; n13++)
          s11[t * r11 + n13] = i11[e10 * r11 + n13];
      }), c10.setAttribute(e, new BufferAttribute(s11, r11, o11));
    });
    let f10 = true;
    Object.keys(d10.morphAttributes).forEach((e) => {
      c10.morphAttributes[e] = [];
      const n12 = d10.morphAttributes[e];
      for (let i11 = 0; i11 < n12.length; i11++) {
        const r11 = n12[i11];
        if (r11.isInterleavedBufferAttribute)
          throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
        const o11 = r11.array, { itemSize: s11, normalized: a11 } = r11, l11 = new o11.constructor(m10.length * s11);
        m10.forEach((e10, t) => {
          for (let n13 = 0; n13 < s11; n13++)
            l11[t * s11 + n13] = o11[e10 * s11 + n13];
        }), f10 = f10 && l11.every((e10) => e10 === 0), c10.morphAttributes[e][i11] = new BufferAttribute(l11, s11, a11);
      }
    }), f10 && (c10.morphAttributes = {}), l10.geometry = c10;
  }), Array.from(i10.keys()).forEach((e) => {
    e.dispose();
  });
};
var Pe = new Vector3();
var Ie = new MeshBasicMaterial({ color: 16711935, wireframe: true, transparent: true, depthTest: false });
var Ce = new Vector3();

// node_modules/.pnpm/@vladmandic+human@2.6.4/node_modules/@vladmandic/human/dist/human.esm.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
function log(...msg) {
  const dt2 = new Date();
  const ts2 = `${dt2.getHours().toString().padStart(2, "0")}:${dt2.getMinutes().toString().padStart(2, "0")}:${dt2.getSeconds().toString().padStart(2, "0")}.${dt2.getMilliseconds().toString().padStart(3, "0")}`;
  if (msg)
    console.log(ts2, "Human:", ...msg);
}
function join(folder, file) {
  const separator = folder.endsWith("/") ? "" : "/";
  const skipJoin = file.startsWith(".") || file.startsWith("/") || file.startsWith("http:") || file.startsWith("https:") || file.startsWith("file:");
  const path = skipJoin ? `${file}` : `${folder}${separator}${file}`;
  if (!path.toLocaleLowerCase().includes(".json"))
    throw new Error(`modelpath error: expecting json file: ${path}`);
  return path;
}
var now2 = () => {
  if (typeof performance !== "undefined")
    return performance.now();
  return parseInt((Number(process.hrtime.bigint()) / 1e3 / 1e3).toString());
};
function validate(defaults, config3, parent = "config", msgs = []) {
  for (const key of Object.keys(config3)) {
    if (typeof config3[key] === "object") {
      validate(defaults[key], config3[key], key, msgs);
    } else {
      const defined = defaults && typeof defaults[key] !== "undefined";
      if (!defined)
        msgs.push({ reason: "unknown property", where: `${parent}.${key} = ${config3[key]}` });
      const same = defaults && typeof defaults[key] === typeof config3[key];
      if (defined && !same)
        msgs.push({ reason: "property type mismatch", where: `${parent}.${key} = ${config3[key]}`, expected: typeof defaults[key] });
    }
  }
  if (config3.debug && parent === "config" && msgs.length > 0)
    log("invalid configuration", msgs);
  return msgs;
}
function mergeDeep(...objects) {
  const isObject = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj || {}).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal))
        prev[key] = pVal.concat(...oVal);
      else if (isObject(pVal) && isObject(oVal))
        prev[key] = mergeDeep(pVal, oVal);
      else
        prev[key] = oVal;
    });
    return prev;
  }, {});
}
var config = {
  backend: "",
  modelBasePath: "",
  cacheModels: true,
  wasmPath: "",
  wasmPlatformFetch: false,
  debug: true,
  async: true,
  warmup: "full",
  cacheSensitivity: 0.7,
  skipAllowed: false,
  deallocate: false,
  filter: {
    enabled: true,
    equalization: false,
    width: 0,
    height: 0,
    flip: false,
    return: true,
    brightness: 0,
    contrast: 0,
    sharpness: 0,
    blur: 0,
    saturation: 0,
    hue: 0,
    negative: false,
    sepia: false,
    vintage: false,
    kodachrome: false,
    technicolor: false,
    polaroid: false,
    pixelate: 0
  },
  gesture: {
    enabled: true
  },
  face: {
    enabled: true,
    detector: {
      modelPath: "blazeface.json",
      rotation: true,
      maxDetected: 1,
      skipFrames: 99,
      skipTime: 2500,
      minConfidence: 0.2,
      iouThreshold: 0.1,
      mask: false,
      return: false
    },
    mesh: {
      enabled: true,
      modelPath: "facemesh.json"
    },
    iris: {
      enabled: true,
      modelPath: "iris.json"
    },
    emotion: {
      enabled: true,
      minConfidence: 0.1,
      skipFrames: 99,
      skipTime: 1500,
      modelPath: "emotion.json"
    },
    description: {
      enabled: true,
      modelPath: "faceres.json",
      skipFrames: 99,
      skipTime: 3e3,
      minConfidence: 0.1
    },
    antispoof: {
      enabled: false,
      skipFrames: 99,
      skipTime: 4e3,
      modelPath: "antispoof.json"
    },
    liveness: {
      enabled: false,
      skipFrames: 99,
      skipTime: 4e3,
      modelPath: "liveness.json"
    }
  },
  body: {
    enabled: true,
    modelPath: "movenet-lightning.json",
    maxDetected: -1,
    minConfidence: 0.3,
    skipFrames: 1,
    skipTime: 200
  },
  hand: {
    enabled: true,
    rotation: true,
    skipFrames: 99,
    skipTime: 1e3,
    minConfidence: 0.5,
    iouThreshold: 0.2,
    maxDetected: -1,
    landmarks: true,
    detector: {
      modelPath: "handtrack.json"
    },
    skeleton: {
      modelPath: "handlandmark-full.json"
    }
  },
  object: {
    enabled: false,
    modelPath: "mb3-centernet.json",
    minConfidence: 0.2,
    iouThreshold: 0.4,
    maxDetected: 10,
    skipFrames: 99,
    skipTime: 2e3
  },
  segmentation: {
    enabled: false,
    modelPath: "selfie.json",
    blur: 8
  }
};
var tfjs_esm_exports = {};
__export(tfjs_esm_exports, {
  Abs: () => ao,
  Acos: () => nl,
  Acosh: () => sl,
  AdadeltaOptimizer: () => pb,
  AdagradOptimizer: () => hb,
  AdamOptimizer: () => fb,
  AdamaxOptimizer: () => mb,
  Add: () => kr,
  AddN: () => xa,
  All: () => rl,
  Any: () => al,
  ArgMax: () => wa,
  ArgMin: () => il,
  Asin: () => ol,
  Asinh: () => ul,
  Atan: () => ll,
  Atan2: () => dl,
  Atanh: () => cl,
  AvgPool: () => ka,
  AvgPool3D: () => Hd,
  AvgPool3DGrad: () => ag,
  AvgPoolGrad: () => rg,
  BackendWasm: () => ide,
  BatchMatMul: () => Ia,
  BatchToSpaceND: () => io,
  Bincount: () => ig,
  BroadcastArgs: () => og,
  BroadcastTo: () => w$,
  Callback: () => mW,
  CallbackList: () => TL,
  Cast: () => Sa,
  Ceil: () => Ca,
  ClipByValue: () => Ir,
  Complex: () => qd,
  ComplexAbs: () => jd,
  Concat: () => oo,
  Conv2D: () => Na,
  Conv2DBackpropFilter: () => ug,
  Conv2DBackpropInput: () => Ta,
  Conv3D: () => Kd,
  Conv3DBackpropFilterV2: () => lg,
  Conv3DBackpropInputV2: () => cg,
  Cos: () => $a,
  Cosh: () => _a,
  CropAndResize: () => lo,
  Cumsum: () => uo,
  CustomCallback: () => AL,
  DataStorage: () => Wd,
  DenseBincount: () => dg,
  DepthToSpace: () => co,
  DepthwiseConv2dNative: () => Aa,
  DepthwiseConv2dNativeBackpropFilter: () => pg,
  DepthwiseConv2dNativeBackpropInput: () => hg,
  Diag: () => fg,
  Dilation2D: () => Xd,
  Dilation2DBackpropFilter: () => Xf,
  Dilation2DBackpropInput: () => Kf,
  ENV: () => jw,
  EarlyStopping: () => gW,
  Einsum: () => Yd,
  Elu: () => Ra,
  EluGrad: () => mg,
  Environment: () => m$,
  Equal: () => po,
  Erf: () => pl,
  Exp: () => Da,
  ExpandDims: () => ho,
  Expm1: () => fo,
  FFT: () => gg,
  Fill: () => hl,
  FlipLeftRight: () => mo,
  Floor: () => Fa,
  FloorDiv: () => Oa,
  FromPixels: () => hd,
  FusedBatchNorm: () => Pa,
  FusedConv2D: () => sa,
  FusedDepthwiseConv2D: () => ra,
  GPGPUContext: () => qf,
  GatherNd: () => bo,
  GatherV2: () => go,
  GraphModel: () => w4,
  Greater: () => yo,
  GreaterEqual: () => za,
  History: () => _L,
  IFFT: () => bg,
  Identity: () => Ma,
  Imag: () => Qd,
  InputSpec: () => Dt,
  IsFinite: () => fl,
  IsInf: () => ml,
  IsNan: () => gl,
  KernelBackend: () => tl,
  LRN: () => Jd,
  LRNGrad: () => vg,
  LayerVariable: () => xL,
  LayersModel: () => pr,
  LeakyRelu: () => La,
  Less: () => vo,
  LessEqual: () => xo,
  LinSpace: () => yg,
  Log: () => Ba,
  Log1p: () => bl,
  LogSoftmax: () => k$,
  LogicalAnd: () => wo,
  LogicalNot: () => yl,
  LogicalOr: () => Zd,
  MathBackendCPU: () => RS,
  MathBackendWebGL: () => A1,
  Max: () => Va,
  MaxPool: () => Ua,
  MaxPool3D: () => ep,
  MaxPool3DGrad: () => wg,
  MaxPoolGrad: () => xg,
  MaxPoolWithArgmax: () => kg,
  Maximum: () => Wa,
  Mean: () => Ga,
  Min: () => Ha,
  Minimum: () => qa,
  MirrorPad: () => ja,
  Mod: () => vl,
  MomentumOptimizer: () => gb,
  Multinomial: () => Ig,
  Multiply: () => Ka,
  Neg: () => ko,
  NonMaxSuppressionV3: () => So,
  NonMaxSuppressionV4: () => xl,
  NonMaxSuppressionV5: () => Co,
  NotEqual: () => Io,
  OP_SCOPE_SUFFIX: () => e_,
  OneHot: () => To,
  OnesLike: () => No,
  Optimizer: () => $r,
  OptimizerConstructors: () => Vr,
  Pack: () => $o,
  PadV2: () => Xa,
  Pool: () => pde,
  Pow: () => Ya,
  Prelu: () => Qa,
  Prod: () => _o,
  RMSPropOptimizer: () => bb,
  RNN: () => _r,
  Range: () => wl,
  Rank: () => H$,
  Real: () => tp,
  RealDiv: () => Ea,
  Reciprocal: () => kl,
  Reduction: () => YF,
  Relu: () => Za,
  Relu6: () => ei,
  Reshape: () => Ao,
  ResizeBilinear: () => Ja,
  ResizeBilinearGrad: () => Cg,
  ResizeNearestNeighbor: () => Il,
  ResizeNearestNeighborGrad: () => Sg,
  Reverse: () => Eo,
  RotateWithOffset: () => Ho,
  Round: () => Ro,
  Rsqrt: () => ti,
  SGDOptimizer: () => kp,
  ScatterNd: () => Do,
  Select: () => Fo,
  Selu: () => Sl,
  Sequential: () => Vb,
  Sigmoid: () => si,
  Sign: () => Cl,
  Sin: () => ni,
  Sinh: () => Po,
  Slice: () => Oo,
  Softmax: () => ii,
  Softplus: () => Nl,
  SpaceToBatchND: () => zo,
  SparseFillEmptyRows: () => np,
  SparseReshape: () => Tl,
  SparseSegmentMean: () => sp,
  SparseSegmentSum: () => rp,
  SparseToDense: () => ap,
  SplitV: () => Mo,
  Sqrt: () => ri,
  Square: () => $l,
  SquaredDifference: () => oi,
  Step: () => di,
  StridedSlice: () => Lo,
  StringNGrams: () => ip,
  StringSplit: () => Ng,
  StringToHashBucketFast: () => Tg,
  Sub: () => ui,
  Sum: () => ai,
  SymbolicTensor: () => $s,
  Tan: () => Bo,
  Tanh: () => li,
  Tensor: () => et,
  TensorBuffer: () => Vt,
  Tile: () => Sr,
  TopK: () => Vo,
  Transform: () => Wo,
  Transpose: () => ci,
  Unique: () => $g,
  Unpack: () => Uo,
  UnsortedSegmentSum: () => op,
  Variable: () => md,
  ZerosLike: () => Go,
  _FusedMatMul: () => na,
  abs: () => Mt,
  acos: () => OA,
  acosh: () => zA,
  add: () => ie2,
  addN: () => LA,
  all: () => Bk,
  any: () => cm,
  argMax: () => Gu,
  argMin: () => GA,
  asin: () => qA,
  asinh: () => KA,
  atan: () => YA,
  atan2: () => ZA,
  atanh: () => eE,
  avgPool: () => Wg,
  avgPool3d: () => Gk,
  backend: () => $A,
  backend_util: () => N2,
  basicLSTMCell: () => Ade,
  batchNorm: () => qu,
  batchNorm2d: () => vE,
  batchNorm3d: () => wE,
  batchNorm4d: () => IE,
  batchToSpaceND: () => Ug,
  bincount: () => Hk,
  booleanMaskAsync: () => rpe,
  broadcastArgs: () => NE,
  broadcastTo: () => td,
  broadcast_util: () => qo,
  browser: () => xk,
  buffer: () => De,
  callbacks: () => fpe,
  cast: () => ce2,
  ceil: () => _E,
  clipByValue: () => Bn,
  clone: () => lr,
  complex: () => aa,
  concat: () => Ft,
  concat1d: () => RE,
  concat2d: () => FE,
  concat3d: () => PE,
  concat4d: () => ME,
  constraints: () => $M,
  conv1d: () => qk,
  conv2d: () => ua,
  conv2dTranspose: () => jk,
  conv3d: () => Kk,
  conv3dTranspose: () => qE,
  copyRegisteredKernels: () => mde,
  cos: () => Hg,
  cosh: () => Yk,
  cosineWindow: () => wI,
  cumsum: () => Qk,
  customGrad: () => js,
  data: () => k4,
  denseBincount: () => QE,
  deprecationWarn: () => Mk,
  depthToSpace: () => JE,
  depthwiseConv2d: () => pp,
  deregisterOp: () => gpe,
  device_util: () => cp,
  diag: () => Ede,
  dilation2d: () => sR,
  disableDeprecationWarnings: () => vde,
  dispose: () => Re2,
  disposeVariables: () => xde,
  div: () => xe2,
  divNoNan: () => uR,
  dot: () => Rde,
  dropout: () => H3,
  einsum: () => dR,
  elu: () => hp,
  enableDebugMode: () => yde,
  enableProdMode: () => bde,
  enclosingPowerOfTwo: () => q3,
  engine: () => Ss,
  env: () => X2,
  equal: () => qn,
  erf: () => fR,
  exp: () => jn,
  expandDims: () => On,
  expm1: () => yR,
  eye: () => Zk,
  fft: () => ob,
  fill: () => Fl,
  findBackend: () => Tde,
  findBackendFactory: () => $de,
  floor: () => fp,
  floorDiv: () => Lk,
  forceHalfFloat: () => DX,
  fused: () => da,
  gather: () => ju,
  gatherND: () => W3,
  gather_util: () => kk,
  getBackend: () => Cde,
  getGradient: () => Jv,
  getKernel: () => Yf,
  getKernelsForBackend: () => Qf,
  getThreadsCount: () => Npe,
  gpgpu_util: () => wK,
  grad: () => Ode,
  grads: () => Pde,
  greater: () => Wn,
  greaterEqual: () => jo,
  ifft: () => kd,
  imag: () => qg,
  image: () => ds,
  inTopKAsync: () => ipe,
  initializers: () => PM,
  input: () => CB,
  io: () => _n,
  irfft: () => fI,
  isFinite: () => Dde,
  isInf: () => Fde,
  isNaN: () => _R,
  keep: () => Ht,
  kernel_impls: () => xs,
  layers: () => yL,
  leakyRelu: () => jg,
  less: () => Jk,
  lessEqual: () => Ko,
  linalg: () => AO,
  linspace: () => DR,
  loadGraphModel: () => bpe,
  loadLayersModel: () => ppe,
  localResponseNormalization: () => OR,
  log: () => Kn,
  log1p: () => Kg,
  logSigmoid: () => Lde,
  logSoftmax: () => eI,
  logSumExp: () => XR,
  logicalAnd: () => Ds,
  logicalNot: () => Qg,
  logicalOr: () => rI,
  logicalXor: () => Bde,
  losses: () => lpe,
  matMul: () => We,
  math: () => Q_,
  max: () => As,
  maxPool: () => Zg,
  maxPool3d: () => aI,
  maxPoolWithArgmax: () => sD,
  maximum: () => Tr,
  mean: () => It,
  memory: () => lm,
  meshgrid: () => Vde,
  metrics: () => KV,
  min: () => pm,
  minimum: () => gp,
  mirrorPad: () => lD,
  mod: () => dD,
  model: () => cpe,
  models: () => cW,
  moments: () => Jg,
  movingAverage: () => ape,
  mul: () => V2,
  multiRNNCell: () => Wde,
  multinomial: () => gD,
  neg: () => kt,
  nextFrame: () => RO,
  norm: () => vI,
  notEqual: () => Ku,
  oneHot: () => yd,
  ones: () => zn,
  onesLike: () => Xn,
  op: () => L2,
  outerProduct: () => Ude,
  pad: () => pi,
  pad1d: () => Gde,
  pad2d: () => Hde,
  pad3d: () => qde,
  pad4d: () => jde,
  pool: () => Kde,
  pow: () => ca,
  prelu: () => tb,
  print: () => F_,
  prod: () => iI,
  profile: () => wde,
  rand: () => Xde,
  randomGamma: () => Yde,
  randomNormal: () => zD,
  randomUniform: () => Pl,
  range: () => Xu,
  ready: () => Sde,
  real: () => xd,
  reciprocal: () => VD,
  registerBackend: () => dp,
  registerCallbackConstructor: () => hpe,
  registerGradient: () => S$,
  registerKernel: () => _l,
  registerOp: () => mpe,
  regularizers: () => dW,
  relu: () => Xs,
  relu6: () => oI,
  removeBackend: () => Nde,
  reshape: () => G2,
  reverse: () => Yn,
  reverse1d: () => Qde,
  reverse2d: () => Zde,
  reverse3d: () => Jde,
  reverse4d: () => epe,
  rfft: () => ub,
  round: () => uI,
  rsqrt: () => lI,
  scalar: () => Ie2,
  scatterND: () => M3,
  scatter_util: () => Sk,
  selu: () => cI,
  separableConv2d: () => JD,
  sequential: () => dpe,
  serialization: () => ae2,
  setBackend: () => Ide,
  setPlatform: () => _de,
  setThreadsCount: () => Cpe,
  setWasmPath: () => Ipe,
  setWasmPaths: () => Spe,
  setWebGLContext: () => p5,
  setdiff1dAsync: () => t3,
  shared: () => Yy,
  sigmoid: () => qs,
  sign: () => s3,
  signal: () => upe,
  sin: () => dI,
  sinh: () => pI,
  slice: () => He,
  slice1d: () => rb,
  slice2d: () => hI,
  slice3d: () => ab,
  slice4d: () => wd,
  slice_util: () => wt,
  softmax: () => ib,
  softplus: () => Ol,
  spaceToBatchND: () => eb,
  sparse: () => Vc,
  sparseToDense: () => xI,
  spectral: () => ope,
  split: () => Ln,
  sqrt: () => ln,
  square: () => ct,
  squaredDifference: () => mI,
  squeeze: () => mr,
  stack: () => Qn,
  step: () => bp,
  stridedSlice: () => k3,
  string: () => Pf,
  sub: () => ge2,
  sum: () => ye2,
  sumOutType: () => lp,
  tan: () => S3,
  tanh: () => Hu,
  tensor: () => hs,
  tensor1d: () => Qt,
  tensor2d: () => ji,
  tensor3d: () => sA,
  tensor4d: () => tpe,
  tensor5d: () => npe,
  tensor6d: () => spe,
  tensor_util: () => _s,
  test_util: () => xA,
  tidy: () => j2,
  tile: () => cs,
  time: () => kde,
  topk: () => N3,
  train: () => Fi,
  transpose: () => qe,
  truncatedNormal: () => lb,
  unique: () => cx,
  unregisterGradient: () => fde,
  unregisterKernel: () => hde,
  unsortedSegmentSum: () => A3,
  unstack: () => Fs,
  upcastType: () => yn,
  util: () => w2,
  valueAndGrad: () => zde,
  valueAndGrads: () => Mde,
  variable: () => R3,
  variableGrads: () => MR,
  version: () => $pe,
  version_converter: () => ype,
  version_core: () => gde,
  version_cpu: () => vpe,
  version_layers: () => t0,
  version_wasm: () => Tpe,
  version_webgl: () => xpe,
  webgl: () => wpe,
  webgl_util: () => d5,
  webgpu: () => Hie,
  where: () => vn,
  whereAsync: () => bI,
  zeros: () => $t,
  zerosLike: () => je
});
var AT = Object.create;
var Bd = Object.defineProperty;
var ET = Object.getOwnPropertyDescriptor;
var Ow = Object.getOwnPropertyNames;
var RT = Object.getPrototypeOf;
var DT = Object.prototype.hasOwnProperty;
var FT = (e) => Bd(e, "__esModule", { value: true });
var zt = (e, t) => function() {
  return t || (0, e[Ow(e)[0]])((t = { exports: {} }).exports, t), t.exports;
};
var Ae = (e, t) => {
  for (var n10 in t)
    Bd(e, n10, { get: t[n10], enumerable: true });
};
var OT = (e, t, n10, s10) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let r10 of Ow(t))
      !DT.call(e, r10) && (n10 || r10 !== "default") && Bd(e, r10, { get: () => t[r10], enumerable: !(s10 = ET(t, r10)) || s10.enumerable });
  return e;
};
var ya = (e, t) => OT(FT(Bd(e != null ? AT(RT(e)) : {}, "default", !t && e && e.__esModule ? { get: () => e.default, enumerable: true } : { value: e, enumerable: true })), e);
var PT = zt({ "src/node_modules/long/src/long.js"(e, t) {
  t.exports = s10;
  var n10 = null;
  try {
    n10 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (F10) {
  }
  function s10(F10, $10, z10) {
    this.low = F10 | 0, this.high = $10 | 0, this.unsigned = !!z10;
  }
  s10.prototype.__isLong__, Object.defineProperty(s10.prototype, "__isLong__", { value: true });
  function r10(F10) {
    return (F10 && F10.__isLong__) === true;
  }
  s10.isLong = r10;
  var a10 = {}, i10 = {};
  function o10(F10, $10) {
    var z10, W10, q10;
    return $10 ? (F10 >>>= 0, (q10 = 0 <= F10 && F10 < 256) && (W10 = i10[F10], W10) ? W10 : (z10 = l10(F10, (F10 | 0) < 0 ? -1 : 0, true), q10 && (i10[F10] = z10), z10)) : (F10 |= 0, (q10 = -128 <= F10 && F10 < 128) && (W10 = a10[F10], W10) ? W10 : (z10 = l10(F10, F10 < 0 ? -1 : 0, false), q10 && (a10[F10] = z10), z10));
  }
  s10.fromInt = o10;
  function u10(F10, $10) {
    if (isNaN(F10))
      return $10 ? x10 : v10;
    if ($10) {
      if (F10 < 0)
        return x10;
      if (F10 >= g10)
        return A10;
    } else {
      if (F10 <= -b10)
        return P10;
      if (F10 + 1 >= b10)
        return E10;
    }
    return F10 < 0 ? u10(-F10, $10).neg() : l10(F10 % m10 | 0, F10 / m10 | 0, $10);
  }
  s10.fromNumber = u10;
  function l10(F10, $10, z10) {
    return new s10(F10, $10, z10);
  }
  s10.fromBits = l10;
  var c10 = Math.pow;
  function p10(F10, $10, z10) {
    if (F10.length === 0)
      throw Error("empty string");
    if (F10 === "NaN" || F10 === "Infinity" || F10 === "+Infinity" || F10 === "-Infinity")
      return v10;
    if (typeof $10 == "number" ? (z10 = $10, $10 = false) : $10 = !!$10, z10 = z10 || 10, z10 < 2 || 36 < z10)
      throw RangeError("radix");
    var W10;
    if ((W10 = F10.indexOf("-")) > 0)
      throw Error("interior hyphen");
    if (W10 === 0)
      return p10(F10.substring(1), $10, z10).neg();
    for (var q10 = u10(c10(z10, 8)), K10 = v10, Y10 = 0; Y10 < F10.length; Y10 += 8) {
      var Z10 = Math.min(8, F10.length - Y10), te2 = parseInt(F10.substring(Y10, Y10 + Z10), z10);
      if (Z10 < 8) {
        var ee2 = u10(c10(z10, Z10));
        K10 = K10.mul(ee2).add(u10(te2));
      } else
        K10 = K10.mul(q10), K10 = K10.add(u10(te2));
    }
    return K10.unsigned = $10, K10;
  }
  s10.fromString = p10;
  function d10(F10, $10) {
    return typeof F10 == "number" ? u10(F10, $10) : typeof F10 == "string" ? p10(F10, $10) : l10(F10.low, F10.high, typeof $10 == "boolean" ? $10 : F10.unsigned);
  }
  s10.fromValue = d10;
  var h10 = 1 << 16, f10 = 1 << 24, m10 = h10 * h10, g10 = m10 * m10, b10 = g10 / 2, y10 = o10(f10), v10 = o10(0);
  s10.ZERO = v10;
  var x10 = o10(0, true);
  s10.UZERO = x10;
  var k10 = o10(1);
  s10.ONE = k10;
  var C10 = o10(1, true);
  s10.UONE = C10;
  var T10 = o10(-1);
  s10.NEG_ONE = T10;
  var E10 = l10(-1, 2147483647, false);
  s10.MAX_VALUE = E10;
  var A10 = l10(-1, -1, true);
  s10.MAX_UNSIGNED_VALUE = A10;
  var P10 = l10(0, -2147483648, false);
  s10.MIN_VALUE = P10;
  var R10 = s10.prototype;
  R10.toInt = function() {
    return this.unsigned ? this.low >>> 0 : this.low;
  }, R10.toNumber = function() {
    return this.unsigned ? (this.high >>> 0) * m10 + (this.low >>> 0) : this.high * m10 + (this.low >>> 0);
  }, R10.toString = function($10) {
    if ($10 = $10 || 10, $10 < 2 || 36 < $10)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative())
      if (this.eq(P10)) {
        var z10 = u10($10), W10 = this.div(z10), q10 = W10.mul(z10).sub(this);
        return W10.toString($10) + q10.toInt().toString($10);
      } else
        return "-" + this.neg().toString($10);
    for (var K10 = u10(c10($10, 6), this.unsigned), Y10 = this, Z10 = ""; ; ) {
      var te2 = Y10.div(K10), ee2 = Y10.sub(te2.mul(K10)).toInt() >>> 0, se2 = ee2.toString($10);
      if (Y10 = te2, Y10.isZero())
        return se2 + Z10;
      for (; se2.length < 6; )
        se2 = "0" + se2;
      Z10 = "" + se2 + Z10;
    }
  }, R10.getHighBits = function() {
    return this.high;
  }, R10.getHighBitsUnsigned = function() {
    return this.high >>> 0;
  }, R10.getLowBits = function() {
    return this.low;
  }, R10.getLowBitsUnsigned = function() {
    return this.low >>> 0;
  }, R10.getNumBitsAbs = function() {
    if (this.isNegative())
      return this.eq(P10) ? 64 : this.neg().getNumBitsAbs();
    for (var $10 = this.high != 0 ? this.high : this.low, z10 = 31; z10 > 0 && ($10 & 1 << z10) == 0; z10--)
      ;
    return this.high != 0 ? z10 + 33 : z10 + 1;
  }, R10.isZero = function() {
    return this.high === 0 && this.low === 0;
  }, R10.eqz = R10.isZero, R10.isNegative = function() {
    return !this.unsigned && this.high < 0;
  }, R10.isPositive = function() {
    return this.unsigned || this.high >= 0;
  }, R10.isOdd = function() {
    return (this.low & 1) === 1;
  }, R10.isEven = function() {
    return (this.low & 1) === 0;
  }, R10.equals = function($10) {
    return r10($10) || ($10 = d10($10)), this.unsigned !== $10.unsigned && this.high >>> 31 === 1 && $10.high >>> 31 === 1 ? false : this.high === $10.high && this.low === $10.low;
  }, R10.eq = R10.equals, R10.notEquals = function($10) {
    return !this.eq($10);
  }, R10.neq = R10.notEquals, R10.ne = R10.notEquals, R10.lessThan = function($10) {
    return this.comp($10) < 0;
  }, R10.lt = R10.lessThan, R10.lessThanOrEqual = function($10) {
    return this.comp($10) <= 0;
  }, R10.lte = R10.lessThanOrEqual, R10.le = R10.lessThanOrEqual, R10.greaterThan = function($10) {
    return this.comp($10) > 0;
  }, R10.gt = R10.greaterThan, R10.greaterThanOrEqual = function($10) {
    return this.comp($10) >= 0;
  }, R10.gte = R10.greaterThanOrEqual, R10.ge = R10.greaterThanOrEqual, R10.compare = function($10) {
    if (r10($10) || ($10 = d10($10)), this.eq($10))
      return 0;
    var z10 = this.isNegative(), W10 = $10.isNegative();
    return z10 && !W10 ? -1 : !z10 && W10 ? 1 : this.unsigned ? $10.high >>> 0 > this.high >>> 0 || $10.high === this.high && $10.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub($10).isNegative() ? -1 : 1;
  }, R10.comp = R10.compare, R10.negate = function() {
    return !this.unsigned && this.eq(P10) ? P10 : this.not().add(k10);
  }, R10.neg = R10.negate, R10.add = function($10) {
    r10($10) || ($10 = d10($10));
    var z10 = this.high >>> 16, W10 = this.high & 65535, q10 = this.low >>> 16, K10 = this.low & 65535, Y10 = $10.high >>> 16, Z10 = $10.high & 65535, te2 = $10.low >>> 16, ee2 = $10.low & 65535, se2 = 0, ne2 = 0, oe2 = 0, re2 = 0;
    return re2 += K10 + ee2, oe2 += re2 >>> 16, re2 &= 65535, oe2 += q10 + te2, ne2 += oe2 >>> 16, oe2 &= 65535, ne2 += W10 + Z10, se2 += ne2 >>> 16, ne2 &= 65535, se2 += z10 + Y10, se2 &= 65535, l10(oe2 << 16 | re2, se2 << 16 | ne2, this.unsigned);
  }, R10.subtract = function($10) {
    return r10($10) || ($10 = d10($10)), this.add($10.neg());
  }, R10.sub = R10.subtract, R10.multiply = function($10) {
    if (this.isZero())
      return v10;
    if (r10($10) || ($10 = d10($10)), n10) {
      var z10 = n10.mul(this.low, this.high, $10.low, $10.high);
      return l10(z10, n10.get_high(), this.unsigned);
    }
    if ($10.isZero())
      return v10;
    if (this.eq(P10))
      return $10.isOdd() ? P10 : v10;
    if ($10.eq(P10))
      return this.isOdd() ? P10 : v10;
    if (this.isNegative())
      return $10.isNegative() ? this.neg().mul($10.neg()) : this.neg().mul($10).neg();
    if ($10.isNegative())
      return this.mul($10.neg()).neg();
    if (this.lt(y10) && $10.lt(y10))
      return u10(this.toNumber() * $10.toNumber(), this.unsigned);
    var W10 = this.high >>> 16, q10 = this.high & 65535, K10 = this.low >>> 16, Y10 = this.low & 65535, Z10 = $10.high >>> 16, te2 = $10.high & 65535, ee2 = $10.low >>> 16, se2 = $10.low & 65535, ne2 = 0, oe2 = 0, re2 = 0, le2 = 0;
    return le2 += Y10 * se2, re2 += le2 >>> 16, le2 &= 65535, re2 += K10 * se2, oe2 += re2 >>> 16, re2 &= 65535, re2 += Y10 * ee2, oe2 += re2 >>> 16, re2 &= 65535, oe2 += q10 * se2, ne2 += oe2 >>> 16, oe2 &= 65535, oe2 += K10 * ee2, ne2 += oe2 >>> 16, oe2 &= 65535, oe2 += Y10 * te2, ne2 += oe2 >>> 16, oe2 &= 65535, ne2 += W10 * se2 + q10 * ee2 + K10 * te2 + Y10 * Z10, ne2 &= 65535, l10(re2 << 16 | le2, ne2 << 16 | oe2, this.unsigned);
  }, R10.mul = R10.multiply, R10.divide = function($10) {
    if (r10($10) || ($10 = d10($10)), $10.isZero())
      throw Error("division by zero");
    if (n10) {
      if (!this.unsigned && this.high === -2147483648 && $10.low === -1 && $10.high === -1)
        return this;
      var z10 = (this.unsigned ? n10.div_u : n10.div_s)(this.low, this.high, $10.low, $10.high);
      return l10(z10, n10.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? x10 : v10;
    var W10, q10, K10;
    if (this.unsigned) {
      if ($10.unsigned || ($10 = $10.toUnsigned()), $10.gt(this))
        return x10;
      if ($10.gt(this.shru(1)))
        return C10;
      K10 = x10;
    } else {
      if (this.eq(P10)) {
        if ($10.eq(k10) || $10.eq(T10))
          return P10;
        if ($10.eq(P10))
          return k10;
        var Y10 = this.shr(1);
        return W10 = Y10.div($10).shl(1), W10.eq(v10) ? $10.isNegative() ? k10 : T10 : (q10 = this.sub($10.mul(W10)), K10 = W10.add(q10.div($10)), K10);
      } else if ($10.eq(P10))
        return this.unsigned ? x10 : v10;
      if (this.isNegative())
        return $10.isNegative() ? this.neg().div($10.neg()) : this.neg().div($10).neg();
      if ($10.isNegative())
        return this.div($10.neg()).neg();
      K10 = v10;
    }
    for (q10 = this; q10.gte($10); ) {
      W10 = Math.max(1, Math.floor(q10.toNumber() / $10.toNumber()));
      for (var Z10 = Math.ceil(Math.log(W10) / Math.LN2), te2 = Z10 <= 48 ? 1 : c10(2, Z10 - 48), ee2 = u10(W10), se2 = ee2.mul($10); se2.isNegative() || se2.gt(q10); )
        W10 -= te2, ee2 = u10(W10, this.unsigned), se2 = ee2.mul($10);
      ee2.isZero() && (ee2 = k10), K10 = K10.add(ee2), q10 = q10.sub(se2);
    }
    return K10;
  }, R10.div = R10.divide, R10.modulo = function($10) {
    if (r10($10) || ($10 = d10($10)), n10) {
      var z10 = (this.unsigned ? n10.rem_u : n10.rem_s)(this.low, this.high, $10.low, $10.high);
      return l10(z10, n10.get_high(), this.unsigned);
    }
    return this.sub(this.div($10).mul($10));
  }, R10.mod = R10.modulo, R10.rem = R10.modulo, R10.not = function() {
    return l10(~this.low, ~this.high, this.unsigned);
  }, R10.and = function($10) {
    return r10($10) || ($10 = d10($10)), l10(this.low & $10.low, this.high & $10.high, this.unsigned);
  }, R10.or = function($10) {
    return r10($10) || ($10 = d10($10)), l10(this.low | $10.low, this.high | $10.high, this.unsigned);
  }, R10.xor = function($10) {
    return r10($10) || ($10 = d10($10)), l10(this.low ^ $10.low, this.high ^ $10.high, this.unsigned);
  }, R10.shiftLeft = function($10) {
    return r10($10) && ($10 = $10.toInt()), ($10 &= 63) === 0 ? this : $10 < 32 ? l10(this.low << $10, this.high << $10 | this.low >>> 32 - $10, this.unsigned) : l10(0, this.low << $10 - 32, this.unsigned);
  }, R10.shl = R10.shiftLeft, R10.shiftRight = function($10) {
    return r10($10) && ($10 = $10.toInt()), ($10 &= 63) === 0 ? this : $10 < 32 ? l10(this.low >>> $10 | this.high << 32 - $10, this.high >> $10, this.unsigned) : l10(this.high >> $10 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  }, R10.shr = R10.shiftRight, R10.shiftRightUnsigned = function($10) {
    if (r10($10) && ($10 = $10.toInt()), $10 &= 63, $10 === 0)
      return this;
    var z10 = this.high;
    if ($10 < 32) {
      var W10 = this.low;
      return l10(W10 >>> $10 | z10 << 32 - $10, z10 >>> $10, this.unsigned);
    } else
      return $10 === 32 ? l10(z10, 0, this.unsigned) : l10(z10 >>> $10 - 32, 0, this.unsigned);
  }, R10.shru = R10.shiftRightUnsigned, R10.shr_u = R10.shiftRightUnsigned, R10.toSigned = function() {
    return this.unsigned ? l10(this.low, this.high, false) : this;
  }, R10.toUnsigned = function() {
    return this.unsigned ? this : l10(this.low, this.high, true);
  }, R10.toBytes = function($10) {
    return $10 ? this.toBytesLE() : this.toBytesBE();
  }, R10.toBytesLE = function() {
    var $10 = this.high, z10 = this.low;
    return [z10 & 255, z10 >>> 8 & 255, z10 >>> 16 & 255, z10 >>> 24, $10 & 255, $10 >>> 8 & 255, $10 >>> 16 & 255, $10 >>> 24];
  }, R10.toBytesBE = function() {
    var $10 = this.high, z10 = this.low;
    return [$10 >>> 24, $10 >>> 16 & 255, $10 >>> 8 & 255, $10 & 255, z10 >>> 24, z10 >>> 16 & 255, z10 >>> 8 & 255, z10 & 255];
  }, s10.fromBytes = function($10, z10, W10) {
    return W10 ? s10.fromBytesLE($10, z10) : s10.fromBytesBE($10, z10);
  }, s10.fromBytesLE = function($10, z10) {
    return new s10($10[0] | $10[1] << 8 | $10[2] << 16 | $10[3] << 24, $10[4] | $10[5] << 8 | $10[6] << 16 | $10[7] << 24, z10);
  }, s10.fromBytesBE = function($10, z10) {
    return new s10($10[4] << 24 | $10[5] << 16 | $10[6] << 8 | $10[7], $10[0] << 24 | $10[1] << 16 | $10[2] << 8 | $10[3], z10);
  };
} });
var zT = zt({ "(disabled):src/node_modules/node-fetch/browser.js"() {
} });
var MT = zt({ "(disabled):util"() {
} });
var LT = zt({ "src/node_modules/seedrandom/lib/alea.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(l10) {
      var c10 = this, p10 = u10();
      c10.next = function() {
        var d10 = 2091639 * c10.s0 + c10.c * 23283064365386963e-26;
        return c10.s0 = c10.s1, c10.s1 = c10.s2, c10.s2 = d10 - (c10.c = d10 | 0);
      }, c10.c = 1, c10.s0 = p10(" "), c10.s1 = p10(" "), c10.s2 = p10(" "), c10.s0 -= p10(l10), c10.s0 < 0 && (c10.s0 += 1), c10.s1 -= p10(l10), c10.s1 < 0 && (c10.s1 += 1), c10.s2 -= p10(l10), c10.s2 < 0 && (c10.s2 += 1), p10 = null;
    }
    function i10(l10, c10) {
      return c10.c = l10.c, c10.s0 = l10.s0, c10.s1 = l10.s1, c10.s2 = l10.s2, c10;
    }
    function o10(l10, c10) {
      var p10 = new a10(l10), d10 = c10 && c10.state, h10 = p10.next;
      return h10.int32 = function() {
        return p10.next() * 4294967296 | 0;
      }, h10.double = function() {
        return h10() + (h10() * 2097152 | 0) * 11102230246251565e-32;
      }, h10.quick = h10, d10 && (typeof d10 == "object" && i10(d10, p10), h10.state = function() {
        return i10(p10, {});
      }), h10;
    }
    function u10() {
      var l10 = 4022871197, c10 = function(p10) {
        p10 = String(p10);
        for (var d10 = 0; d10 < p10.length; d10++) {
          l10 += p10.charCodeAt(d10);
          var h10 = 0.02519603282416938 * l10;
          l10 = h10 >>> 0, h10 -= l10, h10 *= l10, l10 = h10 >>> 0, h10 -= l10, l10 += h10 * 4294967296;
        }
        return (l10 >>> 0) * 23283064365386963e-26;
      };
      return c10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.alea = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var BT = zt({ "src/node_modules/seedrandom/lib/xor128.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(u10) {
      var l10 = this, c10 = "";
      l10.x = 0, l10.y = 0, l10.z = 0, l10.w = 0, l10.next = function() {
        var d10 = l10.x ^ l10.x << 11;
        return l10.x = l10.y, l10.y = l10.z, l10.z = l10.w, l10.w ^= l10.w >>> 19 ^ d10 ^ d10 >>> 8;
      }, u10 === (u10 | 0) ? l10.x = u10 : c10 += u10;
      for (var p10 = 0; p10 < c10.length + 64; p10++)
        l10.x ^= c10.charCodeAt(p10) | 0, l10.next();
    }
    function i10(u10, l10) {
      return l10.x = u10.x, l10.y = u10.y, l10.z = u10.z, l10.w = u10.w, l10;
    }
    function o10(u10, l10) {
      var c10 = new a10(u10), p10 = l10 && l10.state, d10 = function() {
        return (c10.next() >>> 0) / 4294967296;
      };
      return d10.double = function() {
        do
          var h10 = c10.next() >>> 11, f10 = (c10.next() >>> 0) / 4294967296, m10 = (h10 + f10) / (1 << 21);
        while (m10 === 0);
        return m10;
      }, d10.int32 = c10.next, d10.quick = d10, p10 && (typeof p10 == "object" && i10(p10, c10), d10.state = function() {
        return i10(c10, {});
      }), d10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.xor128 = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var VT = zt({ "src/node_modules/seedrandom/lib/xorwow.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(u10) {
      var l10 = this, c10 = "";
      l10.next = function() {
        var d10 = l10.x ^ l10.x >>> 2;
        return l10.x = l10.y, l10.y = l10.z, l10.z = l10.w, l10.w = l10.v, (l10.d = l10.d + 362437 | 0) + (l10.v = l10.v ^ l10.v << 4 ^ (d10 ^ d10 << 1)) | 0;
      }, l10.x = 0, l10.y = 0, l10.z = 0, l10.w = 0, l10.v = 0, u10 === (u10 | 0) ? l10.x = u10 : c10 += u10;
      for (var p10 = 0; p10 < c10.length + 64; p10++)
        l10.x ^= c10.charCodeAt(p10) | 0, p10 == c10.length && (l10.d = l10.x << 10 ^ l10.x >>> 4), l10.next();
    }
    function i10(u10, l10) {
      return l10.x = u10.x, l10.y = u10.y, l10.z = u10.z, l10.w = u10.w, l10.v = u10.v, l10.d = u10.d, l10;
    }
    function o10(u10, l10) {
      var c10 = new a10(u10), p10 = l10 && l10.state, d10 = function() {
        return (c10.next() >>> 0) / 4294967296;
      };
      return d10.double = function() {
        do
          var h10 = c10.next() >>> 11, f10 = (c10.next() >>> 0) / 4294967296, m10 = (h10 + f10) / (1 << 21);
        while (m10 === 0);
        return m10;
      }, d10.int32 = c10.next, d10.quick = d10, p10 && (typeof p10 == "object" && i10(p10, c10), d10.state = function() {
        return i10(c10, {});
      }), d10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.xorwow = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var WT = zt({ "src/node_modules/seedrandom/lib/xorshift7.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(u10) {
      var l10 = this;
      l10.next = function() {
        var p10 = l10.x, d10 = l10.i, h10, f10, m10;
        return h10 = p10[d10], h10 ^= h10 >>> 7, f10 = h10 ^ h10 << 24, h10 = p10[d10 + 1 & 7], f10 ^= h10 ^ h10 >>> 10, h10 = p10[d10 + 3 & 7], f10 ^= h10 ^ h10 >>> 3, h10 = p10[d10 + 4 & 7], f10 ^= h10 ^ h10 << 7, h10 = p10[d10 + 7 & 7], h10 = h10 ^ h10 << 13, f10 ^= h10 ^ h10 << 9, p10[d10] = f10, l10.i = d10 + 1 & 7, f10;
      };
      function c10(p10, d10) {
        var h10, f10, m10 = [];
        if (d10 === (d10 | 0))
          f10 = m10[0] = d10;
        else
          for (d10 = "" + d10, h10 = 0; h10 < d10.length; ++h10)
            m10[h10 & 7] = m10[h10 & 7] << 15 ^ d10.charCodeAt(h10) + m10[h10 + 1 & 7] << 13;
        for (; m10.length < 8; )
          m10.push(0);
        for (h10 = 0; h10 < 8 && m10[h10] === 0; ++h10)
          ;
        for (h10 == 8 ? f10 = m10[7] = -1 : f10 = m10[h10], p10.x = m10, p10.i = 0, h10 = 256; h10 > 0; --h10)
          p10.next();
      }
      c10(l10, u10);
    }
    function i10(u10, l10) {
      return l10.x = u10.x.slice(), l10.i = u10.i, l10;
    }
    function o10(u10, l10) {
      u10 == null && (u10 = +new Date());
      var c10 = new a10(u10), p10 = l10 && l10.state, d10 = function() {
        return (c10.next() >>> 0) / 4294967296;
      };
      return d10.double = function() {
        do
          var h10 = c10.next() >>> 11, f10 = (c10.next() >>> 0) / 4294967296, m10 = (h10 + f10) / (1 << 21);
        while (m10 === 0);
        return m10;
      }, d10.int32 = c10.next, d10.quick = d10, p10 && (p10.x && i10(p10, c10), d10.state = function() {
        return i10(c10, {});
      }), d10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.xorshift7 = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var UT = zt({ "src/node_modules/seedrandom/lib/xor4096.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(u10) {
      var l10 = this;
      l10.next = function() {
        var p10 = l10.w, d10 = l10.X, h10 = l10.i, f10, m10;
        return l10.w = p10 = p10 + 1640531527 | 0, m10 = d10[h10 + 34 & 127], f10 = d10[h10 = h10 + 1 & 127], m10 ^= m10 << 13, f10 ^= f10 << 17, m10 ^= m10 >>> 15, f10 ^= f10 >>> 12, m10 = d10[h10] = m10 ^ f10, l10.i = h10, m10 + (p10 ^ p10 >>> 16) | 0;
      };
      function c10(p10, d10) {
        var h10, f10, m10, g10, b10, y10 = [], v10 = 128;
        for (d10 === (d10 | 0) ? (f10 = d10, d10 = null) : (d10 = d10 + "\0", f10 = 0, v10 = Math.max(v10, d10.length)), m10 = 0, g10 = -32; g10 < v10; ++g10)
          d10 && (f10 ^= d10.charCodeAt((g10 + 32) % d10.length)), g10 === 0 && (b10 = f10), f10 ^= f10 << 10, f10 ^= f10 >>> 15, f10 ^= f10 << 4, f10 ^= f10 >>> 13, g10 >= 0 && (b10 = b10 + 1640531527 | 0, h10 = y10[g10 & 127] ^= f10 + b10, m10 = h10 == 0 ? m10 + 1 : 0);
        for (m10 >= 128 && (y10[(d10 && d10.length || 0) & 127] = -1), m10 = 127, g10 = 4 * 128; g10 > 0; --g10)
          f10 = y10[m10 + 34 & 127], h10 = y10[m10 = m10 + 1 & 127], f10 ^= f10 << 13, h10 ^= h10 << 17, f10 ^= f10 >>> 15, h10 ^= h10 >>> 12, y10[m10] = f10 ^ h10;
        p10.w = b10, p10.X = y10, p10.i = m10;
      }
      c10(l10, u10);
    }
    function i10(u10, l10) {
      return l10.i = u10.i, l10.w = u10.w, l10.X = u10.X.slice(), l10;
    }
    function o10(u10, l10) {
      u10 == null && (u10 = +new Date());
      var c10 = new a10(u10), p10 = l10 && l10.state, d10 = function() {
        return (c10.next() >>> 0) / 4294967296;
      };
      return d10.double = function() {
        do
          var h10 = c10.next() >>> 11, f10 = (c10.next() >>> 0) / 4294967296, m10 = (h10 + f10) / (1 << 21);
        while (m10 === 0);
        return m10;
      }, d10.int32 = c10.next, d10.quick = d10, p10 && (p10.X && i10(p10, c10), d10.state = function() {
        return i10(c10, {});
      }), d10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.xor4096 = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var GT = zt({ "src/node_modules/seedrandom/lib/tychei.js"(e, t) {
  (function(n10, s10, r10) {
    function a10(u10) {
      var l10 = this, c10 = "";
      l10.next = function() {
        var d10 = l10.b, h10 = l10.c, f10 = l10.d, m10 = l10.a;
        return d10 = d10 << 25 ^ d10 >>> 7 ^ h10, h10 = h10 - f10 | 0, f10 = f10 << 24 ^ f10 >>> 8 ^ m10, m10 = m10 - d10 | 0, l10.b = d10 = d10 << 20 ^ d10 >>> 12 ^ h10, l10.c = h10 = h10 - f10 | 0, l10.d = f10 << 16 ^ h10 >>> 16 ^ m10, l10.a = m10 - d10 | 0;
      }, l10.a = 0, l10.b = 0, l10.c = -1640531527, l10.d = 1367130551, u10 === Math.floor(u10) ? (l10.a = u10 / 4294967296 | 0, l10.b = u10 | 0) : c10 += u10;
      for (var p10 = 0; p10 < c10.length + 20; p10++)
        l10.b ^= c10.charCodeAt(p10) | 0, l10.next();
    }
    function i10(u10, l10) {
      return l10.a = u10.a, l10.b = u10.b, l10.c = u10.c, l10.d = u10.d, l10;
    }
    function o10(u10, l10) {
      var c10 = new a10(u10), p10 = l10 && l10.state, d10 = function() {
        return (c10.next() >>> 0) / 4294967296;
      };
      return d10.double = function() {
        do
          var h10 = c10.next() >>> 11, f10 = (c10.next() >>> 0) / 4294967296, m10 = (h10 + f10) / (1 << 21);
        while (m10 === 0);
        return m10;
      }, d10.int32 = c10.next, d10.quick = d10, p10 && (typeof p10 == "object" && i10(p10, c10), d10.state = function() {
        return i10(c10, {});
      }), d10;
    }
    s10 && s10.exports ? s10.exports = o10 : r10 && r10.amd ? r10(function() {
      return o10;
    }) : this.tychei = o10;
  })(e, typeof t == "object" && t, typeof define == "function" && define);
} });
var HT = zt({ "(disabled):crypto"() {
} });
var qT = zt({ "src/node_modules/seedrandom/seedrandom.js"(e, t) {
  (function(n10, s10, r10) {
    var a10 = 256, i10 = 6, o10 = 52, u10 = "random", l10 = r10.pow(a10, i10), c10 = r10.pow(2, o10), p10 = c10 * 2, d10 = a10 - 1, h10;
    function f10(k10, C10, T10) {
      var E10 = [];
      C10 = C10 == true ? { entropy: true } : C10 || {};
      var A10 = y10(b10(C10.entropy ? [k10, x10(s10)] : k10 == null ? v10() : k10, 3), E10), P10 = new m10(E10), R10 = function() {
        for (var F10 = P10.g(i10), $10 = l10, z10 = 0; F10 < c10; )
          F10 = (F10 + z10) * a10, $10 *= a10, z10 = P10.g(1);
        for (; F10 >= p10; )
          F10 /= 2, $10 /= 2, z10 >>>= 1;
        return (F10 + z10) / $10;
      };
      return R10.int32 = function() {
        return P10.g(4) | 0;
      }, R10.quick = function() {
        return P10.g(4) / 4294967296;
      }, R10.double = R10, y10(x10(P10.S), s10), (C10.pass || T10 || function(F10, $10, z10, W10) {
        return W10 && (W10.S && g10(W10, P10), F10.state = function() {
          return g10(P10, {});
        }), z10 ? (r10[u10] = F10, $10) : F10;
      })(R10, A10, "global" in C10 ? C10.global : this == r10, C10.state);
    }
    function m10(k10) {
      var C10, T10 = k10.length, E10 = this, A10 = 0, P10 = E10.i = E10.j = 0, R10 = E10.S = [];
      for (T10 || (k10 = [T10++]); A10 < a10; )
        R10[A10] = A10++;
      for (A10 = 0; A10 < a10; A10++)
        R10[A10] = R10[P10 = d10 & P10 + k10[A10 % T10] + (C10 = R10[A10])], R10[P10] = C10;
      (E10.g = function(F10) {
        for (var $10, z10 = 0, W10 = E10.i, q10 = E10.j, K10 = E10.S; F10--; )
          $10 = K10[W10 = d10 & W10 + 1], z10 = z10 * a10 + K10[d10 & (K10[W10] = K10[q10 = d10 & q10 + $10]) + (K10[q10] = $10)];
        return E10.i = W10, E10.j = q10, z10;
      })(a10);
    }
    function g10(k10, C10) {
      return C10.i = k10.i, C10.j = k10.j, C10.S = k10.S.slice(), C10;
    }
    function b10(k10, C10) {
      var T10 = [], E10 = typeof k10, A10;
      if (C10 && E10 == "object")
        for (A10 in k10)
          try {
            T10.push(b10(k10[A10], C10 - 1));
          } catch (P10) {
          }
      return T10.length ? T10 : E10 == "string" ? k10 : k10 + "\0";
    }
    function y10(k10, C10) {
      for (var T10 = k10 + "", E10, A10 = 0; A10 < T10.length; )
        C10[d10 & A10] = d10 & (E10 ^= C10[d10 & A10] * 19) + T10.charCodeAt(A10++);
      return x10(C10);
    }
    function v10() {
      try {
        var k10;
        return h10 && (k10 = h10.randomBytes) ? k10 = k10(a10) : (k10 = new Uint8Array(a10), (n10.crypto || n10.msCrypto).getRandomValues(k10)), x10(k10);
      } catch (E10) {
        var C10 = n10.navigator, T10 = C10 && C10.plugins;
        return [+new Date(), n10, T10, n10.screen, x10(s10)];
      }
    }
    function x10(k10) {
      return String.fromCharCode.apply(0, k10);
    }
    if (y10(r10.random(), s10), typeof t == "object" && t.exports) {
      t.exports = f10;
      try {
        h10 = HT();
      } catch (k10) {
      }
    } else
      typeof define == "function" && define.amd ? define(function() {
        return f10;
      }) : r10["seed" + u10] = f10;
  })(typeof self != "undefined" ? self : e, [], Math);
} });
var Vd = zt({ "src/node_modules/seedrandom/index.js"(e, t) {
  var n10 = LT(), s10 = BT(), r10 = VT(), a10 = WT(), i10 = UT(), o10 = GT(), u10 = qT();
  u10.alea = n10, u10.xor128 = s10, u10.xorwow = r10, u10.xorshift7 = a10, u10.xor4096 = i10, u10.tychei = o10, t.exports = u10;
} });
var Pw = zt({ "(disabled):src/node_modules/string_decoder/index.js"() {
} });
var Jm = zt({ "(disabled):fs"() {
} });
var cd = zt({ "(disabled):path"() {
} });
var jT = zt({ "(disabled):worker_threads"() {
} });
var KT = zt({ "(disabled):perf_hooks"() {
} });
var XT = zt({ "(disabled):os"() {
} });
var YT = zt({ "src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e, t) {
  var n10 = (() => {
    var s10 = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename != "undefined" && (s10 = s10 || __filename), function(r10) {
      r10 = r10 || {};
      function a10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), ac;
      }
      function i10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), ic;
      }
      function o10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), pu;
      }
      function u10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), oc;
      }
      function l10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), uc;
      }
      function c10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), lc;
      }
      function p10() {
        return Ce2.buffer != tn && ns(Ce2.buffer), cc;
      }
      var d10 = typeof r10 != "undefined" ? r10 : {}, h10, f10;
      d10.ready = new Promise(function(S10, D10) {
        h10 = S10, f10 = D10;
      });
      var m10;
      typeof process != "undefined" && process.listeners && (m10 = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
      var g10 = Object.assign({}, d10), b10 = [], y10 = "./this.program", v10 = (S10, D10) => {
        throw D10;
      }, x10 = typeof window == "object", k10 = typeof importScripts == "function", C10 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", T10 = d10.ENVIRONMENT_IS_PTHREAD || false, E10 = "";
      function A10(S10) {
        return d10.locateFile ? d10.locateFile(S10, E10) : E10 + S10;
      }
      var P10, R10, F10, $10;
      function z10(S10) {
        if (S10 instanceof wu)
          return;
        ee2("exiting due to exception: " + S10);
      }
      var W10, q10, K10;
      if (C10) {
        k10 ? E10 = cd().dirname(E10) + "/" : E10 = __dirname + "/", K10 = () => {
          q10 || (W10 = Jm(), q10 = cd());
        }, P10 = function(B10, Q10) {
          return K10(), B10 = q10.normalize(B10), W10.readFileSync(B10, Q10 ? void 0 : "utf8");
        }, F10 = (D10) => {
          var B10 = P10(D10, true);
          return B10.buffer || (B10 = new Uint8Array(B10)), B10;
        }, R10 = (D10, B10, Q10) => {
          K10(), D10 = q10.normalize(D10), W10.readFile(D10, function(ue2, pe2) {
            ue2 ? Q10(ue2) : B10(pe2.buffer);
          });
        }, process.argv.length > 1 && (y10 = process.argv[1].replace(/\\/g, "/")), b10 = process.argv.slice(2), process.on("uncaughtException", function(D10) {
          if (!(D10 instanceof wu))
            throw D10;
        }), process.on("unhandledRejection", function(D10) {
          throw D10;
        }), v10 = (D10, B10) => {
          if (Or())
            throw process.exitCode = D10, B10;
          z10(B10), process.exit(D10);
        }, d10.inspect = function() {
          return "[Emscripten Module object]";
        };
        let S10;
        try {
          S10 = jT();
        } catch (D10) {
          throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), D10;
        }
        global.Worker = S10.Worker;
      } else
        (x10 || k10) && (k10 ? E10 = self.location.href : typeof document != "undefined" && document.currentScript && (E10 = document.currentScript.src), typeof s10 != "undefined" && s10 && (E10 = s10), E10.indexOf("blob:") !== 0 ? E10 = E10.substr(0, E10.replace(/[?#].*/, "").lastIndexOf("/") + 1) : E10 = "", C10 || (P10 = (S10) => {
          var D10 = new XMLHttpRequest();
          return D10.open("GET", S10, false), D10.send(null), D10.responseText;
        }, k10 && (F10 = (S10) => {
          var D10 = new XMLHttpRequest();
          return D10.open("GET", S10, false), D10.responseType = "arraybuffer", D10.send(null), new Uint8Array(D10.response);
        }), R10 = (S10, D10, B10) => {
          var Q10 = new XMLHttpRequest();
          Q10.open("GET", S10, true), Q10.responseType = "arraybuffer", Q10.onload = () => {
            if (Q10.status == 200 || Q10.status == 0 && Q10.response) {
              D10(Q10.response);
              return;
            }
            B10();
          }, Q10.onerror = B10, Q10.send(null);
        }), $10 = (S10) => document.title = S10);
      C10 && typeof performance == "undefined" && (global.performance = KT().performance);
      var Y10 = console.log.bind(console), Z10 = console.warn.bind(console);
      C10 && (K10(), Y10 = (S10) => W10.writeSync(1, S10 + `
`), Z10 = (S10) => W10.writeSync(2, S10 + `
`));
      var te2 = d10.print || Y10, ee2 = d10.printErr || Z10;
      Object.assign(d10, g10), g10 = null, d10.arguments && (b10 = d10.arguments), d10.thisProgram && (y10 = d10.thisProgram), d10.quit && (v10 = d10.quit);
      var se2 = 4;
      function ne2(S10) {
        ne2.shown || (ne2.shown = {}), ne2.shown[S10] || (ne2.shown[S10] = 1, ee2(S10));
      }
      function oe2(S10, D10) {
        if (typeof WebAssembly.Function == "function") {
          for (var B10 = { i: "i32", j: "i64", f: "f32", d: "f64" }, Q10 = { parameters: [], results: D10[0] == "v" ? [] : [B10[D10[0]]] }, ue2 = 1; ue2 < D10.length; ++ue2)
            Q10.parameters.push(B10[D10[ue2]]);
          return new WebAssembly.Function(Q10, S10);
        }
        var pe2 = [1, 0, 1, 96], be = D10.slice(0, 1), Te2 = D10.slice(1), bt = { i: 127, j: 126, f: 125, d: 124 };
        pe2.push(Te2.length);
        for (var ue2 = 0; ue2 < Te2.length; ++ue2)
          pe2.push(bt[Te2[ue2]]);
        be == "v" ? pe2.push(0) : pe2 = pe2.concat([1, bt[be]]), pe2[1] = pe2.length - 2;
        var is = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(pe2, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])), os = new WebAssembly.Module(is), Lc = new WebAssembly.Instance(os, { e: { f: S10 } }), ku = Lc.exports.f;
        return ku;
      }
      var re2 = [], le2;
      function me2() {
        if (re2.length)
          return re2.pop();
        try {
          Dn.grow(1);
        } catch (S10) {
          throw S10 instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : S10;
        }
        return Dn.length - 1;
      }
      function we2(S10, D10) {
        for (var B10 = S10; B10 < S10 + D10; B10++) {
          var Q10 = Ni(B10);
          Q10 && le2.set(Q10, B10);
        }
      }
      var Se2 = 0, Ee2 = (S10) => {
        Se2 = S10;
      }, Pe2 = Atomics.load, Xe = Atomics.store, Je = Atomics.compareExchange, Ye;
      d10.wasmBinary && (Ye = d10.wasmBinary);
      var tt = d10.noExitRuntime || true;
      typeof WebAssembly != "object" && Ii("no native wasm support detected");
      var Ce2, ut, rt = false, Zt;
      function Nt(S10, D10) {
        S10 || Ii(D10);
      }
      function In(S10) {
        var D10 = d10["_" + S10];
        return D10;
      }
      function Et(S10, D10, B10, Q10, ue2) {
        var pe2 = { string: function(Nn) {
          var Di = 0;
          if (Nn != null && Nn !== 0) {
            var Qv = (Nn.length << 2) + 1;
            Di = Ri(Qv), Ls(Nn, Di, Qv);
          }
          return Di;
        }, array: function(Nn) {
          var Di = Ri(Nn.length);
          return Bs(Nn, Di), Di;
        } };
        function be(Nn) {
          return D10 === "string" ? en(Nn) : D10 === "boolean" ? Boolean(Nn) : Nn;
        }
        var Te2 = In(S10), bt = [], is = 0;
        if (Q10)
          for (var os = 0; os < Q10.length; os++) {
            var Lc = pe2[B10[os]];
            Lc ? (is === 0 && (is = _f()), bt[os] = Lc(Q10[os])) : bt[os] = Q10[os];
          }
        var ku = Te2.apply(null, bt);
        function _T(Nn) {
          return is !== 0 && Oc(is), be(Nn);
        }
        return ku = _T(ku), ku;
      }
      function Jt(S10, D10, B10, Q10) {
        B10 = B10 || [];
        var ue2 = B10.every(function(be) {
          return be === "number";
        }), pe2 = D10 !== "string";
        return pe2 && ue2 && !Q10 ? In(S10) : function() {
          return Et(S10, D10, B10, arguments, Q10);
        };
      }
      var Sn = 1;
      function Cn(S10) {
        var D10 = new TextDecoder(S10);
        this.decode = (B10) => (B10.buffer instanceof SharedArrayBuffer && (B10 = new Uint8Array(B10)), D10.decode.call(D10, B10));
      }
      var Xt = typeof TextDecoder != "undefined" ? new Cn("utf8") : void 0;
      function Rn(S10, D10, B10) {
        for (var Q10 = D10 + B10, ue2 = D10; S10[ue2] && !(ue2 >= Q10); )
          ++ue2;
        if (ue2 - D10 > 16 && S10.subarray && Xt)
          return Xt.decode(S10.subarray(D10, ue2));
        for (var pe2 = ""; D10 < ue2; ) {
          var be = S10[D10++];
          if (!(be & 128)) {
            pe2 += String.fromCharCode(be);
            continue;
          }
          var Te2 = S10[D10++] & 63;
          if ((be & 224) == 192) {
            pe2 += String.fromCharCode((be & 31) << 6 | Te2);
            continue;
          }
          var bt = S10[D10++] & 63;
          if ((be & 240) == 224 ? be = (be & 15) << 12 | Te2 << 6 | bt : be = (be & 7) << 18 | Te2 << 12 | bt << 6 | S10[D10++] & 63, be < 65536)
            pe2 += String.fromCharCode(be);
          else {
            var is = be - 65536;
            pe2 += String.fromCharCode(55296 | is >> 10, 56320 | is & 1023);
          }
        }
        return pe2;
      }
      function en(S10, D10) {
        return S10 ? Rn(i10(), S10, D10) : "";
      }
      function Ms(S10, D10, B10, Q10) {
        if (!(Q10 > 0))
          return 0;
        for (var ue2 = B10, pe2 = B10 + Q10 - 1, be = 0; be < S10.length; ++be) {
          var Te2 = S10.charCodeAt(be);
          if (Te2 >= 55296 && Te2 <= 57343) {
            var bt = S10.charCodeAt(++be);
            Te2 = 65536 + ((Te2 & 1023) << 10) | bt & 1023;
          }
          if (Te2 <= 127) {
            if (B10 >= pe2)
              break;
            D10[B10++] = Te2;
          } else if (Te2 <= 2047) {
            if (B10 + 1 >= pe2)
              break;
            D10[B10++] = 192 | Te2 >> 6, D10[B10++] = 128 | Te2 & 63;
          } else if (Te2 <= 65535) {
            if (B10 + 2 >= pe2)
              break;
            D10[B10++] = 224 | Te2 >> 12, D10[B10++] = 128 | Te2 >> 6 & 63, D10[B10++] = 128 | Te2 & 63;
          } else {
            if (B10 + 3 >= pe2)
              break;
            D10[B10++] = 240 | Te2 >> 18, D10[B10++] = 128 | Te2 >> 12 & 63, D10[B10++] = 128 | Te2 >> 6 & 63, D10[B10++] = 128 | Te2 & 63;
          }
        }
        return D10[B10] = 0, B10 - ue2;
      }
      function Ls(S10, D10, B10) {
        return Ms(S10, i10(), D10, B10);
      }
      function xi(S10) {
        for (var D10 = 0, B10 = 0; B10 < S10.length; ++B10) {
          var Q10 = S10.charCodeAt(B10);
          Q10 >= 55296 && Q10 <= 57343 && (Q10 = 65536 + ((Q10 & 1023) << 10) | S10.charCodeAt(++B10) & 1023), Q10 <= 127 ? ++D10 : Q10 <= 2047 ? D10 += 2 : Q10 <= 65535 ? D10 += 3 : D10 += 4;
        }
        return D10;
      }
      var Js = typeof TextDecoder != "undefined" ? new Cn("utf-16le") : void 0;
      function Bs(S10, D10) {
        a10().set(S10, D10);
      }
      function du(S10, D10, B10) {
        for (var Q10 = 0; Q10 < S10.length; ++Q10)
          a10()[D10++ >> 0] = S10.charCodeAt(Q10);
        B10 || (a10()[D10 >> 0] = 0);
      }
      function wi(S10, D10) {
        return S10 % D10 > 0 && (S10 += D10 - S10 % D10), S10;
      }
      var tn, ac, ic, pu, oc, uc, Ev, lc, cc;
      T10 && (tn = d10.buffer);
      function ns(S10) {
        tn = S10, d10.HEAP8 = ac = new Int8Array(S10), d10.HEAP16 = pu = new Int16Array(S10), d10.HEAP32 = uc = new Int32Array(S10), d10.HEAPU8 = ic = new Uint8Array(S10), d10.HEAPU16 = oc = new Uint16Array(S10), d10.HEAPU32 = Ev = new Uint32Array(S10), d10.HEAPF32 = lc = new Float32Array(S10), d10.HEAPF64 = cc = new Float64Array(S10);
      }
      var dc = d10.INITIAL_MEMORY || 16777216;
      if (T10)
        Ce2 = d10.wasmMemory, tn = d10.buffer;
      else if (d10.wasmMemory)
        Ce2 = d10.wasmMemory;
      else if (Ce2 = new WebAssembly.Memory({ initial: dc / 65536, maximum: 32768, shared: true }), !(Ce2.buffer instanceof SharedArrayBuffer))
        throw ee2("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), C10 && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
      Ce2 && (tn = Ce2.buffer), dc = tn.byteLength, ns(tn);
      var Dn, ki = [], er = [], eh = [], pc = [], Fr = false, th = false, hc = 0;
      function Or() {
        return tt || hc > 0;
      }
      function nn() {
        if (d10.preRun)
          for (typeof d10.preRun == "function" && (d10.preRun = [d10.preRun]); d10.preRun.length; )
            Rv(d10.preRun.shift());
        yc(ki);
      }
      function hu() {
        Fr = true, !T10 && yc(er);
      }
      function nh() {
        T10 || ($e.terminateAllThreads(), th = true);
      }
      function sh() {
        if (!T10) {
          if (d10.postRun)
            for (typeof d10.postRun == "function" && (d10.postRun = [d10.postRun]); d10.postRun.length; )
              fu(d10.postRun.shift());
          yc(pc);
        }
      }
      function Rv(S10) {
        ki.unshift(S10);
      }
      function Dv(S10) {
        er.unshift(S10);
      }
      function fu(S10) {
        pc.unshift(S10);
      }
      var tr = 0, fc = null, ss = null;
      function mu(S10) {
        tr++, d10.monitorRunDependencies && d10.monitorRunDependencies(tr);
      }
      function Fv(S10) {
        if (tr--, d10.monitorRunDependencies && d10.monitorRunDependencies(tr), tr == 0 && (fc !== null && (clearInterval(fc), fc = null), ss)) {
          var D10 = ss;
          ss = null, D10();
        }
      }
      d10.preloadedImages = {}, d10.preloadedAudios = {};
      function Ii(S10) {
        T10 ? postMessage({ cmd: "onAbort", arg: S10 }) : d10.onAbort && d10.onAbort(S10), S10 = "Aborted(" + S10 + ")", ee2(S10), rt = true, Zt = 1, S10 += ". Build with -s ASSERTIONS=1 for more info.";
        var D10 = new WebAssembly.RuntimeError(S10);
        throw f10(D10), D10;
      }
      var rh = "data:application/octet-stream;base64,";
      function mc(S10) {
        return S10.startsWith(rh);
      }
      function gc(S10) {
        return S10.startsWith("file://");
      }
      var sn;
      sn = "tfjs-backend-wasm-threaded-simd.wasm", mc(sn) || (sn = A10(sn));
      function bc(S10) {
        try {
          if (S10 == sn && Ye)
            return new Uint8Array(Ye);
          if (F10)
            return F10(S10);
          throw "both async and sync fetching of the wasm failed";
        } catch (D10) {
          Ii(D10);
        }
      }
      function Si() {
        if (!Ye && (x10 || k10)) {
          if (typeof fetch == "function" && !gc(sn))
            return fetch(sn, { credentials: "same-origin" }).then(function(S10) {
              if (!S10.ok)
                throw "failed to load wasm binary file at '" + sn + "'";
              return S10.arrayBuffer();
            }).catch(function() {
              return bc(sn);
            });
          if (R10)
            return new Promise(function(S10, D10) {
              R10(sn, function(B10) {
                S10(new Uint8Array(B10));
              }, D10);
            });
        }
        return Promise.resolve().then(function() {
          return bc(sn);
        });
      }
      function ah() {
        var S10 = { env: Ac, wasi_snapshot_preview1: Ac };
        function D10(be, Te2) {
          var bt = be.exports;
          if (d10.asm = bt, ph(d10.asm.emscripten_tls_init), Dn = d10.asm.__indirect_function_table, Dv(d10.asm.__wasm_call_ctors), ut = Te2, !T10) {
            var is = $e.unusedWorkers.length;
            $e.unusedWorkers.forEach(function(os) {
              $e.loadWasmModuleToWorker(os, function() {
                --is || Fv("wasm-instantiate");
              });
            });
          }
        }
        T10 || mu("wasm-instantiate");
        function B10(be) {
          D10(be.instance, be.module);
        }
        function Q10(be) {
          return Si().then(function(Te2) {
            return WebAssembly.instantiate(Te2, S10);
          }).then(function(Te2) {
            return Te2;
          }).then(be, function(Te2) {
            ee2("failed to asynchronously prepare wasm: " + Te2), Ii(Te2);
          });
        }
        function ue2() {
          return !Ye && typeof WebAssembly.instantiateStreaming == "function" && !mc(sn) && !gc(sn) && typeof fetch == "function" ? fetch(sn, { credentials: "same-origin" }).then(function(be) {
            var Te2 = WebAssembly.instantiateStreaming(be, S10);
            return Te2.then(B10, function(bt) {
              return ee2("wasm streaming compile failed: " + bt), ee2("falling back to ArrayBuffer instantiation"), Q10(B10);
            });
          }) : Q10(B10);
        }
        if (d10.instantiateWasm)
          try {
            var pe2 = d10.instantiateWasm(S10, D10);
            return pe2;
          } catch (be) {
            return ee2("Module.instantiateWasm callback failed with error: " + be), false;
          }
        return ue2().catch(f10), {};
      }
      var Ov, Pv, ih = {};
      function yc(S10) {
        for (; S10.length > 0; ) {
          var D10 = S10.shift();
          if (typeof D10 == "function") {
            D10(d10);
            continue;
          }
          var B10 = D10.func;
          typeof B10 == "number" ? D10.arg === void 0 ? Ni(B10)() : Ni(B10)(D10.arg) : B10(D10.arg === void 0 ? null : D10.arg);
        }
      }
      function Ci(S10) {
        var D10 = _f(), B10 = S10();
        return Oc(D10), B10;
      }
      function zN(S10) {
        return S10;
      }
      function zv(S10) {
        var D10 = /\b_Z[\w\d_]+/g;
        return S10.replace(D10, function(B10) {
          var Q10 = B10;
          return B10 === Q10 ? B10 : Q10 + " [" + B10 + "]";
        });
      }
      function oh(S10) {
        l10()[S10 >> 2] = 0;
        var D10 = $e.pthreads[S10];
        delete $e.pthreads[S10], D10.worker.terminate(), $f(S10), $e.runningWorkers.splice($e.runningWorkers.indexOf(D10.worker), 1), D10.worker.pthread = void 0;
      }
      function uh(S10) {
        var D10 = $e.pthreads[S10];
        D10.worker.postMessage({ cmd: "cancel" });
      }
      function vc(S10) {
        var D10 = $e.pthreads[S10];
        if (D10) {
          l10()[S10 >> 2] = 0;
          var B10 = D10.worker;
          $e.returnWorkerToPool(B10);
        }
      }
      function xc(S10) {
        NT(S10);
      }
      function lh(S10) {
        if (S10 instanceof wu || S10 == "unwind")
          return Zt;
        v10(1, S10);
      }
      var $e = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], init: function() {
        T10 ? $e.initWorker() : $e.initMainThread();
      }, initMainThread: function() {
        for (var S10 = 8, D10 = 0; D10 < S10; ++D10)
          $e.allocateUnusedWorker();
      }, initWorker: function() {
        tt = false;
      }, pthreads: {}, setExitStatus: function(S10) {
        Zt = S10;
      }, terminateAllThreads: function() {
        for (var S10 in $e.pthreads) {
          var D10 = $e.pthreads[S10];
          D10 && D10.worker && $e.returnWorkerToPool(D10.worker);
        }
        for (var B10 = 0; B10 < $e.unusedWorkers.length; ++B10) {
          var Q10 = $e.unusedWorkers[B10];
          Q10.terminate();
        }
        $e.unusedWorkers = [];
      }, returnWorkerToPool: function(S10) {
        $e.runWithoutMainThreadQueuedCalls(function() {
          delete $e.pthreads[S10.pthread.threadInfoStruct], $e.unusedWorkers.push(S10), $e.runningWorkers.splice($e.runningWorkers.indexOf(S10), 1), $f(S10.pthread.threadInfoStruct), S10.pthread = void 0;
        });
      }, runWithoutMainThreadQueuedCalls: function(S10) {
        l10()[Yv >> 2] = 0;
        try {
          S10();
        } finally {
          l10()[Yv >> 2] = 1;
        }
      }, receiveObjectTransfer: function(S10) {
      }, threadInit: function() {
        for (var S10 in $e.tlsInitFunctions)
          $e.tlsInitFunctions[S10]();
      }, loadWasmModuleToWorker: function(S10, D10) {
        S10.onmessage = (B10) => {
          var Q10 = B10.data, ue2 = Q10.cmd;
          if (S10.pthread && ($e.currentProxiedOperationCallerThread = S10.pthread.threadInfoStruct), Q10.targetThread && Q10.targetThread != Fc()) {
            var pe2 = $e.pthreads[Q10.targetThread];
            pe2 ? pe2.worker.postMessage(Q10, Q10.transferList) : ee2('Internal error! Worker sent a message "' + ue2 + '" to target pthread ' + Q10.targetThread + ", but that thread no longer exists!"), $e.currentProxiedOperationCallerThread = void 0;
            return;
          }
          ue2 === "processQueuedMainThreadWork" ? Hv() : ue2 === "spawnThread" ? kc(Q10) : ue2 === "cleanupThread" ? vc(Q10.thread) : ue2 === "killThread" ? oh(Q10.thread) : ue2 === "cancelThread" ? uh(Q10.thread) : ue2 === "loaded" ? (S10.loaded = true, D10 && D10(S10), S10.runPthread && (S10.runPthread(), delete S10.runPthread)) : ue2 === "print" ? te2("Thread " + Q10.threadId + ": " + Q10.text) : ue2 === "printErr" ? ee2("Thread " + Q10.threadId + ": " + Q10.text) : ue2 === "alert" ? alert("Thread " + Q10.threadId + ": " + Q10.text) : Q10.target === "setimmediate" ? S10.postMessage(Q10) : ue2 === "onAbort" ? d10.onAbort && d10.onAbort(Q10.arg) : ee2("worker sent an unknown command " + ue2), $e.currentProxiedOperationCallerThread = void 0;
        }, S10.onerror = (B10) => {
          var Q10 = "worker sent an error!";
          throw ee2(Q10 + " " + B10.filename + ":" + B10.lineno + ": " + B10.message), B10;
        }, C10 && (S10.on("message", function(B10) {
          S10.onmessage({ data: B10 });
        }), S10.on("error", function(B10) {
          S10.onerror(B10);
        }), S10.on("detachedExit", function() {
        })), S10.postMessage({ cmd: "load", urlOrBlob: d10.mainScriptUrlOrBlob || s10, wasmMemory: Ce2, wasmModule: ut });
      }, allocateUnusedWorker: function() {
        var S10 = A10("tfjs-backend-wasm-threaded-simd.worker.js");
        $e.unusedWorkers.push(new Worker(S10));
      }, getNewWorker: function() {
        return $e.unusedWorkers.length == 0 && ($e.allocateUnusedWorker(), $e.loadWasmModuleToWorker($e.unusedWorkers[0])), $e.unusedWorkers.pop();
      } };
      function ch() {
        var S10 = Fc(), D10 = l10()[S10 + 44 >> 2], B10 = l10()[S10 + 48 >> 2], Q10 = D10 - B10;
        Xv(D10, Q10), Oc(D10);
      }
      d10.establishStackSpace = ch;
      function wc(S10) {
        if (T10)
          return Mr(1, 0, S10);
        try {
          xc(S10);
        } catch (D10) {
          lh(D10);
        }
      }
      var Pr = [];
      function Ni(S10) {
        var D10 = Pr[S10];
        return D10 || (S10 >= Pr.length && (Pr.length = S10 + 1), Pr[S10] = D10 = Dn.get(S10)), D10;
      }
      function dh(S10, D10) {
        return Ni(S10)(D10);
      }
      d10.invokeEntryPoint = dh;
      function Mv() {
        var S10 = new Error();
        if (!S10.stack) {
          try {
            throw new Error();
          } catch (D10) {
            S10 = D10;
          }
          if (!S10.stack)
            return "(no stack trace available)";
        }
        return S10.stack.toString();
      }
      function ph(S10, D10, B10) {
        $e.tlsInitFunctions.push(S10);
      }
      function Lv(S10, D10) {
        Dn.set(S10, D10), Pr[S10] = D10;
      }
      var zr;
      C10 ? zr = () => {
        var S10 = process.hrtime();
        return S10[0] * 1e3 + S10[1] / 1e6;
      } : T10 ? zr = () => performance.now() - d10.__performance_now_clock_drift : zr = () => performance.now();
      var hh = true;
      function fh(S10) {
        return l10()[Gv() >> 2] = S10, S10;
      }
      function mh(S10, D10) {
        var B10;
        if (S10 === 0)
          B10 = Date.now();
        else if ((S10 === 1 || S10 === 4) && hh)
          B10 = zr();
        else
          return fh(28), -1;
        return l10()[D10 >> 2] = B10 / 1e3 | 0, l10()[D10 + 4 >> 2] = B10 % 1e3 * 1e3 * 1e3 | 0, 0;
      }
      function gh(S10, D10) {
        return mh(S10, D10);
      }
      function bh(S10) {
        qv(S10, !k10, 1, !x10), $e.threadInit();
      }
      function yh(S10) {
        T10 ? postMessage({ cmd: "cleanupThread", thread: S10 }) : vc(S10);
      }
      function kc(S10) {
        var D10 = $e.getNewWorker();
        if (!D10)
          return 6;
        $e.runningWorkers.push(D10);
        var B10 = $e.pthreads[S10.pthread_ptr] = { worker: D10, threadInfoStruct: S10.pthread_ptr };
        D10.pthread = B10;
        var Q10 = { cmd: "run", start_routine: S10.startRoutine, arg: S10.arg, threadInfoStruct: S10.pthread_ptr };
        return D10.runPthread = () => {
          Q10.time = performance.now(), D10.postMessage(Q10, S10.transferList);
        }, D10.loaded && (D10.runPthread(), delete D10.runPthread), 0;
      }
      function vh(S10, D10, B10, Q10) {
        if (typeof SharedArrayBuffer == "undefined")
          return ee2("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
        var ue2 = [], pe2 = 0;
        if (T10 && (ue2.length === 0 || pe2))
          return jv(687865856, S10, D10, B10, Q10);
        if (pe2)
          return pe2;
        var be = { startRoutine: B10, pthread_ptr: S10, arg: Q10, transferList: ue2 };
        return T10 ? (be.cmd = "spawnThread", postMessage(be, ue2), 0) : kc(be);
      }
      function xh() {
        return 2097152;
      }
      function wh(S10, D10) {
        if (S10 == D10)
          postMessage({ cmd: "processQueuedMainThreadWork" });
        else if (T10)
          postMessage({ targetThread: S10, cmd: "processThreadQueue" });
        else {
          var B10 = $e.pthreads[S10], Q10 = B10 && B10.worker;
          if (!Q10)
            return;
          Q10.postMessage({ cmd: "processThreadQueue" });
        }
        return 1;
      }
      function kh() {
        Ii("");
      }
      function Ih() {
        C10 || k10 || ne2("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
      }
      function Ic() {
        return 2147483648;
      }
      function Sh(S10, D10, B10) {
        i10().copyWithin(S10, D10, D10 + B10);
      }
      function Ch() {
        return C10 ? XT().cpus().length : navigator.hardwareConcurrency;
      }
      function Mr(S10, D10) {
        var B10 = arguments.length - 2, Q10 = arguments;
        return Ci(function() {
          for (var ue2 = B10, pe2 = Ri(ue2 * 8), be = pe2 >> 3, Te2 = 0; Te2 < B10; Te2++) {
            var bt = Q10[2 + Te2];
            p10()[be + Te2] = bt;
          }
          return Kv(S10, ue2, pe2, D10);
        });
      }
      var gu = [];
      function Nh(S10, D10, B10) {
        gu.length = D10;
        for (var Q10 = B10 >> 3, ue2 = 0; ue2 < D10; ue2++)
          gu[ue2] = p10()[Q10 + ue2];
        var pe2 = S10 < 0, be = pe2 ? ih[-S10 - 1] : Hh[S10];
        return be.apply(null, gu);
      }
      function Th(S10) {
        try {
          return Ce2.grow(S10 - tn.byteLength + 65535 >>> 16), ns(Ce2.buffer), 1;
        } catch (D10) {
        }
      }
      function $h(S10) {
        var D10 = i10().length;
        if (S10 = S10 >>> 0, S10 <= D10)
          return false;
        var B10 = Ic();
        if (S10 > B10)
          return false;
        for (var Q10 = 1; Q10 <= 4; Q10 *= 2) {
          var ue2 = D10 * (1 + 0.2 / Q10);
          ue2 = Math.min(ue2, S10 + 100663296);
          var pe2 = Math.min(B10, wi(Math.max(S10, ue2), 65536)), be = Th(pe2);
          if (be)
            return true;
        }
        return false;
      }
      var Le2 = { inEventHandler: 0, removeAllEventListeners: function() {
        for (var S10 = Le2.eventHandlers.length - 1; S10 >= 0; --S10)
          Le2._removeHandler(S10);
        Le2.eventHandlers = [], Le2.deferredCalls = [];
      }, registerRemoveEventListeners: function() {
        Le2.removeEventListenersRegistered || (eh.push(Le2.removeAllEventListeners), Le2.removeEventListenersRegistered = true);
      }, deferredCalls: [], deferCall: function(S10, D10, B10) {
        function Q10(be, Te2) {
          if (be.length != Te2.length)
            return false;
          for (var bt in be)
            if (be[bt] != Te2[bt])
              return false;
          return true;
        }
        for (var ue2 in Le2.deferredCalls) {
          var pe2 = Le2.deferredCalls[ue2];
          if (pe2.targetFunction == S10 && Q10(pe2.argsList, B10))
            return;
        }
        Le2.deferredCalls.push({ targetFunction: S10, precedence: D10, argsList: B10 }), Le2.deferredCalls.sort(function(be, Te2) {
          return be.precedence < Te2.precedence;
        });
      }, removeDeferredCalls: function(S10) {
        for (var D10 = 0; D10 < Le2.deferredCalls.length; ++D10)
          Le2.deferredCalls[D10].targetFunction == S10 && (Le2.deferredCalls.splice(D10, 1), --D10);
      }, canPerformEventHandlerRequests: function() {
        return Le2.inEventHandler && Le2.currentEventHandler.allowsDeferredCalls;
      }, runDeferredCalls: function() {
        if (!!Le2.canPerformEventHandlerRequests())
          for (var S10 = 0; S10 < Le2.deferredCalls.length; ++S10) {
            var D10 = Le2.deferredCalls[S10];
            Le2.deferredCalls.splice(S10, 1), --S10, D10.targetFunction.apply(null, D10.argsList);
          }
      }, eventHandlers: [], removeAllHandlersOnTarget: function(S10, D10) {
        for (var B10 = 0; B10 < Le2.eventHandlers.length; ++B10)
          Le2.eventHandlers[B10].target == S10 && (!D10 || D10 == Le2.eventHandlers[B10].eventTypeString) && Le2._removeHandler(B10--);
      }, _removeHandler: function(S10) {
        var D10 = Le2.eventHandlers[S10];
        D10.target.removeEventListener(D10.eventTypeString, D10.eventListenerFunc, D10.useCapture), Le2.eventHandlers.splice(S10, 1);
      }, registerOrRemoveHandler: function(S10) {
        var D10 = function(ue2) {
          ++Le2.inEventHandler, Le2.currentEventHandler = S10, Le2.runDeferredCalls(), S10.handlerFunc(ue2), Le2.runDeferredCalls(), --Le2.inEventHandler;
        };
        if (S10.callbackfunc)
          S10.eventListenerFunc = D10, S10.target.addEventListener(S10.eventTypeString, D10, S10.useCapture), Le2.eventHandlers.push(S10), Le2.registerRemoveEventListeners();
        else
          for (var B10 = 0; B10 < Le2.eventHandlers.length; ++B10)
            Le2.eventHandlers[B10].target == S10.target && Le2.eventHandlers[B10].eventTypeString == S10.eventTypeString && Le2._removeHandler(B10--);
      }, queueEventHandlerOnThread_iiii: function(S10, D10, B10, Q10, ue2) {
        Ci(function() {
          var pe2 = Ri(12);
          l10()[pe2 >> 2] = B10, l10()[pe2 + 4 >> 2] = Q10, l10()[pe2 + 8 >> 2] = ue2, Tf(S10, 637534208, D10, Q10, pe2);
        });
      }, getTargetThreadForEventCallback: function(S10) {
        switch (S10) {
          case 1:
            return 0;
          case 2:
            return $e.currentProxiedOperationCallerThread;
          default:
            return S10;
        }
      }, getNodeNameForTarget: function(S10) {
        return S10 ? S10 == window ? "#window" : S10 == screen ? "#screen" : S10 && S10.nodeName ? S10.nodeName : "" : "";
      }, fullscreenEnabled: function() {
        return document.fullscreenEnabled || document.webkitFullscreenEnabled;
      } };
      function _h(S10) {
        var D10 = xi(S10) + 1, B10 = Nf(D10);
        return Ls(S10, B10, D10), B10;
      }
      function Ah(S10, D10, B10, Q10) {
        Ci(function() {
          var ue2 = Ri(12), pe2 = 0;
          D10 && (pe2 = _h(D10)), l10()[ue2 >> 2] = pe2, l10()[ue2 + 4 >> 2] = B10, l10()[ue2 + 8 >> 2] = Q10, Tf(S10, 657457152, 0, pe2, ue2);
        });
      }
      function Eh(S10, D10, B10, Q10) {
        D10 = D10 ? en(D10) : "", Ah(S10, D10, B10, Q10);
      }
      function Rh(S10) {
        return S10 > 2 ? en(S10) : S10;
      }
      var Dh = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];
      function Fh(S10) {
        S10 = Rh(S10);
        var D10 = Dh[S10] || (typeof document != "undefined" ? document.querySelector(S10) : void 0);
        return D10;
      }
      function bu(S10) {
        return Fh(S10);
      }
      function Sc(S10, D10, B10) {
        var Q10 = bu(S10);
        if (!Q10)
          return -4;
        if (Q10.canvasSharedPtr && (l10()[Q10.canvasSharedPtr >> 2] = D10, l10()[Q10.canvasSharedPtr + 4 >> 2] = B10), Q10.offscreenCanvas || !Q10.controlTransferredOffscreen) {
          Q10.offscreenCanvas && (Q10 = Q10.offscreenCanvas);
          var ue2 = false;
          if (Q10.GLctxObject && Q10.GLctxObject.GLctx) {
            var pe2 = Q10.GLctxObject.GLctx.getParameter(2978);
            ue2 = pe2[0] === 0 && pe2[1] === 0 && pe2[2] === Q10.width && pe2[3] === Q10.height;
          }
          Q10.width = D10, Q10.height = B10, ue2 && Q10.GLctxObject.GLctx.viewport(0, 0, D10, B10);
        } else if (Q10.canvasSharedPtr) {
          var be = l10()[Q10.canvasSharedPtr + 8 >> 2];
          return Eh(be, S10, D10, B10), 1;
        } else
          return -4;
        return 0;
      }
      function Cc(S10, D10, B10) {
        return T10 ? Mr(2, 1, S10, D10, B10) : Sc(S10, D10, B10);
      }
      function Oh(S10, D10, B10) {
        var Q10 = bu(S10);
        return Q10 ? Sc(S10, D10, B10) : Cc(S10, D10, B10);
      }
      function Ph() {
        throw "unwind";
      }
      function zh(S10) {
        var D10 = S10.getExtension("ANGLE_instanced_arrays");
        if (D10)
          return S10.vertexAttribDivisor = function(B10, Q10) {
            D10.vertexAttribDivisorANGLE(B10, Q10);
          }, S10.drawArraysInstanced = function(B10, Q10, ue2, pe2) {
            D10.drawArraysInstancedANGLE(B10, Q10, ue2, pe2);
          }, S10.drawElementsInstanced = function(B10, Q10, ue2, pe2, be) {
            D10.drawElementsInstancedANGLE(B10, Q10, ue2, pe2, be);
          }, 1;
      }
      function Mh(S10) {
        var D10 = S10.getExtension("OES_vertex_array_object");
        if (D10)
          return S10.createVertexArray = function() {
            return D10.createVertexArrayOES();
          }, S10.deleteVertexArray = function(B10) {
            D10.deleteVertexArrayOES(B10);
          }, S10.bindVertexArray = function(B10) {
            D10.bindVertexArrayOES(B10);
          }, S10.isVertexArray = function(B10) {
            return D10.isVertexArrayOES(B10);
          }, 1;
      }
      function Lh(S10) {
        var D10 = S10.getExtension("WEBGL_draw_buffers");
        if (D10)
          return S10.drawBuffers = function(B10, Q10) {
            D10.drawBuffersWEBGL(B10, Q10);
          }, 1;
      }
      function Bh(S10) {
        return !!(S10.multiDrawWebgl = S10.getExtension("WEBGL_multi_draw"));
      }
      var gt = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function(D10) {
        gt.lastError || (gt.lastError = D10);
      }, getNewId: function(S10) {
        for (var D10 = gt.counter++, B10 = S10.length; B10 < D10; B10++)
          S10[B10] = null;
        return D10;
      }, getSource: function(S10, D10, B10, Q10) {
        for (var ue2 = "", pe2 = 0; pe2 < D10; ++pe2) {
          var be = Q10 ? l10()[Q10 + pe2 * 4 >> 2] : -1;
          ue2 += en(l10()[B10 + pe2 * 4 >> 2], be < 0 ? void 0 : be);
        }
        return ue2;
      }, createContext: function(S10, D10) {
        S10.getContextSafariWebGL2Fixed || (S10.getContextSafariWebGL2Fixed = S10.getContext, S10.getContext = function(ue2, pe2) {
          var be = S10.getContextSafariWebGL2Fixed(ue2, pe2);
          return ue2 == "webgl" == be instanceof WebGLRenderingContext ? be : null;
        });
        var B10 = S10.getContext("webgl", D10);
        if (!B10)
          return 0;
        var Q10 = gt.registerContext(B10, D10);
        return Q10;
      }, registerContext: function(S10, D10) {
        var B10 = Nf(8);
        l10()[B10 + 4 >> 2] = Fc();
        var Q10 = { handle: B10, attributes: D10, version: D10.majorVersion, GLctx: S10 };
        return S10.canvas && (S10.canvas.GLctxObject = Q10), gt.contexts[B10] = Q10, (typeof D10.enableExtensionsByDefault == "undefined" || D10.enableExtensionsByDefault) && gt.initExtensions(Q10), B10;
      }, makeContextCurrent: function(S10) {
        return gt.currentContext = gt.contexts[S10], d10.ctx = _c = gt.currentContext && gt.currentContext.GLctx, !(S10 && !_c);
      }, getContext: function(S10) {
        return gt.contexts[S10];
      }, deleteContext: function(S10) {
        gt.currentContext === gt.contexts[S10] && (gt.currentContext = null), typeof Le2 == "object" && Le2.removeAllHandlersOnTarget(gt.contexts[S10].GLctx.canvas), gt.contexts[S10] && gt.contexts[S10].GLctx.canvas && (gt.contexts[S10].GLctx.canvas.GLctxObject = void 0), Uv(gt.contexts[S10].handle), gt.contexts[S10] = null;
      }, initExtensions: function(S10) {
        if (S10 || (S10 = gt.currentContext), !S10.initExtensionsDone) {
          S10.initExtensionsDone = true;
          var D10 = S10.GLctx;
          zh(D10), Mh(D10), Lh(D10), D10.disjointTimerQueryExt = D10.getExtension("EXT_disjoint_timer_query"), Bh(D10);
          var B10 = D10.getSupportedExtensions() || [];
          B10.forEach(function(Q10) {
            !Q10.includes("lose_context") && !Q10.includes("debug") && D10.getExtension(Q10);
          });
        }
      } }, Vh = ["default", "low-power", "high-performance"];
      function Wh(S10, D10) {
        var B10 = D10 >> 2, Q10 = l10()[B10 + 6], ue2 = { alpha: !!l10()[B10 + 0], depth: !!l10()[B10 + 1], stencil: !!l10()[B10 + 2], antialias: !!l10()[B10 + 3], premultipliedAlpha: !!l10()[B10 + 4], preserveDrawingBuffer: !!l10()[B10 + 5], powerPreference: Vh[Q10], failIfMajorPerformanceCaveat: !!l10()[B10 + 7], majorVersion: l10()[B10 + 8], minorVersion: l10()[B10 + 9], enableExtensionsByDefault: l10()[B10 + 10], explicitSwapControl: l10()[B10 + 11], proxyContextToMainThread: l10()[B10 + 12], renderViaOffscreenBackBuffer: l10()[B10 + 13] }, pe2 = bu(S10);
        if (!pe2 || ue2.explicitSwapControl)
          return 0;
        var be = gt.createContext(pe2, ue2);
        return be;
      }
      function Uh(S10, D10) {
        return Wh(S10, D10);
      }
      var Ti = { mappings: {}, buffers: [null, [], []], printChar: function(S10, D10) {
        var B10 = Ti.buffers[S10];
        D10 === 0 || D10 === 10 ? ((S10 === 1 ? te2 : ee2)(Rn(B10, 0)), B10.length = 0) : B10.push(D10);
      }, varargs: void 0, get: function() {
        Ti.varargs += 4;
        var S10 = l10()[Ti.varargs - 4 >> 2];
        return S10;
      }, getStr: function(S10) {
        var D10 = en(S10);
        return D10;
      }, get64: function(S10, D10) {
        return S10;
      } };
      function Nc(S10) {
        return T10 ? Mr(3, 1, S10) : 0;
      }
      function Tc(S10, D10, B10, Q10, ue2) {
        if (T10)
          return Mr(4, 1, S10, D10, B10, Q10, ue2);
      }
      function $c(S10, D10, B10, Q10) {
        if (T10)
          return Mr(5, 1, S10, D10, B10, Q10);
        for (var ue2 = 0, pe2 = 0; pe2 < B10; pe2++) {
          var be = l10()[D10 >> 2], Te2 = l10()[D10 + 4 >> 2];
          D10 += 8;
          for (var bt = 0; bt < Te2; bt++)
            Ti.printChar(S10, i10()[be + bt]);
          ue2 += Te2;
        }
        return l10()[Q10 >> 2] = ue2, 0;
      }
      function Gh(S10) {
        Ee2(S10);
      }
      $e.init();
      var _c, Hh = [null, wc, Cc, Nc, Tc, $c], Bv = false, Ac = { __clock_gettime: gh, __emscripten_init_main_thread_js: bh, __emscripten_thread_cleanup: yh, __pthread_create_js: vh, _emscripten_default_pthread_stack_size: xh, _emscripten_notify_thread_queue: wh, abort: kh, emscripten_check_blocking_allowed: Ih, emscripten_get_heap_max: Ic, emscripten_get_now: zr, emscripten_memcpy_big: Sh, emscripten_num_logical_cores: Ch, emscripten_receive_on_main_thread_js: Nh, emscripten_resize_heap: $h, emscripten_set_canvas_element_size: Oh, emscripten_unwind_to_js_event_loop: Ph, emscripten_webgl_create_context: Uh, exit: xc, fd_close: Nc, fd_seek: Tc, fd_write: $c, memory: Ce2 || d10.wasmMemory, setTempRet0: Gh }, Vv = ah(), qh = d10.___wasm_call_ctors = function() {
        return (qh = d10.___wasm_call_ctors = d10.asm.__wasm_call_ctors).apply(null, arguments);
      }, jh = d10._init = function() {
        return (jh = d10._init = d10.asm.init).apply(null, arguments);
      }, Kh = d10._init_with_threads_count = function() {
        return (Kh = d10._init_with_threads_count = d10.asm.init_with_threads_count).apply(null, arguments);
      }, Xh = d10._get_threads_count = function() {
        return (Xh = d10._get_threads_count = d10.asm.get_threads_count).apply(null, arguments);
      }, Yh = d10._register_tensor = function() {
        return (Yh = d10._register_tensor = d10.asm.register_tensor).apply(null, arguments);
      }, Qh = d10._dispose_data = function() {
        return (Qh = d10._dispose_data = d10.asm.dispose_data).apply(null, arguments);
      }, Zh = d10._dispose = function() {
        return (Zh = d10._dispose = d10.asm.dispose).apply(null, arguments);
      }, Jh = d10._Abs = function() {
        return (Jh = d10._Abs = d10.asm.Abs).apply(null, arguments);
      }, ef = d10._Add = function() {
        return (ef = d10._Add = d10.asm.Add).apply(null, arguments);
      }, tf = d10._AddN = function() {
        return (tf = d10._AddN = d10.asm.AddN).apply(null, arguments);
      }, nf = d10._All = function() {
        return (nf = d10._All = d10.asm.All).apply(null, arguments);
      }, sf = d10._Any = function() {
        return (sf = d10._Any = d10.asm.Any).apply(null, arguments);
      }, rf = d10._ArgMax = function() {
        return (rf = d10._ArgMax = d10.asm.ArgMax).apply(null, arguments);
      }, af = d10._AvgPool = function() {
        return (af = d10._AvgPool = d10.asm.AvgPool).apply(null, arguments);
      }, of = d10._BatchMatMul = function() {
        return (of = d10._BatchMatMul = d10.asm.BatchMatMul).apply(null, arguments);
      }, uf = d10._Ceil = function() {
        return (uf = d10._Ceil = d10.asm.Ceil).apply(null, arguments);
      }, lf = d10._ClipByValue = function() {
        return (lf = d10._ClipByValue = d10.asm.ClipByValue).apply(null, arguments);
      }, cf = d10._Conv2D = function() {
        return (cf = d10._Conv2D = d10.asm.Conv2D).apply(null, arguments);
      }, df = d10._Conv2DBackpropInput = function() {
        return (df = d10._Conv2DBackpropInput = d10.asm.Conv2DBackpropInput).apply(null, arguments);
      }, pf = d10._Cos = function() {
        return (pf = d10._Cos = d10.asm.Cos).apply(null, arguments);
      }, hf = d10._Cosh = function() {
        return (hf = d10._Cosh = d10.asm.Cosh).apply(null, arguments);
      }, ff = d10._CropAndResize = function() {
        return (ff = d10._CropAndResize = d10.asm.CropAndResize).apply(null, arguments);
      }, mf = d10._Cumsum = function() {
        return (mf = d10._Cumsum = d10.asm.Cumsum).apply(null, arguments);
      }, gf = d10._DepthToSpace = function() {
        return (gf = d10._DepthToSpace = d10.asm.DepthToSpace).apply(null, arguments);
      }, bf = d10._DepthwiseConv2dNative = function() {
        return (bf = d10._DepthwiseConv2dNative = d10.asm.DepthwiseConv2dNative).apply(null, arguments);
      }, yf = d10._Elu = function() {
        return (yf = d10._Elu = d10.asm.Elu).apply(null, arguments);
      }, vf = d10._Equal = function() {
        return (vf = d10._Equal = d10.asm.Equal).apply(null, arguments);
      }, xf = d10._Exp = function() {
        return (xf = d10._Exp = d10.asm.Exp).apply(null, arguments);
      }, wf = d10._FlipLeftRight = function() {
        return (wf = d10._FlipLeftRight = d10.asm.FlipLeftRight).apply(null, arguments);
      }, Ec = d10._Floor = function() {
        return (Ec = d10._Floor = d10.asm.Floor).apply(null, arguments);
      }, Rc = d10._FloorDiv = function() {
        return (Rc = d10._FloorDiv = d10.asm.FloorDiv).apply(null, arguments);
      }, yu = d10._FusedBatchNorm = function() {
        return (yu = d10._FusedBatchNorm = d10.asm.FusedBatchNorm).apply(null, arguments);
      }, kf = d10._FusedConv2D = function() {
        return (kf = d10._FusedConv2D = d10.asm.FusedConv2D).apply(null, arguments);
      }, If = d10._FusedDepthwiseConv2D = function() {
        return (If = d10._FusedDepthwiseConv2D = d10.asm.FusedDepthwiseConv2D).apply(null, arguments);
      }, $i = d10._Gather = function() {
        return ($i = d10._Gather = d10.asm.Gather).apply(null, arguments);
      }, vu = d10._GatherNd = function() {
        return (vu = d10._GatherNd = d10.asm.GatherNd).apply(null, arguments);
      }, xu = d10._Greater = function() {
        return (xu = d10._Greater = d10.asm.Greater).apply(null, arguments);
      }, Wv = d10._GreaterEqual = function() {
        return (Wv = d10._GreaterEqual = d10.asm.GreaterEqual).apply(null, arguments);
      }, _i = d10._LeakyRelu = function() {
        return (_i = d10._LeakyRelu = d10.asm.LeakyRelu).apply(null, arguments);
      }, Ai = d10._Less = function() {
        return (Ai = d10._Less = d10.asm.Less).apply(null, arguments);
      }, Sf = d10._LessEqual = function() {
        return (Sf = d10._LessEqual = d10.asm.LessEqual).apply(null, arguments);
      }, H10 = d10._Log = function() {
        return (H10 = d10._Log = d10.asm.Log).apply(null, arguments);
      }, J10 = d10._LogicalAnd = function() {
        return (J10 = d10._LogicalAnd = d10.asm.LogicalAnd).apply(null, arguments);
      }, de2 = d10._Max = function() {
        return (de2 = d10._Max = d10.asm.Max).apply(null, arguments);
      }, ke = d10._MaxPool = function() {
        return (ke = d10._MaxPool = d10.asm.MaxPool).apply(null, arguments);
      }, Qe = d10._Maximum = function() {
        return (Qe = d10._Maximum = d10.asm.Maximum).apply(null, arguments);
      }, Ze = d10._Mean = function() {
        return (Ze = d10._Mean = d10.asm.Mean).apply(null, arguments);
      }, Ve = d10._Min = function() {
        return (Ve = d10._Min = d10.asm.Min).apply(null, arguments);
      }, ze = d10._Minimum = function() {
        return (ze = d10._Minimum = d10.asm.Minimum).apply(null, arguments);
      }, Tt = d10._MirrorPad = function() {
        return (Tt = d10._MirrorPad = d10.asm.MirrorPad).apply(null, arguments);
      }, rs = d10._Multiply = function() {
        return (rs = d10._Multiply = d10.asm.Multiply).apply(null, arguments);
      }, as = d10._Neg = function() {
        return (as = d10._Neg = d10.asm.Neg).apply(null, arguments);
      }, Ei = d10._NonMaxSuppressionV3 = function() {
        return (Ei = d10._NonMaxSuppressionV3 = d10.asm.NonMaxSuppressionV3).apply(null, arguments);
      }, Lr = d10._NonMaxSuppressionV4 = function() {
        return (Lr = d10._NonMaxSuppressionV4 = d10.asm.NonMaxSuppressionV4).apply(null, arguments);
      }, Cf = d10._NonMaxSuppressionV5 = function() {
        return (Cf = d10._NonMaxSuppressionV5 = d10.asm.NonMaxSuppressionV5).apply(null, arguments);
      }, rn = d10._NotEqual = function() {
        return (rn = d10._NotEqual = d10.asm.NotEqual).apply(null, arguments);
      }, nr = d10._OneHot = function() {
        return (nr = d10._OneHot = d10.asm.OneHot).apply(null, arguments);
      }, Dc = d10._PadV2 = function() {
        return (Dc = d10._PadV2 = d10.asm.PadV2).apply(null, arguments);
      }, MN = d10._Pow = function() {
        return (MN = d10._Pow = d10.asm.Pow).apply(null, arguments);
      }, LN = d10._Prelu = function() {
        return (LN = d10._Prelu = d10.asm.Prelu).apply(null, arguments);
      }, BN = d10._Prod = function() {
        return (BN = d10._Prod = d10.asm.Prod).apply(null, arguments);
      }, VN = d10._RealDiv = function() {
        return (VN = d10._RealDiv = d10.asm.RealDiv).apply(null, arguments);
      }, WN = d10._Relu = function() {
        return (WN = d10._Relu = d10.asm.Relu).apply(null, arguments);
      }, UN = d10._Relu6 = function() {
        return (UN = d10._Relu6 = d10.asm.Relu6).apply(null, arguments);
      }, GN = d10._ResizeBilinear = function() {
        return (GN = d10._ResizeBilinear = d10.asm.ResizeBilinear).apply(null, arguments);
      }, HN = d10._Reverse = function() {
        return (HN = d10._Reverse = d10.asm.Reverse).apply(null, arguments);
      }, qN = d10._RotateWithOffset = function() {
        return (qN = d10._RotateWithOffset = d10.asm.RotateWithOffset).apply(null, arguments);
      }, jN = d10._Round = function() {
        return (jN = d10._Round = d10.asm.Round).apply(null, arguments);
      }, KN = d10._Rsqrt = function() {
        return (KN = d10._Rsqrt = d10.asm.Rsqrt).apply(null, arguments);
      }, XN = d10._ScatterNd = function() {
        return (XN = d10._ScatterNd = d10.asm.ScatterNd).apply(null, arguments);
      }, YN = d10._SelectV2 = function() {
        return (YN = d10._SelectV2 = d10.asm.SelectV2).apply(null, arguments);
      }, QN = d10._Sigmoid = function() {
        return (QN = d10._Sigmoid = d10.asm.Sigmoid).apply(null, arguments);
      }, ZN = d10._Sin = function() {
        return (ZN = d10._Sin = d10.asm.Sin).apply(null, arguments);
      }, JN = d10._Softmax = function() {
        return (JN = d10._Softmax = d10.asm.Softmax).apply(null, arguments);
      }, eT = d10._SparseFillEmptyRows = function() {
        return (eT = d10._SparseFillEmptyRows = d10.asm.SparseFillEmptyRows).apply(null, arguments);
      }, tT = d10._SparseReshape = function() {
        return (tT = d10._SparseReshape = d10.asm.SparseReshape).apply(null, arguments);
      }, nT = d10._SparseSegmentReduction = function() {
        return (nT = d10._SparseSegmentReduction = d10.asm.SparseSegmentReduction).apply(null, arguments);
      }, sT = d10._Sqrt = function() {
        return (sT = d10._Sqrt = d10.asm.Sqrt).apply(null, arguments);
      }, rT = d10._Square = function() {
        return (rT = d10._Square = d10.asm.Square).apply(null, arguments);
      }, aT = d10._SquaredDifference = function() {
        return (aT = d10._SquaredDifference = d10.asm.SquaredDifference).apply(null, arguments);
      }, iT = d10._Step = function() {
        return (iT = d10._Step = d10.asm.Step).apply(null, arguments);
      }, oT = d10._StridedSlice = function() {
        return (oT = d10._StridedSlice = d10.asm.StridedSlice).apply(null, arguments);
      }, uT = d10._Sub = function() {
        return (uT = d10._Sub = d10.asm.Sub).apply(null, arguments);
      }, lT = d10._Sum = function() {
        return (lT = d10._Sum = d10.asm.Sum).apply(null, arguments);
      }, cT = d10._Tan = function() {
        return (cT = d10._Tan = d10.asm.Tan).apply(null, arguments);
      }, dT = d10._Tanh = function() {
        return (dT = d10._Tanh = d10.asm.Tanh).apply(null, arguments);
      }, pT = d10._Tile = function() {
        return (pT = d10._Tile = d10.asm.Tile).apply(null, arguments);
      }, hT = d10._TopK = function() {
        return (hT = d10._TopK = d10.asm.TopK).apply(null, arguments);
      }, fT = d10._Transform = function() {
        return (fT = d10._Transform = d10.asm.Transform).apply(null, arguments);
      }, mT = d10._Transpose = function() {
        return (mT = d10._Transpose = d10.asm.Transpose).apply(null, arguments);
      }, gT = d10.__FusedMatMul = function() {
        return (gT = d10.__FusedMatMul = d10.asm._FusedMatMul).apply(null, arguments);
      }, Nf = d10._malloc = function() {
        return (Nf = d10._malloc = d10.asm.malloc).apply(null, arguments);
      }, Uv = d10._free = function() {
        return (Uv = d10._free = d10.asm.free).apply(null, arguments);
      }, bT = d10._emscripten_tls_init = function() {
        return (bT = d10._emscripten_tls_init = d10.asm.emscripten_tls_init).apply(null, arguments);
      }, Gv = d10.___errno_location = function() {
        return (Gv = d10.___errno_location = d10.asm.__errno_location).apply(null, arguments);
      }, Fc = d10._pthread_self = function() {
        return (Fc = d10._pthread_self = d10.asm.pthread_self).apply(null, arguments);
      }, Hv = d10._emscripten_main_thread_process_queued_calls = function() {
        return (Hv = d10._emscripten_main_thread_process_queued_calls = d10.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
      }, yT = d10.__emscripten_thread_crashed = function() {
        return (yT = d10.__emscripten_thread_crashed = d10.asm._emscripten_thread_crashed).apply(null, arguments);
      }, qv = d10.__emscripten_thread_init = function() {
        return (qv = d10.__emscripten_thread_init = d10.asm._emscripten_thread_init).apply(null, arguments);
      }, vT = d10._emscripten_current_thread_process_queued_calls = function() {
        return (vT = d10._emscripten_current_thread_process_queued_calls = d10.asm.emscripten_current_thread_process_queued_calls).apply(null, arguments);
      }, xT = d10._emscripten_main_browser_thread_id = function() {
        return (xT = d10._emscripten_main_browser_thread_id = d10.asm.emscripten_main_browser_thread_id).apply(null, arguments);
      }, wT = d10._emscripten_sync_run_in_main_thread_2 = function() {
        return (wT = d10._emscripten_sync_run_in_main_thread_2 = d10.asm.emscripten_sync_run_in_main_thread_2).apply(null, arguments);
      }, jv = d10._emscripten_sync_run_in_main_thread_4 = function() {
        return (jv = d10._emscripten_sync_run_in_main_thread_4 = d10.asm.emscripten_sync_run_in_main_thread_4).apply(null, arguments);
      }, Kv = d10._emscripten_run_in_main_runtime_thread_js = function() {
        return (Kv = d10._emscripten_run_in_main_runtime_thread_js = d10.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
      }, Tf = d10._emscripten_dispatch_to_thread_ = function() {
        return (Tf = d10._emscripten_dispatch_to_thread_ = d10.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
      }, $f = d10.__emscripten_thread_free_data = function() {
        return ($f = d10.__emscripten_thread_free_data = d10.asm._emscripten_thread_free_data).apply(null, arguments);
      }, kT = d10.__emscripten_thread_exit = function() {
        return (kT = d10.__emscripten_thread_exit = d10.asm._emscripten_thread_exit).apply(null, arguments);
      }, IT = d10._memalign = function() {
        return (IT = d10._memalign = d10.asm.memalign).apply(null, arguments);
      }, Xv = d10._emscripten_stack_set_limits = function() {
        return (Xv = d10._emscripten_stack_set_limits = d10.asm.emscripten_stack_set_limits).apply(null, arguments);
      }, _f = d10.stackSave = function() {
        return (_f = d10.stackSave = d10.asm.stackSave).apply(null, arguments);
      }, Oc = d10.stackRestore = function() {
        return (Oc = d10.stackRestore = d10.asm.stackRestore).apply(null, arguments);
      }, Ri = d10.stackAlloc = function() {
        return (Ri = d10.stackAlloc = d10.asm.stackAlloc).apply(null, arguments);
      }, ST = d10.dynCall_iijjiiii = function() {
        return (ST = d10.dynCall_iijjiiii = d10.asm.dynCall_iijjiiii).apply(null, arguments);
      }, CT = d10.dynCall_jiji = function() {
        return (CT = d10.dynCall_jiji = d10.asm.dynCall_jiji).apply(null, arguments);
      }, Yv = d10.__emscripten_allow_main_runtime_queued_calls = 21408;
      d10.cwrap = Jt, d10.keepRuntimeAlive = Or, d10.PThread = $e, d10.PThread = $e, d10.wasmMemory = Ce2, d10.ExitStatus = wu;
      var Pc;
      function wu(S10) {
        this.name = "ExitStatus", this.message = "Program terminated with exit(" + S10 + ")", this.status = S10;
      }
      ss = function S10() {
        Pc || Af(), Pc || (ss = S10);
      };
      function Af(S10) {
        if (S10 = S10 || b10, tr > 0)
          return;
        if (T10) {
          h10(d10), hu(), postMessage({ cmd: "loaded" });
          return;
        }
        if (nn(), tr > 0)
          return;
        function D10() {
          Pc || (Pc = true, d10.calledRun = true, !rt && (hu(), h10(d10), d10.onRuntimeInitialized && d10.onRuntimeInitialized(), sh()));
        }
        d10.setStatus ? (d10.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            d10.setStatus("");
          }, 1), D10();
        }, 1)) : D10();
      }
      d10.run = Af;
      function NT(S10, D10) {
        if (Zt = S10, !D10 && T10)
          throw wc(S10), "unwind";
        Or() || nh(), TT(S10);
      }
      function TT(S10) {
        Zt = S10, Or() || ($e.terminateAllThreads(), d10.onExit && d10.onExit(S10), rt = true), v10(S10, new wu(S10));
      }
      if (d10.preInit)
        for (typeof d10.preInit == "function" && (d10.preInit = [d10.preInit]); d10.preInit.length > 0; )
          d10.preInit.pop()();
      Af();
      var zc;
      m10 && (zc = { uncaughtException: process.listeners("uncaughtException").filter(function(S10) {
        return !m10.uncaughtException.indexOf(S10) > -1;
      }), unhandledRejection: process.listeners("unhandledRejection").filter(function(S10) {
        return !m10.unhandledRejection.indexOf(S10) > -1;
      }) });
      var Mc;
      if (typeof WasmBackendModule != "undefined")
        Mc = WasmBackendModule;
      else if (typeof r10 != "undefined")
        Mc = r10;
      else
        throw new Error("Could not find wasm module in post.js");
      if (zc) {
        var $T = Mc._dispose;
        Mc._dispose = function() {
          $T(), zc.uncaughtException.forEach(function(S10) {
            process.removeListener("uncaughtException", S10);
          }), zc.unhandledRejection.forEach(function(S10) {
            process.removeListener("unhandledRejection", S10);
          });
        };
      }
      return r10.ready;
    };
  })();
  typeof e == "object" && typeof t == "object" ? t.exports = n10 : typeof define == "function" && define.amd ? define([], function() {
    return n10;
  }) : typeof e == "object" && (e.WasmBackendModuleThreadedSimd = n10);
} });
var QT = zt({ "src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e, t) {
  var n10 = (() => {
    var s10 = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename != "undefined" && (s10 = s10 || __filename), function(r10) {
      r10 = r10 || {};
      var a10 = typeof r10 != "undefined" ? r10 : {}, i10, o10;
      a10.ready = new Promise(function(H10, J10) {
        i10 = H10, o10 = J10;
      });
      var u10;
      typeof process != "undefined" && process.listeners && (u10 = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
      var l10 = Object.assign({}, a10), c10 = [], p10 = "./this.program", d10 = (H10, J10) => {
        throw J10;
      }, h10 = typeof window == "object", f10 = typeof importScripts == "function", m10 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g10 = "";
      function b10(H10) {
        return a10.locateFile ? a10.locateFile(H10, g10) : g10 + H10;
      }
      var y10, v10, x10, k10;
      function C10(H10) {
        if (H10 instanceof vu)
          return;
        R10("exiting due to exception: " + H10);
      }
      var T10, E10, A10;
      m10 ? (f10 ? g10 = cd().dirname(g10) + "/" : g10 = __dirname + "/", A10 = () => {
        E10 || (T10 = Jm(), E10 = cd());
      }, y10 = function(J10, de2) {
        return A10(), J10 = E10.normalize(J10), T10.readFileSync(J10, de2 ? void 0 : "utf8");
      }, x10 = (H10) => {
        var J10 = y10(H10, true);
        return J10.buffer || (J10 = new Uint8Array(J10)), J10;
      }, v10 = (H10, J10, de2) => {
        A10(), H10 = E10.normalize(H10), T10.readFile(H10, function(ke, Qe) {
          ke ? de2(ke) : J10(Qe.buffer);
        });
      }, process.argv.length > 1 && (p10 = process.argv[1].replace(/\\/g, "/")), c10 = process.argv.slice(2), process.on("uncaughtException", function(H10) {
        if (!(H10 instanceof vu))
          throw H10;
      }), process.on("unhandledRejection", function(H10) {
        throw H10;
      }), d10 = (H10, J10) => {
        if (pu())
          throw process.exitCode = H10, J10;
        C10(J10), process.exit(H10);
      }, a10.inspect = function() {
        return "[Emscripten Module object]";
      }) : (h10 || f10) && (f10 ? g10 = self.location.href : typeof document != "undefined" && document.currentScript && (g10 = document.currentScript.src), s10 && (g10 = s10), g10.indexOf("blob:") !== 0 ? g10 = g10.substr(0, g10.replace(/[?#].*/, "").lastIndexOf("/") + 1) : g10 = "", y10 = (H10) => {
        var J10 = new XMLHttpRequest();
        return J10.open("GET", H10, false), J10.send(null), J10.responseText;
      }, f10 && (x10 = (H10) => {
        var J10 = new XMLHttpRequest();
        return J10.open("GET", H10, false), J10.responseType = "arraybuffer", J10.send(null), new Uint8Array(J10.response);
      }), v10 = (H10, J10, de2) => {
        var ke = new XMLHttpRequest();
        ke.open("GET", H10, true), ke.responseType = "arraybuffer", ke.onload = () => {
          if (ke.status == 200 || ke.status == 0 && ke.response) {
            J10(ke.response);
            return;
          }
          de2();
        }, ke.onerror = de2, ke.send(null);
      }, k10 = (H10) => document.title = H10);
      var P10 = a10.print || console.log.bind(console), R10 = a10.printErr || console.warn.bind(console);
      Object.assign(a10, l10), l10 = null, a10.arguments && (c10 = a10.arguments), a10.thisProgram && (p10 = a10.thisProgram), a10.quit && (d10 = a10.quit);
      var F10 = 4;
      function $10(H10) {
        $10.shown || ($10.shown = {}), $10.shown[H10] || ($10.shown[H10] = 1, R10(H10));
      }
      function z10(H10, J10) {
        if (typeof WebAssembly.Function == "function") {
          for (var de2 = { i: "i32", j: "i64", f: "f32", d: "f64" }, ke = { parameters: [], results: J10[0] == "v" ? [] : [de2[J10[0]]] }, Qe = 1; Qe < J10.length; ++Qe)
            ke.parameters.push(de2[J10[Qe]]);
          return new WebAssembly.Function(ke, H10);
        }
        var Ze = [1, 0, 1, 96], Ve = J10.slice(0, 1), ze = J10.slice(1), Tt = { i: 127, j: 126, f: 125, d: 124 };
        Ze.push(ze.length);
        for (var Qe = 0; Qe < ze.length; ++Qe)
          Ze.push(Tt[ze[Qe]]);
        Ve == "v" ? Ze.push(0) : Ze = Ze.concat([1, Tt[Ve]]), Ze[1] = Ze.length - 2;
        var rs = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(Ze, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])), as = new WebAssembly.Module(rs), Ei = new WebAssembly.Instance(as, { e: { f: H10 } }), Lr = Ei.exports.f;
        return Lr;
      }
      var W10 = [], q10;
      function K10() {
        if (W10.length)
          return W10.pop();
        try {
          Js.grow(1);
        } catch (H10) {
          throw H10 instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : H10;
        }
        return Js.length - 1;
      }
      function Y10(H10, J10) {
        for (var de2 = H10; de2 < H10 + J10; de2++) {
          var ke = mu(de2);
          ke && q10.set(ke, de2);
        }
      }
      var Z10 = 0, te2 = (H10) => {
        Z10 = H10;
      }, ee2;
      a10.wasmBinary && (ee2 = a10.wasmBinary);
      var se2 = a10.noExitRuntime || true;
      typeof WebAssembly != "object" && Fr("no native wasm support detected");
      var ne2, oe2 = false, re2;
      function le2(H10, J10) {
        H10 || Fr(J10);
      }
      function me2(H10) {
        var J10 = a10["_" + H10];
        return J10;
      }
      function we2(H10, J10, de2, ke, Qe) {
        var Ze = { string: function(rn) {
          var nr = 0;
          if (rn != null && rn !== 0) {
            var Dc = (rn.length << 2) + 1;
            nr = yu(Dc), tt(rn, nr, Dc);
          }
          return nr;
        }, array: function(rn) {
          var nr = yu(rn.length);
          return rt(rn, nr), nr;
        } };
        function Ve(rn) {
          return J10 === "string" ? Je(rn) : J10 === "boolean" ? Boolean(rn) : rn;
        }
        var ze = me2(H10), Tt = [], rs = 0;
        if (ke)
          for (var as = 0; as < ke.length; as++) {
            var Ei = Ze[de2[as]];
            Ei ? (rs === 0 && (rs = Ec()), Tt[as] = Ei(ke[as])) : Tt[as] = ke[as];
          }
        var Lr = ze.apply(null, Tt);
        function Cf(rn) {
          return rs !== 0 && Rc(rs), Ve(rn);
        }
        return Lr = Cf(Lr), Lr;
      }
      function Se2(H10, J10, de2, ke) {
        de2 = de2 || [];
        var Qe = de2.every(function(Ve) {
          return Ve === "number";
        }), Ze = J10 !== "string";
        return Ze && Qe && !ke ? me2(H10) : function() {
          return we2(H10, J10, de2, arguments, ke);
        };
      }
      var Ee2 = 1, Pe2 = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
      function Xe(H10, J10, de2) {
        for (var ke = J10 + de2, Qe = J10; H10[Qe] && !(Qe >= ke); )
          ++Qe;
        if (Qe - J10 > 16 && H10.subarray && Pe2)
          return Pe2.decode(H10.subarray(J10, Qe));
        for (var Ze = ""; J10 < Qe; ) {
          var Ve = H10[J10++];
          if (!(Ve & 128)) {
            Ze += String.fromCharCode(Ve);
            continue;
          }
          var ze = H10[J10++] & 63;
          if ((Ve & 224) == 192) {
            Ze += String.fromCharCode((Ve & 31) << 6 | ze);
            continue;
          }
          var Tt = H10[J10++] & 63;
          if ((Ve & 240) == 224 ? Ve = (Ve & 15) << 12 | ze << 6 | Tt : Ve = (Ve & 7) << 18 | ze << 12 | Tt << 6 | H10[J10++] & 63, Ve < 65536)
            Ze += String.fromCharCode(Ve);
          else {
            var rs = Ve - 65536;
            Ze += String.fromCharCode(55296 | rs >> 10, 56320 | rs & 1023);
          }
        }
        return Ze;
      }
      function Je(H10, J10) {
        return H10 ? Xe(Jt, H10, J10) : "";
      }
      function Ye(H10, J10, de2, ke) {
        if (!(ke > 0))
          return 0;
        for (var Qe = de2, Ze = de2 + ke - 1, Ve = 0; Ve < H10.length; ++Ve) {
          var ze = H10.charCodeAt(Ve);
          if (ze >= 55296 && ze <= 57343) {
            var Tt = H10.charCodeAt(++Ve);
            ze = 65536 + ((ze & 1023) << 10) | Tt & 1023;
          }
          if (ze <= 127) {
            if (de2 >= Ze)
              break;
            J10[de2++] = ze;
          } else if (ze <= 2047) {
            if (de2 + 1 >= Ze)
              break;
            J10[de2++] = 192 | ze >> 6, J10[de2++] = 128 | ze & 63;
          } else if (ze <= 65535) {
            if (de2 + 2 >= Ze)
              break;
            J10[de2++] = 224 | ze >> 12, J10[de2++] = 128 | ze >> 6 & 63, J10[de2++] = 128 | ze & 63;
          } else {
            if (de2 + 3 >= Ze)
              break;
            J10[de2++] = 240 | ze >> 18, J10[de2++] = 128 | ze >> 12 & 63, J10[de2++] = 128 | ze >> 6 & 63, J10[de2++] = 128 | ze & 63;
          }
        }
        return J10[de2] = 0, de2 - Qe;
      }
      function tt(H10, J10, de2) {
        return Ye(H10, Jt, J10, de2);
      }
      function Ce2(H10) {
        for (var J10 = 0, de2 = 0; de2 < H10.length; ++de2) {
          var ke = H10.charCodeAt(de2);
          ke >= 55296 && ke <= 57343 && (ke = 65536 + ((ke & 1023) << 10) | H10.charCodeAt(++de2) & 1023), ke <= 127 ? ++J10 : ke <= 2047 ? J10 += 2 : ke <= 65535 ? J10 += 3 : J10 += 4;
        }
        return J10;
      }
      var ut = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
      function rt(H10, J10) {
        Et.set(H10, J10);
      }
      function Zt(H10, J10, de2) {
        for (var ke = 0; ke < H10.length; ++ke)
          Et[J10++ >> 0] = H10.charCodeAt(ke);
        de2 || (Et[J10 >> 0] = 0);
      }
      function Nt(H10, J10) {
        return H10 % J10 > 0 && (H10 += J10 - H10 % J10), H10;
      }
      var In, Et, Jt, Sn, Cn, Xt, Rn, en, Ms;
      function Ls(H10) {
        In = H10, a10.HEAP8 = Et = new Int8Array(H10), a10.HEAP16 = Sn = new Int16Array(H10), a10.HEAP32 = Xt = new Int32Array(H10), a10.HEAPU8 = Jt = new Uint8Array(H10), a10.HEAPU16 = Cn = new Uint16Array(H10), a10.HEAPU32 = Rn = new Uint32Array(H10), a10.HEAPF32 = en = new Float32Array(H10), a10.HEAPF64 = Ms = new Float64Array(H10);
      }
      var xi = a10.INITIAL_MEMORY || 16777216, Js, Bs = [], du = [], wi = [], tn = false, ac = false, ic = 0;
      function pu() {
        return se2 || ic > 0;
      }
      function oc() {
        if (a10.preRun)
          for (typeof a10.preRun == "function" && (a10.preRun = [a10.preRun]); a10.preRun.length; )
            cc(a10.preRun.shift());
        fu(Bs);
      }
      function uc() {
        tn = true, fu(du);
      }
      function Ev() {
        ac = true;
      }
      function lc() {
        if (a10.postRun)
          for (typeof a10.postRun == "function" && (a10.postRun = [a10.postRun]); a10.postRun.length; )
            dc(a10.postRun.shift());
        fu(wi);
      }
      function cc(H10) {
        Bs.unshift(H10);
      }
      function ns(H10) {
        du.unshift(H10);
      }
      function dc(H10) {
        wi.unshift(H10);
      }
      var Dn = 0, ki = null, er = null;
      function eh(H10) {
        Dn++, a10.monitorRunDependencies && a10.monitorRunDependencies(Dn);
      }
      function pc(H10) {
        if (Dn--, a10.monitorRunDependencies && a10.monitorRunDependencies(Dn), Dn == 0 && (ki !== null && (clearInterval(ki), ki = null), er)) {
          var J10 = er;
          er = null, J10();
        }
      }
      a10.preloadedImages = {}, a10.preloadedAudios = {};
      function Fr(H10) {
        a10.onAbort && a10.onAbort(H10), H10 = "Aborted(" + H10 + ")", R10(H10), oe2 = true, re2 = 1, H10 += ". Build with -s ASSERTIONS=1 for more info.";
        var J10 = new WebAssembly.RuntimeError(H10);
        throw o10(J10), J10;
      }
      var th = "data:application/octet-stream;base64,";
      function hc(H10) {
        return H10.startsWith(th);
      }
      function Or(H10) {
        return H10.startsWith("file://");
      }
      var nn;
      nn = "tfjs-backend-wasm.wasm", hc(nn) || (nn = b10(nn));
      function hu(H10) {
        try {
          if (H10 == nn && ee2)
            return new Uint8Array(ee2);
          if (x10)
            return x10(H10);
          throw "both async and sync fetching of the wasm failed";
        } catch (J10) {
          Fr(J10);
        }
      }
      function nh() {
        if (!ee2 && (h10 || f10)) {
          if (typeof fetch == "function" && !Or(nn))
            return fetch(nn, { credentials: "same-origin" }).then(function(H10) {
              if (!H10.ok)
                throw "failed to load wasm binary file at '" + nn + "'";
              return H10.arrayBuffer();
            }).catch(function() {
              return hu(nn);
            });
          if (v10)
            return new Promise(function(H10, J10) {
              v10(nn, function(de2) {
                H10(new Uint8Array(de2));
              }, J10);
            });
        }
        return Promise.resolve().then(function() {
          return hu(nn);
        });
      }
      function sh() {
        var H10 = { env: Ci, wasi_snapshot_preview1: Ci };
        function J10(Ve, ze) {
          var Tt = Ve.exports;
          a10.asm = Tt, ne2 = a10.asm.memory, Ls(ne2.buffer), Js = a10.asm.__indirect_function_table, ns(a10.asm.__wasm_call_ctors), pc("wasm-instantiate");
        }
        eh("wasm-instantiate");
        function de2(Ve) {
          J10(Ve.instance);
        }
        function ke(Ve) {
          return nh().then(function(ze) {
            return WebAssembly.instantiate(ze, H10);
          }).then(function(ze) {
            return ze;
          }).then(Ve, function(ze) {
            R10("failed to asynchronously prepare wasm: " + ze), Fr(ze);
          });
        }
        function Qe() {
          return !ee2 && typeof WebAssembly.instantiateStreaming == "function" && !hc(nn) && !Or(nn) && typeof fetch == "function" ? fetch(nn, { credentials: "same-origin" }).then(function(Ve) {
            var ze = WebAssembly.instantiateStreaming(Ve, H10);
            return ze.then(de2, function(Tt) {
              return R10("wasm streaming compile failed: " + Tt), R10("falling back to ArrayBuffer instantiation"), ke(de2);
            });
          }) : ke(de2);
        }
        if (a10.instantiateWasm)
          try {
            var Ze = a10.instantiateWasm(H10, J10);
            return Ze;
          } catch (Ve) {
            return R10("Module.instantiateWasm callback failed with error: " + Ve), false;
          }
        return Qe().catch(o10), {};
      }
      var Rv, Dv;
      function fu(H10) {
        for (; H10.length > 0; ) {
          var J10 = H10.shift();
          if (typeof J10 == "function") {
            J10(a10);
            continue;
          }
          var de2 = J10.func;
          typeof de2 == "number" ? J10.arg === void 0 ? mu(de2)() : mu(de2)(J10.arg) : de2(J10.arg === void 0 ? null : J10.arg);
        }
      }
      function tr(H10) {
        return H10;
      }
      function fc(H10) {
        var J10 = /\b_Z[\w\d_]+/g;
        return H10.replace(J10, function(de2) {
          var ke = de2;
          return de2 === ke ? de2 : ke + " [" + de2 + "]";
        });
      }
      var ss = [];
      function mu(H10) {
        var J10 = ss[H10];
        return J10 || (H10 >= ss.length && (ss.length = H10 + 1), ss[H10] = J10 = Js.get(H10)), J10;
      }
      function Fv() {
        var H10 = new Error();
        if (!H10.stack) {
          try {
            throw new Error();
          } catch (J10) {
            H10 = J10;
          }
          if (!H10.stack)
            return "(no stack trace available)";
        }
        return H10.stack.toString();
      }
      function Ii(H10, J10) {
        Js.set(H10, J10), ss[H10] = J10;
      }
      function rh() {
        Fr("");
      }
      function mc(H10, J10, de2) {
        Jt.copyWithin(H10, J10, J10 + de2);
      }
      function gc() {
        return 2147483648;
      }
      function sn(H10) {
        try {
          return ne2.grow(H10 - In.byteLength + 65535 >>> 16), Ls(ne2.buffer), 1;
        } catch (J10) {
        }
      }
      function bc(H10) {
        var J10 = Jt.length;
        H10 = H10 >>> 0;
        var de2 = gc();
        if (H10 > de2)
          return false;
        for (var ke = 1; ke <= 4; ke *= 2) {
          var Qe = J10 * (1 + 0.2 / ke);
          Qe = Math.min(Qe, H10 + 100663296);
          var Ze = Math.min(de2, Nt(Math.max(H10, Qe), 65536)), Ve = sn(Ze);
          if (Ve)
            return true;
        }
        return false;
      }
      var Si = { mappings: {}, buffers: [null, [], []], printChar: function(H10, J10) {
        var de2 = Si.buffers[H10];
        J10 === 0 || J10 === 10 ? ((H10 === 1 ? P10 : R10)(Xe(de2, 0)), de2.length = 0) : de2.push(J10);
      }, varargs: void 0, get: function() {
        Si.varargs += 4;
        var H10 = Xt[Si.varargs - 4 >> 2];
        return H10;
      }, getStr: function(H10) {
        var J10 = Je(H10);
        return J10;
      }, get64: function(H10, J10) {
        return H10;
      } };
      function ah(H10) {
        return 0;
      }
      function Ov(H10, J10, de2, ke, Qe) {
      }
      function Pv(H10, J10, de2, ke) {
        for (var Qe = 0, Ze = 0; Ze < de2; Ze++) {
          var Ve = Xt[J10 >> 2], ze = Xt[J10 + 4 >> 2];
          J10 += 8;
          for (var Tt = 0; Tt < ze; Tt++)
            Si.printChar(H10, Jt[Ve + Tt]);
          Qe += ze;
        }
        return Xt[ke >> 2] = Qe, 0;
      }
      function ih(H10) {
        te2(H10);
      }
      var yc = false, Ci = { abort: rh, emscripten_memcpy_big: mc, emscripten_resize_heap: bc, fd_close: ah, fd_seek: Ov, fd_write: Pv, setTempRet0: ih }, zN = sh(), zv = a10.___wasm_call_ctors = function() {
        return (zv = a10.___wasm_call_ctors = a10.asm.__wasm_call_ctors).apply(null, arguments);
      }, oh = a10._init = function() {
        return (oh = a10._init = a10.asm.init).apply(null, arguments);
      }, uh = a10._init_with_threads_count = function() {
        return (uh = a10._init_with_threads_count = a10.asm.init_with_threads_count).apply(null, arguments);
      }, vc = a10._get_threads_count = function() {
        return (vc = a10._get_threads_count = a10.asm.get_threads_count).apply(null, arguments);
      }, xc = a10._register_tensor = function() {
        return (xc = a10._register_tensor = a10.asm.register_tensor).apply(null, arguments);
      }, lh = a10._dispose_data = function() {
        return (lh = a10._dispose_data = a10.asm.dispose_data).apply(null, arguments);
      }, $e = a10._dispose = function() {
        return ($e = a10._dispose = a10.asm.dispose).apply(null, arguments);
      }, ch = a10._Abs = function() {
        return (ch = a10._Abs = a10.asm.Abs).apply(null, arguments);
      }, wc = a10._Add = function() {
        return (wc = a10._Add = a10.asm.Add).apply(null, arguments);
      }, Pr = a10._AddN = function() {
        return (Pr = a10._AddN = a10.asm.AddN).apply(null, arguments);
      }, Ni = a10._All = function() {
        return (Ni = a10._All = a10.asm.All).apply(null, arguments);
      }, dh = a10._Any = function() {
        return (dh = a10._Any = a10.asm.Any).apply(null, arguments);
      }, Mv = a10._ArgMax = function() {
        return (Mv = a10._ArgMax = a10.asm.ArgMax).apply(null, arguments);
      }, ph = a10._AvgPool = function() {
        return (ph = a10._AvgPool = a10.asm.AvgPool).apply(null, arguments);
      }, Lv = a10._BatchMatMul = function() {
        return (Lv = a10._BatchMatMul = a10.asm.BatchMatMul).apply(null, arguments);
      }, zr = a10._Ceil = function() {
        return (zr = a10._Ceil = a10.asm.Ceil).apply(null, arguments);
      }, hh = a10._ClipByValue = function() {
        return (hh = a10._ClipByValue = a10.asm.ClipByValue).apply(null, arguments);
      }, fh = a10._Conv2D = function() {
        return (fh = a10._Conv2D = a10.asm.Conv2D).apply(null, arguments);
      }, mh = a10._Conv2DBackpropInput = function() {
        return (mh = a10._Conv2DBackpropInput = a10.asm.Conv2DBackpropInput).apply(null, arguments);
      }, gh = a10._Cos = function() {
        return (gh = a10._Cos = a10.asm.Cos).apply(null, arguments);
      }, bh = a10._Cosh = function() {
        return (bh = a10._Cosh = a10.asm.Cosh).apply(null, arguments);
      }, yh = a10._CropAndResize = function() {
        return (yh = a10._CropAndResize = a10.asm.CropAndResize).apply(null, arguments);
      }, kc = a10._Cumsum = function() {
        return (kc = a10._Cumsum = a10.asm.Cumsum).apply(null, arguments);
      }, vh = a10._DepthToSpace = function() {
        return (vh = a10._DepthToSpace = a10.asm.DepthToSpace).apply(null, arguments);
      }, xh = a10._DepthwiseConv2dNative = function() {
        return (xh = a10._DepthwiseConv2dNative = a10.asm.DepthwiseConv2dNative).apply(null, arguments);
      }, wh = a10._Elu = function() {
        return (wh = a10._Elu = a10.asm.Elu).apply(null, arguments);
      }, kh = a10._Equal = function() {
        return (kh = a10._Equal = a10.asm.Equal).apply(null, arguments);
      }, Ih = a10._Exp = function() {
        return (Ih = a10._Exp = a10.asm.Exp).apply(null, arguments);
      }, Ic = a10._FlipLeftRight = function() {
        return (Ic = a10._FlipLeftRight = a10.asm.FlipLeftRight).apply(null, arguments);
      }, Sh = a10._Floor = function() {
        return (Sh = a10._Floor = a10.asm.Floor).apply(null, arguments);
      }, Ch = a10._FloorDiv = function() {
        return (Ch = a10._FloorDiv = a10.asm.FloorDiv).apply(null, arguments);
      }, Mr = a10._FusedBatchNorm = function() {
        return (Mr = a10._FusedBatchNorm = a10.asm.FusedBatchNorm).apply(null, arguments);
      }, gu = a10._FusedConv2D = function() {
        return (gu = a10._FusedConv2D = a10.asm.FusedConv2D).apply(null, arguments);
      }, Nh = a10._FusedDepthwiseConv2D = function() {
        return (Nh = a10._FusedDepthwiseConv2D = a10.asm.FusedDepthwiseConv2D).apply(null, arguments);
      }, Th = a10._Gather = function() {
        return (Th = a10._Gather = a10.asm.Gather).apply(null, arguments);
      }, $h = a10._GatherNd = function() {
        return ($h = a10._GatherNd = a10.asm.GatherNd).apply(null, arguments);
      }, Le2 = a10._Greater = function() {
        return (Le2 = a10._Greater = a10.asm.Greater).apply(null, arguments);
      }, _h = a10._GreaterEqual = function() {
        return (_h = a10._GreaterEqual = a10.asm.GreaterEqual).apply(null, arguments);
      }, Ah = a10._LeakyRelu = function() {
        return (Ah = a10._LeakyRelu = a10.asm.LeakyRelu).apply(null, arguments);
      }, Eh = a10._Less = function() {
        return (Eh = a10._Less = a10.asm.Less).apply(null, arguments);
      }, Rh = a10._LessEqual = function() {
        return (Rh = a10._LessEqual = a10.asm.LessEqual).apply(null, arguments);
      }, Dh = a10._Log = function() {
        return (Dh = a10._Log = a10.asm.Log).apply(null, arguments);
      }, Fh = a10._LogicalAnd = function() {
        return (Fh = a10._LogicalAnd = a10.asm.LogicalAnd).apply(null, arguments);
      }, bu = a10._Max = function() {
        return (bu = a10._Max = a10.asm.Max).apply(null, arguments);
      }, Sc = a10._MaxPool = function() {
        return (Sc = a10._MaxPool = a10.asm.MaxPool).apply(null, arguments);
      }, Cc = a10._Maximum = function() {
        return (Cc = a10._Maximum = a10.asm.Maximum).apply(null, arguments);
      }, Oh = a10._Mean = function() {
        return (Oh = a10._Mean = a10.asm.Mean).apply(null, arguments);
      }, Ph = a10._Min = function() {
        return (Ph = a10._Min = a10.asm.Min).apply(null, arguments);
      }, zh = a10._Minimum = function() {
        return (zh = a10._Minimum = a10.asm.Minimum).apply(null, arguments);
      }, Mh = a10._MirrorPad = function() {
        return (Mh = a10._MirrorPad = a10.asm.MirrorPad).apply(null, arguments);
      }, Lh = a10._Multiply = function() {
        return (Lh = a10._Multiply = a10.asm.Multiply).apply(null, arguments);
      }, Bh = a10._Neg = function() {
        return (Bh = a10._Neg = a10.asm.Neg).apply(null, arguments);
      }, gt = a10._NonMaxSuppressionV3 = function() {
        return (gt = a10._NonMaxSuppressionV3 = a10.asm.NonMaxSuppressionV3).apply(null, arguments);
      }, Vh = a10._NonMaxSuppressionV4 = function() {
        return (Vh = a10._NonMaxSuppressionV4 = a10.asm.NonMaxSuppressionV4).apply(null, arguments);
      }, Wh = a10._NonMaxSuppressionV5 = function() {
        return (Wh = a10._NonMaxSuppressionV5 = a10.asm.NonMaxSuppressionV5).apply(null, arguments);
      }, Uh = a10._NotEqual = function() {
        return (Uh = a10._NotEqual = a10.asm.NotEqual).apply(null, arguments);
      }, Ti = a10._OneHot = function() {
        return (Ti = a10._OneHot = a10.asm.OneHot).apply(null, arguments);
      }, Nc = a10._PadV2 = function() {
        return (Nc = a10._PadV2 = a10.asm.PadV2).apply(null, arguments);
      }, Tc = a10._Pow = function() {
        return (Tc = a10._Pow = a10.asm.Pow).apply(null, arguments);
      }, $c = a10._Prelu = function() {
        return ($c = a10._Prelu = a10.asm.Prelu).apply(null, arguments);
      }, Gh = a10._Prod = function() {
        return (Gh = a10._Prod = a10.asm.Prod).apply(null, arguments);
      }, _c = a10._RealDiv = function() {
        return (_c = a10._RealDiv = a10.asm.RealDiv).apply(null, arguments);
      }, Hh = a10._Relu = function() {
        return (Hh = a10._Relu = a10.asm.Relu).apply(null, arguments);
      }, Bv = a10._Relu6 = function() {
        return (Bv = a10._Relu6 = a10.asm.Relu6).apply(null, arguments);
      }, Ac = a10._ResizeBilinear = function() {
        return (Ac = a10._ResizeBilinear = a10.asm.ResizeBilinear).apply(null, arguments);
      }, Vv = a10._Reverse = function() {
        return (Vv = a10._Reverse = a10.asm.Reverse).apply(null, arguments);
      }, qh = a10._RotateWithOffset = function() {
        return (qh = a10._RotateWithOffset = a10.asm.RotateWithOffset).apply(null, arguments);
      }, jh = a10._Round = function() {
        return (jh = a10._Round = a10.asm.Round).apply(null, arguments);
      }, Kh = a10._Rsqrt = function() {
        return (Kh = a10._Rsqrt = a10.asm.Rsqrt).apply(null, arguments);
      }, Xh = a10._ScatterNd = function() {
        return (Xh = a10._ScatterNd = a10.asm.ScatterNd).apply(null, arguments);
      }, Yh = a10._SelectV2 = function() {
        return (Yh = a10._SelectV2 = a10.asm.SelectV2).apply(null, arguments);
      }, Qh = a10._Sigmoid = function() {
        return (Qh = a10._Sigmoid = a10.asm.Sigmoid).apply(null, arguments);
      }, Zh = a10._Sin = function() {
        return (Zh = a10._Sin = a10.asm.Sin).apply(null, arguments);
      }, Jh = a10._Softmax = function() {
        return (Jh = a10._Softmax = a10.asm.Softmax).apply(null, arguments);
      }, ef = a10._SparseFillEmptyRows = function() {
        return (ef = a10._SparseFillEmptyRows = a10.asm.SparseFillEmptyRows).apply(null, arguments);
      }, tf = a10._SparseReshape = function() {
        return (tf = a10._SparseReshape = a10.asm.SparseReshape).apply(null, arguments);
      }, nf = a10._SparseSegmentReduction = function() {
        return (nf = a10._SparseSegmentReduction = a10.asm.SparseSegmentReduction).apply(null, arguments);
      }, sf = a10._Sqrt = function() {
        return (sf = a10._Sqrt = a10.asm.Sqrt).apply(null, arguments);
      }, rf = a10._Square = function() {
        return (rf = a10._Square = a10.asm.Square).apply(null, arguments);
      }, af = a10._SquaredDifference = function() {
        return (af = a10._SquaredDifference = a10.asm.SquaredDifference).apply(null, arguments);
      }, of = a10._Step = function() {
        return (of = a10._Step = a10.asm.Step).apply(null, arguments);
      }, uf = a10._StridedSlice = function() {
        return (uf = a10._StridedSlice = a10.asm.StridedSlice).apply(null, arguments);
      }, lf = a10._Sub = function() {
        return (lf = a10._Sub = a10.asm.Sub).apply(null, arguments);
      }, cf = a10._Sum = function() {
        return (cf = a10._Sum = a10.asm.Sum).apply(null, arguments);
      }, df = a10._Tan = function() {
        return (df = a10._Tan = a10.asm.Tan).apply(null, arguments);
      }, pf = a10._Tanh = function() {
        return (pf = a10._Tanh = a10.asm.Tanh).apply(null, arguments);
      }, hf = a10._Tile = function() {
        return (hf = a10._Tile = a10.asm.Tile).apply(null, arguments);
      }, ff = a10._TopK = function() {
        return (ff = a10._TopK = a10.asm.TopK).apply(null, arguments);
      }, mf = a10._Transform = function() {
        return (mf = a10._Transform = a10.asm.Transform).apply(null, arguments);
      }, gf = a10._Transpose = function() {
        return (gf = a10._Transpose = a10.asm.Transpose).apply(null, arguments);
      }, bf = a10.__FusedMatMul = function() {
        return (bf = a10.__FusedMatMul = a10.asm._FusedMatMul).apply(null, arguments);
      }, yf = a10._malloc = function() {
        return (yf = a10._malloc = a10.asm.malloc).apply(null, arguments);
      }, vf = a10._free = function() {
        return (vf = a10._free = a10.asm.free).apply(null, arguments);
      }, xf = a10.___errno_location = function() {
        return (xf = a10.___errno_location = a10.asm.__errno_location).apply(null, arguments);
      }, wf = a10._emscripten_main_thread_process_queued_calls = function() {
        return (wf = a10._emscripten_main_thread_process_queued_calls = a10.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
      }, Ec = a10.stackSave = function() {
        return (Ec = a10.stackSave = a10.asm.stackSave).apply(null, arguments);
      }, Rc = a10.stackRestore = function() {
        return (Rc = a10.stackRestore = a10.asm.stackRestore).apply(null, arguments);
      }, yu = a10.stackAlloc = function() {
        return (yu = a10.stackAlloc = a10.asm.stackAlloc).apply(null, arguments);
      }, kf = a10.dynCall_iijjiiii = function() {
        return (kf = a10.dynCall_iijjiiii = a10.asm.dynCall_iijjiiii).apply(null, arguments);
      }, If = a10.dynCall_jiji = function() {
        return (If = a10.dynCall_jiji = a10.asm.dynCall_jiji).apply(null, arguments);
      };
      a10.cwrap = Se2;
      var $i;
      function vu(H10) {
        this.name = "ExitStatus", this.message = "Program terminated with exit(" + H10 + ")", this.status = H10;
      }
      er = function H10() {
        $i || xu(), $i || (er = H10);
      };
      function xu(H10) {
        if (H10 = H10 || c10, Dn > 0 || (oc(), Dn > 0))
          return;
        function J10() {
          $i || ($i = true, a10.calledRun = true, !oe2 && (uc(), i10(a10), a10.onRuntimeInitialized && a10.onRuntimeInitialized(), lc()));
        }
        a10.setStatus ? (a10.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            a10.setStatus("");
          }, 1), J10();
        }, 1)) : J10();
      }
      a10.run = xu;
      function Wv(H10) {
        re2 = H10, pu() || (a10.onExit && a10.onExit(H10), oe2 = true), d10(H10, new vu(H10));
      }
      if (a10.preInit)
        for (typeof a10.preInit == "function" && (a10.preInit = [a10.preInit]); a10.preInit.length > 0; )
          a10.preInit.pop()();
      xu();
      var _i;
      u10 && (_i = { uncaughtException: process.listeners("uncaughtException").filter(function(H10) {
        return !u10.uncaughtException.indexOf(H10) > -1;
      }), unhandledRejection: process.listeners("unhandledRejection").filter(function(H10) {
        return !u10.unhandledRejection.indexOf(H10) > -1;
      }) });
      var Ai;
      if (typeof r10 != "undefined")
        Ai = r10;
      else if (typeof WasmBackendModuleThreadedSimd != "undefined")
        Ai = WasmBackendModuleThreadedSimd;
      else
        throw new Error("Could not find wasm module in post.js");
      if (_i) {
        var Sf = Ai._dispose;
        Ai._dispose = function() {
          Sf(), _i.uncaughtException.forEach(function(H10) {
            process.removeListener("uncaughtException", H10);
          }), _i.unhandledRejection.forEach(function(H10) {
            process.removeListener("unhandledRejection", H10);
          });
        };
      }
      return r10.ready;
    };
  })();
  typeof e == "object" && typeof t == "object" ? t.exports = n10 : typeof define == "function" && define.amd ? define([], function() {
    return n10;
  }) : typeof e == "object" && (e.WasmBackendModule = n10);
} });
var ZT = 1e-7;
var JT = 1e-4;
var Wd = class {
  constructor(e, t) {
    this.backend = e, this.dataMover = t, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  get(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }
  set(e, t) {
    this.dataIdsCount++, this.data.set(e, t);
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
};
var tl = class {
  refCount(e) {
    return Fn("refCount");
  }
  incRef(e) {
    return Fn("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(e) {
    return Fn("time");
  }
  read(e) {
    return Fn("read");
  }
  readSync(e) {
    return Fn("readSync");
  }
  readToGPU(e, t) {
    return Fn("readToGPU");
  }
  numDataIds() {
    return Fn("numDataIds");
  }
  disposeData(e, t) {
    return Fn("disposeData");
  }
  write(e, t, n10) {
    return Fn("write");
  }
  move(e, t, n10, s10, r10) {
    return Fn("move");
  }
  memory() {
    return Fn("memory");
  }
  floatPrecision() {
    return Fn("floatPrecision");
  }
  epsilon() {
    return this.floatPrecision() === 32 ? ZT : JT;
  }
  dispose() {
    return Fn("dispose");
  }
};
function Fn(e) {
  throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
function zw(e) {
  let t = e.length, n10 = 0;
  for (; t > 0; )
    n10 = Math.random() * t | 0, t--, dd(e, t, n10);
}
function e$(e, t) {
  if (e.length !== t.length)
    throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);
  let n10 = e.length, s10 = 0;
  for (; n10 > 0; )
    s10 = Math.random() * n10 | 0, n10--, dd(e, n10, s10), dd(t, n10, s10);
}
function Bu(e, t, n10) {
  return Math.max(e, Math.min(t, n10));
}
function t$(e) {
  return e % 2 === 0 ? e : e + 1;
}
function dd(e, t, n10) {
  let s10 = e[t];
  e[t] = e[n10], e[n10] = s10;
}
function n$(e) {
  let t = 0;
  for (let n10 = 0; n10 < e.length; n10++)
    t += e[n10];
  return t;
}
function s$(e, t) {
  let n10 = Math.random();
  return t * n10 + (1 - n10) * e;
}
function r$(e, t) {
  let n10 = 0;
  for (let s10 = 0; s10 < e.length; s10++) {
    let r10 = Number(e[s10]) - Number(t[s10]);
    n10 += r10 * r10;
  }
  return n10;
}
function O2(e, t) {
  if (!e)
    throw new Error(typeof t == "string" ? t : t());
}
function dn(e, t, n10 = "") {
  O2(wr(e, t), () => n10 + ` Shapes ${e} and ${t} must match`);
}
function va(e) {
  O2(e != null, () => "The input to the tensor constructor must be a non-null value.");
}
function ta(e, t = [], n10 = false) {
  if (t == null && (t = []), Array.isArray(e) || Yt(e) && !n10)
    for (let s10 = 0; s10 < e.length; ++s10)
      ta(e[s10], t, n10);
  else
    t.push(e);
  return t;
}
function pt(e) {
  if (e.length === 0)
    return 1;
  let t = e[0];
  for (let n10 = 1; n10 < e.length; n10++)
    t *= e[n10];
  return t;
}
function a$(e) {
  return e.length === 0;
}
function wr(e, t) {
  if (e === t)
    return true;
  if (e == null || t == null || e.length !== t.length)
    return false;
  for (let n10 = 0; n10 < e.length; n10++)
    if (e[n10] !== t[n10])
      return false;
  return true;
}
function Xi(e) {
  return e % 1 === 0;
}
function i$(e) {
  if (Math.tanh != null)
    return Math.tanh(e);
  if (e === 1 / 0)
    return 1;
  if (e === -1 / 0)
    return -1;
  {
    let t = Math.exp(2 * e);
    return (t - 1) / (t + 1);
  }
}
function o$(e) {
  let t = Math.ceil(Math.sqrt(e));
  return [t, Math.ceil(e / t)];
}
function u$(e) {
  let t = new Uint32Array(e);
  for (let n10 = 0; n10 < e; ++n10)
    t[n10] = n10;
  return zw(t), t;
}
function Pu(e, t) {
  return t <= e.length ? e : e + " ".repeat(t - e.length);
}
function l$(e, t = (s10) => 0, n10) {
  return new Promise((s10, r10) => {
    let a10 = 0, i10 = () => {
      if (e()) {
        s10();
        return;
      }
      a10++;
      let o10 = t(a10);
      if (n10 != null && a10 >= n10) {
        r10();
        return;
      }
      setTimeout(i10, o10);
    };
    i10();
  });
}
function c$(e, t) {
  let n10 = 1, s10 = -1;
  for (let a10 = 0; a10 < e.length; ++a10)
    if (e[a10] >= 0)
      n10 *= e[a10];
    else if (e[a10] === -1) {
      if (s10 !== -1)
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s10} and dim ${a10}`);
      s10 = a10;
    } else if (e[a10] < 0)
      throw Error(`Shapes can not be < 0. Found ${e[a10]} at dim ${a10}`);
  if (s10 === -1) {
    if (t > 0 && t !== n10)
      throw Error(`Size(${t}) must match the product of shape ${e}`);
    return e;
  }
  if (n10 === 0)
    throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);
  if (t % n10 !== 0)
    throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n10}`);
  let r10 = e.slice();
  return r10[s10] = t / n10, r10;
}
function Jn(e, t) {
  let n10 = t.length;
  return e = e == null ? t.map((s10, r10) => r10) : [].concat(e), O2(e.every((s10) => s10 >= -n10 && s10 < n10), () => `All values in axis param must be in range [-${n10}, ${n10}) but got axis ${e}`), O2(e.every((s10) => Xi(s10)), () => `All values in axis param must be integers but got axis ${e}`), e.map((s10) => s10 < 0 ? n10 + s10 : s10);
}
function Mw(e, t) {
  let n10 = [], s10 = [], r10 = t != null && Array.isArray(t) && t.length === 0, a10 = t == null || r10 ? null : Jn(t, e).sort(), i10 = 0;
  for (let o10 = 0; o10 < e.length; ++o10) {
    if (a10 != null) {
      if (a10[i10] === o10 && e[o10] !== 1)
        throw new Error(`Can't squeeze axis ${o10} since its dim '${e[o10]}' is not 1`);
      (a10[i10] == null || a10[i10] > o10) && e[o10] === 1 && (n10.push(e[o10]), s10.push(o10)), a10[i10] <= o10 && i10++;
    }
    e[o10] !== 1 && (n10.push(e[o10]), s10.push(o10));
  }
  return { newShape: n10, keptDims: s10 };
}
function Lw(e, t) {
  let n10 = null;
  if (e == null || e === "float32")
    n10 = new Float32Array(t);
  else if (e === "int32")
    n10 = new Int32Array(t);
  else if (e === "bool")
    n10 = new Uint8Array(t);
  else
    throw new Error(`Unknown data type ${e}`);
  return n10;
}
function Bw(e, t) {
  let n10 = null;
  if (e == null || e === "float32")
    n10 = new Float32Array(t);
  else if (e === "int32")
    n10 = new Int32Array(t);
  else if (e === "bool")
    n10 = new Uint8Array(t);
  else if (e === "string")
    n10 = new Array(t);
  else
    throw new Error(`Unknown data type ${e}`);
  return n10;
}
function Vw(e, t) {
  for (let n10 = 0; n10 < e.length; n10++) {
    let s10 = e[n10];
    if (isNaN(s10) || !isFinite(s10))
      throw Error(`A tensor of type ${t} being uploaded contains ${s10}.`);
  }
}
function Ww(e) {
  return e === "bool" || e === "complex64" || e === "float32" || e === "int32" || e === "string";
}
function d$(e, t) {
  return !(t === "complex64" || t === "float32" && e !== "complex64" || t === "int32" && e !== "float32" && e !== "complex64" || t === "bool" && e === "bool");
}
function Yt(e) {
  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray;
}
function jf(e) {
  if (e === "float32" || e === "int32")
    return 4;
  if (e === "complex64")
    return 8;
  if (e === "bool")
    return 1;
  throw new Error(`Unknown dtype ${e}`);
}
function Uw(e) {
  if (e == null)
    return 0;
  let t = 0;
  return e.forEach((n10) => t += n10.length), t;
}
function ir(e) {
  return typeof e == "string" || e instanceof String;
}
function Gw(e) {
  return typeof e == "boolean";
}
function Hw(e) {
  return typeof e == "number";
}
function Ud(e) {
  return Array.isArray(e) ? Ud(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray ? "int32" : Hw(e) ? "float32" : ir(e) ? "string" : Gw(e) ? "bool" : "float32";
}
function hr(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function pd(e, t) {
  for (let n10 = t; n10 < e; ++n10)
    if (e % n10 === 0)
      return n10;
  return e;
}
function ro(e) {
  let t = e.length;
  if (t < 2)
    return [];
  let n10 = new Array(t - 1);
  n10[t - 2] = e[t - 1];
  for (let s10 = t - 3; s10 >= 0; --s10)
    n10[s10] = n10[s10 + 1] * e[s10 + 1];
  return n10;
}
function qw(e, t, n10, s10 = false) {
  let r10 = new Array();
  if (t.length === 1) {
    let a10 = t[0] * (s10 ? 2 : 1);
    for (let i10 = 0; i10 < a10; i10++)
      r10[i10] = n10[e + i10];
  } else {
    let a10 = t[0], i10 = t.slice(1), o10 = i10.reduce((u10, l10) => u10 * l10) * (s10 ? 2 : 1);
    for (let u10 = 0; u10 < a10; u10++)
      r10[u10] = qw(e + u10 * o10, i10, n10, s10);
  }
  return r10;
}
function Gi(e, t, n10 = false) {
  if (e.length === 0)
    return t[0];
  let s10 = e.reduce((r10, a10) => r10 * a10) * (n10 ? 2 : 1);
  if (s10 === 0)
    return [];
  if (s10 !== t.length)
    throw new Error(`[${e}] does not match the input size ${t.length}${n10 ? " for a complex tensor" : ""}.`);
  return qw(0, e, t, n10);
}
function eg(e, t) {
  let n10 = Gd(e, t);
  for (let s10 = 0; s10 < n10.length; s10++)
    n10[s10] = 1;
  return n10;
}
function Gd(e, t) {
  if (t == null || t === "float32" || t === "complex64")
    return new Float32Array(e);
  if (t === "int32")
    return new Int32Array(e);
  if (t === "bool")
    return new Uint8Array(e);
  throw new Error(`Unknown data type ${t}`);
}
function p$(e, t) {
  let n10 = e.reduce((s10, r10) => s10 * r10, 1);
  if (t == null || t === "float32")
    return Gi(e, new Float32Array(n10));
  if (t === "int32")
    return Gi(e, new Int32Array(n10));
  if (t === "bool")
    return Gi(e, new Uint8Array(n10));
  throw new Error(`Unknown data type ${t}`);
}
function tg(e) {
  e.forEach((t) => {
    O2(Number.isInteger(t) && t >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${e}].`);
  });
}
function h$(e, t, n10) {
  if (t === 0)
    return 0;
  if (t === 1)
    return e[0];
  let s10 = e[e.length - 1];
  for (let r10 = 0; r10 < e.length - 1; ++r10)
    s10 += n10[r10] * e[r10];
  return s10;
}
function f$(e, t, n10) {
  if (t === 0)
    return [];
  if (t === 1)
    return [e];
  let s10 = new Array(t);
  for (let r10 = 0; r10 < s10.length - 1; ++r10)
    s10[r10] = Math.floor(e / n10[r10]), e -= s10[r10] * n10[r10];
  return s10[s10.length - 1] = e, s10;
}
function ng(e) {
  return e && e.then && typeof e.then == "function";
}
var Zv = "tfjsflags";
var m$ = class {
  constructor(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = g$, this.populateURLFlags();
  }
  setPlatform(e, t) {
    this.platform != null && (X2().getBool("IS_TEST") || X2().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)), this.platformName = e, this.platform = t;
  }
  registerFlag(e, t, n10) {
    if (this.flagRegistry[e] = { evaluationFn: t, setHook: n10 }, this.urlFlags[e] != null) {
      let s10 = this.urlFlags[e];
      X2().getBool("IS_TEST") || X2().getBool("PROD") || console.warn(`Setting feature override from URL ${e}: ${s10}.`), this.set(e, s10);
    }
  }
  async getAsync(e) {
    return e in this.flags ? this.flags[e] : (this.flags[e] = await this.evaluateFlag(e), this.flags[e]);
  }
  get(e) {
    if (e in this.flags)
      return this.flags[e];
    let t = this.evaluateFlag(e);
    if (ng(t))
      throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
    return this.flags[e] = t, this.flags[e];
  }
  getNumber(e) {
    return this.get(e);
  }
  getBool(e) {
    return this.get(e);
  }
  getFlags() {
    return this.flags;
  }
  get features() {
    return this.flags;
  }
  set(e, t) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot set flag ${e} as it has not been registered.`);
    this.flags[e] = t, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(t);
  }
  evaluateFlag(e) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
    return this.flagRegistry[e].evaluationFn();
  }
  setFlags(e) {
    this.flags = Object.assign({}, e);
  }
  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global == "undefined" || typeof this.global.location == "undefined" || typeof this.global.location.search == "undefined")
      return;
    let e = this.getQueryParams(this.global.location.search);
    Zv in e && e[Zv].split(",").forEach((n10) => {
      let [s10, r10] = n10.split(":");
      this.urlFlags[s10] = y$(s10, r10);
    });
  }
};
function g$(e) {
  let t = {};
  return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (n10, ...s10) => (b$(t, s10[0], s10[1]), s10.join("="))), t;
}
function b$(e, t, n10) {
  e[decodeURIComponent(t)] = decodeURIComponent(n10 || "");
}
function y$(e, t) {
  if (t = t.toLowerCase(), t === "true" || t === "false")
    return t === "true";
  if (`${+t}` === t)
    return +t;
  throw new Error(`Could not parse value flag value ${t} for flag ${e}.`);
}
function X2() {
  return jw;
}
var jw = null;
function v$(e) {
  jw = e;
}
var Ef;
function Kw() {
  if (Ef == null) {
    let e;
    if (typeof window != "undefined")
      e = window;
    else if (typeof global != "undefined")
      e = global;
    else if (typeof process != "undefined")
      e = process;
    else if (typeof self != "undefined")
      e = self;
    else
      throw new Error("Could not find a global object");
    Ef = e;
  }
  return Ef;
}
function x$() {
  let e = Kw();
  return e._tfGlobals == null && (e._tfGlobals = /* @__PURE__ */ new Map()), e._tfGlobals;
}
function sg(e, t) {
  let n10 = x$();
  if (n10.has(e))
    return n10.get(e);
  {
    let s10 = t();
    return n10.set(e, s10), n10.get(e);
  }
}
var ao = "Abs";
var nl = "Acos";
var sl = "Acosh";
var kr = "Add";
var xa = "AddN";
var rl = "All";
var al = "Any";
var wa = "ArgMax";
var il = "ArgMin";
var ol = "Asin";
var ul = "Asinh";
var ll = "Atan";
var cl = "Atanh";
var dl = "Atan2";
var ka = "AvgPool";
var rg = "AvgPoolGrad";
var Hd = "AvgPool3D";
var ag = "AvgPool3DGrad";
var Ia = "BatchMatMul";
var io = "BatchToSpaceND";
var ig = "Bincount";
var w$ = "BroadcastTo";
var og = "BroadcastArgs";
var Sa = "Cast";
var Ca = "Ceil";
var Ir = "ClipByValue";
var qd = "Complex";
var jd = "ComplexAbs";
var oo = "Concat";
var Na = "Conv2D";
var ug = "Conv2DBackpropFilter";
var Ta = "Conv2DBackpropInput";
var Kd = "Conv3D";
var lg = "Conv3DBackpropFilterV2";
var cg = "Conv3DBackpropInputV2";
var $a = "Cos";
var _a = "Cosh";
var uo = "Cumsum";
var lo = "CropAndResize";
var dg = "DenseBincount";
var co = "DepthToSpace";
var Aa = "DepthwiseConv2dNative";
var pg = "DepthwiseConv2dNativeBackpropFilter";
var hg = "DepthwiseConv2dNativeBackpropInput";
var fg = "Diag";
var Xd = "Dilation2D";
var Kf = "Dilation2DBackpropInput";
var Xf = "Dilation2DBackpropFilter";
var Ea = "RealDiv";
var Yd = "Einsum";
var Ra = "Elu";
var mg = "EluGrad";
var pl = "Erf";
var po = "Equal";
var Da = "Exp";
var ho = "ExpandDims";
var fo = "Expm1";
var gg = "FFT";
var hl = "Fill";
var mo = "FlipLeftRight";
var Fa = "Floor";
var Oa = "FloorDiv";
var Pa = "FusedBatchNorm";
var go = "GatherV2";
var bo = "GatherNd";
var yo = "Greater";
var za = "GreaterEqual";
var Ma = "Identity";
var bg = "IFFT";
var Qd = "Imag";
var fl = "IsFinite";
var ml = "IsInf";
var gl = "IsNan";
var La = "LeakyRelu";
var vo = "Less";
var xo = "LessEqual";
var yg = "LinSpace";
var Ba = "Log";
var bl = "Log1p";
var wo = "LogicalAnd";
var yl = "LogicalNot";
var Zd = "LogicalOr";
var k$ = "LogSoftmax";
var Jd = "LRN";
var vg = "LRNGrad";
var Va = "Max";
var Wa = "Maximum";
var Ua = "MaxPool";
var xg = "MaxPoolGrad";
var ep = "MaxPool3D";
var wg = "MaxPool3DGrad";
var kg = "MaxPoolWithArgmax";
var Ga = "Mean";
var Ha = "Min";
var qa = "Minimum";
var ja = "MirrorPad";
var vl = "Mod";
var Ig = "Multinomial";
var Ka = "Multiply";
var ko = "Neg";
var Io = "NotEqual";
var So = "NonMaxSuppressionV3";
var xl = "NonMaxSuppressionV4";
var Co = "NonMaxSuppressionV5";
var No = "OnesLike";
var To = "OneHot";
var $o = "Pack";
var Xa = "PadV2";
var pde = "Pool";
var Ya = "Pow";
var Qa = "Prelu";
var _o = "Prod";
var wl = "Range";
var tp = "Real";
var kl = "Reciprocal";
var Za = "Relu";
var Ao = "Reshape";
var Il = "ResizeNearestNeighbor";
var Sg = "ResizeNearestNeighborGrad";
var Ja = "ResizeBilinear";
var Cg = "ResizeBilinearGrad";
var ei = "Relu6";
var Eo = "Reverse";
var Ro = "Round";
var ti = "Rsqrt";
var Do = "ScatterNd";
var Fo = "Select";
var Sl = "Selu";
var Oo = "Slice";
var ni = "Sin";
var Po = "Sinh";
var Cl = "Sign";
var si = "Sigmoid";
var Nl = "Softplus";
var ri = "Sqrt";
var ai = "Sum";
var zo = "SpaceToBatchND";
var Mo = "SplitV";
var ii = "Softmax";
var np = "SparseFillEmptyRows";
var Tl = "SparseReshape";
var sp = "SparseSegmentMean";
var rp = "SparseSegmentSum";
var ap = "SparseToDense";
var oi = "SquaredDifference";
var $l = "Square";
var Lo = "StridedSlice";
var ip = "StringNGrams";
var Ng = "StringSplit";
var Tg = "StringToHashBucketFast";
var ui = "Sub";
var Bo = "Tan";
var li = "Tanh";
var Sr = "Tile";
var Vo = "TopK";
var Wo = "Transform";
var ci = "Transpose";
var $g = "Unique";
var Uo = "Unpack";
var op = "UnsortedSegmentSum";
var Go = "ZerosLike";
var di = "Step";
var hd = "FromPixels";
var Ho = "RotateWithOffset";
var na = "_FusedMatMul";
var sa = "FusedConv2D";
var ra = "FusedDepthwiseConv2D";
function ar(...e) {
  X2().getBool("IS_TEST") || X2().getBool("PROD") || console.warn(...e);
}
function I$(...e) {
  X2().getBool("IS_TEST") || X2().getBool("PROD") || console.log(...e);
}
var Yi = sg("kernelRegistry", () => /* @__PURE__ */ new Map());
var Vu = sg("gradRegistry", () => /* @__PURE__ */ new Map());
function Yf(e, t) {
  let n10 = _g(e, t);
  return Yi.get(n10);
}
function Jv(e) {
  return Vu.get(e);
}
function Qf(e) {
  let t = Yi.entries(), n10 = [];
  for (; ; ) {
    let { done: s10, value: r10 } = t.next();
    if (s10)
      break;
    let [a10, i10] = r10, [o10] = a10.split("_");
    o10 === e && n10.push(i10);
  }
  return n10;
}
function _l(e) {
  let { kernelName: t, backendName: n10 } = e, s10 = _g(t, n10);
  Yi.has(s10) && ar(`The kernel '${t}' for backend '${n10}' is already registered`), Yi.set(s10, e);
}
function S$(e) {
  let { kernelName: t } = e;
  Vu.has(t) && X2().getBool("DEBUG") && ar(`Overriding the gradient for '${t}'`), Vu.set(t, e);
}
function hde(e, t) {
  let n10 = _g(e, t);
  if (!Yi.has(n10))
    throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);
  Yi.delete(n10);
}
function fde(e) {
  if (!Vu.has(e))
    throw new Error(`The gradient '${e}' for backend is not registered`);
  Vu.delete(e);
}
function mde(e, t) {
  Qf(e).forEach((s10) => {
    let r10 = Object.assign({}, s10, { backendName: t });
    _l(r10);
  });
}
function _g(e, t) {
  return `${t}_${e}`;
}
var w2 = {};
Ae(w2, { arraysEqual: () => wr, assert: () => O2, assertNonNegativeIntegerDimensions: () => tg, assertNonNull: () => va, assertShapesMatch: () => dn, bytesFromStringArray: () => Uw, bytesPerElement: () => jf, checkConversionForErrors: () => Vw, clamp: () => Bu, computeStrides: () => ro, createScalarValue: () => A$, createShuffledIndices: () => u$, decodeString: () => fd, distSquared: () => r$, encodeString: () => El, fetch: () => R$, fingerPrint64: () => _$, flatten: () => ta, getArrayFromDType: () => Bw, getTypedArrayFromDType: () => Lw, hasEncodingLoss: () => d$, hexToLong: () => Al, indexToLoc: () => f$, inferDtype: () => Ud, inferFromImplicitShape: () => c$, isBoolean: () => Gw, isFunction: () => hr, isInt: () => Xi, isNumber: () => Hw, isPromise: () => ng, isScalarShape: () => a$, isString: () => ir, isTypedArray: () => Yt, isValidDtype: () => Ww, locToIndex: () => h$, makeOnesTypedArray: () => eg, makeZerosNestedTypedArray: () => p$, makeZerosTypedArray: () => Gd, nearestDivisor: () => pd, nearestLargerEven: () => t$, now: () => Wu, parseAxisParam: () => Jn, randUniform: () => s$, repeatedTry: () => l$, rightPad: () => Pu, shuffle: () => zw, shuffleCombo: () => e$, sizeFromShape: () => pt, sizeToSquarishShape: () => o$, squeezeShape: () => Mw, sum: () => n$, swap: () => dd, tanh: () => i$, toNestedArray: () => Gi, toTypedArray: () => up });
var ex = ya(PT());
var Gr = ex.default || ex;
function Al(e) {
  return Gr.fromString(e, true, 16);
}
var Xw = Al("c3a5c85c97cb3127");
var Ur = Al("b492b66fbe98f273");
var an = Al("9ae16a3b2f90404f");
function Zf(e) {
  return e.xor(e.shru(47));
}
function Yw(e, t, n10) {
  let s10 = e.slice(t, t + n10);
  return Gr.fromBytes(Array.from(s10), true, true);
}
function lt(e, t) {
  return Yw(e, t, 8);
}
function tx(e, t) {
  return Yw(e, t, 4);
}
function Lt(e, t) {
  return t === 0 ? e : e.shru(t).or(e.shl(64 - t));
}
function ur(e, t, n10 = Al("9ddfea08eb382d69")) {
  let s10 = e.xor(t).mul(n10);
  s10 = s10.xor(s10.shru(47));
  let r10 = t.xor(s10).mul(n10);
  return r10 = r10.xor(r10.shru(47)), r10 = r10.mul(n10), r10;
}
function C$(e, t, n10, s10, r10, a10) {
  r10 = r10.add(e), a10 = Lt(a10.add(r10).add(s10), 21);
  let i10 = r10;
  return r10 = r10.add(t), r10 = r10.add(n10), a10 = a10.add(Lt(r10, 44)), [r10.add(s10), a10.add(i10)];
}
function Bc(e, t, n10, s10) {
  return C$(lt(e, t), lt(e, t + 8), lt(e, t + 16), lt(e, t + 24), n10, s10);
}
function N$(e, t = e.length) {
  if (t >= 8) {
    let n10 = an.add(t * 2), s10 = lt(e, 0).add(an), r10 = lt(e, t - 8), a10 = Lt(r10, 37).mul(n10).add(s10), i10 = Lt(s10, 25).add(r10).mul(n10);
    return ur(a10, i10, n10);
  }
  if (t >= 4) {
    let n10 = an.add(t * 2), s10 = tx(e, 0);
    return ur(s10.shl(3).add(t), tx(e, t - 4), n10);
  }
  if (t > 0) {
    let n10 = e[0], s10 = e[t >> 1], r10 = e[t - 1], a10 = n10 + (s10 << 8), i10 = t + (r10 << 2);
    return Zf(an.mul(a10).xor(Xw.mul(i10))).mul(an);
  }
  return an;
}
function T$(e, t = e.length) {
  let n10 = an.add(t * 2), s10 = lt(e, 0).mul(Ur), r10 = lt(e, 8), a10 = lt(e, t - 8).mul(n10), i10 = lt(e, t - 16).mul(an);
  return ur(Lt(s10.add(r10), 43).add(Lt(a10, 30)).add(i10), s10.add(Lt(r10.add(an), 18)).add(a10), n10);
}
function $$(e, t = e.length) {
  let n10 = an.add(t * 2), s10 = lt(e, 0).mul(an), r10 = lt(e, 8), a10 = lt(e, t - 8).mul(n10), i10 = lt(e, t - 16).mul(an), o10 = Lt(s10.add(r10), 43).add(Lt(a10, 30)).add(i10), u10 = ur(o10, s10.add(Lt(r10.add(an), 18)).add(a10), n10), l10 = lt(e, 16).mul(n10), c10 = lt(e, 24), p10 = o10.add(lt(e, t - 32)).mul(n10), d10 = u10.add(lt(e, t - 24)).mul(n10);
  return ur(Lt(l10.add(c10), 43).add(Lt(p10, 30)).add(d10), l10.add(Lt(c10.add(s10), 18)).add(p10), n10);
}
function _$(e, t = e.length) {
  let n10 = Gr.fromNumber(81, true);
  if (t <= 32)
    return t <= 16 ? N$(e, t) : T$(e, t);
  if (t <= 64)
    return $$(e, t);
  let s10 = n10, r10 = n10.mul(Ur).add(113), a10 = Zf(r10.mul(an).add(113)).mul(an), i10 = [Gr.UZERO, Gr.UZERO], o10 = [Gr.UZERO, Gr.UZERO];
  s10 = s10.mul(an).add(lt(e, 0));
  let u10 = 0, l10 = (t - 1 >> 6) * 64, c10 = l10 + (t - 1 & 63) - 63;
  do
    s10 = Lt(s10.add(r10).add(i10[0]).add(lt(e, u10 + 8)), 37).mul(Ur), r10 = Lt(r10.add(i10[1]).add(lt(e, u10 + 48)), 42).mul(Ur), s10 = s10.xor(o10[1]), r10 = r10.add(i10[0]).add(lt(e, u10 + 40)), a10 = Lt(a10.add(o10[0]), 33).mul(Ur), i10 = Bc(e, u10, i10[1].mul(Ur), s10.add(o10[0])), o10 = Bc(e, u10 + 32, a10.add(o10[1]), r10.add(lt(e, u10 + 16))), [a10, s10] = [s10, a10], u10 += 64;
  while (u10 !== l10);
  let p10 = Ur.add(a10.and(255).shl(1));
  return u10 = c10, o10[0] = o10[0].add(t - 1 & 63), i10[0] = i10[0].add(o10[0]), o10[0] = o10[0].add(i10[0]), s10 = Lt(s10.add(r10).add(i10[0]).add(lt(e, u10 + 8)), 37).mul(p10), r10 = Lt(r10.add(i10[1]).add(lt(e, u10 + 48)), 42).mul(p10), s10 = s10.xor(o10[1].mul(9)), r10 = r10.add(i10[0].mul(9).add(lt(e, u10 + 40))), a10 = Lt(a10.add(o10[0]), 33).mul(p10), i10 = Bc(e, u10, i10[1].mul(p10), s10.add(o10[0])), o10 = Bc(e, u10 + 32, a10.add(o10[1]), r10.add(lt(e, u10 + 16))), [a10, s10] = [s10, a10], ur(ur(i10[0], o10[0], p10).add(Zf(r10).mul(Xw)).add(a10), ur(i10[1], o10[1], p10).add(s10), p10);
}
function A$(e, t) {
  return t === "string" ? El(e) : up([e], t);
}
function E$(e, t) {
  return e instanceof Float32Array && t === "float32" || e instanceof Int32Array && t === "int32" || e instanceof Uint8Array && t === "bool";
}
function up(e, t) {
  if (t === "string")
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e) && (e = ta(e)), X2().getBool("DEBUG") && Vw(e, t), E$(e, t))
    return e;
  if (t == null || t === "float32" || t === "complex64")
    return new Float32Array(e);
  if (t === "int32")
    return new Int32Array(e);
  if (t === "bool") {
    let n10 = new Uint8Array(e.length);
    for (let s10 = 0; s10 < n10.length; ++s10)
      Math.round(e[s10]) !== 0 && (n10[s10] = 1);
    return n10;
  } else
    throw new Error(`Unknown data type ${t}`);
}
function Wu() {
  return X2().platform.now();
}
function R$(e, t) {
  return X2().platform.fetch(e, t);
}
function El(e, t = "utf-8") {
  return t = t || "utf-8", X2().platform.encode(e, t);
}
function fd(e, t = "utf-8") {
  return t = t || "utf-8", X2().platform.decode(e, t);
}
var D$ = class {
  constructor(e, t) {
    this.backendTimer = e, this.logger = t, t == null && (this.logger = new O$());
  }
  profileKernel(e, t, n10) {
    let s10, r10 = () => {
      s10 = n10();
    }, a10, i10 = Wu();
    if (this.backendTimer.timerAvailable())
      a10 = this.backendTimer.time(r10);
    else {
      r10();
      for (let u10 of s10)
        u10.dataSync();
      a10 = Promise.resolve({ kernelMs: Wu() - i10 });
    }
    if (X2().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
      for (let u10 = 0; u10 < s10.length; u10++) {
        let l10 = s10[u10];
        l10.data().then((c10) => {
          F$(c10, l10.dtype, e);
        });
      }
    return { kernelName: e, outputs: s10, inputs: t, timeMs: a10.then((u10) => u10.kernelMs), extraInfo: a10.then((u10) => u10.getExtraProfileInfo != null ? u10.getExtraProfileInfo() : "") };
  }
  logKernelProfile(e) {
    let { kernelName: t, outputs: n10, timeMs: s10, inputs: r10, extraInfo: a10 } = e;
    n10.forEach((i10) => {
      Promise.all([i10.data(), s10, a10]).then((o10) => {
        this.logger.logKernelProfile(t, i10, o10[0], o10[1], r10, o10[2]);
      });
    });
  }
};
function F$(e, t, n10) {
  if (t !== "float32")
    return false;
  for (let s10 = 0; s10 < e.length; s10++) {
    let r10 = e[s10];
    if (isNaN(r10) || !isFinite(r10))
      return console.warn(`Found ${r10} in the result of '${n10}'`), true;
  }
  return false;
}
var O$ = class {
  logKernelProfile(e, t, n10, s10, r10, a10) {
    let i10 = typeof s10 == "number" ? Pu(`${s10}ms`, 9) : s10.error, o10 = Pu(e, 25), u10 = t.rank, l10 = t.size, c10 = Pu(t.shape.toString(), 14), p10 = "";
    for (let d10 in r10) {
      let h10 = r10[d10];
      if (h10 != null) {
        let f10 = h10.shape || t.shape, m10 = f10.length;
        p10 += `${d10}: ${m10}D ${m10 > 0 ? f10 : ""} `;
      }
    }
    console.log(`%c${o10}	%c${i10}	%c${u10}D ${c10}	%c${l10}	%c${p10}	%c${a10}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
};
function P$(e, t, n10) {
  let s10 = {}, r10 = {};
  for (let u10 = 0; u10 < t.length; u10++)
    s10[t[u10].id] = true;
  for (let u10 = 0; u10 < e.length; u10++) {
    let l10 = e[u10], c10 = l10.inputs;
    for (let p10 in c10) {
      let d10 = c10[p10], h10 = false;
      for (let f10 = 0; f10 < t.length; f10++)
        if (s10[d10.id]) {
          l10.outputs.forEach((m10) => s10[m10.id] = true), h10 = true, r10[l10.id] = true;
          break;
        }
      if (h10)
        break;
    }
  }
  let a10 = {};
  a10[n10.id] = true;
  let i10 = {};
  for (let u10 = e.length - 1; u10 >= 0; u10--) {
    let l10 = e[u10], c10 = l10.inputs;
    for (let p10 = 0; p10 < l10.outputs.length; p10++)
      if (a10[l10.outputs[p10].id]) {
        for (let d10 in c10)
          a10[c10[d10].id] = true, i10[l10.id] = true;
        break;
      }
  }
  let o10 = [];
  for (let u10 = 0; u10 < e.length; u10++) {
    let l10 = e[u10];
    if (r10[l10.id] && i10[l10.id]) {
      let c10 = {};
      for (let d10 in l10.inputs) {
        let h10 = l10.inputs[d10];
        s10[h10.id] && (c10[d10] = h10);
      }
      let p10 = Object.assign({}, l10);
      p10.inputs = c10, p10.outputs = l10.outputs, o10.push(p10);
    }
  }
  return o10;
}
function z$(e, t, n10, s10) {
  for (let r10 = t.length - 1; r10 >= 0; r10--) {
    let a10 = t[r10], i10 = [];
    if (a10.outputs.forEach((u10) => {
      let l10 = e[u10.id];
      l10 != null ? i10.push(l10) : i10.push(null);
    }), a10.gradient == null)
      throw new Error(`Cannot compute gradient: gradient function not found for ${a10.kernelName}.`);
    let o10 = a10.gradient(i10);
    for (let u10 in a10.inputs) {
      if (!(u10 in o10))
        throw new Error(`Cannot backprop through input ${u10}. Available gradients found: ${Object.keys(o10)}.`);
      let l10 = n10(() => o10[u10]());
      if (l10.dtype !== "float32")
        throw new Error(`Error in gradient for op ${a10.kernelName}. The gradient of input ${u10} must have 'float32' dtype, but has '${l10.dtype}'`);
      let c10 = a10.inputs[u10];
      if (!wr(l10.shape, c10.shape))
        throw new Error(`Error in gradient for op ${a10.kernelName}. The gradient of input '${u10}' has shape '${l10.shape}', which does not match the shape of the input '${c10.shape}'`);
      if (e[c10.id] == null)
        e[c10.id] = l10;
      else {
        let p10 = e[c10.id];
        e[c10.id] = s10(p10, l10), p10.dispose();
      }
    }
  }
}
var nx = 20;
var Iu = 3;
var Rf = 7;
function M$(e, t, n10, s10) {
  let r10 = ro(t), a10 = L$(e, t, n10, r10), i10 = t.length, o10 = Jc(e, t, n10, r10, a10), u10 = ["Tensor"];
  return s10 && (u10.push(`  dtype: ${n10}`), u10.push(`  rank: ${i10}`), u10.push(`  shape: [${t}]`), u10.push("  values:")), u10.push(o10.map((l10) => "    " + l10).join(`
`)), u10.join(`
`);
}
function L$(e, t, n10, s10) {
  let r10 = pt(t), a10 = s10[s10.length - 1], i10 = new Array(a10).fill(0), o10 = t.length, u10 = n10 === "complex64" ? $u(e) : e;
  if (o10 > 1)
    for (let l10 = 0; l10 < r10 / a10; l10++) {
      let c10 = l10 * a10;
      for (let p10 = 0; p10 < a10; p10++)
        i10[p10] = Math.max(i10[p10], Tu(u10[c10 + p10], 0, n10).length);
    }
  return i10;
}
function Tu(e, t, n10) {
  let s10;
  return Array.isArray(e) ? s10 = `${parseFloat(e[0].toFixed(Rf))} + ${parseFloat(e[1].toFixed(Rf))}j` : ir(e) ? s10 = `'${e}'` : n10 === "bool" ? s10 = Qw(e) : s10 = parseFloat(e.toFixed(Rf)).toString(), Pu(s10, t);
}
function Qw(e) {
  return e === 0 ? "false" : "true";
}
function Jc(e, t, n10, s10, r10, a10 = true) {
  let i10 = n10 === "complex64" ? 2 : 1, o10 = t[0], u10 = t.length;
  if (u10 === 0) {
    if (n10 === "complex64") {
      let m10 = $u(e);
      return [Tu(m10[0], 0, n10)];
    }
    return n10 === "bool" ? [Qw(e[0])] : [e[0].toString()];
  }
  if (u10 === 1) {
    if (o10 > nx) {
      let g10 = Iu * i10, b10 = Array.from(e.slice(0, g10)), y10 = Array.from(e.slice((o10 - Iu) * i10, o10 * i10));
      return n10 === "complex64" && (b10 = $u(b10), y10 = $u(y10)), ["[" + b10.map((v10, x10) => Tu(v10, r10[x10], n10)).join(", ") + ", ..., " + y10.map((v10, x10) => Tu(v10, r10[o10 - Iu + x10], n10)).join(", ") + "]"];
    }
    let m10 = n10 === "complex64" ? $u(e) : Array.from(e);
    return ["[" + m10.map((g10, b10) => Tu(g10, r10[b10], n10)).join(", ") + "]"];
  }
  let l10 = t.slice(1), c10 = s10.slice(1), p10 = s10[0] * i10, d10 = [];
  if (o10 > nx) {
    for (let m10 = 0; m10 < Iu; m10++) {
      let g10 = m10 * p10, b10 = g10 + p10;
      d10.push(...Jc(e.slice(g10, b10), l10, n10, c10, r10, false));
    }
    d10.push("...");
    for (let m10 = o10 - Iu; m10 < o10; m10++) {
      let g10 = m10 * p10, b10 = g10 + p10;
      d10.push(...Jc(e.slice(g10, b10), l10, n10, c10, r10, m10 === o10 - 1));
    }
  } else
    for (let m10 = 0; m10 < o10; m10++) {
      let g10 = m10 * p10, b10 = g10 + p10;
      d10.push(...Jc(e.slice(g10, b10), l10, n10, c10, r10, m10 === o10 - 1));
    }
  let h10 = u10 === 2 ? "," : "";
  d10[0] = "[" + d10[0] + h10;
  for (let m10 = 1; m10 < d10.length - 1; m10++)
    d10[m10] = " " + d10[m10] + h10;
  let f10 = `,
`;
  for (let m10 = 2; m10 < u10; m10++)
    f10 += `
`;
  return d10[d10.length - 1] = " " + d10[d10.length - 1] + "]" + (a10 ? "" : f10), d10;
}
function $u(e) {
  let t = [];
  for (let n10 = 0; n10 < e.length; n10 += 2)
    t.push([e[n10], e[n10 + 1]]);
  return t;
}
var Vt = class {
  constructor(e, t, n10) {
    if (this.dtype = t, this.shape = e.slice(), this.size = pt(e), n10 != null) {
      let s10 = n10.length;
      O2(s10 === this.size, () => `Length of values '${s10}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (t === "complex64")
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n10 || Bw(t, this.size), this.strides = ro(e);
  }
  set(e, ...t) {
    t.length === 0 && (t = [0]), O2(t.length === this.rank, () => `The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);
    let n10 = this.locToIndex(t);
    this.values[n10] = e;
  }
  get(...e) {
    e.length === 0 && (e = [0]);
    let t = 0;
    for (let s10 of e) {
      if (s10 < 0 || s10 >= this.shape[t]) {
        let r10 = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
        throw new Error(r10);
      }
      t++;
    }
    let n10 = e[e.length - 1];
    for (let s10 = 0; s10 < e.length - 1; ++s10)
      n10 += this.strides[s10] * e[s10];
    return this.values[n10];
  }
  locToIndex(e) {
    if (this.rank === 0)
      return 0;
    if (this.rank === 1)
      return e[0];
    let t = e[e.length - 1];
    for (let n10 = 0; n10 < e.length - 1; ++n10)
      t += this.strides[n10] * e[n10];
    return t;
  }
  indexToLoc(e) {
    if (this.rank === 0)
      return [];
    if (this.rank === 1)
      return [e];
    let t = new Array(this.shape.length);
    for (let n10 = 0; n10 < t.length - 1; ++n10)
      t[n10] = Math.floor(e / this.strides[n10]), e -= t[n10] * this.strides[n10];
    return t[t.length - 1] = e, t;
  }
  get rank() {
    return this.shape.length;
  }
  toTensor() {
    return us().makeTensor(this.values, this.shape, this.dtype);
  }
};
var us = null;
var Bi = null;
var B$ = null;
function V$(e) {
  us = e;
}
function W$(e) {
  Bi = e;
}
function U$(e) {
  B$ = e;
}
var et = class {
  constructor(e, t, n10, s10) {
    this.kept = false, this.isDisposedInternal = false, this.shape = e.slice(), this.dtype = t || "float32", this.size = pt(e), this.strides = ro(e), this.dataId = n10, this.id = s10, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  async buffer() {
    let e = await this.data();
    return Bi.buffer(this.shape, this.dtype, e);
  }
  bufferSync() {
    return Bi.buffer(this.shape, this.dtype, this.dataSync());
  }
  async array() {
    let e = await this.data();
    return Gi(this.shape, e, this.dtype === "complex64");
  }
  arraySync() {
    return Gi(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  async data() {
    this.throwIfDisposed();
    let e = us().read(this.dataId);
    if (this.dtype === "string") {
      let t = await e;
      try {
        return t.map((n10) => fd(n10));
      } catch (n10) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return e;
  }
  dataToGPU(e) {
    return this.throwIfDisposed(), us().readToGPU(this.dataId, e);
  }
  dataSync() {
    this.throwIfDisposed();
    let e = us().readSync(this.dataId);
    if (this.dtype === "string")
      try {
        return e.map((t) => fd(t));
      } catch (t) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return e;
  }
  async bytes() {
    this.throwIfDisposed();
    let e = await us().read(this.dataId);
    return this.dtype === "string" ? e : new Uint8Array(e.buffer);
  }
  dispose() {
    this.isDisposed || (us().disposeTensor(this), this.isDisposedInternal = true);
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }
  print(e = false) {
    return Bi.print(this, e);
  }
  clone() {
    return this.throwIfDisposed(), Bi.clone(this);
  }
  toString(e = false) {
    let t = this.dataSync();
    return M$(t, this.shape, this.dtype, e);
  }
  cast(e) {
    return this.throwIfDisposed(), Bi.cast(this, e);
  }
  variable(e = true, t, n10) {
    return this.throwIfDisposed(), us().makeVariable(this, e, t, n10);
  }
};
Object.defineProperty(et, Symbol.hasInstance, { value: (e) => !!e && e.data != null && e.dataSync != null && e.throwIfDisposed != null });
function G$() {
  return sg("Tensor", () => et);
}
G$();
var md = class extends et {
  constructor(e, t, n10, s10) {
    super(e.shape, e.dtype, e.dataId, s10);
    this.trainable = t, this.name = n10;
  }
  assign(e) {
    if (e.dtype !== this.dtype)
      throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
    if (!wr(e.shape, this.shape))
      throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
    us().disposeTensor(this), this.dataId = e.dataId, us().incRef(this, null);
  }
  dispose() {
    us().disposeVariable(this), this.isDisposedInternal = true;
  }
};
Object.defineProperty(md, Symbol.hasInstance, { value: (e) => e instanceof et && e.assign != null && e.assign instanceof Function });
var _s = {};
Ae(_s, { assertTypesMatch: () => nk, getTensorsInContainer: () => Ag, isTensorInList: () => j$, makeTypesMatch: () => vt });
var H$ = ((e) => (e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6", e))(H$ || {});
var Zw = ((e) => (e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64", e))(Zw || {});
var Jw = ((e) => (e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64", e))(Jw || {});
var ek = ((e) => (e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64", e))(ek || {});
var tk = ((e) => (e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64", e))(tk || {});
var q$ = { float32: ek, int32: Zw, bool: Jw, complex64: tk };
function yn(e, t) {
  if (e === "string" || t === "string") {
    if (e === "string" && t === "string")
      return "string";
    throw new Error(`Can not upcast ${e} with ${t}`);
  }
  return q$[e][t];
}
function lp(e) {
  return yn(e, "int32");
}
function vt(e, t) {
  if (e.dtype === t.dtype)
    return [e, t];
  let n10 = yn(e.dtype, t.dtype);
  return [e.cast(n10), t.cast(n10)];
}
function nk(e, t) {
  O2(e.dtype === t.dtype, () => `The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`);
}
function j$(e, t) {
  return t.some((n10) => n10.id === e.id);
}
function Ag(e) {
  let t = [];
  return sk(e, t, /* @__PURE__ */ new Set()), t;
}
function sk(e, t, n10) {
  if (e == null)
    return;
  if (e instanceof et) {
    t.push(e);
    return;
  }
  if (!K$(e))
    return;
  let s10 = e;
  for (let r10 in s10) {
    let a10 = s10[r10];
    n10.has(a10) || (n10.add(a10), sk(a10, t, n10));
  }
}
function K$(e) {
  return Array.isArray(e) || typeof e == "object";
}
function Df(e) {
  return e.kernelName != null;
}
var sx = class {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null, get kernelNames() {
      return Array.from(new Set(this.kernels.map((e) => e.name)));
    } };
  }
  dispose() {
    for (let e in this.registeredVariables)
      this.registeredVariables[e].dispose();
  }
};
var Jf = class {
  constructor(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new sx();
  }
  async ready() {
    if (this.pendingBackendInit != null)
      return this.pendingBackendInit.then(() => {
      });
    if (this.backendInstance != null)
      return;
    let e = this.getSortedBackends();
    for (let t = 0; t < e.length; t++) {
      let n10 = e[t];
      if (await this.initializeBackend(n10).success) {
        await this.setBackend(n10);
        return;
      }
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  get backend() {
    if (this.pendingBackendInit != null)
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    if (this.backendInstance == null) {
      let { name: e, asyncInit: t } = this.initializeBackendsAndReturnBest();
      if (t)
        throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      this.setBackend(e);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(e) {
    if (!(e in this.registry))
      if (e in this.registryFactory) {
        let { asyncInit: t } = this.initializeBackend(e);
        if (t)
          return null;
      } else
        return null;
    return this.registry[e];
  }
  findBackendFactory(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }
  registerBackend(e, t, n10 = 1) {
    return e in this.registryFactory ? (ar(`${e} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[e] = { factory: t, priority: n10 }, true);
  }
  async setBackend(e) {
    if (this.registryFactory[e] == null)
      throw new Error(`Backend name '${e}' not found in registry`);
    if (this.backendName = e, this.registry[e] == null) {
      this.backendInstance = null;
      let { success: t, asyncInit: n10 } = this.initializeBackend(e);
      if (!(n10 ? await t : t))
        return false;
    }
    return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new D$(this.backendInstance), true;
  }
  setupRegisteredKernels() {
    Qf(this.backendName).forEach((t) => {
      t.setupFunc != null && t.setupFunc(this.backendInstance);
    });
  }
  disposeRegisteredKernels(e) {
    Qf(e).forEach((n10) => {
      n10.disposeFunc != null && n10.disposeFunc(this.registry[e]);
    });
  }
  initializeBackend(e) {
    let t = this.registryFactory[e];
    if (t == null)
      throw new Error(`Cannot initialize backend ${e}, no registration found.`);
    try {
      let n10 = t.factory();
      if (n10 && !(n10 instanceof tl) && typeof n10.then == "function") {
        let s10 = ++this.pendingBackendInitId, r10 = n10.then((a10) => s10 < this.pendingBackendInitId ? false : (this.registry[e] = a10, this.pendingBackendInit = null, true)).catch((a10) => (s10 < this.pendingBackendInitId || (this.pendingBackendInit = null, ar(`Initialization of backend ${e} failed`), ar(a10.stack || a10.message)), false));
        return this.pendingBackendInit = r10, { success: r10, asyncInit: true };
      } else
        return this.registry[e] = n10, { success: true, asyncInit: false };
    } catch (n10) {
      return ar(`Initialization of backend ${e} failed`), ar(n10.stack || n10.message), { success: false, asyncInit: false };
    }
  }
  removeBackend(e) {
    if (!(e in this.registryFactory))
      throw new Error(`${e} backend not found in registry`);
    this.backendName === e && this.pendingBackendInit != null && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority);
  }
  initializeBackendsAndReturnBest() {
    let e = this.getSortedBackends();
    for (let t = 0; t < e.length; t++) {
      let n10 = e[t], { success: s10, asyncInit: r10 } = this.initializeBackend(n10);
      if (r10 || s10)
        return { name: n10, asyncInit: r10 };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  moveData(e, t) {
    let n10 = this.state.tensorInfo.get(t), s10 = n10.backend, r10 = this.readSync(t), a10 = s10.refCount(t);
    s10.disposeData(t, true), n10.backend = e, e.move(t, r10, n10.shape, n10.dtype, a10), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }
  tidy(e, t) {
    let n10 = null;
    if (t == null) {
      if (typeof e != "function")
        throw new Error("Please provide a function to tidy()");
      t = e;
    } else {
      if (typeof e != "string" && !(e instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof t != "function")
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      n10 = e;
    }
    let s10;
    return this.scopedRun(() => this.startScope(n10), () => this.endScope(s10), () => (s10 = t(), s10 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), s10));
  }
  scopedRun(e, t, n10) {
    e();
    try {
      let s10 = n10();
      return t(), s10;
    } catch (s10) {
      throw t(), s10;
    }
  }
  nextTensorId() {
    return Jf.nextTensorId++;
  }
  nextVariableId() {
    return Jf.nextVariableId++;
  }
  clone(e) {
    let t = M2.runKernel(Ma, { x: e }), n10 = { x: e }, s10 = (a10) => ({ x: () => {
      let i10 = "float32", o10 = { x: a10 }, u10 = { dtype: i10 };
      return M2.runKernel(Sa, o10, u10);
    } }), r10 = [];
    return this.addTapeNode(this.state.activeScope.name, n10, [t], s10, r10, {}), t;
  }
  runKernel(e, t, n10) {
    if (this.backendName == null && this.backend, !(Yf(e, this.backendName) != null))
      throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
    return this.runKernelFunc({ kernelName: e, inputs: t, attrs: n10 });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(e, t, n10) {
    let s10 = this.backend.numDataIds(), r10 = 0;
    n10.forEach((o10) => {
      r10 += o10.dtype === "complex64" ? 3 : 1;
    });
    let a10 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i10 = s10 - t - r10 - a10;
    if (i10 > 0)
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i10} data ids) after running '${e}'`);
  }
  runKernelFunc(e) {
    let t, n10 = [], s10 = this.isTapeOn(), r10 = this.state.numBytes, a10 = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    let i10;
    this.backendName == null && this.backend;
    let o10, u10 = Df(e) ? e.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (Df(e)) {
      let { kernelName: h10, inputs: f10, attrs: m10 } = e;
      this.backendName == null && this.backend;
      let g10 = Yf(h10, this.backendName);
      O2(g10 != null, () => `Cannot find registered kernel '${h10}' for backend '${this.backendName}'`), i10 = () => {
        let b10 = this.backend.numDataIds();
        o10 = g10.kernelFunc({ inputs: f10, attrs: m10, backend: this.backend });
        let y10 = Array.isArray(o10) ? o10 : [o10];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(h10, b10, y10);
        let v10 = y10.map((x10) => {
          if (x10.rank != null)
            return x10;
          let { dataId: k10, shape: C10, dtype: T10 } = x10;
          return this.makeTensorFromDataId(k10, C10, T10);
        });
        if (s10) {
          let x10 = this.getTensorsForGradient(h10, f10, v10);
          n10 = this.saveTensorsForBackwardMode(x10);
        }
        return v10;
      };
    } else {
      let { forwardFunc: h10 } = e, f10 = (m10) => {
        !s10 || (n10 = m10.map((g10) => this.keep(this.clone(g10))));
      };
      i10 = () => {
        let m10 = this.backend.numDataIds();
        o10 = this.tidy(() => h10(this.backend, f10));
        let g10 = Array.isArray(o10) ? o10 : [o10];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u10, m10, g10), g10;
      };
    }
    let { inputs: l10, attrs: c10 } = e, p10 = Df(e) ? null : e.backwardsFunc, d10;
    return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      !this.ENV.getBool("DEBUG") && !this.state.profiling ? t = i10() : (d10 = this.profiler.profileKernel(u10, l10, () => i10()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(d10), t = d10.outputs);
    }), s10 && this.addTapeNode(u10, l10, t, p10, n10, c10), this.state.profiling && this.state.activeProfile.kernels.push({ name: u10, bytesAdded: this.state.numBytes - r10, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - a10, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(l10).map((h10) => l10[h10] != null ? l10[h10].shape : null), outputShapes: t.map((h10) => h10.shape), kernelTimeMs: d10.timeMs, extraInfo: d10.extraInfo }), Array.isArray(o10) ? t : t[0];
  }
  saveTensorsForBackwardMode(e) {
    return e.map((n10) => this.keep(this.clone(n10)));
  }
  getTensorsForGradient(e, t, n10) {
    let s10 = Jv(e);
    if (s10 != null) {
      let r10 = s10.inputsToSave || [], a10 = s10.outputsToSave || [], i10;
      s10.saveAllInputs ? (O2(Array.isArray(t), () => "saveAllInputs is true, expected inputs to be an array."), i10 = Object.keys(t).map((u10) => t[u10])) : i10 = r10.map((u10) => t[u10]);
      let o10 = n10.filter((u10, l10) => a10[l10]);
      return i10.concat(o10);
    }
    return [];
  }
  makeTensor(e, t, n10, s10) {
    if (e == null)
      throw new Error("Values passed to engine.makeTensor() are null");
    n10 = n10 || "float32", s10 = s10 || this.backend;
    let r10 = e;
    n10 === "string" && ir(e[0]) && (r10 = e.map((o10) => El(o10)));
    let a10 = s10.write(r10, t, n10), i10 = new et(t, n10, a10, this.nextTensorId());
    if (this.trackTensor(i10, s10), n10 === "string") {
      let o10 = this.state.tensorInfo.get(a10), u10 = Uw(r10);
      this.state.numBytes += u10 - o10.bytes, o10.bytes = u10;
    }
    return i10;
  }
  makeTensorFromDataId(e, t, n10, s10) {
    n10 = n10 || "float32";
    let r10 = new et(t, n10, e, this.nextTensorId());
    return this.trackTensor(r10, s10), r10;
  }
  makeVariable(e, t = true, n10, s10) {
    n10 = n10 || this.nextVariableId().toString(), s10 != null && s10 !== e.dtype && (e = e.cast(s10));
    let r10 = new md(e, t, n10, this.nextTensorId());
    if (this.state.registeredVariables[r10.name] != null)
      throw new Error(`Variable with name ${r10.name} was already registered`);
    return this.state.registeredVariables[r10.name] = r10, this.incRef(r10, this.backend), r10;
  }
  trackTensor(e, t) {
    this.state.numTensors++, e.dtype === "string" && this.state.numStringTensors++;
    let n10 = 0;
    e.dtype !== "complex64" && e.dtype !== "string" && (n10 = e.size * jf(e.dtype)), this.state.numBytes += n10, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, { backend: t || this.backend, dtype: e.dtype, shape: e.shape, bytes: n10 })), e instanceof md || this.track(e);
  }
  incRef(e, t) {
    this.trackTensor(e, t), this.backend.incRef(e.dataId);
  }
  removeDataId(e, t) {
    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
  }
  disposeTensor(e) {
    if (!this.state.tensorInfo.has(e.dataId))
      return;
    let t = this.state.tensorInfo.get(e.dataId);
    if (this.state.numTensors--, e.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), e.dtype !== "complex64" && e.dtype !== "string") {
      let n10 = e.size * jf(e.dtype);
      this.state.numBytes -= n10;
    }
    t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
  }
  disposeVariables() {
    for (let e in this.state.registeredVariables) {
      let t = this.state.registeredVariables[e];
      this.disposeVariable(t);
    }
  }
  disposeVariable(e) {
    this.disposeTensor(e), this.state.registeredVariables[e.name] != null && delete this.state.registeredVariables[e.name];
  }
  memory() {
    let e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = true, e.reasons == null && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }
  async profile(e) {
    this.state.profiling = true;
    let t = this.state.numBytes, n10 = this.state.numTensors;
    this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((s10) => s10.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - n10;
    for (let s10 of this.state.activeProfile.kernels)
      s10.kernelTimeMs = await s10.kernelTimeMs, s10.extraInfo = await s10.extraInfo;
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(e, t, n10, s10, r10, a10) {
    let i10 = { id: this.state.nextTapeNodeId++, kernelName: e, inputs: t, outputs: n10, saved: r10 }, o10 = Jv(e);
    o10 != null && (s10 = o10.gradFunc), s10 != null && (i10.gradient = (u10) => (u10 = u10.map((l10, c10) => {
      if (l10 == null) {
        let p10 = n10[c10], d10 = Gd(p10.size, p10.dtype);
        return this.makeTensor(d10, p10.shape, p10.dtype);
      }
      return l10;
    }), s10(u10.length > 1 ? u10 : u10[0], r10, a10))), this.state.activeTape.push(i10);
  }
  keep(e) {
    return e.kept = true, e;
  }
  startTape() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  startScope(e) {
    let t = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
    e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
  }
  endScope(e) {
    let t = Ag(e), n10 = new Set(t.map((r10) => r10.id));
    for (let r10 = 0; r10 < this.state.activeScope.track.length; r10++) {
      let a10 = this.state.activeScope.track[r10];
      !a10.kept && !n10.has(a10.id) && a10.dispose();
    }
    let s10 = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach((r10) => {
      !r10.kept && r10.scopeId === s10.id && this.track(r10);
    });
  }
  gradients(e, t, n10, s10 = false) {
    if (O2(t.length > 0, () => "gradients() received an empty list of xs."), n10 != null && n10.dtype !== "float32")
      throw new Error(`dy must have 'float32' dtype, but has '${n10.dtype}'`);
    let r10 = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
    O2(r10 instanceof et, () => "The result y returned by f() must be a tensor.");
    let a10 = P$(this.state.activeTape, t, r10);
    if (!s10 && a10.length === 0 && t.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      let i10 = {};
      i10[r10.id] = n10 == null ? X$(r10.shape) : n10, z$(i10, a10, (u10) => this.tidy(u10), Y$);
      let o10 = t.map((u10) => i10[u10.id]);
      return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((u10) => {
        for (let l10 of u10.saved)
          l10.dispose();
      }), this.state.activeTape = null), { value: r10, grads: o10 };
    });
  }
  customGrad(e) {
    return O2(hr(e), () => "The f passed in customGrad(f) must be a function."), (...t) => {
      O2(t.every((i10) => i10 instanceof et), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let n10, s10 = {};
      t.forEach((i10, o10) => {
        s10[o10] = i10;
      });
      let r10 = (i10, o10) => (n10 = e(...t, o10), O2(n10.value instanceof et, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), O2(hr(n10.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), n10.value), a10 = (i10, o10) => {
        let u10 = n10.gradFunc(i10, o10), l10 = Array.isArray(u10) ? u10 : [u10];
        O2(l10.length === t.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), O2(l10.every((p10) => p10 instanceof et), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        let c10 = {};
        return l10.forEach((p10, d10) => {
          c10[d10] = () => p10;
        }), c10;
      };
      return this.runKernelFunc({ forwardFunc: r10, backwardsFunc: a10, inputs: s10 });
    };
  }
  readSync(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }
  read(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }
  readToGPU(e, t) {
    return this.state.tensorInfo.get(e).backend.readToGPU(e, t);
  }
  async time(e) {
    let t = Wu(), n10 = await this.backend.time(e);
    return n10.wallMs = Wu() - t, n10;
  }
  track(e) {
    return this.state.activeScope != null && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new sx();
    for (let e in this.registry)
      this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }
};
var Eg = Jf;
Eg.nextTensorId = 0;
Eg.nextVariableId = 0;
function X$(e) {
  let t = eg(pt(e), "float32");
  return M2.makeTensor(t, e, "float32");
}
function rk() {
  let e = Kw();
  if (e._tfengine == null) {
    let t = new m$(e);
    e._tfengine = new Eg(t);
  }
  return v$(e._tfengine.ENV), V$(() => e._tfengine), e._tfengine;
}
var M2 = rk();
function Y$(e, t) {
  let n10 = { a: e, b: t };
  return M2.runKernel(kr, n10);
}
var cp = {};
Ae(cp, { isBrowser: () => ak, isMobile: () => J$, mockIsMobile: () => Z$ });
function Q$() {
  return typeof navigator != "undefined" && navigator != null;
}
var em;
function Z$(e) {
  em = e;
}
function J$(e) {
  if (em !== void 0)
    return em;
  if (e || Q$()) {
    if (e || (e = navigator), e.product === "ReactNative")
      return true;
    let t = e.userAgent || e.vendor || (typeof window != "undefined" ? window.opera : "");
    if (!t) {
      let n10 = e;
      return n10.userAgentData && n10.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
  }
  return false;
}
function ak() {
  return typeof window != "undefined" && window.document != null || typeof WorkerGlobalScope != "undefined";
}
var gs = X2();
gs.registerFlag("DEBUG", () => false, (e) => {
  e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
});
gs.registerFlag("IS_BROWSER", () => ak());
gs.registerFlag("IS_NODE", () => typeof process != "undefined" && typeof process.versions != "undefined" && typeof process.versions.node != "undefined");
gs.registerFlag("IS_CHROME", () => typeof navigator != "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
gs.registerFlag("PROD", () => false);
gs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => gs.getBool("DEBUG"));
gs.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
gs.registerFlag("IS_TEST", () => false);
gs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
gs.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
function Rs(e, t) {
  let n10 = e;
  if (Yt(e))
    return t === "string" ? [] : [e.length];
  if (!Array.isArray(e))
    return [];
  let s10 = [];
  for (; Array.isArray(n10) || Yt(n10) && t !== "string"; )
    s10.push(n10.length), n10 = n10[0];
  return Array.isArray(e) && X2().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && ik(e, s10, []), s10;
}
function ik(e, t, n10) {
  if (n10 = n10 || [], !Array.isArray(e) && !Yt(e)) {
    O2(t.length === 0, () => `Element arr[${n10.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);
    return;
  }
  O2(t.length > 0, () => `Element arr[${n10.join("][")}] should be a primitive, but is an array of ${e.length} elements`), O2(e.length === t[0], () => `Element arr[${n10.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);
  let s10 = t.slice(1);
  for (let r10 = 0; r10 < e.length; ++r10)
    ik(e[r10], s10, n10.concat(r10));
}
function rx(e, t, n10, s10) {
  if (e !== "string_or_numeric") {
    if (e == null)
      throw new Error("Expected dtype cannot be null.");
    if (e !== "numeric" && e !== t || e === "numeric" && t === "string")
      throw new Error(`Argument '${n10}' passed to '${s10}' must be ${e} tensor, but got ${t} tensor`);
  }
}
function _2(e, t, n10, s10 = "numeric") {
  if (e instanceof et)
    return rx(s10, e.dtype, t, n10), e;
  let r10 = Ud(e);
  if (r10 !== "string" && ["bool", "int32", "float32"].indexOf(s10) >= 0 && (r10 = s10), rx(s10, r10, t, n10), e == null || !Yt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") {
    let u10 = e == null ? "null" : e.constructor.name;
    throw new Error(`Argument '${t}' passed to '${n10}' must be a Tensor or TensorLike, but got '${u10}'`);
  }
  let a10 = Rs(e, r10);
  !Yt(e) && !Array.isArray(e) && (e = [e]);
  let o10 = r10 !== "string" ? up(e, r10) : ta(e, [], true);
  return M2.makeTensor(o10, a10, r10);
}
function Uu(e, t, n10, s10 = "numeric") {
  if (!Array.isArray(e))
    throw new Error(`Argument ${t} passed to ${n10} must be a \`Tensor[]\` or \`TensorLike[]\``);
  return e.map((a10, i10) => _2(a10, `${t}[${i10}]`, n10, s10));
}
var e_ = "__op";
function L2(e) {
  let t = Object.keys(e);
  if (t.length !== 1)
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
  let n10 = t[0], s10 = e[n10];
  n10.endsWith("_") && (n10 = n10.substring(0, n10.length - 1)), n10 = n10 + e_;
  let r10 = (...a10) => {
    M2.startScope(n10);
    try {
      let i10 = s10(...a10);
      return ng(i10) && console.error("Cannot return a Promise inside of tidy."), M2.endScope(i10), i10;
    } catch (i10) {
      throw M2.endScope(null), i10;
    }
  };
  return Object.defineProperty(r10, "name", { value: n10, configurable: true }), r10;
}
function t_(e, t) {
  let n10 = _2(e, "real", "complex"), s10 = _2(t, "imag", "complex");
  dn(n10.shape, s10.shape, `real and imag shapes, ${n10.shape} and ${s10.shape}, must match in call to tf.complex().`);
  let r10 = { real: n10, imag: s10 };
  return M2.runKernel(qd, r10);
}
var aa = L2({ complex_: t_ });
function Cr(e, t, n10, s10) {
  if (s10 == null && (s10 = Ud(e)), s10 === "complex64")
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!Yt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string")
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (t != null) {
    tg(t);
    let r10 = pt(t), a10 = pt(n10);
    O2(r10 === a10, () => `Based on the provided shape, [${t}], the tensor should have ${r10} values but has ${a10}`);
    for (let i10 = 0; i10 < n10.length; ++i10) {
      let o10 = n10[i10], u10 = i10 === n10.length - 1 ? o10 !== pt(t.slice(i10)) : true;
      O2(n10[i10] === t[i10] || !u10, () => `Error creating a new Tensor. Inferred shape (${n10}) does not match the provided shape (${t}). `);
    }
  }
  return !Yt(e) && !Array.isArray(e) && (e = [e]), t = t || n10, e = s10 !== "string" ? up(e, s10) : ta(e, [], true), M2.makeTensor(e, t, s10);
}
function hs(e, t, n10) {
  let s10 = Rs(e, n10);
  return Cr(e, t, s10, n10);
}
var tm = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 };
var gd = 4;
async function n_(e, t) {
  let n10 = [], s10 = [], r10 = Array.isArray(e) ? e.map((i10) => i10.name) : Object.keys(e);
  for (let i10 = 0; i10 < r10.length; ++i10) {
    let o10 = r10[i10], u10 = Array.isArray(e) ? e[i10].tensor : e[o10];
    if (u10.dtype !== "float32" && u10.dtype !== "int32" && u10.dtype !== "bool" && u10.dtype !== "string" && u10.dtype !== "complex64")
      throw new Error(`Unsupported dtype in weight '${o10}': ${u10.dtype}`);
    let l10 = { name: o10, shape: u10.shape, dtype: u10.dtype };
    if (u10.dtype === "string") {
      let c10 = new Promise(async (p10) => {
        let d10 = await u10.bytes(), h10 = d10.reduce((g10, b10) => g10 + b10.length, 0) + gd * d10.length, f10 = new Uint8Array(h10), m10 = 0;
        for (let g10 = 0; g10 < d10.length; g10++) {
          let b10 = d10[g10], y10 = new Uint8Array(new Uint32Array([b10.length]).buffer);
          f10.set(y10, m10), m10 += gd, f10.set(b10, m10), m10 += b10.length;
        }
        p10(f10);
      });
      s10.push(c10);
    } else
      s10.push(u10.data());
    t != null && (l10.group = t), n10.push(l10);
  }
  let a10 = await Promise.all(s10);
  return { data: s_(a10), specs: n10 };
}
function ok(e, t) {
  let n10 = {}, s10, r10 = 0;
  for (let a10 of t) {
    let i10 = a10.name, o10 = a10.dtype, u10 = a10.shape, l10 = pt(u10), c10;
    if ("quantization" in a10) {
      let p10 = a10.quantization;
      if (p10.dtype === "uint8" || p10.dtype === "uint16") {
        if (!("min" in p10 && "scale" in p10))
          throw new Error(`Weight ${a10.name} with quantization ${p10.dtype} doesn't have corresponding metadata min and scale.`);
      } else if (p10.dtype === "float16") {
        if (o10 !== "float32")
          throw new Error(`Weight ${a10.name} is quantized with ${p10.dtype} which only supports weights of type float32 not ${o10}.`);
      } else
        throw new Error(`Weight ${a10.name} has unknown quantization dtype ${p10.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      let d10 = tm[p10.dtype], h10 = e.slice(r10, r10 + l10 * d10), f10 = p10.dtype === "uint8" ? new Uint8Array(h10) : new Uint16Array(h10);
      if (o10 === "float32")
        if (p10.dtype === "uint8" || p10.dtype === "uint16") {
          c10 = new Float32Array(f10.length);
          for (let m10 = 0; m10 < f10.length; m10++) {
            let g10 = f10[m10];
            c10[m10] = g10 * p10.scale + p10.min;
          }
        } else if (p10.dtype === "float16")
          s10 === void 0 && (s10 = l_()), c10 = s10(f10);
        else
          throw new Error(`Unsupported quantization type ${p10.dtype} for weight type float32.`);
      else if (o10 === "int32") {
        if (p10.dtype !== "uint8" && p10.dtype !== "uint16")
          throw new Error(`Unsupported quantization type ${p10.dtype} for weight type int32.`);
        c10 = new Int32Array(f10.length);
        for (let m10 = 0; m10 < f10.length; m10++) {
          let g10 = f10[m10];
          c10[m10] = Math.round(g10 * p10.scale + p10.min);
        }
      } else
        throw new Error(`Unsupported dtype in weight '${i10}': ${o10}`);
      r10 += l10 * d10;
    } else if (o10 === "string") {
      let p10 = pt(a10.shape);
      c10 = [];
      for (let d10 = 0; d10 < p10; d10++) {
        let h10 = new Uint32Array(e.slice(r10, r10 + gd))[0];
        r10 += gd;
        let f10 = new Uint8Array(e.slice(r10, r10 + h10));
        c10.push(f10), r10 += h10;
      }
    } else {
      let p10 = tm[o10], d10 = e.slice(r10, r10 + l10 * p10);
      if (o10 === "float32")
        c10 = new Float32Array(d10);
      else if (o10 === "int32")
        c10 = new Int32Array(d10);
      else if (o10 === "bool")
        c10 = new Uint8Array(d10);
      else if (o10 === "complex64") {
        c10 = new Float32Array(d10);
        let h10 = new Float32Array(c10.length / 2), f10 = new Float32Array(c10.length / 2);
        for (let b10 = 0; b10 < h10.length; b10++)
          h10[b10] = c10[b10 * 2], f10[b10] = c10[b10 * 2 + 1];
        let m10 = hs(h10, u10, "float32"), g10 = hs(f10, u10, "float32");
        n10[i10] = aa(m10, g10), m10.dispose(), g10.dispose();
      } else
        throw new Error(`Unsupported dtype in weight '${i10}': ${o10}`);
      r10 += l10 * p10;
    }
    o10 !== "complex64" && (n10[i10] = hs(c10, u10, o10));
  }
  return n10;
}
function s_(e) {
  if (e === null)
    throw new Error(`Invalid input value: ${JSON.stringify(e)}`);
  let t = 0, n10 = [];
  e.forEach((a10) => {
    if (t += a10.byteLength, n10.push(a10.byteLength === a10.buffer.byteLength ? a10 : new a10.constructor(a10)), !(a10 instanceof Float32Array || a10 instanceof Int32Array || a10 instanceof Uint8Array))
      throw new Error(`Unsupported TypedArray subtype: ${a10.constructor.name}`);
  });
  let s10 = new Uint8Array(t), r10 = 0;
  return n10.forEach((a10) => {
    s10.set(new Uint8Array(a10.buffer), r10), r10 += a10.byteLength;
  }), s10.buffer;
}
var Rg = typeof Buffer != "undefined" && (typeof Blob == "undefined" || typeof atob == "undefined" || typeof btoa == "undefined");
function ax(e) {
  return Rg ? Buffer.byteLength(e) : new Blob([e]).size;
}
function r_(e) {
  if (Rg)
    return Buffer.from(e).toString("base64");
  let t = new Uint8Array(e), n10 = "";
  for (let s10 = 0, r10 = t.length; s10 < r10; s10++)
    n10 += String.fromCharCode(t[s10]);
  return btoa(n10);
}
function a_(e) {
  if (Rg) {
    let s10 = Buffer.from(e, "base64");
    return s10.buffer.slice(s10.byteOffset, s10.byteOffset + s10.byteLength);
  }
  let t = atob(e), n10 = new Uint8Array(t.length);
  for (let s10 = 0; s10 < t.length; ++s10)
    n10.set([t.charCodeAt(s10)], s10);
  return n10.buffer;
}
function Dg(e) {
  if (e.length === 1)
    return e[0];
  let t = 0;
  e.forEach((r10) => {
    t += r10.byteLength;
  });
  let n10 = new Uint8Array(t), s10 = 0;
  return e.forEach((r10) => {
    n10.set(new Uint8Array(r10), s10), s10 += r10.byteLength;
  }), n10.buffer;
}
function ix(e) {
  let t = "/";
  for (e = e.trim(); e.endsWith(t); )
    e = e.slice(0, e.length - 1);
  let n10 = e.split(t);
  return n10[n10.length - 1];
}
function uk(e, t) {
  let n10 = { modelTopology: e.modelTopology, format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy, weightsManifest: t };
  return e.signature != null && (n10.signature = e.signature), e.userDefinedMetadata != null && (n10.userDefinedMetadata = e.userDefinedMetadata), e.modelInitializer != null && (n10.modelInitializer = e.modelInitializer), e.trainingConfig != null && (n10.trainingConfig = e.trainingConfig), n10;
}
async function Fg(e, t) {
  let n10 = { modelTopology: e.modelTopology, format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy };
  if (e.trainingConfig != null && (n10.trainingConfig = e.trainingConfig), e.weightsManifest != null) {
    let [s10, r10] = await t(e.weightsManifest);
    n10.weightSpecs = s10, n10.weightData = r10;
  }
  return e.signature != null && (n10.signature = e.signature), e.userDefinedMetadata != null && (n10.userDefinedMetadata = e.userDefinedMetadata), e.modelInitializer != null && (n10.modelInitializer = e.modelInitializer), n10;
}
function Rl(e) {
  if (e.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return { dateSaved: new Date(), modelTopologyType: "JSON", modelTopologyBytes: e.modelTopology == null ? 0 : ax(JSON.stringify(e.modelTopology)), weightSpecsBytes: e.weightSpecs == null ? 0 : ax(JSON.stringify(e.weightSpecs)), weightDataBytes: e.weightData == null ? 0 : e.weightData.byteLength };
}
function i_() {
  let e = (n10) => {
    let s10 = n10 << 13, r10 = 0;
    for (; (s10 & 8388608) === 0; )
      r10 -= 8388608, s10 <<= 1;
    return s10 &= -8388609, r10 += 947912704, s10 | r10;
  }, t = new Uint32Array(2048);
  t[0] = 0;
  for (let n10 = 1; n10 < 1024; n10++)
    t[n10] = e(n10);
  for (let n10 = 1024; n10 < 2048; n10++)
    t[n10] = 939524096 + (n10 - 1024 << 13);
  return t;
}
function o_() {
  let e = new Uint32Array(64);
  e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;
  for (let t = 1; t < 31; t++)
    e[t] = t << 23;
  for (let t = 33; t < 63; t++)
    e[t] = 2147483648 + (t - 32 << 23);
  return e;
}
function u_() {
  let e = new Uint32Array(64);
  for (let t = 0; t < 64; t++)
    e[t] = 1024;
  return e[0] = e[32] = 0, e;
}
function l_() {
  let e = i_(), t = o_(), n10 = u_();
  return (s10) => {
    let r10 = new ArrayBuffer(4 * s10.length), a10 = new Uint32Array(r10);
    for (let i10 = 0; i10 < s10.length; i10++) {
      let o10 = s10[i10], u10 = e[n10[o10 >> 10] + (o10 & 1023)] + t[o10 >> 10];
      a10[i10] = u10;
    }
    return new Float32Array(r10);
  };
}
var xt = class {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }
  static getInstance() {
    return xt.instance == null && (xt.instance = new xt()), xt.instance;
  }
  static registerSaveRouter(e) {
    xt.getInstance().saveRouters.push(e);
  }
  static registerLoadRouter(e) {
    xt.getInstance().loadRouters.push(e);
  }
  static getSaveHandlers(e) {
    return xt.getHandlers(e, "save");
  }
  static getLoadHandlers(e, t) {
    return xt.getHandlers(e, "load", t);
  }
  static getHandlers(e, t, n10) {
    let s10 = [];
    return (t === "load" ? xt.getInstance().loadRouters : xt.getInstance().saveRouters).forEach((a10) => {
      let i10 = a10(e, n10);
      i10 !== null && s10.push(i10);
    }), s10;
  }
};
var c_ = (e) => xt.registerSaveRouter(e);
var d_ = (e) => xt.registerLoadRouter(e);
var p_ = (e) => xt.getSaveHandlers(e);
var h_ = (e, t) => xt.getLoadHandlers(e, t);
var nm = "tensorflowjs";
var sm = 1;
var Kr = "models_store";
var or = "model_info_store";
function lk() {
  if (!X2().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  let e = typeof window == "undefined" ? self : window, t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
  if (t == null)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return t;
}
function rm(e) {
  let t = e.result;
  t.createObjectStore(Kr, { keyPath: "modelPath" }), t.createObjectStore(or, { keyPath: "modelPath" });
}
var ia = class {
  constructor(e) {
    if (this.indexedDB = lk(), e == null || !e)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    return this.databaseAction(this.modelPath, e);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  databaseAction(e, t) {
    return new Promise((n10, s10) => {
      let r10 = this.indexedDB.open(nm, sm);
      r10.onupgradeneeded = () => rm(r10), r10.onsuccess = () => {
        let a10 = r10.result;
        if (t == null) {
          let i10 = a10.transaction(Kr, "readonly"), u10 = i10.objectStore(Kr).get(this.modelPath);
          u10.onsuccess = () => {
            if (u10.result == null)
              return a10.close(), s10(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            n10(u10.result.modelArtifacts);
          }, u10.onerror = (l10) => (a10.close(), s10(u10.error)), i10.oncomplete = () => a10.close();
        } else {
          let i10 = Rl(t), o10 = a10.transaction(or, "readwrite"), u10 = o10.objectStore(or), l10 = u10.put({ modelPath: this.modelPath, modelArtifactsInfo: i10 }), c10;
          l10.onsuccess = () => {
            c10 = a10.transaction(Kr, "readwrite");
            let d10 = c10.objectStore(Kr).put({ modelPath: this.modelPath, modelArtifacts: t, modelArtifactsInfo: i10 });
            d10.onsuccess = () => n10({ modelArtifactsInfo: i10 }), d10.onerror = (h10) => {
              u10 = o10.objectStore(or);
              let f10 = u10.delete(this.modelPath);
              f10.onsuccess = () => (a10.close(), s10(d10.error)), f10.onerror = (m10) => (a10.close(), s10(d10.error));
            };
          }, l10.onerror = (p10) => (a10.close(), s10(l10.error)), o10.oncomplete = () => {
            c10 == null ? a10.close() : c10.oncomplete = () => a10.close();
          };
        }
      }, r10.onerror = (a10) => s10(r10.error);
    });
  }
};
ia.URL_SCHEME = "indexeddb://";
var ck = (e) => X2().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(ia.URL_SCHEME) ? f_(e.slice(ia.URL_SCHEME.length)) : null;
xt.registerSaveRouter(ck);
xt.registerLoadRouter(ck);
function f_(e) {
  return new ia(e);
}
function m_(e) {
  return e.startsWith(ia.URL_SCHEME) ? e.slice(ia.URL_SCHEME.length) : e;
}
var g_ = class {
  constructor() {
    this.indexedDB = lk();
  }
  async listModels() {
    return new Promise((e, t) => {
      let n10 = this.indexedDB.open(nm, sm);
      n10.onupgradeneeded = () => rm(n10), n10.onsuccess = () => {
        let s10 = n10.result, r10 = s10.transaction(or, "readonly"), i10 = r10.objectStore(or).getAll();
        i10.onsuccess = () => {
          let o10 = {};
          for (let u10 of i10.result)
            o10[u10.modelPath] = u10.modelArtifactsInfo;
          e(o10);
        }, i10.onerror = (o10) => (s10.close(), t(i10.error)), r10.oncomplete = () => s10.close();
      }, n10.onerror = (s10) => t(n10.error);
    });
  }
  async removeModel(e) {
    return e = m_(e), new Promise((t, n10) => {
      let s10 = this.indexedDB.open(nm, sm);
      s10.onupgradeneeded = () => rm(s10), s10.onsuccess = () => {
        let r10 = s10.result, a10 = r10.transaction(or, "readwrite"), i10 = a10.objectStore(or), o10 = i10.get(e), u10;
        o10.onsuccess = () => {
          if (o10.result == null)
            return r10.close(), n10(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
          {
            let l10 = i10.delete(e), c10 = () => {
              u10 = r10.transaction(Kr, "readwrite");
              let d10 = u10.objectStore(Kr).delete(e);
              d10.onsuccess = () => t(o10.result.modelArtifactsInfo), d10.onerror = (h10) => n10(o10.error);
            };
            l10.onsuccess = c10, l10.onerror = (p10) => (c10(), r10.close(), n10(o10.error));
          }
        }, o10.onerror = (l10) => (r10.close(), n10(o10.error)), a10.oncomplete = () => {
          u10 == null ? r10.close() : u10.oncomplete = () => r10.close();
        };
      }, s10.onerror = (r10) => n10(s10.error);
    });
  }
};
var Gs = "/";
var Vi = "tensorflowjs_models";
var dk = "info";
var b_ = "model_topology";
var y_ = "weight_specs";
var v_ = "weight_data";
var x_ = "model_metadata";
function pk(e) {
  return { info: [Vi, e, dk].join(Gs), topology: [Vi, e, b_].join(Gs), weightSpecs: [Vi, e, y_].join(Gs), weightData: [Vi, e, v_].join(Gs), modelMetadata: [Vi, e, x_].join(Gs) };
}
function hk(e) {
  for (let t of Object.values(e))
    window.localStorage.removeItem(t);
}
function w_(e) {
  let t = e.split(Gs);
  if (t.length < 3)
    throw new Error(`Invalid key format: ${e}`);
  return t.slice(1, t.length - 1).join(Gs);
}
function k_(e) {
  return e.startsWith(oa.URL_SCHEME) ? e.slice(oa.URL_SCHEME.length) : e;
}
var oa = class {
  constructor(e) {
    if (!X2().getBool("IS_BROWSER") || typeof window == "undefined" || typeof window.localStorage == "undefined")
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, e == null || !e)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = pk(this.modelPath);
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    {
      let t = JSON.stringify(e.modelTopology), n10 = JSON.stringify(e.weightSpecs), s10 = Rl(e);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(s10)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, n10), this.LS.setItem(this.keys.weightData, r_(e.weightData));
        let r10 = { format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy, signature: e.signature != null ? e.signature : void 0, userDefinedMetadata: e.userDefinedMetadata != null ? e.userDefinedMetadata : void 0, modelInitializer: e.modelInitializer != null ? e.modelInitializer : void 0, trainingConfig: e.trainingConfig != null ? e.trainingConfig : void 0 };
        return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(r10)), { modelArtifactsInfo: s10 };
      } catch (r10) {
        throw hk(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s10.modelTopologyBytes}, weightSpecsBytes=${s10.weightSpecsBytes}, weightDataBytes=${s10.weightDataBytes}.`);
      }
    }
  }
  async load() {
    let e = JSON.parse(this.LS.getItem(this.keys.info));
    if (e == null)
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    if (e.modelTopologyType !== "JSON")
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    let t = {}, n10 = JSON.parse(this.LS.getItem(this.keys.topology));
    if (n10 == null)
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    t.modelTopology = n10;
    let s10 = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (s10 == null)
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    t.weightSpecs = s10;
    let r10 = this.LS.getItem(this.keys.modelMetadata);
    if (r10 != null) {
      let i10 = JSON.parse(r10);
      t.format = i10.format, t.generatedBy = i10.generatedBy, t.convertedBy = i10.convertedBy, i10.signature != null && (t.signature = i10.signature), i10.userDefinedMetadata != null && (t.userDefinedMetadata = i10.userDefinedMetadata), i10.modelInitializer != null && (t.modelInitializer = i10.modelInitializer), i10.trainingConfig != null && (t.trainingConfig = i10.trainingConfig);
    }
    let a10 = this.LS.getItem(this.keys.weightData);
    if (a10 == null)
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    return t.weightData = a_(a10), t;
  }
};
oa.URL_SCHEME = "localstorage://";
var fk = (e) => X2().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(oa.URL_SCHEME) ? I_(e.slice(oa.URL_SCHEME.length)) : null;
xt.registerSaveRouter(fk);
xt.registerLoadRouter(fk);
function I_(e) {
  return new oa(e);
}
var S_ = class {
  constructor() {
    O2(X2().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), O2(typeof window == "undefined" || typeof window.localStorage != "undefined", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }
  async listModels() {
    let e = {}, t = Vi + Gs, n10 = Gs + dk;
    for (let s10 = 0; s10 < this.LS.length; ++s10) {
      let r10 = this.LS.key(s10);
      if (r10.startsWith(t) && r10.endsWith(n10)) {
        let a10 = w_(r10);
        e[a10] = JSON.parse(this.LS.getItem(r10));
      }
    }
    return e;
  }
  async removeModel(e) {
    e = k_(e);
    let t = pk(e);
    if (this.LS.getItem(t.info) == null)
      throw new Error(`Cannot find model at path '${e}'`);
    let n10 = JSON.parse(this.LS.getItem(t.info));
    return hk(t), n10;
  }
};
var Hi = "://";
var Pn = class {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    return Pn.instance == null && (Pn.instance = new Pn()), Pn.instance;
  }
  static registerManager(e, t) {
    O2(e != null, () => "scheme must not be undefined or null."), e.endsWith(Hi) && (e = e.slice(0, e.indexOf(Hi))), O2(e.length > 0, () => "scheme must not be an empty string.");
    let n10 = Pn.getInstance();
    O2(n10.managers[e] == null, () => `A model store manager is already registered for scheme '${e}'.`), n10.managers[e] = t;
  }
  static getManager(e) {
    let t = this.getInstance().managers[e];
    if (t == null)
      throw new Error(`Cannot find model manager for scheme '${e}'`);
    return t;
  }
  static getSchemes() {
    return Object.keys(this.getInstance().managers);
  }
};
function ed(e) {
  if (e.indexOf(Hi) === -1)
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Pn.getSchemes().join(",")}`);
  return { scheme: e.split(Hi)[0], path: e.split(Hi)[1] };
}
async function mk(e, t, n10 = false) {
  O2(e !== t, () => `Old path and new path are the same: '${e}'`);
  let s10 = xt.getLoadHandlers(e);
  O2(s10.length > 0, () => `Copying failed because no load handler is found for source URL ${e}.`), O2(s10.length < 2, () => `Copying failed because more than one (${s10.length}) load handlers for source URL ${e}.`);
  let r10 = s10[0], a10 = xt.getSaveHandlers(t);
  O2(a10.length > 0, () => `Copying failed because no save handler is found for destination URL ${t}.`), O2(a10.length < 2, () => `Copying failed because more than one (${s10.length}) save handlers for destination URL ${t}.`);
  let i10 = a10[0], o10 = ed(e).scheme, u10 = ed(e).path, l10 = o10 === ed(e).scheme, c10 = await r10.load();
  n10 && l10 && await Pn.getManager(o10).removeModel(u10);
  let p10 = await i10.save(c10);
  return n10 && !l10 && await Pn.getManager(o10).removeModel(u10), p10.modelArtifactsInfo;
}
async function C_() {
  let e = Pn.getSchemes(), t = {};
  for (let n10 of e) {
    let s10 = await Pn.getManager(n10).listModels();
    for (let r10 in s10) {
      let a10 = n10 + Hi + r10;
      t[a10] = s10[r10];
    }
  }
  return t;
}
async function N_(e) {
  let t = ed(e);
  return Pn.getManager(t.scheme).removeModel(t.path);
}
async function T_(e, t) {
  return mk(e, t, false);
}
async function $_(e, t) {
  return mk(e, t, true);
}
var __ = class {
  fetch(e, t) {
    return fetch(e, t);
  }
  now() {
    return performance.now();
  }
  encode(e, t) {
    if (t !== "utf-8" && t !== "utf8")
      throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }
  decode(e, t) {
    return new TextDecoder(t).decode(e);
  }
};
if (X2().get("IS_BROWSER")) {
  X2().setPlatform("browser", new __());
  try {
    Pn.registerManager(oa.URL_SCHEME, new S_());
  } catch (e) {
  }
  try {
    Pn.registerManager(ia.URL_SCHEME, new g_());
  } catch (e) {
  }
}
var A_ = { importFetch: () => zT() };
var Ff;
var E_ = class {
  constructor() {
    this.util = MT(), this.textEncoder = new this.util.TextEncoder();
  }
  fetch(e, t) {
    return X2().global.fetch != null ? X2().global.fetch(e, t) : (Ff == null && (Ff = A_.importFetch()), Ff(e, t));
  }
  now() {
    let e = process.hrtime();
    return e[0] * 1e3 + e[1] / 1e6;
  }
  encode(e, t) {
    if (t !== "utf-8" && t !== "utf8")
      throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
    return this.textEncoder.encode(e);
  }
  decode(e, t) {
    return e.length === 0 ? "" : new this.util.TextDecoder(t).decode(e);
  }
};
X2().get("IS_NODE") && !X2().get("IS_BROWSER") && X2().setPlatform("node", new E_());
function De(e, t = "float32", n10) {
  return t = t || "float32", tg(e), new Vt(e, t, n10);
}
function R_(e, t) {
  let n10 = _2(e, "x", "cast");
  if (!Ww(t))
    throw new Error(`Failed to cast to unknown dtype ${t}`);
  if (t === "string" && n10.dtype !== "string" || t !== "string" && n10.dtype === "string")
    throw new Error("Only strings can be casted to strings");
  let s10 = { x: n10 }, r10 = { dtype: t };
  return M2.runKernel(Sa, s10, r10);
}
var ce2 = L2({ cast_: R_ });
function D_(e) {
  let n10 = { x: _2(e, "x", "clone", "string_or_numeric") };
  return M2.runKernel(Ma, n10);
}
var lr = L2({ clone_: D_ });
function F_(e, t = false) {
  console.log(e.toString(t));
}
rk();
var O_ = { buffer: De, cast: ce2, clone: lr, print: F_ };
W$(O_);
var _n = {};
Ae(_n, { browserFiles: () => W_, browserHTTPRequest: () => j_, concatenateArrayBuffers: () => Dg, copyModel: () => T_, decodeWeights: () => ok, encodeWeights: () => n_, fromMemory: () => X_, getLoadHandlers: () => h_, getModelArtifactsForJSON: () => Fg, getModelArtifactsInfoForJSON: () => Rl, getSaveHandlers: () => p_, http: () => Pg, isHTTPScheme: () => im, listModels: () => C_, loadWeights: () => U_, moveModel: () => $_, registerLoadRouter: () => d_, registerSaveRouter: () => c_, removeModel: () => N_, weightsLoaderFactory: () => bk, withSaveHandler: () => Y_ });
var P_ = "model";
var z_ = ".json";
var M_ = ".weights.bin";
function ox(e) {
  return new Promise((t) => setTimeout(t)).then(e);
}
var am = class {
  constructor(e) {
    if (!X2().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(am.URL_SCHEME) && (e = e.slice(am.URL_SCHEME.length)), (e == null || e.length === 0) && (e = P_), this.modelJsonFileName = e + z_, this.weightDataFileName = e + M_;
  }
  async save(e) {
    if (typeof document == "undefined")
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    let t = window.URL.createObjectURL(new Blob([e.weightData], { type: "application/octet-stream" }));
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    {
      let n10 = [{ paths: ["./" + this.weightDataFileName], weights: e.weightSpecs }], s10 = uk(e, n10), r10 = window.URL.createObjectURL(new Blob([JSON.stringify(s10)], { type: "application/json" })), a10 = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      if (a10.download = this.modelJsonFileName, a10.href = r10, await ox(() => a10.dispatchEvent(new MouseEvent("click"))), e.weightData != null) {
        let i10 = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        i10.download = this.weightDataFileName, i10.href = t, await ox(() => i10.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: Rl(e) };
    }
  }
};
var bd = am;
bd.URL_SCHEME = "downloads://";
var L_ = class {
  constructor(e) {
    if (e == null || e.length < 1)
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);
    this.jsonFile = e[0], this.weightsFiles = e.slice(1);
  }
  async load() {
    return new Promise((e, t) => {
      let n10 = new FileReader();
      n10.onload = (s10) => {
        let r10 = JSON.parse(s10.target.result), a10 = r10.modelTopology;
        if (a10 == null) {
          t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (r10.weightsManifest == null) {
          t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          e({ modelTopology: a10 });
          return;
        }
        let o10 = Fg(r10, (u10) => this.loadWeights(u10));
        e(o10);
      }, n10.onerror = (s10) => t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), n10.readAsText(this.jsonFile);
    });
  }
  loadWeights(e) {
    let t = [], n10 = [];
    for (let a10 of e)
      t.push(...a10.weights), n10.push(...a10.paths);
    let s10 = this.checkManifestAndWeightFiles(e), r10 = n10.map((a10) => this.loadWeightsFile(a10, s10[a10]));
    return Promise.all(r10).then((a10) => [t, Dg(a10)]);
  }
  loadWeightsFile(e, t) {
    return new Promise((n10, s10) => {
      let r10 = new FileReader();
      r10.onload = (a10) => {
        let i10 = a10.target.result;
        n10(i10);
      }, r10.onerror = (a10) => s10(`Failed to weights data from file of path '${e}'.`), r10.readAsArrayBuffer(t);
    });
  }
  checkManifestAndWeightFiles(e) {
    let t = [], n10 = this.weightsFiles.map((r10) => ix(r10.name)), s10 = {};
    for (let r10 of e)
      r10.paths.forEach((a10) => {
        let i10 = ix(a10);
        if (t.indexOf(i10) !== -1)
          throw new Error(`Duplicate file basename found in weights manifest: '${i10}'`);
        if (t.push(i10), n10.indexOf(i10) === -1)
          throw new Error(`Weight file with basename '${i10}' is not provided.`);
        s10[a10] = this.weightsFiles[n10.indexOf(i10)];
      });
    if (t.length !== this.weightsFiles.length)
      throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    return s10;
  }
};
var B_ = (e) => X2().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(bd.URL_SCHEME) ? V_(e.slice(bd.URL_SCHEME.length)) : null;
xt.registerSaveRouter(B_);
function V_(e = "model") {
  return new bd(e);
}
function W_(e) {
  return new L_(e);
}
function ux(e, t, n10, s10) {
  i10(e), n10 = n10 == null ? 0 : n10, s10 = s10 == null ? 1 : s10, o10(n10, s10);
  let r10 = 0, a10 = (u10) => (u10.then((l10) => {
    let c10 = n10 + ++r10 / e.length * (s10 - n10);
    return t(c10), l10;
  }), u10);
  function i10(u10) {
    O2(u10 != null && Array.isArray(u10) && u10.length > 0, () => "promises must be a none empty array");
  }
  function o10(u10, l10) {
    O2(u10 >= 0 && u10 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${u10}`), O2(l10 >= 0 && l10 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${l10}`), O2(l10 >= u10, () => `startFraction must be no more than endFraction, but got startFraction ${u10} and endFraction ${l10}`);
  }
  return Promise.all(e.map(a10));
}
async function gk(e, t) {
  t == null && (t = {});
  let n10 = t.fetchFunc == null ? X2().platform.fetch : t.fetchFunc, s10 = e.map((p10) => n10(p10, t.requestInit, { isBinary: true })), r10 = 0, a10 = 0.5, o10 = (t.onProgress == null ? await Promise.all(s10) : await ux(s10, t.onProgress, r10, a10)).map((p10) => p10.arrayBuffer()), u10 = 0.5, l10 = 1;
  return t.onProgress == null ? await Promise.all(o10) : await ux(o10, t.onProgress, u10, l10);
}
async function U_(e, t = "", n10, s10) {
  return bk((i10) => gk(i10, { requestInit: s10 }))(e, t, n10);
}
function bk(e) {
  return async (t, n10 = "", s10) => {
    let r10 = t.map(() => false), a10 = {}, i10 = s10 != null ? s10.map(() => false) : [], o10 = [];
    if (t.forEach((h10, f10) => {
      let m10 = 0;
      h10.weights.forEach((g10) => {
        let b10 = "quantization" in g10 ? g10.quantization.dtype : g10.dtype, y10 = tm[b10] * pt(g10.shape), v10 = () => {
          r10[f10] = true, a10[f10] == null && (a10[f10] = []), a10[f10].push({ manifestEntry: g10, groupOffset: m10, sizeBytes: y10 });
        };
        s10 != null ? s10.forEach((x10, k10) => {
          x10 === g10.name && (v10(), i10[k10] = true);
        }) : v10(), o10.push(g10.name), m10 += y10;
      });
    }), !i10.every((h10) => h10)) {
      let h10 = s10.filter((f10, m10) => !i10[m10]);
      throw new Error(`Could not find weights in manifest with names: ${h10.join(", ")}. 
Manifest JSON has weights with names: ${o10.join(", ")}.`);
    }
    let u10 = r10.reduce((h10, f10, m10) => (f10 && h10.push(m10), h10), []), l10 = [];
    u10.forEach((h10) => {
      t[h10].paths.forEach((f10) => {
        let m10 = n10 + (n10.endsWith("/") ? "" : "/") + f10;
        l10.push(m10);
      });
    });
    let c10 = await e(l10), p10 = {}, d10 = 0;
    return u10.forEach((h10) => {
      let f10 = t[h10].paths.length, m10 = 0;
      for (let x10 = 0; x10 < f10; x10++)
        m10 += c10[d10 + x10].byteLength;
      let g10 = new ArrayBuffer(m10), b10 = new Uint8Array(g10), y10 = 0;
      for (let x10 = 0; x10 < f10; x10++) {
        let k10 = new Uint8Array(c10[d10 + x10]);
        b10.set(k10, y10), y10 += k10.byteLength;
      }
      a10[h10].forEach((x10) => {
        let k10 = g10.slice(x10.groupOffset, x10.groupOffset + x10.sizeBytes), C10 = ok(k10, [x10.manifestEntry]);
        for (let T10 in C10)
          p10[T10] = C10[T10];
      }), d10 += f10;
    }), p10;
  };
}
var G_ = "application/octet-stream";
var H_ = "application/json";
var Og = class {
  constructor(e, t) {
    if (this.DEFAULT_METHOD = "POST", t == null && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, t.fetchFunc != null ? (O2(typeof t.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = t.fetchFunc) : this.fetch = X2().platform.fetch, O2(e != null && e.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e) && O2(e.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${e.length}).`), this.path = e, t.requestInit != null && t.requestInit.body != null)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    let t = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    t.body = new FormData();
    let n10 = [{ paths: ["./model.weights.bin"], weights: e.weightSpecs }], s10 = uk(e, n10);
    t.body.append("model.json", new Blob([JSON.stringify(s10)], { type: H_ }), "model.json"), e.weightData != null && t.body.append("model.weights.bin", new Blob([e.weightData], { type: G_ }), "model.weights.bin");
    let r10 = await this.fetch(this.path, t);
    if (r10.ok)
      return { modelArtifactsInfo: Rl(e), responses: [r10] };
    throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r10.status}.`);
  }
  async load() {
    let e = await this.fetch(this.path, this.requestInit);
    if (!e.ok)
      throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);
    let t;
    try {
      t = await e.json();
    } catch (r10) {
      let a10 = `Failed to parse model JSON of response from ${this.path}.`;
      throw this.path.endsWith(".pb") ? a10 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : a10 += " Please make sure the server is serving valid JSON for this request.", new Error(a10);
    }
    let n10 = t.modelTopology, s10 = t.weightsManifest;
    if (n10 == null && s10 == null)
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    return Fg(t, (r10) => this.loadWeights(r10));
  }
  async loadWeights(e) {
    let t = Array.isArray(this.path) ? this.path[1] : this.path, [n10, s10] = q_(t), r10 = this.weightPathPrefix || n10, a10 = [];
    for (let l10 of e)
      a10.push(...l10.weights);
    let i10 = [], o10 = [];
    for (let l10 of e)
      for (let c10 of l10.paths)
        this.weightUrlConverter != null ? o10.push(this.weightUrlConverter(c10)) : i10.push(r10 + c10 + s10);
    this.weightUrlConverter && i10.push(...await Promise.all(o10));
    let u10 = await gk(i10, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress });
    return [a10, Dg(u10)];
  }
};
Og.URL_SCHEME_REGEX = /^https?:\/\//;
function q_(e) {
  let t = e.lastIndexOf("/"), n10 = e.lastIndexOf("?"), s10 = e.substring(0, t), r10 = n10 > t ? e.substring(n10) : "";
  return [s10 + "/", r10];
}
function im(e) {
  return e.match(Og.URL_SCHEME_REGEX) != null;
}
var yk = (e, t) => {
  if (typeof fetch == "undefined" && (t == null || t.fetchFunc == null))
    return null;
  {
    let n10 = true;
    if (Array.isArray(e) ? n10 = e.every((s10) => im(s10)) : n10 = im(e), n10)
      return Pg(e, t);
  }
  return null;
};
xt.registerSaveRouter(yk);
xt.registerLoadRouter(yk);
function Pg(e, t) {
  return new Og(e, t);
}
function j_(e, t) {
  return Pg(e, t);
}
var Of = class {
  constructor(e) {
    this.modelArtifacts = e;
  }
  async load() {
    return this.modelArtifacts;
  }
};
var K_ = class {
  constructor(e) {
    this.saveHandler = e;
  }
  async save(e) {
    return this.saveHandler(e);
  }
};
function X_(e, t, n10, s10) {
  return arguments.length === 1 ? e.modelTopology != null || e.weightSpecs != null ? new Of(e) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Of({ modelTopology: e })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Of({ modelTopology: e, weightSpecs: t, weightData: n10, trainingConfig: s10 }));
}
function Y_(e) {
  return new K_(e);
}
var Q_ = {};
Ae(Q_, { confusionMatrix: () => nA });
function Z_(e, t, n10 = false, s10 = false) {
  let r10 = _2(e, "a", "matMul"), a10 = _2(t, "b", "matMul");
  [r10, a10] = vt(r10, a10);
  let i10 = { a: r10, b: a10 }, o10 = { transposeA: n10, transposeB: s10 };
  return M2.runKernel(Ia, i10, o10);
}
var We = L2({ matMul_: Z_ });
function J_(e, t, n10 = 1, s10 = 0) {
  if (t < 2)
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
  let a10 = { indices: _2(e, "indices", "oneHot", "int32") }, i10 = { depth: t, onValue: n10, offValue: s10 };
  return M2.runKernel(To, a10, i10);
}
var yd = L2({ oneHot_: J_ });
function eA(e, t) {
  let n10 = _2(e, "x", "transpose");
  if (t == null && (t = n10.shape.map((a10, i10) => i10).reverse()), O2(n10.rank === t.length, () => `Error in transpose: rank of input ${n10.rank} must match length of perm ${t}.`), t.forEach((a10) => {
    O2(a10 >= 0 && a10 < n10.rank, () => `All entries in 'perm' must be between 0 and ${n10.rank - 1} but got ${t}`);
  }), n10.rank <= 1)
    return n10.clone();
  let s10 = { x: n10 }, r10 = { perm: t };
  return M2.runKernel(ci, s10, r10);
}
var qe = L2({ transpose_: eA });
function tA(e, t, n10) {
  let s10 = _2(e, "labels", "confusionMatrix"), r10 = _2(t, "predictions", "confusionMatrix");
  O2(n10 == null || n10 > 0 && Number.isInteger(n10), () => `If provided, numClasses must be a positive integer, but got ${n10}`), O2(s10.rank === 1, () => `Expected the rank of labels to be 1, but got ${s10.rank}`), O2(r10.rank === 1, () => `Expected the rank of predictions to be 1, but got ${r10.rank}`), O2(s10.shape[0] === r10.shape[0], () => `Mismatch in the number of examples: ${s10.shape[0]} vs. ${r10.shape[0]}. Labels and predictions should have the same number of elements.`), O2(n10 > 0 && Number.isInteger(n10), () => `numClasses is required to be a positive integer, but got ${n10}`);
  let a10 = yd(ce2(s10, "int32"), n10), i10 = yd(ce2(r10, "int32"), n10), o10 = qe(a10), u10 = We(o10, i10);
  return ce2(u10, "int32");
}
var nA = L2({ confusionMatrix_: tA });
var qo = {};
Ae(qo, { assertAndGetBroadcastShape: () => it, getBroadcastDims: () => vk, getReductionAxes: () => _t });
function vk(e, t) {
  let n10 = e.length, s10 = [];
  for (let r10 = 0; r10 < n10; r10++) {
    let a10 = n10 - 1 - r10, i10 = e[a10] || 1;
    (t[t.length - 1 - r10] || 1) > 1 && i10 === 1 && s10.unshift(a10);
  }
  return s10;
}
function _t(e, t) {
  let n10 = [];
  for (let s10 = 0; s10 < t.length; s10++) {
    let r10 = e[e.length - s10 - 1], a10 = t.length - s10 - 1, i10 = t[a10];
    (r10 == null || r10 === 1 && i10 > 1) && n10.unshift(a10);
  }
  return n10;
}
function it(e, t) {
  let n10 = [], s10 = Math.max(e.length, t.length);
  for (let r10 = 0; r10 < s10; r10++) {
    let a10 = e[e.length - r10 - 1];
    a10 == null && (a10 = 1);
    let i10 = t[t.length - r10 - 1];
    if (i10 == null && (i10 = 1), a10 === 1)
      n10.unshift(i10);
    else if (i10 === 1)
      n10.unshift(a10);
    else if (a10 !== i10) {
      let o10 = `Operands could not be broadcast together with shapes ${e} and ${t}.`;
      throw Error(o10);
    } else
      n10.unshift(a10);
  }
  return n10;
}
var xk = {};
Ae(xk, { fromPixels: () => cA, fromPixelsAsync: () => uA, toPixels: () => lA });
function sA(e, t, n10) {
  if (va(e), t != null && t.length !== 3)
    throw new Error("tensor3d() requires shape to have three numbers");
  let s10 = Rs(e, n10);
  if (s10.length !== 3 && s10.length !== 1)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (s10.length === 1 && t == null)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Cr(e, t, s10, n10);
}
var Br;
function wk(e, t = 3) {
  if (t > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (e == null)
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let n10 = false, s10 = false, r10 = false, a10 = false, i10 = false, o10 = false;
  if (e.data instanceof Uint8Array)
    n10 = true;
  else if (typeof ImageData != "undefined" && e instanceof ImageData)
    s10 = true;
  else if (typeof HTMLVideoElement != "undefined" && e instanceof HTMLVideoElement)
    r10 = true;
  else if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement)
    a10 = true;
  else if (e.getContext != null)
    i10 = true;
  else if (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
    o10 = true;
  else
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);
  if (r10 && r10 && e.readyState < 2)
    throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
  if (Yf(hd, M2.backendName) != null) {
    let f10 = { pixels: e }, m10 = { numChannels: t };
    return M2.runKernel(hd, f10, m10);
  }
  let [l10, c10] = r10 ? [e.videoWidth, e.videoHeight] : [e.width, e.height], p10;
  if (i10)
    p10 = e.getContext("2d").getImageData(0, 0, l10, c10).data;
  else if (s10 || n10)
    p10 = e.data;
  else if (a10 || r10 || o10) {
    if (Br == null)
      if (typeof document == "undefined")
        if (typeof OffscreenCanvas != "undefined" && typeof OffscreenCanvasRenderingContext2D != "undefined")
          Br = new OffscreenCanvas(1, 1).getContext("2d");
        else
          throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
      else
        Br = document.createElement("canvas").getContext("2d");
    Br.canvas.width = l10, Br.canvas.height = c10, Br.drawImage(e, 0, 0, l10, c10), p10 = Br.getImageData(0, 0, l10, c10).data;
  }
  let d10;
  if (t === 4)
    d10 = new Int32Array(p10);
  else {
    let f10 = l10 * c10;
    d10 = new Int32Array(f10 * t);
    for (let m10 = 0; m10 < f10; m10++)
      for (let g10 = 0; g10 < t; ++g10)
        d10[m10 * t + g10] = p10[m10 * 4 + g10];
  }
  return sA(d10, [c10, l10, t], "int32");
}
function rA(e) {
  return e != null && e.data instanceof Uint8Array;
}
function aA() {
  return typeof window != "undefined" && typeof ImageBitmap != "undefined" && window.hasOwnProperty("createImageBitmap");
}
function iA(e) {
  return e != null && e.width !== 0 && e.height !== 0;
}
function oA(e) {
  return aA() && !(e instanceof ImageBitmap) && iA(e) && !rA(e);
}
async function uA(e, t = 3) {
  let n10 = null;
  if (X2().getBool("WRAP_TO_IMAGEBITMAP") && oA(e)) {
    let s10;
    try {
      s10 = await createImageBitmap(e, { premultiplyAlpha: "none" });
    } catch (r10) {
      s10 = null;
    }
    s10 != null && s10.width === e.width && s10.height === e.height ? n10 = s10 : n10 = e;
  } else
    n10 = e;
  return wk(n10, t);
}
async function lA(e, t) {
  let n10 = _2(e, "img", "toPixels");
  if (!(e instanceof et)) {
    let l10 = n10;
    n10 = ce2(l10, "int32"), l10.dispose();
  }
  if (n10.rank !== 2 && n10.rank !== 3)
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n10.rank}.`);
  let [s10, r10] = n10.shape.slice(0, 2), a10 = n10.rank === 2 ? 1 : n10.shape[2];
  if (a10 > 4 || a10 === 2)
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a10}`);
  if (n10.dtype !== "float32" && n10.dtype !== "int32")
    throw new Error(`Unsupported type for toPixels: ${n10.dtype}. Please use float32 or int32 tensors.`);
  let i10 = await n10.data(), o10 = n10.dtype === "float32" ? 255 : 1, u10 = new Uint8ClampedArray(r10 * s10 * 4);
  for (let l10 = 0; l10 < s10 * r10; ++l10) {
    let c10 = [0, 0, 0, 255];
    for (let d10 = 0; d10 < a10; d10++) {
      let h10 = i10[l10 * a10 + d10];
      if (n10.dtype === "float32") {
        if (h10 < 0 || h10 > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h10}.`);
      } else if (n10.dtype === "int32" && (h10 < 0 || h10 > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h10}.`);
      a10 === 1 ? (c10[0] = h10 * o10, c10[1] = h10 * o10, c10[2] = h10 * o10) : c10[d10] = h10 * o10;
    }
    let p10 = l10 * 4;
    u10[p10 + 0] = Math.round(c10[0]), u10[p10 + 1] = Math.round(c10[1]), u10[p10 + 2] = Math.round(c10[2]), u10[p10 + 3] = Math.round(c10[3]);
  }
  if (t != null) {
    t.width = r10, t.height = s10;
    let l10 = t.getContext("2d"), c10 = new ImageData(u10, r10, s10);
    l10.putImageData(c10, 0, 0);
  }
  return n10 !== e && n10.dispose(), u10;
}
var cA = L2({ fromPixels_: wk });
var kk = {};
Ae(kk, { prepareAndValidate: () => Ik });
function Ik(e, t) {
  let n10 = e.shape.length, s10 = t.shape.length;
  if (n10 < 1)
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n10}.`);
  if (s10 < 1)
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s10}.`);
  if (t.dtype !== "int32")
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
  if (t.shape[s10 - 1] > n10)
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s10 - 1]} vs. ${n10}`);
  if (pt(e.shape) === 0)
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);
  let r10 = t.shape, a10 = r10[r10.length - 1], i10 = 1;
  for (let p10 = 0; p10 < r10.length - 1; ++p10)
    i10 *= r10[p10];
  let o10 = e.shape, u10 = r10.slice();
  u10.pop();
  let l10 = 1;
  for (let p10 = a10; p10 < n10; ++p10)
    l10 *= o10[p10], u10.push(o10[p10]);
  let c10 = [...ro(e.shape).map((p10) => p10 / l10), 1].slice(0, a10);
  return [u10, i10, l10, c10];
}
var Sk = {};
Ae(Sk, { calculateShapes: () => Ck, validateInput: () => Mg, validateUpdateShape: () => zg });
function zg(e, t, n10) {
  let s10 = t.rank > 1 ? t.shape[t.rank - 1] : 1, r10 = t.rank > 1 ? t.rank - 1 : 1, a10 = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n10.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s10}, and batchDim: ${r10}.`;
  if (n10.rank < r10)
    throw new Error(a10 + ` update.rank < ${r10}. `);
  if (e.length < s10 + (n10.rank - r10))
    throw new Error(a10 + ` Output shape length < ${s10 + (n10.rank - r10)}`);
  if (n10.rank !== r10 + e.length - s10)
    throw new Error(a10 + ` update.rank != ${r10 + e.length - s10}`);
  for (let i10 = 0; i10 < r10; ++i10)
    if (n10.shape[i10] !== t.shape[i10])
      throw new Error(a10 + ` updates.shape[${i10}] (${n10.shape[i10]}) != indices.shape[${i10}] (${t.shape[i10]}).`);
  for (let i10 = 0; i10 < n10.rank - r10; ++i10)
    if (n10.shape[i10 + r10] !== e[i10 + s10])
      throw new Error(a10 + ` updates.shape[${i10 + r10}] (${n10.shape[i10 + r10]}) != shape[${i10 + r10}] (${e[i10 + r10]})`);
}
function Mg(e, t, n10) {
  if (t.rank < 1)
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
  if (e.rank < 1)
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);
  if (t.dtype !== "int32")
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
  if (n10.length < 1)
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n10}`);
  if (n10.length === 0) {
    if (t.size === 0)
      throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
    if (e.size === 0)
      throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`);
  }
  zg(n10, t, e);
}
function Ck(e, t, n10) {
  let s10 = t.shape.length, r10 = s10 > 1 ? t.shape[s10 - 1] : 1, a10 = n10.length, i10 = 1;
  for (let p10 = r10; p10 < a10; ++p10)
    i10 *= n10[p10];
  let o10 = r10 < 1 ? 1 : r10, u10 = pt(t.shape) / o10, l10 = [...ro(n10.slice(0, r10)), 1], c10 = pt(n10);
  return { sliceRank: r10, numUpdates: u10, sliceSize: i10, strides: l10, outputSize: c10 };
}
var wt = {};
Ae(wt, { assertParamsValid: () => pA, computeFlatOffset: () => bA, computeOutShape: () => fA, getNormalizedAxes: () => mA, isSliceContinous: () => gA, maskToAxes: () => hA, parseSliceParams: () => Fk, sliceInfo: () => yA, startForAxis: () => Rk, startIndicesWithElidedDims: () => _k, stopForAxis: () => Dk, stopIndicesWithElidedDims: () => Ak, stridesForAxis: () => Ek, stridesWithElidedDims: () => Nk });
var om = -2;
var dA = -1;
function pA(e, t, n10) {
  let s10 = e.shape.length;
  O2(s10 === t.length, () => `Error in slice${s10}D: Length of begin ${t} must match the rank of the array (${s10}).`), O2(s10 === n10.length, () => `Error in slice${s10}D: Length of size ${n10} must match the rank of the array (${s10}).`);
  for (let r10 = 0; r10 < s10; ++r10)
    O2(t[r10] + n10[r10] <= e.shape[r10], () => `Error in slice${s10}D: begin[${r10}] + size[${r10}] (${t[r10] + n10[r10]}) would overflow input.shape[${r10}] (${e.shape[r10]})`);
}
function hA(e) {
  let t = [], n10 = 0;
  for (; e > 0; )
    e & 1 && t.push(n10), e /= 2, n10++;
  return t;
}
function fA(e, t, n10) {
  let s10 = [];
  for (let r10 = 0; r10 < e.length; r10++)
    s10[r10] = Math.ceil((t[r10] - e[r10]) / n10[r10]);
  return s10;
}
function Nk(e, t, n10, s10) {
  let r10 = [...e];
  for (let a10 = r10.length; a10 < s10.length; a10++)
    r10.push(1);
  for (let a10 = 0; a10 < n10; a10++)
    a10 === 0 ? r10[t] = 1 : (r10.splice(t, 0, 1), r10.pop());
  return r10;
}
function Tk(e, t, n10) {
  return n10 <= e ? n10 : n10 - (t - 1);
}
function $k(e, t) {
  let n10 = [];
  for (let s10 = 0; s10 < e; s10++)
    n10.push(t + s10);
  return n10;
}
function mA(e, t, n10, s10, r10, a10, i10, o10, u10) {
  let l10 = e.length, c10 = new Array(l10), p10 = new Array(l10), d10 = new Array(l10);
  if (t.length && n10 > 0) {
    let h10 = t[0], f10 = n10 + 1;
    c10 = _k(i10, h10, f10, s10, e), p10 = Ak(o10, h10, f10, r10, e), d10 = Nk(a10, h10, f10, e);
  } else
    for (let h10 = 0; h10 < l10; h10++)
      c10[h10] = Rk(i10, s10, a10, e, h10, u10), p10[h10] = Dk(o10, r10, a10, e, h10, u10), d10[h10] = Ek(a10, h10, u10);
  return { begin: c10, end: p10, strides: d10 };
}
function _k(e, t, n10, s10, r10) {
  let a10 = [...r10], i10 = $k(n10, t);
  for (let o10 = 0; o10 < a10.length; o10++)
    if (i10.indexOf(o10) > -1)
      a10[o10] = 0;
    else {
      let u10 = Tk(t, n10, o10), l10 = s10[u10];
      e & 1 << u10 && (l10 = 0), a10[o10] = l10;
    }
  return a10;
}
function Ak(e, t, n10, s10, r10) {
  let a10 = [...r10], i10 = $k(n10, t);
  for (let o10 = 0; o10 < a10.length; o10++)
    if (i10.indexOf(o10) > -1)
      a10[o10] = Number.MAX_SAFE_INTEGER;
    else {
      let u10 = Tk(t, n10, o10), l10 = s10[u10];
      e & 1 << u10 && (l10 = Number.MAX_SAFE_INTEGER), a10[o10] = l10;
    }
  for (let o10 = 0; o10 < a10.length; o10++) {
    let u10 = r10[o10];
    a10[o10] < 0 && (a10[o10] += u10), a10[o10] = Bu(0, a10[o10], r10[o10]);
  }
  return a10;
}
function Ek(e, t, n10) {
  let s10 = e[t];
  return (n10 & 1 << t || s10 == null) && (s10 = 1), s10;
}
function Rk(e, t, n10, s10, r10, a10) {
  let i10 = t[r10], o10 = n10[r10] || 1;
  (e & 1 << r10 || a10 & 1 << r10 || i10 == null) && (o10 > 0 ? i10 = Number.MIN_SAFE_INTEGER : i10 = Number.MAX_SAFE_INTEGER);
  let u10 = s10[r10];
  return i10 < 0 && (i10 += u10), i10 = Bu(0, i10, u10 - 1), i10;
}
function Dk(e, t, n10, s10, r10, a10) {
  let i10 = t[r10], o10 = n10[r10] || 1;
  (e & 1 << r10 || a10 & 1 << r10 || i10 == null) && (o10 > 0 ? i10 = Number.MAX_SAFE_INTEGER : i10 = Number.MIN_SAFE_INTEGER);
  let u10 = s10[r10];
  return i10 < 0 && (i10 += u10), o10 > 0 ? i10 = Bu(0, i10, u10) : i10 = Bu(-1, i10, u10 - 1), i10;
}
function gA(e, t, n10) {
  let s10 = n10.length;
  for (let r10 = 0; r10 < n10.length; r10++)
    if (n10[r10] > 1) {
      s10 = r10;
      break;
    }
  for (let r10 = s10 + 1; r10 < n10.length; r10++)
    if (t[r10] > 0 || n10[r10] !== e[r10])
      return false;
  return true;
}
function bA(e, t) {
  let n10 = e.length > 0 ? e[e.length - 1] : 1;
  for (let s10 = 0; s10 < e.length - 1; s10++)
    n10 += e[s10] * t[s10];
  return n10;
}
function Fk(e, t, n10) {
  let s10, r10 = e.shape.length;
  typeof t == "number" ? s10 = [t, ...new Array(r10 - 1).fill(0)] : t.length < r10 ? s10 = t.concat(new Array(r10 - t.length).fill(0)) : s10 = t.slice(), s10.forEach((i10) => {
    O2(i10 !== -1, () => "slice() does not support negative begin indexing.");
  });
  let a10;
  return n10 == null ? a10 = new Array(r10).fill(-1) : typeof n10 == "number" ? a10 = [n10, ...new Array(r10 - 1).fill(-1)] : n10.length < r10 ? a10 = n10.concat(new Array(r10 - n10.length).fill(-1)) : a10 = n10, a10 = a10.map((i10, o10) => i10 >= 0 ? i10 : (O2(i10 === -1, () => `Negative size values should be exactly -1 but got ${i10} for the slice() size at index ${o10}.`), e.shape[o10] - s10[o10])), [s10, a10];
}
function yA(e, t, n10, s10, r10, a10, i10, o10, u10) {
  let l10;
  if (s10 == null ? (l10 = new Array(t.length), l10.fill(1)) : l10 = s10, i10 != null && (i10 & i10 - 1) !== 0)
    throw new Error("Multiple ellipses in slice is not allowed.");
  let c10 = false, p10 = { dims: l10.length, numAddAxisAfterEllipsis: 0, begin: t.slice(), end: n10.slice(), strides: l10.slice(), beginMask: r10, endMask: a10, ellipsisMask: i10, newAxisMask: o10, shrinkAxisMask: u10 };
  for (let v10 = 0; v10 < p10.dims; v10++)
    c10 && (1 << v10 & o10) !== 0 && p10.numAddAxisAfterEllipsis++, 1 << v10 & i10 && (c10 = true);
  c10 || (p10.ellipsisMask |= 1 << p10.dims, p10.dims++);
  let d10 = { dims: e.length, beginMask: 0, endMask: 0, beginValid: false, endValid: false };
  vA(p10, d10);
  let h10 = true, f10 = true, m10 = true, g10 = [], b10 = [];
  for (let v10 = 0; v10 < e.length; ++v10) {
    if (d10.strides[v10] === 0)
      throw Error(`strides[${v10}] must be non-zero`);
    let x10 = !!(d10.shrinkAxisMask & 1 << v10), k10 = e[v10];
    if (k10 === -1) {
      g10.push(x10 ? 1 : -1);
      continue;
    }
    let C10 = [d10.beginMask & 1 << v10, d10.endMask & 1 << v10], T10 = [d10.strides[v10] > 0 ? 0 : -1, d10.strides[v10] > 0 ? k10 : k10 - 1];
    if (x10 && d10.strides[v10] <= 0)
      throw Error("only stride 1 allowed on non-range indexing.");
    m10 = m10 && d10.strides[v10] === 1;
    let E10 = !!(d10.beginMask & 1 << v10 && d10.endMask & 1 << v10);
    if (d10.beginValid && d10.endValid) {
      if (x10) {
        let F10 = d10.begin[v10] < 0 ? k10 + d10.begin[v10] : d10.begin[v10];
        if (d10.begin[v10] = F10, d10.end[v10] = d10.begin[v10] + 1, F10 < 0 || F10 >= k10)
          throw Error(`slice index ${d10.begin[v10]} of dimension ${v10} out of bounds.`);
      } else
        d10.begin[v10] = lx(d10.begin[v10], 0, d10.strides[v10], k10, C10, T10), d10.end[v10] = lx(d10.end[v10], 1, d10.strides[v10], k10, C10, T10);
      let R10 = d10.strides[v10] === 1 && d10.begin[v10] === 0 && d10.end[v10] === k10;
      h10 = h10 && R10, f10 = f10 && (v10 === 0 && d10.strides[v10] === 1 || R10);
    } else
      h10 = h10 && d10.strides[v10] === 1 && E10, f10 = f10 && (v10 === 0 && d10.strides[v10] === 1 || E10);
    let A10, P10 = false;
    if (d10.beginValid && d10.endValid ? (A10 = d10.end[v10] - d10.begin[v10], P10 = true) : x10 ? (A10 = 1, P10 = true) : E10 && k10 >= 0 && (d10.strides[v10] < 0 ? A10 = -k10 : A10 = k10, P10 = true), P10) {
      let R10;
      A10 === 0 || A10 < 0 != d10.strides[v10] < 0 ? R10 = 0 : R10 = Math.trunc(A10 / d10.strides[v10]) + (A10 % d10.strides[v10] !== 0 ? 1 : 0), g10.push(R10);
    } else
      g10.push(-1);
  }
  for (let v10 = 0; v10 < d10.finalShapeGatherIndices.length; ++v10) {
    let x10 = d10.finalShapeGatherIndices[v10];
    x10 >= 0 ? b10.push(g10[x10]) : x10 === om && b10.push(1);
  }
  return { finalShapeSparse: b10.filter((v10, x10) => d10.finalShapeGatherIndices[x10] !== om), finalShape: b10, isIdentity: h10, sliceDim0: f10, isSimpleSlice: m10, begin: d10.begin, end: d10.end, strides: d10.strides };
}
function vA(e, t) {
  t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
  let n10 = 0;
  t.beginValid = e.begin != null, t.endValid = e.end != null, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
  for (let s10 = 0; s10 < e.dims; s10++)
    if (1 << s10 & e.ellipsisMask) {
      let r10 = Math.min(t.dims - (e.dims - s10) + 1 + e.numAddAxisAfterEllipsis, t.dims);
      for (; n10 < r10; n10++)
        t.begin[n10] = 0, t.end[n10] = 0, t.strides[n10] = 1, t.beginMask |= 1 << n10, t.endMask |= 1 << n10, t.finalShapeGatherIndices.push(n10), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[n10] = s10;
    } else if (1 << s10 & e.newAxisMask)
      t.finalShapeGatherIndices.push(om), t.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (n10 === t.begin.length)
        throw Error(`Index out of range using input dim ${n10}; input has only ${t.dims} dims, ${t.begin.length}.`);
      e.begin != null && (t.begin[n10] = e.begin[s10]), e.end != null && (t.end[n10] = e.end[s10]), t.strides[n10] = e.strides[s10], e.beginMask & 1 << s10 && (t.beginMask |= 1 << n10), e.endMask & 1 << s10 && (t.endMask |= 1 << n10), e.shrinkAxisMask & 1 << s10 ? (t.finalShapeGatherIndices.push(dA), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << n10) : (t.finalShapeGatherIndices.push(n10), t.finalShapeGatherIndicesSparse.push(s10)), t.inputShapeGatherIndicesSparse[n10] = s10, n10++;
    }
}
function lx(e, t, n10, s10, r10, a10) {
  if (r10[t])
    return n10 > 0 ? a10[t] : a10[t + 1 & 1];
  {
    let i10 = e < 0 ? s10 + e : e;
    return i10 < a10[0] ? a10[0] : i10 > a10[1] ? a10[1] : i10;
  }
}
var ae2 = {};
Ae(ae2, { Serializable: () => Ok, SerializationMap: () => Hr, registerClass: () => Nr });
var Ok = class {
  getClassName() {
    return this.constructor.className;
  }
  static fromConfig(e, t) {
    return new e(t);
  }
};
var Hr = class {
  constructor() {
    this.classNameMap = {};
  }
  static getMap() {
    return Hr.instance == null && (Hr.instance = new Hr()), Hr.instance;
  }
  static register(e) {
    Hr.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }
};
function Nr(e) {
  O2(e.className != null, () => "Class being registered does not have the static className property defined."), O2(typeof e.className == "string", () => "className is required to be a string, but got type " + typeof e.className), O2(e.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), Hr.register(e);
}
var xA = {};
Ae(xA, { TEST_EPSILON_FLOAT16: () => Pk, encodeStrings: () => zk, expectArrayBuffersEqual: () => TA, expectArraysClose: () => kA, expectArraysEqual: () => SA, expectNumbersClose: () => CA, expectPromiseToFail: () => IA, expectValuesInRange: () => NA, testEpsilon: () => Lg });
var wA = 1e-3;
var Pk = 0.1;
function kA(e, t, n10) {
  return n10 == null && (n10 = Lg()), um(e, t, (s10, r10) => Bg(s10, r10, n10));
}
function Lg() {
  return M2.backend.floatPrecision() === 32 ? wA : Pk;
}
function um(e, t, n10) {
  let s10 = true;
  if ((Yt(e) || Yt(t)) && (s10 = false), Yt(e) && Yt(t) && (s10 = true), s10) {
    let i10 = e.constructor.name, o10 = t.constructor.name;
    if (i10 !== o10)
      throw new Error(`Arrays are of different type. Actual: ${i10}. Expected: ${o10}`);
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    let i10 = Rs(e), o10 = Rs(t);
    if (!wr(i10, o10))
      throw new Error(`Arrays have different shapes. Actual: [${i10}]. Expected: [${o10}]`);
  }
  let r10 = Yt(e) ? e : ta(e), a10 = Yt(t) ? t : ta(t);
  if (r10.length !== a10.length)
    throw new Error(`Arrays have different lengths actual: ${r10.length} vs expected: ${a10.length}.
Actual:   ${r10}.
Expected: ${a10}.`);
  for (let i10 = 0; i10 < a10.length; ++i10) {
    let o10 = r10[i10], u10 = a10[i10];
    if (!n10(o10, u10))
      throw new Error(`Arrays differ: actual[${i10}] = ${o10}, expected[${i10}] = ${u10}.
Actual:   ${r10}.
Expected: ${a10}.`);
  }
}
function IA(e, t) {
  e().then(() => t.fail(), () => t());
}
function SA(e, t) {
  let n10 = typeof t == "string" || typeof t == "number" || typeof t == "boolean" ? [t] : t;
  return ir(e) || ir(e[0]) || ir(t) || ir(t[0]) ? um(e, n10, (s10, r10) => s10 == r10) : um(e, t, (s10, r10) => Bg(s10, r10, 0));
}
function CA(e, t, n10) {
  if (n10 == null && (n10 = Lg()), !Bg(e, t, n10))
    throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);
}
function Bg(e, t, n10) {
  return !isFinite(e) && !isFinite(t) ? true : !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n10);
}
function NA(e, t, n10) {
  for (let s10 = 0; s10 < e.length; s10++)
    if (e[s10] < t || e[s10] > n10)
      throw new Error(`Value out of range:${e[s10]} low: ${t}, high: ${n10}`);
}
function TA(e, t) {
  let n10 = new Float32Array(e), s10 = new Float32Array(t);
  if (n10.length !== s10.length)
    throw new Error(`Expected ArrayBuffer to be of length ${s10.length}, but it was ${n10.length}`);
  for (let r10 = 0; r10 < s10.length; r10++)
    if (n10[r10] !== s10[r10])
      throw new Error(`Expected ArrayBuffer value at ${r10} to be ${s10[r10]} but got ${n10[r10]} instead`);
}
function zk(e) {
  for (let t = 0; t < e.length; t++) {
    let n10 = e[t];
    Array.isArray(n10) ? zk(n10) : e[t] = El(n10);
  }
  return e;
}
var gde = "0.0.0";
function bde() {
  X2().set("PROD", true);
}
function yde() {
  X2().set("DEBUG", true);
}
function vde() {
  X2().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function Mk(e) {
  X2().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
U$(Mk);
function xde() {
  M2.disposeVariables();
}
function Ss() {
  return M2;
}
function lm() {
  return M2.memory();
}
function wde(e) {
  return M2.profile(e);
}
function j2(e, t) {
  return M2.tidy(e, t);
}
function Re2(e) {
  Ag(e).forEach((n10) => n10.dispose());
}
function Ht(e) {
  return M2.keep(e);
}
function kde(e) {
  return M2.time(e);
}
function Ide(e) {
  return M2.setBackend(e);
}
function Sde() {
  return M2.ready();
}
function Cde() {
  return M2.backendName;
}
function Nde(e) {
  M2.removeBackend(e);
}
function Tde(e) {
  return M2.findBackend(e);
}
function $de(e) {
  return M2.findBackendFactory(e);
}
function dp(e, t, n10 = 1) {
  return M2.registerBackend(e, t, n10);
}
function $A() {
  return M2.backend;
}
function _de(e, t) {
  X2().setPlatform(e, t);
}
function _A(e, t) {
  let n10 = _2(e, "a", "add"), s10 = _2(t, "b", "add");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(kr, r10);
}
var ie2 = L2({ add_: _A });
function AA(e, t) {
  let n10 = _2(e, "a", "floorDiv"), s10 = _2(t, "b", "floorDiv");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Oa, r10);
}
var Lk = L2({ floorDiv_: AA });
function EA(e, t) {
  let n10 = _2(e, "a", "div"), s10 = _2(t, "b", "div");
  if ([n10, s10] = vt(n10, s10), n10.dtype === "int32" && s10.dtype === "int32")
    return Lk(n10, s10);
  let r10 = { a: n10, b: s10 }, a10 = {};
  return M2.runKernel(Ea, r10, a10);
}
var xe2 = L2({ div_: EA });
function RA(e, t) {
  let n10 = _2(e, "a", "mul"), s10 = _2(t, "b", "mul");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Ka, r10);
}
var V2 = L2({ mul_: RA });
function DA(e) {
  let t = _2(e, "x", "abs");
  if (t.dtype === "complex64") {
    let n10 = { x: t };
    return M2.runKernel(jd, n10);
  } else {
    let n10 = { x: t };
    return M2.runKernel(ao, n10);
  }
}
var Mt = L2({ abs_: DA });
function FA(e) {
  let n10 = { x: _2(e, "x", "acos") };
  return M2.runKernel(nl, n10);
}
var OA = L2({ acos_: FA });
function PA(e) {
  let n10 = { x: _2(e, "x", "acosh") };
  return M2.runKernel(sl, n10);
}
var zA = L2({ acosh_: PA });
function MA(e) {
  O2(Array.isArray(e), () => "The argument passed to tf.addN() must be a list of tensors"), O2(e.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${e.length}`);
  let t = e.map((r10, a10) => _2(r10, `tensors${a10}`, "addN")), n10 = t[0];
  t.forEach((r10) => {
    if (r10.dtype !== n10.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), t.forEach((r10) => {
    if (!wr(r10.shape, n10.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  let s10 = t;
  return M2.runKernel(xa, s10);
}
var LA = L2({ addN_: MA });
function BA(e, t = null, n10 = false) {
  let r10 = { x: _2(e, "x", "all", "bool") }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(rl, r10, a10);
}
var Bk = L2({ all_: BA });
function VA(e, t = null, n10 = false) {
  let r10 = { x: _2(e, "x", "any", "bool") }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(al, r10, a10);
}
var cm = L2({ any_: VA });
function WA(e, t = 0) {
  let s10 = { x: _2(e, "x", "argMax") }, r10 = { axis: t };
  return M2.runKernel(wa, s10, r10);
}
var Gu = L2({ argMax_: WA });
function UA(e, t = 0) {
  let s10 = { x: _2(e, "x", "argMin") }, r10 = { axis: t };
  return M2.runKernel(il, s10, r10);
}
var GA = L2({ argMin_: UA });
function HA(e) {
  let n10 = { x: _2(e, "x", "asin") };
  return M2.runKernel(ol, n10);
}
var qA = L2({ asin_: HA });
function jA(e) {
  let n10 = { x: _2(e, "x", "asinh") };
  return M2.runKernel(ul, n10);
}
var KA = L2({ asinh_: jA });
function XA(e) {
  let n10 = { x: _2(e, "x", "atan") };
  return M2.runKernel(ll, n10);
}
var YA = L2({ atan_: XA });
function QA(e, t) {
  let n10 = _2(e, "a", "atan2"), s10 = _2(t, "b", "atan2");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(dl, r10);
}
var ZA = L2({ atan2_: QA });
function JA(e) {
  let n10 = { x: _2(e, "x", "atanh") };
  return M2.runKernel(cl, n10);
}
var eE = L2({ atanh_: JA });
function tE(e, t, n10, s10, r10 = "NHWC", a10) {
  let i10 = e[3], o10 = [...t, i10], u10 = Uk(r10);
  return Dl(e, o10, n10, a10, s10, null, null, u10);
}
function Vk(e, t, n10, s10, r10, a10, i10 = "channelsLast") {
  let [o10, u10] = vd(t), l10;
  if (i10 === "channelsLast")
    l10 = [o10, u10, e[3], e[3]];
  else if (i10 === "channelsFirst")
    l10 = [o10, u10, e[1], e[1]];
  else
    throw new Error(`Unknown dataFormat ${i10}`);
  return Dl(e, l10, n10, s10, r10, a10, false, i10);
}
function nE(e, t, n10, s10, r10, a10, i10 = "NDHWC") {
  let [o10, u10, l10] = dm(t), c10, p10;
  if (i10 === "NDHWC")
    p10 = "channelsLast", c10 = [o10, u10, l10, e[4], e[4]];
  else if (i10 === "NCDHW")
    p10 = "channelsFirst", c10 = [o10, u10, l10, e[1], e[1]];
  else
    throw new Error(`Unknown dataFormat ${i10}`);
  return Wk(e, c10, n10, s10, r10, false, p10, a10);
}
function Dl(e, t, n10, s10, r10, a10, i10 = false, o10 = "channelsLast") {
  let [u10, l10, c10, p10] = [-1, -1, -1, -1];
  if (o10 === "channelsLast")
    [u10, l10, c10, p10] = e;
  else if (o10 === "channelsFirst")
    [u10, p10, l10, c10] = e;
  else
    throw new Error(`Unknown dataFormat ${o10}`);
  let [d10, h10, , f10] = t, [m10, g10] = vd(n10), [b10, y10] = vd(s10), v10 = qi(d10, b10), x10 = qi(h10, y10), { padInfo: k10, outHeight: C10, outWidth: T10 } = aE(r10, l10, c10, m10, g10, v10, x10, a10, o10), E10 = i10 ? f10 * p10 : f10, A10;
  return o10 === "channelsFirst" ? A10 = [u10, E10, C10, T10] : o10 === "channelsLast" && (A10 = [u10, C10, T10, E10]), { batchSize: u10, dataFormat: o10, inHeight: l10, inWidth: c10, inChannels: p10, outHeight: C10, outWidth: T10, outChannels: E10, padInfo: k10, strideHeight: m10, strideWidth: g10, filterHeight: d10, filterWidth: h10, effectiveFilterHeight: v10, effectiveFilterWidth: x10, dilationHeight: b10, dilationWidth: y10, inShape: e, outShape: A10, filterShape: t };
}
function Wk(e, t, n10, s10, r10, a10 = false, i10 = "channelsLast", o10) {
  let [u10, l10, c10, p10, d10] = [-1, -1, -1, -1, -1];
  if (i10 === "channelsLast")
    [u10, l10, c10, p10, d10] = e;
  else if (i10 === "channelsFirst")
    [u10, d10, l10, c10, p10] = e;
  else
    throw new Error(`Unknown dataFormat ${i10}`);
  let [h10, f10, m10, , g10] = t, [b10, y10, v10] = dm(n10), [x10, k10, C10] = dm(s10), T10 = qi(h10, x10), E10 = qi(f10, k10), A10 = qi(m10, C10), { padInfo: P10, outDepth: R10, outHeight: F10, outWidth: $10 } = iE(r10, l10, c10, p10, b10, y10, v10, T10, E10, A10, o10), z10 = a10 ? g10 * d10 : g10, W10;
  return i10 === "channelsFirst" ? W10 = [u10, z10, R10, F10, $10] : i10 === "channelsLast" && (W10 = [u10, R10, F10, $10, z10]), { batchSize: u10, dataFormat: i10, inDepth: l10, inHeight: c10, inWidth: p10, inChannels: d10, outDepth: R10, outHeight: F10, outWidth: $10, outChannels: z10, padInfo: P10, strideDepth: b10, strideHeight: y10, strideWidth: v10, filterDepth: h10, filterHeight: f10, filterWidth: m10, effectiveFilterDepth: T10, effectiveFilterHeight: E10, effectiveFilterWidth: A10, dilationDepth: x10, dilationHeight: k10, dilationWidth: C10, inShape: e, outShape: W10, filterShape: t };
}
function sE(e, t, n10, s10, r10) {
  s10 == null && (s10 = Vg(e, t, n10));
  let a10 = e[0], i10 = e[1], o10 = Qr((a10 - t + 2 * s10) / n10 + 1, r10), u10 = Qr((i10 - t + 2 * s10) / n10 + 1, r10);
  return [o10, u10];
}
function rE(e, t, n10, s10, r10, a10) {
  r10 == null && (r10 = Vg(e, t, s10));
  let i10 = e[0], o10 = e[1], u10 = e[2], l10 = Qr((i10 - t + 2 * r10) / s10 + 1, a10), c10 = Qr((o10 - t + 2 * r10) / s10 + 1, a10), p10 = Qr((u10 - t + 2 * r10) / s10 + 1, a10);
  return [l10, c10, p10, n10];
}
function Vg(e, t, n10, s10 = 1) {
  let r10 = qi(t, s10);
  return Math.floor((e[0] * (n10 - 1) - n10 + r10) / 2);
}
function vd(e) {
  return typeof e == "number" ? [e, e, e] : e.length === 2 ? [e[0], e[1], 1] : e;
}
function dm(e) {
  return typeof e == "number" ? [e, e, e] : e;
}
function qi(e, t) {
  return t <= 1 ? e : e + (e - 1) * (t - 1);
}
function aE(e, t, n10, s10, r10, a10, i10, o10, u10) {
  let l10, c10, p10;
  if (typeof e == "number") {
    l10 = { top: e, bottom: e, left: e, right: e, type: e === 0 ? "VALID" : "NUMBER" };
    let h10 = sE([t, n10], a10, s10, e, o10);
    c10 = h10[0], p10 = h10[1];
  } else if (e === "same") {
    c10 = Math.ceil(t / s10), p10 = Math.ceil(n10 / r10);
    let d10 = Math.max(0, (c10 - 1) * s10 + a10 - t), h10 = Math.max(0, (p10 - 1) * r10 + i10 - n10), f10 = Math.floor(d10 / 2), m10 = d10 - f10, g10 = Math.floor(h10 / 2), b10 = h10 - g10;
    l10 = { top: f10, bottom: m10, left: g10, right: b10, type: "SAME" };
  } else if (e === "valid")
    l10 = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, c10 = Math.ceil((t - a10 + 1) / s10), p10 = Math.ceil((n10 - i10 + 1) / r10);
  else if (typeof e == "object") {
    let d10 = u10 === "channelsLast" ? e[1][0] : e[2][0], h10 = u10 === "channelsLast" ? e[1][1] : e[2][1], f10 = u10 === "channelsLast" ? e[2][0] : e[3][0], m10 = u10 === "channelsLast" ? e[2][1] : e[3][1];
    l10 = { top: d10, bottom: h10, left: f10, right: m10, type: d10 === 0 && h10 === 0 && f10 === 0 && m10 === 0 ? "VALID" : "EXPLICIT" }, c10 = Qr((t - a10 + d10 + h10) / s10 + 1, o10), p10 = Qr((n10 - i10 + f10 + m10) / r10 + 1, o10);
  } else
    throw Error(`Unknown padding parameter: ${e}`);
  return { padInfo: l10, outHeight: c10, outWidth: p10 };
}
function iE(e, t, n10, s10, r10, a10, i10, o10, u10, l10, c10) {
  let p10, d10, h10, f10;
  if (typeof e == "number") {
    p10 = { top: e, bottom: e, left: e, right: e, front: e, back: e, type: e === 0 ? "VALID" : "NUMBER" };
    let g10 = rE([t, n10, s10, 1], o10, 1, r10, e, c10);
    d10 = g10[0], h10 = g10[1], f10 = g10[2];
  } else if (e === "same") {
    d10 = Math.ceil(t / r10), h10 = Math.ceil(n10 / a10), f10 = Math.ceil(s10 / i10);
    let m10 = (d10 - 1) * r10 + o10 - t, g10 = (h10 - 1) * a10 + u10 - n10, b10 = (f10 - 1) * i10 + l10 - s10, y10 = Math.floor(m10 / 2), v10 = m10 - y10, x10 = Math.floor(g10 / 2), k10 = g10 - x10, C10 = Math.floor(b10 / 2), T10 = b10 - C10;
    p10 = { top: x10, bottom: k10, left: C10, right: T10, front: y10, back: v10, type: "SAME" };
  } else if (e === "valid")
    p10 = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }, d10 = Math.ceil((t - o10 + 1) / r10), h10 = Math.ceil((n10 - u10 + 1) / a10), f10 = Math.ceil((s10 - l10 + 1) / i10);
  else
    throw Error(`Unknown padding parameter: ${e}`);
  return { padInfo: p10, outDepth: d10, outHeight: h10, outWidth: f10 };
}
function Qr(e, t) {
  if (!t)
    return Math.trunc(e);
  switch (t) {
    case "round":
      return Math.round(e);
    case "ceil":
      return Math.ceil(e);
    case "floor":
      return Math.floor(e);
    default:
      throw new Error(`Unknown roundingMode ${t}`);
  }
}
function fr(e) {
  let [t, n10, s10] = vd(e);
  return t === 1 && n10 === 1 && s10 === 1;
}
function Ps(e, t) {
  return fr(e) || fr(t);
}
function Uk(e) {
  if (e === "NHWC")
    return "channelsLast";
  if (e === "NCHW")
    return "channelsFirst";
  throw new Error(`Unknown dataFormat ${e}`);
}
function pn(e, t, n10) {
  if (n10 != null) {
    if (typeof t == "string")
      throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n10} but got pad ${t}.`);
    if (typeof t == "number")
      O2(Xi(t), () => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n10} but got pad ${t}.`);
    else if (typeof t == "object")
      t.forEach((s10) => {
        s10.forEach((r10) => {
          O2(Xi(r10), () => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n10} but got pad ${r10}.`);
        });
      });
    else
      throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);
  }
}
function oE(e, t) {
  let s10 = { x: _2(e, "x", "reshape", "string_or_numeric") }, r10 = { shape: t };
  return M2.runKernel(Ao, s10, r10);
}
var G2 = L2({ reshape_: oE });
function uE(e, t, n10, s10, r10) {
  let a10 = _2(e, "x", "avgPool", "float32"), i10 = 1;
  O2(Ps(n10, i10), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n10} and dilations '${i10}'`);
  let o10 = a10, u10 = false;
  a10.rank === 3 && (u10 = true, o10 = G2(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]])), O2(o10.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${o10.rank}.`), pn("avgPool", s10, r10);
  let l10 = { x: o10 }, c10 = { filterSize: t, strides: n10, pad: s10, dimRoundingMode: r10 }, p10 = M2.runKernel(ka, l10, c10);
  return p10 = ce2(p10, a10.dtype), u10 ? G2(p10, [p10.shape[1], p10.shape[2], p10.shape[3]]) : p10;
}
var Wg = L2({ avgPool_: uE });
function lE(e, t, n10, s10, r10, a10 = "NDHWC") {
  let i10 = _2(e, "x", "avgPool3d", "float32"), o10 = i10, u10 = false;
  i10.rank === 4 && (u10 = true, o10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2], i10.shape[3]])), O2(o10.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${o10.rank}.`), O2(a10 === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a10}`), pn("avgPool3d", s10, r10);
  let l10 = { x: o10 }, c10 = { filterSize: t, strides: n10, pad: s10, dimRoundingMode: r10, dataFormat: a10 }, p10 = M2.runKernel(Hd, l10, c10);
  return p10 = ce2(p10, o10.dtype), u10 ? G2(p10, [p10.shape[1], p10.shape[2], p10.shape[3], p10.shape[4]]) : p10;
}
var Gk = L2({ avgPool3d_: lE });
function cE(e, t = 0) {
  O2(e.length >= 1, () => "Pass at least one tensor to concat");
  let n10 = Uu(e, "tensors", "concat", "string_or_numeric");
  if (n10[0].dtype === "complex64" && n10.forEach((a10) => {
    if (a10.dtype !== "complex64")
      throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a10.dtype}. `);
  }), n10.length === 1)
    return lr(n10[0]);
  let s10 = n10, r10 = { axis: t };
  return M2.runKernel(oo, s10, r10);
}
var Ft = L2({ concat_: cE });
function dE(e) {
  let n10 = { x: _2(e, "x", "sigmoid", "float32") };
  return M2.runKernel(si, n10);
}
var qs = L2({ sigmoid_: dE });
function pE(e, t, n10) {
  let s10 = _2(e, "x", "slice", "string_or_numeric");
  if (s10.rank === 0)
    throw new Error("Slicing scalar is not possible");
  let r10 = { x: s10 }, a10 = { begin: t, size: n10 };
  return M2.runKernel(Oo, r10, a10);
}
var He = L2({ slice_: pE });
function hE(e) {
  let n10 = { x: _2(e, "x", "tanh", "float32") };
  return M2.runKernel(li, n10);
}
var Hu = L2({ tanh_: hE });
function fE(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "forgetBias", "basicLSTMCell"), o10 = _2(t, "lstmKernel", "basicLSTMCell"), u10 = _2(n10, "lstmBias", "basicLSTMCell"), l10 = _2(s10, "data", "basicLSTMCell"), c10 = _2(r10, "c", "basicLSTMCell"), p10 = _2(a10, "h", "basicLSTMCell"), d10 = Ft([l10, p10], 1), h10 = We(d10, o10), f10 = ie2(h10, u10), m10 = f10.shape[0], g10 = f10.shape[1] / 4, b10 = [m10, g10], y10 = He(f10, [0, 0], b10), v10 = He(f10, [0, g10], b10), x10 = He(f10, [0, g10 * 2], b10), k10 = He(f10, [0, g10 * 3], b10), C10 = ie2(V2(qs(y10), Hu(v10)), V2(c10, qs(ie2(i10, x10)))), T10 = V2(Hu(C10), qs(k10));
  return [C10, T10];
}
var Ade = L2({ basicLSTMCell_: fE });
function mE(e, t, n10) {
  let s10 = _2(e, "x", "batchToSpaceND"), r10 = t.reduce((o10, u10) => o10 * u10);
  O2(s10.rank >= 1 + t.length, () => `input rank is ${s10.rank} but should be > than blockShape.length ${t.length}`), O2(n10.length === t.length, () => `crops.length is ${n10.length} but should be equal to blockShape.length  ${t.length}`), O2(s10.shape[0] % r10 === 0, () => `input tensor batch is ${s10.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r10}`);
  let a10 = { x: s10 }, i10 = { blockShape: t, crops: n10 };
  return M2.runKernel(io, a10, i10);
}
var Ug = L2({ batchToSpaceND_: mE });
function gE(e) {
  let t;
  return e.rank === 0 || e.rank === 1 ? t = G2(e, [1, 1, 1, e.size]) : e.rank === 2 ? t = G2(e, [1, 1, e.shape[0], e.shape[1]]) : e.rank === 3 ? t = G2(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : t = e, t;
}
function bE(e, t, n10, s10, r10, a10) {
  a10 == null && (a10 = 1e-3);
  let i10 = _2(e, "x", "batchNorm"), o10 = _2(t, "mean", "batchNorm"), u10 = _2(n10, "variance", "batchNorm"), l10;
  r10 != null && (l10 = _2(r10, "scale", "batchNorm"));
  let c10;
  s10 != null && (c10 = _2(s10, "offset", "batchNorm")), O2(o10.rank === u10.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), O2(c10 == null || o10.rank === c10.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), O2(l10 == null || o10.rank === l10.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let d10 = { x: gE(i10), scale: l10, offset: c10, mean: o10, variance: u10 }, h10 = { varianceEpsilon: a10 }, f10 = M2.runKernel(Pa, d10, h10);
  return G2(f10, i10.shape);
}
var qu = L2({ batchNorm_: bE });
function yE(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "x", "batchNorm"), o10 = _2(t, "mean", "batchNorm"), u10 = _2(n10, "variance", "batchNorm"), l10;
  r10 != null && (l10 = _2(r10, "scale", "batchNorm"));
  let c10;
  return s10 != null && (c10 = _2(s10, "offset", "batchNorm")), O2(i10.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${i10.rank}.`), O2(o10.rank === 2 || o10.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o10.rank}.`), O2(u10.rank === 2 || u10.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u10.rank}.`), l10 != null && O2(l10.rank === 2 || l10.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l10.rank}.`), c10 != null && O2(c10.rank === 2 || c10.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c10.rank}.`), qu(i10, o10, u10, c10, l10, a10);
}
var vE = L2({ batchNorm2d_: yE });
function xE(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "x", "batchNorm"), o10 = _2(t, "mean", "batchNorm"), u10 = _2(n10, "variance", "batchNorm"), l10;
  r10 != null && (l10 = _2(r10, "scale", "batchNorm"));
  let c10;
  return s10 != null && (c10 = _2(s10, "offset", "batchNorm")), O2(i10.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${i10.rank}.`), O2(o10.rank === 3 || o10.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o10.rank}.`), O2(u10.rank === 3 || u10.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u10.rank}.`), l10 != null && O2(l10.rank === 3 || l10.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l10.rank}.`), c10 != null && O2(c10.rank === 3 || c10.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c10.rank}.`), qu(i10, o10, u10, c10, l10, a10);
}
var wE = L2({ batchNorm3d_: xE });
function kE(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "x", "batchNorm"), o10 = _2(t, "mean", "batchNorm"), u10 = _2(n10, "variance", "batchNorm"), l10;
  r10 != null && (l10 = _2(r10, "scale", "batchNorm"));
  let c10;
  return s10 != null && (c10 = _2(s10, "offset", "batchNorm")), O2(i10.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${i10.rank}.`), O2(o10.rank === 4 || o10.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o10.rank}.`), O2(u10.rank === 4 || u10.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u10.rank}.`), l10 != null && O2(l10.rank === 4 || l10.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l10.rank}.`), c10 != null && O2(c10.rank === 4 || c10.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c10.rank}.`), qu(i10, o10, u10, c10, l10, a10);
}
var IE = L2({ batchNorm4d_: kE });
function SE(e, t, n10) {
  let s10 = _2(e, "x", "bincount"), r10 = _2(t, "weights", "bincount");
  O2(s10.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${s10.dtype}`), O2(n10 >= 0, () => `size must be non-negative, but got ${n10}.`), O2(r10.size === s10.size || r10.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s10.shape}, weights shape: ${r10.shape}.`);
  let a10 = { x: s10, weights: r10 }, i10 = { size: n10 };
  return M2.runKernel(ig, a10, i10);
}
var Hk = L2({ bincount_: SE });
function CE(e, t) {
  let n10 = _2(e, "s0", "broadcastArgs", "int32"), s10 = _2(t, "s1", "broadcastArgs", "int32");
  if (n10.rank !== 1)
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n10.rank}`);
  if (s10.rank !== 1)
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s10.rank}`);
  let r10 = { s0: n10, s1: s10 };
  return M2.runKernel(og, r10);
}
var NE = L2({ broadcastArgs_: CE });
function TE(e, t) {
  let n10 = _2(e, "broadcastTo", "x"), s10 = n10.shape;
  if (t.some((l10) => !(l10 > 0) || l10 % 1 !== 0))
    throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);
  if (t.length < n10.rank)
    throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n10.rank}.`);
  if (t.length > n10.rank) {
    let l10 = n10.shape.slice();
    for (; l10.length < t.length; )
      l10.unshift(1);
    n10 = G2(n10, l10);
  }
  let r10 = n10.shape, a10 = Array.from(t);
  for (let l10 = t.length - 1; l10 >= 0; l10--)
    if (r10[l10] === t[l10])
      a10[l10] = 1;
    else if (n10.shape[l10] !== 1)
      throw new Error(`broadcastTo(): [${s10}] cannot be broadcast to [${t}].`);
  if (a10.map((l10, c10) => l10 > 1 ? c10 : -1).filter((l10) => l10 >= 0).length === 0)
    return lr(n10);
  let o10 = { x: n10 }, u10 = { reps: a10 };
  return M2.runKernel(Sr, o10, u10);
}
var td = L2({ broadcastTo_: TE });
function $E(e) {
  let n10 = { x: _2(e, "x", "ceil", "float32") };
  return M2.runKernel(Ca, n10);
}
var _E = L2({ ceil_: $E });
function AE(e, t, n10) {
  let s10 = _2(e, "x", "clipByValue");
  O2(t <= n10, () => `Error in clip: min (${t}) must be less than or equal to max (${n10}).`);
  let r10 = { x: s10 }, a10 = { clipValueMin: t, clipValueMax: n10 };
  return M2.runKernel(Ir, r10, a10);
}
var Bn = L2({ clipByValue_: AE });
function EE(e) {
  return Ft(e, 0);
}
var RE = L2({ concat1d_: EE });
function DE(e, t) {
  return Ft(e, t);
}
var FE = L2({ concat2d_: DE });
function OE(e, t) {
  return Ft(e, t);
}
var PE = L2({ concat3d_: OE });
function zE(e, t) {
  return Ft(e, t);
}
var ME = L2({ concat4d_: zE });
function LE(e, t, n10, s10, r10 = "NHWC", a10 = [1, 1], i10) {
  let o10 = _2(e, "x", "conv2d", "float32"), u10 = _2(t, "filter", "conv2d", "float32"), l10 = o10, c10 = false;
  o10.rank === 3 && (c10 = true, l10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]])), O2(l10.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${l10.rank}.`), O2(u10.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${u10.rank}.`), pn("conv2d", s10, i10);
  let p10 = r10 === "NHWC" ? l10.shape[3] : l10.shape[1];
  O2(p10 === u10.shape[2], () => `Error in conv2d: depth of input (${p10}) must match input depth for filter ${u10.shape[2]}.`), O2(Ps(n10, a10), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n10} and dilations '${a10}'`);
  let d10 = { x: l10, filter: u10 }, h10 = { strides: n10, pad: s10, dataFormat: r10, dilations: a10, dimRoundingMode: i10 }, f10 = M2.runKernel(Na, d10, h10);
  return c10 ? G2(f10, [f10.shape[1], f10.shape[2], f10.shape[3]]) : f10;
}
var ua = L2({ conv2d_: LE });
function BE(e, t, n10, s10, r10 = "NWC", a10 = 1, i10) {
  let o10 = _2(e, "x", "conv1d"), u10 = _2(t, "filter", "conv1d"), l10 = o10, c10 = false;
  o10.rank === 2 && (c10 = true, l10 = G2(o10, [1, o10.shape[0], o10.shape[1]])), O2(l10.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${l10.rank}.`), O2(u10.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${u10.rank}.`), pn("conv1d", s10, i10), O2(l10.shape[2] === u10.shape[1], () => `Error in conv1d: depth of input (${l10.shape[2]}) must match input depth for filter ${u10.shape[1]}.`), O2(Ps(n10, a10), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n10} and dilation '${a10}'`), O2(r10 === "NWC", () => `Error in conv1d: got dataFormat of ${r10} but only NWC is currently supported.`);
  let p10 = G2(u10, [1, u10.shape[0], u10.shape[1], u10.shape[2]]), d10 = G2(l10, [l10.shape[0], 1, l10.shape[1], l10.shape[2]]), g10 = ua(d10, p10, [1, n10], s10, "NHWC", [1, a10], i10);
  return c10 ? G2(g10, [g10.shape[2], g10.shape[3]]) : G2(g10, [g10.shape[0], g10.shape[2], g10.shape[3]]);
}
var qk = L2({ conv1d_: BE });
function VE(e, t, n10, s10, r10, a10 = "NHWC", i10) {
  O2(e.length === t.rank, () => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);
  let o10 = e, u10 = t, l10 = false;
  t.rank === 3 && (l10 = true, u10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2]]), o10 = [1, e[0], e[1], e[2]]), O2(o10.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${o10.length}.`), O2(u10.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${u10.rank}`), O2(n10.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${n10.rank}`);
  let c10 = a10 === "NHWC" ? o10[3] : o10[1], p10 = a10 === "NHWC" ? u10.shape[3] : u10.shape[1];
  O2(c10 === n10.shape[2], () => `Error in conv2dDerInput: depth of input (${c10}) must match input depth for filter ${n10.shape[2]}.`), O2(p10 === n10.shape[3], () => `Error in conv2dDerInput: depth of output (${p10}) must match output depth for filter ${n10.shape[3]}.`), pn("conv2dDerInput", r10, i10);
  let d10 = { dy: u10, filter: n10 }, h10 = { strides: s10, pad: r10, dataFormat: a10, dimRoundingMode: i10, inputShape: o10 }, f10 = M2.runKernel(Ta, d10, h10);
  return l10 ? G2(f10, [f10.shape[1], f10.shape[2], f10.shape[3]]) : f10;
}
var Gg = L2({ conv2DBackpropInput_: VE });
function WE(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "x", "conv2dTranspose"), o10 = _2(t, "filter", "conv2dTranspose");
  return Gg(n10, i10, o10, s10, r10, "NHWC", a10);
}
var jk = L2({ conv2dTranspose_: WE });
function UE(e, t, n10, s10, r10 = "NDHWC", a10 = [1, 1, 1]) {
  let i10 = _2(e, "x", "conv3d"), o10 = _2(t, "filter", "conv3d"), u10 = i10, l10 = false;
  i10.rank === 4 && (l10 = true, u10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2], i10.shape[3]])), O2(u10.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${u10.rank}.`), O2(o10.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${o10.rank}.`), O2(u10.shape[4] === o10.shape[3], () => `Error in conv3d: depth of input (${u10.shape[4]}) must match input depth for filter ${o10.shape[3]}.`), O2(Ps(n10, a10), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n10} and dilations '${a10}'`), O2(r10 === "NDHWC", () => `Error in conv3d: got dataFormat of ${r10} but only NDHWC is currently supported.`);
  let c10 = { x: u10, filter: o10 }, p10 = { strides: n10, pad: s10, dataFormat: r10, dilations: a10 }, d10 = M2.runKernel(Kd, c10, p10);
  return l10 ? G2(d10, [d10.shape[1], d10.shape[2], d10.shape[3], d10.shape[4]]) : d10;
}
var Kk = L2({ conv3d_: UE });
function GE(e, t, n10, s10, r10) {
  O2(e.length === t.rank, () => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);
  let a10 = e, i10 = t, o10 = false;
  t.rank === 4 && (o10 = true, i10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), a10 = [1, e[0], e[1], e[2], e[3]]);
  let u10 = a10[4], l10 = i10.shape[4];
  O2(a10.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${a10.length}.`), O2(i10.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${i10.rank}`), O2(n10.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${n10.rank}`), O2(u10 === n10.shape[3], () => `Error in conv3dDerInput: depth of input (${u10}) must match input depth for filter ${n10.shape[3]}.`), O2(l10 === n10.shape[4], () => `Error in conv3dDerInput: depth of output (${l10}) must match output depth for filter ${n10.shape[4]}.`);
  let c10 = { dy: i10, filter: n10 }, p10 = { pad: r10, strides: s10, inputShape: a10 }, d10 = M2.runKernel(cg, c10, p10);
  return o10 ? G2(d10, [d10.shape[1], d10.shape[2], d10.shape[3], d10.shape[4]]) : d10;
}
var Xk = L2({ conv3DBackpropInput_: GE });
function HE(e, t, n10, s10, r10) {
  let a10 = _2(e, "x", "conv3dTranspose"), i10 = _2(t, "filter", "conv3dTranspose");
  return Xk(n10, a10, i10, s10, r10);
}
var qE = L2({ conv3dTranspose_: HE });
function jE(e) {
  let n10 = { x: _2(e, "x", "cos", "float32") };
  return M2.runKernel($a, n10);
}
var Hg = L2({ cos_: jE });
function KE(e) {
  let n10 = { x: _2(e, "x", "cosh", "float32") };
  return M2.runKernel(_a, n10);
}
var Yk = L2({ cosh_: KE });
function XE(e, t = 0, n10 = false, s10 = false) {
  let a10 = { x: _2(e, "x", "cumsum") }, i10 = { axis: t, exclusive: n10, reverse: s10 };
  return M2.runKernel(uo, a10, i10);
}
var Qk = L2({ cumsum_: XE });
function YE(e, t, n10, s10 = false) {
  let r10 = _2(e, "x", "denseBincount"), a10 = _2(t, "weights", "denseBincount");
  O2(r10.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${r10.dtype}`), O2(r10.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${r10.rank}.`), O2(n10 >= 0, () => `size must be non-negative, but got ${n10}.`), O2(a10.size === r10.size || a10.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r10.shape}, weights shape: ${a10.shape}.`);
  let i10 = { x: r10, weights: a10 }, o10 = { size: n10, binaryOutput: s10 };
  return M2.runKernel(dg, i10, o10);
}
var QE = L2({ denseBincount_: YE });
function ZE(e, t, n10 = "NHWC") {
  let s10 = _2(e, "x", "depthToSpace", "float32"), r10 = n10 === "NHWC" ? s10.shape[1] : s10.shape[2], a10 = n10 === "NHWC" ? s10.shape[2] : s10.shape[3], i10 = n10 === "NHWC" ? s10.shape[3] : s10.shape[1];
  O2(t > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${t}`), O2(r10 * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${r10} and ${t}  for depthToSpace with input shape
    ${s10.shape}`), O2(a10 * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${a10} and ${t} for depthToSpace with input shape
        ${s10.shape}`), O2(i10 % (t * t) === 0, () => `Dimension size must be evenly divisible by ${t * t} but is ${i10} for depthToSpace with input shape ${s10.shape}`);
  let o10 = { x: s10 }, u10 = { blockSize: t, dataFormat: n10 };
  return M2.runKernel(co, o10, u10);
}
var JE = L2({ depthToSpace_: ZE });
function eR(e, t, n10, s10, r10 = "NHWC", a10 = [1, 1], i10) {
  let o10 = _2(e, "x", "depthwiseConv2d", "float32"), u10 = _2(t, "filter", "depthwiseConv2d", "float32"), l10 = o10, c10 = false;
  o10.rank === 3 && (c10 = true, l10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]])), O2(l10.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${l10.rank}.`), O2(u10.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${u10.rank}.`), O2(l10.shape[3] === u10.shape[2], () => `Error in depthwiseConv2d: number of input channels (${l10.shape[3]}) must match the inChannels dimension in filter ${u10.shape[2]}.`), pn("depthwiseConv2d", s10, i10);
  let p10 = { x: l10, filter: u10 }, d10 = { strides: n10, pad: s10, dataFormat: r10, dilations: a10, dimRoundingMode: i10 }, h10 = M2.runKernel(Aa, p10, d10);
  return c10 ? G2(h10, [h10.shape[1], h10.shape[2], h10.shape[3]]) : h10;
}
var pp = L2({ depthwiseConv2d_: eR });
function tR(e) {
  let n10 = { x: _2(e, "x", "diag") };
  return M2.runKernel(fg, n10);
}
var Ede = L2({ diag_: tR });
function nR(e, t, n10, s10, r10 = [1, 1], a10 = "NHWC") {
  let i10 = _2(e, "x", "dilation2d"), o10 = _2(t, "filter", "dilation2d");
  O2(i10.rank === 3 || i10.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${i10.rank}.`), O2(o10.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${o10.rank}.`), O2(a10 === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a10}`);
  let u10 = i10, l10 = false;
  i10.rank === 3 && (u10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]]), l10 = true);
  let c10 = { x: u10, filter: o10 }, p10 = { strides: n10, pad: s10, dilations: r10 }, d10 = M2.runKernel(Xd, c10, p10);
  return l10 ? G2(d10, [d10.shape[1], d10.shape[2], d10.shape[3]]) : d10;
}
var sR = L2({ dilation2d_: nR });
function rR(e, t) {
  let n10 = _2(e, "a", "equal", "string_or_numeric"), s10 = _2(t, "b", "equal", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(po, r10);
}
var qn = L2({ equal_: rR });
function aR(e, t, n10) {
  let s10 = _2(t, "a", "where"), r10 = _2(n10, "b", "where"), a10 = _2(e, "condition", "where", "bool"), i10 = it(it(a10.shape, s10.shape), r10.shape), o10 = td(a10, i10), u10 = td(s10, i10), l10 = td(r10, i10), c10 = { condition: o10, t: u10, e: l10 };
  return M2.runKernel(Fo, c10);
}
var vn = L2({ where_: aR });
function iR(e) {
  let n10 = { x: _2(e, "x", "zerosLike") };
  return M2.runKernel(Go, n10);
}
var je = L2({ zerosLike_: iR });
function oR(e, t) {
  let n10 = _2(e, "a", "div"), s10 = _2(t, "b", "div");
  [n10, s10] = vt(n10, s10);
  let r10 = xe2(n10, s10), a10 = je(r10), i10 = qn(s10, a10);
  return vn(i10, a10, r10);
}
var uR = L2({ divNoNan_: oR });
function lR(e, t) {
  let n10 = _2(e, "t1", "dot"), s10 = _2(t, "t2", "dot");
  O2((n10.rank === 1 || n10.rank === 2) && (s10.rank === 1 || s10.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n10.rank} and ${s10.rank}.`);
  let r10 = n10.rank === 1 ? n10.size : n10.shape[1], a10 = s10.rank === 1 ? s10.size : s10.shape[0];
  if (O2(r10 === a10, () => `Error in dot: inner dimensions of inputs must match, but got ${r10} and ${a10}.`), n10.rank === 1 && s10.rank === 1) {
    let i10 = G2(n10, [1, -1]), o10 = G2(s10, [-1, 1]), u10 = We(i10, o10);
    return G2(u10, []);
  } else if (n10.rank === 1 && s10.rank === 2) {
    let i10 = G2(n10, [1, -1]), o10 = G2(s10, [s10.shape[0], s10.shape[1]]), u10 = We(i10, o10);
    return G2(u10, [u10.size]);
  } else if (n10.rank === 2 && s10.rank === 1) {
    let i10 = G2(s10, [-1, 1]), o10 = We(n10, i10);
    return G2(o10, [o10.size]);
  } else {
    let i10 = G2(s10, [s10.shape[0], s10.shape[1]]);
    return We(n10, i10);
  }
}
var Rde = L2({ dot_: lR });
function cR(e, ...t) {
  let n10 = t.map((r10, a10) => _2(r10, `tensors${a10}`, "einsum")), s10 = { equation: e };
  return M2.runKernel(Yd, n10, s10);
}
var dR = L2({ einsum_: cR });
function pR(e) {
  let n10 = { x: _2(e, "x", "elu", "float32") };
  return M2.runKernel(Ra, n10);
}
var hp = L2({ elu_: pR });
function hR(e) {
  let t = _2(e, "x", "erf");
  O2(t.dtype === "int32" || t.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), t.dtype === "int32" && (t = ce2(t, "float32"));
  let n10 = { x: t };
  return M2.runKernel(pl, n10);
}
var fR = L2({ erf_: hR });
function mR(e) {
  let n10 = { x: _2(e, "x", "exp") };
  return M2.runKernel(Da, n10);
}
var jn = L2({ exp_: mR });
function gR(e, t = 0) {
  let n10 = _2(e, "x", "expandDims", "string_or_numeric");
  O2(t <= n10.rank, () => "Axis must be <= rank of the tensor");
  let s10 = { input: n10 }, r10 = { dim: t };
  return M2.runKernel(ho, s10, r10);
}
var On = L2({ expandDims_: gR });
function bR(e) {
  let n10 = { x: _2(e, "x", "expm1") };
  return M2.runKernel(fo, n10);
}
var yR = L2({ expm1_: bR });
function vR(e, t) {
  let n10 = _2(e, "x", "tile", "string_or_numeric");
  O2(n10.rank === t.length, () => `Error in transpose: rank of input ${n10.rank} must match length of reps ${t}.`);
  let s10 = { x: n10 }, r10 = { reps: t };
  return M2.runKernel(Sr, s10, r10);
}
var cs = L2({ tile_: vR });
function xR(e, t, n10, s10 = "float32") {
  t == null && (t = e);
  let r10 = De([e, t], s10), a10 = e <= t ? e : t;
  for (let o10 = 0; o10 < a10; ++o10)
    r10.set(1, o10, o10);
  let i10 = G2(r10.toTensor(), [e, t]);
  if (n10 == null)
    return i10;
  if (n10.length === 1)
    return cs(On(i10, 0), [n10[0], 1, 1]);
  if (n10.length === 2)
    return cs(On(On(i10, 0), 0), [n10[0], n10[1], 1, 1]);
  if (n10.length === 3)
    return cs(On(On(On(i10, 0), 0), 0), [n10[0], n10[1], n10[2], 1, 1]);
  throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n10.length}D.`);
}
var Zk = L2({ eye_: xR });
function Fl(e, t, n10) {
  let s10 = { shape: e, value: t, dtype: n10 };
  return M2.runKernel(hl, {}, s10);
}
function wR(e) {
  let n10 = { x: _2(e, "x", "floor", "float32") };
  return M2.runKernel(Fa, n10);
}
var fp = L2({ floor_: wR });
function kR(e, t, n10 = 0, s10 = 0) {
  let r10 = _2(e, "x", "gather"), a10 = _2(t, "indices", "gather", "int32"), i10 = { x: r10, indices: a10 }, o10 = { axis: n10, batchDims: s10 };
  return M2.runKernel(go, i10, o10);
}
var ju = L2({ gather_: kR });
function IR(e, t) {
  let n10 = _2(e, "a", "greater", "string_or_numeric"), s10 = _2(t, "b", "greater", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(yo, r10);
}
var Wn = L2({ greater_: IR });
function SR(e, t) {
  let n10 = _2(e, "a", "greaterEqual", "string_or_numeric"), s10 = _2(t, "b", "greaterEqual", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(za, r10);
}
var jo = L2({ greaterEqual_: SR });
function CR(e) {
  let n10 = { input: _2(e, "input", "imag") };
  return M2.runKernel(Qd, n10);
}
var qg = L2({ imag_: CR });
function NR(e) {
  let n10 = { x: _2(e, "x", "isFinite") };
  return M2.runKernel(fl, n10);
}
var Dde = L2({ isFinite_: NR });
function TR(e) {
  let n10 = { x: _2(e, "x", "isInf") };
  return M2.runKernel(ml, n10);
}
var Fde = L2({ isInf_: TR });
function $R(e) {
  let n10 = { x: _2(e, "x", "isNaN") };
  return M2.runKernel(gl, n10);
}
var _R = L2({ isNaN_: $R });
function AR(e, t = 0.2) {
  let s10 = { x: _2(e, "x", "leakyRelu") }, r10 = { alpha: t };
  return M2.runKernel(La, s10, r10);
}
var jg = L2({ leakyRelu_: AR });
function ER(e, t) {
  let n10 = _2(e, "a", "less", "string_or_numeric"), s10 = _2(t, "b", "less", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(vo, r10);
}
var Jk = L2({ less_: ER });
function RR(e, t) {
  let n10 = _2(e, "a", "lessEqual", "string_or_numeric"), s10 = _2(t, "b", "lessEqual", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(xo, r10);
}
var Ko = L2({ lessEqual_: RR });
function DR(e, t, n10) {
  if (n10 <= 0)
    throw new Error("The number of values should be positive.");
  let s10 = { start: e, stop: t, num: n10 };
  return M2.runKernel(yg, {}, s10);
}
function FR(e, t = 5, n10 = 1, s10 = 1, r10 = 0.5) {
  let a10 = _2(e, "x", "localResponseNormalization");
  O2(a10.rank === 4 || a10.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a10.rank}.`), O2(Xi(t), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);
  let i10 = a10, o10 = false;
  a10.rank === 3 && (o10 = true, i10 = G2(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]]));
  let u10 = { x: i10 }, l10 = { depthRadius: t, bias: n10, alpha: s10, beta: r10 }, c10 = M2.runKernel(Jd, u10, l10);
  return o10 ? G2(c10, [c10.shape[1], c10.shape[2], c10.shape[3]]) : c10;
}
var OR = L2({ localResponseNormalization_: FR });
function PR(e) {
  let n10 = { x: _2(e, "x", "log", "float32") };
  return M2.runKernel(Ba, n10);
}
var Kn = L2({ log_: PR });
function zR(e) {
  let n10 = { x: _2(e, "x", "log1p") };
  return M2.runKernel(bl, n10);
}
var Kg = L2({ log1p_: zR });
function Ode(e) {
  return O2(hr(e), () => "The f passed in grad(f) must be a function"), (t, n10) => {
    let s10 = _2(t, "x", "tf.grad", "string_or_numeric"), r10 = n10 != null ? _2(n10, "dy", "tf.grad") : null;
    return M2.tidy(() => {
      let { value: a10, grads: i10 } = M2.gradients(() => e(s10), [s10], r10);
      return r10 != null && dn(a10.shape, r10.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), mp(i10), i10[0];
    });
  };
}
function Pde(e) {
  return O2(hr(e), () => "The f passed in grads(f) must be a function"), (t, n10) => {
    O2(Array.isArray(t), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    let s10 = Uu(t, "args", "tf.grads", "string_or_numeric"), r10 = n10 != null ? _2(n10, "dy", "tf.grads") : null;
    return M2.tidy(() => {
      let { value: a10, grads: i10 } = M2.gradients(() => e(...s10), s10, r10);
      return r10 != null && dn(a10.shape, r10.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mp(i10), i10;
    });
  };
}
function zde(e) {
  return O2(hr(e), () => "The f passed in valueAndGrad(f) must be a function"), (t, n10) => {
    O2(t instanceof et, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), O2(n10 == null || n10 instanceof et, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    let { grads: s10, value: r10 } = M2.gradients(() => e(t), [t], n10);
    return mp(s10), { grad: s10[0], value: r10 };
  };
}
function Mde(e) {
  return O2(hr(e), () => "The f passed in valueAndGrads(f) must be a function"), (t, n10) => {
    O2(Array.isArray(t) && t.every((r10) => r10 instanceof et), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), O2(n10 == null || n10 instanceof et, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    let s10 = M2.gradients(() => e(...t), t, n10);
    return n10 != null && dn(s10.value.shape, n10.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mp(s10.grads), s10;
  };
}
function MR(e, t) {
  O2(hr(e), () => "The f passed in variableGrads(f) must be a function"), O2(t == null || Array.isArray(t) && t.every((l10) => l10 instanceof md), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  let n10 = t != null;
  if (!n10) {
    t = [];
    for (let l10 in M2.registeredVariables)
      t.push(M2.registeredVariables[l10]);
  }
  let s10 = n10 ? t.filter((l10) => !l10.trainable) : null, r10 = t.length;
  t = t.filter((l10) => l10.trainable), O2(t.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${r10} variables is trainable.`);
  let a10 = true, { value: i10, grads: o10 } = M2.gradients(e, t, null, a10);
  O2(o10.some((l10) => l10 != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), O2(i10.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i10.rank} tensor`);
  let u10 = {};
  return t.forEach((l10, c10) => {
    o10[c10] != null && (u10[l10.name] = o10[c10]);
  }), s10 != null && s10.forEach((l10) => u10[l10.name] = null), { value: i10, grads: u10 };
}
function js(e) {
  return M2.customGrad(e);
}
function mp(e) {
  if (e.filter((n10) => n10 == null).length > 0)
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
}
function LR(e) {
  let n10 = { x: _2(e, "x", "neg") };
  return M2.runKernel(ko, n10);
}
var kt = L2({ neg_: LR });
function BR(e) {
  let n10 = { x: _2(e, "x", "softplus") };
  return M2.runKernel(Nl, n10);
}
var Ol = L2({ softplus_: BR });
function VR(e) {
  let t = _2(e, "x", "logSigmoid");
  return js((s10) => ({ value: kt(Ol(kt(s10))), gradFunc: (i10) => V2(i10, qs(kt(s10))) }))(t);
}
var Lde = L2({ logSigmoid_: VR });
function WR(e, t = null, n10 = false) {
  let r10 = { x: _2(e, "x", "max") }, a10 = { reductionIndices: t, keepDims: n10 };
  return M2.runKernel(Va, r10, a10);
}
var As = L2({ max_: WR });
function UR(e, t) {
  let n10 = _2(e, "a", "sub"), s10 = _2(t, "b", "sub");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(ui, r10);
}
var ge2 = L2({ sub_: UR });
function GR(e, t = null, n10 = false) {
  let s10 = _2(e, "x", "sum");
  s10.dtype === "bool" && (s10 = ce2(s10, "int32"));
  let r10 = { x: s10 }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(ai, r10, a10);
}
var ye2 = L2({ sum_: GR });
function HR(e, t = -1) {
  let n10 = _2(e, "logits", "logSoftmax");
  if (t === -1 && (t = n10.rank - 1), t !== n10.rank - 1)
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n10.rank} and axis was ${t}`);
  return js((r10, a10) => {
    let o10 = As(r10, t, true), u10 = ge2(r10, o10), l10 = ge2(ce2(u10, "float32"), Kn(ye2(jn(u10), t, true)));
    return a10([l10]), { value: l10, gradFunc: (p10, d10) => {
      let [h10] = d10, f10 = true, m10 = jn(h10);
      return ge2(p10, V2(ye2(p10, t, f10), m10));
    } };
  })(n10);
}
var eI = L2({ logSoftmax_: HR });
function Xg(e, t) {
  for (let n10 = 0; n10 < e.length; ++n10)
    if (e[e.length - n10 - 1] !== t - 1 - n10)
      return false;
  return true;
}
function tI(e, t, n10) {
  let s10 = e.length + t.length, r10 = [], a10 = 0, i10 = 0;
  for (let o10 = 0; o10 < s10; o10++)
    n10.indexOf(o10) === -1 ? r10.push(e[a10++]) : r10.push(t[i10++]);
  return r10;
}
function nI(e, t) {
  let n10 = [], s10 = e.length;
  for (let a10 = 0; a10 < s10; a10++)
    t.indexOf(a10) === -1 && n10.push(e[a10]);
  let r10 = t.map((a10) => e[a10]);
  return [n10, r10];
}
function la(e, t) {
  let n10 = t.map((s10) => 1);
  return tI(e, n10, t);
}
function qR(e, t, n10) {
  O2(Xg(t, n10), () => `${e} supports only inner-most axes for now. Got axes ${t} and rank-${n10} input.`);
}
function sI(e, t) {
  if (Xg(e, t))
    return null;
  let n10 = [];
  for (let s10 = 0; s10 < t; ++s10)
    e.indexOf(s10) === -1 && n10.push(s10);
  return e.forEach((s10) => n10.push(s10)), n10;
}
function Yg(e) {
  return e.map((t, n10) => [n10, t]).sort((t, n10) => t[1] - n10[1]).map((t) => t[0]);
}
function jR(e, t) {
  let n10 = [];
  for (let s10 = t - e; s10 < t; ++s10)
    n10.push(s10);
  return n10;
}
function KR(e, t = null, n10 = false) {
  let s10 = _2(e, "x", "logSumExp"), r10 = Jn(t, s10.shape), a10 = As(s10, r10, true), i10 = ge2(s10, a10), o10 = jn(i10), u10 = ye2(o10, r10), l10 = Kn(u10), c10 = ie2(G2(a10, l10.shape), l10);
  if (n10) {
    let p10 = la(c10.shape, r10);
    return G2(c10, p10);
  }
  return c10;
}
var XR = L2({ logSumExp_: KR });
function YR(e, t) {
  let n10 = _2(e, "a", "logicalAnd", "bool"), s10 = _2(t, "b", "logicalAnd", "bool");
  it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(wo, r10);
}
var Ds = L2({ logicalAnd_: YR });
function QR(e) {
  let n10 = { x: _2(e, "x", "logicalNot", "bool") };
  return M2.runKernel(yl, n10);
}
var Qg = L2({ logicalNot_: QR });
function ZR(e, t) {
  let n10 = _2(e, "a", "logicalOr", "bool"), s10 = _2(t, "b", "logicalOr", "bool");
  it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Zd, r10);
}
var rI = L2({ logicalOr_: ZR });
function JR(e, t) {
  let n10 = _2(e, "a", "logicalXor", "bool"), s10 = _2(t, "b", "logicalXor", "bool");
  return it(n10.shape, s10.shape), Ds(rI(e, t), Qg(Ds(e, t)));
}
var Bde = L2({ logicalXor_: JR });
function eD(e, t, n10, s10, r10) {
  let a10 = _2(e, "x", "maxPool"), i10 = 1, o10 = a10, u10 = false;
  a10.rank === 3 && (u10 = true, o10 = G2(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]])), O2(o10.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${o10.rank}.`), O2(Ps(n10, i10), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n10} and dilations '${i10}'`), pn("maxPool", s10, r10);
  let l10 = { x: o10 }, c10 = { filterSize: t, strides: n10, pad: s10, dimRoundingMode: r10 }, p10 = M2.runKernel(Ua, l10, c10);
  return u10 ? G2(p10, [p10.shape[1], p10.shape[2], p10.shape[3]]) : p10;
}
var Zg = L2({ maxPool_: eD });
function tD(e, t = [1, 1, 1], n10, s10, r10, a10 = "NDHWC") {
  let i10 = _2(e, "x", "maxPool3d"), o10 = i10, u10 = false;
  i10.rank === 4 && (u10 = true, o10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2], i10.shape[3]])), O2(o10.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${o10.rank}.`), O2(a10 === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a10}`), pn("maxPool3d", s10, r10);
  let l10 = { x: o10 }, c10 = { filterSize: t, strides: n10, pad: s10, dimRoundingMode: r10, dataFormat: a10 }, p10 = M2.runKernel(ep, l10, c10);
  return u10 ? G2(p10, [p10.shape[1], p10.shape[2], p10.shape[3], p10.shape[4]]) : p10;
}
var aI = L2({ maxPool3d_: tD });
function nD(e, t, n10, s10, r10 = false) {
  let i10 = { x: _2(e, "x", "maxPoolWithArgmax") }, o10 = { filterSize: t, strides: n10, pad: s10, includeBatchInIndex: r10 }, u10 = M2.runKernel(kg, i10, o10);
  return { result: u10[0], indexes: u10[1] };
}
var sD = L2({ maxPoolWithArgmax_: nD });
function rD(e, t) {
  let n10 = _2(e, "a", "maximum"), s10 = _2(t, "b", "maximum");
  [n10, s10] = vt(n10, s10), n10.dtype === "bool" && (n10 = ce2(n10, "int32"), s10 = ce2(s10, "int32")), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Wa, r10);
}
var Tr = L2({ maximum_: rD });
function aD(e, t = null, n10 = false) {
  let r10 = { x: _2(e, "x", "mean") }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(Ga, r10, a10);
}
var It = L2({ mean_: aD });
function $t(e, t = "float32") {
  if (t === "complex64") {
    let s10 = $t(e, "float32"), r10 = $t(e, "float32");
    return aa(s10, r10);
  }
  let n10 = Gd(pt(e), t);
  return M2.makeTensor(n10, e, t);
}
function zn(e, t = "float32") {
  if (t === "complex64") {
    let s10 = zn(e, "float32"), r10 = $t(e, "float32");
    return aa(s10, r10);
  }
  let n10 = eg(pt(e), t);
  return M2.makeTensor(n10, e, t);
}
function Vde(e, t, { indexing: n10 = "xy" } = {}) {
  if (n10 !== "xy" && n10 !== "ij")
    throw new TypeError(`${n10} is not a valid third argument to meshgrid`);
  if (e === void 0)
    return [];
  let s10 = _2(e, "x", "meshgrid", e instanceof et ? e.dtype : "float32");
  if (t === void 0)
    return [s10];
  let r10 = _2(t, "y", "meshgrid", t instanceof et ? t.dtype : "float32"), a10 = pt(s10.shape), i10 = pt(r10.shape);
  return n10 === "xy" ? (s10 = G2(s10, [1, -1]), r10 = G2(r10, [-1, 1]), [We(zn([i10, 1], s10.dtype), s10), We(r10, zn([1, a10], r10.dtype))]) : (s10 = G2(s10, [-1, 1]), r10 = G2(r10, [1, -1]), [We(s10, zn([1, i10], s10.dtype)), We(zn([a10, 1], r10.dtype), r10)]);
}
function iD(e, t = null, n10 = false) {
  let r10 = { x: _2(e, "x", "min") }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(Ha, r10, a10);
}
var pm = L2({ min_: iD });
function oD(e, t) {
  let n10 = _2(e, "a", "minimum"), s10 = _2(t, "b", "minimum");
  [n10, s10] = vt(n10, s10), n10.dtype === "bool" && (n10 = ce2(n10, "int32"), s10 = ce2(s10, "int32")), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(qa, r10);
}
var gp = L2({ minimum_: oD });
function uD(e, t, n10) {
  O2(n10 === "reflect" || n10 === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${n10}.`);
  let s10 = _2(e, "x", "mirrorPad");
  if (s10.rank === 0)
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  O2(t.length === s10.rank, () => `Padding doesn't match input. Must be ${s10.rank}. Got ${t.length}.`);
  let r10 = n10 === "reflect" ? 1 : 0;
  for (let o10 = 0; o10 < s10.rank; o10++)
    O2(t[o10].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), O2(t[o10][0] >= 0 && t[o10][0] <= s10.shape[o10] - r10 && t[o10][1] >= 0 && t[o10][1] <= s10.shape[o10] - r10, () => `Padding in dimension ${o10} cannot be greater than or equal to ${s10.shape[o10] - r10} or less than 0 for input of shape ${s10.shape}`);
  let a10 = { paddings: t, mode: n10 }, i10 = { x: s10 };
  return M2.runKernel(ja, i10, a10);
}
var lD = L2({ mirrorPad_: uD });
function cD(e, t) {
  let n10 = _2(e, "a", "mod"), s10 = _2(t, "b", "mod");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(vl, r10);
}
var dD = L2({ mod_: cD });
function pD(e) {
  let t = _2(e, "x", "square"), n10 = {};
  return M2.runKernel("Square", { x: t }, n10);
}
var ct = L2({ square_: pD });
function hD(e, t = null, n10 = false) {
  e = _2(e, "x", "moments");
  let s10 = Jn(t, e.shape), r10 = It(e, s10, n10), a10 = r10.shape;
  n10 || (a10 = la(r10.shape, s10));
  let i10 = ct(ge2(ce2(e, "float32"), G2(r10, a10))), o10 = It(i10, s10, n10);
  return { mean: r10, variance: o10 };
}
var Jg = L2({ moments_: hD });
function fD(e, t, n10, s10) {
  let r10 = _2(t, "data", "multiRNNCell"), a10 = Uu(n10, "c", "multiRNNCell"), i10 = Uu(s10, "h", "multiRNNCell"), o10 = r10, u10 = [];
  for (let p10 = 0; p10 < e.length; p10++) {
    let d10 = e[p10](o10, a10[p10], i10[p10]);
    u10.push(d10[0]), u10.push(d10[1]), o10 = d10[1];
  }
  let l10 = [], c10 = [];
  for (let p10 = 0; p10 < u10.length; p10 += 2)
    l10.push(u10[p10]), c10.push(u10[p10 + 1]);
  return [l10, c10];
}
var Wde = L2({ multiRNNCell_: fD });
function mD(e, t, n10, s10 = false) {
  let r10 = _2(e, "logits", "multinomial"), a10 = r10.size, i10 = r10.rank;
  if (a10 < 2)
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a10}.`);
  if (i10 > 2)
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${i10}`);
  n10 = n10 || Math.random();
  let u10 = { logits: i10 === 1 ? G2(r10, [1, -1]) : r10 }, l10 = { numSamples: t, seed: n10, normalized: s10 }, c10 = M2.runKernel(Ig, u10, l10);
  return i10 === 1 ? G2(c10, [c10.size]) : c10;
}
var gD = L2({ multinomial_: mD });
function bD(e, t) {
  let n10 = _2(e, "a", "notEqual", "string_or_numeric"), s10 = _2(t, "b", "notEqual", "string_or_numeric");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Io, r10);
}
var Ku = L2({ notEqual_: bD });
function yD(e) {
  let n10 = { x: _2(e, "x", "onesLike") };
  return M2.runKernel(No, n10);
}
var Xn = L2({ onesLike_: yD });
function vD(e, t) {
  let n10 = _2(e, "v1", "outerProduct"), s10 = _2(t, "v2", "outerProduct");
  O2(n10.rank === 1 && s10.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${n10.rank} and ${s10.rank}.`);
  let r10 = G2(n10, [-1, 1]), a10 = G2(s10, [1, -1]);
  return We(r10, a10);
}
var Ude = L2({ outerProduct_: vD });
function xD(e, t, n10 = 0) {
  let s10 = _2(e, "x", "pad");
  if (s10.rank === 0)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  let r10 = { paddings: t, constantValue: n10 }, a10 = { x: s10 };
  return M2.runKernel(Xa, a10, r10);
}
var pi = L2({ pad_: xD });
function wD(e, t, n10 = 0) {
  return O2(t.length === 2, () => "Invalid number of paddings. Must be length of 2."), pi(e, [t], n10);
}
var Gde = L2({ pad1d_: wD });
function kD(e, t, n10 = 0) {
  return O2(t.length === 2 && t[0].length === 2 && t[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), pi(e, t, n10);
}
var Hde = L2({ pad2d_: kD });
function ID(e, t, n10 = 0) {
  return O2(t.length === 3 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), pi(e, t, n10);
}
var qde = L2({ pad3d_: ID });
function SD(e, t, n10 = 0) {
  return O2(t.length === 4 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2 && t[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), pi(e, t, n10);
}
var jde = L2({ pad4d_: SD });
function CD(e, t, n10) {
  let s10 = _2(e, "x", "spaceToBatchND");
  O2(s10.rank >= 1 + t.length, () => `input rank ${s10.rank} should be > than [blockShape] ${t.length}`), O2(n10.length === t.length, () => `paddings.shape[0] ${n10.length} must be equal to [blockShape] ${t.length}`), O2(s10.shape.reduce((i10, o10, u10) => u10 > 0 && u10 <= t.length ? i10 && (o10 + n10[u10 - 1][0] + n10[u10 - 1][1]) % t[u10 - 1] === 0 : i10, true), () => `input spatial dimensions ${s10.shape.slice(1)} with paddings ${n10.toString()} must be divisible by blockShapes ${t.toString()}`);
  let r10 = { x: s10 }, a10 = { blockShape: t, paddings: n10 };
  return M2.runKernel(zo, r10, a10);
}
var eb = L2({ spaceToBatchND_: CD });
function ND(e, t, n10, s10, r10, a10, i10) {
  r10 == null && (r10 = [1, 1]), a10 == null && (a10 = 1), s10 === 0 && (s10 = "valid");
  let o10 = _2(e, "x", "maxPool"), u10 = o10, l10 = false;
  o10.rank === 3 && (l10 = true, u10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]])), O2(Ps(a10, r10), () => `Error in pool: Either strides or dilations must be 1. Got strides ${a10} and dilations '${r10}'`);
  let c10 = Vk(u10.shape, t, a10, r10, s10), p10 = [c10.dilationHeight, c10.dilationWidth], d10;
  s10 === "same" ? d10 = $D([c10.filterHeight, c10.filterWidth], p10) : d10 = [[0, 0], [0, 0]];
  let h10 = p10[0] === 1 && p10[1] === 1, [f10, m10] = TD([c10.inHeight, c10.inWidth], p10, d10), g10 = h10 ? s10 : "valid", b10 = h10 ? u10 : eb(u10, p10, f10), v10 = (n10 === "avg" ? () => Wg(b10, t, a10, g10, i10) : () => Zg(b10, t, a10, g10, i10))(), x10 = h10 ? v10 : Ug(v10, p10, m10);
  return l10 ? G2(x10, [x10.shape[1], x10.shape[2], x10.shape[3]]) : x10;
}
function TD(e, t, n10) {
  let s10 = n10.map((c10) => c10[0]), r10 = n10.map((c10) => c10[1]), a10 = e.concat(s10, r10), i10 = t.map((c10, p10) => (c10 - a10[p10] % c10) % c10), o10 = r10.map((c10, p10) => c10 + i10[p10]), u10 = t.map((c10, p10) => [s10[p10], o10[p10]]), l10 = t.map((c10, p10) => [0, i10[p10]]);
  return [u10, l10];
}
function $D(e, t) {
  let s10 = e.map((i10, o10) => i10 + (i10 - 1) * (t[o10] - 1)).map((i10) => i10 - 1), r10 = s10.map((i10) => Math.floor(i10 / 2)), a10 = s10.map((i10, o10) => i10 - r10[o10]);
  return s10.map((i10, o10) => [r10[o10], a10[o10]]);
}
var Kde = L2({ pool_: ND });
function _D(e, t) {
  let n10 = _2(e, "base", "pow"), s10 = _2(t, "exp", "pow");
  [n10, s10] = vt(n10, s10);
  let r10 = { a: n10, b: s10 };
  return M2.runKernel(Ya, r10);
}
var ca = L2({ pow_: _D });
function AD(e, t) {
  let n10 = _2(e, "x", "prelu"), s10 = _2(t, "alpha", "prelu"), r10 = { x: n10, alpha: s10 };
  return M2.runKernel(Qa, r10);
}
var tb = L2({ prelu_: AD });
function ED(e, t = null, n10 = false) {
  let s10 = _2(e, "x", "prod");
  s10.dtype === "bool" && (s10 = ce2(s10, "int32"));
  let r10 = { x: s10 }, a10 = { axis: t, keepDims: n10 };
  return M2.runKernel(_o, r10, a10);
}
var iI = L2({ prod_: ED });
function RD(e, t, n10) {
  let s10 = pt(e), r10 = null;
  if (n10 == null || n10 === "float32")
    r10 = new Float32Array(s10);
  else if (n10 === "int32")
    r10 = new Int32Array(s10);
  else if (n10 === "bool")
    r10 = new Uint8Array(s10);
  else
    throw new Error(`Unknown data type ${n10}`);
  for (let a10 = 0; a10 < s10; a10++)
    r10[a10] = t();
  return M2.makeTensor(r10, e, n10);
}
var Xde = L2({ rand_: RD });
var nb = ya(Vd());
var sb = class {
  constructor(e, t, n10, s10, r10) {
    this.mean = e, this.stdDev = t, this.dtype = n10, this.nextVal = NaN, this.truncated = s10, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
    let a10 = r10 || Math.random();
    this.random = nb.alea(a10.toString());
  }
  nextValue() {
    if (!isNaN(this.nextVal)) {
      let s10 = this.nextVal;
      return this.nextVal = NaN, s10;
    }
    let e, t, n10 = false;
    for (; !n10; ) {
      let s10, r10, a10;
      do
        s10 = 2 * this.random() - 1, r10 = 2 * this.random() - 1, a10 = s10 * s10 + r10 * r10;
      while (a10 >= 1 || a10 === 0);
      let i10 = Math.sqrt(-2 * Math.log(a10) / a10);
      e = this.mean + this.stdDev * s10 * i10, t = this.mean + this.stdDev * r10 * i10, (!this.truncated || this.isValidTruncated(e)) && (n10 = true);
    }
    return (!this.truncated || this.isValidTruncated(t)) && (this.nextVal = this.convertValue(t)), this.convertValue(e);
  }
  convertValue(e) {
    return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
  }
  isValidTruncated(e) {
    return e <= this.upper && e >= this.lower;
  }
};
var DD = class {
  constructor(e, t, n10, s10) {
    this.alpha = e, this.beta = 1 / t, this.dtype = n10;
    let r10 = s10 || Math.random();
    this.randu = nb.alea(r10.toString()), this.randn = new sb(0, 1, n10, false, this.randu()), e < 1 ? this.d = e + 2 / 3 : this.d = e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  nextValue() {
    let e, t, n10, s10, r10, a10;
    for (; ; ) {
      do
        s10 = this.randn.nextValue(), a10 = 1 + this.c * s10;
      while (a10 <= 0);
      if (a10 *= a10 * a10, e = s10 * s10, t = 1 - 0.331 * e * e, n10 = 0.5 * e + this.d * (1 - a10 + Math.log(a10)), r10 = this.randu(), r10 < t || Math.log(r10) < n10)
        break;
    }
    return a10 = 1 / this.beta * this.d * a10, this.alpha < 1 && (a10 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a10);
  }
  convertValue(e) {
    return this.dtype === "float32" ? e : Math.round(e);
  }
};
var FD = class {
  constructor(e = 0, t = 1, n10, s10) {
    if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = e, this.range = t - e, this.dtype = n10, s10 == null && (s10 = Math.random()), typeof s10 == "number" && (s10 = s10.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);
    this.random = nb.alea(s10);
  }
  convertValue(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
};
function OD(e, t, n10 = 1, s10 = "float32", r10) {
  if (n10 == null && (n10 = 1), s10 == null && (s10 = "float32"), s10 !== "float32" && s10 !== "int32")
    throw new Error(`Unsupported data type ${s10}`);
  let a10 = new DD(t, n10, s10, r10), i10 = De(e, s10);
  for (let o10 = 0; o10 < i10.values.length; o10++)
    i10.values[o10] = a10.nextValue();
  return i10.toTensor();
}
var Yde = L2({ randomGamma_: OD });
function PD(e, t = 0, n10 = 1, s10, r10) {
  if (s10 != null && s10 === "bool")
    throw new Error(`Unsupported data type ${s10}`);
  let a10 = new sb(t, n10, s10, false, r10), i10 = De(e, s10);
  for (let o10 = 0; o10 < i10.values.length; o10++)
    i10.values[o10] = a10.nextValue();
  return i10.toTensor();
}
var zD = L2({ randomNormal_: PD });
function MD(e, t = 0, n10 = 1, s10 = "float32", r10) {
  let a10 = De(e, s10), i10 = new FD(t, n10, null, r10);
  for (let o10 = 0; o10 < a10.values.length; o10++)
    a10.values[o10] = i10.nextValue();
  return a10.toTensor();
}
var Pl = L2({ randomUniform_: MD });
function Xu(e, t, n10 = 1, s10 = "float32") {
  if (n10 === 0)
    throw new Error("Cannot have a step of zero");
  let r10 = { start: e, stop: t, step: n10, dtype: s10 };
  return M2.runKernel(wl, {}, r10);
}
function LD(e) {
  let n10 = { input: _2(e, "input", "real") };
  return M2.runKernel(tp, n10);
}
var xd = L2({ real_: LD });
function BD(e) {
  let n10 = { x: _2(e, "x", "reciprocal") };
  return M2.runKernel(kl, n10);
}
var VD = L2({ reciprocal_: BD });
function WD(e) {
  let n10 = { x: _2(e, "x", "relu") };
  return M2.runKernel(Za, n10);
}
var Xs = L2({ relu_: WD });
function UD(e) {
  let n10 = { x: _2(e, "x", "relu6") };
  return M2.runKernel(ei, n10);
}
var oI = L2({ relu6_: UD });
function GD(e, t) {
  let s10 = { x: _2(e, "x", "reverse") }, r10 = { dims: t };
  return M2.runKernel(Eo, s10, r10);
}
var Yn = L2({ reverse_: GD });
function HD(e) {
  let t = _2(e, "x", "reverse");
  return O2(t.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`), Yn(t, 0);
}
var Qde = L2({ reverse1d_: HD });
function qD(e, t) {
  let n10 = _2(e, "x", "reverse");
  return O2(n10.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${n10.rank}.`), Yn(n10, t);
}
var Zde = L2({ reverse2d_: qD });
function jD(e, t) {
  let n10 = _2(e, "x", "reverse");
  return O2(n10.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${n10.rank}.`), Yn(n10, t);
}
var Jde = L2({ reverse3d_: jD });
function KD(e, t) {
  let n10 = _2(e, "x", "reverse");
  return O2(n10.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${n10.rank}.`), Yn(n10, t);
}
var epe = L2({ reverse4d_: KD });
function XD(e) {
  let n10 = { x: _2(e, "x", "round") };
  return M2.runKernel(Ro, n10);
}
var uI = L2({ round_: XD });
function YD(e) {
  let n10 = { x: _2(e, "x", "rsqrt", "float32") };
  return M2.runKernel(ti, n10);
}
var lI = L2({ rsqrt_: YD });
function Ie2(e, t) {
  if ((Yt(e) && t !== "string" || Array.isArray(e)) && t !== "complex64")
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (t === "string" && Yt(e) && !(e instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Cr(e, [], [], t);
}
function QD(e) {
  let n10 = { x: _2(e, "x", "selu") };
  return M2.runKernel(Sl, n10);
}
var cI = L2({ selu_: QD });
function ZD(e, t, n10, s10, r10, a10 = [1, 1], i10 = "NHWC") {
  let o10 = _2(e, "x", "separableConv2d"), u10 = _2(t, "depthwiseFilter", "separableConv2d"), l10 = _2(n10, "pointwiseFilter", "separableConv2d"), c10 = o10, p10 = false;
  if (o10.rank === 3 && (p10 = true, c10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]])), i10 === "NCHW")
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  O2(c10.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${c10.rank}.`), O2(u10.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u10.rank}.`), O2(l10.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u10.rank}.`), O2(l10.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l10.shape[0]}.`), O2(l10.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l10.shape[1]}.`);
  let d10 = u10.shape[2], h10 = u10.shape[3];
  O2(l10.shape[2] === d10 * h10, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${d10 * h10}, but got ${l10.shape[2]}.`);
  let f10 = pp(c10, u10, s10, r10, i10, a10), g10 = ua(f10, l10, 1, "valid", i10);
  return p10 ? G2(g10, [g10.shape[1], g10.shape[2], g10.shape[3]]) : g10;
}
var JD = L2({ separableConv2d_: ZD });
async function e3(e, t) {
  let n10 = _2(e, "x", "setdiff1d"), s10 = _2(t, "y", "setdiff1d");
  O2(n10.dtype === s10.dtype, () => `x and y should have the same dtype, but got x (${n10.dtype}) and y (${s10.dtype}).`), O2(n10.rank === 1, () => `x should be 1D tensor, but got x (${n10.shape}).`), O2(s10.rank === 1, () => `y should be 1D tensor, but got y (${s10.shape}).`);
  let r10 = await n10.data(), a10 = await s10.data(), i10 = new Set(a10), o10 = 0;
  for (let c10 = 0; c10 < r10.length; c10++)
    i10.has(r10[c10]) || o10++;
  let u10 = new Vt([o10], n10.dtype), l10 = new Vt([o10], "int32");
  for (let c10 = 0, p10 = 0; c10 < r10.length; c10++)
    i10.has(r10[c10]) || (u10.values[p10] = r10[c10], l10.values[p10] = c10, p10++);
  return [u10.toTensor(), l10.toTensor()];
}
var t3 = e3;
function n3(e) {
  let n10 = { x: _2(e, "x", "sign") };
  return M2.runKernel(Cl, n10);
}
var s3 = L2({ sign_: n3 });
function r3(e) {
  let n10 = { x: _2(e, "x", "sin", "float32") };
  return M2.runKernel(ni, n10);
}
var dI = L2({ sin_: r3 });
function a3(e) {
  let n10 = { x: _2(e, "x", "sinh") };
  return M2.runKernel(Po, n10);
}
var pI = L2({ sinh_: a3 });
function i3(e, t, n10) {
  let s10 = _2(e, "x", "slice1d");
  return O2(s10.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${s10.rank} tensor`), He(s10, [t], [n10]);
}
var rb = L2({ slice1d_: i3 });
function o3(e, t, n10) {
  let s10 = _2(e, "x", "slice2d");
  return O2(s10.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${s10.rank} tensor`), He(s10, t, n10);
}
var hI = L2({ slice2d_: o3 });
function u3(e, t, n10) {
  let s10 = _2(e, "x", "slice3d");
  return O2(s10.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${s10.rank} tensor`), He(s10, t, n10);
}
var ab = L2({ slice3d_: u3 });
function l3(e, t, n10) {
  let s10 = _2(e, "x", "slice4d");
  return O2(s10.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${s10.rank} tensor`), He(s10, t, n10);
}
var wd = L2({ slice4d_: l3 });
function c3(e, t = -1) {
  let n10 = _2(e, "logits", "softmax", "float32");
  if (t === -1 && (t = n10.rank - 1), t !== n10.rank - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n10.rank} and dim was ${t}`);
  let s10 = { logits: n10 }, r10 = { dim: t };
  return M2.runKernel(ii, s10, r10);
}
var ib = L2({ softmax_: c3 });
function d3(e) {
  O2(e.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);
  let t = { input: e };
  return M2.runKernel(gg, t);
}
var ob = L2({ fft_: d3 });
function p3(e) {
  O2(e.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);
  let t = { input: e };
  return M2.runKernel(bg, t);
}
var kd = L2({ ifft_: p3 });
function h3(e) {
  let t = e.shape[e.shape.length - 1], n10 = e.size / t, s10;
  if (t <= 2) {
    let r10 = G2(e, [n10, t]);
    s10 = kd(r10);
  } else {
    let r10 = [n10, 2 * (t - 1)], a10 = G2(xd(e), [n10, t]), i10 = G2(qg(e), [n10, t]), o10 = Yn(He(a10, [0, 1], [n10, t - 2]), 1), u10 = V2(Yn(He(i10, [0, 1], [n10, t - 2]), 1), Ie2(-1)), l10 = Ft([a10, o10], 1), c10 = Ft([i10, u10], 1), p10 = G2(aa(l10, c10), [r10[0], r10[1]]);
    s10 = kd(p10);
  }
  if (s10 = xd(s10), e.rank === 3 && e.shape[0] !== 0) {
    let r10 = s10, a10 = e.shape[0];
    s10 = G2(s10, [a10, s10.shape[0] / a10, s10.shape[1]]), r10.dispose();
  }
  return s10;
}
var fI = L2({ irfft_: h3 });
function f3(e, t, n10 = 0) {
  let r10 = { x: _2(e, "x", "split") }, a10 = { numOrSizeSplits: t, axis: n10 };
  return M2.runKernel(Mo, r10, a10);
}
var Ln = L2({ split_: f3 });
function m3(e, t) {
  O2(e.dtype === "float32", () => `The dtype for rfft() must be real value but got ${e.dtype}`);
  let n10 = e.shape[e.shape.length - 1], s10 = e.size / n10, r10;
  if (t != null && t < n10) {
    let f10 = e.shape.map((g10) => 0), m10 = e.shape.map((g10) => g10);
    m10[e.shape.length - 1] = t, r10 = He(e, f10, m10), n10 = t;
  } else if (t != null && t > n10) {
    let f10 = e.shape.map((m10) => m10);
    f10[e.shape.length - 1] = t - n10, r10 = Ft([e, $t(f10)], e.shape.length - 1), n10 = t;
  } else
    r10 = e;
  let a10 = je(r10), i10 = G2(aa(r10, a10), [s10, n10]), o10 = ob(i10), u10 = Math.floor(n10 / 2) + 1, l10 = xd(o10), c10 = qg(o10), p10 = Ln(l10, [u10, n10 - u10], l10.shape.length - 1), d10 = Ln(c10, [u10, n10 - u10], c10.shape.length - 1), h10 = r10.shape.slice();
  return h10[r10.shape.length - 1] = u10, G2(aa(p10[0], d10[0]), h10);
}
var ub = L2({ rfft_: m3 });
function g3(e) {
  let n10 = { x: _2(e, "x", "sqrt", "float32") };
  return M2.runKernel(ri, n10);
}
var ln = L2({ sqrt_: g3 });
function b3(e, t) {
  let n10 = _2(e, "a", "squaredDifference"), s10 = _2(t, "b", "squaredDifference");
  [n10, s10] = vt(n10, s10), it(n10.shape, s10.shape);
  let r10 = { a: n10, b: s10 }, a10 = {};
  return M2.runKernel(oi, r10, a10);
}
var mI = L2({ squaredDifference_: b3 });
function y3(e, t) {
  let n10 = _2(e, "x", "squeeze");
  return G2(n10, Mw(n10.shape, t).newShape);
}
var mr = L2({ squeeze_: y3 });
function v3(e, t = 0) {
  let n10 = Uu(e, "tensors", "stack", "string_or_numeric");
  O2(n10.length >= 1, () => "Pass at least one tensor to tf.stack"), n10.length > 0 && O2(t <= n10[0].rank, () => "Axis must be <= rank of the tensor");
  let s10 = n10, r10 = { axis: t };
  return M2.runKernel($o, s10, r10);
}
var Qn = L2({ stack_: v3 });
function x3(e, t = 0) {
  let s10 = { x: _2(e, "x", "step") }, r10 = { alpha: t };
  return M2.runKernel(di, s10, r10);
}
var bp = L2({ step_: x3 });
function w3(e, t, n10, s10, r10 = 0, a10 = 0, i10 = 0, o10 = 0, u10 = 0) {
  let c10 = { x: _2(e, "x", "stridedSlice", "string_or_numeric") }, p10 = { begin: t, end: n10, strides: s10, beginMask: r10, endMask: a10, ellipsisMask: i10, newAxisMask: o10, shrinkAxisMask: u10 };
  return M2.runKernel(Lo, c10, p10);
}
var k3 = L2({ stridedSlice_: w3 });
function I3(e) {
  let n10 = { x: _2(e, "x", "tan", "float32") };
  return M2.runKernel(Bo, n10);
}
var S3 = L2({ tan_: I3 });
function Qt(e, t) {
  va(e);
  let n10 = Rs(e, t);
  if (n10.length !== 1)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Cr(e, null, n10, t);
}
function ji(e, t, n10) {
  if (va(e), t != null && t.length !== 2)
    throw new Error("tensor2d() requires shape to have two numbers");
  let s10 = Rs(e, n10);
  if (s10.length !== 2 && s10.length !== 1)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (s10.length === 1 && t == null)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Cr(e, t, s10, n10);
}
function tpe(e, t, n10) {
  if (va(e), t != null && t.length !== 4)
    throw new Error("tensor4d() requires shape to have four numbers");
  let s10 = Rs(e, n10);
  if (s10.length !== 4 && s10.length !== 1)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (s10.length === 1 && t == null)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Cr(e, t, s10, n10);
}
function npe(e, t, n10) {
  if (va(e), t != null && t.length !== 5)
    throw new Error("tensor5d() requires shape to have five numbers");
  let s10 = Rs(e, n10);
  if (s10.length !== 5 && s10.length !== 1)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (s10.length === 1 && t == null)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Cr(e, t, s10, n10);
}
function spe(e, t, n10) {
  if (va(e), t != null && t.length !== 6)
    throw new Error("tensor6d() requires shape to have six numbers");
  let s10 = Rs(e, n10);
  if (s10.length !== 6 && s10.length !== 1)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (s10.length === 1 && t == null)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return t = t || s10, Cr(e, t, s10, n10);
}
function C3(e, t = 1, n10 = true) {
  let s10 = _2(e, "x", "topk");
  if (s10.rank === 0)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  let r10 = s10.shape[s10.shape.length - 1];
  if (t < 0)
    throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
  if (t > r10)
    throw new Error(`'k' passed to topk() must be <= the last dimension (${r10}) but got ${t}`);
  let a10 = { x: s10 }, i10 = { k: t, sorted: n10 }, [o10, u10] = M2.runKernel(Vo, a10, i10);
  return { values: o10, indices: u10 };
}
var N3 = L2({ topk_: C3 });
function T3(e, t = 0, n10 = 1, s10, r10) {
  if (s10 != null && s10 === "bool")
    throw new Error("Unsupported data type $ { dtype }");
  let a10 = new sb(t, n10, s10, true, r10), i10 = De(e, s10);
  for (let o10 = 0; o10 < i10.values.length; o10++)
    i10.values[o10] = a10.nextValue();
  return i10.toTensor();
}
var lb = L2({ truncatedNormal_: T3 });
function $3(e, t = 0) {
  let n10 = _2(e, "x", "unique", "string_or_numeric");
  O2(n10.rank > 0, () => "The input tensor must be at least 1D");
  let s10 = { x: n10 }, r10 = { axis: t }, [a10, i10] = M2.runKernel($g, s10, r10);
  return { values: a10, indices: i10 };
}
var cx = L2({ unique_: $3 });
function _3(e, t, n10) {
  let s10 = _2(e, "x", "unsortedSegmentSum"), r10 = _2(t, "segmentIds", "unsortedSegmentSum", "int32");
  O2(Xi(n10), () => "numSegments must be of dtype int");
  let a10 = { x: s10, segmentIds: r10 }, i10 = { numSegments: n10 };
  return M2.runKernel(op, a10, i10);
}
var A3 = L2({ unsortedSegmentSum_: _3 });
function E3(e, t = 0) {
  let n10 = _2(e, "x", "unstack", "string_or_numeric");
  O2(t >= -n10.shape.length && t < n10.shape.length, () => `Axis = ${t} is not in [-${n10.shape.length}, ${n10.shape.length})`);
  let s10 = { value: n10 }, r10 = { axis: t };
  return M2.runKernel(Uo, s10, r10);
}
var Fs = L2({ unstack_: E3 });
function R3(e, t = true, n10, s10) {
  return M2.makeVariable(e, t, n10, s10);
}
function gI(e, t) {
  let n10 = [];
  for (let a10 = 0; a10 < t.length; a10++)
    t[a10] && n10.push(a10);
  let s10 = De(e, "int32"), r10 = De([n10.length, e.length], "int32");
  for (let a10 = 0; a10 < n10.length; a10++) {
    let i10 = s10.indexToLoc(n10[a10]), o10 = a10 * e.length;
    r10.values.set(i10, o10);
  }
  return r10.toTensor();
}
async function D3(e) {
  let t = _2(e, "condition", "whereAsync", "bool"), n10 = await t.data(), s10 = gI(t.shape, n10);
  return e !== t && t.dispose(), s10;
}
var bI = D3;
async function F3(e, t, n10) {
  let s10 = _2(e, "tensor", "boolMask"), r10 = _2(t, "mask", "boolMask", "bool"), a10 = n10 == null ? 0 : n10, i10 = r10.rank, o10 = s10.shape;
  O2(i10 > 0, () => "mask cannot be scalar"), dn(o10.slice(a10, a10 + i10), r10.shape, "mask's shape must match the first K dimensions of tensor's shape,");
  let u10 = 1;
  for (let m10 = a10; m10 < a10 + i10; m10++)
    u10 *= o10[m10];
  let l10 = o10.slice(0, a10).concat([u10], o10.slice(a10 + i10)), c10 = G2(s10, l10), p10 = G2(r10, [-1]), d10 = await bI(p10), h10 = mr(d10, [1]), f10 = ju(c10, h10, a10);
  return e !== s10 && s10.dispose(), t !== r10 && r10.dispose(), h10.dispose(), c10.dispose(), p10.dispose(), d10.dispose(), f10;
}
var rpe = F3;
function O3(e, t = "euclidean", n10 = null, s10 = false) {
  e = _2(e, "x", "norm");
  let r10 = yI(e, t, n10), a10 = r10.shape;
  if (s10) {
    let i10 = Jn(n10, e.shape);
    a10 = la(r10.shape, i10);
  }
  return G2(r10, a10);
}
function yI(e, t, n10 = null) {
  if (e.rank === 0)
    return Mt(e);
  if (e.rank !== 1 && n10 === null)
    return yI(G2(e, [-1]), t, n10);
  if (e.rank === 1 || typeof n10 == "number" || Array.isArray(n10) && n10.length === 1) {
    if (t === 1)
      return ye2(Mt(e), n10);
    if (t === 1 / 0)
      return As(Mt(e), n10);
    if (t === -1 / 0)
      return pm(Mt(e), n10);
    if (t === "euclidean" || t === 2)
      return ln(ye2(ca(Mt(e), Ie2(2, "int32")), n10));
    throw new Error(`Error in norm: invalid ord value: ${t}`);
  }
  if (Array.isArray(n10) && n10.length === 2) {
    if (t === 1)
      return As(ye2(Mt(e), n10[0]), n10[1] - 1);
    if (t === 1 / 0)
      return As(ye2(Mt(e), n10[1]), n10[0]);
    if (t === -1 / 0)
      return pm(ye2(Mt(e), n10[1]), n10[0]);
    if (t === "fro" || t === "euclidean")
      return ln(ye2(ct(e), n10));
    throw new Error(`Error in norm: invalid ord value: ${t}`);
  }
  throw new Error(`Error in norm: invalid axis: ${n10}`);
}
var vI = L2({ norm_: O3 });
function P3(e, t, n10, s10, r10 = true) {
  let a10 = _2(e, "v", "movingAverage"), i10 = _2(t, "x", "movingAverage"), o10 = _2(n10, "decay", "movingAverage");
  nk(a10, i10), O2(wr(a10.shape, i10.shape), () => "Shape mismatch in v and x");
  let u10 = Ie2(1), l10 = ge2(u10, o10), c10 = V2(ge2(i10, a10), l10);
  if (r10) {
    O2(s10 != null, () => "When using zeroDebias: true, step is required.");
    let p10 = _2(s10, "step", "movingAverage");
    c10 = xe2(c10, ge2(u10, ca(o10, p10)));
  }
  return ie2(a10, c10);
}
var ape = L2({ movingAverage_: P3 });
function z3(e, t, n10) {
  let s10 = _2(e, "indices", "scatterND", "int32"), r10 = _2(t, "updates", "scatterND");
  Mg(r10, s10, n10);
  let a10 = { indices: s10, updates: r10 }, i10 = { shape: n10 };
  return M2.runKernel(Do, a10, i10);
}
var M3 = L2({ scatterND_: z3 });
function L3(e, t, n10, s10) {
  if (e.dtype !== "int32")
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
  if (e.rank > 2)
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);
  let r10 = e.rank > 0 ? e.shape[0] : 1, a10 = e.rank > 1 ? e.shape[1] : 1;
  if (n10.length !== a10)
    throw new Error(`outputShape has incorrect number of elements:, ${n10.length}, should be: ${a10}.`);
  let i10 = t.size;
  if (!(t.rank === 0 || t.rank === 1 && i10 === r10))
    throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r10}]`);
  if (t.dtype !== s10.dtype)
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
}
function B3(e, t, n10, s10 = 0) {
  let r10 = _2(e, "sparseIndices", "sparseToDense", "int32"), a10 = _2(t, "sparseValues", "sparseToDense"), i10 = _2(s10, "defaultValue", "sparseToDense", a10.dtype);
  L3(r10, a10, n10, i10);
  let o10 = { sparseIndices: r10, sparseValues: a10, defaultValue: i10 }, u10 = { outputShape: n10 };
  return M2.runKernel(ap, o10, u10);
}
var xI = L2({ sparseToDense_: B3 });
function V3(e, t) {
  let n10 = _2(t, "indices", "gatherND", "int32"), r10 = { params: _2(e, "x", "gatherND", "string_or_numeric"), indices: n10 };
  return M2.runKernel(bo, r10);
}
var W3 = L2({ gatherND_: V3 });
function U3(e, t) {
  if (t == null)
    return e.shape.slice();
  if (wr(e.shape, t))
    return t;
  if (e.shape.length === t.length) {
    let n10 = [];
    for (let s10 = 0; s10 < e.shape.length; s10++)
      t[s10] == null && e.shape[s10] != null ? n10.push(e.shape[s10]) : n10.push(t[s10]);
    return n10;
  }
  return t;
}
function G3(e, t, n10, s10) {
  let r10 = _2(e, "x", "dropout");
  if (O2(r10.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${r10.dtype} tensor instead.`), O2(t >= 0 && t < 1, () => `rate must be a float in the range [0, 1), but got ${t}.`), t === 0)
    return e instanceof et ? r10.clone() : r10;
  let a10 = U3(r10, n10), i10 = 1 - t, o10 = xe2(fp(ie2(Pl(a10, 0, 1, "float32", s10), i10)), i10);
  return V2(r10, o10);
}
var H3 = L2({ dropout_: G3 });
function q3(e) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))));
}
function wI(e, t, n10) {
  let s10 = 1 - e % 2, r10 = new Float32Array(e);
  for (let a10 = 0; a10 < e; ++a10) {
    let i10 = 2 * Math.PI * a10 / (e + s10 - 1);
    r10[a10] = t - n10 * Math.cos(i10);
  }
  return Qt(r10, "float32");
}
async function j3(e, t, n10 = 1) {
  let s10 = _2(e, "predictions", "inTopK"), r10 = _2(t, "targets", "inTopK");
  O2(s10.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${s10.rank}`), O2(s10.rank - 1 === r10.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${s10.rank} and targets rank ${r10.rank}`), dn(s10.shape.slice(0, s10.shape.length - 1), r10.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
  let a10 = s10.shape[s10.shape.length - 1];
  O2(n10 > 0 && n10 <= a10, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a10}), but got ${n10}`);
  let i10 = await s10.data(), o10 = await r10.data(), [u10, l10] = [i10.length / a10, a10], c10 = Lw("bool", u10);
  for (let p10 = 0; p10 < u10; p10++) {
    let d10 = p10 * l10, h10 = i10.subarray(d10, d10 + l10), f10 = [];
    for (let m10 = 0; m10 < h10.length; m10++)
      f10.push({ value: h10[m10], index: m10 });
    f10.sort((m10, g10) => g10.value - m10.value), c10[p10] = 0;
    for (let m10 = 0; m10 < n10; m10++)
      if (f10[m10].index === o10[p10]) {
        c10[p10] = 1;
        break;
      }
  }
  return e !== s10 && s10.dispose(), t !== r10 && r10.dispose(), hs(c10, r10.shape, "bool");
}
var ipe = j3;
var da = {};
Ae(da, { conv2d: () => Y3, depthwiseConv2d: () => eF, matMul: () => nF });
function K3(e, t, n10, s10, r10, a10 = "NHWC", i10) {
  let o10 = e;
  e.rank === 3 && (o10 = G2(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  let u10 = t;
  u10.rank === 3 && (u10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2]])), O2(o10.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${o10.shape}.`), O2(u10.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${u10.shape}.`), O2(n10.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n10}.`);
  let l10 = a10 === "NHWC" ? o10.shape[3] : o10.shape[1], c10 = a10 === "NHWC" ? u10.shape[3] : u10.shape[1];
  O2(l10 === n10[2], () => `Error in conv2dDerFilter: depth of input ${l10}) must match input depth in filter (${n10[2]}.`), O2(c10 === n10[3], () => `Error in conv2dDerFilter: depth of dy (${c10}) must match output depth for filter (${n10[3]}).`), pn("conv2dDerFilter", r10, i10);
  let p10 = { x: o10, dy: u10 }, d10 = { strides: s10, pad: r10, dataFormat: a10, dimRoundingMode: i10, filterShape: n10 };
  return M2.runKernel(ug, p10, d10);
}
var cb = L2({ conv2DBackpropFilter_: K3 });
function yp(e, t, n10) {
  if (n10 == null || n10 === "linear")
    return e;
  if (n10 === "relu")
    return V2(e, bp(t));
  throw new Error(`Cannot compute gradient for fused activation ${n10}.`);
}
function vp(e, t) {
  let n10 = t, s10 = _t(e.shape, t.shape);
  return s10.length > 0 && (n10 = ye2(n10, s10)), G2(n10, e.shape);
}
function xp(e, t, n10, s10) {
  if (t === "linear")
    return e;
  if (t === "relu")
    return Xs(e);
  if (t === "elu")
    return hp(e);
  if (t === "relu6")
    return oI(e);
  if (t === "prelu")
    return tb(e, n10);
  if (t === "leakyrelu")
    return jg(e, s10);
  if (t === "sigmoid")
    return qs(e);
  throw new Error(`Unknown fused activation ${t}.`);
}
var wp = (e, t) => !(e > 0) || t === "linear";
function X3({ x: e, filter: t, strides: n10, pad: s10, dataFormat: r10 = "NHWC", dilations: a10 = [1, 1], dimRoundingMode: i10, bias: o10, activation: u10 = "linear", preluActivationWeights: l10, leakyreluAlpha: c10 }) {
  if (u10 = u10 || "linear", wp(M2.state.gradientDepth, u10) === false) {
    let k10 = ua(e, t, n10, s10, r10, a10, i10);
    return o10 != null && (k10 = ie2(k10, o10)), xp(k10, u10, l10, c10);
  }
  let p10 = _2(e, "x", "conv2d", "float32"), d10 = _2(t, "filter", "conv2d", "float32"), h10 = p10, f10 = false;
  p10.rank === 3 && (f10 = true, h10 = G2(p10, [1, p10.shape[0], p10.shape[1], p10.shape[2]])), O2(h10.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${h10.rank}.`), O2(d10.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${d10.rank}.`), pn("fused conv2d", s10, i10), O2(h10.shape[3] === d10.shape[2], () => `Error in conv2d: depth of input (${h10.shape[3]}) must match input depth for filter ${d10.shape[2]}.`), O2(Ps(n10, a10), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n10} and dilations '${a10}'`), O2(r10 === "NHWC", () => `Error in conv2d: got dataFormat of ${r10} but only NHWC is currently supported.`);
  let m10 = Dl(h10.shape, d10.shape, n10, a10, s10, i10), g10;
  o10 != null && (g10 = _2(o10, "bias", "fused conv2d"), [g10] = vt(g10, p10), it(m10.outShape, g10.shape));
  let b10;
  l10 != null && (b10 = _2(l10, "prelu weights", "fused conv2d"));
  let y10 = (k10, C10) => {
    let [T10, E10, A10, P10] = C10, R10 = yp(k10, A10, u10);
    O2(fr(a10), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a10}'`);
    let F10 = Gg(E10.shape, R10, T10, n10, s10), $10 = cb(E10, R10, T10.shape, n10, s10), z10 = [F10, $10];
    if (P10 != null) {
      let W10 = vp(P10, R10);
      z10.push(W10);
    }
    return z10;
  }, v10 = { x: h10, filter: d10, bias: g10, preluActivationWeights: b10 }, x10 = { strides: n10, pad: s10, dataFormat: r10, dilations: a10, dimRoundingMode: i10, activation: u10, leakyreluAlpha: c10 };
  return o10 == null ? js((C10, T10, E10) => {
    let A10 = M2.runKernel(sa, v10, x10);
    return E10([T10, C10, A10]), f10 && (A10 = G2(A10, [A10.shape[1], A10.shape[2], A10.shape[3]])), { value: A10, gradFunc: y10 };
  })(h10, d10) : js((C10, T10, E10, A10) => {
    let P10 = M2.runKernel(sa, v10, x10);
    return A10([T10, C10, P10, E10]), f10 && (P10 = G2(P10, [P10.shape[1], P10.shape[2], P10.shape[3]])), { value: P10, gradFunc: y10 };
  })(h10, d10, g10);
}
var Y3 = L2({ fusedConv2d_: X3 });
function Q3(e, t, n10, s10, r10, a10 = [1, 1], i10) {
  let o10 = e;
  e.rank === 3 && (o10 = G2(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  let u10 = t;
  u10.rank === 3 && (u10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let l10 = { x: o10, dy: u10 }, c10 = { strides: s10, pad: r10, dimRoundingMode: i10, dilations: a10, filterShape: n10 };
  return M2.runKernel(pg, l10, c10);
}
var kI = L2({ depthwiseConv2dNativeBackpropFilter_: Q3 });
function Z3(e, t, n10, s10, r10, a10 = [1, 1], i10) {
  let o10 = t, u10 = false;
  t.rank === 3 && (u10 = true, o10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let l10 = { dy: o10, filter: n10 }, c10 = { strides: s10, pad: r10, dimRoundingMode: i10, dilations: a10, inputShape: e }, p10 = M2.runKernel(hg, l10, c10);
  return u10 ? G2(p10, [p10.shape[1], p10.shape[2], p10.shape[3]]) : p10;
}
var II = L2({ depthwiseConv2dNativeBackpropInput_: Z3 });
function J3({ x: e, filter: t, strides: n10, pad: s10, dataFormat: r10 = "NHWC", dilations: a10 = [1, 1], dimRoundingMode: i10, bias: o10, activation: u10 = "linear", preluActivationWeights: l10, leakyreluAlpha: c10 }) {
  if (wp(M2.state.gradientDepth, u10) === false) {
    let k10 = pp(e, t, n10, s10, r10, a10, i10);
    return o10 != null && (k10 = ie2(k10, o10)), xp(k10, u10, l10, c10);
  }
  let p10 = _2(e, "x", "depthwiseConv2d", "float32"), d10 = _2(t, "filter", "depthwiseConv2d", "float32"), h10 = p10, f10 = false;
  p10.rank === 3 && (f10 = true, h10 = G2(p10, [1, p10.shape[0], p10.shape[1], p10.shape[2]])), O2(h10.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h10.rank}.`), O2(d10.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d10.rank}.`), O2(h10.shape[3] === d10.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${h10.shape[3]}) must match the inChannels dimension in filter ${d10.shape[2]}.`), a10 == null && (a10 = [1, 1]), O2(Ps(n10, a10), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n10} and dilations '${a10}'`), pn("fused depthwiseConv2d", s10, i10);
  let m10 = Dl(h10.shape, d10.shape, n10, a10, s10, i10, true), g10;
  o10 != null && (g10 = _2(o10, "bias", "fused conv2d"), [g10] = vt(g10, p10), it(m10.outShape, g10.shape));
  let b10;
  l10 != null && (b10 = _2(l10, "prelu weights", "fused depthwiseConv2d"));
  let y10 = (k10, C10) => {
    O2(fr(a10), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a10}'`);
    let [T10, E10, A10, P10] = C10, R10 = yp(k10, A10, u10), F10 = II(E10.shape, R10, T10, n10, s10, a10, i10), $10 = kI(E10, R10, T10.shape, n10, s10, a10, i10);
    if (P10 != null) {
      let z10 = vp(g10, R10);
      return [F10, $10, z10];
    }
    return [F10, $10];
  }, v10 = { x: h10, filter: d10, bias: g10, preluActivationWeights: b10 }, x10 = { strides: n10, pad: s10, dataFormat: r10, dilations: a10, dimRoundingMode: i10, activation: u10, leakyreluAlpha: c10 };
  return o10 == null ? js((C10, T10, E10) => {
    let A10 = M2.runKernel(ra, v10, x10);
    return E10([T10, C10, A10]), f10 && (A10 = G2(A10, [A10.shape[1], A10.shape[2], A10.shape[3]])), { value: A10, gradFunc: y10 };
  })(h10, d10) : js((C10, T10, E10, A10) => {
    let P10 = M2.runKernel(ra, v10, x10);
    return A10([T10, C10, P10, E10]), f10 && (P10 = G2(P10, [P10.shape[1], P10.shape[2], P10.shape[3]])), { value: P10, gradFunc: y10 };
  })(h10, d10, g10);
}
var eF = L2({ fusedDepthwiseConv2d_: J3 });
function tF({ a: e, b: t, transposeA: n10 = false, transposeB: s10 = false, bias: r10, activation: a10 = "linear", preluActivationWeights: i10, leakyreluAlpha: o10 }) {
  if (wp(M2.state.gradientDepth, a10) === false) {
    let R10 = We(e, t, n10, s10);
    return r10 != null && (R10 = ie2(R10, r10)), xp(R10, a10, i10, o10);
  }
  let u10 = _2(e, "a", "fused matMul"), l10 = _2(t, "b", "fused matMul");
  [u10, l10] = vt(u10, l10);
  let c10 = n10 ? u10.shape[u10.rank - 2] : u10.shape[u10.rank - 1], p10 = s10 ? l10.shape[l10.rank - 1] : l10.shape[l10.rank - 2], d10 = n10 ? u10.shape[u10.rank - 1] : u10.shape[u10.rank - 2], h10 = s10 ? l10.shape[l10.rank - 2] : l10.shape[l10.rank - 1], f10 = u10.shape.slice(0, -2), m10 = l10.shape.slice(0, -2), g10 = pt(f10), b10 = pt(m10);
  O2(c10 === p10, () => `Error in fused matMul: inner shapes (${c10}) and (${p10}) of Tensors with shapes ${u10.shape} and ${l10.shape} and transposeA=${n10} and transposeB=${s10} must match.`);
  let v10 = it(u10.shape.slice(0, -2), l10.shape.slice(0, -2)).concat([d10, h10]), x10 = n10 ? G2(u10, [g10, c10, d10]) : G2(u10, [g10, d10, c10]), k10 = s10 ? G2(l10, [b10, h10, p10]) : G2(l10, [b10, p10, h10]), C10;
  r10 != null && (C10 = _2(r10, "bias", "fused matMul"), [C10] = vt(C10, u10), it(v10, C10.shape));
  let T10;
  i10 != null && (T10 = _2(i10, "prelu weights", "fused matMul"));
  let E10 = (R10, F10) => {
    let [$10, z10, W10, q10] = F10, K10 = yp(G2(R10, W10.shape), W10, a10), Y10, Z10;
    if (!n10 && !s10 ? (Y10 = We(K10, z10, false, true), Z10 = We($10, K10, true, false)) : !n10 && s10 ? (Y10 = We(K10, z10, false, false), Z10 = We(K10, $10, true, false)) : n10 && !s10 ? (Y10 = We(z10, K10, false, true), Z10 = We($10, K10, false, false)) : (Y10 = We(z10, K10, true, true), Z10 = We(K10, $10, true, true)), r10 != null) {
      let te2 = vp(q10, K10);
      return [Y10, Z10, te2];
    } else
      return [Y10, Z10];
  }, A10 = { a: x10, b: k10, bias: C10, preluActivationWeights: T10 }, P10 = { transposeA: n10, transposeB: s10, activation: a10, leakyreluAlpha: o10 };
  return r10 == null ? js((F10, $10, z10) => {
    let W10 = M2.runKernel(na, A10, P10);
    return z10([F10, $10, W10]), { value: G2(W10, v10), gradFunc: E10 };
  })(x10, k10) : js((F10, $10, z10, W10) => {
    let q10 = M2.runKernel(na, A10, P10);
    return W10([F10, $10, q10, z10]), { value: G2(q10, v10), gradFunc: E10 };
  })(x10, k10, C10);
}
var nF = L2({ fusedMatMul_: tF });
function sF(e) {
  return wI(e, 0.54, 0.46);
}
var rF = L2({ hammingWindow_: sF });
function aF(e) {
  return wI(e, 0.5, 0.5);
}
var SI = L2({ hannWindow_: aF });
function iF(e, t, n10, s10 = false, r10 = 0) {
  let a10 = 0, i10 = [];
  for (; a10 + t <= e.size; )
    i10.push(He(e, a10, t)), a10 += n10;
  if (s10)
    for (; a10 < e.size; ) {
      let o10 = a10 + t - e.size, u10 = Ft([He(e, a10, t - o10), Fl([o10], r10)]);
      i10.push(u10), a10 += n10;
    }
  return i10.length === 0 ? ji([], [0, t]) : G2(Ft(i10), [i10.length, t]);
}
var CI = L2({ frame_: iF });
function oF(e, t, n10, s10, r10 = SI) {
  s10 == null && (s10 = q3(t));
  let a10 = CI(e, t, n10), i10 = V2(a10, r10(t));
  return ub(i10, s10);
}
var uF = L2({ stft_: oF });
function lF(e, t, n10, s10, r10 = "bilinear", a10 = 0) {
  let i10 = _2(e, "image", "cropAndResize"), o10 = _2(t, "boxes", "cropAndResize", "float32"), u10 = _2(n10, "boxInd", "cropAndResize", "int32"), l10 = o10.shape[0];
  O2(i10.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${i10.rank}.`), O2(o10.rank === 2 && o10.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${l10},4] but had shape ${o10.shape}.`), O2(u10.rank === 1 && u10.shape[0] === l10, () => `Error in cropAndResize: boxInd must be have size [${l10}] but had shape ${o10.shape}.`), O2(s10.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${s10.length}.`), O2(s10[0] >= 1 && s10[1] >= 1, () => `cropSize must be atleast [1,1], but was ${s10}`), O2(r10 === "bilinear" || r10 === "nearest", () => `method must be bilinear or nearest, but was ${r10}`);
  let c10 = { image: i10, boxes: o10, boxInd: u10 }, p10 = { method: r10, extrapolationValue: a10, cropSize: s10 };
  return M2.runKernel(lo, c10, p10);
}
var cF = L2({ cropAndResize_: lF });
function dF(e) {
  let t = _2(e, "image", "flipLeftRight", "float32");
  O2(t.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);
  let n10 = { image: t };
  return M2.runKernel(mo, n10, {});
}
var pF = L2({ flipLeftRight_: dF });
function hF(e) {
  let t = _2(e, "image", "grayscaleToRGB"), n10 = t.rank - 1, s10 = t.shape[n10];
  O2(t.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`), O2(s10 === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s10}.`);
  let r10 = new Array(t.rank);
  return r10.fill(1, 0, n10), r10[n10] = 3, cs(t, r10);
}
var fF = L2({ grayscaleToRGB_: hF });
function mF(e, t, n10 = 0, s10 = 0.5) {
  let r10 = _2(e, "image", "rotateWithOffset", "float32");
  O2(r10.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${r10.rank}.`);
  let a10 = { image: r10 }, i10 = { radians: t, fillValue: n10, center: s10 };
  return M2.runKernel(Ho, a10, i10);
}
var gF = L2({ rotateWithOffset_: mF });
function Xo(e, t, n10, s10, r10, a10) {
  s10 == null && (s10 = 0.5), r10 == null && (r10 = Number.NEGATIVE_INFINITY), a10 == null && (a10 = 0);
  let i10 = e.shape[0];
  return n10 = Math.min(n10, i10), O2(0 <= s10 && s10 <= 1, () => `iouThreshold must be in [0, 1], but was '${s10}'`), O2(e.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${e.rank}'`), O2(e.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`), O2(t.rank === 1, () => "scores must be a 1D tensor"), O2(t.shape[0] === i10, () => `scores has incompatible shape with boxes. Expected ${i10}, but was ${t.shape[0]}`), O2(0 <= a10 && a10 <= 1, () => `softNmsSigma must be in [0, 1], but was '${a10}'`), { maxOutputSize: n10, iouThreshold: s10, scoreThreshold: r10, softNmsSigma: a10 };
}
function bF(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY) {
  let a10 = _2(e, "boxes", "nonMaxSuppression", "float32"), i10 = _2(t, "scores", "nonMaxSuppression", "float32"), o10 = Xo(a10, i10, n10, s10, r10);
  n10 = o10.maxOutputSize, s10 = o10.iouThreshold, r10 = o10.scoreThreshold;
  let u10 = { maxOutputSize: n10, iouThreshold: s10, scoreThreshold: r10 };
  return M2.runKernel(So, { boxes: a10, scores: i10 }, u10);
}
var yF = L2({ nonMaxSuppression_: bF });
function vF(e, t, n10) {
  let s10 = xF(e, t, n10), r10 = s10 < 0 ? -(s10 + 1) : s10;
  e.splice(r10, 0, t);
}
function xF(e, t, n10) {
  return kF(e, t, n10 || wF);
}
function wF(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}
function kF(e, t, n10) {
  let s10 = 0, r10 = e.length, a10 = 0, i10 = false;
  for (; s10 < r10; ) {
    a10 = s10 + (r10 - s10 >>> 1);
    let o10 = n10(t, e[a10]);
    o10 > 0 ? s10 = a10 + 1 : (r10 = a10, i10 = !o10);
  }
  return i10 ? s10 : -s10 - 1;
}
function NI(e, t, n10, s10, r10) {
  return db(e, t, n10, s10, r10, 0);
}
function TI(e, t, n10, s10, r10, a10) {
  return db(e, t, n10, s10, r10, 0, false, a10, true);
}
function $I(e, t, n10, s10, r10, a10) {
  return db(e, t, n10, s10, r10, a10, true);
}
function db(e, t, n10, s10, r10, a10, i10 = false, o10 = false, u10 = false) {
  let l10 = [];
  for (let g10 = 0; g10 < t.length; g10++)
    t[g10] > r10 && l10.push({ score: t[g10], boxIndex: g10, suppressBeginIndex: 0 });
  l10.sort(dx);
  let c10 = a10 > 0 ? -0.5 / a10 : 0, p10 = [], d10 = [];
  for (; p10.length < n10 && l10.length > 0; ) {
    let g10 = l10.pop(), { score: b10, boxIndex: y10, suppressBeginIndex: v10 } = g10;
    if (b10 < r10)
      break;
    let x10 = false;
    for (let k10 = p10.length - 1; k10 >= v10; --k10) {
      let C10 = IF(e, y10, p10[k10]);
      if (C10 >= s10) {
        x10 = true;
        break;
      }
      if (g10.score = g10.score * SF(s10, c10, C10), g10.score <= r10)
        break;
    }
    g10.suppressBeginIndex = p10.length, x10 || (g10.score === b10 ? (p10.push(y10), d10.push(g10.score)) : g10.score > r10 && vF(l10, g10, dx));
  }
  let h10 = p10.length, f10 = n10 - h10;
  o10 && f10 > 0 && (p10.push(...new Array(f10).fill(0)), d10.push(...new Array(f10).fill(0)));
  let m10 = { selectedIndices: p10 };
  return i10 && (m10.selectedScores = d10), u10 && (m10.validOutputs = h10), m10;
}
function IF(e, t, n10) {
  let s10 = e.subarray(t * 4, t * 4 + 4), r10 = e.subarray(n10 * 4, n10 * 4 + 4), a10 = Math.min(s10[0], s10[2]), i10 = Math.min(s10[1], s10[3]), o10 = Math.max(s10[0], s10[2]), u10 = Math.max(s10[1], s10[3]), l10 = Math.min(r10[0], r10[2]), c10 = Math.min(r10[1], r10[3]), p10 = Math.max(r10[0], r10[2]), d10 = Math.max(r10[1], r10[3]), h10 = (o10 - a10) * (u10 - i10), f10 = (p10 - l10) * (d10 - c10);
  if (h10 <= 0 || f10 <= 0)
    return 0;
  let m10 = Math.max(a10, l10), g10 = Math.max(i10, c10), b10 = Math.min(o10, p10), y10 = Math.min(u10, d10), v10 = Math.max(b10 - m10, 0) * Math.max(y10 - g10, 0);
  return v10 / (h10 + f10 - v10);
}
function SF(e, t, n10) {
  let s10 = Math.exp(t * n10 * n10);
  return n10 <= e ? s10 : 0;
}
function dx(e, t) {
  return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
}
async function CF(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY) {
  let a10 = _2(e, "boxes", "nonMaxSuppressionAsync"), i10 = _2(t, "scores", "nonMaxSuppressionAsync"), o10 = Xo(a10, i10, n10, s10, r10);
  n10 = o10.maxOutputSize, s10 = o10.iouThreshold, r10 = o10.scoreThreshold;
  let u10 = await Promise.all([a10.data(), i10.data()]), l10 = u10[0], c10 = u10[1], { selectedIndices: p10 } = NI(l10, c10, n10, s10, r10);
  return a10 !== e && a10.dispose(), i10 !== t && i10.dispose(), Qt(p10, "int32");
}
var NF = CF;
function TF(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY, a10 = 0) {
  let i10 = _2(e, "boxes", "nonMaxSuppression"), o10 = _2(t, "scores", "nonMaxSuppression"), u10 = Xo(i10, o10, n10, s10, r10, a10);
  n10 = u10.maxOutputSize, s10 = u10.iouThreshold, r10 = u10.scoreThreshold, a10 = u10.softNmsSigma;
  let l10 = { boxes: i10, scores: o10 }, c10 = { maxOutputSize: n10, iouThreshold: s10, scoreThreshold: r10, softNmsSigma: a10 }, p10 = M2.runKernel(Co, l10, c10);
  return { selectedIndices: p10[0], selectedScores: p10[1] };
}
var $F = L2({ nonMaxSuppressionWithScore_: TF });
async function _F(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY, a10 = 0) {
  let i10 = _2(e, "boxes", "nonMaxSuppressionAsync"), o10 = _2(t, "scores", "nonMaxSuppressionAsync"), u10 = Xo(i10, o10, n10, s10, r10, a10);
  n10 = u10.maxOutputSize, s10 = u10.iouThreshold, r10 = u10.scoreThreshold, a10 = u10.softNmsSigma;
  let l10 = await Promise.all([i10.data(), o10.data()]), c10 = l10[0], p10 = l10[1], { selectedIndices: d10, selectedScores: h10 } = $I(c10, p10, n10, s10, r10, a10);
  return i10 !== e && i10.dispose(), o10 !== t && o10.dispose(), { selectedIndices: Qt(d10, "int32"), selectedScores: Qt(h10) };
}
var AF = _F;
function EF(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY, a10 = false) {
  let i10 = _2(e, "boxes", "nonMaxSuppression"), o10 = _2(t, "scores", "nonMaxSuppression"), u10 = Xo(i10, o10, n10, s10, r10, null), l10 = u10.maxOutputSize, c10 = u10.iouThreshold, p10 = u10.scoreThreshold, d10 = { boxes: i10, scores: o10 }, h10 = { maxOutputSize: l10, iouThreshold: c10, scoreThreshold: p10, padToMaxOutputSize: a10 }, f10 = M2.runKernel(xl, d10, h10);
  return { selectedIndices: f10[0], validOutputs: f10[1] };
}
var RF = L2({ nonMaxSuppressionPadded_: EF });
async function DF(e, t, n10, s10 = 0.5, r10 = Number.NEGATIVE_INFINITY, a10 = false) {
  let i10 = _2(e, "boxes", "nonMaxSuppressionAsync"), o10 = _2(t, "scores", "nonMaxSuppressionAsync"), u10 = Xo(i10, o10, n10, s10, r10, null), l10 = u10.maxOutputSize, c10 = u10.iouThreshold, p10 = u10.scoreThreshold, [d10, h10] = await Promise.all([i10.data(), o10.data()]), { selectedIndices: f10, validOutputs: m10 } = TI(d10, h10, l10, c10, p10, a10);
  return i10 !== e && i10.dispose(), o10 !== t && o10.dispose(), { selectedIndices: Qt(f10, "int32"), validOutputs: Ie2(m10, "int32") };
}
var FF = DF;
function OF(e, t, n10 = false, s10 = false) {
  let r10 = _2(e, "images", "resizeBilinear");
  O2(r10.rank === 3 || r10.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r10.rank}.`), O2(t.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`), O2(s10 === false || n10 === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let a10 = r10, i10 = false;
  r10.rank === 3 && (i10 = true, a10 = G2(r10, [1, r10.shape[0], r10.shape[1], r10.shape[2]]));
  let [] = t, o10 = { images: a10 }, u10 = { alignCorners: n10, halfPixelCenters: s10, size: t }, l10 = M2.runKernel(Ja, o10, u10);
  return i10 ? G2(l10, [l10.shape[1], l10.shape[2], l10.shape[3]]) : l10;
}
var PF = L2({ resizeBilinear_: OF });
function zF(e, t, n10 = false, s10 = false) {
  let r10 = _2(e, "images", "resizeNearestNeighbor");
  O2(r10.rank === 3 || r10.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r10.rank}.`), O2(t.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`), O2(r10.dtype === "float32" || r10.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), O2(s10 === false || n10 === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let a10 = r10, i10 = false;
  r10.rank === 3 && (i10 = true, a10 = G2(r10, [1, r10.shape[0], r10.shape[1], r10.shape[2]]));
  let [] = t, o10 = { images: a10 }, u10 = { alignCorners: n10, halfPixelCenters: s10, size: t }, l10 = M2.runKernel(Il, o10, u10);
  return i10 ? G2(l10, [l10.shape[1], l10.shape[2], l10.shape[3]]) : l10;
}
var MF = L2({ resizeNearestNeighbor_: zF });
function LF(e, t = "binary", n10 = false, s10 = 0.5) {
  let r10 = _2(e, "image", "threshold"), a10 = 0.2989, i10 = 0.587, o10 = 0.114, u10 = r10.shape[0] * r10.shape[1], l10 = V2(Qt([s10]), 255), c10, p10, d10, h10;
  if (O2(r10.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${r10.rank}.`), O2(r10.shape[2] === 3 || r10.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${r10.shape[2]}.`), O2(r10.dtype === "int32" || r10.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${r10.dtype}.`), O2(t === "otsu" || t === "binary", () => `Method must be binary or otsu, but was ${t}`), r10.shape[2] === 3) {
    [c10, p10, d10] = Ln(r10, [1, 1, 1], -1);
    let g10 = V2(c10, a10), b10 = V2(p10, i10), y10 = V2(d10, o10);
    h10 = ie2(ie2(g10, b10), y10);
  } else
    h10 = e;
  if (t === "otsu") {
    let g10 = Hk(ce2(uI(h10), "int32"), hs([]), 256);
    l10 = BF(g10, u10);
  }
  let f10 = n10 ? Ko(h10, l10) : Wn(h10, l10);
  return ce2(V2(f10, 255), "int32");
}
function BF(e, t) {
  let n10 = Qt([-1]), s10 = Qt([0]), r10 = Qt([0]), a10, i10, o10, u10, l10, c10;
  for (let p10 = 0; p10 < e.size - 1; p10++) {
    a10 = He(e, 0, p10 + 1), i10 = He(e, p10 + 1), l10 = xe2(ye2(a10), t), c10 = xe2(ye2(i10), t);
    let d10 = ye2(V2(a10, Xu(0, a10.size)));
    o10 = xe2(d10, ye2(a10));
    let h10 = Fl(i10.shape, a10.size), f10 = ie2(Xu(0, i10.size), h10), m10 = V2(i10, f10);
    u10 = xe2(ye2(m10), ye2(i10));
    let g10 = ge2(o10, u10), b10 = ge2(o10, u10), y10 = V2(l10, c10);
    r10 = V2(V2(y10, g10), b10);
    let v10 = Wn(r10, s10);
    s10 = vn(v10, r10, s10), n10 = vn(v10, Qt([p10]), n10);
  }
  return n10;
}
var VF = L2({ threshold_: LF });
function WF(e, t, n10 = "nearest", s10 = "constant", r10 = 0, a10) {
  let i10 = _2(e, "image", "transform", "float32"), o10 = _2(t, "transforms", "transform", "float32");
  O2(i10.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${i10.rank}.`), O2(o10.rank === 2 && (o10.shape[0] === i10.shape[0] || o10.shape[0] === 1) && o10.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), O2(a10 == null || a10.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${a10}.`);
  let u10 = { image: i10, transforms: o10 }, l10 = { interpolation: n10, fillMode: s10, fillValue: r10, outputShape: a10 };
  return M2.runKernel(Wo, u10, l10);
}
var UF = L2({ transform_: WF });
function GF(e, t, n10) {
  O2(t % 1 === 0, () => `bandPart(): numLower must be an integer, got ${t}.`), O2(n10 % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${n10}.`);
  let s10 = _2(e, "a", "bandPart");
  O2(s10.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${s10.rank}.`);
  let r10 = s10.shape, [a10, i10] = s10.shape.slice(-2);
  if (!(t <= a10))
    throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a10}).`);
  if (!(n10 <= i10))
    throw new Error(`bandPart(): numUpper (${n10}) must not be greater than the number of columns (${i10}).`);
  t < 0 && (t = a10), n10 < 0 && (n10 = i10);
  let o10 = G2(Xu(0, a10, 1, "int32"), [-1, 1]), u10 = Xu(0, i10, 1, "int32"), l10 = ge2(o10, u10), c10 = Ds(Ko(l10, Ie2(+t, "int32")), jo(l10, Ie2(-n10, "int32"))), p10 = $t([a10, i10], s10.dtype);
  return G2(Qn(Fs(G2(s10, [-1, a10, i10])).map((d10) => vn(c10, d10, p10))), r10);
}
var HF = L2({ bandPart_: GF });
function qF(e) {
  let t;
  if (Array.isArray(e)) {
    t = false, O2(e != null && e.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    let r10 = e[0].shape[0];
    for (let a10 = 1; a10 < e.length; ++a10)
      O2(e[a10].shape[0] === r10, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a10].shape[0]} vs. ${r10})`);
  } else
    t = true, e = Ln(e, e.shape[0], 0).map((r10) => mr(r10, [0]));
  O2(e.length <= e[0].shape[0], () => `Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);
  let n10 = [], s10 = e;
  for (let r10 = 0; r10 < e.length; ++r10)
    n10.push(M2.tidy(() => {
      let a10 = s10[r10];
      if (r10 > 0)
        for (let i10 = 0; i10 < r10; ++i10) {
          let o10 = V2(ye2(V2(n10[i10], a10)), n10[i10]);
          a10 = ge2(a10, o10);
        }
      return xe2(a10, vI(a10, "euclidean"));
    }));
  return t ? Qn(n10, 0) : n10;
}
var jF = L2({ gramSchmidt_: qF });
function KF(e, t = false) {
  if (O2(e.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`), e.rank === 2)
    return px2(e, t);
  {
    let n10 = e.shape.slice(0, e.shape.length - 2).reduce((u10, l10) => u10 * l10), s10 = Fs(G2(e, [n10, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0), r10 = [], a10 = [];
    s10.forEach((u10) => {
      let [l10, c10] = px2(u10, t);
      r10.push(l10), a10.push(c10);
    });
    let i10 = G2(Qn(r10, 0), e.shape), o10 = G2(Qn(a10, 0), e.shape);
    return [i10, o10];
  }
}
function px2(e, t = false) {
  return M2.tidy(() => {
    O2(e.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);
    let n10 = e.shape[0], s10 = e.shape[1], r10 = Zk(n10), a10 = lr(e), i10 = ji([[1]], [1, 1]), o10 = lr(i10), u10 = n10 >= s10 ? s10 : n10;
    for (let l10 = 0; l10 < u10; ++l10) {
      let c10 = a10, p10 = o10, d10 = r10;
      [o10, a10, r10] = M2.tidy(() => {
        let h10 = He(a10, [l10, l10], [n10 - l10, 1]), f10 = vI(h10), m10 = He(a10, [l10, l10], [1, 1]), g10 = vn(Wn(m10, 0), ji([[-1]]), ji([[1]])), b10 = ge2(m10, V2(g10, f10)), y10 = xe2(h10, b10);
        y10.shape[0] === 1 ? o10 = lr(i10) : o10 = Ft([i10, He(y10, [1, 0], [y10.shape[0] - 1, y10.shape[1]])], 0);
        let v10 = kt(xe2(We(g10, b10), f10)), x10 = He(a10, [l10, 0], [n10 - l10, s10]), k10 = V2(v10, o10), C10 = qe(o10);
        if (l10 === 0)
          a10 = ge2(x10, We(k10, We(C10, x10)));
        else {
          let A10 = ge2(x10, We(k10, We(C10, x10)));
          a10 = Ft([He(a10, [0, 0], [l10, s10]), A10], 0);
        }
        let T10 = qe(k10), E10 = He(r10, [0, l10], [n10, r10.shape[1] - l10]);
        if (l10 === 0)
          r10 = ge2(E10, We(We(E10, o10), T10));
        else {
          let A10 = ge2(E10, We(We(E10, o10), T10));
          r10 = Ft([He(r10, [0, 0], [n10, l10]), A10], 1);
        }
        return [o10, a10, r10];
      }), Re2([c10, p10, d10]);
    }
    return !t && n10 > s10 && (r10 = He(r10, [0, 0], [n10, s10]), a10 = He(a10, [0, 0], [s10, s10])), [r10, a10];
  });
}
var XF = L2({ qr_: KF });
var YF = ((e) => (e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS", e))(YF || {});
function QF(e, t, n10 = 3) {
  let s10 = _2(e, "losses", "computeWeightedLoss"), r10 = null;
  t != null && (r10 = _2(t, "weights", "computeWeightedLoss"));
  let a10 = r10 == null ? s10 : V2(s10, r10);
  if (n10 === 0)
    return a10;
  if (n10 === 2)
    return ye2(a10);
  if (n10 === 1) {
    if (r10 == null)
      return It(a10);
    {
      let i10 = s10.size / r10.size, o10 = xe2(ye2(a10), ye2(r10));
      return i10 > 1 ? xe2(o10, Ie2(i10)) : o10;
    }
  }
  if (n10 === 3) {
    if (r10 == null)
      return xe2(ye2(a10), Ie2(s10.size));
    {
      let i10 = V2(r10, zn(s10.shape)), o10 = ce2(ye2(Ku(i10, Ie2(0))), "float32");
      return xe2(ye2(a10), o10);
    }
  }
  throw Error(`Unknown reduction: ${n10}`);
}
var Ys = L2({ computeWeightedLoss_: QF });
function ZF(e, t, n10, s10 = 3) {
  let r10 = _2(e, "labels", "absoluteDifference"), a10 = _2(t, "predictions", "absoluteDifference"), i10 = null;
  n10 != null && (i10 = _2(n10, "weights", "absoluteDifference")), dn(r10.shape, a10.shape, "Error in absoluteDifference: ");
  let o10 = Mt(ge2(r10, a10));
  return Ys(o10, i10, s10);
}
var JF = L2({ absoluteDifference_: ZF });
function eO(e, t, n10, s10, r10 = 3) {
  let a10 = _2(e, "labels", "cosineDistance"), i10 = _2(t, "predictions", "cosineDistance"), o10 = null;
  s10 != null && (o10 = _2(s10, "weights", "cosineDistance")), dn(a10.shape, i10.shape, "Error in cosineDistance: ");
  let u10 = Ie2(1), l10 = ge2(u10, ye2(V2(a10, i10), n10, true));
  return Ys(l10, o10, r10);
}
var tO = L2({ cosineDistance_: eO });
function nO(e, t, n10, s10 = 3) {
  let r10 = _2(e, "labels", "hingeLoss"), a10 = _2(t, "predictions", "hingeLoss"), i10 = null;
  n10 != null && (i10 = _2(n10, "weights", "hingeLoss")), dn(r10.shape, a10.shape, "Error in hingeLoss: ");
  let o10 = Ie2(1);
  r10 = ge2(V2(Ie2(2), r10), o10);
  let u10 = Xs(ge2(o10, V2(r10, a10)));
  return Ys(u10, i10, s10);
}
var sO = L2({ hingeLoss_: nO });
function rO(e, t, n10, s10 = 1, r10 = 3) {
  let a10 = _2(e, "labels", "huberLoss"), i10 = _2(t, "predictions", "huberLoss"), o10 = null;
  n10 != null && (o10 = _2(n10, "weights", "huberLoss")), dn(a10.shape, i10.shape, "Error in huberLoss: ");
  let u10 = Ie2(s10), l10 = Mt(ge2(i10, a10)), c10 = gp(l10, u10), p10 = ge2(l10, c10), d10 = ie2(V2(Ie2(0.5), ct(c10)), V2(u10, p10));
  return Ys(d10, o10, r10);
}
var aO = L2({ huberLoss_: rO });
function iO(e, t, n10, s10 = 1e-7, r10 = 3) {
  let a10 = _2(e, "labels", "logLoss"), i10 = _2(t, "predictions", "logLoss"), o10 = null;
  n10 != null && (o10 = _2(n10, "weights", "logLoss")), dn(a10.shape, i10.shape, "Error in logLoss: ");
  let u10 = Ie2(1), l10 = Ie2(s10), c10 = kt(V2(a10, Kn(ie2(i10, l10)))), p10 = V2(ge2(u10, a10), Kn(ie2(ge2(u10, i10), l10))), d10 = ge2(c10, p10);
  return Ys(d10, o10, r10);
}
var oO = L2({ logLoss_: iO });
function uO(e, t, n10, s10 = 3) {
  let r10 = _2(e, "labels", "meanSquaredError"), a10 = _2(t, "predictions", "meanSquaredError"), i10 = null;
  n10 != null && (i10 = _2(n10, "weights", "meanSquaredError")), dn(r10.shape, a10.shape, "Error in meanSquaredError: ");
  let o10 = mI(r10, a10);
  return Ys(o10, i10, s10);
}
var lO = L2({ meanSquaredError_: uO });
function cO(e, t) {
  let n10 = _2(e, "labels", "sigmoidCrossEntropyWithLogits"), s10 = _2(t, "logits", "sigmoidCrossEntropyWithLogits");
  dn(n10.shape, s10.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  let r10 = Xs(s10), a10 = V2(s10, n10), i10 = Kg(jn(kt(Mt(s10))));
  return ie2(ge2(r10, a10), i10);
}
function dO(e, t, n10, s10 = 0, r10 = 3) {
  let a10 = _2(e, "multiClassLabels", "sigmoidCrossEntropy"), i10 = _2(t, "logits", "sigmoidCrossEntropy"), o10 = null;
  if (n10 != null && (o10 = _2(n10, "weights", "sigmoidCrossEntropy")), dn(a10.shape, i10.shape, "Error in sigmoidCrossEntropy: "), s10 > 0) {
    let l10 = Ie2(s10), c10 = Ie2(1), p10 = Ie2(0.5);
    a10 = ie2(V2(a10, ge2(c10, l10)), V2(p10, l10));
  }
  let u10 = cO(a10, i10);
  return Ys(u10, o10, r10);
}
var pO = L2({ sigmoidCrossEntropy_: dO });
function hO(e, t, n10 = -1) {
  if (n10 === -1 && (n10 = t.rank - 1), n10 !== t.rank - 1)
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n10}`);
  return js((r10, a10, i10) => {
    let u10 = XR(a10, [n10], true), l10 = ge2(ce2(a10, "float32"), u10);
    i10([r10, l10]);
    let c10 = kt(V2(l10, r10));
    return { value: ye2(c10, [n10]), gradFunc: (h10, f10) => {
      let [m10, g10] = f10, b10 = la(h10.shape, [n10]);
      return [V2(G2(h10, b10), ge2(ce2(m10, "float32"), jn(g10))), V2(G2(h10, b10), ge2(jn(g10), ce2(m10, "float32")))];
    } };
  })(e, t);
}
function fO(e, t, n10, s10 = 0, r10 = 3) {
  let a10 = _2(e, "onehotLabels", "softmaxCrossEntropy"), i10 = _2(t, "logits", "softmaxCrossEntropy"), o10 = null;
  if (n10 != null && (o10 = _2(n10, "weights", "softmaxCrossEntropy")), dn(a10.shape, i10.shape, "Error in softmaxCrossEntropy: "), s10 > 0) {
    let l10 = Ie2(s10), c10 = Ie2(1), p10 = Ie2(a10.shape[1]);
    a10 = ie2(V2(a10, ge2(c10, l10)), xe2(l10, p10));
  }
  let u10 = hO(a10, i10);
  return Ys(u10, o10, r10);
}
var mO = L2({ softmaxCrossEntropy_: fO });
function gO(e, t, n10, s10) {
  let r10 = _2(e, "indices", "sparseFillEmptyRows", "int32"), a10 = _2(t, "values", "sparseFillEmptyRows"), i10 = _2(n10, "denseShape", "sparseFillEmptyRows", "int32"), o10 = _2(s10, "defaultValue", "sparseFillEmptyRows", a10.dtype);
  if (r10.rank !== 2)
    throw new Error(`Indices should be Tensor2D but received shape
        ${r10.shape}`);
  if (a10.rank !== 1)
    throw new Error(`Values should be Tensor1D but received shape ${a10.shape}`);
  if (i10.rank !== 1)
    throw new Error(`Dense shape should be Tensor1D but received shape ${i10.shape}`);
  if (o10.rank !== 0)
    throw new Error(`Default value should be a scalar but received shape ${o10.shape}`);
  let u10 = { indices: r10, values: a10, denseShape: i10, defaultValue: o10 }, l10 = M2.runKernel(np, u10);
  return { outputIndices: l10[0], outputValues: l10[1], emptyRowIndicator: l10[2], reverseIndexMap: l10[3] };
}
var bO = L2({ sparseFillEmptyRows_: gO });
function yO(e, t, n10) {
  let s10 = _2(e, "inputIndices", "sparseReshape", "int32"), r10 = _2(t, "inputShape", "sparseReshape", "int32"), a10 = _2(n10, "newShape", "sparseReshape", "int32");
  if (s10.rank !== 2)
    throw new Error(`Input indices should be Tensor2D but received shape
        ${s10.shape}`);
  if (r10.rank !== 1)
    throw new Error(`Input shape should be Tensor1D but received shape ${r10.shape}`);
  if (a10.rank !== 1)
    throw new Error(`New shape should be Tensor1D but received shape ${a10.shape}`);
  let i10 = { inputIndices: s10, inputShape: r10, newShape: a10 }, o10 = M2.runKernel(Tl, i10);
  return { outputIndices: o10[0], outputShape: o10[1] };
}
var vO = L2({ sparseReshape_: yO });
function xO(e, t, n10) {
  let s10 = _2(e, "data", "sparseSegmentMean"), r10 = _2(t, "indices", "sparseSegmentMean", "int32"), a10 = _2(n10, "segmentIds", "sparseSegmentMean", "int32");
  if (s10.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
          ${r10.shape}`);
  if (a10.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${a10.shape}`);
  let i10 = { data: s10, indices: r10, segmentIds: a10 };
  return M2.runKernel(sp, i10);
}
var wO = L2({ sparseSegmentMean_: xO });
function kO(e, t, n10) {
  let s10 = _2(e, "data", "sparseSegmentSum"), r10 = _2(t, "indices", "sparseSegmentSum", "int32"), a10 = _2(n10, "segmentIds", "sparseSegmentSum", "int32");
  if (s10.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
         ${r10.shape}`);
  if (a10.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${a10.shape}`);
  let i10 = { data: s10, indices: r10, segmentIds: a10 };
  return M2.runKernel(rp, i10);
}
var IO = L2({ sparseSegmentSum_: kO });
function SO(e, t, n10, s10, r10, a10, i10, o10) {
  let u10 = _2(e, "data", "stringNGrams", "string");
  if (u10.dtype !== "string")
    throw new Error("Data must be of datatype string");
  if (u10.shape.length !== 1)
    throw new Error(`Data must be a vector, saw: ${u10.shape}`);
  let l10 = _2(t, "dataSplits", "stringNGrams");
  if (l10.dtype !== "int32")
    throw new Error("Data splits must be of datatype int32");
  let c10 = { separator: n10, nGramWidths: s10, leftPad: r10, rightPad: a10, padWidth: i10, preserveShortSequences: o10 }, p10 = { data: u10, dataSplits: l10 }, d10 = M2.runKernel(ip, p10, c10);
  return { nGrams: d10[0], nGramsSplits: d10[1] };
}
var CO = L2({ stringNGrams_: SO });
function NO(e, t, n10 = true) {
  let s10 = _2(e, "input", "stringSplit", "string"), r10 = _2(t, "delimiter", "stringSplit", "string");
  if (s10.rank !== 1)
    throw new Error(`Input should be Tensor1D but received shape ${s10.shape}`);
  if (r10.rank !== 0)
    throw new Error(`Delimiter should be a scalar but received shape ${r10.shape}`);
  let a10 = { skipEmpty: n10 }, i10 = { input: s10, delimiter: r10 }, o10 = M2.runKernel(Ng, i10, a10);
  return { indices: o10[0], values: o10[1], shape: o10[2] };
}
var TO = L2({ stringSplit_: NO });
function $O(e, t) {
  let n10 = _2(e, "input", "stringToHashBucketFast", "string"), s10 = { numBuckets: t };
  if (t <= 0)
    throw new Error("Number of buckets must be at least 1");
  let r10 = { input: n10 };
  return M2.runKernel(Tg, r10, s10);
}
var _O = L2({ stringToHashBucketFast_: $O });
var ope = { fft: ob, ifft: kd, rfft: ub, irfft: fI };
var upe = { hammingWindow: rF, hannWindow: SI, frame: CI, stft: uF };
var ds = { flipLeftRight: pF, grayscaleToRGB: fF, resizeNearestNeighbor: MF, resizeBilinear: PF, rotateWithOffset: gF, cropAndResize: cF, nonMaxSuppression: yF, nonMaxSuppressionAsync: NF, nonMaxSuppressionWithScore: $F, nonMaxSuppressionWithScoreAsync: AF, nonMaxSuppressionPadded: RF, nonMaxSuppressionPaddedAsync: FF, threshold: VF, transform: UF };
var AO = { bandPart: HF, gramSchmidt: jF, qr: XF };
var lpe = { absoluteDifference: JF, computeWeightedLoss: Ys, cosineDistance: tO, hingeLoss: sO, huberLoss: aO, logLoss: oO, meanSquaredError: lO, sigmoidCrossEntropy: pO, softmaxCrossEntropy: mO };
var Vc = { sparseFillEmptyRows: bO, sparseReshape: vO, sparseSegmentMean: wO, sparseSegmentSum: IO };
var Pf = { stringNGrams: CO, stringSplit: TO, stringToHashBucketFast: _O };
var $r = class extends Ok {
  minimize(e, t = false, n10) {
    let { value: s10, grads: r10 } = this.computeGradients(e, n10);
    if (n10 != null) {
      let a10 = n10.map((i10) => ({ name: i10.name, tensor: r10[i10.name] }));
      this.applyGradients(a10);
    } else
      this.applyGradients(r10);
    return Re2(r10), t ? s10 : (s10.dispose(), null);
  }
  get iterations() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  computeGradients(e, t) {
    return MR(e, t);
  }
  dispose() {
    this.iterations_ != null && Re2(this.iterations_);
  }
  async saveIterations() {
    return this.iterations_ == null && (this.iterations_ = 0), { name: "iter", tensor: Ie2(this.iterations_, "int32") };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(e) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  async extractIterations(e) {
    return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1);
  }
};
Object.defineProperty($r, Symbol.hasInstance, { value: (e) => e.minimize != null && e.computeGradients != null && e.applyGradients != null });
var pb = class extends $r {
  constructor(e, t, n10 = null) {
    super();
    this.learningRate = e, this.rho = t, this.epsilon = n10, this.accumulatedGrads = [], this.accumulatedUpdates = [], n10 == null && (this.epsilon = M2.backend.epsilon());
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e)).forEach((n10, s10) => {
      let r10 = M2.registeredVariables[n10], a10 = false;
      this.accumulatedGrads[s10] == null && (this.accumulatedGrads[s10] = { originalName: `${n10}/accum_grad`, variable: j2(() => je(r10).variable(a10)) }), this.accumulatedUpdates[s10] == null && (this.accumulatedUpdates[s10] = { originalName: `${n10}/accum_var`, variable: j2(() => je(r10).variable(a10)) });
      let i10 = Array.isArray(e) ? e[s10].tensor : e[n10];
      if (i10 == null)
        return;
      let o10 = this.accumulatedGrads[s10].variable, u10 = this.accumulatedUpdates[s10].variable;
      j2(() => {
        let l10 = ie2(V2(o10, this.rho), V2(ct(i10), 1 - this.rho)), c10 = V2(xe2(ln(ie2(u10, this.epsilon)), ln(ie2(o10, this.epsilon))), i10), p10 = ie2(V2(u10, this.rho), V2(ct(c10), 1 - this.rho));
        o10.assign(l10), u10.assign(p10);
        let d10 = ie2(V2(c10, -this.learningRate), r10);
        r10.assign(d10);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedUpdates != null && (Re2(this.accumulatedGrads.map((e) => e.variable)), Re2(this.accumulatedUpdates.map((e) => e.variable)));
  }
  async getWeights() {
    let e = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(e.map((t) => ({ name: t.originalName, tensor: t.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    let t = e.length / 2, n10 = false;
    this.accumulatedGrads = e.slice(0, t).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) })), this.accumulatedUpdates = e.slice(t, t * 2).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) }));
  }
  getConfig() {
    return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.rho, t.epsilon);
  }
};
pb.className = "Adadelta";
Nr(pb);
var hb = class extends $r {
  constructor(e, t = 0.1) {
    super();
    this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = [];
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e)).forEach((n10, s10) => {
      let r10 = M2.registeredVariables[n10];
      this.accumulatedGrads[s10] == null && (this.accumulatedGrads[s10] = { originalName: `${n10}/accumulator`, variable: j2(() => Fl(r10.shape, this.initialAccumulatorValue).variable(false)) });
      let a10 = Array.isArray(e) ? e[s10].tensor : e[n10];
      if (a10 == null)
        return;
      let i10 = this.accumulatedGrads[s10].variable;
      j2(() => {
        let o10 = ie2(i10, ct(a10));
        i10.assign(o10);
        let u10 = ie2(V2(xe2(a10, ln(ie2(o10, M2.backend.epsilon()))), -this.learningRate), r10);
        r10.assign(u10);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedGrads != null && Re2(this.accumulatedGrads.map((e) => e.variable));
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    let t = false;
    this.accumulatedGrads = e.map((n10) => ({ originalName: n10.name, variable: n10.tensor.variable(t) }));
  }
  getConfig() {
    return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.initialAccumulatorValue);
  }
};
hb.className = "Adagrad";
Nr(hb);
var fb = class extends $r {
  constructor(e, t, n10, s10 = null) {
    super();
    this.learningRate = e, this.beta1 = t, this.beta2 = n10, this.epsilon = s10, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], j2(() => {
      this.accBeta1 = Ie2(t).variable(), this.accBeta2 = Ie2(n10).variable();
    }), s10 == null && (this.epsilon = M2.backend.epsilon());
  }
  applyGradients(e) {
    let t = Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e);
    j2(() => {
      let n10 = ge2(1, this.accBeta1), s10 = ge2(1, this.accBeta2);
      t.forEach((r10, a10) => {
        let i10 = M2.registeredVariables[r10], o10 = false;
        this.accumulatedFirstMoment[a10] == null && (this.accumulatedFirstMoment[a10] = { originalName: `${r10}/m`, variable: j2(() => je(i10).variable(o10)) }), this.accumulatedSecondMoment[a10] == null && (this.accumulatedSecondMoment[a10] = { originalName: `${r10}/v`, variable: j2(() => je(i10).variable(o10)) });
        let u10 = Array.isArray(e) ? e[a10].tensor : e[r10];
        if (u10 == null)
          return;
        let l10 = this.accumulatedFirstMoment[a10].variable, c10 = this.accumulatedSecondMoment[a10].variable, p10 = ie2(V2(l10, this.beta1), V2(u10, 1 - this.beta1)), d10 = ie2(V2(c10, this.beta2), V2(ct(u10), 1 - this.beta2)), h10 = xe2(p10, n10), f10 = xe2(d10, s10);
        l10.assign(p10), c10.assign(d10);
        let m10 = ie2(V2(xe2(h10, ie2(ln(f10), this.epsilon)), -this.learningRate), i10);
        i10.assign(m10);
      }), this.accBeta1.assign(V2(this.accBeta1, this.beta1)), this.accBeta2.assign(V2(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && Re2(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedSecondMoment != null && Re2(this.accumulatedSecondMoment.map((e) => e.variable));
  }
  async getWeights() {
    let e = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(e.map((t) => ({ name: t.originalName, tensor: t.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e), j2(() => {
      this.accBeta1.assign(ca(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(ca(this.beta2, this.iterations_ + 1));
    });
    let t = e.length / 2, n10 = false;
    this.accumulatedFirstMoment = e.slice(0, t).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) })), this.accumulatedSecondMoment = e.slice(t, t * 2).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) }));
  }
  getConfig() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
  }
};
fb.className = "Adam";
Nr(fb);
var mb = class extends $r {
  constructor(e, t, n10, s10 = null, r10 = 0) {
    super();
    this.learningRate = e, this.beta1 = t, this.beta2 = n10, this.epsilon = s10, this.decay = r10, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], j2(() => {
      this.iteration = Ie2(0).variable(), this.accBeta1 = Ie2(t).variable();
    }), s10 == null && (this.epsilon = M2.backend.epsilon());
  }
  applyGradients(e) {
    let t = Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e);
    j2(() => {
      let n10 = ge2(1, this.accBeta1), s10 = xe2(-this.learningRate, ie2(V2(this.iteration, this.decay), 1));
      t.forEach((r10, a10) => {
        let i10 = M2.registeredVariables[r10], o10 = false;
        this.accumulatedFirstMoment[a10] == null && (this.accumulatedFirstMoment[a10] = { originalName: `${r10}/m`, variable: je(i10).variable(o10) }), this.accumulatedWeightedInfNorm[a10] == null && (this.accumulatedWeightedInfNorm[a10] = { originalName: `${r10}/v`, variable: je(i10).variable(o10) });
        let u10 = Array.isArray(e) ? e[a10].tensor : e[r10];
        if (u10 == null)
          return;
        let l10 = this.accumulatedFirstMoment[a10].variable, c10 = this.accumulatedWeightedInfNorm[a10].variable, p10 = ie2(V2(l10, this.beta1), V2(u10, 1 - this.beta1)), d10 = V2(c10, this.beta2), h10 = Mt(u10), f10 = Tr(d10, h10);
        l10.assign(p10), c10.assign(f10);
        let m10 = ie2(V2(xe2(s10, n10), xe2(p10, ie2(f10, this.epsilon))), i10);
        i10.assign(m10);
      }), this.iteration.assign(ie2(this.iteration, 1)), this.accBeta1.assign(V2(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && Re2(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedWeightedInfNorm != null && Re2(this.accumulatedWeightedInfNorm.map((e) => e.variable));
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(e) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
  }
};
mb.className = "Adamax";
Nr(mb);
var kp = class extends $r {
  constructor(e) {
    super();
    this.learningRate = e, this.setLearningRate(e);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e)).forEach((n10, s10) => {
      let r10 = Array.isArray(e) ? e[s10].tensor : e[n10];
      if (r10 == null)
        return;
      let a10 = M2.registeredVariables[n10];
      j2(() => {
        let i10 = ie2(V2(this.c, r10), a10);
        a10.assign(i10);
      });
    }), this.incrementIterations();
  }
  setLearningRate(e) {
    this.learningRate = e, this.c != null && this.c.dispose(), this.c = Ht(Ie2(-e));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(e) {
    if (e = await this.extractIterations(e), e.length !== 0)
      throw new Error("SGD optimizer does not have settable weights.");
  }
  getConfig() {
    return { learningRate: this.learningRate };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate);
  }
};
kp.className = "SGD";
Nr(kp);
var gb = class extends kp {
  constructor(e, t, n10 = false) {
    super(e);
    this.learningRate = e, this.momentum = t, this.useNesterov = n10, this.accumulations = [], this.m = Ie2(this.momentum);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e)).forEach((n10, s10) => {
      let r10 = M2.registeredVariables[n10];
      this.accumulations[s10] == null && (this.accumulations[s10] = { originalName: `${n10}/momentum`, variable: j2(() => je(r10).variable(false)) });
      let a10 = this.accumulations[s10].variable, i10 = Array.isArray(e) ? e[s10].tensor : e[n10];
      i10 != null && j2(() => {
        let o10, u10 = ie2(V2(this.m, a10), i10);
        this.useNesterov ? o10 = ie2(V2(this.c, ie2(i10, V2(u10, this.m))), r10) : o10 = ie2(V2(this.c, u10), r10), a10.assign(u10), r10.assign(o10);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.m.dispose(), this.accumulations != null && Re2(this.accumulations.map((e) => e.variable));
  }
  setMomentum(e) {
    this.momentum = e;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    let t = false;
    this.accumulations = e.map((n10) => ({ originalName: n10.name, variable: n10.tensor.variable(t) }));
  }
  getConfig() {
    return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.momentum, t.useNesterov);
  }
};
gb.className = "Momentum";
Nr(gb);
var bb = class extends $r {
  constructor(e, t = 0.9, n10 = 0, s10 = null, r10 = false) {
    super();
    if (this.learningRate = e, this.decay = t, this.momentum = n10, this.epsilon = s10, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r10, s10 == null && (this.epsilon = M2.backend.epsilon()), e == null)
      throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((n10) => n10.name) : Object.keys(e)).forEach((n10, s10) => {
      let r10 = M2.registeredVariables[n10], a10 = false;
      this.accumulatedMeanSquares[s10] == null && (this.accumulatedMeanSquares[s10] = { originalName: `${n10}/rms`, variable: j2(() => je(r10).variable(a10)) }), this.accumulatedMoments[s10] == null && (this.accumulatedMoments[s10] = { originalName: `${n10}/momentum`, variable: j2(() => je(r10).variable(a10)) }), this.accumulatedMeanGrads[s10] == null && this.centered && (this.accumulatedMeanGrads[s10] = { originalName: `${n10}/mg`, variable: j2(() => je(r10).variable(a10)) });
      let i10 = Array.isArray(e) ? e[s10].tensor : e[n10];
      if (i10 == null)
        return;
      let o10 = this.accumulatedMeanSquares[s10].variable, u10 = this.accumulatedMoments[s10].variable;
      j2(() => {
        let l10 = ie2(V2(o10, this.decay), V2(ct(i10), 1 - this.decay));
        if (this.centered) {
          let c10 = this.accumulatedMeanGrads[s10].variable, p10 = ie2(V2(c10, this.decay), V2(i10, 1 - this.decay)), d10 = xe2(V2(i10, this.learningRate), ln(ge2(l10, ie2(ct(p10), this.epsilon)))), h10 = ie2(V2(u10, this.momentum), d10);
          o10.assign(l10), c10.assign(p10), u10.assign(h10);
          let f10 = ge2(r10, h10);
          r10.assign(f10);
        } else {
          let c10 = ie2(V2(o10, this.decay), V2(ct(i10), 1 - this.decay)), p10 = ie2(V2(u10, this.momentum), xe2(V2(i10, this.learningRate), ln(ie2(c10, this.epsilon))));
          o10.assign(c10), u10.assign(p10);
          let d10 = ge2(r10, p10);
          r10.assign(d10);
        }
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedMeanSquares != null && Re2(this.accumulatedMeanSquares.map((e) => e.variable)), this.accumulatedMeanGrads != null && this.centered && Re2(this.accumulatedMeanGrads.map((e) => e.variable)), this.accumulatedMoments != null && Re2(this.accumulatedMoments.map((e) => e.variable));
  }
  async getWeights() {
    let e = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    return this.centered && e.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e.map((t) => ({ name: t.originalName, tensor: t.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    let t = this.centered ? e.length / 3 : e.length / 2, n10 = false;
    this.accumulatedMeanSquares = e.slice(0, t).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) })), this.accumulatedMoments = e.slice(t, t * 2).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) })), this.centered && (this.accumulatedMeanGrads = e.slice(t * 2, t * 3).map((s10) => ({ originalName: s10.name, variable: s10.tensor.variable(n10) })));
  }
  getConfig() {
    return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
  }
  static fromConfig(e, t) {
    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
  }
};
bb.className = "RMSProp";
Nr(bb);
var Vr = class {
  static sgd(e) {
    return new kp(e);
  }
  static momentum(e, t, n10 = false) {
    return new gb(e, t, n10);
  }
  static rmsprop(e, t = 0.9, n10 = 0, s10 = null, r10 = false) {
    return new bb(e, t, n10, s10, r10);
  }
  static adam(e = 1e-3, t = 0.9, n10 = 0.999, s10 = null) {
    return new fb(e, t, n10, s10);
  }
  static adadelta(e = 1e-3, t = 0.95, n10 = null) {
    return new pb(e, t, n10);
  }
  static adamax(e = 2e-3, t = 0.9, n10 = 0.999, s10 = null, r10 = 0) {
    return new mb(e, t, n10, s10, r10);
  }
  static adagrad(e, t = 0.1) {
    return new hb(e, t);
  }
};
var Fi = { sgd: Vr.sgd, momentum: Vr.momentum, adadelta: Vr.adadelta, adagrad: Vr.adagrad, rmsprop: Vr.rmsprop, adamax: Vr.adamax, adam: Vr.adam };
var EO = (() => typeof requestAnimationFrame != "undefined" ? requestAnimationFrame : typeof setImmediate != "undefined" ? setImmediate : (e) => e())();
function RO() {
  return new Promise((e) => EO(() => e()));
}
var N2 = {};
Ae(N2, { ERF_A1: () => UO, ERF_A2: () => GO, ERF_A3: () => HO, ERF_A4: () => qO, ERF_A5: () => jO, ERF_P: () => WO, PARALLELIZE_THRESHOLD: () => yb, SELU_SCALE: () => AI, SELU_SCALEALPHA: () => _I, applyActivation: () => xp, assertAndGetBroadcastShape: () => it, assertAxesAreInnerMostDims: () => qR, assertParamsConsistent: () => DO, assignToTypedArray: () => JO, axesAreInnerMostDims: () => Xg, calculateShapes: () => Ck, checkEinsumDimSizes: () => aP, checkPadOnDimRoundingMode: () => pn, combineLocations: () => tI, complexWithEvenIndex: () => YO, complexWithOddIndex: () => QO, computeConv2DInfo: () => Dl, computeConv3DInfo: () => Wk, computeDefaultPad: () => Vg, computeDilation2DInfo: () => tE, computeOptimalWindowSize: () => OO, computeOutAndReduceShapes: () => nI, computeOutShape: () => FO, computePool2DInfo: () => Vk, computePool3DInfo: () => nE, convertConv2DDataFormat: () => Uk, decodeEinsumEquation: () => sP, eitherStridesOrDilationsAreOne: () => Ps, expandShapeToKeepDim: () => la, exponent: () => tP, exponents: () => eP, fromStringArrayToUint8: () => NP, fromUint8ToStringArray: () => CP, getAxesPermutation: () => sI, getBroadcastDims: () => vk, getComplexWithIndex: () => ZO, getEinsumComputePath: () => iP, getEinsumPermutation: () => rP, getFusedBiasGradient: () => vp, getFusedDyActivation: () => yp, getImageCenter: () => PO, getInnerMostAxes: () => jR, getPermuted: () => MO, getReductionAxes: () => _t, getReshaped: () => zO, getReshapedPermuted: () => LO, getSliceBeginCoords: () => BO, getSliceSize: () => VO, getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => cP, getSparseFillEmptyRowsNegativeIndexErrorMessage: () => dP, getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => pP, getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => mP, getSparseReshapeInputOutputMismatchErrorMessage: () => bP, getSparseReshapeInputOutputMultipleErrorMessage: () => gP, getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => hP, getSparseReshapeNegativeOutputDimErrorMessage: () => fP, getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => wP, getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => yP, getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => vP, getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => xP, getUndoAxesPermutation: () => Yg, isIdentityPermutation: () => oP, log: () => I$, mergeRealAndImagArrays: () => KO, prepareAndValidate: () => Ik, prepareSplitSize: () => lP, segment_util: () => EI, shouldFuse: () => wp, slice_util: () => wt, splitRealAndImagArrays: () => XO, tupleValuesAreOne: () => fr, upcastType: () => yn, validateInput: () => Mg, validateUpdateShape: () => zg, warn: () => ar });
function DO(e, t) {
  let n10 = e[0].length;
  e.forEach((r10, a10) => {
    O2(r10.length === n10, () => `Error in concat${n10}D: rank of tensors[${a10}] must be the same as the rank of the rest (${n10})`);
  }), O2(t >= 0 && t < n10, () => `Error in concat${n10}D: axis must be between 0 and ${n10 - 1}.`);
  let s10 = e[0];
  e.forEach((r10, a10) => {
    for (let i10 = 0; i10 < n10; i10++)
      O2(i10 === t || r10[i10] === s10[i10], () => `Error in concat${n10}D: Shape of tensors[${a10}] (${r10}) does not match the shape of the rest (${s10}) along the non-concatenated axis ${a10}.`);
  });
}
function FO(e, t) {
  let n10 = e[0].slice();
  for (let s10 = 1; s10 < e.length; s10++)
    n10[t] += e[s10][t];
  return n10;
}
var yb = 30;
function OO(e) {
  return e <= yb ? e : pd(e, Math.floor(Math.sqrt(e)));
}
function PO(e, t, n10) {
  let s10 = n10 * (typeof e == "number" ? e : e[0]), r10 = t * (typeof e == "number" ? e : e[1]);
  return [s10, r10];
}
function zO(e, t, n10, s10 = true) {
  let r10 = [];
  if (s10)
    r10 = r10.concat(t.slice(0)), r10.push(e[0] / n10), r10 = r10.concat(e.slice(1));
  else {
    r10 = r10.concat(e[0]);
    let a10 = t.length;
    for (let i10 = 0; i10 < a10; ++i10)
      r10 = r10.concat([e[i10 + 1] / t[i10], t[i10]]);
    r10 = r10.concat(e.slice(a10 + 1));
  }
  return r10;
}
function MO(e, t, n10 = true) {
  let s10 = [];
  if (n10) {
    s10.push(t);
    for (let r10 = t + 1; r10 < e; ++r10)
      r10 <= 2 * t ? (s10.push(r10), s10.push(r10 - (t + 1))) : s10.push(r10);
  } else {
    let r10 = [], a10 = [];
    for (let i10 = 1; i10 < e; ++i10)
      i10 >= t * 2 + 1 || i10 % 2 === 1 ? a10.push(i10) : r10.push(i10);
    s10.push(...r10), s10.push(0), s10.push(...a10);
  }
  return s10;
}
function LO(e, t, n10, s10 = true) {
  let r10 = [];
  s10 ? r10.push(e[0] / n10) : r10.push(e[0] * n10);
  for (let a10 = 1; a10 < e.length; ++a10)
    a10 <= t.length ? s10 ? r10.push(t[a10 - 1] * e[a10]) : r10.push(e[a10] / t[a10 - 1]) : r10.push(e[a10]);
  return r10;
}
function BO(e, t) {
  let n10 = [0];
  for (let s10 = 0; s10 < t; ++s10)
    n10.push(e[s10][0]);
  return n10;
}
function VO(e, t, n10) {
  let s10 = e.slice(0, 1);
  for (let r10 = 0; r10 < n10; ++r10)
    s10.push(e[r10 + 1] - t[r10][0] - t[r10][1]);
  return s10;
}
var _I = 1.7580993408473768;
var AI = 1.0507009873554805;
var WO = 0.3275911;
var UO = 0.254829592;
var GO = -0.284496736;
var HO = 1.421413741;
var qO = -1.453152027;
var jO = 1.061405429;
function KO(e, t) {
  if (e.length !== t.length)
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);
  let n10 = new Float32Array(e.length * 2);
  for (let s10 = 0; s10 < n10.length; s10 += 2)
    n10[s10] = e[s10 / 2], n10[s10 + 1] = t[s10 / 2];
  return n10;
}
function XO(e) {
  let t = new Float32Array(e.length / 2), n10 = new Float32Array(e.length / 2);
  for (let s10 = 0; s10 < e.length; s10 += 2)
    t[s10 / 2] = e[s10], n10[s10 / 2] = e[s10 + 1];
  return { real: t, imag: n10 };
}
function YO(e) {
  let t = Math.ceil(e.length / 4), n10 = new Float32Array(t), s10 = new Float32Array(t);
  for (let r10 = 0; r10 < e.length; r10 += 4)
    n10[Math.floor(r10 / 4)] = e[r10], s10[Math.floor(r10 / 4)] = e[r10 + 1];
  return { real: n10, imag: s10 };
}
function QO(e) {
  let t = Math.floor(e.length / 4), n10 = new Float32Array(t), s10 = new Float32Array(t);
  for (let r10 = 2; r10 < e.length; r10 += 4)
    n10[Math.floor(r10 / 4)] = e[r10], s10[Math.floor(r10 / 4)] = e[r10 + 1];
  return { real: n10, imag: s10 };
}
function ZO(e, t) {
  let n10 = e[t * 2], s10 = e[t * 2 + 1];
  return { real: n10, imag: s10 };
}
function JO(e, t, n10, s10) {
  e[s10 * 2] = t, e[s10 * 2 + 1] = n10;
}
function eP(e, t) {
  let n10 = new Float32Array(e / 2), s10 = new Float32Array(e / 2);
  for (let r10 = 0; r10 < Math.ceil(e / 2); r10++) {
    let a10 = (t ? 2 : -2) * Math.PI * (r10 / e);
    n10[r10] = Math.cos(a10), s10[r10] = Math.sin(a10);
  }
  return { real: n10, imag: s10 };
}
function tP(e, t, n10) {
  let s10 = (n10 ? 2 : -2) * Math.PI * (e / t), r10 = Math.cos(s10), a10 = Math.sin(s10);
  return { real: r10, imag: a10 };
}
var zf = "->";
var nP = /->/g;
var hx = ",";
var fx = "...";
function sP(e, t) {
  e = e.replace(/\s/g, "");
  let n10 = (e.length - e.replace(nP, "").length) / zf.length;
  if (n10 < 1)
    throw new Error("Equations without an arrow are not supported.");
  if (n10 > 1)
    throw new Error(`Equation must contain exactly one arrow ("${zf}").`);
  let [s10, r10] = e.split(zf);
  O2(s10.indexOf(fx) === -1, () => `The ellipsis notation ("${fx}") is not supported yet.`);
  let a10 = s10.split(hx), i10 = a10.length;
  if (t !== i10)
    throw new Error(`Expected ${i10} input tensors, received ${t}`);
  if (i10 > 2)
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  let o10 = [];
  for (let d10 = 0; d10 < r10.length; ++d10) {
    let h10 = r10[d10];
    if (!a10.some((f10) => f10.indexOf(h10) !== -1))
      throw new Error(`Output subscripts contain the label ${h10} not present in the input subscripts.`);
    o10.indexOf(h10) === -1 && o10.push(h10);
  }
  for (let d10 = 0; d10 < s10.length; ++d10) {
    let h10 = s10[d10];
    o10.indexOf(h10) === -1 && h10 !== hx && o10.push(h10);
  }
  let u10 = new Array(a10.length);
  for (let d10 = 0; d10 < i10; ++d10) {
    if (new Set(a10[d10].split("")).size !== a10[d10].length)
      throw new Error(`Found duplicate axes in input component ${a10[d10]}. Support for duplicate axes in input is not implemented yet.`);
    u10[d10] = [];
    for (let h10 = 0; h10 < a10[d10].length; ++h10)
      u10[d10].push(o10.indexOf(a10[d10][h10]));
  }
  let l10 = o10.length, c10 = r10.length, p10 = [];
  for (let d10 = c10; d10 < l10; ++d10)
    p10.push(d10);
  return { allDims: o10, summedDims: p10, idDims: u10 };
}
function rP(e, t) {
  let n10 = new Array(e);
  n10.fill(-1);
  for (let r10 = 0; r10 < t.length; ++r10)
    n10[t[r10]] = r10;
  let s10 = [];
  for (let r10 = 0; r10 < e; ++r10)
    n10[r10] === -1 && s10.push(r10);
  return n10 = n10.filter((r10) => r10 !== -1), { permutationIndices: n10, expandDims: s10 };
}
function aP(e, t, n10) {
  let s10 = new Array(e);
  for (let r10 = 0; r10 < n10.length; ++r10) {
    let a10 = n10[r10].shape;
    for (let i10 = 0; i10 < t[r10].length; ++i10)
      s10[t[r10][i10]] === void 0 ? s10[t[r10][i10]] = a10[i10] : O2(s10[t[r10][i10]] === a10[i10], () => `Expected dimension ${s10[t[r10][i10]]} at axis ${i10} of input shaped ${JSON.stringify(a10)}, but got dimension ${a10[i10]}`);
  }
}
function iP(e, t) {
  let n10 = e, s10 = [], r10 = 0;
  e.length === 0 && n10.push(-1), r10 = e.length + 1;
  for (let i10 = 0; i10 < r10; ++i10)
    s10.push([]);
  let a10 = [];
  for (let i10 = 0; i10 < n10.length; ++i10) {
    let o10 = n10[i10], u10 = uP(t, o10);
    for (let l10 of u10)
      a10.indexOf(l10) === -1 && (s10[i10].push(l10), a10.push(l10));
  }
  return { path: n10, steps: s10 };
}
function oP(e) {
  return e.every((t, n10) => t === n10);
}
function uP(e, t) {
  let n10 = [];
  for (let s10 = 0; s10 < e.length; ++s10)
    (e[s10].length === 0 || e[s10].indexOf(t) !== -1 || t === -1) && n10.push(s10);
  return n10;
}
function lP(e, t, n10 = 0) {
  let s10 = [];
  if (typeof t == "number")
    O2(e.shape[n10] % t === 0, () => "Number of splits must evenly divide the axis."), s10 = new Array(t).fill(e.shape[n10] / t);
  else {
    let r10 = t.reduce((i10, o10) => (o10 === -1 && (i10 += 1), i10), 0);
    O2(r10 <= 1, () => "There should be only one negative value in split array.");
    let a10 = t.indexOf(-1);
    if (a10 !== -1) {
      let i10 = t.reduce((o10, u10) => u10 > 0 ? o10 + u10 : o10);
      t[a10] = e.shape[n10] - i10;
    }
    O2(e.shape[n10] === t.reduce((i10, o10) => i10 + o10), () => "The sum of sizes must match the size of the axis dimension."), s10 = t;
  }
  return s10;
}
function cP(e) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`;
}
function dP(e, t) {
  return `indices(${e}, 0) is invalid: ${t} < 0`;
}
function pP(e, t, n10) {
  return `indices(${e}, 0) is invalid: ${t} >= ${n10}`;
}
function hP(e, t) {
  return `only one output dimension may be -1, not both ${e} and ${t}`;
}
function fP(e, t) {
  return `size ${e} must be non-negative, not ${t}`;
}
function mP() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function gP(e, t) {
  let n10 = pt(e), s10 = pt(t);
  return `Input to reshape is a SparseTensor with ${n10}
  dense values, but the requested shape requires a multiple of ${s10}. inputShape=${e} outputShape= ${t}`;
}
function bP(e, t) {
  let n10 = pt(e), s10 = pt(t);
  return `Input to reshape is a tensor with ${n10} dense values, but the requested shape has ${s10}. inputShape=${e} outputShape=${t}`;
}
function yP() {
  return "segment ids must be >= 0";
}
function vP() {
  return "segment ids are not increasing";
}
function xP(e, t) {
  return `Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
}
function wP(e, t, n10) {
  return `Bad: indices[${e}] == ${t} out of range [0, ${n10})`;
}
var EI = {};
Ae(EI, { collectGatherOpShapeInfo: () => SP, computeOutShape: () => IP, segOpComputeOptimalWindowSize: () => kP });
function kP(e, t) {
  let n10 = false, s10;
  for (e <= yb ? (s10 = e, n10 = true) : s10 = pd(e, Math.floor(Math.sqrt(e))); !n10; )
    s10 > t || s10 === e ? n10 = true : s10 = pd(e, s10 + 1);
  return s10;
}
function IP(e, t, n10) {
  let s10 = [], r10 = e.length;
  for (let a10 = 0; a10 < r10; a10++)
    a10 !== t ? s10.push(e[a10]) : s10.push(n10);
  return s10;
}
function SP(e, t, n10, s10) {
  let r10 = t.shape.length, a10 = e.shape.length;
  if (s10 !== 0 && (s10 < -r10 || s10 > r10))
    throw new Error(`Expect batchDims in the range of [-${r10}, ${r10}], but got ${s10}`);
  if (s10 < 0 && (s10 += r10), s10 > a10)
    throw new Error(`batchDims (${s10}) must be less than rank(x) (
    ${a10}).`);
  if (n10 < s10)
    throw new Error(`batchDims (${s10}) must be less than or equal to axis (${n10}).`);
  for (let p10 = 0; p10 < s10; ++p10)
    if (e.shape[p10] !== t.shape[p10])
      throw new Error(`x.shape[${p10}]: ${e.shape[p10]} should be equal to indices.shape[${p10}]: ${t.shape[p10]}.`);
  let i10 = e.shape[n10], o10 = [], u10 = 1, l10 = 1, c10 = 1;
  for (let p10 = 0; p10 < s10; ++p10)
    o10.push(e.shape[p10]), u10 *= e.shape[p10];
  for (let p10 = s10; p10 < n10; p10++)
    o10.push(e.shape[p10]), l10 *= e.shape[p10];
  for (let p10 = s10; p10 < r10; p10++)
    o10.push(t.shape[p10]);
  for (let p10 = n10 + 1; p10 < a10; p10++)
    o10.push(e.shape[p10]), c10 *= e.shape[p10];
  return { batchSize: u10, sliceSize: c10, outerSize: l10, dimSize: i10, outputShape: o10 };
}
function CP(e) {
  try {
    return e.map((t) => fd(t));
  } catch (t) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`);
  }
}
function NP(e) {
  return e.map((t) => El(t));
}
var xs = {};
Ae(xs, { nonMaxSuppressionV3Impl: () => NI, nonMaxSuppressionV4Impl: () => TI, nonMaxSuppressionV5Impl: () => $I, whereImpl: () => gI });
var RI = { kernelName: ao, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, bp(ce2(n10, "float32"), -1)) };
} };
var TP = { kernelName: nl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => {
    let s10 = ct(ce2(n10, "float32")), r10 = ln(ge2(Ie2(1), s10));
    return kt(xe2(e, r10));
  } };
} };
var $P = { kernelName: sl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => {
    let s10 = ln(ge2(ct(ce2(n10, "float32")), 1));
    return xe2(e, s10);
  } };
} };
var _P = { kernelName: kr, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = e, u10 = _t(n10.shape, r10);
    return u10.length > 0 && (o10 = ye2(o10, u10)), G2(o10, n10.shape);
  }, b: () => {
    let o10 = e, u10 = _t(s10.shape, r10);
    return u10.length > 0 && (o10 = ye2(o10, u10)), G2(o10, s10.shape);
  } };
} };
var AP = { kernelName: xa, saveAllInputs: true, gradFunc: (e, t) => {
  let n10 = {};
  return t.forEach((s10, r10) => {
    n10[r10] = () => e.clone();
  }), n10;
} };
var EP = { kernelName: wa, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => je(n10) };
} };
var RP = { kernelName: il, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => je(n10) };
} };
var DP = { kernelName: ol, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ln(ge2(Ie2(1), ct(ce2(n10, "float32"))))) };
} };
var FP = { kernelName: ul, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => {
    let s10 = ln(ie2(Ie2(1), ct(ce2(n10, "float32"))));
    return xe2(e, s10);
  } };
} };
var OP = { kernelName: dl, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = ie2(ct(n10), ct(s10)), u10 = V2(e, xe2(s10, o10)), l10 = _t(n10.shape, r10);
    return l10.length > 0 && (u10 = ye2(u10, l10)), G2(u10, n10.shape);
  }, b: () => {
    let o10 = ie2(ct(n10), ct(s10)), u10 = kt(V2(e, xe2(n10, o10))), l10 = _t(s10.shape, r10);
    return l10.length > 0 && (u10 = ye2(u10, l10)), G2(u10, s10.shape);
  } };
} };
var PP = { kernelName: ll, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ie2(ct(ce2(n10, "float32")), 1)) };
} };
var zP = { kernelName: cl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ge2(Ie2(1), ct(ce2(n10, "float32")))) };
} };
function MP(e, t, n10, s10, r10, a10) {
  let i10 = _2(e, "dy", "avgPool3dGrad"), o10 = _2(t, "input", "avgPool3dGrad"), u10 = i10, l10 = o10, c10 = false;
  o10.rank === 4 && (c10 = true, u10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2], i10.shape[3]]), l10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]])), O2(u10.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${u10.rank}.`), O2(l10.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${l10.rank}.`), pn("avgPool3dGrad", r10, a10);
  let p10 = { dy: u10, input: l10 }, d10 = { filterSize: n10, strides: s10, pad: r10, dimRoundingMode: a10 }, h10 = M2.runKernel(ag, p10, d10);
  return c10 ? G2(h10, [h10.shape[1], h10.shape[2], h10.shape[3], h10.shape[4]]) : h10;
}
var LP = L2({ avgPool3dGrad_: MP });
var BP = { kernelName: Hd, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { filterSize: r10, strides: a10, pad: i10, dimRoundingMode: o10 } = n10;
  return { x: () => LP(e, s10, r10, a10, i10, o10) };
} };
function VP(e, t, n10, s10, r10) {
  let a10 = _2(e, "dy", "avgPoolGrad"), i10 = _2(t, "input", "avgPoolGrad");
  O2(i10.rank === a10.rank, () => `Rank of input (${i10.rank}) does not match rank of dy (${a10.rank})`);
  let o10 = i10, u10 = a10, l10 = false;
  i10.rank === 3 && (l10 = true, o10 = G2(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]]), u10 = G2(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]])), O2(u10.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${u10.rank}.`), O2(o10.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${o10.rank}.`);
  let c10 = { dy: u10, input: o10 }, p10 = { filterSize: n10, strides: s10, pad: r10 }, d10 = M2.runKernel(rg, c10, p10);
  return l10 ? G2(d10, [d10.shape[1], d10.shape[2], d10.shape[3]]) : d10;
}
var WP = L2({ avgPoolGrad_: VP });
var UP = { kernelName: ka, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { filterSize: r10, strides: a10, pad: i10 } = n10;
  return { x: () => WP(e, s10, r10, a10, i10) };
} };
var GP = { kernelName: Ia, inputsToSave: ["a", "b"], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { transposeA: a10, transposeB: i10 } = n10;
  return !a10 && !i10 ? { a: () => We(e, r10, false, true), b: () => We(s10, e, true, false) } : !a10 && i10 ? { a: () => We(e, r10, false, false), b: () => We(e, s10, true, false) } : a10 && !i10 ? { a: () => We(r10, e, false, true), b: () => We(s10, e, false, false) } : { a: () => We(r10, e, true, true), b: () => We(e, s10, true, true) };
} };
var HP = { kernelName: io, gradFunc: (e, t, n10) => {
  let { blockShape: s10, crops: r10 } = n10;
  return { x: () => eb(e, s10, r10) };
} };
var qP = { kernelName: w$, gradFunc: (e, t, n10) => {
  let s10 = n10, r10 = s10.inputShape, a10 = s10.shape, i10 = Array.from(a10);
  for (let u10 = r10.length - 1; u10 >= 0; u10--)
    if (r10[u10] === a10[u10])
      i10[u10] = 1;
    else if (r10[u10] !== 1)
      throw new Error(`broadcastTo(): [${r10}] cannot be broadcast to [${a10}].`);
  let o10 = [];
  for (let u10 = 0; u10 < i10.length; u10++)
    i10[u10] > 1 && o10.push(u10);
  return { x: () => ye2(e, o10, true) };
} };
var jP = { kernelName: Sa, gradFunc: (e) => ({ x: () => e.clone() }) };
var KP = { kernelName: Ca, gradFunc: (e) => ({ x: () => je(e) }) };
var XP = { kernelName: Ir, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { clipValueMin: r10, clipValueMax: a10 } = n10;
  return { x: () => vn(Ds(jo(s10, r10), Ko(s10, a10)), e, je(e)) };
} };
var YP = { kernelName: jd, inputsToSave: ["x"], gradFunc: RI.gradFunc };
var QP = { kernelName: oo, saveAllInputs: true, gradFunc: (e, t, n10) => {
  let s10 = t.map((u10) => u10.shape), { axis: r10 } = n10, a10 = Jn(r10, t[0].shape)[0], i10 = s10.map((u10) => u10[a10]);
  return Ln(e, i10, a10).map((u10) => () => u10);
} };
var ZP = { kernelName: Na, inputsToSave: ["x", "filter"], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { dilations: a10, strides: i10, pad: o10, dataFormat: u10 } = n10;
  return O2(fr(a10), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a10}'`), { x: () => Gg(s10.shape, e, r10, i10, o10, u10), filter: () => cb(s10, e, r10.shape, i10, o10, u10) };
} };
var JP = { kernelName: Ta, inputsToSave: ["dy", "filter"], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { strides: a10, pad: i10, dataFormat: o10, dimRoundingMode: u10 } = n10;
  return { dy: () => ua(e, r10, a10, i10, o10, 1, u10), filter: () => cb(e, s10, r10.shape, a10, i10, o10, u10) };
} };
function ez(e, t, n10, s10, r10) {
  let a10 = e;
  e.rank === 4 && (a10 = G2(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
  let i10 = t;
  i10.rank === 4 && (i10 = G2(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), O2(a10.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${a10.shape}.`), O2(i10.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${i10.shape}.`), O2(n10.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${n10}.`), O2(a10.shape[4] === n10[3], () => `Error in conv3dDerFilter: depth of input ${a10.shape[4]}) must match input depth in filter (${n10[3]}.`), O2(i10.shape[4] === n10[4], () => `Error in conv3dDerFilter: depth of dy (${i10.shape[4]}) must match output depth for filter (${n10[4]}).`);
  let o10 = { x: a10, dy: i10 }, u10 = { strides: s10, pad: r10, filterShape: n10 };
  return M2.runKernel(lg, o10, u10);
}
var tz = L2({ conv3DBackpropFilter_: ez });
var nz = { kernelName: Kd, inputsToSave: ["x", "filter"], gradFunc: (e, t, n10) => {
  let { dilations: s10, strides: r10, pad: a10 } = n10;
  O2(fr(s10), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s10}'`);
  let [i10, o10] = t;
  return { x: () => Xk(i10.shape, e, o10, r10, a10), filter: () => tz(i10, e, o10.shape, r10, a10) };
} };
var sz = { kernelName: $a, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(kt(dI(ce2(n10, "float32"))), e) };
} };
var rz = { kernelName: _a, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(pI(ce2(n10, "float32")), e) };
} };
var az = { kernelName: uo, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { axis: r10, exclusive: a10, reverse: i10 } = n10;
  return { x: () => {
    let o10 = sI([r10], s10.rank), u10 = Qk(e, r10, a10, !i10);
    return o10 != null && (u10 = qe(u10, o10)), u10;
  } };
} };
var iz = { kernelName: Aa, inputsToSave: ["x", "filter"], gradFunc: (e, t, n10) => {
  let { dilations: s10, strides: r10, pad: a10, dimRoundingMode: i10 } = n10, o10 = s10 == null ? [1, 1] : s10;
  O2(fr(o10), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o10}'`);
  let [u10, l10] = t;
  return O2(u10.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u10.rank}.`), O2(l10.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l10.rank}.`), O2(u10.shape[3] === l10.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${u10.shape[3]}) must match the inChannels dimension in filter ${l10.shape[2]}.`), O2(Ps(r10, o10), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r10} and dilations '${o10}'.`), pn("depthwiseConv2d", a10, i10), { x: () => II(u10.shape, e, l10, r10, a10, o10, i10), filter: () => kI(u10, e, l10.shape, r10, a10, o10, i10) };
} };
var oz = { kernelName: Xd, inputsToSave: ["x", "filter"], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, a10 = { x: s10, filter: r10, dy: e }, i10 = { x: s10, filter: r10, dy: e };
  return { x: () => M2.runKernel(Kf, a10, n10), filter: () => M2.runKernel(Xf, i10, n10) };
} };
var uz = { kernelName: Ra, outputsToSave: [true], gradFunc: (e, t) => {
  let [n10] = t, s10 = { dy: e, y: n10 };
  return { x: () => M2.runKernel(mg, s10) };
} };
var lz = { kernelName: pl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t, s10 = V2(jn(kt(ct(n10))), 2 / Math.sqrt(Math.PI));
  return { x: () => V2(e, s10) };
} };
var cz = { kernelName: Da, outputsToSave: [true], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, n10) };
} };
var dz = { kernelName: ho, inputsToSave: ["input"], gradFunc: (e, t) => {
  let [n10] = t;
  return { input: () => G2(e, n10.shape) };
} };
var pz2 = { kernelName: fo, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, jn(n10)) };
} };
var hz = { kernelName: Fa, gradFunc: (e) => ({ x: () => je(e) }) };
var fz = { kernelName: Oa, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = xe2(e, ce2(s10, "float32")), u10 = _t(n10.shape, r10);
    return u10.length > 0 ? G2(ye2(o10, u10), n10.shape) : o10;
  }, b: () => {
    let o10 = V2(e, ce2(n10, "float32")), u10 = _t(s10.shape, r10);
    u10.length > 0 && (o10 = G2(ye2(o10, u10), s10.shape));
    let l10 = ct(s10);
    return kt(xe2(o10, ce2(l10, "float32")));
  } };
} };
var mz = { kernelName: Pa, inputsToSave: ["x", "mean", "variance", "scale"], gradFunc: (e, t, n10) => {
  let { varianceEpsilon: s10 } = n10, [r10, a10, i10, o10] = t, u10 = o10 == null ? Ie2(1) : o10, l10 = _t(a10.shape, r10.shape), c10 = [];
  if (a10.rank === 1) {
    for (let x10 = 0; x10 < r10.shape.length - 1; ++x10)
      c10.push(r10.shape[x10]);
    c10.push(1);
  }
  let p10 = ge2(r10, a10), d10 = V2(e, u10), h10 = lI(ie2(i10, Ie2(s10))), f10 = V2(V2(V2(h10, h10), h10), Ie2(-0.5));
  return { x: () => a10.rank === 1 ? G2(V2(V2(e, cs(G2(h10, [1, 1, 1, a10.shape[0]]), c10)), u10), r10.shape) : G2(V2(V2(e, h10), u10), r10.shape), mean: () => {
    let x10 = V2(V2(h10, Ie2(-1)), d10);
    return a10.rank === 1 && (x10 = ye2(x10, l10)), G2(x10, a10.shape);
  }, variance: () => {
    let x10 = V2(V2(f10, p10), d10);
    return a10.rank === 1 && (x10 = ye2(x10, l10)), G2(x10, a10.shape);
  }, scale: () => {
    let x10 = V2(p10, h10), k10 = V2(e, x10);
    return a10.rank === 1 && (k10 = ye2(k10, l10)), G2(k10, a10.shape);
  }, offset: () => {
    let x10 = e;
    return a10.rank === 1 && (x10 = ye2(x10, l10)), G2(x10, a10.shape);
  } };
} };
var gz = { kernelName: go, inputsToSave: ["x", "indices"], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { axis: a10 } = n10, i10 = Jn(a10, s10.shape)[0];
  return { x: () => {
    let u10 = s10.shape, l10 = r10.size, c10 = u10.slice(0, i10), p10 = c10.length, d10 = u10.slice(a10, u10.length).slice(1), h10 = d10.length, f10 = mx(0, p10), m10 = mx(p10 + 1, p10 + 1 + h10), g10 = gx([c10, [l10], d10]), b10 = G2(e, g10), y10 = G2(r10, [l10]), v10 = gx([[p10], f10, m10]), x10 = qe(b10, v10), k10 = A3(x10, y10, s10.shape[i10]), C10 = Yg(v10);
    return k10 = qe(k10, C10), k10;
  }, indices: () => r10 };
} };
function mx(e, t) {
  let n10 = [];
  for (let s10 = e; s10 < t; ++s10)
    n10.push(s10);
  return n10;
}
function gx(e) {
  let t = [];
  for (let n10 = 0; n10 < e.length; ++n10)
    for (let s10 = 0; s10 < e[n10].length; ++s10)
      t.push(e[n10][s10]);
  return t;
}
var bz = { kernelName: za, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t;
  return { a: () => je(n10), b: () => je(s10) };
} };
var yz = { kernelName: Ma, gradFunc: (e) => ({ x: () => ce2(e, "float32") }) };
var vz = { kernelName: fl, gradFunc: (e) => ({ x: () => je(e) }) };
var xz = { kernelName: ml, gradFunc: (e) => ({ x: () => je(e) }) };
var wz = { kernelName: gl, gradFunc: (e) => ({ x: () => je(e) }) };
var kz = { kernelName: La, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { alpha: r10 } = n10, a10 = Wn(s10, 0);
  return { x: () => vn(a10, e, V2(e, r10)) };
} };
var Iz = { kernelName: bl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ie2(n10, 1)) };
} };
var Sz = { kernelName: Ba, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ce2(n10, "float32")) };
} };
var Cz = { kernelName: k$, inputsToSave: [], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let [s10] = t, { axis: r10 } = n10;
  return { logits: () => {
    let i10 = jn(s10);
    return ge2(e, V2(ye2(e, r10, true), i10));
  } };
} };
function Nz(e, t, n10, s10 = 5, r10 = 1, a10 = 1, i10 = 0.5) {
  let o10 = { x: e, y: t, dy: n10 }, u10 = { depthRadius: s10, bias: r10, alpha: a10, beta: i10 };
  return M2.runKernel(vg, o10, u10);
}
var Tz = L2({ localResponseNormalizationBackprop_: Nz });
var $z = { kernelName: Jd, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { depthRadius: a10, bias: i10, alpha: o10, beta: u10 } = n10;
  return { x: () => Tz(s10, r10, e, a10, i10, o10, u10) };
} };
function DI(e, t, n10, s10) {
  return t.rank < n10.rank && (t = G2(t, la(t.shape, s10))), e.rank < n10.rank && (e = G2(e, la(e.shape, s10))), { x: () => V2(e, ce2(qn(n10, t), e.dtype)) };
}
var bx = { kernelName: Va, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let s10 = n10, { reductionIndices: r10 } = s10, a10 = t[0], i10 = t[1], o10 = Jn(r10, a10.shape), u10 = DI(e, i10, a10, o10);
  return { x: () => u10.x() };
} };
var _z2 = { kernelName: Wa, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t;
  return { a: () => V2(e, ce2(jo(n10, s10), "float32")), b: () => V2(e, ce2(Jk(n10, s10), "float32")) };
} };
function Az(e, t, n10, s10, r10, a10, i10) {
  let o10 = _2(e, "dy", "maxPool3dGrad"), u10 = _2(t, "input", "maxPool3dGrad"), l10 = _2(n10, "output", "maxPool3dGrad"), c10 = o10, p10 = u10, d10 = l10, h10 = false;
  u10.rank === 4 && (h10 = true, c10 = G2(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]]), p10 = G2(u10, [1, u10.shape[0], u10.shape[1], u10.shape[2], u10.shape[3]]), d10 = G2(l10, [1, l10.shape[0], l10.shape[1], l10.shape[2], l10.shape[3]])), O2(c10.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${c10.rank}.`), O2(p10.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${p10.rank}.`), O2(d10.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${d10.rank}.`), pn("maxPool3dGrad", a10, i10);
  let f10 = { dy: c10, input: p10, output: d10 }, m10 = { filterSize: s10, strides: r10, pad: a10, dimRoundingMode: i10 }, g10 = M2.runKernel(wg, f10, m10);
  return h10 ? G2(g10, [g10.shape[1], g10.shape[2], g10.shape[3], g10.shape[4]]) : g10;
}
var Ez = L2({ maxPool3dGrad_: Az });
var Rz = { kernelName: ep, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = n10;
  return { x: () => Ez(e, s10, r10, a10, i10, o10, u10) };
} };
function Dz(e, t, n10, s10, r10, a10, i10) {
  let o10 = _2(e, "dy", "maxPoolGrad"), u10 = _2(t, "input", "maxPoolGrad"), l10 = _2(n10, "output", "maxPoolGrad");
  O2(u10.rank === o10.rank, () => `Rank of input (${u10.rank}) does not match rank of dy (${o10.rank})`), O2(o10.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${o10.rank}.`), O2(u10.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${u10.rank}.`), pn("maxPoolGrad", a10, i10);
  let c10 = { dy: o10, input: u10, output: l10 }, p10 = { filterSize: s10, strides: r10, pad: a10, dimRoundingMode: i10 };
  return M2.runKernel(xg, c10, p10);
}
var Fz = L2({ maxPoolGrad_: Dz });
var Oz = { kernelName: Ua, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let [s10, r10] = t, { filterSize: a10, strides: i10, pad: o10 } = n10;
  return { x: () => Fz(e, s10, r10, a10, i10, o10) };
} };
var Pz = { kernelName: Ga, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { axis: r10 } = n10, a10 = Jn(r10, s10.shape), o10 = nI(s10.shape, a10)[1], u10 = pt(o10);
  return { x: () => {
    let c10 = s10.shape.slice();
    a10.forEach((h10) => {
      c10[h10] = 1;
    });
    let p10 = G2(e, c10);
    return xe2(V2(p10, zn(s10.shape, "float32")), u10);
  } };
} };
var zz = { kernelName: Ha, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e, t, n10) => {
  let s10 = n10, { axis: r10 } = s10, [a10, i10] = t, o10 = Jn(r10, a10.shape), u10 = DI(e, i10, a10, o10);
  return { x: () => u10.x() };
} };
var Mz = { kernelName: qa, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t;
  return { a: () => V2(e, ce2(Ko(n10, s10), "float32")), b: () => V2(e, ce2(Wn(n10, s10), "float32")) };
} };
var Lz = { kernelName: ja, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let s10 = t[0], { paddings: r10 } = n10, a10 = r10.map((i10) => i10[0]);
  return { x: () => He(e, a10, s10.shape) };
} };
var Bz = { kernelName: vl, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = _t(n10.shape, r10);
    return o10.length > 0 ? G2(ye2(e, o10), n10.shape) : e;
  }, b: () => {
    let o10 = V2(e, kt(fp(xe2(n10, s10)))), u10 = _t(s10.shape, r10);
    return u10.length > 0 ? G2(ye2(o10, u10), s10.shape) : o10;
  } };
} };
var Vz = { kernelName: Ka, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = V2(e, ce2(s10, "float32")), u10 = _t(n10.shape, r10);
    return u10.length > 0 ? G2(ye2(o10, u10), n10.shape) : o10;
  }, b: () => {
    let o10 = V2(e, ce2(n10, "float32")), u10 = _t(s10.shape, r10);
    return u10.length > 0 ? G2(ye2(o10, u10), s10.shape) : o10;
  } };
} };
var Wz = { kernelName: ko, gradFunc: (e) => ({ x: () => kt(e) }) };
var Uz = { kernelName: To, inputsToSave: ["indices"], gradFunc: (e, t) => {
  let n10 = t[0];
  return { indices: () => $t(n10.shape, "float32") };
} };
var Gz = { kernelName: No, gradFunc: (e) => ({ x: () => je(e) }) };
var Hz = { kernelName: $o, saveAllInputs: true, gradFunc: (e, t, n10) => {
  let { axis: s10 } = n10;
  return Fs(e, s10).map((a10) => () => a10);
} };
var yx = { kernelName: Xa, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let s10 = t[0], { paddings: r10 } = n10, a10 = r10.map((i10) => i10[0]);
  return { x: () => He(e, a10, s10.shape) };
} };
var qz = { kernelName: Ya, inputsToSave: ["a", "b"], outputsToSave: [true], gradFunc: (e, t) => {
  let [n10, s10, r10] = t, a10 = n10, i10 = s10, o10 = it(a10.shape, i10.shape);
  return { a: () => {
    let c10 = ce2(i10, "float32"), p10 = V2(e, V2(c10, ca(a10, ge2(c10, Ie2(1))))), d10 = _t(a10.shape, o10);
    return d10.length > 0 && (p10 = ye2(p10, d10)), G2(p10, a10.shape);
  }, b: () => {
    let c10 = Wn(a10, 0), p10 = vn(c10, Kn(a10), je(a10)), d10 = V2(e, V2(r10, p10)), h10 = _t(i10.shape, o10);
    return h10.length > 0 && (d10 = ye2(d10, h10)), G2(d10, i10.shape);
  } };
} };
var jz = { kernelName: Qa, inputsToSave: ["x", "alpha"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = Wn(n10, 0);
  return { x: () => vn(r10, e, V2(e, s10)), alpha: () => {
    let a10 = vn(r10, je(e), V2(e, n10)), i10 = _t(s10.shape, e.shape);
    return i10.length > 0 && (a10 = ye2(a10, i10)), G2(a10, s10.shape);
  } };
} };
var Kz = { kernelName: Ea, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = xe2(e, ce2(s10, "float32")), u10 = _t(n10.shape, r10);
    return u10.length > 0 ? G2(ye2(o10, u10), n10.shape) : o10;
  }, b: () => {
    let o10 = V2(e, ce2(n10, "float32")), u10 = _t(s10.shape, r10);
    u10.length > 0 && (o10 = G2(ye2(o10, u10), s10.shape));
    let l10 = ct(s10);
    return kt(xe2(o10, ce2(l10, "float32")));
  } };
} };
var Xz = { kernelName: kl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, kt(ct(n10))) };
} };
var Yz = { kernelName: ei, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t, s10 = V2(Ko(n10, 6), bp(n10));
  return { x: () => V2(e, ce2(s10, "float32")) };
} };
var Qz = { kernelName: Za, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, ce2(bp(n10), "float32")) };
} };
var Zz = { kernelName: Ao, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => G2(e, n10.shape) };
} };
var Jz = { kernelName: Ja, inputsToSave: ["images"], gradFunc: (e, t, n10) => {
  let [s10] = t, r10 = { dy: e, images: s10 };
  return { images: () => M2.runKernel(Cg, r10, n10) };
} };
var eM = { kernelName: Il, inputsToSave: ["images"], gradFunc: (e, t, n10) => {
  let [s10] = t, r10 = { dy: e, images: s10 };
  return { images: () => M2.runKernel(Sg, r10, n10) };
} };
var tM = { kernelName: Eo, gradFunc: (e, t, n10) => {
  let { dims: s10 } = n10, r10 = Jn(s10, e.shape);
  return { x: () => Yn(e, r10) };
} };
var nM = { kernelName: Ro, gradFunc: (e) => ({ x: () => je(e) }) };
var sM = { kernelName: ti, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => kt(xe2(e, V2(ca(n10, 1.5), 2))) };
} };
var rM = { kernelName: Fo, inputsToSave: ["condition"], gradFunc: (e, t) => {
  let [n10] = t;
  return { condition: () => ce2(je(n10), "float32"), t: () => V2(e, ce2(n10, e.dtype)), e: () => V2(e, ce2(Qg(n10), e.dtype)) };
} };
var aM = { kernelName: Sl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => {
    let s10 = Wn(n10, Ie2(0)), r10 = Ie2(_I), a10 = Ie2(AI), i10 = V2(e, a10), o10 = V2(V2(e, r10), jn(ce2(n10, "float32")));
    return vn(s10, i10, o10);
  } };
} };
var iM = { kernelName: si, outputsToSave: [true], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, V2(n10, ge2(Ie2(1), n10))) };
} };
var oM = { kernelName: Cl, gradFunc: (e) => ({ x: () => je(e) }) };
var uM = { kernelName: ni, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(Hg(ce2(n10, "float32")), e) };
} };
var lM = { kernelName: Po, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(Yk(ce2(n10, "float32")), e) };
} };
var cM = { kernelName: Oo, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { begin: r10, size: a10 } = n10, i10 = s10.shape, [o10, u10] = Fk(s10, r10, a10), l10 = [];
  for (let c10 = 0; c10 < e.rank; c10++)
    l10.push([o10[c10], i10[c10] - o10[c10] - u10[c10]]);
  return { x: () => pi(e, l10) };
} };
var dM = { kernelName: ii, outputsToSave: [true], gradFunc: (e, t, n10) => {
  let [s10] = t, { dim: r10 } = n10, a10 = true, i10 = V2(e, s10);
  return { logits: () => ge2(i10, V2(ye2(i10, [r10], a10), s10)) };
} };
var pM = { kernelName: Nl, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, qs(n10)) };
} };
var vx = { kernelName: zo, gradFunc: (e, t, n10) => {
  let { blockShape: s10, paddings: r10 } = n10;
  return { x: () => Ug(e, s10, r10) };
} };
var xx = { kernelName: Mo, gradFunc: (e, t, n10) => {
  let { axis: s10 } = n10;
  return { x: () => Ft(e, s10) };
} };
var hM = { kernelName: ri, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, V2(ln(ce2(n10, "float32")), 2)) };
} };
var fM = { kernelName: $l, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(e, V2(ce2(n10, "float32"), 2)) };
} };
var mM = { kernelName: oi, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = Ie2(2);
  return { a: () => V2(e, V2(r10, ge2(n10, s10))), b: () => V2(e, V2(r10, ge2(s10, n10))) };
} };
var gM = { kernelName: di, gradFunc: (e) => ({ x: () => je(e) }) };
var bM = { kernelName: ui, inputsToSave: ["a", "b"], gradFunc: (e, t) => {
  let [n10, s10] = t, r10 = it(n10.shape, s10.shape);
  return { a: () => {
    let o10 = e, u10 = _t(n10.shape, r10);
    return u10.length > 0 && (o10 = ye2(o10, u10)), G2(o10, n10.shape);
  }, b: () => {
    let o10 = e, u10 = _t(s10.shape, r10);
    return u10.length > 0 && (o10 = ye2(o10, u10)), G2(kt(o10), s10.shape);
  } };
} };
var yM = { kernelName: ai, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, r10 = s10.shape.slice(), { axis: a10 } = n10;
  Jn(a10, s10.shape).forEach((l10) => {
    r10[l10] = 1;
  });
  let o10 = G2(e, r10), u10 = V2(o10, zn(s10.shape, "float32"));
  return { x: () => u10 };
} };
var vM = { kernelName: Bo, inputsToSave: ["x"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => xe2(e, ct(Hg(n10))) };
} };
var xM = { kernelName: li, outputsToSave: [true], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => V2(ge2(Ie2(1), ct(n10)), e) };
} };
var wM = { kernelName: Sr, inputsToSave: ["x"], gradFunc: (e, t, n10) => {
  let [s10] = t, { reps: r10 } = n10;
  return { x: () => {
    let i10 = je(s10);
    if (s10.rank === 1)
      for (let o10 = 0; o10 < r10[0]; ++o10)
        i10 = ie2(i10, He(e, [o10 * s10.shape[0]], [s10.shape[0]]));
    else if (s10.rank === 2)
      for (let o10 = 0; o10 < r10[0]; ++o10)
        for (let u10 = 0; u10 < r10[1]; ++u10)
          i10 = ie2(i10, He(e, [o10 * s10.shape[0], u10 * s10.shape[1]], [s10.shape[0], s10.shape[1]]));
    else if (s10.rank === 3)
      for (let o10 = 0; o10 < r10[0]; ++o10)
        for (let u10 = 0; u10 < r10[1]; ++u10)
          for (let l10 = 0; l10 < r10[2]; ++l10)
            i10 = ie2(i10, He(e, [o10 * s10.shape[0], u10 * s10.shape[1], l10 * s10.shape[2]], [s10.shape[0], s10.shape[1], s10.shape[2]]));
    else if (s10.rank === 4)
      for (let o10 = 0; o10 < r10[0]; ++o10)
        for (let u10 = 0; u10 < r10[1]; ++u10)
          for (let l10 = 0; l10 < r10[2]; ++l10)
            for (let c10 = 0; c10 < r10[3]; ++c10)
              i10 = ie2(i10, He(e, [o10 * s10.shape[0], u10 * s10.shape[1], l10 * s10.shape[2], c10 * s10.shape[3]], [s10.shape[0], s10.shape[1], s10.shape[2], s10.shape[3]]));
    else
      throw new Error(`Gradient for tile operation is not implemented for rank-${s10.rank} tensors yet.`);
    return i10;
  } };
} };
var kM = { kernelName: ci, gradFunc: (e, t, n10) => {
  let s10 = n10, { perm: r10 } = s10, a10 = Yg(r10);
  return { x: () => qe(e, a10) };
} };
var IM = { kernelName: Uo, gradFunc: (e, t, n10) => {
  let s10 = n10, { axis: r10 } = s10;
  return { value: () => Qn(e, r10) };
} };
var SM = { kernelName: op, inputsToSave: ["segmentIds"], gradFunc: (e, t) => {
  let [n10] = t;
  return { x: () => CM(e, n10) };
} };
function CM(e, t) {
  let n10 = Tr(t, je(t)), s10 = ju(e, n10), r10 = jo(t, Ie2(0, "int32")), a10 = s10.rank - r10.rank;
  for (let o10 = 0; o10 < a10; ++o10)
    r10 = On(r10, o10 + 1);
  r10 = Ds(r10, zn(s10.shape, "bool"));
  let i10 = je(s10);
  return vn(r10, s10, i10);
}
var NM = { kernelName: Go, gradFunc: (e) => ({ x: () => je(e) }) };
var TM = [RI, TP, $P, _P, AP, EP, RP, DP, FP, OP, PP, zP, BP, UP, GP, HP, qP, jP, KP, XP, YP, QP, JP, ZP, nz, sz, rz, az, iz, oz, Kz, uz, lz, cz, dz, pz2, fz, hz, mz, gz, bz, yz, vz, xz, wz, kz, Iz, Sz, Cz, $z, bx, bx, _z2, Rz, Oz, Pz, zz, Mz, Lz, Bz, Vz, Wz, Uz, Gz, Hz, yx, yx, qz, jz, Xz, Yz, Qz, Zz, Jz, eM, tM, nM, sM, rM, aM, iM, oM, uM, lM, cM, dM, pM, vx, vx, xx, xx, hM, mM, fM, gM, bM, yM, vM, xM, wM, kM, IM, SM, NM];
for (let e of TM)
  S$(e);
var $M = {};
Ae($M, { maxNorm: () => RM, minMaxNorm: () => OM, nonNeg: () => FM, unitNorm: () => DM });
var Mf;
function Rt() {
  return Mf == null && (Mf = $A().epsilon()), Mf;
}
function bs() {
  return "channelsLast";
}
var Vs = class extends Error {
  constructor(e) {
    super(e);
    Object.setPrototypeOf(this, Vs.prototype);
  }
};
var ps = class extends Error {
  constructor(e) {
    super(e);
    Object.setPrototypeOf(this, ps.prototype);
  }
};
var U2 = class extends Error {
  constructor(e) {
    super(e);
    Object.setPrototypeOf(this, U2.prototype);
  }
};
var Fe = class extends Error {
  constructor(e) {
    super(e);
    Object.setPrototypeOf(this, Fe.prototype);
  }
};
var FI = class extends Error {
  constructor(e) {
    super(e);
    Object.setPrototypeOf(this, FI.prototype);
  }
};
function pa(e, t) {
  if (Array.isArray(e)) {
    let n10 = [];
    for (let s10 = 0; s10 < t; s10++)
      n10 = n10.concat(e);
    return n10;
  } else {
    let n10 = new Array(t);
    return n10.fill(e), n10;
  }
}
function Cs(e, t) {
  if (!e)
    throw new FI(t);
}
function wx(e, t) {
  let n10 = 0;
  for (let s10 of e)
    s10 === t && n10++;
  return n10;
}
function gn(e) {
  return e.length === 1 ? e[0] : e;
}
function dt(e) {
  return Array.isArray(e) ? e : [e];
}
function Ws(e) {
  let n10 = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return n10[0] !== "_" ? n10 : "private" + n10;
}
function qr(e) {
  return e.length <= 1 || e.indexOf("_") === -1 ? e : e.replace(/[_]+(\w|$)/g, (t, n10) => n10.toUpperCase());
}
var Gn = {};
function vb(e) {
  if (e == null)
    return null;
  let t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}
function hm(e) {
  if (!(e == null || typeof e != "object"))
    if (Array.isArray(e))
      e.forEach((t) => hm(t));
    else {
      let t = Object.keys(e);
      for (let n10 of t) {
        let s10 = e[n10];
        s10 != null && typeof s10 == "object" && (!Array.isArray(s10) && s10.type === "ndarray" && typeof s10.value == "number" ? e[n10] = s10.value : hm(s10));
      }
    }
}
function zl(e, t = {}, n10 = {}, s10 = "object", r10 = false) {
  if (typeof e == "string") {
    let a10 = e, i10;
    if (a10 in n10)
      i10 = n10[a10];
    else if (a10 in Gn)
      i10 = Gn[a10];
    else if (i10 = t[a10], i10 == null)
      throw new U2(`Unknown ${s10}: ${e}. This may be due to one of the following reasons:
1. The ${s10} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s10} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    return i10;
  } else {
    let a10 = e;
    if (a10.className == null || a10.config == null)
      throw new U2(`${s10}: Improper config format: ${JSON.stringify(a10)}.
'className' and 'config' must set.`);
    let i10 = a10.className, o10, u10;
    if (i10 in n10 ? [o10, u10] = n10[i10] : i10 in Gn ? [o10, u10] = Gn.className : i10 in t && ([o10, u10] = t[i10]), o10 == null)
      throw new U2(`Unknown ${s10}: ${i10}. This may be due to one of the following reasons:
1. The ${s10} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s10} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    if (u10 != null) {
      let l10 = {};
      for (let h10 of Object.keys(Gn))
        l10[h10] = Gn[h10];
      for (let h10 of Object.keys(n10))
        l10[h10] = n10[h10];
      let c10 = a10.config;
      c10.customObjects = l10;
      let p10 = { ...Gn };
      for (let h10 of Object.keys(n10))
        Gn[h10] = n10[h10];
      hm(a10.config);
      let d10 = u10(o10, a10.config, n10, r10);
      return Gn = { ...p10 }, d10;
    } else {
      let l10 = { ...Gn };
      for (let p10 of Object.keys(n10))
        Gn[p10] = n10[p10];
      let c10 = new o10(a10.config);
      return Gn = { ...l10 }, c10;
    }
  }
}
function _M(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Wc(e, t) {
  return -1 * _M(e, t);
}
function cr(e) {
  if (e == null)
    return e;
  let t = [];
  for (let n10 of e)
    t.indexOf(n10) === -1 && t.push(n10);
  return t;
}
function AM(e) {
  if (e == null)
    throw new U2(`Invalid value in obj: ${JSON.stringify(e)}`);
  for (let t in e)
    if (e.hasOwnProperty(t))
      return false;
  return true;
}
function hi(e, t, n10) {
  if (n10 != null && e.indexOf(n10) < 0)
    throw new U2(`${n10} is not a valid ${t}.  Valid values are ${e} or null/undefined.`);
}
function xb(e, t, n10 = 0, s10 = 1 / 0) {
  return Cs(n10 >= 0), Cs(s10 >= n10), Array.isArray(e) && e.length >= n10 && e.length <= s10 && e.every((r10) => typeof r10 === t);
}
function Bt(e, t) {
  Array.isArray(e) ? (w2.assert(e.length > 0, () => `${t} is unexpectedly an empty array.`), e.forEach((n10, s10) => Bt(n10, `element ${s10 + 1} of ${t}`))) : w2.assert(Number.isInteger(e) && e > 0, () => `Expected ${t} to be a positive integer, but got ${OI(e)}.`);
}
function OI(e) {
  return e === null ? "null" : Array.isArray(e) ? "[" + e.map((t) => OI(t)).join(",") + "]" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function EM(e, t, n10) {
  let s10 = n10 != null ? n10() : w2.now(), r10;
  return (...i10) => {
    let o10 = n10 != null ? n10() : w2.now();
    return o10 - s10 < t || (s10 = o10, r10 = e(...i10)), r10;
  };
}
function PI(e) {
  return e === "relu" ? "relu" : e === "linear" ? "linear" : e === "elu" ? "elu" : null;
}
function wb(e, t) {
  return j2(() => ln(ye2(V2(e, e), t, true)));
}
var Ml = class extends ae2.Serializable {
  getConfig() {
    return {};
  }
};
var kb = class extends Ml {
  constructor(e) {
    super();
    this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return j2(() => {
      let t = wb(e, this.axis), n10 = Bn(t, 0, this.maxValue);
      return V2(e, xe2(n10, ie2(Rt(), t)));
    });
  }
  getConfig() {
    return { maxValue: this.maxValue, axis: this.axis };
  }
};
kb.className = "MaxNorm";
ae2.registerClass(kb);
var Ib = class extends Ml {
  constructor(e) {
    super();
    this.defaultAxis = 0, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return j2(() => xe2(e, ie2(Rt(), wb(e, this.axis))));
  }
  getConfig() {
    return { axis: this.axis };
  }
};
Ib.className = "UnitNorm";
ae2.registerClass(Ib);
var Sb = class extends Ml {
  apply(e) {
    return Xs(e);
  }
};
Sb.className = "NonNeg";
ae2.registerClass(Sb);
var Cb = class extends Ml {
  constructor(e) {
    super();
    this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = e.minValue != null ? e.minValue : this.defaultMinValue, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.rate = e.rate != null ? e.rate : this.defaultRate, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return j2(() => {
      let t = wb(e, this.axis), n10 = ie2(V2(this.rate, Bn(t, this.minValue, this.maxValue)), V2(1 - this.rate, t));
      return V2(e, xe2(n10, ie2(Rt(), t)));
    });
  }
  getConfig() {
    return { minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis };
  }
};
Cb.className = "MinMaxNorm";
ae2.registerClass(Cb);
var kx = { maxNorm: "MaxNorm", minMaxNorm: "MinMaxNorm", nonNeg: "NonNeg", unitNorm: "UnitNorm" };
function Ot(e) {
  return vb(e);
}
function Ix(e, t = {}) {
  return zl(e, ae2.SerializationMap.getMap().classNameMap, t, "constraint");
}
function Pt(e) {
  if (e == null)
    return null;
  if (typeof e == "string") {
    let n10 = { className: e in kx ? kx[e] : e, config: {} };
    return Ix(n10);
  } else
    return e instanceof Ml ? e : Ix(e);
}
function RM(e) {
  return new kb(e);
}
function DM(e) {
  return new Ib(e);
}
function FM() {
  return new Sb();
}
function OM(e) {
  return new Cb(e);
}
var PM = {};
Ae(PM, { constant: () => aL, glorotNormal: () => pL, glorotUniform: () => dL, heNormal: () => hL, heUniform: () => fL, identity: () => lL, leCunNormal: () => mL, leCunUniform: () => gL, ones: () => rL, orthogonal: () => bL, randomNormal: () => oL, randomUniform: () => iL, truncatedNormal: () => uL, varianceScaling: () => cL, zeros: () => sL });
var zM = ["channelsFirst", "channelsLast"];
var MM = ["nearest", "bilinear"];
var LM = ["valid", "same", "causal"];
var BM = ["max", "avg"];
var VM = ["sum", "mul", "concat", "ave"];
var Oi = /* @__PURE__ */ new Map();
function St(e) {
  hi(zM, "DataFormat", e);
}
function WM(e) {
  hi(MM, "InterpolationFormat", e);
}
function Un(e) {
  hi(LM, "PaddingMode", e);
}
function zI(e) {
  hi(BM, "PoolMode", e);
}
var zu = [];
var Sx = "/";
function Zr(e, t) {
  zu.push(e);
  try {
    let n10 = t();
    return zu.pop(), n10;
  } catch (n10) {
    throw zu.pop(), n10;
  }
}
function UM() {
  return zu.length === 0 ? "" : zu.join(Sx) + Sx;
}
function MI(e) {
  if (!BI(e))
    throw new Error("Not a valid tensor name: '" + e + "'");
  return UM() + e;
}
function LI(e) {
  if (!BI(e))
    throw new Error("Not a valid tensor name: '" + e + "'");
  Oi.has(e) || Oi.set(e, 0);
  let t = Oi.get(e);
  if (Oi.set(e, Oi.get(e) + 1), t > 0) {
    let n10 = `${e}_${t}`;
    return Oi.set(n10, 1), n10;
  } else
    return e;
}
var GM = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
function BI(e) {
  return !!e.match(GM);
}
function HM(e) {
  return e === parseInt(e.toString(), 10);
}
function dr(e, t, n10) {
  t == null && (t = 0), n10 == null && (n10 = e.length);
  let s10 = 1;
  for (let r10 = t; r10 < n10; ++r10)
    s10 *= e[r10];
  return s10;
}
function Qi(e) {
  if (e.length === 0)
    return Number.NaN;
  let t = Number.POSITIVE_INFINITY;
  for (let n10 = 0; n10 < e.length; n10++) {
    let s10 = e[n10];
    s10 < t && (t = s10);
  }
  return t;
}
function gr(e) {
  if (e.length === 0)
    return Number.NaN;
  let t = Number.NEGATIVE_INFINITY;
  for (let n10 = 0; n10 < e.length; n10++) {
    let s10 = e[n10];
    s10 > t && (t = s10);
  }
  return t;
}
function ys(e, t) {
  if (t < e)
    throw new U2(`end (${t}) < begin (${e}) is forbidden.`);
  let n10 = [];
  for (let s10 = e; s10 < t; ++s10)
    n10.push(s10);
  return n10;
}
function Ip(e, t) {
  return ce2(e, t);
}
function Ll(e, t = -1) {
  let n10 = e.shape.slice();
  return t < 0 && (t = n10.length + t + 1), n10.splice(t, 0, 1), G2(e, n10);
}
function qM(e, t) {
  return j2(() => {
    if (e.shape.length !== 2)
      throw new U2(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);
    let n10 = Ll(e, 1);
    return fm(n10, [1, t, 1]);
  });
}
function jM(e) {
  let t = [dr(e.shape)];
  return G2(e, t);
}
function KM(e) {
  if (e.rank <= 1)
    throw new U2(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);
  let t = [e.shape[0], dr(e.shape, 1)];
  return G2(e, t);
}
function Jr(e, t, n10) {
  return j2(() => {
    switch (e.rank) {
      case 1:
        return rb(e, t, n10);
      case 2:
        return hI(e, [t, 0], [n10, e.shape[1]]);
      case 3:
        return ab(e, [t, 0, 0], [n10, e.shape[1], e.shape[2]]);
      case 4:
        return wd(e, [t, 0, 0, 0], [n10, e.shape[1], e.shape[2], e.shape[3]]);
      case 5:
        return He(e, [t, 0, 0, 0, 0], [n10, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
      case 6:
        return He(e, [t, 0, 0, 0, 0, 0], [n10, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
      default:
        throw new U2(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`);
    }
  });
}
function Lf(e, t, n10) {
  return j2(() => {
    switch (e.rank) {
      case 1:
        return rb(e, t, n10);
      case 2:
        return hI(e, [0, t], [e.shape[0], n10]);
      case 3:
        return ab(e, [0, 0, t], [e.shape[0], e.shape[1], n10]);
      case 4:
        return wd(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n10]);
      default:
        throw new U2(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`);
    }
  });
}
function Uc(e, t, n10, s10) {
  return j2(() => {
    switch (e.rank) {
      case 1:
        return rb(e, t, n10);
      case 2:
        switch (s10) {
          case 1:
            return Jr(e, t, n10);
          case 2:
            return Lf(e, t, n10);
          default:
            throw new U2(`The axis is not within the rank of the tensor ${s10}`);
        }
      case 3:
        switch (s10) {
          case 1:
            return Jr(e, t, n10);
          case 2:
            return ab(e, [0, t, 0], [e.shape[0], n10, e.shape[2]]);
          case 3:
            return Lf(e, t, n10);
          default:
            throw new U2(`The axis is not within the rank of the tensor ${s10}`);
        }
      case 4:
        switch (s10) {
          case 1:
            return Jr(e, t, n10);
          case 2:
            return wd(e, [0, t, 0, 0], [e.shape[0], n10, e.shape[2], e.shape[3]]);
          case 3:
            return wd(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n10, e.shape[3]]);
          case 4:
            return Lf(e, t, n10);
          default:
            throw new U2(`The axis is not within the rank of the tensor ${s10}`);
        }
      default:
        throw new U2(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`);
    }
  });
}
function Nb(e, t = -1) {
  let n10;
  return t < 0 && (n10 = e[0].rank, n10 !== 0 ? t = n10 : t = 0), t === e[0].rank && (t = -1), Ft(e, t);
}
function Cx(e, t) {
  switch (e.rank) {
    case 1:
      return RE([e, t]);
    case 2:
      return FE([e, t], 0);
    case 3:
      return PE([e, t], 0);
    case 4:
      return ME([e, t], 0);
    default:
      throw new U2(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`);
  }
}
function fm(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length)
    throw new U2(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);
  return cs(e, t);
}
function Sp(e, t = 0, n10 = 1, s10, r10) {
  return zD(e, t, n10, s10, r10);
}
function Es(e, t, n10, s10) {
  if (e.rank < 2 || t.rank < 2)
    throw new Fe(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);
  if (t.rank >= 3) {
    let r10 = e.shape.slice(-1)[0], a10 = t.shape.slice(-2)[0];
    if (r10 !== a10)
      throw new Fe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);
  }
  if (e.rank === 2 && t.rank === 2)
    return da.matMul({ a: e, b: t, transposeA: false, transposeB: false, bias: s10 ? mm(e.rank, s10, bs()) : null, activation: n10 });
  {
    let r10 = e.shape.slice(), a10 = r10.pop();
    e = G2(e, [-1, a10]);
    let i10 = t.shape.slice(), o10 = i10.pop(), u10 = i10.pop(), l10 = [...i10, o10], c10 = Array.from({ length: t.rank }, (f10, m10) => m10 === 0 ? t.rank - 2 : m10 <= t.rank - 2 ? m10 - 1 : m10);
    t = G2(qe(t, c10), [u10, -1]);
    let p10 = [...r10, ...l10], d10 = false, h10 = false;
    return G2(da.matMul({ a: e, b: t, transposeA: d10, transposeB: h10, bias: s10 ? mm(e.rank, s10, bs()) : null, activation: n10 }), p10);
  }
}
function VI(e, t, n10) {
  return j2(() => (Array.isArray(t) ? t = Qt(t, "int32") : t = ce2(t, "int32"), ju(e, t, n10)));
}
function Bl(e) {
  return V2(e, e);
}
function mm(e, t, n10) {
  let s10 = t.shape;
  if (t.rank !== 1 && t.rank !== e)
    throw new U2(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);
  if (e === 5) {
    if (n10 === "channelsFirst")
      return s10.length === 1 ? G2(t, [1, s10[0], 1, 1, 1]) : G2(t, [1, s10[3], s10[0], s10[1], s10[2]]);
    if (n10 === "channelsLast")
      return s10.length === 1 ? G2(t, [1, 1, 1, 1, s10[0]]) : G2(t, [1].concat(s10));
  } else if (e === 4) {
    if (n10 === "channelsFirst")
      return s10.length === 1 ? G2(t, [1, s10[0], 1, 1]) : G2(t, [1, s10[2], s10[0], s10[1]]);
    if (n10 === "channelsLast")
      return s10.length === 1 ? G2(t, [1, 1, 1, s10[0]]) : G2(t, [1].concat(s10));
  } else if (e === 3) {
    if (n10 === "channelsFirst")
      return s10.length === 1 ? G2(t, [1, s10[0], 1]) : G2(t, [1, s10[1], s10[0]]);
    if (n10 === "channelsLast")
      return s10.length === 1 ? G2(t, [1, 1, s10[0]]) : G2(t, [1].concat(s10));
  } else if (e < 3)
    return t;
  throw new U2(`Unsupported input rank by biasAdd: ${t.rank}`);
}
function ws(e, t, n10) {
  return j2(() => (n10 == null && (n10 = bs()), St(n10), ie2(e, mm(e.rank, t, n10))));
}
function XM(e, t = 1) {
  if (t !== 1)
    throw new Fe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
  return hp(e);
}
function YM(e) {
  return j2(() => xe2(e, ie2(Mt(e), 1)));
}
function WI(e, t, n10, s10) {
  return j2(() => H3(e, t, n10, s10));
}
function QM(e) {
  return j2(() => {
    let t = ie2(0.5, V2(0.2, e));
    return Bn(t, 0, 1);
  });
}
function Vl(e, t, n10 = false) {
  return n10 ? e() : t();
}
var ZM = ["fanIn", "fanOut", "fanAvg"];
var JM = ["normal", "uniform", "truncatedNormal"];
function eL(e) {
  hi(ZM, "FanMode", e);
}
function tL(e) {
  hi(JM, "Distribution", e);
}
var es = class extends ae2.Serializable {
  fromConfigUsesCustomObjects() {
    return false;
  }
  getConfig() {
    return {};
  }
};
var Tb = class extends es {
  apply(e, t) {
    return $t(e, t);
  }
};
Tb.className = "Zeros";
ae2.registerClass(Tb);
var Cp = class extends es {
  apply(e, t) {
    return zn(e, t);
  }
};
Cp.className = "Ones";
ae2.registerClass(Cp);
var $b = class extends es {
  constructor(e) {
    super();
    if (typeof e != "object")
      throw new U2(`Expected argument of type ConstantConfig but got ${e}`);
    if (e.value === void 0)
      throw new U2(`config must have value set but got ${e}`);
    this.value = e.value;
  }
  apply(e, t) {
    return j2(() => V2(Ie2(this.value), zn(e, t)));
  }
  getConfig() {
    return { value: this.value };
  }
};
$b.className = "Constant";
ae2.registerClass($b);
var _b = class extends es {
  constructor(e) {
    super();
    this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed;
  }
  apply(e, t) {
    return Pl(e, this.minval, this.maxval, t);
  }
  getConfig() {
    return { minval: this.minval, maxval: this.maxval, seed: this.seed };
  }
};
_b.className = "RandomUniform";
ae2.registerClass(_b);
var Ab = class extends es {
  constructor(e) {
    super();
    this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }
  apply(e, t) {
    if (t = t || "float32", t !== "float32" && t !== "int32")
      throw new Fe(`randomNormal does not support dType ${t}.`);
    return Sp(e, this.mean, this.stddev, t, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
};
Ab.className = "RandomNormal";
ae2.registerClass(Ab);
var Eb = class extends es {
  constructor(e) {
    super();
    this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }
  apply(e, t) {
    if (t = t || "float32", t !== "float32" && t !== "int32")
      throw new Fe(`truncatedNormal does not support dType ${t}.`);
    return lb(e, this.mean, this.stddev, t, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
};
Eb.className = "TruncatedNormal";
ae2.registerClass(Eb);
var Rb = class extends es {
  constructor(e) {
    super();
    this.gain = e.gain != null ? e.gain : 1;
  }
  apply(e, t) {
    return j2(() => {
      if (e.length !== 2 || e[0] !== e[1])
        throw new U2("Identity matrix initializer can only be used for 2D square matrices.");
      return V2(this.gain, Zk(e[0]));
    });
  }
  getConfig() {
    return { gain: this.gain };
  }
};
Rb.className = "Identity";
ae2.registerClass(Rb);
function nL(e, t = "channelsLast") {
  let n10, s10;
  if (St(t), e.length === 2)
    n10 = e[0], s10 = e[1];
  else if ([3, 4, 5].indexOf(e.length) !== -1) {
    if (t === "channelsFirst") {
      let r10 = dr(e, 2);
      n10 = e[1] * r10, s10 = e[0] * r10;
    } else if (t === "channelsLast") {
      let r10 = dr(e, 0, e.length - 2);
      n10 = e[e.length - 2] * r10, s10 = e[e.length - 1] * r10;
    }
  } else {
    let r10 = dr(e);
    n10 = Math.sqrt(r10), s10 = Math.sqrt(r10);
  }
  return [n10, s10];
}
var xn = class extends es {
  constructor(e) {
    super();
    if (e.scale < 0)
      throw new U2(`scale must be a positive float. Got: ${e.scale}`);
    this.scale = e.scale == null ? 1 : e.scale, this.mode = e.mode == null ? "fanIn" : e.mode, eL(this.mode), this.distribution = e.distribution == null ? "normal" : e.distribution, tL(this.distribution), this.seed = e.seed;
  }
  apply(e, t) {
    let n10 = nL(e), s10 = n10[0], r10 = n10[1], a10 = this.scale;
    if (this.mode === "fanIn" ? a10 /= Math.max(1, s10) : this.mode === "fanOut" ? a10 /= Math.max(1, r10) : a10 /= Math.max(1, (s10 + r10) / 2), this.distribution === "normal") {
      let i10 = Math.sqrt(a10);
      if (t = t || "float32", t !== "float32" && t !== "int32")
        throw new Fe(`${this.getClassName()} does not support dType ${t}.`);
      return lb(e, 0, i10, t, this.seed);
    } else {
      let i10 = Math.sqrt(3 * a10);
      return Pl(e, -i10, i10, t);
    }
  }
  getConfig() {
    return { scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed };
  }
};
xn.className = "VarianceScaling";
ae2.registerClass(xn);
var Np = class extends xn {
  constructor(e) {
    super({ scale: 1, mode: "fanAvg", distribution: "uniform", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
Np.className = "GlorotUniform";
ae2.registerClass(Np);
var Tp = class extends xn {
  constructor(e) {
    super({ scale: 1, mode: "fanAvg", distribution: "normal", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
Tp.className = "GlorotNormal";
ae2.registerClass(Tp);
var $p = class extends xn {
  constructor(e) {
    super({ scale: 2, mode: "fanIn", distribution: "normal", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
$p.className = "HeNormal";
ae2.registerClass($p);
var _p = class extends xn {
  constructor(e) {
    super({ scale: 2, mode: "fanIn", distribution: "uniform", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
_p.className = "HeUniform";
ae2.registerClass(_p);
var Ap = class extends xn {
  constructor(e) {
    super({ scale: 1, mode: "fanIn", distribution: "normal", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
Ap.className = "LeCunNormal";
ae2.registerClass(Ap);
var Ep = class extends xn {
  constructor(e) {
    super({ scale: 1, mode: "fanIn", distribution: "uniform", seed: e == null ? null : e.seed });
  }
  getClassName() {
    return xn.className;
  }
};
Ep.className = "LeCunNormal";
ae2.registerClass(Ep);
var Db = class extends es {
  constructor(e) {
    super();
    if (this.DEFAULT_GAIN = 1, this.gain = e.gain == null ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed, this.seed != null)
      throw new Fe("Random seed is not implemented for Orthogonal Initializer yet.");
  }
  apply(e, t) {
    return j2(() => {
      if (e.length < 2)
        throw new Fe("Shape must be at least 2D.");
      e[0] * e[1] > 2e3 && console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0] * e[1]}) elements: Slowness may result.`);
      let n10 = e[0] > e[1] ? [e[1], e[0]] : e, s10 = Sp(n10, 0, 1, "float32"), r10 = AO.gramSchmidt(s10);
      return e[0] > e[1] && (r10 = qe(r10)), V2(this.gain, r10);
    });
  }
  getConfig() {
    return { gain: this.gain, seed: this.seed };
  }
};
Db.className = "Orthogonal";
ae2.registerClass(Db);
var Nx = { constant: "Constant", glorotNormal: "GlorotNormal", glorotUniform: "GlorotUniform", heNormal: "HeNormal", heUniform: "HeUniform", identity: "Identity", leCunNormal: "LeCunNormal", leCunUniform: "LeCunUniform", ones: "Ones", orthogonal: "Orthogonal", randomNormal: "RandomNormal", randomUniform: "RandomUniform", truncatedNormal: "TruncatedNormal", varianceScaling: "VarianceScaling", zeros: "Zeros" };
function Tx(e, t = {}) {
  return zl(e, ae2.SerializationMap.getMap().classNameMap, t, "initializer");
}
function yt(e) {
  return vb(e);
}
function ht(e) {
  if (typeof e == "string") {
    let t = e in Nx ? Nx[e] : e;
    if (t === "GlorotNormal")
      return new Tp();
    if (t === "GlorotUniform")
      return new Np();
    if (t === "HeNormal")
      return new $p();
    if (t === "HeUniform")
      return new _p();
    if (t === "LeCunNormal")
      return new Ap();
    if (t === "LeCunUniform")
      return new Ep();
    {
      let n10 = {};
      return n10.className = t, n10.config = {}, Tx(n10);
    }
  } else
    return e instanceof es ? e : Tx(e);
}
function sL() {
  return new Tb();
}
function rL() {
  return new Cp();
}
function aL(e) {
  return new $b(e);
}
function iL(e) {
  return new _b(e);
}
function oL(e) {
  return new Ab(e);
}
function uL(e) {
  return new Eb(e);
}
function lL(e) {
  return new Rb(e);
}
function cL(e) {
  return new xn(e);
}
function dL(e) {
  return new Np(e);
}
function pL(e) {
  return new Tp(e);
}
function hL(e) {
  return new $p(e);
}
function fL(e) {
  return new _p(e);
}
function mL(e) {
  return new Ap(e);
}
function gL(e) {
  return new Ep(e);
}
function bL(e) {
  return new Db(e);
}
var yL = {};
Ae(yL, { Layer: () => Ge, RNN: () => _r, RNNCell: () => Gl, activation: () => eV, add: () => lV, alphaDropout: () => qV, average: () => cV, averagePooling1d: () => Uy, averagePooling2d: () => Gy, averagePooling3d: () => Hy, avgPool1d: () => vV, avgPool2d: () => wV, avgPool3d: () => IV, avgPooling1d: () => xV, avgPooling2d: () => kV, avgPooling3d: () => SV, batchNormalization: () => gV, bidirectional: () => MV, concatenate: () => dV, conv1d: () => HB, conv2d: () => qB, conv2dTranspose: () => jB, conv3d: () => KB, conv3dTranspose: () => XB, convLstm2d: () => FV, convLstm2dCell: () => OV, cropping2D: () => QB, dense: () => tV, depthwiseConv2d: () => JB, dot: () => mV, dropout: () => nV, elu: () => LB, embedding: () => uV, flatten: () => rV, gaussianDropout: () => HV, gaussianNoise: () => GV, globalAveragePooling1d: () => CV, globalAveragePooling2d: () => NV, globalMaxPool1d: () => BV, globalMaxPool2d: () => VV, globalMaxPooling1d: () => z0, globalMaxPooling2d: () => M0, gru: () => $V, gruCell: () => _V, input: () => CB, inputLayer: () => MB, layerNormalization: () => bV, leakyReLU: () => VB, lstm: () => AV, lstmCell: () => EV, masking: () => jV, maxPool1d: () => WV, maxPool2d: () => UV, maxPooling1d: () => L0, maxPooling2d: () => B0, maxPooling3d: () => TV, maximum: () => pV, minimum: () => hV, multiply: () => fV, permute: () => oV, prelu: () => WB, reLU: () => BB, repeatVector: () => aV, reshape: () => iV, rnn: () => PV, separableConv2d: () => YB, simpleRNN: () => RV, simpleRNNCell: () => DV, softmax: () => UB, spatialDropout1d: () => sV, stackedRNNCells: () => zV, thresholdedReLU: () => GB, timeDistributed: () => LV, upSampling2d: () => ZB, zeroPadding2d: () => yV });
var vL = 0;
function UI() {
  return vL++;
}
var Gc = {};
function Rp(e = "") {
  return e in Gc || (Gc[e] = 0), Gc[e] += 1, e + Gc[e].toString();
}
function gm(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}
function Id(e) {
  return e.length === 0 ? [] : Array.isArray(e[0]) ? e : [e];
}
function Oe(e) {
  let t;
  if (Array.isArray(e)) {
    if (e.length !== 1)
      throw new U2(`Expected Tensor length to be 1; got ${e.length}`);
    t = e[0];
  } else
    t = e;
  return t;
}
function nt(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (e.length === 1)
      return e = e, e[0];
    throw new U2(`Expected exactly 1 Shape; got ${e.length}`);
  } else
    return e;
}
function Sd(e) {
  let t = 0;
  for (let n10 of e)
    n10.shape.length === 0 ? t += 1 : t += n10.shape.reduce((s10, r10) => s10 * r10);
  return t;
}
var $x = "Variable";
var xL = class {
  constructor(e, t = "float32", n10 = $x, s10 = true, r10 = null) {
    this.dtype = t == null ? "float32" : t, this.shape = e.shape, this.id = UI(), n10 = n10 == null ? $x : n10, this.originalName = MI(n10), this.name = LI(this.originalName), this.trainable_ = s10, this.constraint = r10, this.val = R3(e, this.trainable_, this.name, this.dtype);
  }
  read() {
    return this.assertNotDisposed(), this.val;
  }
  write(e) {
    return this.assertNotDisposed(), wL(this.val, e), this.val.id !== e.id && (this.val.assign(e), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
  }
  dispose() {
    this.assertNotDisposed(), this.val.dispose();
  }
  assertNotDisposed() {
    if (this.val.isDisposed)
      throw new Error(`LayersVariable ${this.name} is already disposed.`);
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this.trainable_ = e, this.val.trainable = e;
  }
};
function wL(e, t) {
  if (e.shape.toString() !== t.shape.toString())
    throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
}
function bm(e) {
  return e.map((t) => t.read());
}
function Fb(e) {
  e.forEach((t) => {
    t[0].write(t[1]);
  });
}
var Dt = class {
  constructor(e) {
    this.dtype = e.dtype, this.shape = e.shape, e.shape != null ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  }
};
var $s = class {
  constructor(e, t, n10, s10, r10, a10, i10) {
    this.dtype = e, this.shape = t, this.sourceLayer = n10, this.inputs = s10, this.callArgs = r10, this.outputTensorIndex = i10, this.id = UI(), a10 != null && (this.originalName = MI(a10), this.name = LI(this.originalName)), this.rank = t.length;
  }
};
var kL = 0;
var Dp = class {
  constructor(e, t) {
    this.callArgs = t, this.id = kL++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
    for (let n10 of e.inboundLayers)
      n10 != null && n10.outboundNodes.push(this);
    e.outboundLayer.inboundNodes.push(this);
  }
  getConfig() {
    let e = [];
    for (let t of this.inboundLayers)
      t != null ? e.push(t.name) : e.push(null);
    return { outboundLayer: this.outboundLayer ? this.outboundLayer.name : null, inboundLayers: e, nodeIndices: this.nodeIndices, tensorIndices: this.tensorIndices };
  }
};
var IL = 0;
var Ge = class extends ae2.Serializable {
  constructor(e = {}) {
    super();
    this._callHook = null, this._addedWeightNames = [], this._stateful = false, this.id = IL++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = false, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = false, this.inboundNodes = [], this.outboundNodes = [];
    let t = e.name;
    if (!t) {
      let n10 = this.getClassName();
      t = Ws(n10) + "_" + Rp(n10);
    }
    if (this.name = t, this.trainable_ = e.trainable == null ? true : e.trainable, e.inputShape != null || e.batchInputShape != null) {
      let n10;
      if (e.batchInputShape != null)
        n10 = e.batchInputShape;
      else if (e.inputShape != null) {
        let r10 = null;
        e.batchSize != null && (r10 = e.batchSize), n10 = [r10].concat(e.inputShape);
      }
      this.batchInputShape = n10;
      let s10 = e.dtype;
      s10 == null && (s10 = e.inputDType), s10 == null && (s10 = "float32"), this.dtype = s10;
    }
    e.weights != null ? this.initialWeights = e.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = false;
  }
  static nodeKey(e, t) {
    return e.name + "_ib-" + t.toString();
  }
  getNodeAtIndex(e, t) {
    if (this.inboundNodes.length === 0)
      throw new ps(`The layer has never been called and thus has no defined ${t}.`);
    if (this.inboundNodes.length <= e)
      throw new U2(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
    return this.inboundNodes[e];
  }
  getInputAt(e) {
    return gn(this.getNodeAtIndex(e, "input").inputTensors);
  }
  getOutputAt(e) {
    return gn(this.getNodeAtIndex(e, "output").outputTensors);
  }
  get input() {
    if (this.inboundNodes.length > 1)
      throw new Vs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
    if (this.inboundNodes.length === 0)
      throw new Vs(`Layer ${this.name} is not connected, no input to return.`);
    return gn(this.getNodeAtIndex(0, "input").inputTensors);
  }
  get output() {
    if (this.inboundNodes.length === 0)
      throw new Vs(`Layer ${this.name} has no inbound nodes.`);
    if (this.inboundNodes.length > 1)
      throw new Vs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
    return gn(this.getNodeAtIndex(0, "output").outputTensors);
  }
  get losses() {
    return this._losses;
  }
  calculateLosses() {
    return this.losses.map((e) => e());
  }
  get updates() {
    return this._updates;
  }
  get built() {
    return this._built;
  }
  set built(e) {
    this._built = e;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this._trainableWeights.forEach((t) => t.trainable = e), this.trainable_ = e;
  }
  get trainableWeights() {
    return this.trainable_ ? this._trainableWeights.filter((e) => e.trainable) : [];
  }
  set trainableWeights(e) {
    this._trainableWeights = e;
  }
  get nonTrainableWeights() {
    return this.trainable ? this._trainableWeights.filter((e) => !e.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
  }
  set nonTrainableWeights(e) {
    this._nonTrainableWeights = e;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  get stateful() {
    return this._stateful;
  }
  resetStates() {
    if (!this.stateful)
      throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }
  assertInputCompatibility(e) {
    if (e = dt(e), this.inputSpec == null || this.inputSpec.length === 0)
      return;
    let t = dt(this.inputSpec);
    if (e.length !== t.length)
      throw new U2(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);
    for (let n10 = 0; n10 < e.length; n10++) {
      let s10 = e[n10], r10 = t[n10];
      if (r10 == null)
        continue;
      let a10 = s10.rank;
      if (r10.ndim != null && a10 !== r10.ndim)
        throw new U2(`Input ${n10} is incompatible with layer ${this.name}: expected ndim=${r10.ndim}, found ndim=${a10}`);
      if (r10.maxNDim != null && a10 > r10.maxNDim)
        throw new U2(`Input ${n10} is incompatible with layer ${this.name}: expected max_ndim=${r10.maxNDim}, found ndim=${a10}`);
      if (r10.minNDim != null && a10 < r10.minNDim)
        throw new U2(`Input ${n10} is incompatible with layer ${this.name}: expected min_ndim=${r10.minNDim}, found ndim=${a10}.`);
      if (r10.dtype != null && s10.dtype !== r10.dtype)
        throw new U2(`Input ${n10} is incompatible with layer ${this.name} : expected dtype=${r10.dtype}, found dtype=${s10.dtype}.`);
      if (r10.axes) {
        let i10 = s10.shape;
        for (let o10 in r10.axes) {
          let u10 = Number(o10), l10 = r10.axes[o10], c10 = u10 >= 0 ? i10[u10] : i10[i10.length + u10];
          if (l10 != null && [l10, null].indexOf(c10) === -1)
            throw new U2(`Input ${n10} is incompatible with layer ${this.name}: expected axis ${u10} of input shape to have value ${l10} but got shape ${i10}.`);
        }
      }
      if (r10.shape != null)
        for (let i10 = 0; i10 < r10.shape.length; ++i10) {
          let o10 = r10.shape[i10], u10 = s10.shape[i10];
          if (o10 != null && u10 != null && o10 !== u10)
            throw new U2(`Input ${n10} is incompatible with layer ${this.name}: expected shape=${r10.shape}, found shape=${s10.shape}.`);
        }
    }
  }
  call(e, t) {
    return e;
  }
  invokeCallHook(e, t) {
    this._callHook != null && this._callHook(e, t);
  }
  setCallHook(e) {
    this._callHook = e;
  }
  clearCallHook() {
    this._callHook = null;
  }
  apply(e, t) {
    t = t || {}, this.assertNotDisposed();
    let n10 = dt(e), s10 = true;
    for (let a10 of n10)
      if (!(a10 instanceof $s)) {
        s10 = false;
        break;
      }
    let r10 = true;
    for (let a10 of n10)
      if (a10 instanceof $s) {
        r10 = false;
        break;
      }
    if (s10 === r10)
      throw new U2("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return Zr(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(e);
        let a10 = [];
        for (let i10 of dt(e))
          a10.push(i10.shape);
        this.build(gn(a10)), this.built = true, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && r10 && (this._refCount = 1);
      }
      if (this.assertInputCompatibility(e), r10) {
        let a10 = this.call(e, t), i10 = dt(a10), o10 = [];
        for (let u10 of i10)
          n10.indexOf(u10) !== -1 && (u10 = u10.clone()), o10.push(u10);
        if (a10 = gn(o10), this.activityRegularizer != null)
          throw new Fe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return a10;
      } else {
        let a10 = SL(e), i10 = this.computeOutputShape(a10), o10, u10 = CL(e);
        if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? a10[0] : a10), i10 != null && i10.length > 0 && Array.isArray(i10[0]) ? o10 = i10.map((l10, c10) => new $s(u10, l10, this, dt(e), t, this.name, c10)) : o10 = new $s(u10, i10, this, dt(e), t, this.name), this.addInboundNode(e, o10, null, null, a10, i10, t), this._refCount++, this.activityRegularizer != null)
          throw new Fe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return o10;
      }
    });
  }
  warnOnIncompatibleInputShape(e) {
    if (this.batchInputShape != null)
      if (e.length !== this.batchInputShape.length)
        console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let t = false;
        this.batchInputShape.forEach((n10, s10) => {
          n10 != null && e[s10] != null && e[s10] !== n10 && (t = true);
        }), t && console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
  }
  get outputShape() {
    if (this.inboundNodes == null || this.inboundNodes.length === 0)
      throw new Vs(`The layer ${this.name} has never been called and thus has no defined output shape.`);
    let e = [];
    for (let t of this.inboundNodes) {
      let n10 = JSON.stringify(t.outputShapes);
      e.indexOf(n10) === -1 && e.push(n10);
    }
    if (e.length === 1) {
      let t = this.inboundNodes[0].outputShapes;
      return Array.isArray(t) && Array.isArray(t[0]) && t.length === 1 ? t[0] : t;
    } else
      throw new Vs(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
  }
  countParams() {
    if (!this.built)
      throw new ps(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
    return Sd(this.weights);
  }
  build(e) {
    this.built = true;
  }
  getWeights(e = false) {
    return bm(e ? this.trainableWeights : this.weights);
  }
  setWeights(e) {
    j2(() => {
      let t = this.weights;
      if (t.length !== e.length)
        throw new U2(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);
      if (t.length === 0)
        return;
      let n10 = [], s10 = bm(t);
      for (let r10 = 0; r10 < s10.length; ++r10) {
        let a10 = s10[r10], i10 = t[r10], o10 = e[r10];
        if (!w2.arraysEqual(a10.shape, o10.shape))
          throw new U2(`Layer weight shape ${a10.shape} not compatible with provided weight shape ${o10.shape}`);
        n10.push([i10, o10]);
      }
      Fb(n10);
    });
  }
  addWeight(e, t, n10, s10, r10, a10, i10, o10) {
    if (this._addedWeightNames.indexOf(e) !== -1)
      throw new U2(`Duplicate weight name ${e} for layer ${this.name}`);
    this._addedWeightNames.push(e), n10 == null && (n10 = "float32"), this.fastWeightInitDuringBuild && (s10 = o10 != null ? o10() : ht("zeros"));
    let u10 = s10.apply(t, n10), l10 = new xL(u10, n10, e, a10, i10);
    return u10.dispose(), r10 != null && this.addLoss(() => r10.apply(l10.read())), a10 == null && (a10 = true), a10 ? this._trainableWeights.push(l10) : this._nonTrainableWeights.push(l10), l10;
  }
  setFastWeightInitDuringBuild(e) {
    this.fastWeightInitDuringBuild = e;
  }
  addLoss(e) {
    e == null || Array.isArray(e) && e.length === 0 || (e = dt(e), this._losses !== void 0 && this._losses !== null && this.losses.push(...e));
  }
  computeOutputShape(e) {
    return e;
  }
  computeMask(e, t) {
    if (!this.supportsMasking) {
      if (t != null)
        if (Array.isArray(t))
          t.forEach((n10) => {
            if (n10 != null)
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
          });
        else
          throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
      return null;
    }
    return t;
  }
  addInboundNode(e, t, n10, s10, r10, a10, i10 = null) {
    let o10 = dt(e);
    t = dt(t), n10 = dt(n10), s10 = dt(s10), r10 = Id(r10), a10 = Id(a10);
    let u10 = [], l10 = [], c10 = [];
    for (let p10 of o10)
      u10.push(p10.sourceLayer), l10.push(p10.nodeIndex), c10.push(p10.tensorIndex);
    new Dp({ outboundLayer: this, inboundLayers: u10, nodeIndices: l10, tensorIndices: c10, inputTensors: o10, outputTensors: t, inputMasks: n10, outputMasks: s10, inputShapes: r10, outputShapes: a10 }, i10);
    for (let p10 = 0; p10 < t.length; p10++)
      t[p10].sourceLayer = this, t[p10].nodeIndex = this.inboundNodes.length - 1, t[p10].tensorIndex = p10;
  }
  getConfig() {
    let e = { name: this.name, trainable: this.trainable };
    return this.batchInputShape != null && (e.batchInputShape = this.batchInputShape), this.dtype != null && (e.dtype = this.dtype), e;
  }
  disposeWeights() {
    return this.weights.forEach((e) => e.dispose()), this.weights.length;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Layer '${this.name}' is already disposed.`);
  }
  dispose() {
    if (!this.built)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
    if (this._refCount === null)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
    this.assertNotDisposed();
    let e = 0;
    return --this._refCount === 0 && (e = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: e };
  }
};
function SL(e) {
  e = dt(e);
  let t = [];
  for (let n10 of e)
    t.push(n10.shape);
  return gn(t);
}
function CL(e) {
  return "float32";
}
function GI(e, t, n10) {
  if ((t == null || n10 != null && n10 > 0) && (t = e.sourceLayer, n10 = e.nodeIndex), t.inboundNodes.length === 0)
    return [e];
  {
    let s10 = t.inboundNodes[n10];
    if (s10.inboundLayers.length === 0)
      return s10.inputTensors;
    {
      let r10 = [];
      for (let a10 = 0; a10 < s10.inboundLayers.length; a10++) {
        let i10 = s10.inputTensors[a10], o10 = s10.inboundLayers[a10], u10 = s10.nodeIndices[a10], l10 = GI(i10, o10, u10);
        for (let c10 of l10)
          r10.indexOf(c10) === -1 && r10.push(c10);
      }
      return r10;
    }
  }
}
var Yo = class extends Ge {
  constructor(e) {
    super({ dtype: e.dtype, name: e.name != null ? e.name : Rp("input").toString() });
    if (e.batchSize == null && (e.batchSize = null), e.sparse == null && (e.sparse = false), this.trainable = false, this.built = true, this.sparse = e.sparse, e.inputShape != null && e.batchInputShape != null)
      throw new U2("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    let t = e.batchInputShape;
    if (t == null) {
      if (e.inputShape == null)
        throw new U2("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      t = [e.batchSize].concat(e.inputShape);
    } else if (e.batchSize != null)
      throw new U2("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
    let n10 = e.dtype || "float32";
    this.batchInputShape = t, this.dtype = n10, this.inputSpec = [{ shape: t }];
    let s10 = new $s(this.dtype, this.batchInputShape, this, [], {}, this.name);
    s10.nodeIndex = 0, s10.tensorIndex = 0, new Dp({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: [s10], outputTensors: [s10], inputMasks: [null], outputMasks: [null], inputShapes: [t], outputShapes: [t] });
  }
  apply(e, t) {
    throw new U2(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
  }
  dispose() {
    return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
  }
  getConfig() {
    return { batchInputShape: this.batchInputShape, dtype: this.dtype, sparse: this.sparse, name: this.name };
  }
};
Yo.className = "InputLayer";
ae2.registerClass(Yo);
function HI(e) {
  if (e.batchShape == null && e.shape == null)
    throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  if (e.batchShape != null && e.shape != null)
    throw new U2("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  let t = e.batchShape;
  e.shape != null && t == null && (t = [null].concat(e.shape));
  let n10 = e.dtype;
  return n10 == null && (n10 = "float32"), new Yo({ batchInputShape: t, name: e.name, dtype: n10, sparse: e.sparse }).inboundNodes[0].outputTensors[0];
}
async function rr(e) {
  if (e == null)
    return;
  let t = [], n10 = [], s10 = [];
  for (let r10 in e) {
    let a10 = e[r10];
    if (typeof a10 != "number") {
      let i10 = a10;
      t.push(i10.data()), n10.push(r10), s10.push(i10);
    }
  }
  if (t.length > 0) {
    let r10 = await Promise.all(t);
    for (let a10 = 0; a10 < r10.length; ++a10)
      e[n10[a10]] = r10[a10][0];
    Re2(s10);
  }
}
function qI(e) {
  if (e != null)
    for (let t in e) {
      let n10 = e[t];
      typeof n10 != "number" && n10.dispose();
    }
}
var NL = 125;
var Zi = class {
  constructor() {
    this.validationData = null;
  }
  setParams(e) {
    this.params = e;
  }
  async onEpochBegin(e, t) {
  }
  async onEpochEnd(e, t) {
  }
  async onBatchBegin(e, t) {
  }
  async onBatchEnd(e, t) {
  }
  async onTrainBegin(e) {
  }
  async onTrainEnd(e) {
  }
  setModel(e) {
  }
};
var TL = class {
  constructor(e, t = 10) {
    e == null && (e = []), this.callbacks = e, this.queueLength = t;
  }
  append(e) {
    this.callbacks.push(e);
  }
  setParams(e) {
    for (let t of this.callbacks)
      t.setParams(e);
  }
  setModel(e) {
    for (let t of this.callbacks)
      t.setModel(e);
  }
  async onEpochBegin(e, t) {
    t == null && (t = {});
    for (let n10 of this.callbacks)
      await n10.onEpochBegin(e, t);
  }
  async onEpochEnd(e, t) {
    t == null && (t = {});
    for (let n10 of this.callbacks)
      await n10.onEpochEnd(e, t);
  }
  async onBatchBegin(e, t) {
    t == null && (t = {});
    for (let n10 of this.callbacks)
      await n10.onBatchBegin(e, t);
  }
  async onBatchEnd(e, t) {
    t == null && (t = {});
    for (let n10 of this.callbacks)
      await n10.onBatchEnd(e, t);
  }
  async onTrainBegin(e) {
    e == null && (e = {});
    for (let t of this.callbacks)
      await t.onTrainBegin(e);
  }
  async onTrainEnd(e) {
    e == null && (e = {});
    for (let t of this.callbacks)
      await t.onTrainEnd(e);
  }
};
var $L = class extends Zi {
  constructor() {
    super();
  }
  async onEpochBegin(e) {
    this.seen = 0, this.totals = {};
  }
  async onBatchEnd(e, t) {
    t == null && (t = {});
    let n10 = t.size == null ? 0 : t.size;
    this.seen += n10;
    for (let s10 in t) {
      let r10 = t[s10];
      if (typeof r10 == "number")
        this.totals.hasOwnProperty(s10) || (this.totals[s10] = 0), this.totals[s10] = this.totals[s10] + r10 * n10;
      else {
        let a10;
        s10 in this.totals ? a10 = this.totals[s10] : this.totals[s10] = 0;
        let i10 = j2(() => ie2(this.totals[s10], V2(r10, n10)));
        this.totals[s10] = i10, a10 != null && a10.dispose();
      }
    }
  }
  async onEpochEnd(e, t) {
    if (t != null)
      for (let n10 of this.params.metrics)
        this.totals[n10] != null && (typeof this.totals[n10] == "number" ? t[n10] = this.totals[n10] / this.seen : j2(() => {
          let s10 = V2(xe2(1, this.seen), this.totals[n10]);
          t[n10] = s10, this.totals[n10].dispose(), Ht(t[n10]);
        }));
  }
};
var _L = class extends Zi {
  async onTrainBegin(e) {
    this.epoch = [], this.history = {};
  }
  async onEpochEnd(e, t) {
    t == null && (t = {}), this.epoch.push(e);
    for (let n10 in t)
      this.history[n10] == null && (this.history[n10] = []), this.history[n10].push(t[n10]);
  }
  async syncData() {
    let e = [], t = [], n10 = [];
    for (let r10 in this.history) {
      let a10 = this.history[r10];
      for (let i10 = 0; i10 < a10.length; ++i10)
        if (typeof a10[i10] != "number") {
          let o10 = a10[i10];
          e.push(o10.data()), t.push(r10), n10.push(i10);
        }
    }
    let s10 = await Promise.all(e);
    for (let r10 = 0; r10 < s10.length; ++r10)
      this.history[t[r10]][n10[r10]].dispose(), this.history[t[r10]][n10[r10]] = s10[r10][0];
  }
};
var AL = class extends Zi {
  constructor(e, t) {
    super();
    if (this.currentEpoch = 0, this.nowFunc = e.nowFunc, this.nextFrameFunc = e.nextFrameFunc || RO, this.yieldEvery = t || "auto", this.yieldEvery === "auto" && (this.yieldEvery = NL), this.yieldEvery === "never" && e.onYield != null)
      throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    w2.isNumber(this.yieldEvery) && (this.maybeWait = EM(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield;
  }
  async maybeWait(e, t, n10) {
    let s10 = [];
    this.yield != null && (await rr(n10), s10.push(this.yield(e, t, n10))), s10.push(this.nextFrameFunc()), await Promise.all(s10);
  }
  async onEpochBegin(e, t) {
    this.currentEpoch = e, this.epochBegin != null && (await rr(t), await this.epochBegin(e, t));
  }
  async onEpochEnd(e, t) {
    let n10 = [];
    this.epochEnd != null && (await rr(t), n10.push(this.epochEnd(e, t))), this.yieldEvery === "epoch" && n10.push(this.nextFrameFunc()), await Promise.all(n10);
  }
  async onBatchBegin(e, t) {
    this.batchBegin != null && (await rr(t), await this.batchBegin(e, t));
  }
  async onBatchEnd(e, t) {
    let n10 = [];
    this.batchEnd != null && (await rr(t), n10.push(this.batchEnd(e, t))), this.yieldEvery === "batch" ? n10.push(this.nextFrameFunc()) : w2.isNumber(this.yieldEvery) && n10.push(this.maybeWait(this.currentEpoch, e, t)), await Promise.all(n10);
  }
  async onTrainBegin(e) {
    this.trainBegin != null && (await rr(e), await this.trainBegin(e));
  }
  async onTrainEnd(e) {
    this.trainEnd != null && (await rr(e), await this.trainEnd(e));
  }
};
function jI(e, t) {
  return e == null && (e = {}), e instanceof Zi ? [e] : Array.isArray(e) && e[0] instanceof Zi ? e : dt(e).map((s10) => new AL(s10, t));
}
var ks = class {
  constructor() {
  }
  static registerCallbackConstructor(e, t) {
    w2.assert(e >= 0 && Number.isInteger(e), () => `Verbosity level is expected to be an integer >= 0, but got ${e}`), ks.checkForDuplicate(t), ks.constructors[e] == null && (ks.constructors[e] = []), ks.constructors[e].push(t);
  }
  static checkForDuplicate(e) {
    for (let t in ks.constructors)
      ks.constructors[+t].forEach((s10) => {
        if (s10 === e)
          throw new U2("Duplicate callback constructor.");
      });
  }
  static clear() {
    ks.constructors = {};
  }
  static createCallbacks(e) {
    let t = [];
    for (let n10 in ks.constructors) {
      let s10 = +n10;
      e >= s10 && t.push(...ks.constructors[s10]);
    }
    return t.map((n10) => new n10());
  }
};
var Ob = ks;
Ob.constructors = {};
function KI(e, t, n10, s10, r10, a10, i10, o10, u10) {
  let l10 = new _L(), c10 = [new $L(), ...Ob.createCallbacks(t)];
  e != null && c10.push(...e), c10.push(l10);
  let p10 = new TL(c10);
  return p10.setParams({ epochs: n10, initialEpoch: s10, samples: r10, steps: a10, batchSize: i10, verbose: t, doValidation: o10, metrics: u10 }), { callbackList: p10, history: l10 };
}
function fs(e, t = {}, n10 = false) {
  return zl(e, ae2.SerializationMap.getMap().classNameMap, t, "layer", n10);
}
function Cd(e, t) {
  return j2(() => {
    e.dtype !== "float32" && (e = ce2(e, "float32"));
    let n10 = ye2(Bl(e), t, true), s10 = Fl(n10.shape, Rt()), r10 = ln(Tr(n10, s10));
    return xe2(e, r10);
  });
}
function fi(e, t) {
  return j2(() => It(Bl(ge2(t, e)), -1));
}
function Fp(e, t) {
  return j2(() => It(Mt(ge2(t, e)), -1));
}
function Qo(e, t) {
  return j2(() => {
    let n10 = ge2(e, t), s10 = Bn(Mt(e), Rt(), Number.MAX_VALUE), r10 = Mt(xe2(n10, s10));
    return V2(100, It(r10, -1));
  });
}
function EL(e, t) {
  return j2(() => {
    let n10 = Bn(t, Rt(), Number.MAX_VALUE), s10 = Kn(ie2(1, n10)), r10 = Bn(e, Rt(), Number.MAX_VALUE), a10 = Kn(ie2(1, r10));
    return It(Bl(ge2(s10, a10)), -1);
  });
}
function RL(e, t) {
  return j2(() => {
    let n10 = Tr(0, ge2(1, V2(e, t)));
    return It(Bl(n10), -1);
  });
}
function DL(e, t) {
  return j2(() => {
    let n10 = Tr(0, ge2(1, V2(e, t)));
    return It(n10, -1);
  });
}
function FL(e, t) {
  return j2(() => {
    let n10 = ye2(V2(e, t), -1), s10 = As(V2(ge2(1, e), t), -1);
    return Tr(0, ie2(1, ge2(s10, n10)));
  });
}
function OL(e, t) {
  return j2(() => {
    let n10 = Math.log(2), s10 = ge2(t, e), r10 = ge2(ie2(s10, Ol(V2(-2, s10))), n10);
    return It(r10, -1);
  });
}
function Yu(e, t, n10 = false) {
  return j2(() => {
    if (n10)
      t = ib(t);
    else {
      let s10 = ye2(t, t.shape.length - 1, true);
      t = xe2(t, s10);
    }
    return t = Bn(t, Rt(), 1 - Rt()), kt(ye2(V2(ce2(e, "float32"), Kn(t)), t.shape.length - 1));
  });
}
function Nd(e, t, n10 = false) {
  return j2(() => {
    let s10 = ce2(fp(jM(e)), "int32");
    t = Bn(t, Rt(), 1 - Rt());
    let r10 = t.shape, a10 = G2(yd(s10, r10[r10.length - 1]), r10);
    return Yu(a10, t, n10);
  });
}
function PL(e, t) {
  if (!w2.arraysEqual(e.shape, t.shape))
    throw new U2(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);
  return j2(() => {
    let n10 = Xs(t), s10 = kt(Mt(t));
    return ie2(ge2(n10, V2(t, e)), Kg(jn(s10)));
  });
}
function Op(e, t) {
  return j2(() => {
    let n10;
    return n10 = Bn(t, Rt(), 1 - Rt()), n10 = Kn(xe2(n10, ge2(1, n10))), It(PL(e, n10), -1);
  });
}
function zL(e, t) {
  return j2(() => {
    let n10 = Bn(e, Rt(), 1), s10 = Bn(t, Rt(), 1);
    return ye2(V2(e, Kn(xe2(n10, s10))), -1);
  });
}
function ML(e, t) {
  return j2(() => {
    let n10 = Kn(ie2(Rt(), t));
    return It(ge2(t, V2(e, n10)), -1);
  });
}
function Pb(e, t) {
  return j2(() => {
    let n10 = Cd(e, -1), s10 = Cd(t, -1), r10 = V2(n10, s10);
    return kt(ye2(r10, -1));
  });
}
var Td = { meanSquaredError: fi, meanAbsoluteError: Fp, meanAbsolutePercentageError: Qo, meanSquaredLogarithmicError: EL, squaredHinge: RL, hinge: DL, categoricalHinge: FL, logcosh: OL, categoricalCrossentropy: Yu, sparseCategoricalCrossentropy: Nd, binaryCrossentropy: Op, kullbackLeiblerDivergence: zL, poisson: ML, cosineProximity: Pb };
function Bf(e) {
  if (typeof e == "string") {
    if (e in Td)
      return Td[e];
    let t = `Unknown loss ${e}`;
    throw e.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new U2(t);
  } else
    return e;
}
function zb(e, t) {
  return j2(() => {
    let n10 = V2(0.5, Xn(t)), s10 = Ip(Wn(t, n10), e.dtype);
    return It(qn(e, s10), -1);
  });
}
function Mb(e, t) {
  return j2(() => Ip(qn(Gu(e, -1), Gu(t, -1)), "float32"));
}
function XI(e, t) {
  return j2(() => ce2(ye2(Ds(qn(e, 1), qn(t, 1))), "float32"));
}
function LL(e, t) {
  return j2(() => ce2(ye2(Ds(qn(e, 1), qn(t, 0))), "float32"));
}
function BL(e, t) {
  return j2(() => ce2(ye2(Ds(qn(e, 0), qn(t, 1))), "float32"));
}
function YI(e, t) {
  return j2(() => {
    let n10 = XI(e, t), s10 = BL(e, t), r10 = ie2(n10, s10);
    return ce2(vn(Wn(r10, 0), xe2(n10, r10), 0), "float32");
  });
}
function VL(e, t) {
  return j2(() => {
    let n10 = XI(e, t), s10 = LL(e, t), r10 = ie2(n10, s10);
    return ce2(vn(Wn(r10, 0), xe2(n10, r10), 0), "float32");
  });
}
function QI(e, t) {
  return Op(e, t);
}
function ZI(e, t) {
  return e.rank === t.rank && (e = mr(e, [e.rank - 1])), t = Gu(t, -1), t.dtype !== e.dtype && (t = ce2(t, e.dtype)), ce2(qn(e, t), "float32");
}
var WL = fi;
var UL = fi;
var GL = Fp;
var HL = Fp;
var qL = Qo;
var jL = Qo;
var Lb = Yu;
var KL = Pb;
var JI = Nd;
var $d = { binaryAccuracy: zb, categoricalAccuracy: Mb, precision: YI, categoricalCrossentropy: Lb, sparseCategoricalCrossentropy: JI, mse: WL, MSE: UL, mae: GL, MAE: HL, mape: qL, MAPE: jL, cosine: KL };
function XL(e) {
  if (typeof e == "string" && e in $d)
    return $d[e];
  if (typeof e != "string" && e != null)
    return e;
  throw new U2(`Unknown metric ${e}`);
}
function Hc(e) {
  if (Cs(e !== null, `Unknown LossOrMetricFn ${e}`), typeof e == "string")
    return e;
  {
    let t;
    for (let n10 of Object.keys(Td))
      if (Td[n10] === e) {
        t = n10;
        break;
      }
    if (t !== void 0)
      return t;
    for (let n10 of Object.keys($d))
      if ($d[n10] === e) {
        t = n10;
        break;
      }
    return t !== void 0 ? t : e.name;
  }
}
function YL(e) {
  let t = { Adagrad: () => Fi.adagrad(0.01), Adadelta: () => Fi.adadelta(1, 0.95, Rt()), Adam: () => Fi.adam(1e-3, 0.9, 0.999, Rt()), Adamax: () => Fi.adamax(2e-3, 0.9, 0.999, Rt(), 0), RMSProp: () => Fi.rmsprop(1e-3, 0.9, 0, Rt()), SGD: () => Fi.sgd(0.01) };
  if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t)
    return t[e]();
  throw new U2(`Unknown Optimizer ${e}`);
}
var _x2 = 1 * 1024 * 1024;
function Ax(e, t, n10 = false) {
  if (e == null || typeof e != "object" || Object.getPrototypeOf(e) !== Object.prototype || !ym(e))
    throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
  if (n10) {
    let s10 = JSON.stringify(e);
    s10.length > _x2 && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s10.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${_x2}.`);
  }
}
function ym(e) {
  if (e === null)
    return true;
  if (typeof e == "object")
    if (Object.getPrototypeOf(e) === Object.prototype) {
      let t = Object.keys(e);
      for (let n10 of t)
        if (typeof n10 != "string" || !ym(e[n10]))
          return false;
      return true;
    } else if (Array.isArray(e)) {
      for (let t of e)
        if (!ym(t))
          return false;
      return true;
    } else
      return false;
  else {
    let t = typeof e;
    return t === "string" || t === "number" || t === "boolean";
  }
}
function QL(e, t, n10, s10 = console.log) {
  let r10 = JL(e), a10 = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
  r10 ? (t = t || 90, n10 = n10 || [0.32, 0.61, 0.89, 1]) : (t = t || 115, n10 = n10 || [0.24, 0.48, 0.7, 0.8, 1]), n10[n10.length - 1] <= 1 && (n10 = n10.map((c10) => Math.floor(t * c10)));
  let i10;
  if (!r10) {
    a10.push("Receives inputs"), i10 = [];
    for (let c10 in e.nodesByDepth)
      i10.push(...e.nodesByDepth[c10]);
  }
  s10("_".repeat(t)), _d(a10, n10, s10), s10("=".repeat(t));
  let o10 = e.layers;
  for (let c10 = 0; c10 < o10.length; ++c10)
    r10 ? eB(o10[c10], n10, s10) : tB(o10[c10], n10, i10, s10), s10((c10 === o10.length - 1 ? "=" : "_").repeat(t));
  e.checkTrainableWeightsConsistency();
  let u10 = ZL(e), l10 = Sd(e.nonTrainableWeights);
  s10(`Total params: ${u10 + l10}`), s10(`Trainable params: ${u10}`), s10(`Non-trainable params: ${l10}`), s10("_".repeat(t));
}
function ZL(e) {
  let t;
  return e.collectedTrainableWeights != null ? t = Sd(e.collectedTrainableWeights) : t = Sd(e.trainableWeights), t;
}
function JL(e) {
  let t = true, n10 = [], s10 = [];
  for (let r10 in e.nodesByDepth)
    n10.push(e.nodesByDepth[r10]);
  for (let r10 of n10) {
    if (r10.length > 1 || r10.length === 1 && r10[0].inboundLayers.length > 1) {
      t = false;
      break;
    }
    s10.push(...r10);
  }
  if (t)
    for (let r10 of e.layers) {
      let a10 = false;
      for (let i10 of r10.inboundNodes)
        if (s10.indexOf(i10) !== -1)
          if (a10) {
            t = false;
            break;
          } else
            a10 = true;
      if (!t)
        break;
    }
  return t;
}
function _d(e, t, n10 = console.log) {
  let s10 = "";
  for (let r10 = 0; r10 < e.length; ++r10)
    r10 > 0 && (s10 = s10.slice(0, s10.length - 1) + " "), s10 += e[r10], s10 = s10.slice(0, t[r10]), s10 += " ".repeat(t[r10] - s10.length);
  n10(s10);
}
function eB(e, t, n10) {
  let s10, r10;
  try {
    r10 = e.inboundNodes.map((u10) => JSON.stringify(u10.inputShapes)).join(",");
  } catch (u10) {
    r10 = "multiple";
  }
  try {
    s10 = JSON.stringify(e.outputShape);
  } catch (u10) {
    s10 = "multiple";
  }
  let a10 = e.name, i10 = e.getClassName(), o10 = [`${a10} (${i10})`, r10, s10, e.countParams().toString()];
  _d(o10, t, n10);
}
function tB(e, t, n10, s10) {
  let r10, a10;
  try {
    a10 = e.inboundNodes.map((p10) => JSON.stringify(p10.inputShapes)).join(",");
  } catch (p10) {
    a10 = "multiple";
  }
  try {
    r10 = JSON.stringify(e.outputShape);
  } catch (p10) {
    r10 = "multiple";
  }
  let i10 = [];
  for (let p10 of e.inboundNodes)
    if (!(n10 != null && n10.length > 0 && n10.indexOf(p10) === -1))
      for (let d10 = 0; d10 < p10.inboundLayers.length; ++d10) {
        let h10 = p10.inboundLayers[d10].name, f10 = p10.nodeIndices[d10], m10 = p10.tensorIndices[d10];
        i10.push(`${h10}[${f10}][${m10}]`);
      }
  let o10 = e.name, u10 = e.getClassName(), l10 = i10.length === 0 ? "" : i10[0], c10 = [`${o10} (${u10})`, a10, r10, e.countParams().toString(), l10];
  _d(c10, t, s10);
  for (let p10 = 1; p10 < i10.length; ++p10)
    _d(["", "", "", "", i10[p10]], t, s10);
}
function e0(e, t, n10) {
  return (e === "inboundNodes" || e === "outputLayers" || e === "inputLayers") && t === 0 && typeof n10 == "string";
}
function Qu(e, t) {
  if (e === null)
    return null;
  if (typeof e == "string")
    return qr(e);
  if (typeof e == "number" || typeof e == "boolean")
    return e;
  if (e instanceof Array) {
    let n10 = [], s10 = e.length;
    for (let r10 = 0; r10 < s10; ++r10) {
      let a10 = e[r10];
      e0(t, r10, a10) ? n10.push(a10) : n10.push(Qu(a10, t));
    }
    return n10;
  } else {
    let n10 = {};
    for (let s10 of Object.keys(e)) {
      let r10 = e[s10];
      if (s10 === "name" && typeof r10 == "string")
        n10[s10] = r10;
      else {
        let a10 = qr(s10);
        n10[a10] = Qu(r10, a10);
      }
    }
    return n10;
  }
}
function vm(e, t) {
  if (e == null)
    return null;
  if (typeof e == "string")
    return Ws(e);
  if (typeof e == "number" || typeof e == "boolean")
    return e;
  if (e instanceof Array) {
    let n10 = [], s10 = e.length;
    for (let r10 = 0; r10 < s10; ++r10) {
      let a10 = e[r10];
      e0(t, r10, a10) ? n10.push(a10) : n10.push(vm(a10, t));
    }
    return n10;
  } else {
    let n10 = {};
    for (let s10 of Object.keys(e)) {
      let r10 = e[s10], a10 = Ws(s10);
      (s10 === "name" || s10 === "className") && typeof r10 == "string" ? n10[a10] = r10 : n10[a10] = vm(r10, s10);
    }
    return n10;
  }
}
var t0 = "0.0.0";
function nB(e, t) {
  if (e.dtype == null || e.dtype === t.dtype)
    return t;
  try {
    return ce2(t, e.dtype);
  } catch (n10) {
    throw new U2(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`);
  }
}
var Xr = class {
  constructor(e) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof Xr)
      for (let t in e.id2Value)
        this.id2Value[t] = e.id2Value[t], t in e.id2Mask && (this.id2Mask[t] = e.id2Mask[t]);
    else {
      if (e == null)
        return;
      for (let t of e)
        this.add(t.key, t.value);
    }
  }
  add(e, t, n10) {
    if (this.id2Value[e.id] == null)
      this.id2Value[e.id] = nB(e, t), this.name2Id[e.name] = e.id, n10 != null && (this.id2Mask[e.id] = n10);
    else
      throw new U2(`Duplicate key: name=${e.name}, id=${e.id}`);
    return this;
  }
  addFeed(e) {
    this.add(e.key, e.value);
  }
  hasKey(e) {
    return this.id2Value[e.id] != null;
  }
  names() {
    return Object.keys(this.name2Id);
  }
  getValue(e) {
    if (e instanceof $s) {
      if (this.id2Value[e.id] == null)
        throw new U2(`Nonexistent key: ${e.name}`);
      return this.id2Value[e.id];
    } else {
      let t = this.name2Id[e];
      if (t == null)
        throw new U2(`Feed dict has no SymbolicTensor name: ${e}`);
      return this.id2Value[t];
    }
  }
  getMask(e) {
    if (e instanceof $s) {
      if (this.id2Value[e.id] == null)
        throw new U2(`Nonexistent key: ${e.name}`);
      return this.id2Mask[e.id];
    } else {
      let t = this.name2Id[e];
      if (t == null)
        throw new U2(`Feed dict has no SymbolicTensor name: ${e}`);
      return this.id2Mask[t];
    }
  }
  disposeMasks() {
    this.id2Mask != null && Re2(this.id2Mask);
  }
};
var Vf = {};
var Ex = {};
function _u(e, t, n10, s10) {
  let r10 = n10 == null ? false : n10.training, a10 = Array.isArray(e), i10 = a10 ? e : [e], o10 = i10.map((f10) => f10.name), u10 = [], l10 = t.names();
  for (let f10 of o10)
    l10.indexOf(f10) !== -1 ? u10.push(t.getValue(f10)) : u10.push(null);
  s10 != null && (s10.maxNumTensors = -1 / 0, s10.minNumTensors = 1 / 0);
  let c10 = o10.join(",") + "|" + t.names().join(","), p10, d10;
  if (Vf[c10] == null) {
    let f10 = sB(i10, t);
    p10 = f10.sorted, d10 = f10.recipientCounts, Vf[c10] = p10, Ex[c10] = d10;
  }
  p10 = Vf[c10], d10 = {}, r10 || Object.assign(d10, Ex[c10]);
  let h10 = new Xr(t);
  for (let f10 = 0; f10 < p10.length; ++f10) {
    if (s10 != null) {
      let A10 = lm().numTensors;
      A10 > s10.maxNumTensors && (s10.maxNumTensors = A10), A10 < s10.minNumTensors && (s10.minNumTensors = A10);
    }
    let m10 = p10[f10], g10 = m10.sourceLayer;
    if (g10 instanceof Yo)
      continue;
    let b10 = [], y10 = [], v10 = [], x10 = false;
    for (let A10 of m10.inputs) {
      let P10 = h10.getValue(A10), R10 = h10.getMask(A10);
      b10.push(P10), y10.push(R10), R10 != null && (x10 = true), r10 || (d10[A10.name]--, d10[A10.name] === 0 && !t.hasKey(A10) && o10.indexOf(A10.name) === -1 && !P10.isDisposed && A10.sourceLayer.stateful !== true && v10.push(P10));
    }
    x10 && (n10 = n10 || {}, n10.mask = y10[0]);
    let k10 = dt(g10.apply(b10, n10)), C10 = null;
    g10.supportsMasking && (C10 = g10.computeMask(b10, y10));
    let T10 = aB(m10), E10 = Array.isArray(T10) ? T10 : [T10];
    for (let A10 = 0; A10 < E10.length; ++A10) {
      h10.hasKey(E10[A10]) || h10.add(E10[A10], k10[A10], Array.isArray(C10) ? C10[0] : C10);
      let P10 = o10.indexOf(E10[A10].name);
      P10 !== -1 && (u10[P10] = k10[A10]);
    }
    r10 || Re2(v10);
  }
  return h10.disposeMasks(), a10 ? u10 : u10[0];
}
function sB(e, t) {
  w2.assert(e != null && e.length > 0, () => "Expected at least one fetch, got none");
  let n10 = [], s10 = {};
  if (e.length === 1) {
    let r10 = Rx(e[0], t);
    n10 = r10.sorted, s10 = r10.recipientMap;
  } else {
    let r10 = /* @__PURE__ */ new Set();
    for (let a10 of e) {
      let { sorted: i10, recipientMap: o10 } = Rx(a10, t);
      for (let u10 of i10)
        r10.has(u10.name) || (n10.push(u10), r10.add(u10.name));
      for (let u10 in o10)
        s10[u10] == null && (s10[u10] = /* @__PURE__ */ new Set()), o10[u10].forEach((l10) => s10[u10].add(l10));
    }
  }
  return { sorted: n10, recipientCounts: rB(s10) };
}
function rB(e) {
  let t = {};
  for (let n10 in e)
    t[n10] = e[n10].size;
  return t;
}
function Rx(e, t) {
  let n10 = /* @__PURE__ */ new Set(), s10 = [], r10 = {};
  for (let o10 of t.names())
    n10.add(o10);
  let a10 = [], i10 = [];
  for (a10.push(e); a10.length > 0; ) {
    let o10 = a10[a10.length - 1];
    if (n10.has(o10.name)) {
      a10.pop();
      continue;
    }
    let u10 = i10[i10.length - 1] === a10.length - 1;
    if (o10.inputs.length === 0 || u10)
      a10.pop(), s10.push(o10), n10.add(o10.name), u10 && i10.pop();
    else {
      i10.push(a10.length - 1);
      for (let l10 of o10.inputs)
        r10[l10.name] == null && (r10[l10.name] = /* @__PURE__ */ new Set()), r10[l10.name].add(o10.name), !n10.has(l10.name) && a10.push(l10);
    }
  }
  return { sorted: s10, recipientMap: r10 };
}
function aB(e) {
  let t;
  if (e.sourceLayer.inboundNodes.length === 1)
    t = e.sourceLayer.output;
  else {
    let n10 = null;
    for (let s10 = 0; s10 < e.sourceLayer.inboundNodes.length; ++s10)
      for (let r10 of e.sourceLayer.inboundNodes[s10].outputTensors)
        if (r10.id === e.id) {
          n10 = s10;
          break;
        }
    t = e.sourceLayer.getOutputAt(n10);
  }
  return t;
}
var Is = class extends Ge {
  constructor(e) {
    super({});
    if (this.containerNodes = /* @__PURE__ */ new Set(), this.name = e.name, this.name == null) {
      let b10 = this.getClassName().toLowerCase();
      this.name = Rp(b10);
    }
    if (this.supportsMasking = false, this.trainable_ = true, Array.isArray(e.inputs) ? this.inputs = e.inputs.slice() : this.inputs = [e.inputs], Array.isArray(e.outputs) ? this.outputs = e.outputs.slice() : this.outputs = [e.outputs], cr(this.inputs).length !== this.inputs.length)
      throw new U2(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((b10) => b10.name)}`);
    cr(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((b10) => b10.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
    for (let b10 of this.outputs) {
      let y10 = b10.sourceLayer, v10 = b10.nodeIndex, x10 = b10.tensorIndex;
      this.outputLayers.push(y10), this.outputLayersNodeIndices.push(v10), this.outputLayersTensorIndices.push(x10);
    }
    for (let b10 of this.inputs) {
      let y10 = b10.sourceLayer, v10 = b10.nodeIndex, x10 = b10.tensorIndex;
      Cs(v10 === 0, "input layer has >1 nodes"), Cs(x10 === 0, "input layer has >1 tensors"), this.inputLayers.push(y10), this.inputLayersNodeIndices.push(v10), this.inputLayersTensorIndices.push(x10);
    }
    this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
    for (let b10 = 0; b10 < this.inputLayers.length; b10++) {
      let y10 = this.inputLayers[b10];
      if (!(y10 instanceof Yo))
        throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b10} (0-based) originates from layer type ${y10.getClassName()}.`);
      this.inputNames.push(y10.name), this.feedInputShapes.push(y10.batchInputShape), this.feedInputNames.push(y10.name);
    }
    for (let b10 of this.outputLayers)
      this.outputNames.push(b10.name);
    this.internalInputShapes = this.inputs.map((b10) => b10.shape), this.internalOutputShapes = this.outputs.map((b10) => b10.shape);
    let t = {}, n10 = {}, s10 = {}, r10 = {}, a10 = {}, i10 = [], o10 = (b10, y10, v10, x10, k10, C10) => {
      (x10 == null || k10 == null || C10 == null) && (x10 = b10.sourceLayer, k10 = b10.nodeIndex, C10 = b10.tensorIndex);
      let T10 = x10.inboundNodes[k10];
      if (v10.indexOf(T10) !== -1)
        throw new ps(`The tensor ${b10.name} at layer "${x10.name}" is part of a cycle.`);
      if (y10.indexOf(T10) !== -1)
        return;
      this.containerNodes.add(Is.nodeKey(x10, k10)), x10.id in a10 || (a10[x10.id] = Object.keys(a10).length), v10.indexOf(T10) === -1 && v10.push(T10);
      let E10 = T10.inboundLayers.length;
      for (let A10 = 0; A10 < E10; A10++) {
        let P10 = T10.inputTensors[A10], R10 = T10.inboundLayers[A10], F10 = T10.nodeIndices[A10], $10 = T10.tensorIndices[A10];
        o10(P10, y10, v10, R10, F10, $10);
      }
      for (y10.push(T10); v10.indexOf(T10) >= 0; )
        v10.splice(v10.indexOf(T10), 1);
      i10.push(T10);
    }, u10 = [], l10 = [];
    for (let b10 of this.outputs)
      o10(b10, u10, l10);
    let c10 = i10.slice().reverse();
    for (let b10 of c10) {
      n10[b10.id] = b10, b10.id in t || (t[b10.id] = 0);
      let y10 = t[b10.id], v10 = s10[b10.outboundLayer.id] == null ? 0 : s10[b10.outboundLayer.id];
      y10 = Math.max(y10, v10), s10[b10.outboundLayer.id] = y10, r10[b10.outboundLayer.id] = b10.outboundLayer, t[b10.id] = y10;
      for (let x10 = 0; x10 < b10.inboundLayers.length; x10++) {
        let k10 = b10.inboundLayers[x10], C10 = b10.nodeIndices[x10], T10 = k10.inboundNodes[C10], E10 = t[T10.id] == null ? 0 : t[T10.id];
        t[T10.id] = Math.max(y10 + 1, E10), n10[T10.id] = T10;
      }
    }
    let p10 = {};
    for (let b10 in t) {
      let y10 = t[b10];
      y10 in p10 || (p10[y10] = []), p10[y10].push(n10[b10]);
    }
    let d10 = {};
    for (let b10 in s10) {
      let y10 = s10[b10];
      y10 in d10 || (d10[y10] = []), d10[y10].push(r10[b10]);
    }
    let h10 = Object.keys(d10).map((b10) => parseInt(b10, 10)).sort(Wc);
    this.layers = [];
    for (let b10 of h10) {
      let y10 = d10[b10];
      y10.sort((v10, x10) => {
        let k10 = a10[v10.id], C10 = a10[x10.id];
        return k10 < C10 ? -1 : k10 > C10 ? 1 : 0;
      });
      for (let v10 of y10)
        v10 instanceof Is && this.internalContainerRefs.push(v10), this.layers.push(v10);
    }
    this.layersByDepth = d10, h10 = Object.keys(p10).map((b10) => parseInt(b10, 10)).sort(Wc);
    let f10 = this.inputs.slice(), m10 = [];
    for (let b10 of h10)
      for (let y10 of p10[b10]) {
        let v10 = y10.outboundLayer;
        if (v10 != null) {
          for (let x10 of y10.inputTensors)
            if (f10.indexOf(x10) === -1)
              throw new ps(`Graph disconnected: cannot obtain value for tensor ${x10} at layer "${v10.name}". The following previous layers were accessed without issue: ${m10}`);
          for (let x10 of y10.outputTensors)
            f10.push(x10);
          m10.push(v10.name);
        }
      }
    this.nodesByDepth = p10;
    let g10 = this.layers.map((b10) => b10.name);
    for (let b10 of g10) {
      let y10 = g10.filter((v10) => v10 === b10).length;
      if (y10 !== 1)
        throw new ps(`The name "${b10}" is used ${y10} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(g10));
    }
    this.outboundNodes = [], this.inboundNodes = [], new Dp({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: this.inputs.map((b10) => null), outputMasks: this.outputs.map((b10) => null), inputShapes: this.inputs.map((b10) => b10.shape), outputShapes: this.outputs.map((b10) => b10.shape) }), this.built = true, this._refCount = 1;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Container '${this.name}' is already disposed.`);
  }
  dispose() {
    this.assertNotDisposed();
    let e = { refCountAfterDispose: null, numDisposedVariables: 0 };
    if (--this._refCount === 0) {
      for (let t of this.layers)
        e.numDisposedVariables += t.dispose().numDisposedVariables;
      for (let t of this.internalContainerRefs)
        e.numDisposedVariables += t.dispose().numDisposedVariables;
    }
    return e.refCountAfterDispose = this._refCount, e;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this.layers.forEach((t) => {
      t._trainableWeights.forEach((n10) => n10.trainable = e);
    }), this.trainable_ = e;
  }
  get trainableWeights() {
    if (this._trainableWeights.length > 0)
      throw new U2("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    if (!this.trainable)
      return [];
    let e = [];
    for (let t of this.layers)
      e = e.concat(t.trainableWeights);
    return e;
  }
  get nonTrainableWeights() {
    let e = [];
    for (let t of this.layers)
      e.push(...t.nonTrainableWeights);
    if (!this.trainable) {
      let t = [];
      for (let n10 of this.layers)
        t.push(...n10.trainableWeights);
      return t.concat(e);
    }
    return e;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  loadWeights(e, t = true) {
    let n10 = {}, s10 = 0;
    for (let a10 of this.layers)
      for (let i10 of a10.weights) {
        if (n10[i10.originalName] != null)
          throw new U2(`Duplicate weight name: ${i10.originalName}`);
        n10[i10.originalName] = i10, s10++;
      }
    let r10 = [];
    for (let a10 in e) {
      let i10 = a10;
      if (n10[a10] == null) {
        let o10 = a10.split("/");
        i10 = o10.slice(0, -2).concat([o10[o10.length - 1]]).join("/");
      }
      if (n10[i10] != null)
        r10.push([n10[i10], e[a10]]);
      else if (t)
        throw new U2(`Provided weight data has no target variable: ${a10}`);
      delete n10[i10];
    }
    if (t) {
      let a10 = [];
      for (let i10 in n10)
        a10.push(i10);
      if (a10.length > 0)
        throw new U2(`${a10.length} of ${s10} weights are not set: ${a10}`);
    }
    Fb(r10);
  }
  updatedConfig() {
    let e = this.getConfig(), t = {};
    return t.className = this.getClassName(), t.config = e, t.kerasVersion = `tfjs-layers ${t0}`, t.backend = "TensorFlow.js", t;
  }
  toJSON(e, t = true) {
    let n10 = vm(this.updatedConfig());
    return t ? JSON.stringify(n10) : n10;
  }
  call(e, t) {
    return j2(() => {
      e = dt(e);
      let n10 = new Xr();
      for (let s10 = 0; s10 < this.inputs.length; ++s10)
        n10.add(this.inputs[s10], e[s10]);
      return _u(this.outputs, n10, t);
    });
  }
  computeMask(e, t) {
    return j2(() => {
      e = dt(e);
      let n10;
      return t == null ? n10 = pa(null, e.length) : n10 = dt(t), this.runInternalGraph(e, n10)[1];
    });
  }
  computeOutputShape(e) {
    let t = Id(e);
    if (t.length !== this.inputLayers.length)
      throw new U2(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);
    let n10 = {};
    for (let i10 = 0; i10 < t.length; i10++) {
      let o10 = this.inputLayers[i10], u10 = t[i10], l10 = o10.name + "_0_0";
      n10[l10] = u10;
    }
    let s10 = Object.keys(this.nodesByDepth).map((i10) => parseInt(i10, 10)).sort(Wc);
    if (s10.length > 1)
      for (let i10 of s10) {
        let o10 = this.nodesByDepth[i10];
        for (let u10 of o10) {
          let l10 = u10.outboundLayer;
          if (this.inputLayers.map((f10) => f10.id).indexOf(l10.id) !== -1)
            continue;
          let c10 = [];
          for (let f10 = 0; f10 < u10.inboundLayers.length; f10++) {
            let m10 = u10.inboundLayers[f10], g10 = u10.nodeIndices[f10], b10 = u10.tensorIndices[f10], y10 = `${m10.name}_${g10}_${b10}`, v10 = n10[y10];
            c10.push(v10);
          }
          let p10 = l10.computeOutputShape(gn(c10)), d10 = Id(p10), h10 = l10.inboundNodes.indexOf(u10);
          for (let f10 = 0; f10 < d10.length; f10++) {
            let m10 = `${l10.name}_${h10}_${f10}`;
            n10[m10] = d10[f10];
          }
        }
      }
    let r10 = [], a10 = [];
    for (let i10 = 0; i10 < this.outputLayers.length; i10++) {
      let o10 = this.outputLayers[i10], u10 = this.outputLayersNodeIndices[i10], l10 = this.outputLayersTensorIndices[i10], c10 = `${o10.name}_${u10}_${l10}`;
      a10.push(c10);
    }
    for (let i10 = 0; i10 < a10.length; i10++) {
      let o10 = a10[i10];
      Cs(o10 in n10), r10.push(n10[o10]);
    }
    return gn(r10);
  }
  runInternalGraph(e, t) {
    t == null && (t = pa(null, e.length));
    let n10 = {};
    for (let o10 = 0; o10 < this.inputs.length; ++o10) {
      let u10 = this.inputs[o10], l10 = e[o10], c10 = t[o10];
      n10[u10.id] = [l10, c10];
    }
    let s10 = Object.keys(this.nodesByDepth).map((o10) => parseInt(o10, 10)).sort(Wc);
    for (let o10 of s10) {
      let u10 = this.nodesByDepth[o10];
      for (let l10 of u10) {
        let c10 = l10.outboundLayer, p10 = l10.inputTensors, d10 = l10.outputTensors, h10 = new Array();
        for (let f10 of p10)
          f10.id in n10 && h10.push(n10[f10.id]);
        if (h10.length === p10.length) {
          let f10 = {}, m10, g10, b10, y10;
          if (l10.callArgs != null && (f10 = l10.callArgs), h10.length === 1) {
            let [v10, x10] = h10[0];
            f10.mask == null && (f10.mask = x10), b10 = dt(c10.call(v10, f10)), y10 = dt(c10.computeMask(v10, x10)), m10 = [v10], g10 = [x10];
          } else
            m10 = h10.map((v10) => v10[0]), g10 = h10.map((v10) => v10[1]), f10.mask == null && (f10.mask = g10), b10 = dt(c10.call(m10, f10)), y10 = dt(c10.computeMask(m10, g10));
          if (c10.activityRegularizer)
            throw new Fe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
          for (let v10 = 0; v10 < d10.length; ++v10) {
            let x10 = d10[v10], k10 = b10[v10], C10 = y10[v10];
            n10[x10.id] = [k10, C10];
          }
        }
      }
    }
    let r10 = [], a10 = [], i10 = [];
    for (let o10 of this.outputs) {
      Cs(o10.id in n10, `Could not compute output ${o10.name} : ${o10.id}`);
      let [u10, l10] = n10[o10.id];
      i10.push(u10.shape), r10.push(u10), a10.push(l10);
    }
    return [r10, a10, i10];
  }
  buildNodeConversionMap(e) {
    let t = {}, n10;
    for (let s10 of this.layers) {
      n10 = s10 instanceof Is ? 1 : 0;
      for (let r10 = 0; r10 < s10.inboundNodes.length; r10++) {
        let a10 = Is.nodeKey(s10, r10);
        this.containerNodes.has(a10) && (t[a10] = n10, n10 += 1);
      }
    }
    return t;
  }
  getLayer(e, t) {
    if (t != null) {
      if (this.layers.length <= t)
        throw new U2(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);
      return this.layers[t];
    } else if (e == null)
      throw new U2("Provide either a layer name or layer index");
    for (let n10 of this.layers)
      if (n10.name === e)
        return n10;
    throw new U2(`No such layer: ${e}`);
  }
  calculateLosses() {
    return j2(() => {
      let e = [];
      for (let t of this.layers)
        for (let n10 = 0; n10 < t.inboundNodes.length; ++n10) {
          let s10 = Is.nodeKey(t, n10);
          this.containerNodes.has(s10) && e.push(...t.calculateLosses());
        }
      return e;
    });
  }
  getConfig() {
    let e = { name: this.name }, t = this.buildNodeConversionMap(this.layers), n10 = [];
    for (let a10 of this.layers) {
      let i10 = a10.getClassName(), o10 = a10.getConfig(), u10 = [];
      for (let c10 = 0; c10 < a10.inboundNodes.length; c10++) {
        let p10 = a10.inboundNodes[c10], d10 = Is.nodeKey(a10, c10), h10 = {};
        if (this.containerNodes.has(d10)) {
          if (p10.callArgs)
            try {
              JSON.stringify(p10.callArgs), h10 = p10.callArgs;
            } catch (f10) {
              console.warn(`Layer ${a10.name} was passed non-serializable keyword arguments: ${p10.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), h10 = {};
            }
          if (p10.inboundLayers.length > 0) {
            let f10 = [];
            for (let m10 = 0; m10 < p10.inboundLayers.length; m10++) {
              let g10 = p10.inboundLayers[m10], b10 = p10.nodeIndices[m10], y10 = p10.tensorIndices[m10], v10 = Is.nodeKey(g10, b10), x10 = t[v10];
              x10 == null && (x10 = 0), f10.push([g10.name, x10, y10, h10]);
            }
            u10.push(f10);
          }
        }
      }
      let l10 = {};
      l10.name = a10.name, l10.className = i10, l10.config = o10, l10.inboundNodes = u10, n10.push(l10);
    }
    e.layers = n10;
    let s10 = [];
    for (let a10 = 0; a10 < this.inputLayers.length; a10++) {
      let i10 = this.inputLayers[a10], o10 = this.inputLayersNodeIndices[a10], u10 = Is.nodeKey(i10, o10);
      if (!this.containerNodes.has(u10))
        continue;
      let l10 = t[u10];
      l10 == null && (l10 = 0);
      let c10 = this.inputLayersTensorIndices[a10];
      s10.push([i10.name, l10, c10]);
    }
    e.inputLayers = s10;
    let r10 = [];
    for (let a10 = 0; a10 < this.outputLayers.length; a10++) {
      let i10 = this.outputLayers[a10], o10 = this.outputLayersNodeIndices[a10], u10 = Is.nodeKey(i10, o10);
      if (!this.containerNodes.has(u10))
        continue;
      let l10 = t[u10];
      l10 == null && (l10 = 0);
      let c10 = this.outputLayersTensorIndices[a10];
      r10.push([i10.name, l10, c10]);
    }
    return e.outputLayers = r10, e;
  }
  static fromConfig(e, t, n10 = {}, s10 = false) {
    let r10 = {}, a10 = {};
    function i10(m10, g10) {
      m10.name in a10 ? a10[m10.name].push(g10) : a10[m10.name] = [g10];
    }
    function o10(m10, g10) {
      let b10 = [], y10;
      for (let v10 of g10) {
        let x10 = v10[0], k10 = v10[1], C10 = v10[2];
        if (y10 = v10[3] == null ? {} : v10[3], !(x10 in r10)) {
          i10(m10, g10);
          return;
        }
        let T10 = r10[x10];
        if (T10.inboundNodes.length <= k10) {
          i10(m10, g10);
          return;
        }
        let E10 = T10.inboundNodes[k10];
        b10.push(E10.outputTensors[C10]);
      }
      b10.length > 0 && m10.apply(gn(b10), y10);
    }
    function u10(m10) {
      let g10 = m10.name, b10 = fs(m10, t.customObjects != null ? t.customObjects : {});
      b10.setFastWeightInitDuringBuild(s10), r10[g10] = b10, m10.inboundNodes.forEach((v10) => {
        if (!(v10 instanceof Array))
          throw new U2(`Corrupted configuration, expected array for nodeData: ${v10}`);
        i10(b10, v10);
      });
    }
    let l10 = t.name, c10 = t.layers;
    for (let m10 of c10)
      u10(m10);
    for (; !AM(a10); )
      for (let m10 of c10) {
        let g10 = r10[m10.name];
        if (g10.name in a10) {
          let b10 = a10[g10.name];
          delete a10[g10.name];
          for (let y10 of b10)
            o10(g10, y10);
        }
      }
    let p10 = [], d10 = [], h10 = t.inputLayers;
    for (let m10 of h10) {
      let g10 = m10[0], b10 = m10[1], y10 = m10[2];
      Cs(g10 in r10);
      let x10 = r10[g10].inboundNodes[b10].outputTensors;
      p10.push(x10[y10]);
    }
    let f10 = t.outputLayers;
    for (let m10 of f10) {
      let g10 = m10[0], b10 = m10[1], y10 = m10[2];
      Cs(g10 in r10);
      let x10 = r10[g10].inboundNodes[b10].outputTensors;
      d10.push(x10[y10]);
    }
    return new e({ inputs: p10, outputs: d10, name: l10 });
  }
  get stateful() {
    if (this._stateful)
      throw new U2("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
    for (let e of this.layers)
      if (e.stateful)
        return true;
    return false;
  }
  resetStates() {
    j2(() => {
      this.layers.forEach((e) => {
        e.stateful && e.resetStates();
      });
    });
  }
};
function iB(e, t, n10) {
  let s10 = t.length;
  if (e == null || Array.isArray(e) && e.length === 0)
    return t.map((r10) => null);
  if (s10 === 1)
    return Array.isArray(e) && e.length === 1 ? e : typeof e == "object" && t[0] in e ? [e[t[0]]] : [e];
  if (Array.isArray(e)) {
    if (e.length !== s10)
      throw new Error(`Provided ${n10} is an array of ${e.length} element(s), but the model has ${s10} outputs. Make sure a set of weights is provided for each model output.`);
    return e;
  } else if (typeof e == "object" && Object.keys(e).length > 0 && typeof e[Object.keys(e)[0]] == "object") {
    let r10 = [];
    return t.forEach((a10) => {
      a10 in e ? r10.push(e[a10]) : r10.push(null);
    }), r10;
  } else
    throw new Error(`The model has multiple (${s10}) outputs, so ${n10} must be either an array with ${s10} elements or an object with ${t} keys. Provided ${n10} not understood: ${JSON.stringify(e)}`);
}
function n0(e, t) {
  return iB(e, t, "classWeight");
}
async function s0(e, t, n10, s10) {
  if (t != null || s10 != null)
    throw new Error("Support sampleWeight is not implemented yet");
  if (n10 != null) {
    let r10 = j2(() => {
      if (e.shape.length === 1)
        return lr(e);
      if (e.shape.length === 2) {
        if (e.shape[1] > 1)
          return Gu(e, 1);
        if (e.shape[1] === 1)
          return G2(e, [e.shape[0]]);
        throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
      } else
        throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
    }), a10 = Array.from(await r10.data());
    Re2(r10);
    let i10 = [];
    return a10.forEach((o10) => {
      if (n10[o10] == null)
        throw new Error(`classWeight must contain all classes in the training data. The class ${o10} exists in the data but not in classWeight`);
      i10.push(n10[o10]);
    }), Qt(i10, "float32");
  } else
    return null;
}
function oB(e, t) {
  return V2(e, t);
}
var uB = 32;
function r0(e, t) {
  let n10, s10, r10 = t;
  n10 = r10.xs, s10 = r10.ys, w2.assert(n10 != null && s10 != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);
  let a10 = Dx("input", e.inputNames, n10), i10 = Dx("output", e.outputNames, s10), o10 = a10[0].shape[0];
  w2.assert(a10.length === e.inputs.length, () => `LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a10.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`), w2.assert(i10.length === e.outputs.length, () => `LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i10.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);
  for (let u10 = 0; u10 < a10.length; u10++)
    w2.assert(a10[u10].shape[0] === o10, () => `Batch size mismatch: input ${e.inputNames[u10]} has ${a10[u10].shape[0]}; expected  ${o10} based on input ${e.inputNames[0]}.`);
  for (let u10 = 0; u10 < i10.length; u10++)
    w2.assert(i10[u10].shape[0] === o10, () => `Batch size mismatch: output ${e.outputNames[u10]} has ${i10[u10].shape[0]}; expected  ${o10} based on input ${e.inputNames[0]}.`);
  return { xs: a10, ys: i10 };
}
function Dx(e, t, n10) {
  if (n10 instanceof et)
    return [n10];
  if (Array.isArray(n10))
    return w2.assert(n10.length === t.length, () => `Received an array of ${n10.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`), n10;
  {
    let s10 = [];
    for (let r10 of t) {
      if (n10[r10] == null)
        throw new U2(`The feature data generated by the dataset lacks the required ${e} key '${r10}'.`);
      s10.push(n10[r10]);
    }
    return s10;
  }
}
function lB(e) {
  if (e.length === 3)
    throw new Fe("Validation with sample weights is not implemented yet.");
  return { xs: e[0], ys: e[1] };
}
async function cB(e, t, n10) {
  let s10 = n10.batchesPerEpoch != null;
  if (w2.assert(e.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), w2.assert(n10 != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), w2.assert(n10.epochs != null && n10.epochs > 0 && Number.isInteger(n10.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${n10.epochs}`), w2.assert(!s10 || n10.batchesPerEpoch > 0 && Number.isInteger(n10.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n10.batchesPerEpoch}`), w2.assert(n10.validationSplit == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), e.isTraining)
    throw new Error("Cannot start training because another fit() call is ongoing.");
  e.isTraining = true;
  try {
    let r10 = n10.validationData != null, a10, i10;
    if (r10)
      if (Fx(n10.validationData))
        w2.assert(n10.validationBatches == null || n10.validationBatches > 0 && Number.isInteger(n10.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n10.validationBatches}`);
      else {
        let g10 = lB(n10.validationData);
        a10 = g10.xs, i10 = g10.ys;
      }
    let o10 = e.makeTrainFunction(), u10 = e.getDedupedMetricsNames(), l10;
    r10 ? l10 = u10.slice().concat(u10.map((g10) => "val_" + g10)) : l10 = u10.slice();
    let c10 = jI(n10.callbacks, n10.yieldEvery), p10 = n10.verbose == null ? 1 : n10.verbose, { callbackList: d10, history: h10 } = KI(c10, p10, n10.epochs, null, null, dB(t, n10), null, r10, l10);
    d10.setModel(e), e.history = h10, await d10.onTrainBegin(), e.stopTraining_ = false;
    let f10 = n10.initialEpoch == null ? 0 : n10.initialEpoch, m10 = await t.iterator();
    for (; f10 < n10.epochs; ) {
      let g10 = {};
      await d10.onEpochBegin(f10);
      let b10 = 0, y10 = 0;
      for (s10 || (m10 = await t.iterator()); !s10 || b10 < n10.batchesPerEpoch; ) {
        let v10 = await m10.next();
        if (s10 && v10.done) {
          console.warn(`You provided \`batchesPerEpoch\` as ${n10.batchesPerEpoch}, but your dataset iterator ran out of data after ${b10} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n10.batchesPerEpoch * n10.epochs} batches). You may need to use the repeat() function when building your dataset.`);
          break;
        }
        if (v10.value != null) {
          let { xs: x10, ys: k10 } = r0(e, v10.value), C10 = {};
          C10.batch = y10, C10.size = x10[0].shape[0], await d10.onBatchBegin(y10, C10);
          let T10 = [];
          if (n10.classWeight != null) {
            let P10 = n0(n10.classWeight, e.outputNames);
            for (let R10 = 0; R10 < P10.length; ++R10)
              T10.push(await s0(k10[R10], null, P10[R10]));
          }
          let E10 = x10.concat(k10).concat(T10), A10 = o10(E10);
          Re2(E10);
          for (let P10 = 0; P10 < u10.length; ++P10) {
            let R10 = u10[P10], F10 = A10[P10];
            C10[R10] = F10, Ht(F10);
          }
          await d10.onBatchEnd(y10, C10), qI(C10), y10++, b10++;
        }
        if (s10 ? b10 >= n10.batchesPerEpoch : v10.done) {
          if (r10) {
            let x10;
            Fx(n10.validationData) ? x10 = dt(await e.evaluateDataset(n10.validationData, { batches: n10.validationBatches })) : x10 = dt(e.evaluate(a10, i10, { batchSize: n10.validationBatchSize == null ? uB : n10.validationBatchSize, verbose: 0 }));
            for (let k10 = 0; k10 < e.metricsNames.length; ++k10)
              g10[`val_${e.metricsNames[k10]}`] = x10[k10];
          }
          break;
        }
        if (e.stopTraining_)
          break;
      }
      if (await d10.onEpochEnd(f10, g10), f10++, e.stopTraining_)
        break;
    }
    return await d10.onTrainEnd(), await e.history.syncData(), e.history;
  } finally {
    e.isTraining = false;
  }
}
function dB(e, t) {
  let n10 = null;
  return t.batchesPerEpoch != null ? n10 = t.batchesPerEpoch : Number.isFinite(e.size) && (n10 = e.size), n10;
}
function Fx(e) {
  return typeof e.iterator == "function";
}
function pB(e) {
  return typeof e.next == "function";
}
async function hB(e, t, n10) {
  n10 = n10 || {};
  let s10 = n10.batches != null, r10 = e.testFunction, a10 = [];
  if (n10.verbose > 0)
    throw new Fe("Verbose mode is not implemented yet.");
  w2.assert(!s10 || n10.batches > 0 && Number.isInteger(n10.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n10.batches)}`);
  let i10 = pB(t) ? t : await t.iterator(), o10 = 0, u10 = 0;
  for (; !s10 || u10 < n10.batches; ) {
    let l10 = await i10.next();
    if (a10 = j2(() => {
      if (l10.value) {
        let { xs: c10, ys: p10 } = r0(e, l10.value), d10 = c10.concat(p10), h10 = j2(() => r10(d10));
        if (Re2(d10), u10 === 0)
          for (let m10 = 0; m10 < h10.length; ++m10)
            a10.push(Ie2(0));
        let f10 = d10[0].shape[0];
        for (let m10 = 0; m10 < h10.length; ++m10) {
          let g10 = h10[m10], b10 = a10[m10];
          a10[m10] = j2(() => ie2(a10[m10], V2(f10, g10))), u10 > 0 && Re2(b10);
        }
        Re2(h10), o10 += f10, ++u10;
      }
      return a10;
    }), l10.done) {
      s10 && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n10.batches} batches). You may need to use the repeat() function when building your dataset.`);
      break;
    }
  }
  for (let l10 = 0; l10 < a10.length; ++l10) {
    let c10 = a10[l10];
    a10[l10] = xe2(a10[l10], o10), Re2(c10);
  }
  return gn(a10);
}
function xm(e) {
  w2.assert(e > 0 && Number.isInteger(e), () => `batchSize is required to be a positive integer, but got ${e}`);
}
function Au(e, t, n10) {
  return e == null ? [null] : Array.isArray(e) ? e.map((s10) => Jr(s10, t, n10 - t)) : Jr(e, t, n10 - t);
}
function Bb(e, t) {
  return j2(() => e == null ? null : Array.isArray(e) ? e.map((n10) => Bb(n10, t)) : VI(e, t.dtype === "int32" ? t : ce2(t, "int32")));
}
function wm(e, t) {
  let n10 = [], s10 = 0, r10 = null;
  for (; s10 < e; )
    r10 = s10 + t, r10 >= e && (r10 = e), n10.push([s10, r10]), s10 = r10;
  return n10;
}
async function fB(e, t, n10, s10, r10, a10, i10, o10, u10, l10, c10, p10, d10, h10, f10) {
  r10 == null && (r10 = 32), a10 == null && (a10 = 1), c10 == null && (c10 = true), d10 == null && (d10 = 0);
  let m10 = false;
  if (u10 != null && l10 != null && (m10 = true), f10 != null && (m10 = true, h10 == null))
    throw new U2("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
  let g10 = e.checkNumSamples(n10, r10, h10, "steps_per_epoch"), b10;
  g10 != null && (b10 = ys(0, g10)), i10 == null && (i10 = 1);
  let { callbackList: y10, history: v10 } = KI(o10, i10, a10, d10, g10, h10, r10, m10, p10);
  y10.setModel(e), e.history = v10, await y10.onTrainBegin(), e.stopTraining_ = false;
  for (let x10 = d10; x10 < a10; ++x10) {
    await y10.onEpochBegin(x10);
    let k10 = {};
    if (h10 != null)
      throw new Fe("stepsPerEpoch mode is not implemented yet.");
    {
      if (c10 === "batch")
        throw new Fe("batch shuffling is not implemneted yet");
      c10 && w2.shuffle(b10);
      let C10 = Qt(b10), T10 = wm(g10, r10);
      for (let E10 = 0; E10 < T10.length; ++E10) {
        let A10 = {};
        if (await y10.onBatchBegin(E10, A10), j2(() => {
          let P10 = T10[E10][0], R10 = T10[E10][1], F10 = Jr(C10, P10, R10 - P10);
          A10.batch = E10, A10.size = R10 - P10;
          let $10 = Bb(n10, F10), z10 = t($10);
          for (let W10 = 0; W10 < s10.length; ++W10) {
            let q10 = s10[W10], K10 = z10[W10];
            A10[q10] = K10, Ht(K10);
          }
          if (E10 === T10.length - 1 && m10) {
            let W10 = e.testLoop(u10, l10, r10);
            for (let q10 = 0; q10 < s10.length; ++q10) {
              let K10 = s10[q10], Y10 = W10[q10];
              Ht(Y10), k10["val_" + K10] = Y10;
            }
          }
        }), await y10.onBatchEnd(E10, A10), qI(A10), e.stopTraining_)
          break;
      }
      C10.dispose();
    }
    if (await y10.onEpochEnd(x10, k10), e.stopTraining_)
      break;
  }
  return await y10.onTrainEnd(), await e.history.syncData(), e.history;
}
async function mB(e, t, n10, s10 = {}) {
  if (e.isTraining)
    throw new Error("Cannot start training because another fit() call is ongoing.");
  e.isTraining = true;
  let r10, a10, i10, o10, u10, l10, c10, p10, d10;
  try {
    let h10 = s10.batchSize == null ? 32 : s10.batchSize;
    xm(h10);
    let f10 = false, m10 = await e.standardizeUserData(t, n10, s10.sampleWeight, s10.classWeight, f10, h10);
    r10 = m10[0], a10 = m10[1], d10 = m10[2];
    let g10 = false, b10;
    if (s10.validationData != null && s10.validationData.length > 0) {
      if (g10 = true, s10.validationData.length === 2)
        u10 = s10.validationData[0], l10 = s10.validationData[1];
      else
        throw s10.validationData.length === 3 ? new Fe("validationData including sample weights is not supported yet.") : new U2(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s10.validationData} is invalid.`);
      let A10 = true, P10 = await e.standardizeUserData(u10, l10, null, null, A10, h10);
      c10 = P10[0], p10 = P10[1], b10 = c10.concat(p10);
    } else if (s10.validationSplit != null && s10.validationSplit > 0 && s10.validationSplit < 1) {
      g10 = true;
      let A10 = Math.floor(r10[0].shape[0] * (1 - s10.validationSplit)), P10 = r10[0].shape[0];
      c10 = Au(r10, A10, P10), i10 = r10, r10 = Au(r10, 0, A10), p10 = Au(a10, A10, P10), o10 = a10, a10 = Au(a10, 0, A10), b10 = c10.concat(p10);
    } else
      s10.validationSteps != null && (g10 = true);
    let y10 = r10.concat(a10).concat(d10);
    e.checkTrainableWeightsConsistency();
    let v10 = e.makeTrainFunction(), x10 = e.getDedupedMetricsNames(), k10, C10;
    g10 ? (e.makeTestFunction(), k10 = e.testFunction, C10 = x10.slice().concat(x10.map((A10) => "val_" + A10))) : (k10 = null, b10 = [], C10 = x10.slice());
    let T10 = jI(s10.callbacks, s10.yieldEvery);
    return await fB(e, v10, y10, x10, h10, s10.epochs, s10.verbose, T10, k10, b10, s10.shuffle, C10, s10.initialEpoch, null, null);
  } finally {
    e.isTraining = false, ls(r10, t), ls(a10, n10), ls(i10, t), ls(o10, n10), ls(c10, u10), ls(p10, l10), d10 != null && Re2(d10);
  }
}
function a0(e) {
  let t = [];
  e instanceof et && (e = [e]);
  for (let n10 = 0; n10 < e.length; ++n10) {
    let s10 = e[n10];
    if (s10.rank === 1)
      t.push(Ll(s10, 1));
    else {
      if (s10.rank === 0)
        throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(s10);
    }
  }
  return t;
}
function ls(e, t) {
  if (e == null)
    return;
  let n10 = [];
  if (t instanceof et)
    n10.push(t.id);
  else if (Array.isArray(t))
    t.forEach((r10) => n10.push(r10.id));
  else if (t != null)
    for (let r10 in t) {
      let a10 = t[r10];
      n10.push(a10.id);
    }
  let s10 = [];
  if (e instanceof et)
    n10.indexOf(e.id) === -1 && s10.push(e);
  else if (Array.isArray(e))
    e.forEach((r10) => {
      n10.indexOf(r10.id) === -1 && s10.push(r10);
    });
  else if (e != null)
    for (let r10 in e) {
      let a10 = e[r10];
      n10.indexOf(a10.id) === -1 && s10.push(a10);
    }
  s10.forEach((r10) => {
    r10.isDisposed || r10.dispose();
  });
}
function gB(e) {
  return e instanceof et;
}
function km(e) {
  return Array.isArray(e);
}
function Ox(e) {
  return !gB(e) && !km(e);
}
function Px(e, t, n10, s10 = true, r10 = "") {
  if (t == null || t.length === 0) {
    if (e != null) {
      let i10 = false;
      if (km(e) && e.length > 0)
        i10 = true;
      else if (Ox(e)) {
        for (let o10 in e)
          if (e.hasOwnProperty(o10)) {
            i10 = true;
            break;
          }
      } else
        i10 = true;
      if (i10)
        throw new U2(`Error when checking model ${r10} expected no data, but got ${e}`);
    }
    return [];
  }
  if (e == null)
    return t.map((i10) => null);
  let a10;
  if (Ox(e)) {
    e = e, a10 = [];
    for (let i10 of t) {
      if (e[i10] == null)
        throw new U2(`No data provided for "${i10}". Need data for each key in: ${t}`);
      a10.push(e[i10]);
    }
  } else if (km(e)) {
    if (e = e, e.length !== t.length)
      throw new U2(`Error when checking model ${r10}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);
    a10 = e;
  } else {
    if (e = e, t.length > 1)
      throw new U2(`The model ${r10} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);
    a10 = [e];
  }
  if (a10 = a0(a10), n10 != null)
    for (let i10 = 0; i10 < t.length; ++i10) {
      if (n10[i10] == null)
        continue;
      let o10 = a10[i10];
      if (o10.shape.length !== n10[i10].length)
        throw new U2(`Error when checking ${r10}: expected ${t[i10]} to have ${n10[i10].length} dimension(s). but got array with shape ${o10.shape}`);
      for (let u10 = 0; u10 < n10[i10].length; ++u10) {
        if (u10 === 0 && !s10)
          continue;
        let l10 = o10.shape[u10], c10 = n10[i10][u10];
        if (c10 != null && c10 >= 0 && l10 !== c10)
          throw new U2(`${r10} expected a batch of elements where each example has shape [${n10[i10].slice(1, n10[i10].length)}] (i.e.,tensor shape [*,${n10[i10].slice(1, n10[i10].length)}]) but the ${r10} received an input with ${o10.shape[0]} examples, each with shape [${o10.shape.slice(1, o10.shape.length)}] (tensor shape [${o10.shape}])`);
      }
    }
  return a10;
}
function bB(e, t, n10) {
  let s10 = cr(e.map((a10) => a10.shape[0]));
  s10.sort();
  let r10 = cr(t.map((a10) => a10.shape[0]));
  if (r10.sort(), s10.length > 1)
    throw new U2(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((a10) => a10.shape))}`);
  if (r10.length > 1)
    throw new U2(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((a10) => a10.shape))}`);
  if (s10.length > 0 && r10.length > 0 && !w2.arraysEqual(s10, r10))
    throw new U2(`Input Tensors should have the same number of samples as target Tensors. Found ${s10[0]} input sample(s) and ${r10[0]} target sample(s).`);
}
function yB(e, t, n10) {
  let s10 = [fi, Op, Yu];
  for (let r10 = 0; r10 < e.length; ++r10) {
    let a10 = e[r10], i10 = t[r10], o10 = n10[r10];
    if (i10 != null) {
      if (i10 === Yu && a10.shape[a10.shape.length - 1] === 1)
        throw new U2(`You are passing a target array of shape ${a10.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
      if (s10.indexOf(i10) !== -1) {
        let u10 = a10.shape.slice(1), l10 = o10.slice(1);
        for (let c10 = 0; c10 < u10.length; ++c10) {
          let p10 = u10[c10], d10 = l10[c10];
          if (d10 != null && p10 !== d10)
            throw new U2(`A target Tensor with shape ${a10.shape} was passed for an output of shape ${o10}, while using a loss function that expects targets to have the same shape as the output.`);
        }
      }
    }
  }
}
function zx(e, t, n10, s10 = true, r10 = "") {
  let a10;
  if (Array.isArray(e)) {
    if (e.length !== t.length)
      throw new U2(`Error when checking model ${r10}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);
    a10 = e;
  } else {
    if (t.length > 1)
      throw new U2(`The model expects ${t.length} ${r10} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);
    a10 = [e];
  }
  if (n10 != null)
    for (let i10 = 0; i10 < t.length; ++i10) {
      if (n10[i10] == null)
        continue;
      let o10 = a10[i10];
      if (o10.shape.length !== n10[i10].length)
        throw new U2(`Error when checking ${r10}: expected ${t[i10]} to have ${n10[i10].length} dimension(s), but got array with shape ${JSON.stringify(o10.shape)}`);
      for (let u10 = 0; u10 < n10[i10].length; ++u10) {
        if (u10 === 0 && !s10)
          continue;
        let l10 = o10.shape[u10], c10 = n10[i10][u10];
        if (c10 != null && c10 !== l10)
          throw new U2(`Error when checking ${r10}: expected ${t[i10]} to have shape ${JSON.stringify(n10[i10])} but got array with shape ${JSON.stringify(o10.shape)}.`);
      }
    }
}
function vB(e, t) {
  if (e == null || Array.isArray(e) && e.length === 0)
    return t.map((s10) => []);
  let n10;
  if (typeof e == "string" || typeof e == "function")
    n10 = [e];
  else if (Array.isArray(e) || typeof e == "object")
    n10 = e;
  else
    throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);
  if (Array.isArray(n10))
    return t.map((s10) => n10);
  {
    let s10 = [];
    for (let r10 of t) {
      let a10 = n10.hasOwnProperty(r10) ? n10[r10] : [];
      Array.isArray(a10) || (a10 = [a10]), s10.push(a10);
    }
    return s10;
  }
}
var xB = "layers-model";
var pr = class extends Is {
  constructor(e) {
    super(e);
    this.isTraining = false;
  }
  summary(e, t, n10 = console.log) {
    if (!this.built)
      throw new U2("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    QL(this, e, t, n10);
  }
  compile(e) {
    if (e.loss == null && (e.loss = []), this.loss = e.loss, typeof e.optimizer == "string")
      this.optimizer_ = YL(e.optimizer), this.isOptimizerOwned = true;
    else {
      if (!(e.optimizer instanceof $r))
        throw new U2("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = false;
    }
    let t = [];
    if (!Array.isArray(e.loss) && typeof e.loss != "string" && typeof e.loss != "function") {
      e.loss = e.loss;
      for (let a10 in e.loss)
        if (this.outputNames.indexOf(a10) === -1)
          throw new U2(`Unknown entry in loss dictionary: "${a10}". Only expected the following keys: ${this.outputNames}`);
      for (let a10 of this.outputNames)
        e.loss[a10] == null && console.warn(`Output "${a10}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a10} during training`), t.push(Bf(e.loss[a10]));
    } else if (Array.isArray(e.loss)) {
      if (e.loss.length !== this.outputs.length)
        throw new U2(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);
      t = e.loss.map((i10) => Bf(i10));
    } else {
      let a10 = Bf(e.loss);
      this.outputs.forEach((i10) => {
        t.push(a10);
      });
    }
    this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
    for (let a10 = 0; a10 < this.outputs.length; ++a10) {
      let i10 = this.internalOutputShapes[a10], o10 = this.outputNames[a10];
      this.feedOutputNames.push(o10), this.feedOutputShapes.push(i10), this.feedLossFns.push(this.lossFunctions[a10]);
    }
    let n10 = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], Zr("loss", () => {
      for (let a10 = 0; a10 < this.outputs.length; ++a10) {
        if (n10.indexOf(a10) !== -1)
          continue;
        let i10 = this.lossFunctions[a10];
        this.outputs.length > 1 && (this.metricsTensors.push([i10, a10]), this.metricsNames.push(this.outputNames[a10] + "_loss"));
      }
    });
    let s10 = vB(e.metrics, this.outputNames), r10 = (a10, i10, o10) => {
      this.outputNames.length > 1 && (i10 = this.outputNames[a10] + "_" + i10), this.metricsNames.push(i10), this.metricsTensors.push([o10, a10]);
    };
    Zr("metric", () => {
      for (let a10 = 0; a10 < this.outputs.length; ++a10) {
        if (n10.indexOf(a10) !== -1)
          continue;
        let i10 = s10[a10];
        ((u10) => {
          let l10 = "", c10, p10, d10;
          for (let h10 of u10) {
            if (typeof h10 == "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(h10) !== -1) {
              let m10 = this.internalOutputShapes[a10];
              m10[m10.length - 1] === 1 || this.lossFunctions[a10] === Op ? ["accuracy", "acc"].indexOf(h10) !== -1 ? p10 = zb : ["crossentropy", "ce"].indexOf(h10) !== -1 && (p10 = QI) : this.lossFunctions[a10] === Nd ? ["accuracy", "acc"].indexOf(h10) !== -1 ? p10 = ZI : ["crossentropy", "ce"].indexOf(h10) !== -1 && (p10 = JI) : ["accuracy", "acc"].indexOf(h10) !== -1 ? p10 = Mb : ["crossentropy", "ce"].indexOf(h10) !== -1 && (p10 = Lb);
              let g10;
              ["accuracy", "acc"].indexOf(h10) !== -1 ? g10 = "acc" : ["crossentropy", "ce"].indexOf(h10) !== -1 && (g10 = "ce"), d10 = p10, c10 = l10 + g10;
            } else
              d10 = XL(h10), c10 = l10 + Hc(h10);
            let f10;
            Zr(c10, () => {
              f10 = d10;
            }), r10(a10, c10, f10);
          }
        })(i10);
      }
    }), this.collectedTrainableWeights = this.trainableWeights;
  }
  checkTrainableWeightsConsistency() {
    this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }
  evaluate(e, t, n10 = {}) {
    let s10 = n10.batchSize == null ? 32 : n10.batchSize;
    xm(s10);
    let r10 = true, a10 = this.standardizeUserDataXY(e, t, r10, s10);
    try {
      let i10 = a10[0].concat(a10[1]);
      this.makeTestFunction();
      let o10 = this.testFunction, u10 = this.testLoop(o10, i10, s10, n10.verbose, n10.steps);
      return gn(u10);
    } finally {
      ls(a10[0], e), ls(a10[1], t);
    }
  }
  async evaluateDataset(e, t) {
    return this.makeTestFunction(), hB(this, e, t);
  }
  checkNumSamples(e, t, n10, s10 = "steps") {
    let r10;
    if (n10 != null) {
      if (r10 = null, t != null)
        throw new U2(`If ${s10} is set, batchSize must be null or undefined.Got batchSize = ${t}`);
    } else if (e != null)
      Array.isArray(e) ? r10 = e[0].shape[0] : r10 = e.shape[0];
    else
      throw new U2(`Either the input data should have a defined shape, or ${s10} shoud be specified.`);
    return r10;
  }
  execute(e, t) {
    if (Array.isArray(t) && t.length === 0)
      throw new U2("`outputs` is an empty Array, which is not allowed.");
    let n10 = Array.isArray(t), s10 = n10 ? t : [t], r10 = this.retrieveSymbolicTensors(s10), a10 = new Xr();
    if (e instanceof et && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length)
        throw new U2(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
      for (let o10 = 0; o10 < this.inputs.length; ++o10)
        a10.add(this.inputs[o10], e[o10]);
    } else
      for (let o10 of this.inputs) {
        let u10 = e[o10.name];
        if (u10 == null)
          throw new U2(`No value is provided for the model's input ${o10.name}`);
        a10.add(o10, u10);
      }
    let i10 = _u(r10, a10);
    return n10 ? i10 : i10[0];
  }
  retrieveSymbolicTensors(e) {
    let t = pa(null, e.length), n10 = e.length;
    for (let s10 of this.layers) {
      let r10 = Array.isArray(s10.output) ? s10.output : [s10.output], a10 = r10.map((i10) => i10.name);
      for (let i10 = 0; i10 < e.length; ++i10) {
        let o10 = a10.indexOf(e[i10]);
        if (o10 !== -1 && (t[i10] = r10[o10], n10--), n10 === 0)
          break;
      }
      if (n10 === 0)
        break;
    }
    if (n10 > 0) {
      let s10 = [];
      throw t.forEach((r10, a10) => {
        r10 == null && s10.push(e[a10]);
      }), new U2(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s10)}`);
    }
    return t;
  }
  predictLoop(e, t = 32, n10 = false) {
    return j2(() => {
      let s10 = this.checkNumSamples(e);
      if (n10)
        throw new Fe("Verbose predictLoop() is not implemented yet.");
      let r10 = wm(s10, t), a10 = this.outputs.map((i10) => []);
      for (let i10 = 0; i10 < r10.length; ++i10)
        j2(() => {
          let u10 = r10[i10][0], l10 = r10[i10][1], c10 = Au(e, u10, l10), p10 = [];
          if (Array.isArray(c10))
            for (let h10 = 0; h10 < c10.length; ++h10)
              p10.push({ key: this.inputs[h10], value: c10[h10] });
          else
            p10.push({ key: this.inputs[0], value: c10 });
          let d10 = new Xr(p10);
          return _u(this.outputs, d10);
        }).forEach((u10, l10) => a10[l10].push(u10));
      return gn(a10.map((i10) => Ft(i10, 0)));
    });
  }
  predict(e, t = {}) {
    let n10 = a0(e);
    zx(n10, this.inputNames, this.feedInputShapes, false);
    try {
      let s10 = t.batchSize == null ? 32 : t.batchSize;
      return xm(s10), this.predictLoop(n10, s10);
    } finally {
      ls(n10, e);
    }
  }
  predictOnBatch(e) {
    zx(e, this.inputNames, this.feedInputShapes, true);
    let t = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, t);
  }
  standardizeUserDataXY(e, t, n10 = true, s10) {
    if (this.optimizer_ == null)
      throw new ps("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    let r10 = [];
    for (let a10 = 0; a10 < this.feedOutputShapes.length; ++a10) {
      let i10 = this.feedOutputShapes[a10];
      this.feedLossFns[a10] === Nd ? r10.push(i10.slice(0, i10.length - 1).concat([1])) : r10.push(i10);
    }
    if (e = Px(e, this.feedInputNames, this.feedInputShapes, false, "input"), t = Px(t, this.feedOutputNames, r10, false, "target"), bB(e, t, null), yB(t, this.feedLossFns, this.feedOutputShapes), this.stateful && s10 != null && s10 > 0 && e[0].shape[0] % s10 !== 0)
      throw new U2(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s10}. Found: ${e[0].shape[0]} sample(s).`);
    return [e, t];
  }
  async standardizeUserData(e, t, n10, s10, r10 = true, a10) {
    let [i10, o10] = this.standardizeUserDataXY(e, t, r10, a10);
    if (n10 != null)
      throw new Error("sample weight is not supported yet.");
    let u10 = null;
    if (s10 != null) {
      let l10 = n0(s10, this.outputNames);
      u10 = [];
      for (let c10 = 0; c10 < l10.length; ++c10)
        u10.push(await s0(o10[c10], null, l10[c10]));
    }
    return [i10, o10, u10];
  }
  testLoop(e, t, n10, s10 = 0, r10) {
    return j2(() => {
      let a10 = this.checkNumSamples(t, n10, r10, "steps"), i10 = [];
      if (s10 > 0)
        throw new Fe("Verbose mode is not implemented yet.");
      if (r10 != null)
        throw new Fe("steps mode in testLoop() is not implemented yet");
      {
        let o10 = wm(a10, n10), u10 = Qt(ys(0, a10));
        for (let l10 = 0; l10 < o10.length; ++l10) {
          let c10 = o10[l10][0], p10 = o10[l10][1], d10 = Jr(u10, c10, p10 - c10), h10 = Bb(t, d10), f10 = e(h10);
          if (l10 === 0)
            for (let m10 = 0; m10 < f10.length; ++m10)
              i10.push(Ie2(0));
          for (let m10 = 0; m10 < f10.length; ++m10) {
            let g10 = f10[m10];
            i10[m10] = ie2(i10[m10], V2(p10 - c10, g10));
          }
        }
        for (let l10 = 0; l10 < i10.length; ++l10)
          i10[l10] = xe2(i10[l10], a10);
      }
      return i10;
    });
  }
  getDedupedMetricsNames() {
    let e = this.metricsNames, t = [];
    for (let n10 = 0; n10 < e.length; ++n10) {
      let s10 = e[n10], r10 = s10;
      wx(e, s10) > 1 && (r10 += `_${wx(e.slice(0, n10), s10)}`), t.push(r10);
    }
    return t;
  }
  makeTrainFunction() {
    return (e) => {
      let t = [], n10 = e.slice(0, this.inputs.length), s10 = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), r10 = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), a10 = [], i10 = () => {
        let c10 = [];
        for (let f10 = 0; f10 < this.inputs.length; ++f10)
          c10.push({ key: this.inputs[f10], value: n10[f10] });
        let p10 = new Xr(c10), d10 = _u(this.outputs, p10, { training: true }), h10;
        for (let f10 = 0; f10 < this.lossFunctions.length; ++f10) {
          let g10 = this.lossFunctions[f10](s10[f10], d10[f10]);
          r10[f10] != null && (g10 = oB(g10, r10[f10]));
          let b10 = It(g10);
          t.push(b10), f10 === 0 ? h10 = g10 : h10 = ie2(h10, g10);
        }
        for (let f10 = 0; f10 < this.metricsTensors.length; ++f10) {
          let m10;
          if (this.outputs.length > 1 && f10 < this.outputs.length)
            m10 = t[f10];
          else {
            let g10 = this.metricsTensors[f10][0], b10 = this.metricsTensors[f10][1];
            m10 = It(g10(s10[b10], d10[b10]));
          }
          Ht(m10), a10.push(m10);
        }
        return h10 = It(h10), this.calculateLosses().forEach((f10) => {
          h10 = ie2(h10, f10);
        }), h10;
      }, o10 = this.collectedTrainableWeights.map((c10) => c10.read()), u10 = true;
      return [this.optimizer_.minimize(i10, u10, o10)].concat(a10);
    };
  }
  makeTestFunction() {
    this.testFunction = (e) => j2(() => {
      let t = [], n10, s10 = e.slice(0, this.inputs.length), r10 = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), a10 = [];
      for (let u10 = 0; u10 < this.inputs.length; ++u10)
        a10.push({ key: this.inputs[u10], value: s10[u10] });
      let i10 = new Xr(a10), o10 = _u(this.outputs, i10);
      for (let u10 = 0; u10 < this.lossFunctions.length; ++u10) {
        let l10 = this.lossFunctions[u10], c10 = It(l10(r10[u10], o10[u10]));
        u10 === 0 ? n10 = c10 : n10 = ie2(n10, c10), t.push(n10);
      }
      for (let u10 = 0; u10 < this.metricsTensors.length; ++u10) {
        let l10 = this.metricsTensors[u10][0], c10 = this.metricsTensors[u10][1], p10 = It(l10(r10[c10], o10[c10]));
        t.push(p10);
      }
      return t;
    });
  }
  async fit(e, t, n10 = {}) {
    return mB(this, e, t, n10);
  }
  async fitDataset(e, t) {
    return cB(this, e, t);
  }
  async trainOnBatch(e, t) {
    let n10 = await this.standardizeUserData(e, t), s10 = n10[0], r10 = n10[1], i10 = this.makeTrainFunction()(s10.concat(r10)), o10 = [];
    for (let u10 of i10) {
      let l10 = await u10.data();
      o10.push(l10[0]);
    }
    return Re2(i10), ls(n10[0], e), ls(n10[1], t), gn(o10);
  }
  getNamedWeights(e) {
    let t = [], n10 = e != null && e.trainableOnly, s10 = n10 ? this.trainableWeights : this.weights, r10 = this.getWeights(n10);
    for (let a10 = 0; a10 < s10.length; ++a10)
      n10 && !s10[a10].trainable || t.push({ name: s10[a10].originalName, tensor: r10[a10] });
    return t;
  }
  set stopTraining(e) {
    this.stopTraining_ = e;
  }
  get stopTraining() {
    return this.stopTraining_;
  }
  get optimizer() {
    return this.optimizer_;
  }
  set optimizer(e) {
    this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = false);
  }
  dispose() {
    let e = super.dispose();
    if (e.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
      let t = lm().numTensors;
      this.optimizer_.dispose(), e.numDisposedVariables += t - lm().numTensors;
    }
    return e;
  }
  getLossIdentifiers() {
    let e;
    if (typeof this.loss == "string")
      e = Ws(this.loss);
    else if (Array.isArray(this.loss)) {
      for (let t of this.loss)
        if (typeof t != "string")
          throw new Error("Serialization of non-string loss is not supported.");
      e = this.loss.map((t) => Ws(t));
    } else {
      let t = Object.keys(this.loss);
      e = {};
      let n10 = this.loss;
      for (let s10 of t)
        if (typeof n10[s10] == "string")
          e[s10] = Ws(n10[s10]);
        else
          throw new Error("Serialization of non-string loss is not supported.");
    }
    return e;
  }
  getMetricIdentifiers() {
    if (typeof this.metrics == "string" || typeof this.metrics == "function")
      return [Ws(Hc(this.metrics))];
    if (Array.isArray(this.metrics))
      return this.metrics.map((e) => Ws(Hc(e)));
    {
      let e = {};
      for (let t in this.metrics)
        e[t] = Ws(Hc(this.metrics[t]));
      return e;
    }
  }
  getTrainingConfig() {
    return { loss: this.getLossIdentifiers(), metrics: this.getMetricIdentifiers(), optimizer_config: { class_name: this.optimizer.getClassName(), config: this.optimizer.getConfig() } };
  }
  loadTrainingConfig(e) {
    if (e.weighted_metrics != null)
      throw new Error("Loading weight_metrics is not supported yet.");
    if (e.loss_weights != null)
      throw new Error("Loading loss_weights is not supported yet.");
    if (e.sample_weight_mode != null)
      throw new Error("Loading sample_weight_mode is not supported yet.");
    let t = Qu(e.optimizer_config), n10 = fs(t), s10;
    if (typeof e.loss == "string")
      s10 = qr(e.loss);
    else if (Array.isArray(e.loss))
      s10 = e.loss.map((a10) => qr(a10));
    else if (e.loss != null) {
      s10 = {};
      for (let a10 in e.loss)
        s10[a10] = qr(e.loss[a10]);
    }
    let r10;
    if (Array.isArray(e.metrics))
      r10 = e.metrics.map((a10) => qr(a10));
    else if (e.metrics != null) {
      r10 = {};
      for (let a10 in e.metrics)
        r10[a10] = qr(e.metrics[a10]);
    }
    this.compile({ loss: s10, metrics: r10, optimizer: n10 });
  }
  async save(e, t) {
    if (typeof e == "string") {
      let u10 = _n.getSaveHandlers(e);
      if (u10.length === 0)
        throw new U2(`Cannot find any save handlers for URL '${e}'`);
      if (u10.length > 1)
        throw new U2(`Found more than one (${u10.length}) save handlers for URL '${e}'`);
      e = u10[0];
    }
    if (e.save == null)
      throw new U2("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    let n10 = await _n.encodeWeights(this.getNamedWeights(t)), s10 = false, r10 = null, i10 = { modelTopology: this.toJSON(r10, s10), format: xB, generatedBy: `TensorFlow.js tfjs-layers v${t0}`, convertedBy: null };
    if ((t == null ? false : t.includeOptimizer) && this.optimizer != null) {
      i10.trainingConfig = this.getTrainingConfig();
      let u10 = "optimizer", { data: l10, specs: c10 } = await _n.encodeWeights(await this.optimizer.getWeights(), u10);
      n10.specs.push(...c10), n10.data = _n.concatenateArrayBuffers([n10.data, l10]);
    }
    return this.userDefinedMetadata != null && (Ax(this.userDefinedMetadata, this.name, true), i10.userDefinedMetadata = this.userDefinedMetadata), i10.weightData = n10.data, i10.weightSpecs = n10.specs, e.save(i10);
  }
  setUserDefinedMetadata(e) {
    Ax(e, this.name), this.userDefinedMetadata = e;
  }
  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }
};
pr.className = "Model";
ae2.registerClass(pr);
var i0 = class extends pr {
};
i0.className = "Functional";
ae2.registerClass(i0);
async function wB(e, t) {
  "modelTopology" in e || (e = { modelTopology: e }), e = e;
  let n10 = e.modelTopology;
  n10.model_config != null && (n10 = n10.model_config);
  let s10 = Qu(n10), r10 = fs(s10, t);
  if (e.weightsManifest != null) {
    let a10 = await _n.loadWeights(e.weightsManifest, e.pathPrefix, r10.weights.map((o10) => o10.originalName)), i10 = {};
    for (let o10 of r10.weights)
      i10[o10.originalName] = a10[o10.originalName];
    r10.loadWeights(i10), Re2(a10);
  }
  return r10;
}
async function kB(e, t) {
  if (t == null && (t = {}), typeof e == "string") {
    let n10 = _n.getLoadHandlers(e, t);
    if (n10.length === 0)
      n10.push(_n.browserHTTPRequest(e, t));
    else if (n10.length > 1)
      throw new U2(`Found more than one (${n10.length}) load handlers for URL '${e}'`);
    e = n10[0];
  }
  return IB(e, void 0, t);
}
async function IB(e, t, n10) {
  if (n10 == null && (n10 = {}), e.load == null)
    throw new U2("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
  let s10 = await e.load(), r10 = s10.modelTopology;
  r10.model_config != null && (r10 = r10.model_config);
  let a10 = n10.strict == null ? true : n10.strict, i10 = s10.weightData != null && s10.weightSpecs != null && a10, o10 = fs(Qu(r10), t, i10), u10 = s10.trainingConfig;
  if (u10 != null && o10.loadTrainingConfig(u10), s10.userDefinedMetadata != null && o10.setUserDefinedMetadata(s10.userDefinedMetadata), s10.weightData != null) {
    if (s10.weightSpecs == null)
      throw new U2("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
    let { modelWeights: l10, optimizerWeights: c10 } = SB(s10.weightData, s10.weightSpecs);
    o10.loadWeights(l10, a10), o10.optimizer != null && c10.length > 0 && await o10.optimizer.setWeights(c10), Re2(l10), Re2(c10.map((p10) => p10.tensor));
  }
  return o10;
}
function SB(e, t) {
  let n10 = _n.decodeWeights(e, t), s10 = {}, r10 = [];
  return t.forEach((a10) => {
    a10.group === "optimizer" ? r10.push({ name: a10.name, tensor: n10[a10.name] }) : s10[a10.name] = n10[a10.name];
  }), { modelWeights: s10, optimizerWeights: r10 };
}
var Im = class extends pr {
  constructor(e) {
    super({ inputs: [], outputs: [] });
    if (e = e || {}, this.trainable = true, this.built = false, this.name = e.name != null ? e.name : Rp("sequential_"), e.layers != null)
      for (let t of e.layers)
        this.add(t);
  }
  checkShape(e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some((n10) => n10 < 0))
      throw new U2(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`);
  }
  add(e) {
    let t = e instanceof Im || e instanceof pr, n10;
    if (t) {
      if (n10 = e, n10.outputs.length !== 1)
        throw new U2("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (n10.inputs.length !== 1)
        throw new U2("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }
    if (this.outputs.length === 0) {
      if (e.inboundNodes.length === 0) {
        if (e.batchInputShape == null)
          throw new U2("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        let s10 = HI({ batchShape: e.batchInputShape, dtype: e.dtype, name: e.name + "_input" });
        e.apply(s10);
      }
      if (t)
        this.outputs = n10.outputs, this.inputs = n10.inputs;
      else {
        if (e.inboundNodes.length !== 1)
          throw new U2(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);
        if (e.inboundNodes[0].outputTensors.length !== 1)
          throw new U2("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = GI(this.outputs[0]);
      }
      this.inboundNodes = [], new Dp({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: pa(null, this.inputs.length), outputMasks: [null], inputShapes: this.inputs.map((s10) => s10.shape), outputShapes: this.outputs[0].shape });
    } else {
      let s10 = e.apply(this.outputs[0]);
      if (Array.isArray(s10))
        throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [s10], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
    this.layers.push(e), this.built = false;
  }
  pop() {
    if (this.layers.length === 0)
      throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), this.layers.length === 0)
      this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
    else {
      let e = this.layers.length - 1;
      this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }
  call(e, t) {
    return this.model == null && this.build(), this.model.call(e, t);
  }
  build(e) {
    if (nt(e), this.inputs.length === 0 || this.outputs.length === 0)
      throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new pr({ inputs: this.inputs, outputs: this.outputs[0], name: this.name + "_model" }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
  }
  countParams() {
    return this.built || this.build(), super.countParams();
  }
  summary(e, t, n10 = console.log) {
    this.built || this.build(), super.summary(e, t, n10);
  }
  setWeights(e) {
    this.model == null && this.build(), this.model.setWeights(e);
  }
  evaluate(e, t, n10 = {}) {
    if (!this.built)
      throw new ps("The model needs to be compiled before being used.");
    return this.model.evaluate(e, t, n10);
  }
  async evaluateDataset(e, t) {
    if (!this.built)
      throw new ps("The model needs to be compiled before being used.");
    return this.model.evaluateDataset(e, t);
  }
  predict(e, t = {}) {
    return this.model == null && this.build(), this.model.predict(e, t);
  }
  predictOnBatch(e) {
    return this.model == null && this.build(), this.model.predictOnBatch(e);
  }
  compile(e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }
  get optimizer() {
    return this.model == null ? void 0 : this.model.optimizer;
  }
  set optimizer(e) {
    this.model.optimizer = e;
  }
  async fit(e, t, n10 = {}) {
    if (!this.built)
      throw new ps("The model needs to be compiled before being used.");
    return this.model.fit(e, t, n10);
  }
  async fitDataset(e, t) {
    if (!this.built)
      throw new ps("The model needs to be compiled before being used.");
    return this.model.fitDataset(e, t);
  }
  async trainOnBatch(e, t) {
    return this.model.trainOnBatch(e, t);
  }
  static fromConfig(e, t, n10 = {}, s10 = false) {
    let r10, a10 = {};
    if (t instanceof Array) {
      if (t[0].className == null || t[0].className === "Merge")
        throw new U2("Legacy serialization format not supported yet.");
      r10 = t;
    } else
      w2.assert(t.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), r10 = t.layers, delete t.layers, a10 = t;
    let i10 = new e(a10);
    if (!(i10 instanceof Im))
      throw new Fe(`Sequential.fromConfig called on non-Sequential input: ${i10}`);
    for (let o10 of r10) {
      let l10 = fs(o10, void 0, s10);
      s10 && l10.setFastWeightInitDuringBuild(true), i10.add(l10);
    }
    return i10;
  }
  set stopTraining(e) {
    if (this.model == null)
      throw new U2("Cannot set the stopTraining property of a sequential model before it is compiled.");
    this.model.stopTraining = e;
  }
  get stopTraining() {
    if (this.model == null)
      throw new U2("Cannot get the stopTraining property of a sequential model before it is compiled.");
    return this.model.stopTraining;
  }
  getConfig() {
    let e = [];
    for (let t of this.layers) {
      let n10 = {};
      n10.className = t.getClassName(), n10.config = t.getConfig(), e.push(n10);
    }
    return { name: this.name, layers: e };
  }
};
var Vb = Im;
Vb.className = "Sequential";
ae2.registerClass(Vb);
function cpe(e) {
  return new pr(e);
}
function dpe(e) {
  return new Vb(e);
}
function ppe(e, t) {
  return t == null && (t = {}), kB(e, t);
}
function CB(e) {
  return HI(e);
}
function hpe(e, t) {
  Ob.registerCallbackConstructor(e, t);
}
var wn = class extends ae2.Serializable {
  getConfig() {
    return {};
  }
};
var o0 = class extends wn {
  apply(e, t = 1) {
    return XM(e, t);
  }
};
o0.className = "elu";
ae2.registerClass(o0);
var u0 = class extends wn {
  apply(e) {
    return cI(e);
  }
};
u0.className = "selu";
ae2.registerClass(u0);
var l0 = class extends wn {
  apply(e) {
    return Xs(e);
  }
};
l0.className = "relu";
ae2.registerClass(l0);
var c0 = class extends wn {
  apply(e) {
    return j2(() => gp(6, Xs(e)));
  }
};
c0.className = "relu6";
ae2.registerClass(c0);
var d0 = class extends wn {
  apply(e) {
    return e;
  }
};
d0.className = "linear";
ae2.registerClass(d0);
var p0 = class extends wn {
  apply(e) {
    return qs(e);
  }
};
p0.className = "sigmoid";
ae2.registerClass(p0);
var h0 = class extends wn {
  apply(e) {
    return QM(e);
  }
};
h0.className = "hardSigmoid";
ae2.registerClass(h0);
var f0 = class extends wn {
  apply(e) {
    return Ol(e);
  }
};
f0.className = "softplus";
ae2.registerClass(f0);
var m0 = class extends wn {
  apply(e) {
    return YM(e);
  }
};
m0.className = "softsign";
ae2.registerClass(m0);
var g0 = class extends wn {
  apply(e) {
    return Hu(e);
  }
};
g0.className = "tanh";
ae2.registerClass(g0);
var Wb = class extends wn {
  apply(e, t = -1) {
    return ib(e, t);
  }
};
Wb.className = "softmax";
ae2.registerClass(Wb);
var b0 = class extends wn {
  apply(e, t = -1) {
    return eI(e, t);
  }
};
b0.className = "logSoftmax";
ae2.registerClass(b0);
var y0 = class extends wn {
  apply(e, t = 1) {
    return j2(() => V2(qs(V2(e, t)), e));
  }
};
y0.className = "swish";
ae2.registerClass(y0);
var v0 = class extends wn {
  apply(e) {
    return j2(() => V2(e, Hu(Ol(e))));
  }
};
v0.className = "mish";
ae2.registerClass(v0);
function br(e) {
  return e.getClassName();
}
function Wf(e, t = {}) {
  return zl(e, ae2.SerializationMap.getMap().classNameMap, t, "activation");
}
function yr(e) {
  if (e == null) {
    let t = {};
    return t.className = "linear", t.config = {}, Wf(t);
  }
  if (typeof e == "string") {
    let t = {};
    return t.className = e, t.config = {}, Wf(t);
  } else
    return e instanceof wn ? e : Wf(e);
}
function Ub(e) {
  if (e != null && typeof e != "object")
    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`);
}
var x0 = class extends ae2.Serializable {
};
var Wl = class extends x0 {
  constructor(e) {
    super();
    Ub(e), this.l1 = e == null || e.l1 == null ? 0.01 : e.l1, this.l2 = e == null || e.l2 == null ? 0.01 : e.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
  }
  apply(e) {
    return j2(() => {
      let t = $t([1]);
      return this.hasL1 && (t = ie2(t, ye2(V2(this.l1, Mt(e))))), this.hasL2 && (t = ie2(t, ye2(V2(this.l2, Bl(e))))), G2(t, []);
    });
  }
  getConfig() {
    return { l1: this.l1, l2: this.l2 };
  }
  static fromConfig(e, t) {
    return new e({ l1: t.l1, l2: t.l2 });
  }
};
Wl.className = "L1L2";
ae2.registerClass(Wl);
function NB(e) {
  return Ub(e), new Wl({ l1: e != null ? e.l1 : null, l2: 0 });
}
function TB(e) {
  return Ub(e), new Wl({ l2: e != null ? e.l2 : null, l1: 0 });
}
var Mx = { l1l2: "L1L2" };
function at(e) {
  return vb(e);
}
function Lx(e, t = {}) {
  return zl(e, ae2.SerializationMap.getMap().classNameMap, t, "regularizer");
}
function ft(e) {
  if (e == null)
    return null;
  if (typeof e == "string") {
    let n10 = { className: e in Mx ? Mx[e] : e, config: {} };
    return Lx(n10);
  } else
    return e instanceof x0 ? e : Lx(e);
}
var Gb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    this.supportsMasking = true, e != null && (this.maxValue = e.maxValue);
  }
  call(e, t) {
    e = Oe(e);
    let n10 = Xs(e);
    return this.maxValue != null && (n10 = Bn(n10, 0, this.maxValue)), n10;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = { maxValue: this.maxValue }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Gb.className = "ReLU";
ae2.registerClass(Gb);
var Hb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    this.DEFAULT_ALPHA = 0.3, e == null && (e = {}), this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
  }
  call(e, t) {
    let n10 = Oe(e);
    return jg(n10, this.alpha);
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = { alpha: this.alpha }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Hb.className = "LeakyReLU";
ae2.registerClass(Hb);
var qb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    if (this.DEFAULT_ALPHA_INITIALIZER = "zeros", e == null && (e = {}), this.supportsMasking = true, this.alphaInitializer = ht(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = ft(e.alphaRegularizer), this.alphaConstraint = Pt(e.alphaConstraint), e.sharedAxes == null)
      this.sharedAxes = null;
    else if (Array.isArray(e.sharedAxes))
      this.sharedAxes = e.sharedAxes;
    else if (typeof e.sharedAxes == "number")
      this.sharedAxes = [e.sharedAxes];
    else
      throw new U2(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);
  }
  build(e) {
    e = nt(e);
    let t = e.slice(1);
    if (this.sharedAxes != null)
      for (let s10 of this.sharedAxes)
        t[s10 - 1] = 1;
    this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
    let n10 = {};
    if (this.sharedAxes != null)
      for (let s10 = 1; s10 < e.length; ++s10)
        n10[s10] = e[s10];
    this.inputSpec = [new Dt({ ndim: e.length, axes: n10 })], this.built = true;
  }
  call(e, t) {
    return e = Oe(e), tb(e, this.alpha.read());
  }
  getConfig() {
    let e = { alphaInitializer: yt(this.alphaInitializer), alphaRegularizer: at(this.alphaRegularizer), alphaConstraint: Ot(this.alphaConstraint), sharedAxes: this.sharedAxes }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
qb.className = "PReLU";
ae2.registerClass(qb);
var jb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    if (this.DEFAULT_ALPHA = 1, e == null && (e = {}), e.alpha != null && e.alpha !== this.DEFAULT_ALPHA)
      throw new Fe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);
    this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
  }
  call(e, t) {
    let n10 = Oe(e);
    return hp(n10);
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = { alpha: this.alpha }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
jb.className = "ELU";
ae2.registerClass(jb);
var Kb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    this.DEFAULT_THETA = 1, e == null && (e = {}), this.theta = e.theta == null ? this.DEFAULT_THETA : e.theta;
  }
  call(e, t) {
    let n10 = Oe(e);
    return V2(n10, ce2(Wn(n10, this.theta), "float32"));
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = { theta: this.theta }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Kb.className = "ThresholdedReLU";
ae2.registerClass(Kb);
var Xb = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    this.DEFAULT_AXIS = 1, e == null && (e = {}), this.softmax = new Wb().apply, this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis;
  }
  call(e, t) {
    let n10 = Oe(e);
    return this.softmax(n10, this.axis);
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = { axis: this.axis }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Xb.className = "Softmax";
ae2.registerClass(Xb);
function Ki(e, t, n10) {
  if (typeof e == "number")
    return pa(e, t);
  if (e.length !== t)
    throw new U2(`The ${n10} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);
  for (let s10 = 0; s10 < t; ++s10) {
    let r10 = e[s10];
    if (!HM(r10))
      throw new U2(`The ${n10} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r10}`);
  }
  return e;
}
function ms(e, t, n10, s10, r10 = 1) {
  if (e == null)
    return e;
  let a10 = t + (t - 1) * (r10 - 1), i10;
  return n10 === "same" ? i10 = e : i10 = e - a10 + 1, Math.floor((i10 + s10 - 1) / s10);
}
function Ns(e, t, n10, s10) {
  if (e == null)
    return null;
  if (s10 === "valid")
    e = e * t + gr([n10 - t, 0]);
  else if (s10 === "same")
    e = e * t;
  else
    throw new U2(`Unsupport padding mode: ${s10}.`);
  return e;
}
function Yb(e, t) {
  return j2(() => (St(t), t === "channelsFirst" ? qe(e, [0, 2, 3, 1]) : e));
}
function w0(e, t) {
  return j2(() => (St(t), t === "channelsFirst" ? qe(e, [0, 2, 3, 4, 1]) : e));
}
function $B(e, t, n10, s10 = 1, r10 = "valid", a10, i10 = 1) {
  return j2(() => {
    if (a10 == null && (a10 = bs()), St(a10), e.shape.length !== 3)
      throw new U2(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);
    if (t.shape.length !== 3)
      throw new U2(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
    if (n10 != null && n10.shape.length !== 1)
      throw new U2(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
    if (a10 === "channelsFirst" && (e = qe(e, [0, 2, 1])), r10 === "causal")
      throw new Fe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    let o10 = qk(e, t, s10, r10 === "same" ? "same" : "valid", "NWC", i10);
    return n10 != null && (o10 = ws(o10, n10)), o10;
  });
}
function Bx(e, t, n10, s10 = [1, 1], r10 = "valid", a10, i10, o10 = null) {
  return j2(() => {
    if (a10 == null && (a10 = bs()), St(a10), e.rank !== 3 && e.rank !== 4)
      throw new U2(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);
    if (t.rank !== 3 && t.rank !== 4)
      throw new U2(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);
    let u10 = Yb(e, a10);
    if (r10 === "causal")
      throw new Fe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return u10 = da.conv2d({ x: u10, filter: t, strides: s10, pad: r10 === "same" ? "same" : "valid", dilations: i10, dataFormat: "NHWC", bias: n10, activation: o10 }), a10 === "channelsFirst" && (u10 = qe(u10, [0, 3, 1, 2])), u10;
  });
}
function _B(e, t, n10, s10 = [1, 1, 1], r10 = "valid", a10, i10) {
  return j2(() => {
    if (a10 == null && (a10 = bs()), St(a10), e.rank !== 4 && e.rank !== 5)
      throw new U2(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);
    if (t.rank !== 4 && t.rank !== 5)
      throw new U2(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);
    let o10 = w0(e, a10);
    if (r10 === "causal")
      throw new Fe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    return o10 = Kk(o10, t, s10, r10 === "same" ? "same" : "valid", "NDHWC", i10), n10 != null && (o10 = ws(o10, n10)), a10 === "channelsFirst" && (o10 = qe(o10, [0, 4, 1, 2, 3])), o10;
  });
}
var Qb = class extends Ge {
  constructor(e, t) {
    super(t);
    if (this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", Qb.verifyArgs(t), this.rank = e, Bt(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3)
      throw new Fe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
    if (this.kernelSize = Ki(t.kernelSize, e, "kernelSize"), this.strides = Ki(t.strides == null ? 1 : t.strides, e, "strides"), this.padding = t.padding == null ? "valid" : t.padding, Un(this.padding), this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, St(this.dataFormat), this.activation = yr(t.activation), this.useBias = t.useBias == null ? true : t.useBias, this.biasInitializer = ht(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Pt(t.biasConstraint), this.biasRegularizer = ft(t.biasRegularizer), this.activityRegularizer = ft(t.activityRegularizer), this.dilationRate = Ki(t.dilationRate == null ? 1 : t.dilationRate, e, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)
      throw new U2(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    if (this.rank === 2) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 2)
        throw new U2(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    } else if (this.rank === 3) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 3)
        throw new U2(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    }
  }
  static verifyArgs(e) {
    if (Cs("kernelSize" in e, "required key 'kernelSize' not in config"), typeof e.kernelSize != "number" && !xb(e.kernelSize, "number", 1, 3))
      throw new U2(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`);
  }
  getConfig() {
    let e = { kernelSize: this.kernelSize, strides: this.strides, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, activation: br(this.activation), useBias: this.useBias, biasInitializer: yt(this.biasInitializer), biasRegularizer: at(this.biasRegularizer), activityRegularizer: at(this.activityRegularizer), biasConstraint: Ot(this.biasConstraint) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
var Ul = class extends Qb {
  constructor(e, t) {
    super(e, t);
    this.kernel = null, Ul.verifyArgs(t), this.filters = t.filters, Bt(this.filters, "filters"), this.kernelInitializer = ht(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Pt(t.kernelConstraint), this.kernelRegularizer = ft(t.kernelRegularizer);
  }
  build(e) {
    e = nt(e);
    let t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[t] == null)
      throw new U2(`The channel dimension of the input should be defined. Found ${e[t]}`);
    let n10 = e[t], s10 = this.kernelSize.concat([n10, this.filters]);
    this.kernel = this.addWeight("kernel", s10, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: { [t]: n10 } }], this.built = true;
  }
  call(e, t) {
    return j2(() => {
      e = Oe(e);
      let n10, s10 = this.bias == null ? null : this.bias.read(), r10 = PI(this.activation.getClassName());
      if (r10 != null && this.rank === 2)
        n10 = Bx(e, this.kernel.read(), s10, this.strides, this.padding, this.dataFormat, this.dilationRate, r10);
      else {
        if (this.rank === 1)
          n10 = $B(e, this.kernel.read(), s10, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
        else if (this.rank === 2)
          n10 = Bx(e, this.kernel.read(), s10, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else if (this.rank === 3)
          n10 = _B(e, this.kernel.read(), s10, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else
          throw new Fe("convolutions greater than 3D are not implemented yet.");
        this.activation != null && (n10 = this.activation.apply(n10));
      }
      return n10;
    });
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = [], n10 = this.dataFormat === "channelsLast" ? e.slice(1, e.length - 1) : e.slice(2);
    for (let r10 = 0; r10 < n10.length; ++r10) {
      let a10 = ms(n10[r10], this.kernelSize[r10], this.padding, this.strides[r10], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[r10]);
      t.push(a10);
    }
    let s10 = [e[0]];
    return this.dataFormat === "channelsLast" ? (s10 = s10.concat(t), s10.push(this.filters)) : (s10.push(this.filters), s10 = s10.concat(t)), s10;
  }
  getConfig() {
    let e = { filters: this.filters, kernelInitializer: yt(this.kernelInitializer), kernelRegularizer: at(this.kernelRegularizer), kernelConstraint: Ot(this.kernelConstraint) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
  static verifyArgs(e) {
    if (!("filters" in e) || typeof e.filters != "number" || e.filters < 1)
      throw new U2(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`);
  }
};
var k0 = class extends Ul {
  constructor(e) {
    super(2, e);
    k0.verifyArgs(e);
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.rank, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !xb(e.kernelSize, "number", 1, 2))
      throw new U2(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`);
  }
};
var Pp = k0;
Pp.className = "Conv2D";
ae2.registerClass(Pp);
var I0 = class extends Ul {
  constructor(e) {
    super(3, e);
    I0.verifyArgs(e);
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.rank, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !(Array.isArray(e.kernelSize) && (e.kernelSize.length === 1 || e.kernelSize.length === 3)))
      throw new U2(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`);
  }
};
var zp = I0;
zp.className = "Conv3D";
ae2.registerClass(zp);
var Zb = class extends Pp {
  constructor(e) {
    super(e);
    if (this.inputSpec = [new Dt({ ndim: 4 })], this.padding !== "same" && this.padding !== "valid")
      throw new U2(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(e) {
    if (e = nt(e), e.length !== 4)
      throw new U2("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    let t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[t] == null)
      throw new U2("The channel dimension of the inputs should be defined. Found `None`.");
    let n10 = e[t], s10 = this.kernelSize.concat([this.filters, n10]);
    this.kernel = this.addWeight("kernel", s10, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new Dt({ ndim: 4, axes: { [t]: n10 } })], this.built = true;
  }
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      if (n10.shape.length !== 4)
        throw new U2(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n10.shape.length}`);
      let s10 = n10.shape, r10 = s10[0], a10, i10;
      this.dataFormat === "channelsFirst" ? (a10 = 2, i10 = 3) : (a10 = 1, i10 = 2);
      let o10 = s10[a10], u10 = s10[i10], l10 = this.kernelSize[0], c10 = this.kernelSize[1], p10 = this.strides[0], d10 = this.strides[1], h10 = Ns(o10, p10, l10, this.padding), f10 = Ns(u10, d10, c10, this.padding), m10 = [r10, h10, f10, this.filters];
      this.dataFormat !== "channelsLast" && (n10 = qe(n10, [0, 2, 3, 1]));
      let g10 = jk(n10, this.kernel.read(), m10, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (g10 = qe(g10, [0, 3, 1, 2])), this.bias != null && (g10 = ws(g10, this.bias.read(), this.dataFormat)), this.activation != null && (g10 = this.activation.apply(g10)), g10;
    });
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = e.slice(), n10, s10, r10;
    this.dataFormat === "channelsFirst" ? (n10 = 1, s10 = 2, r10 = 3) : (n10 = 3, s10 = 1, r10 = 2);
    let a10 = this.kernelSize[0], i10 = this.kernelSize[1], o10 = this.strides[0], u10 = this.strides[1];
    return t[n10] = this.filters, t[s10] = Ns(t[s10], o10, a10, this.padding), t[r10] = Ns(t[r10], u10, i10, this.padding), t;
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.dilationRate, e;
  }
};
Zb.className = "Conv2DTranspose";
ae2.registerClass(Zb);
var Jb = class extends zp {
  constructor(e) {
    super(e);
    if (this.inputSpec = [new Dt({ ndim: 5 })], this.padding !== "same" && this.padding !== "valid")
      throw new U2(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(e) {
    if (e = nt(e), e.length !== 5)
      throw new U2("Input should have rank 5; Received input shape: " + JSON.stringify(e));
    let t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[t] == null)
      throw new U2("The channel dimension of the inputs should be defined. Found `None`.");
    let n10 = e[t], s10 = this.kernelSize.concat([this.filters, n10]);
    this.kernel = this.addWeight("kernel", s10, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new Dt({ ndim: 5, axes: { [t]: n10 } })], this.built = true;
  }
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      if (n10.shape.length !== 5)
        throw new U2(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n10.shape.length}`);
      let s10 = n10.shape, r10 = s10[0], a10, i10, o10;
      this.dataFormat === "channelsFirst" ? (o10 = 2, a10 = 3, i10 = 4) : (o10 = 1, a10 = 2, i10 = 3);
      let u10 = s10[o10], l10 = s10[a10], c10 = s10[i10], p10 = this.kernelSize[0], d10 = this.kernelSize[1], h10 = this.kernelSize[2], f10 = this.strides[0], m10 = this.strides[1], g10 = this.strides[2], b10 = Ns(u10, f10, p10, this.padding), y10 = Ns(l10, m10, d10, this.padding), v10 = Ns(c10, g10, h10, this.padding), x10 = [r10, b10, y10, v10, this.filters];
      this.dataFormat !== "channelsLast" && (n10 = qe(n10, [0, 2, 3, 4, 1]));
      let k10 = qE(n10, this.kernel.read(), x10, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (k10 = qe(k10, [0, 4, 1, 2, 3])), this.bias !== null && (k10 = ws(k10, this.bias.read(), this.dataFormat)), this.activation !== null && (k10 = this.activation.apply(k10)), k10;
    });
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = e.slice(), n10, s10, r10, a10;
    this.dataFormat === "channelsFirst" ? (n10 = 1, s10 = 2, r10 = 3, a10 = 4) : (n10 = 4, s10 = 1, r10 = 2, a10 = 3);
    let i10 = this.kernelSize[0], o10 = this.kernelSize[1], u10 = this.kernelSize[2], l10 = this.strides[0], c10 = this.strides[1], p10 = this.strides[2];
    return t[n10] = this.filters, t[s10] = Ns(t[s10], l10, i10, this.padding), t[r10] = Ns(t[r10], c10, o10, this.padding), t[a10] = Ns(t[a10], p10, u10, this.padding), t;
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.dilationRate, e;
  }
};
Jb.className = "Conv3DTranspose";
ae2.registerClass(Jb);
var S0 = class extends Ul {
  constructor(e, t) {
    super(e, t);
    if (this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, t.filters == null)
      throw new U2("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (t.kernelInitializer != null || t.kernelRegularizer != null || t.kernelConstraint != null)
      throw new U2("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (t.padding != null && t.padding !== "same" && t.padding !== "valid")
      throw new U2(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);
    this.depthMultiplier = t.depthMultiplier == null ? 1 : t.depthMultiplier, this.depthwiseInitializer = ht(t.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = ft(t.depthwiseRegularizer), this.depthwiseConstraint = Pt(t.depthwiseConstraint), this.pointwiseInitializer = ht(t.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = ft(t.pointwiseRegularizer), this.pointwiseConstraint = Pt(t.pointwiseConstraint);
  }
  build(e) {
    if (e = nt(e), e.length < this.rank + 2)
      throw new U2(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(e)}`);
    let t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[t] == null || e[t] < 0)
      throw new U2(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);
    let n10 = e[t], s10 = this.kernelSize.concat([n10, this.depthMultiplier]), r10 = [];
    for (let i10 = 0; i10 < this.rank; ++i10)
      r10.push(1);
    r10.push(n10 * this.depthMultiplier, this.filters);
    let a10 = true;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", s10, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, a10, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r10, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, a10, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, a10, this.biasConstraint) : this.bias = null, this.inputSpec = [new Dt({ ndim: this.rank + 2, axes: { [t]: n10 } })], this.built = true;
  }
  call(e, t) {
    return j2(() => {
      e = Oe(e);
      let n10;
      if (this.rank === 1)
        throw new Fe("1D separable convolution is not implemented yet.");
      return this.rank === 2 && (this.dataFormat === "channelsFirst" && (e = qe(e, [0, 2, 3, 1])), n10 = JD(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (n10 = ws(n10, this.bias.read(), this.dataFormat)), this.activation != null && (n10 = this.activation.apply(n10)), this.dataFormat === "channelsFirst" && (n10 = qe(n10, [0, 3, 1, 2])), n10;
    });
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = yt(this.depthwiseInitializer), e.pointwiseInitializer = yt(this.pointwiseInitializer), e.depthwiseRegularizer = at(this.depthwiseRegularizer), e.pointwiseRegularizer = at(this.pointwiseRegularizer), e.depthwiseConstraint = Ot(this.depthwiseConstraint), e.pointwiseConstraint = Ot(this.pointwiseConstraint), e;
  }
};
S0.className = "SeparableConv";
var ey = class extends S0 {
  constructor(e) {
    super(2, e);
  }
};
ey.className = "SeparableConv2D";
ae2.registerClass(ey);
var C0 = class extends Ul {
  constructor(e) {
    super(1, e);
    C0.verifyArgs(e), this.inputSpec = [{ ndim: 3 }];
  }
  getConfig() {
    let e = super.getConfig();
    return delete e.rank, delete e.dataFormat, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !xb(e.kernelSize, "number", 1, 1))
      throw new U2(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`);
  }
};
var ty = C0;
ty.className = "Conv1D";
ae2.registerClass(ty);
var ny = class extends Ge {
  constructor(e) {
    super(e);
    typeof e.cropping == "number" ? this.cropping = [[e.cropping, e.cropping], [e.cropping, e.cropping]] : typeof e.cropping[0] == "number" ? this.cropping = [[e.cropping[0], e.cropping[0]], [e.cropping[1], e.cropping[1]]] : this.cropping = e.cropping, this.dataFormat = e.dataFormat === void 0 ? "channelsLast" : e.dataFormat, this.inputSpec = [{ ndim: 4 }];
  }
  computeOutputShape(e) {
    return this.dataFormat === "channelsFirst" ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
  }
  call(e, t) {
    return j2(() => {
      if (e = Oe(e), this.dataFormat === "channelsLast") {
        let n10 = Uc(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
        return Uc(n10, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      } else {
        let n10 = Uc(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
        return Uc(n10, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }
  getConfig() {
    let e = { cropping: this.cropping, dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
ny.className = "Cropping2D";
ae2.registerClass(ny);
var sy = class extends Ge {
  constructor(e) {
    super(e);
    this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{ ndim: 4 }], this.size = e.size == null ? this.DEFAULT_SIZE : e.size, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, St(this.dataFormat), this.interpolation = e.interpolation == null ? "nearest" : e.interpolation, WM(this.interpolation);
  }
  computeOutputShape(e) {
    if (this.dataFormat === "channelsFirst") {
      let t = e[2] == null ? null : this.size[0] * e[2], n10 = e[3] == null ? null : this.size[1] * e[3];
      return [e[0], e[1], t, n10];
    } else {
      let t = e[1] == null ? null : this.size[0] * e[1], n10 = e[2] == null ? null : this.size[1] * e[2];
      return [e[0], t, n10, e[3]];
    }
  }
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e), s10 = n10.shape;
      if (this.dataFormat === "channelsFirst") {
        n10 = qe(n10, [0, 2, 3, 1]);
        let r10 = this.size[0] * s10[2], a10 = this.size[1] * s10[3], i10 = this.interpolation === "nearest" ? ds.resizeNearestNeighbor(n10, [r10, a10]) : ds.resizeBilinear(n10, [r10, a10]);
        return qe(i10, [0, 3, 1, 2]);
      } else {
        let r10 = this.size[0] * s10[1], a10 = this.size[1] * s10[2];
        return this.interpolation === "nearest" ? ds.resizeNearestNeighbor(n10, [r10, a10]) : ds.resizeBilinear(n10, [r10, a10]);
      }
    });
  }
  getConfig() {
    let e = { size: this.size, dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
sy.className = "UpSampling2D";
ae2.registerClass(sy);
function AB(e, t, n10 = [1, 1], s10 = "valid", r10, a10) {
  return j2(() => {
    r10 == null && (r10 = bs()), St(r10);
    let i10 = Yb(e, r10);
    if (e.rank !== 4)
      throw new U2(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);
    if (t.rank !== 4)
      throw new U2(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
    return i10 = pp(i10, t, n10, s10 === "same" ? "same" : "valid", "NHWC", a10), r10 === "channelsFirst" && (i10 = qe(i10, [0, 3, 1, 2])), i10;
  });
}
var ry = class extends Qb {
  constructor(e) {
    super(2, e);
    this.depthwiseKernel = null, this.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier, this.depthwiseInitializer = ht(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Pt(e.depthwiseConstraint), this.depthwiseRegularizer = ft(e.depthwiseRegularizer);
  }
  build(e) {
    if (e = nt(e), e.length < 4)
      throw new U2(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);
    let t = this.dataFormat === "channelsFirst" ? 1 : 3;
    if (e[t] == null || e[t] < 0)
      throw new U2(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);
    let n10 = e[t], s10 = [this.kernelSize[0], this.kernelSize[1], n10, this.depthMultiplier];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", s10, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n10 * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  call(e, t) {
    return j2(() => {
      e = Oe(e);
      let n10 = AB(e, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
      return this.useBias && (n10 = ws(n10, this.bias.read(), this.dataFormat)), this.activation != null && (n10 = this.activation.apply(n10)), n10;
    });
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = this.dataFormat === "channelsFirst" ? e[2] : e[1], n10 = this.dataFormat === "channelsFirst" ? e[3] : e[2], s10 = this.dataFormat === "channelsFirst" ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier, r10 = ms(t, this.kernelSize[0], this.padding, this.strides[0]), a10 = ms(n10, this.kernelSize[1], this.padding, this.strides[1]);
    return this.dataFormat === "channelsFirst" ? [e[0], s10, r10, a10] : [e[0], r10, a10, s10];
  }
  getConfig() {
    let e = super.getConfig();
    return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = yt(this.depthwiseInitializer), e.depthwiseRegularizer = at(this.depthwiseRegularizer), e.depthwiseConstraint = Ot(this.depthwiseRegularizer), e;
  }
};
ry.className = "DepthwiseConv2D";
ae2.registerClass(ry);
function N0(e, t, n10, s10) {
  if (Array.isArray(e)) {
    if (t != null || n10 != null)
      throw new U2("When inputs is an array, neither initialState or constants should be provided");
    s10 != null && (n10 = e.slice(e.length - s10, e.length), e = e.slice(0, e.length - s10)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }
  function r10(a10) {
    return a10 == null || Array.isArray(a10) ? a10 : [a10];
  }
  return t = r10(t), n10 = r10(n10), { inputs: e, initialState: t, constants: n10 };
}
function T0(e, t, n10, s10 = false, r10, a10, i10 = false, o10 = false) {
  return j2(() => {
    let u10 = t.shape.length;
    if (u10 < 3)
      throw new U2(`Input should be at least 3D, but is ${u10}D.`);
    let l10 = [1, 0].concat(ys(2, u10));
    if (t = qe(t, l10), a10 != null)
      throw new Fe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    i10 && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), r10 != null && (r10 = ce2(ce2(r10, "bool"), "float32"), r10.rank === u10 - 1 && (r10 = On(r10, -1)), r10 = qe(r10, l10)), s10 && (t = Yn(t, 0), r10 != null && (r10 = Yn(r10, 0)));
    let c10 = [], p10, d10 = n10, h10 = t.shape[0], f10 = Fs(t), m10;
    r10 != null && (m10 = Fs(r10));
    for (let b10 = 0; b10 < h10; ++b10) {
      let y10 = f10[b10], v10 = j2(() => e(y10, d10));
      if (r10 == null)
        p10 = v10[0], d10 = v10[1];
      else {
        let x10 = j2(() => {
          let k10 = m10[b10], C10 = ge2(Xn(k10), k10), T10 = ie2(V2(v10[0], k10), V2(d10[0], C10)), E10 = d10.map((A10, P10) => ie2(V2(v10[1][P10], k10), V2(A10, C10)));
          return { output: T10, newStates: E10 };
        });
        p10 = x10.output, d10 = x10.newStates;
      }
      o10 && c10.push(p10);
    }
    let g10;
    return o10 && (g10 = Qn(c10, 1)), [p10, g10, d10];
  });
}
var $0 = class extends Ge {
  constructor(e) {
    super(e);
    let t;
    if (e.cell == null)
      throw new U2("cell property is missing for the constructor of RNN.");
    if (Array.isArray(e.cell) ? t = new Bp({ cells: e.cell }) : t = e.cell, t.stateSize == null)
      throw new U2("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    this.cell = t, this.returnSequences = e.returnSequences == null ? false : e.returnSequences, this.returnState = e.returnState == null ? false : e.returnState, this.goBackwards = e.goBackwards == null ? false : e.goBackwards, this._stateful = e.stateful == null ? false : e.stateful, this.unroll = e.unroll == null ? false : e.unroll, this.supportsMasking = true, this.inputSpec = [new Dt({ ndim: 3 })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
  }
  getStates() {
    if (this.states_ == null) {
      let e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      return ys(0, e).map((t) => null);
    } else
      return this.states_;
  }
  setStates(e) {
    this.states_ = e;
  }
  computeOutputShape(e) {
    gm(e) && (e = e[0]), e = e;
    let t = this.cell.stateSize;
    Array.isArray(t) || (t = [t]);
    let n10 = t[0], s10;
    if (this.returnSequences ? s10 = [e[0], e[1], n10] : s10 = [e[0], n10], this.returnState) {
      let r10 = [];
      for (let a10 of t)
        r10.push([e[0], a10]);
      return [s10].concat(r10);
    } else
      return s10;
  }
  computeMask(e, t) {
    return j2(() => {
      Array.isArray(t) && (t = t[0]);
      let n10 = this.returnSequences ? t : null;
      if (this.returnState) {
        let s10 = this.states.map((r10) => null);
        return [n10].concat(s10);
      } else
        return n10;
    });
  }
  get states() {
    if (this.states_ == null) {
      let e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [];
      for (let n10 = 0; n10 < e; ++n10)
        t.push(null);
      return t;
    } else
      return this.states_;
  }
  set states(e) {
    this.states_ = e;
  }
  build(e) {
    if (this.numConstants != null)
      throw new Fe("Constants support is not implemented in RNN yet.");
    gm(e) && (e = e[0]), e = e;
    let n10 = this.stateful ? e[0] : null, s10 = e.slice(2);
    this.inputSpec[0] = new Dt({ shape: [n10, null, ...s10] });
    let r10 = [e[0]].concat(e.slice(2));
    this.cell.build(r10);
    let a10;
    if (Array.isArray(this.cell.stateSize) ? a10 = this.cell.stateSize : a10 = [this.cell.stateSize], this.stateSpec != null) {
      if (!w2.arraysEqual(this.stateSpec.map((i10) => i10.shape[i10.shape.length - 1]), a10))
        throw new U2(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
    } else
      this.stateSpec = a10.map((i10) => new Dt({ shape: [null, i10] }));
    this.stateful && this.resetStates();
  }
  resetStates(e, t = false) {
    j2(() => {
      if (!this.stateful)
        throw new Vs("Cannot call resetStates() on an RNN Layer that is not stateful.");
      let n10 = this.inputSpec[0].shape[0];
      if (n10 == null)
        throw new U2("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.states_ == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((s10) => $t([n10, s10])) : this.states_ = [$t([n10, this.cell.stateSize])];
      else if (e == null)
        Re2(this.states_), this.keptStates != null && (Re2(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((s10) => $t([n10, s10])) : this.states_[0] = $t([n10, this.cell.stateSize]);
      else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length)
          throw new U2(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
        t === true ? this.keptStates.push(this.states_.slice()) : Re2(this.states_);
        for (let s10 = 0; s10 < this.states_.length; ++s10) {
          let r10 = e[s10], a10 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[s10] : this.cell.stateSize, i10 = [n10, a10];
          if (!w2.arraysEqual(r10.shape, i10))
            throw new U2(`State ${s10} is incompatible with layer ${this.name}: expected shape=${i10}, received shape=${r10.shape}`);
          this.states_[s10] = r10;
        }
      }
      this.states_ = this.states_.map((s10) => Ht(s10.clone()));
    });
  }
  apply(e, t) {
    let n10 = t == null ? null : t.initialState, s10 = t == null ? null : t.constants;
    t == null && (t = {});
    let r10 = N0(e, n10, s10, this.numConstants);
    e = r10.inputs, n10 = r10.initialState, s10 = r10.constants;
    let a10 = [], i10 = [];
    if (n10 != null) {
      t.initialState = n10, a10 = a10.concat(n10), this.stateSpec = [];
      for (let u10 of n10)
        this.stateSpec.push(new Dt({ shape: u10.shape }));
      i10 = i10.concat(this.stateSpec);
    }
    if (s10 != null && (t.constants = s10, a10 = a10.concat(s10), this.numConstants = s10.length), a10[0] instanceof $s) {
      let u10 = [e].concat(a10), l10 = this.inputSpec.concat(i10), c10 = this.inputSpec;
      this.inputSpec = l10;
      let p10 = super.apply(u10, t);
      return this.inputSpec = c10, p10;
    } else
      return super.apply(e, t);
  }
  call(e, t) {
    return j2(() => {
      let n10 = t == null ? null : t.mask, s10 = t == null ? null : t.training, r10 = t == null ? null : t.initialState;
      e = Oe(e), r10 == null && (this.stateful ? r10 = this.states_ : r10 = this.getInitialState(e));
      let a10 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (r10.length !== a10)
        throw new U2(`RNN Layer has ${a10} state(s) but was passed ${r10.length} initial state(s).`);
      this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      let i10 = { training: s10 }, u10 = T0((h10, f10) => {
        let m10 = this.cell.call([h10].concat(f10), i10);
        return [m10[0], m10.slice(1)];
      }, e, r10, this.goBackwards, n10, null, this.unroll, this.returnSequences), l10 = u10[0], c10 = u10[1], p10 = u10[2];
      this.stateful && this.resetStates(p10, s10);
      let d10 = this.returnSequences ? c10 : l10;
      return this.returnState ? [d10].concat(p10) : d10;
    });
  }
  getInitialState(e) {
    return j2(() => {
      let t = $t(e.shape);
      return t = ye2(t, [1, 2]), t = Ll(t), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((n10) => n10 > 1 ? fm(t, [1, n10]) : t) : this.cell.stateSize > 1 ? [fm(t, [1, this.cell.stateSize])] : [t];
    });
  }
  get trainableWeights() {
    return this.trainable ? this.cell.trainableWeights : [];
  }
  get nonTrainableWeights() {
    return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
  }
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.cell != null && this.cell.setFastWeightInitDuringBuild(e);
  }
  getConfig() {
    let e = super.getConfig(), t = { returnSequences: this.returnSequences, returnState: this.returnState, goBackwards: this.goBackwards, stateful: this.stateful, unroll: this.unroll };
    this.numConstants != null && (t.numConstants = this.numConstants);
    let n10 = this.cell.getConfig();
    return this.getClassName() === $0.className && (t.cell = { className: this.cell.getClassName(), config: n10 }), { ...n10, ...e, ...t };
  }
  static fromConfig(e, t, n10 = {}) {
    let s10 = t.cell, r10 = fs(s10, n10);
    return new e(Object.assign(t, { cell: r10 }));
  }
};
var _r = $0;
_r.className = "RNN";
ae2.registerClass(_r);
var Gl = class extends Ge {
};
var Mp = class extends Gl {
  constructor(e) {
    super(e);
    this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Bt(this.units, "units"), this.activation = yr(e.activation == null ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = ht(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = ht(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = ht(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = ft(e.kernelRegularizer), this.recurrentRegularizer = ft(e.recurrentRegularizer), this.biasRegularizer = ft(e.biasRegularizer), this.kernelConstraint = Pt(e.kernelConstraint), this.recurrentConstraint = Pt(e.recurrentConstraint), this.biasConstraint = Pt(e.biasConstraint), this.dropout = Qi([1, gr([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Qi([1, gr([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    e = nt(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  call(e, t) {
    return j2(() => {
      if (e = e, e.length !== 2)
        throw new U2(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);
      let n10 = e[1];
      e = e[0];
      let s10 = t.training == null ? false : t.training;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = vr({ ones: () => Xn(e), rate: this.dropout, training: s10, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = vr({ ones: () => Xn(n10), rate: this.recurrentDropout, training: s10, dropoutFunc: this.dropoutFunc }));
      let r10, a10 = this.dropoutMask, i10 = this.recurrentDropoutMask;
      a10 != null ? r10 = Es(V2(e, a10), this.kernel.read()) : r10 = Es(e, this.kernel.read()), this.bias != null && (r10 = ws(r10, this.bias.read())), i10 != null && (n10 = V2(n10, i10));
      let o10 = ie2(r10, Es(n10, this.recurrentKernel.read()));
      return this.activation != null && (o10 = this.activation.apply(o10)), [o10, o10];
    });
  }
  getConfig() {
    let e = super.getConfig(), t = { units: this.units, activation: br(this.activation), useBias: this.useBias, kernelInitializer: yt(this.kernelInitializer), recurrentInitializer: yt(this.recurrentInitializer), biasInitializer: yt(this.biasInitializer), kernelRegularizer: at(this.kernelRegularizer), recurrentRegularizer: at(this.recurrentRegularizer), biasRegularizer: at(this.biasRegularizer), activityRegularizer: at(this.activityRegularizer), kernelConstraint: Ot(this.kernelConstraint), recurrentConstraint: Ot(this.recurrentConstraint), biasConstraint: Ot(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout };
    return { ...e, ...t };
  }
};
Mp.className = "SimpleRNNCell";
ae2.registerClass(Mp);
var ay = class extends _r {
  constructor(e) {
    e.cell = new Mp(e);
    super(e);
  }
  call(e, t) {
    return j2(() => {
      this.cell.dropoutMask != null && (Re2(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Re2(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      let n10 = t == null ? null : t.mask, s10 = t == null ? null : t.training, r10 = t == null ? null : t.initialState;
      return super.call(e, { mask: n10, training: s10, initialState: r10 });
    });
  }
  static fromConfig(e, t) {
    return new e(t);
  }
};
ay.className = "SimpleRNN";
ae2.registerClass(ay);
var Lp = class extends Gl {
  constructor(e) {
    super(e);
    if (this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter)
      throw new U2("GRUCell does not support reset_after parameter set to true.");
    this.units = e.units, Bt(this.units, "units"), this.activation = yr(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = yr(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = ht(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = ht(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = ht(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = ft(e.kernelRegularizer), this.recurrentRegularizer = ft(e.recurrentRegularizer), this.biasRegularizer = ft(e.biasRegularizer), this.kernelConstraint = Pt(e.kernelConstraint), this.recurrentConstraint = Pt(e.recurrentConstraint), this.biasConstraint = Pt(e.biasConstraint), this.dropout = Qi([1, gr([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Qi([1, gr([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    e = nt(e);
    let t = e[e.length - 1];
    this.kernel = this.addWeight("kernel", [t, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  call(e, t) {
    return j2(() => {
      if (e = e, e.length !== 2)
        throw new U2(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);
      let n10 = t.training == null ? false : t.training, s10 = e[1];
      e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = vr({ ones: () => Xn(e), rate: this.dropout, training: n10, count: 3, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = vr({ ones: () => Xn(s10), rate: this.recurrentDropout, training: n10, count: 3, dropoutFunc: this.dropoutFunc }));
      let r10 = this.dropoutMask, a10 = this.recurrentDropoutMask, i10, o10, u10;
      0 < this.dropout && this.dropout < 1 && (e = V2(e, r10[0]));
      let l10 = Es(e, this.kernel.read());
      this.useBias && (l10 = ws(l10, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (s10 = V2(s10, a10[0]));
      let c10 = this.recurrentKernel.read(), [p10, d10] = Ln(c10, [2 * this.units, this.units], c10.rank - 1), h10 = Es(s10, p10), [f10, m10, g10] = Ln(l10, 3, l10.rank - 1), [b10, y10] = Ln(h10, 2, h10.rank - 1);
      i10 = this.recurrentActivation.apply(ie2(f10, b10)), o10 = this.recurrentActivation.apply(ie2(m10, y10));
      let v10 = Es(V2(o10, s10), d10);
      u10 = this.activation.apply(ie2(g10, v10));
      let x10 = ie2(V2(i10, s10), V2(ie2(1, kt(i10)), u10));
      return [x10, x10];
    });
  }
  getConfig() {
    let e = super.getConfig(), t = { units: this.units, activation: br(this.activation), recurrentActivation: br(this.recurrentActivation), useBias: this.useBias, kernelInitializer: yt(this.kernelInitializer), recurrentInitializer: yt(this.recurrentInitializer), biasInitializer: yt(this.biasInitializer), kernelRegularizer: at(this.kernelRegularizer), recurrentRegularizer: at(this.recurrentRegularizer), biasRegularizer: at(this.biasRegularizer), activityRegularizer: at(this.activityRegularizer), kernelConstraint: Ot(this.kernelConstraint), recurrentConstraint: Ot(this.recurrentConstraint), biasConstraint: Ot(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation, resetAfter: false };
    return { ...e, ...t };
  }
};
Lp.className = "GRUCell";
ae2.registerClass(Lp);
var iy = class extends _r {
  constructor(e) {
    e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Lp(e);
    super(e);
  }
  call(e, t) {
    return j2(() => {
      this.cell.dropoutMask != null && (Re2(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Re2(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      let n10 = t == null ? null : t.mask, s10 = t == null ? null : t.training, r10 = t == null ? null : t.initialState;
      return super.call(e, { mask: n10, training: s10, initialState: r10 });
    });
  }
  static fromConfig(e, t) {
    return t.implmentation === 0 && (t.implementation = 1), new e(t);
  }
};
iy.className = "GRU";
ae2.registerClass(iy);
var Hl = class extends Gl {
  constructor(e) {
    super(e);
    this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Bt(this.units, "units"), this.activation = yr(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = yr(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = ht(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = ht(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = ht(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = ft(e.kernelRegularizer), this.recurrentRegularizer = ft(e.recurrentRegularizer), this.biasRegularizer = ft(e.biasRegularizer), this.kernelConstraint = Pt(e.kernelConstraint), this.recurrentConstraint = Pt(e.recurrentConstraint), this.biasConstraint = Pt(e.biasConstraint), this.dropout = Qi([1, gr([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Qi([1, gr([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    var t;
    e = nt(e);
    let n10 = e[e.length - 1];
    this.kernel = this.addWeight("kernel", [n10, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    let s10;
    if (this.useBias) {
      if (this.unitForgetBias) {
        let r10 = this.biasInitializer, a10 = this.units;
        s10 = new (t = class extends es {
          apply(i10, o10) {
            let u10 = r10.apply([a10]), l10 = new Cp().apply([a10]), c10 = r10.apply([a10 * 2]);
            return Cx(Cx(u10, l10), c10);
          }
        }, t.className = "CustomInit", t)();
      } else
        s10 = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.units * 4], null, s10, this.biasRegularizer, true, this.biasConstraint);
    } else
      this.bias = null;
    this.built = true;
  }
  call(e, t) {
    return j2(() => {
      let n10 = t.training == null ? false : t.training;
      if (e = e, e.length !== 3)
        throw new U2(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
      let s10 = e[1], r10 = e[2];
      e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = vr({ ones: () => Xn(e), rate: this.dropout, training: n10, count: 4, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = vr({ ones: () => Xn(s10), rate: this.recurrentDropout, training: n10, count: 4, dropoutFunc: this.dropoutFunc }));
      let a10 = this.dropoutMask, i10 = this.recurrentDropoutMask, o10, u10, l10, c10;
      0 < this.dropout && this.dropout < 1 && (e = V2(e, a10[0]));
      let p10 = Es(e, this.kernel.read());
      0 < this.recurrentDropout && this.recurrentDropout < 1 && (s10 = V2(s10, i10[0])), p10 = ie2(p10, Es(s10, this.recurrentKernel.read())), this.useBias && (p10 = ws(p10, this.bias.read()));
      let [d10, h10, f10, m10] = Ln(p10, 4, p10.rank - 1);
      o10 = this.recurrentActivation.apply(d10), u10 = this.recurrentActivation.apply(h10), l10 = ie2(V2(u10, r10), V2(o10, this.activation.apply(f10))), c10 = this.recurrentActivation.apply(m10);
      let g10 = V2(c10, this.activation.apply(l10));
      return [g10, g10, l10];
    });
  }
  getConfig() {
    let e = super.getConfig(), t = { units: this.units, activation: br(this.activation), recurrentActivation: br(this.recurrentActivation), useBias: this.useBias, kernelInitializer: yt(this.kernelInitializer), recurrentInitializer: yt(this.recurrentInitializer), biasInitializer: yt(this.biasInitializer), unitForgetBias: this.unitForgetBias, kernelRegularizer: at(this.kernelRegularizer), recurrentRegularizer: at(this.recurrentRegularizer), biasRegularizer: at(this.biasRegularizer), activityRegularizer: at(this.activityRegularizer), kernelConstraint: Ot(this.kernelConstraint), recurrentConstraint: Ot(this.recurrentConstraint), biasConstraint: Ot(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation };
    return { ...e, ...t };
  }
};
Hl.className = "LSTMCell";
ae2.registerClass(Hl);
var oy = class extends _r {
  constructor(e) {
    e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Hl(e);
    super(e);
  }
  call(e, t) {
    return j2(() => {
      this.cell.dropoutMask != null && (Re2(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Re2(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      let n10 = t == null ? null : t.mask, s10 = t == null ? null : t.training, r10 = t == null ? null : t.initialState;
      return super.call(e, { mask: n10, training: s10, initialState: r10 });
    });
  }
  static fromConfig(e, t) {
    return t.implmentation === 0 && (t.implementation = 1), new e(t);
  }
};
oy.className = "LSTM";
ae2.registerClass(oy);
var Bp = class extends Gl {
  constructor(e) {
    super(e);
    this.cells = e.cells;
  }
  get stateSize() {
    let e = [];
    for (let t of this.cells.slice().reverse())
      Array.isArray(t.stateSize) ? e.push(...t.stateSize) : e.push(t.stateSize);
    return e;
  }
  call(e, t) {
    return j2(() => {
      e = e;
      let n10 = e.slice(1), s10 = [];
      for (let i10 of this.cells.slice().reverse())
        Array.isArray(i10.stateSize) ? s10.push(n10.splice(0, i10.stateSize.length)) : s10.push(n10.splice(0, 1));
      s10.reverse();
      let r10 = [], a10;
      for (let i10 = 0; i10 < this.cells.length; ++i10) {
        let o10 = this.cells[i10];
        n10 = s10[i10], i10 === 0 ? a10 = [e[0]].concat(n10) : a10 = [a10[0]].concat(n10), a10 = o10.call(a10, t), r10.push(a10.slice(1));
      }
      n10 = [];
      for (let i10 of r10.slice().reverse())
        n10.push(...i10);
      return [a10[0]].concat(n10);
    });
  }
  build(e) {
    gm(e) && (e = e[0]), e = e;
    let t;
    this.cells.forEach((n10, s10) => {
      Zr(`RNNCell_${s10}`, () => {
        n10.build(e), Array.isArray(n10.stateSize) ? t = n10.stateSize[0] : t = n10.stateSize, e = [e[0], t];
      });
    }), this.built = true;
  }
  getConfig() {
    let e = super.getConfig(), t = (r10) => ({ className: r10.getClassName(), config: r10.getConfig() }), s10 = { cells: this.cells.map(t) };
    return { ...e, ...s10 };
  }
  static fromConfig(e, t, n10 = {}) {
    let s10 = [];
    for (let r10 of t.cells)
      s10.push(fs(r10, n10));
    return new e({ cells: s10 });
  }
  get trainableWeights() {
    if (!this.trainable)
      return [];
    let e = [];
    for (let t of this.cells)
      e.push(...t.trainableWeights);
    return e;
  }
  get nonTrainableWeights() {
    let e = [];
    for (let t of this.cells)
      e.push(...t.nonTrainableWeights);
    if (!this.trainable) {
      let t = [];
      for (let n10 of this.cells)
        t.push(...n10.trainableWeights);
      return t.concat(e);
    }
    return e;
  }
  getWeights() {
    let e = [];
    for (let t of this.cells)
      e.push(...t.weights);
    return bm(e);
  }
  setWeights(e) {
    let t = [];
    for (let n10 of this.cells) {
      let s10 = n10.weights.length, r10 = e.splice(s10);
      for (let a10 = 0; a10 < n10.weights.length; ++a10)
        t.push([n10.weights[a10], r10[a10]]);
    }
    Fb(t);
  }
};
Bp.className = "StackedRNNCells";
ae2.registerClass(Bp);
function vr(e) {
  let { ones: t, rate: n10, training: s10 = false, count: r10 = 1, dropoutFunc: a10 } = e, i10 = () => a10 != null ? a10(t(), n10) : WI(t(), n10), o10 = () => Vl(i10, t, s10);
  return !r10 || r10 <= 1 ? Ht(o10().clone()) : Array(r10).fill(void 0).map(o10).map((l10) => Ht(l10.clone()));
}
var _0 = class extends _r {
  constructor(e) {
    if (e.unroll)
      throw new Fe("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(e.cell))
      throw new Fe("It is not possible at the moment to stack convolutional cells.");
    super(e);
    this.inputSpec = [new Dt({ ndim: 5 })];
  }
  call(e, t) {
    return j2(() => {
      if (this.cell.dropoutMask != null && (Re2(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Re2(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), t && t.constants)
        throw new U2("ConvRNN2D cell does not support constants");
      let n10 = t == null ? null : t.mask, s10 = t == null ? null : t.training, r10 = t == null ? null : t.initialState;
      return super.call(e, { mask: n10, training: s10, initialState: r10 });
    });
  }
  computeOutputShape(e) {
    let t = this.computeSingleOutputShape(e);
    return this.returnSequences || (t = [t[0], ...t.slice(2)]), this.returnState && (t = [t, ...Array(2).fill([e[0], ...t.slice(-3)])]), t;
  }
  getInitialState(e) {
    return j2(() => {
      let { stateSize: t } = this.cell, n10 = e.shape, s10 = this.computeSingleOutputShape(n10), r10 = [s10[0], ...s10.slice(2)], a10 = $t(r10);
      return Array.isArray(t) ? Array(t.length).fill(a10) : [a10];
    });
  }
  resetStates(e, t = false) {
    j2(() => {
      if (!this.stateful)
        throw new Vs("Cannot call resetStates() on an RNN Layer that is not stateful.");
      let n10 = this.inputSpec[0].shape, s10 = this.computeSingleOutputShape(n10), r10 = [s10[0], ...s10.slice(2)];
      if (n10[0] == null)
        throw new U2("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.getStates() == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => $t(r10)) : this.states_ = [$t(r10)];
      else if (e == null)
        Re2(this.states_), this.keptStates != null && (Re2(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => $t(r10)) : this.states_[0] = $t(r10);
      else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length)
          throw new U2(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
        t ? this.keptStates.push(this.states_.slice()) : Re2(this.states_);
        for (let i10 = 0; i10 < this.states_.length; ++i10) {
          let o10 = e[i10], u10 = r10;
          if (!w2.arraysEqual(o10.shape, u10))
            throw new U2(`State ${i10} is incompatible with layer ${this.name}: expected shape=${u10}, received shape=${o10.shape}`);
          this.states_[i10] = o10;
        }
      }
      this.states_ = this.states_.map((i10) => Ht(i10.clone()));
    });
  }
  computeSingleOutputShape(e) {
    let { dataFormat: t, filters: n10, kernelSize: s10, padding: r10, strides: a10, dilationRate: i10 } = this.cell, o10 = t === "channelsFirst", u10 = e[o10 ? 3 : 2], l10 = e[o10 ? 4 : 3], c10 = ms(u10, s10[0], r10, a10[0], i10[0]), p10 = ms(l10, s10[1], r10, a10[1], i10[1]);
    return [...e.slice(0, 2), ...o10 ? [n10, c10, p10] : [c10, p10, n10]];
  }
};
_0.className = "ConvRNN2D";
var Vp = class extends Hl {
  constructor(e) {
    let { filters: t, kernelSize: n10, strides: s10, padding: r10, dataFormat: a10, dilationRate: i10 } = e;
    super({ ...e, units: t });
    this.filters = t, Bt(this.filters, "filters"), this.kernelSize = Ki(n10, 2, "kernelSize"), this.kernelSize.forEach((o10) => Bt(o10, "kernelSize")), this.strides = Ki(s10 || 1, 2, "strides"), this.strides.forEach((o10) => Bt(o10, "strides")), this.padding = r10 || "valid", Un(this.padding), this.dataFormat = a10 || "channelsLast", St(this.dataFormat), this.dilationRate = Ki(i10 || 1, 2, "dilationRate"), this.dilationRate.forEach((o10) => Bt(o10, "dilationRate"));
  }
  build(e) {
    var t;
    e = nt(e);
    let n10 = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[n10] == null)
      throw new U2(`The channel dimension of the input should be defined. Found ${e[n10]}`);
    let s10 = e[n10], r10 = 4, a10 = this.kernelSize.concat([s10, this.filters * r10]);
    this.kernel = this.addWeight("kernel", a10, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    let i10 = this.kernelSize.concat([this.filters, this.filters * r10]);
    if (this.recurrentKernel = this.addWeight("recurrent_kernel", i10, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
      let o10;
      if (this.unitForgetBias) {
        let u10 = this.biasInitializer, l10 = this.filters;
        o10 = new (t = class extends es {
          apply(c10, p10) {
            let d10 = u10.apply([l10]), h10 = zn([l10]), f10 = u10.apply([l10 * 2]);
            return Nb([d10, h10, f10]);
          }
        }, t.className = "CustomInit", t)();
      } else
        o10 = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.filters * r10], null, o10, this.biasRegularizer, true, this.biasConstraint);
    }
    this.built = true;
  }
  call(e, t) {
    return j2(() => {
      if (e.length !== 3)
        throw new U2(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
      let n10 = t.training || false, s10 = e[0], r10 = e[1], a10 = e[2], i10 = 4;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = vr({ ones: () => Xn(s10), rate: this.dropout, training: n10, count: i10, dropoutFunc: this.dropoutFunc }));
      let o10 = this.dropoutMask, u10 = (Z10, te2, ee2) => !te2 || !te2[ee2] ? Z10 : V2(te2[ee2], Z10), l10 = u10(s10, o10, 0), c10 = u10(s10, o10, 1), p10 = u10(s10, o10, 2), d10 = u10(s10, o10, 3);
      0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = vr({ ones: () => Xn(r10), rate: this.recurrentDropout, training: n10, count: i10, dropoutFunc: this.dropoutFunc }));
      let h10 = this.recurrentDropoutMask, f10 = u10(r10, h10, 0), m10 = u10(r10, h10, 1), g10 = u10(r10, h10, 2), b10 = u10(r10, h10, 3), y10 = 3, [v10, x10, k10, C10] = Ln(this.kernel.read(), i10, y10), [T10, E10, A10, P10] = this.useBias ? Ln(this.bias.read(), i10) : [null, null, null, null];
      l10 = this.inputConv(l10, v10, T10, this.padding), c10 = this.inputConv(c10, x10, E10, this.padding), p10 = this.inputConv(p10, k10, A10, this.padding), d10 = this.inputConv(d10, C10, P10, this.padding);
      let [R10, F10, $10, z10] = Ln(this.recurrentKernel.read(), i10, y10);
      f10 = this.recurrentConv(f10, R10), m10 = this.recurrentConv(m10, F10), g10 = this.recurrentConv(g10, $10), b10 = this.recurrentConv(b10, z10);
      let W10 = this.recurrentActivation.apply(ie2(l10, f10)), q10 = this.recurrentActivation.apply(ie2(c10, m10)), K10 = ie2(V2(q10, a10), V2(W10, this.activation.apply(ie2(p10, g10)))), Y10 = V2(this.recurrentActivation.apply(ie2(d10, b10)), this.activation.apply(K10));
      return [Y10, Y10, K10];
    });
  }
  getConfig() {
    let { units: e, ...t } = super.getConfig(), n10 = { filters: this.filters, kernelSize: this.kernelSize, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, strides: this.strides };
    return { ...t, ...n10 };
  }
  inputConv(e, t, n10, s10) {
    let r10 = ua(e, t, this.strides, s10 || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
    return n10 ? ws(r10, n10, this.dataFormat) : r10;
  }
  recurrentConv(e, t) {
    return ua(e, t, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
  }
};
Vp.className = "ConvLSTM2DCell";
ae2.registerClass(Vp);
var uy = class extends _0 {
  constructor(e) {
    let t = new Vp(e);
    super({ ...e, cell: t });
  }
  static fromConfig(e, t) {
    return new e(t);
  }
};
uy.className = "ConvLSTM2D";
ae2.registerClass(uy);
var Wp = class extends Ge {
  constructor(e) {
    super(e);
    this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = true;
  }
  getNoiseShape(e) {
    if (this.noiseShape == null)
      return this.noiseShape;
    let t = e.shape, n10 = [];
    for (let s10 = 0; s10 < this.noiseShape.length; ++s10)
      n10.push(this.noiseShape[s10] == null ? t[s10] : this.noiseShape[s10]);
    return n10;
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      if (0 < this.rate && this.rate < 1) {
        let s10 = t.training == null ? false : t.training, r10 = this.getNoiseShape(n10);
        return Vl(() => WI(n10, this.rate, r10, this.seed), () => n10, s10);
      }
      return e;
    });
  }
  getConfig() {
    let e = { rate: this.rate, noiseShape: this.noiseShape, seed: this.seed }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
  dispose() {
    return super.dispose();
  }
};
Wp.className = "Dropout";
ae2.registerClass(Wp);
var ly = class extends Wp {
  constructor(e) {
    super(e);
    this.inputSpec = [{ ndim: 3 }];
  }
  getNoiseShape(e) {
    let t = e.shape;
    return [t[0], 1, t[2]];
  }
};
ly.className = "SpatialDropout1D";
ae2.registerClass(ly);
var cy = class extends Ge {
  constructor(e) {
    super(e);
    if (this.activation = null, this.useBias = true, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.batchInputShape == null && e.inputShape == null && e.inputDim != null) {
      let t = null;
      e.batchSize != null && (t = e.batchSize), this.batchInputShape = [t, e.inputDim];
    }
    this.units = e.units, Bt(this.units, "units"), this.activation = yr(e.activation), e.useBias != null && (this.useBias = e.useBias), this.kernelInitializer = ht(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = ht(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Pt(e.kernelConstraint), this.biasConstraint = Pt(e.biasConstraint), this.kernelRegularizer = ft(e.kernelRegularizer), this.biasRegularizer = ft(e.biasRegularizer), this.activityRegularizer = ft(e.activityRegularizer), this.supportsMasking = true, this.inputSpec = [{ minNDim: 2 }];
  }
  build(e) {
    e = nt(e);
    let t = e[e.length - 1];
    this.kernel == null && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: { [-1]: t } }], this.built = true;
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = e.slice();
    return t[t.length - 1] = this.units, t;
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e), s10 = PI(this.activation.getClassName()), r10;
      return s10 != null ? r10 = Es(n10, this.kernel.read(), s10, this.bias ? this.bias.read() : null) : (r10 = Es(n10, this.kernel.read()), this.bias != null && (r10 = ws(r10, this.bias.read())), this.activation != null && (r10 = this.activation.apply(r10))), r10;
    });
  }
  getConfig() {
    let e = { units: this.units, activation: br(this.activation), useBias: this.useBias, kernelInitializer: yt(this.kernelInitializer), biasInitializer: yt(this.biasInitializer), kernelRegularizer: at(this.kernelRegularizer), biasRegularizer: at(this.biasRegularizer), activityRegularizer: at(this.activityRegularizer), kernelConstraint: Ot(this.kernelConstraint), biasConstraint: Ot(this.biasConstraint) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
cy.className = "Dense";
ae2.registerClass(cy);
var dy = class extends Ge {
  constructor(e) {
    e = e || {};
    super(e);
    this.inputSpec = [{ minNDim: 3 }], this.dataFormat = e.dataFormat;
  }
  computeOutputShape(e) {
    e = nt(e);
    for (let t of e.slice(1))
      if (t == null)
        throw new U2(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
    return [e[0], dr(e, 1)];
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      if (this.dataFormat === "channelsFirst" && n10.rank > 1) {
        let s10 = [0];
        for (let r10 = 2; r10 < n10.rank; ++r10)
          s10.push(r10);
        s10.push(1), n10 = qe(n10, s10);
      }
      return KM(n10);
    });
  }
  getConfig() {
    let e = {};
    this.dataFormat != null && (e.dataFormat = this.dataFormat);
    let t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
dy.className = "Flatten";
ae2.registerClass(dy);
var py2 = class extends Ge {
  constructor(e) {
    super(e);
    this.supportsMasking = true, this.activation = yr(e.activation);
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      return this.activation.apply(n10);
    });
  }
  getConfig() {
    let e = { activation: br(this.activation) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
py2.className = "Activation";
ae2.registerClass(py2);
var hy = class extends Ge {
  constructor(e) {
    super(e);
    this.n = e.n, this.inputSpec = [{ ndim: 2 }];
  }
  computeOutputShape(e) {
    return [e[0], this.n, e[1]];
  }
  call(e, t) {
    return j2(() => (e = Oe(e), qM(e, this.n)));
  }
  getConfig() {
    let e = { n: this.n }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
hy.className = "RepeatVector";
ae2.registerClass(hy);
var fy = class extends Ge {
  constructor(e) {
    super(e);
    this.targetShape = e.targetShape;
    for (let t = 0; t < this.targetShape.length; ++t)
      this.isUnknown(this.targetShape[t]) && (this.targetShape[t] = null);
  }
  isUnknown(e) {
    return e < 0 || e == null;
  }
  fixUnknownDimension(e, t) {
    let n10 = "Total size of new array must be unchanged.", s10 = t.slice(), r10 = 1, a10 = null;
    for (let o10 = 0; o10 < s10.length; ++o10) {
      let u10 = s10[o10];
      if (this.isUnknown(u10))
        if (a10 === null)
          a10 = o10;
        else
          throw new U2("Can only specifiy one unknown dimension.");
      else
        r10 *= u10;
    }
    let i10 = dr(e);
    if (a10 !== null) {
      if (r10 === 0 || i10 % r10 !== 0)
        throw new U2(n10);
      s10[a10] = i10 / r10;
    } else if (i10 !== r10)
      throw new U2(n10);
    return s10;
  }
  computeOutputShape(e) {
    let t = false;
    for (let n10 = 0; n10 < e.length; ++n10)
      if (this.isUnknown(e[n10])) {
        t = true;
        break;
      }
    return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e), s10 = n10.shape, r10 = s10.slice(0, 1).concat(this.fixUnknownDimension(s10.slice(1), this.targetShape));
      return G2(n10, r10);
    });
  }
  getConfig() {
    let e = { targetShape: this.targetShape }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
fy.className = "Reshape";
ae2.registerClass(fy);
var my = class extends Ge {
  constructor(e) {
    super(e);
    if (e.dims == null)
      throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(e.dims))
      throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);
    let t = ys(1, e.dims.length + 1);
    if (!w2.arraysEqual(e.dims.slice().sort(), t))
      throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
    this.dims = e.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new Dt({ ndim: this.dims.length + 1 })];
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = e.slice();
    return this.dims.forEach((n10, s10) => {
      t[s10 + 1] = e[n10];
    }), t;
  }
  call(e, t) {
    return qe(Oe(e), this.dimsIncludingBatch);
  }
  getConfig() {
    let e = { dims: this.dims }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
my.className = "Permute";
ae2.registerClass(my);
var gy = class extends Ge {
  constructor(e) {
    super(e == null ? {} : e);
    this.supportsMasking = true, e != null ? this.maskValue = e.maskValue == null ? 0 : e.maskValue : this.maskValue = 0;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = super.getConfig(), t = { maskValue: this.maskValue };
    return Object.assign(t, e), t;
  }
  computeMask(e, t) {
    let n10 = Oe(e), s10 = -1;
    return cm(Ku(n10, this.maskValue), s10);
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e), s10 = -1, r10 = true, a10 = cm(Ku(n10, this.maskValue), s10, r10);
      return V2(n10, ce2(a10, n10.dtype));
    });
  }
};
gy.className = "Masking";
ae2.registerClass(gy);
var by = class extends Ge {
  constructor(e) {
    super(e);
    if (this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", e.batchInputShape == null && e.inputShape == null) {
      let t = null;
      e.batchSize != null && (t = e.batchSize), e.inputLength == null ? this.batchInputShape = [t, null] : this.batchInputShape = [t].concat(dt(e.inputLength));
    }
    this.inputDim = e.inputDim, Bt(this.inputDim, "inputDim"), this.outputDim = e.outputDim, Bt(this.outputDim, "outputDim"), this.embeddingsInitializer = ht(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = ft(e.embeddingsRegularizer), this.activityRegularizer = ft(e.activityRegularizer), this.embeddingsConstraint = Pt(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength;
  }
  build(e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
  }
  warnOnIncompatibleInputShape(e) {
  }
  computeMask(e, t) {
    return j2(() => this.maskZero ? (e = Oe(e), Ku(e, je(e))) : null);
  }
  computeOutputShape(e) {
    if (e = nt(e), this.inputLength == null)
      return [...e, this.outputDim];
    let t = dt(this.inputLength);
    if (t.length !== e.length - 1)
      throw new U2(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
    {
      let n10 = 0;
      for (let s10 = 0; s10 < t.length; ++s10) {
        let r10 = t[s10], a10 = e[s10 + 1];
        if (r10 != null && a10 != null && r10 !== a10)
          throw new U2(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
        r10 == null && (t[n10] = a10), n10++;
      }
    }
    return [e[0], ...t, this.outputDim];
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      n10.dtype !== "int32" && (n10 = Ip(n10, "int32"));
      let s10 = VI(this.embeddings.read(), G2(n10, [n10.size]));
      return G2(s10, nt(this.computeOutputShape(n10.shape)));
    });
  }
  getConfig() {
    let e = { inputDim: this.inputDim, outputDim: this.outputDim, embeddingsInitializer: yt(this.embeddingsInitializer), embeddingsRegularizer: at(this.embeddingsRegularizer), activityRegularizer: at(this.activityRegularizer), embeddingsConstraint: Ot(this.embeddingsConstraint), maskZero: this.maskZero, inputLength: this.inputLength }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
by.className = "Embedding";
ae2.registerClass(by);
var mi = class extends Ge {
  constructor(e) {
    super(e || {});
    this.supportsMasking = true;
  }
  mergeFunction(e) {
    throw new Fe();
  }
  computeElementwiseOpOutputShape(e, t) {
    if (e == null || t == null)
      return null;
    if (e.length < t.length)
      return this.computeElementwiseOpOutputShape(t, e);
    if (t.length === 0)
      return e;
    let n10 = e.slice(0, e.length - t.length);
    for (let s10 = 0; s10 < t.length; ++s10) {
      let r10 = e[e.length - t.length + s10], a10 = t[s10];
      if (r10 == null || a10 == null || r10 < 0 || a10 < 0)
        n10.push(null);
      else if (r10 === 1)
        n10.push(a10);
      else if (a10 === 1)
        n10.push(r10);
      else {
        if (r10 !== a10)
          throw new U2("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
        n10.push(r10);
      }
    }
    return n10;
  }
  build(e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [nt(e)]), e = e, e.length < 2)
      throw new U2(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);
    let t = [];
    for (let r10 of e)
      r10 != null && r10[0] !== null && t.push(r10[0]);
    if (t = cr(t), t.length > 1)
      throw new U2(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);
    let n10 = e[0] == null ? null : e[0].slice(1);
    for (let r10 = 1; r10 < e.length; ++r10) {
      let a10 = e[r10] == null ? null : e[r10].slice(1);
      n10 = this.computeElementwiseOpOutputShape(n10, a10);
    }
    let s10 = e.map((r10) => r10.length);
    e.indexOf(null) === -1 && cr(s10).length === 1 ? this.reshapeRequired = false : this.reshapeRequired = true;
  }
  call(e, t) {
    return j2(() => {
      if (e = e, this.reshapeRequired) {
        let n10 = [], s10 = e.map((r10) => r10.rank);
        if (s10.indexOf(null) === -1) {
          let r10 = gr(s10);
          for (let a10 of e) {
            let i10 = a10.rank;
            for (let o10 = 0; o10 < r10 - i10; ++o10)
              a10 = Ll(a10, 1);
            n10.push(a10);
          }
          return this.mergeFunction(n10);
        } else {
          let r10 = false;
          for (let o10 of e) {
            let u10 = o10.rank;
            if (u10 == null) {
              let l10 = o10.shape, c10 = l10[0], p10 = l10.slice(1).concat([c10]), d10 = G2(o10, [c10].concat(dr(l10.slice(1))));
              d10 = qe(d10, [1, 0]), d10 = G2(d10, p10), n10.push(d10), r10 = true;
            } else if (u10 > 1) {
              let l10 = ys(1, u10).concat([0]);
              n10.push(qe(o10, l10)), r10 = true;
            } else
              n10.push(o10);
          }
          let a10 = this.mergeFunction(n10), i10 = a10.rank;
          if (r10) {
            if (i10 == null) {
              let o10 = a10.shape, u10 = o10.length, l10 = o10[u10 - 1], c10 = [l10].concat(o10.slice(0, o10.length - 1));
              a10 = G2(qe(G2(a10, [-1, l10]), [1, 0]), c10);
            } else if (i10 > 1) {
              let o10 = [i10 - 1].concat(ys(0, i10 - 1));
              a10 = qe(a10, o10);
            }
          }
          return a10;
        }
      } else
        return this.mergeFunction(e);
    });
  }
  computeOutputShape(e) {
    e = e;
    let t;
    e[0] == null ? t = null : t = e[0].slice(1);
    for (let s10 = 1; s10 < e.length; ++s10) {
      let r10 = e[s10] == null ? null : e[s10].slice(1);
      t = this.computeElementwiseOpOutputShape(t, r10);
    }
    let n10 = [];
    for (let s10 of e)
      s10 != null && s10[0] !== null && n10.push(s10[0]);
    return n10 = cr(n10), n10.length === 1 ? t = n10.concat(t) : t = [null].concat(t), t;
  }
  computeMask(e, t) {
    return j2(() => {
      if (t == null)
        return null;
      if (!Array.isArray(t))
        throw new U2("`mask` should be an Array");
      if (!Array.isArray(e))
        throw new U2("`inputs` should be an Array");
      if (t.length !== e.length)
        throw new U2(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);
      if (t.every((s10) => s10 == null))
        return null;
      t = t.map((s10) => s10 == null ? s10 : On(s10, 0));
      let n10 = t[0];
      for (let s10 = 1; s10 < t.length - 1; ++s10)
        n10 = Ds(n10, t[s10]);
      return n10;
    });
  }
};
var yy = class extends mi {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return j2(() => {
      let t = e[0].clone();
      for (let n10 = 1; n10 < e.length; ++n10)
        t = ie2(t, e[n10]);
      return t;
    });
  }
};
yy.className = "Add";
ae2.registerClass(yy);
var vy = class extends mi {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return j2(() => {
      let t = e[0].clone();
      for (let n10 = 1; n10 < e.length; ++n10)
        t = V2(t, e[n10]);
      return t;
    });
  }
};
vy.className = "Multiply";
ae2.registerClass(vy);
var xy = class extends mi {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return j2(() => {
      let t = e[0].clone();
      for (let n10 = 1; n10 < e.length; ++n10)
        t = ie2(t, e[n10]);
      return V2(1 / e.length, t);
    });
  }
};
xy.className = "Average";
ae2.registerClass(xy);
var wy = class extends mi {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return j2(() => {
      let t = e[0];
      for (let n10 = 1; n10 < e.length; ++n10)
        t = Tr(t, e[n10]);
      return t;
    });
  }
};
wy.className = "Maximum";
ae2.registerClass(wy);
var ky = class extends mi {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return j2(() => {
      let t = e[0];
      for (let n10 = 1; n10 < e.length; ++n10)
        t = gp(t, e[n10]);
      return t;
    });
  }
};
ky.className = "Minimum";
ae2.registerClass(ky);
var Iy = class extends mi {
  constructor(e) {
    super(e);
    this.DEFAULT_AXIS = -1, e == null && (e = {}), this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = true, this.reshapeRequired = false;
  }
  build(e) {
    if (!(Array.isArray(e) && Array.isArray(e[0])) || e.length === 1)
      throw new U2("A `Concatenate` layer should be called on a list of at least 2 inputs");
    e = e;
    let t = true;
    for (let s10 of e)
      if (s10 != null) {
        t = false;
        break;
      }
    if (t)
      return;
    let n10 = [];
    for (let s10 = 0; s10 < e.length; ++s10) {
      let r10 = e[s10].slice();
      r10.splice(this.axis, 1);
      let a10 = false;
      for (let i10 of n10)
        if (w2.arraysEqual(i10, r10)) {
          a10 = true;
          break;
        }
      a10 || n10.push(r10);
    }
    if (n10.length > 1)
      throw new U2("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
  }
  mergeFunction(e) {
    return j2(() => Nb(e, this.axis));
  }
  computeOutputShape(e) {
    if (!(Array.isArray(e) && Array.isArray(e[0])))
      throw new U2("A `Concatenate` layer should be called on a list of inputs.");
    let t = e, n10 = t[0].slice(), s10 = this.axis < 0 ? n10.length + this.axis : this.axis;
    for (let r10 of t.slice(1)) {
      if (n10[s10] == null || r10[s10] == null) {
        n10[s10] = null;
        break;
      }
      n10[s10] += r10[s10];
    }
    return n10;
  }
  computeMask(e, t) {
    if (t == null)
      return null;
    if (!Array.isArray(t))
      throw new U2("`mask` should be an array for Concatenate");
    if (!Array.isArray(e))
      throw new U2("`inputs` should be an array for Concatenate");
    if (t.length !== e.length)
      throw new U2(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);
    return j2(() => {
      let n10 = true;
      if (t.forEach((a10) => {
        if (a10 != null) {
          n10 = false;
          return;
        }
      }), n10)
        return null;
      let s10 = [];
      for (let a10 = 0; a10 < e.length; ++a10)
        t[a10] == null ? s10.push(ce2(Xn(e[a10]), "bool")) : t[a10].rank < e[a10].rank ? s10.push(On(t[a10], -1)) : s10.push(t[a10]);
      let r10 = Ft(s10, this.axis);
      return Bk(r10, -1, false);
    });
  }
  getConfig() {
    let e = { axis: this.axis }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Iy.className = "Concatenate";
ae2.registerClass(Iy);
function Su(e, t) {
  for (; e < 0; )
    e += t;
  return e;
}
function EB(e, t, n10) {
  if (e.shape.length > 3 || t.shape.length > 3)
    throw new Fe("batchDot is not implemented for tensors of 4D or higher rank yet");
  if (w2.assert(e.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`), w2.assert(e.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`), typeof n10 == "number" && (n10 = [n10, n10]), e.dtype === "complex64" || t.dtype === "complex64")
    throw new Fe("batchDot is not implemented for complex64-type Tensors yet.");
  let s10 = e.shape.length, r10 = t.shape.length;
  n10 == null && (n10 = [s10 - 1, r10 - 2]);
  let a10 = n10;
  return j2(() => {
    let i10;
    if (s10 > r10) {
      i10 = s10 - r10;
      let u10 = [];
      for (let l10 = 0; l10 < i10; ++l10)
        u10.push(1);
      t = G2(t, t.shape.concat(u10));
    } else if (r10 > s10) {
      i10 = r10 - s10;
      let u10 = [];
      for (let l10 = 0; l10 < i10; ++l10)
        u10.push(1);
      e = G2(e, e.shape.concat(u10));
    } else
      i10 = 0;
    let o10;
    if (e.shape.length === 2 && t.shape.length === 2)
      a10[0] === a10[1] ? o10 = ye2(V2(e, t), a10[0]) : o10 = ye2(V2(qe(e, [1, 0]), t), a10[1]);
    else {
      let u10 = a10[0] !== e.shape.length - 1, l10 = a10[1] === t.shape.length - 1;
      o10 = We(e, t, u10, l10);
    }
    if (i10 > 0) {
      let u10;
      s10 > r10 ? u10 = s10 + r10 - 3 : u10 = s10 - 1;
      let l10 = [];
      for (let c10 = u10; c10 < u10 + i10; ++c10)
        l10.push(c10);
      o10 = mr(o10, l10);
    }
    return o10.shape.length === 1 && (o10 = On(o10, 1)), o10;
  });
}
var Sy = class extends mi {
  constructor(e) {
    super(e);
    this.axes = e.axes, this.normalize = e.normalize == null ? false : e.normalize, this.supportsMasking = true, this.reshapeRequired = false;
  }
  build(e) {
    w2.assert(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    let t = e[0], n10 = e[1];
    if (t.length > 3 || n10.length > 3)
      throw new Fe("Dot layer does not support tensors of 4D or higher rank yet.");
    let s10 = this.interpretAxes(t, n10);
    if (t[s10[0]] !== n10[s10[1]])
      throw new U2(`Dimension incompatibility: ${t[s10[0]]} !== ${n10[s10[1]]}`);
  }
  mergeFunction(e) {
    if (e.length !== 2)
      throw new U2(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);
    let t = e[0], n10 = e[1], s10;
    return Array.isArray(this.axes) ? s10 = this.axes.map((r10, a10) => Su(r10, e[a10].shape.length)) : s10 = [Su(this.axes, t.shape.length), Su(this.axes, n10.shape.length)], this.normalize && (t = Cd(t, s10[0]), n10 = Cd(n10, s10[1])), EB(t, n10, s10);
  }
  interpretAxes(e, t) {
    let n10;
    return Array.isArray(this.axes) ? n10 = this.axes : n10 = [Su(this.axes, e.length), Su(this.axes, t.length)], n10;
  }
  computeOutputShape(e) {
    w2.assert(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    let t = e[0].slice(), n10 = e[1].slice();
    if (t.length > 3 || n10.length > 3)
      throw new Fe("Dot layer does not support tensors of 4D or higher rank yet.");
    let s10 = this.interpretAxes(t, n10);
    t.splice(s10[0], 1), n10.splice(s10[1], 1), n10.splice(0, 1);
    let r10 = t.concat(n10);
    return r10.length === 1 && r10.push(1), r10;
  }
  computeMask(e, t) {
    return null;
  }
  getConfig() {
    let e = { axes: this.axes, normalize: this.normalize }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Sy.className = "Dot";
ae2.registerClass(Sy);
var Cy = class extends Ge {
  constructor(e) {
    super(e);
    this.supportsMasking = true, this.stddev = e.stddev;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = super.getConfig(), t = { stddev: this.stddev };
    return Object.assign(t, e), t;
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      return Vl(() => ie2(Sp(n10.shape, 0, this.stddev), n10), () => n10, t.training || false);
    });
  }
};
Cy.className = "GaussianNoise";
ae2.registerClass(Cy);
var Ny = class extends Ge {
  constructor(e) {
    super(e);
    this.supportsMasking = true, this.rate = e.rate;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = super.getConfig(), t = { rate: this.rate };
    return Object.assign(t, e), t;
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t);
      let n10 = Oe(e);
      return this.rate > 0 && this.rate < 1 ? Vl(() => {
        let r10 = Math.sqrt(this.rate / (1 - this.rate));
        return V2(n10, Sp(n10.shape, 1, r10));
      }, () => n10, t.training || false) : n10;
    });
  }
};
Ny.className = "GaussianDropout";
ae2.registerClass(Ny);
var Ty = class extends Ge {
  constructor(e) {
    super(e);
    this.supportsMasking = true, this.rate = e.rate, this.noiseShape = e.noiseShape;
  }
  _getNoiseShape(e) {
    return this.noiseShape || Oe(e).shape;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    let e = super.getConfig(), t = { rate: this.rate };
    return Object.assign(t, e), t;
  }
  call(e, t) {
    return j2(() => {
      if (this.rate < 1 && this.rate > 0) {
        let n10 = this._getNoiseShape(e);
        return Vl(() => {
          let r10 = Oe(e), a10 = 1.6732632423543772, i10 = 1.0507009873554805, o10 = -a10 * i10, u10 = jo(Pl(n10), this.rate);
          u10 = Ip(u10, "float32");
          let l10 = ((1 - this.rate) * (1 + this.rate * o10 ** 2)) ** -0.5, c10 = -l10 * o10 * this.rate, p10 = ie2(V2(r10, u10), V2(ie2(u10, -1), o10));
          return ie2(V2(p10, l10), c10);
        }, () => Oe(e), t.training || false);
      }
      return e;
    });
  }
};
Ty.className = "AlphaDropout";
ae2.registerClass(Ty);
function Zu(e, t, n10, s10, r10, a10 = 1e-3) {
  let i10;
  if (e.rank === 2)
    i10 = vE(e, t, n10, s10, r10, a10);
  else if (e.rank === 3)
    i10 = wE(e, t, n10, s10, r10, a10);
  else if (e.rank === 4)
    i10 = IE(e, t, n10, s10, r10, a10);
  else
    throw new Fe(`batchNormalization is not implemented for array of rank ${e.rank} yet`);
  return i10;
}
function RB(e, t, n10, s10, r10 = 1e-3) {
  return j2(() => {
    let a10 = Jg(e, s10), i10 = a10.mean, o10 = a10.variance;
    return [Zu(e, i10, o10, n10, t, r10), i10, o10];
  });
}
function DB(e, t, n10, s10, r10 = 1e-3) {
  return j2(() => {
    let a10 = Jg(e, s10), i10 = a10.mean, o10 = a10.variance, u10 = [];
    for (let f10 of ys(0, e.rank))
      s10.indexOf(f10) !== -1 ? u10.push(1) : u10.push(e.shape[f10]);
    let l10 = G2(i10, u10), c10 = G2(o10, u10), p10 = t == null ? null : G2(t, u10), d10 = n10 == null ? null : G2(n10, u10);
    return [Zu(e, l10, c10, d10, p10, r10), i10, o10];
  });
}
function FB(e, t, n10, s10, r10 = 1e-3) {
  return w2.arraysEqual(s10.slice().sort(), ys(0, e.rank - 1)) ? RB(e, t, n10, s10, r10) : DB(e, t, n10, s10, r10);
}
var $y = class extends Ge {
  constructor(e) {
    e == null && (e = {});
    super(e);
    this.supportsMasking = true, this.axis = e.axis == null ? -1 : e.axis, this.momentum = e.momentum == null ? 0.99 : e.momentum, this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? true : e.center, this.scale = e.scale == null ? true : e.scale, this.betaInitializer = ht(e.betaInitializer || "zeros"), this.gammaInitializer = ht(e.gammaInitializer || "ones"), this.movingMeanInitializer = ht(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = ht(e.movingVarianceInitializer || "ones"), this.betaConstraint = Pt(e.betaConstraint), this.gammaConstraint = Pt(e.gammaConstraint), this.betaRegularizer = ft(e.betaRegularizer), this.gammaRegularizer = ft(e.gammaRegularizer);
  }
  build(e) {
    e = nt(e);
    let t = this.axis >= 0 ? this.axis : this.axis + e.length, n10 = e[t];
    if (n10 == null)
      throw new U2(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);
    this.inputSpec = [new Dt({ ndim: e.length, axes: { [t]: n10 } })];
    let s10 = [n10];
    this.scale && (this.gamma = this.addWeight("gamma", s10, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", s10, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", s10, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", s10, null, this.movingVarianceInitializer, null, false), this.built = true;
  }
  call(e, t) {
    return j2(() => {
      let n10 = t.training == null ? false : t.training, s10 = Oe(e), r10 = s10.shape, a10 = r10.length, i10 = ys(0, a10), o10 = this.axis >= 0 ? this.axis : this.axis + a10;
      i10.splice(o10, 1);
      let u10 = pa(1, a10);
      u10[o10] = r10[o10];
      let l10 = i10.slice();
      l10.sort();
      let c10 = !w2.arraysEqual(l10, ys(0, a10).slice(0, a10 - 1)), p10 = () => {
        if (c10) {
          let b10 = G2(this.movingMean.read(), u10), y10 = G2(this.movingVariance.read(), u10), v10 = this.center ? G2(this.beta.read(), u10) : null, x10 = this.scale ? G2(this.gamma.read(), u10) : null;
          return Zu(s10, b10, y10, v10, x10, this.epsilon);
        } else
          return Zu(s10, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
      };
      if (!n10)
        return p10();
      let [d10, h10, f10] = FB(s10, this.gamma.read(), this.beta.read(), i10, this.epsilon), m10 = (b10, y10, v10) => {
        j2(() => {
          let x10 = 1 - v10, k10 = b10.read(), C10 = V2(ge2(k10, y10), x10);
          b10.write(ge2(k10, C10));
        });
      };
      return (() => {
        m10(this.movingMean, h10, this.momentum), m10(this.movingVariance, f10, this.momentum);
      })(), d10;
    });
  }
  getConfig() {
    let e = { axis: this.axis, momentum: this.momentum, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: yt(this.betaInitializer), gammaInitializer: yt(this.gammaInitializer), movingMeanInitializer: yt(this.movingMeanInitializer), movingVarianceInitializer: yt(this.movingVarianceInitializer), betaRegularizer: at(this.betaRegularizer), gammaRegularizer: at(this.gammaRegularizer), betaConstraint: Ot(this.betaConstraint), gammaConstraint: Ot(this.gammaConstraint) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
$y.className = "BatchNormalization";
ae2.registerClass($y);
var _y2 = class extends Ge {
  constructor(e) {
    e == null && (e = {});
    super(e);
    if (this.axis = e.axis == null ? -1 : e.axis, typeof this.axis == "number") {
      if (!Number.isInteger(this.axis))
        throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
    } else if (Array.isArray(this.axis)) {
      for (let t of this.axis)
        if (!Number.isInteger(t))
          throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
    } else
      throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
    this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? true : e.center, this.scale = e.scale == null ? true : e.scale, this.betaInitializer = ht(e.betaInitializer || "zeros"), this.gammaInitializer = ht(e.gammaInitializer || "ones"), this.betaRegularizer = ft(e.betaRegularizer), this.gammaRegularizer = ft(e.gammaRegularizer), this.supportsMasking = true;
  }
  build(e) {
    e = nt(e);
    let t = e.length;
    typeof this.axis == "number" && (this.axis = [this.axis]);
    for (let r10 = 0; r10 < this.axis.length; ++r10)
      this.axis[r10] < 0 && (this.axis[r10] += t);
    for (let r10 of this.axis)
      if (r10 < 0 || r10 >= t)
        throw new Error(`Invalid axis: ${r10}`);
    if (this.axis.length !== cr(this.axis).length)
      throw new Error(`Found duplicate axes in: ${this.axis}`);
    let n10 = this.axis.map((r10) => e[r10]), s10 = true;
    this.scale ? this.gamma = this.addWeight("gamma", n10, "float32", this.gammaInitializer, this.gammaRegularizer, s10) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", n10, "float32", this.betaInitializer, this.betaRegularizer, s10) : this.beta = null, this.built = true;
  }
  call(e, t) {
    let n10 = Oe(e), s10 = n10.shape, r10 = s10.length;
    return j2(() => {
      let { mean: i10, variance: o10 } = Jg(n10, this.axis, true), u10 = pa(1, r10);
      for (let f10 of this.axis)
        u10[f10] = s10[f10];
      let l10 = (f10) => f10 != null && f10.shape.length !== r10 ? G2(f10, u10) : f10, c10 = l10(this.gamma.read()), p10 = l10(this.beta.read()), d10 = [], h10 = [];
      for (let f10 = 0; f10 < r10; ++f10)
        this.axis.indexOf(f10) !== -1 ? (d10.push(s10[f10]), h10.push(1)) : (d10.push(1), h10.push(s10[f10]));
      return i10 = cs(i10, d10), o10 = cs(o10, d10), c10 = cs(c10, h10), p10 = cs(p10, h10), Zu(n10, i10, o10, p10, c10, this.epsilon);
    });
  }
  getConfig() {
    let e = { axis: this.axis, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: yt(this.betaInitializer), gammaInitializer: yt(this.gammaInitializer), betaRegularizer: at(this.betaRegularizer), gammaRegularizer: at(this.gammaRegularizer) }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
_y2.className = "LayerNormalization";
ae2.registerClass(_y2);
function OB(e, t, n10) {
  return j2(() => {
    if (e.rank !== 4)
      throw new U2(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);
    if (t == null && (t = [[1, 1], [1, 1]]), t.length !== 2 || t[0].length !== 2 || t[1].length !== 2)
      throw new U2("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    if (n10 == null && (n10 = bs()), n10 !== "channelsLast" && n10 !== "channelsFirst")
      throw new U2(`Unknown data format: ${n10}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
    let s10;
    return n10 === "channelsFirst" ? s10 = [[0, 0], [0, 0], t[0], t[1]] : s10 = [[0, 0], t[0], t[1], [0, 0]], pi(e, s10);
  });
}
var Ay = class extends Ge {
  constructor(e) {
    e == null && (e = {});
    super(e);
    if (this.dataFormat = e.dataFormat == null ? bs() : e.dataFormat, e.padding == null)
      this.padding = [[1, 1], [1, 1]];
    else if (typeof e.padding == "number")
      this.padding = [[e.padding, e.padding], [e.padding, e.padding]];
    else {
      if (e.padding = e.padding, e.padding.length !== 2)
        throw new U2(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);
      let t, n10;
      if (typeof e.padding[0] == "number")
        t = [e.padding[0], e.padding[0]], n10 = [e.padding[1], e.padding[1]];
      else {
        if (e.padding = e.padding, e.padding[0].length !== 2)
          throw new U2(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);
        if (t = e.padding[0], e.padding[1].length !== 2)
          throw new U2(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);
        n10 = e.padding[1];
      }
      this.padding = [t, n10];
    }
    this.inputSpec = [new Dt({ ndim: 4 })];
  }
  computeOutputShape(e) {
    e = nt(e);
    let t, n10;
    return this.dataFormat === "channelsFirst" ? (e[2] != null && e[2] >= 0 ? t = e[2] + this.padding[0][0] + this.padding[0][1] : t = null, e[3] != null && e[3] >= 0 ? n10 = e[3] + this.padding[1][0] + this.padding[1][1] : n10 = null, [e[0], e[1], t, n10]) : (e[1] != null && e[1] >= 0 ? t = e[1] + this.padding[0][0] + this.padding[0][1] : t = null, e[2] != null && e[2] >= 0 ? n10 = e[2] + this.padding[1][0] + this.padding[1][1] : n10 = null, [e[0], t, n10, e[3]]);
  }
  call(e, t) {
    return j2(() => OB(Oe(e), this.padding, this.dataFormat));
  }
  getConfig() {
    let e = { padding: this.padding, dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
Ay.className = "ZeroPadding2D";
ae2.registerClass(Ay);
function Up(e, t, n10, s10, r10, a10) {
  return j2(() => {
    St(r10), zI(a10), Un(s10), n10 == null && (n10 = [1, 1]), s10 == null && (s10 = "valid"), r10 == null && (r10 = bs()), a10 == null && (a10 = "max"), e = Yb(e, r10);
    let i10, o10 = s10 === "same" ? "same" : "valid";
    return a10 === "max" ? i10 = Zg(e, t, n10, o10) : i10 = Wg(e, t, n10, o10), r10 === "channelsFirst" && (i10 = qe(i10, [0, 3, 1, 2])), i10;
  });
}
function A0(e, t, n10, s10, r10, a10) {
  return j2(() => {
    St(r10), zI(a10), Un(s10), n10 == null && (n10 = [1, 1, 1]), s10 == null && (s10 = "valid"), r10 == null && (r10 = bs()), a10 == null && (a10 = "max"), e = w0(e, r10);
    let i10, o10 = s10 === "same" ? "same" : "valid";
    return a10 === "max" ? i10 = aI(e, t, n10, o10) : i10 = Gk(e, t, n10, o10), r10 === "channelsFirst" && (i10 = qe(i10, [0, 4, 1, 2, 3])), i10;
  });
}
var E0 = class extends Ge {
  constructor(e) {
    e.poolSize == null && (e.poolSize = 2);
    super(e);
    if (typeof e.poolSize == "number")
      this.poolSize = [e.poolSize];
    else if (Array.isArray(e.poolSize) && e.poolSize.length === 1 && typeof e.poolSize[0] == "number")
      this.poolSize = e.poolSize;
    else
      throw new U2(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);
    if (Bt(this.poolSize, "poolSize"), e.strides == null)
      this.strides = this.poolSize;
    else if (typeof e.strides == "number")
      this.strides = [e.strides];
    else if (Array.isArray(e.strides) && e.strides.length === 1 && typeof e.strides[0] == "number")
      this.strides = e.strides;
    else
      throw new U2(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);
    Bt(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, Un(this.padding), this.inputSpec = [new Dt({ ndim: 3 })];
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = ms(e[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], t, e[2]];
  }
  call(e, t) {
    return j2(() => {
      this.invokeCallHook(e, t), e = Ll(Oe(e), 2);
      let n10 = this.poolingFunction(Oe(e), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return mr(n10, [2]);
    });
  }
  getConfig() {
    let e = { poolSize: this.poolSize, padding: this.padding, strides: this.strides }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
var Ey = class extends E0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), Up(e, t, n10, s10, r10, "max");
  }
};
Ey.className = "MaxPooling1D";
ae2.registerClass(Ey);
var Ry = class extends E0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), Up(e, t, n10, s10, r10, "avg");
  }
};
Ry.className = "AveragePooling1D";
ae2.registerClass(Ry);
var R0 = class extends Ge {
  constructor(e) {
    e.poolSize == null && (e.poolSize = [2, 2]);
    super(e);
    if (this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], e.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(e.strides)) {
      if (e.strides.length !== 2)
        throw new U2(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);
      this.strides = e.strides;
    } else
      this.strides = [e.strides, e.strides];
    Bt(this.poolSize, "poolSize"), Bt(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, St(this.dataFormat), Un(this.padding), this.inputSpec = [new Dt({ ndim: 4 })];
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = this.dataFormat === "channelsFirst" ? e[2] : e[1], n10 = this.dataFormat === "channelsFirst" ? e[3] : e[2];
    return t = ms(t, this.poolSize[0], this.padding, this.strides[0]), n10 = ms(n10, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [e[0], e[1], t, n10] : [e[0], t, n10, e[3]];
  }
  call(e, t) {
    return j2(() => (this.invokeCallHook(e, t), this.poolingFunction(Oe(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    let e = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
var Dy = class extends R0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), Up(e, t, n10, s10, r10, "max");
  }
};
Dy.className = "MaxPooling2D";
ae2.registerClass(Dy);
var Fy = class extends R0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), Up(e, t, n10, s10, r10, "avg");
  }
};
Fy.className = "AveragePooling2D";
ae2.registerClass(Fy);
var D0 = class extends Ge {
  constructor(e) {
    e.poolSize == null && (e.poolSize = [2, 2, 2]);
    super(e);
    if (this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], e.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(e.strides)) {
      if (e.strides.length !== 3)
        throw new U2(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);
      this.strides = e.strides;
    } else
      this.strides = [e.strides, e.strides, e.strides];
    Bt(this.poolSize, "poolSize"), Bt(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, St(this.dataFormat), Un(this.padding), this.inputSpec = [new Dt({ ndim: 5 })];
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = this.dataFormat === "channelsFirst" ? e[2] : e[1], n10 = this.dataFormat === "channelsFirst" ? e[3] : e[2], s10 = this.dataFormat === "channelsFirst" ? e[4] : e[3];
    return t = ms(t, this.poolSize[0], this.padding, this.strides[0]), n10 = ms(n10, this.poolSize[1], this.padding, this.strides[1]), s10 = ms(s10, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [e[0], e[1], t, n10, s10] : [e[0], t, n10, s10, e[4]];
  }
  call(e, t) {
    return j2(() => (this.invokeCallHook(e, t), this.poolingFunction(Oe(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    let e = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
var Oy = class extends D0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), A0(e, t, n10, s10, r10, "max");
  }
};
Oy.className = "MaxPooling3D";
ae2.registerClass(Oy);
var Py = class extends D0 {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, t, n10, s10, r10) {
    return St(r10), Un(s10), A0(e, t, n10, s10, r10, "avg");
  }
};
Py.className = "AveragePooling3D";
ae2.registerClass(Py);
var F0 = class extends Ge {
  constructor(e) {
    super(e);
    this.inputSpec = [new Dt({ ndim: 3 })];
  }
  computeOutputShape(e) {
    return [e[0], e[2]];
  }
  call(e, t) {
    throw new Fe();
  }
};
var zy = class extends F0 {
  constructor(e) {
    super(e || {});
  }
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      return It(n10, 1);
    });
  }
};
zy.className = "GlobalAveragePooling1D";
ae2.registerClass(zy);
var My = class extends F0 {
  constructor(e) {
    super(e || {});
  }
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      return As(n10, 1);
    });
  }
};
My.className = "GlobalMaxPooling1D";
ae2.registerClass(My);
var O0 = class extends Ge {
  constructor(e) {
    super(e);
    this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, St(this.dataFormat), this.inputSpec = [new Dt({ ndim: 4 })];
  }
  computeOutputShape(e) {
    return e = e, this.dataFormat === "channelsLast" ? [e[0], e[3]] : [e[0], e[1]];
  }
  call(e, t) {
    throw new Fe();
  }
  getConfig() {
    let e = { dataFormat: this.dataFormat }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
};
var Ly = class extends O0 {
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      return this.dataFormat === "channelsLast" ? It(n10, [1, 2]) : It(n10, [2, 3]);
    });
  }
};
Ly.className = "GlobalAveragePooling2D";
ae2.registerClass(Ly);
var By = class extends O0 {
  call(e, t) {
    return j2(() => {
      let n10 = Oe(e);
      return this.dataFormat === "channelsLast" ? As(n10, [1, 2]) : As(n10, [2, 3]);
    });
  }
};
By.className = "GlobalMaxPooling2D";
ae2.registerClass(By);
var P0 = class extends Ge {
  constructor(e) {
    super(e);
    this.layer = e.layer;
  }
  build(e) {
    this.built = true;
  }
  get trainable() {
    return this.layer != null ? this.layer.trainable : false;
  }
  set trainable(e) {
    this.layer != null && (this.layer.trainable = e);
  }
  get trainableWeights() {
    return this.layer.trainableWeights;
  }
  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }
  get updates() {
    return this.layer._updates;
  }
  get losses() {
    return this.layer.losses;
  }
  getWeights() {
    return this.layer.getWeights();
  }
  setWeights(e) {
    this.layer.setWeights(e);
  }
  getConfig() {
    let e = { layer: { className: this.layer.getClassName(), config: this.layer.getConfig() } }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.layer != null && this.layer.setFastWeightInitDuringBuild(e);
  }
  static fromConfig(e, t, n10 = {}) {
    let s10 = t.layer, r10 = fs(s10, n10);
    delete t.layer;
    let a10 = { layer: r10 };
    return Object.assign(a10, t), new e(a10);
  }
};
var Vy = class extends P0 {
  constructor(e) {
    super(e);
    this.supportsMasking = true;
  }
  build(e) {
    if (e = nt(e), e.length < 3)
      throw new U2(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);
    this.inputSpec = [{ shape: e }];
    let t = [e[0]].concat(e.slice(2));
    this.layer.built || (this.layer.build(t), this.layer.built = true), super.build(e);
  }
  computeOutputShape(e) {
    e = nt(e);
    let t = [e[0]].concat(e.slice(2)), n10 = this.layer.computeOutputShape(t), s10 = e[1];
    return [n10[0], s10].concat(n10.slice(1));
  }
  call(e, t) {
    return j2(() => (e = Oe(e), T0((a10, i10) => [Oe(this.layer.call(a10, t)), []], e, [], false, null, null, false, true)[1]));
  }
};
Vy.className = "TimeDistributed";
ae2.registerClass(Vy);
function PB(e) {
  hi(VM, "BidirectionalMergeMode", e);
}
var zB = "concat";
var Wy = class extends P0 {
  constructor(e) {
    super(e);
    let t = e.layer.getConfig(), n10 = {};
    n10.className = e.layer.getClassName(), n10.config = t, this.forwardLayer = fs(n10), t.goBackwards = t.goBackwards !== true;
    let s10 = {};
    if (s10.className = e.layer.getClassName(), s10.config = t, this.backwardLayer = fs(s10), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = e.mergeMode === void 0 ? zB : e.mergeMode, PB(this.mergeMode), e.weights)
      throw new Fe("weights support is not implemented for Bidirectional layer yet.");
    this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = true, this._trainable = true, this.inputSpec = e.layer.inputSpec, this.numConstants = null;
  }
  get trainable() {
    return this._trainable;
  }
  set trainable(e) {
    this._trainable = e, this.forwardLayer != null && (this.forwardLayer.trainable = e), this.backwardLayer != null && (this.backwardLayer.trainable = e);
  }
  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }
  setWeights(e) {
    let t = e.length, n10 = Math.floor(t / 2);
    this.forwardLayer.setWeights(e.slice(0, n10)), this.backwardLayer.setWeights(e.slice(n10));
  }
  computeOutputShape(e) {
    let t = this.forwardLayer.computeOutputShape(e);
    Array.isArray(t) && Array.isArray(t[0]) || (t = [t]), t = t;
    let n10, s10, r10;
    return this.returnState && (r10 = t.slice(1)), n10 = t[0], n10 = n10, this.mergeMode === "concat" ? (n10[n10.length - 1] *= 2, s10 = [n10]) : this.mergeMode == null ? s10 = [n10, n10.slice()] : s10 = [n10], this.returnState ? this.mergeMode == null ? s10.concat(r10).concat(r10.slice()) : [n10].concat(r10).concat(r10.slice()) : gn(s10);
  }
  apply(e, t) {
    let n10 = t == null ? null : t.initialState, s10 = t == null ? null : t.constants;
    t == null && (t = {});
    let r10 = N0(e, n10, s10, this.numConstants);
    if (e = r10.inputs, n10 = r10.initialState, s10 = r10.constants, Array.isArray(e) && (n10 = e.slice(1), e = e[0]), (n10 == null || n10.length === 0) && s10 == null)
      return super.apply(e, t);
    let a10 = [], i10 = [];
    if (n10 != null) {
      let u10 = n10.length;
      if (u10 % 2 > 0)
        throw new U2("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      t.initialState = n10, a10.push(...n10);
      let l10 = n10.map((c10) => new Dt({ shape: c10.shape }));
      this.forwardLayer.stateSpec = l10.slice(0, u10 / 2), this.backwardLayer.stateSpec = l10.slice(u10 / 2), i10.push(...l10);
    }
    if (s10 != null)
      throw new Fe("Support for constants in Bidirectional layers is not implemented yet.");
    let o10 = a10[0] instanceof $s;
    for (let u10 of a10)
      if (u10 instanceof $s !== o10)
        throw new U2("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    if (o10) {
      let u10 = [e].concat(a10), l10 = this.inputSpec.concat(i10), c10 = this.inputSpec;
      this.inputSpec = l10;
      let p10 = super.apply(u10, t);
      return this.inputSpec = c10, p10;
    } else
      return super.apply(e, t);
  }
  call(e, t) {
    return j2(() => {
      let n10 = t.initialState, s10, r10;
      if (n10 == null)
        s10 = this.forwardLayer.call(e, t), r10 = this.backwardLayer.call(e, t);
      else {
        let o10 = n10.slice(0, n10.length / 2), u10 = n10.slice(n10.length / 2);
        s10 = this.forwardLayer.call(e, Object.assign(t, { initialState: o10 })), r10 = this.backwardLayer.call(e, Object.assign(t, { initialState: u10 }));
      }
      let a10;
      this.returnState && (Array.isArray(s10) && (a10 = s10.slice(1).concat(r10.slice(1))), s10 = s10[0], r10 = r10[0]), this.returnSequences && (r10 = Yn(r10, 1));
      let i10;
      return this.mergeMode === "concat" ? i10 = Nb([s10, r10]) : this.mergeMode === "sum" ? i10 = ie2(s10, r10) : this.mergeMode === "ave" ? i10 = V2(0.5, ie2(s10, r10)) : this.mergeMode === "mul" ? i10 = V2(s10, r10) : this.mergeMode == null && (i10 = [s10, r10]), this.returnState ? this.mergeMode == null ? i10.concat(a10) : [i10].concat(a10) : i10;
    });
  }
  resetStates(e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }
  build(e) {
    Zr(this.forwardLayer.name, () => {
      this.forwardLayer.build(e);
    }), Zr(this.backwardLayer.name, () => {
      this.backwardLayer.build(e);
    }), this.built = true;
  }
  computeMask(e, t) {
    Array.isArray(t) && (t = t[0]);
    let n10;
    if (this.returnSequences ? this.mergeMode == null ? n10 = [t, t] : n10 = t : this.mergeMode == null ? n10 = [null, null] : n10 = null, this.returnState) {
      let r10 = this.forwardLayer.states.map((a10) => null);
      return Array.isArray(n10) ? n10.concat(r10).concat(r10) : [n10].concat(r10).concat(r10);
    } else
      return n10;
  }
  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }
  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(e), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(e);
  }
  getConfig() {
    let e = { mergeMode: this.mergeMode }, t = super.getConfig();
    return Object.assign(e, t), e;
  }
  static fromConfig(e, t) {
    let n10 = fs(t.layer);
    if (delete t.layer, t.numConstants != null)
      throw new Fe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    let s10 = t;
    return s10.layer = n10, new e(s10);
  }
};
Wy.className = "Bidirectional";
ae2.registerClass(Wy);
function MB(e) {
  return new Yo(e);
}
function LB(e) {
  return new jb(e);
}
function BB(e) {
  return new Gb(e);
}
function VB(e) {
  return new Hb(e);
}
function WB(e) {
  return new qb(e);
}
function UB(e) {
  return new Xb(e);
}
function GB(e) {
  return new Kb(e);
}
function HB(e) {
  return new ty(e);
}
function qB(e) {
  return new Pp(e);
}
function jB(e) {
  return new Zb(e);
}
function KB(e) {
  return new zp(e);
}
function XB(e) {
  return new Jb(e);
}
function YB(e) {
  return new ey(e);
}
function QB(e) {
  return new ny(e);
}
function ZB(e) {
  return new sy(e);
}
function JB(e) {
  return new ry(e);
}
function eV(e) {
  return new py2(e);
}
function tV(e) {
  return new cy(e);
}
function nV(e) {
  return new Wp(e);
}
function sV(e) {
  return new ly(e);
}
function rV(e) {
  return new dy(e);
}
function aV(e) {
  return new hy(e);
}
function iV(e) {
  return new fy(e);
}
function oV(e) {
  return new my(e);
}
function uV(e) {
  return new by(e);
}
function lV(e) {
  return new yy(e);
}
function cV(e) {
  return new xy(e);
}
function dV(e) {
  return new Iy(e);
}
function pV(e) {
  return new wy(e);
}
function hV(e) {
  return new ky(e);
}
function fV(e) {
  return new vy(e);
}
function mV(e) {
  return new Sy(e);
}
function gV(e) {
  return new $y(e);
}
function bV(e) {
  return new _y2(e);
}
function yV(e) {
  return new Ay(e);
}
function Uy(e) {
  return new Ry(e);
}
function vV(e) {
  return Uy(e);
}
function xV(e) {
  return Uy(e);
}
function Gy(e) {
  return new Fy(e);
}
function wV(e) {
  return Gy(e);
}
function kV(e) {
  return Gy(e);
}
function Hy(e) {
  return new Py(e);
}
function IV(e) {
  return Hy(e);
}
function SV(e) {
  return Hy(e);
}
function CV(e) {
  return new zy(e);
}
function NV(e) {
  return new Ly(e);
}
function z0(e) {
  return new My(e);
}
function M0(e) {
  return new By(e);
}
function L0(e) {
  return new Ey(e);
}
function B0(e) {
  return new Dy(e);
}
function TV(e) {
  return new Oy(e);
}
function $V(e) {
  return new iy(e);
}
function _V(e) {
  return new Lp(e);
}
function AV(e) {
  return new oy(e);
}
function EV(e) {
  return new Hl(e);
}
function RV(e) {
  return new ay(e);
}
function DV(e) {
  return new Mp(e);
}
function FV(e) {
  return new uy(e);
}
function OV(e) {
  return new Vp(e);
}
function PV(e) {
  return new _r(e);
}
function zV(e) {
  return new Bp(e);
}
function MV(e) {
  return new Wy(e);
}
function LV(e) {
  return new Vy(e);
}
var BV = z0;
var VV = M0;
var WV = L0;
var UV = B0;
function GV(e) {
  return new Cy(e);
}
function HV(e) {
  return new Ny(e);
}
function qV(e) {
  return new Ty(e);
}
function jV(e) {
  return new gy(e);
}
var KV = {};
Ae(KV, { MAPE: () => aW, MSE: () => uW, binaryAccuracy: () => XV, binaryCrossentropy: () => YV, categoricalAccuracy: () => ZV, categoricalCrossentropy: () => JV, cosineProximity: () => nW, mape: () => iW, meanAbsoluteError: () => sW, meanAbsolutePercentageError: () => rW, meanSquaredError: () => oW, mse: () => lW, precision: () => eW, recall: () => tW, sparseCategoricalAccuracy: () => QV });
function XV(e, t) {
  return zb(e, t);
}
function YV(e, t) {
  return QI(e, t);
}
function QV(e, t) {
  return ZI(e, t);
}
function ZV(e, t) {
  return Mb(e, t);
}
function JV(e, t) {
  return Lb(e, t);
}
function eW(e, t) {
  return YI(e, t);
}
function tW(e, t) {
  return VL(e, t);
}
function nW(e, t) {
  return Pb(e, t);
}
function sW(e, t) {
  return Fp(e, t);
}
function rW(e, t) {
  return Qo(e, t);
}
function aW(e, t) {
  return Qo(e, t);
}
function iW(e, t) {
  return Qo(e, t);
}
function oW(e, t) {
  return fi(e, t);
}
function uW(e, t) {
  return fi(e, t);
}
function lW(e, t) {
  return fi(e, t);
}
var cW = {};
Ae(cW, { modelFromJSON: () => wB });
var dW = {};
Ae(dW, { l1: () => hW, l1l2: () => pW, l2: () => fW });
function pW(e) {
  return new Wl(e);
}
function hW(e) {
  return NB(e);
}
function fW(e) {
  return TB(e);
}
var mW = class extends Zi {
  constructor() {
    super(...arguments);
    this.model = null;
  }
  setModel(e) {
    if (!(e instanceof pr))
      throw new Error("model must be a LayersModel, not some other Container");
    this.model = e;
  }
};
function qc(e, t) {
  return e < t;
}
function Vx(e, t) {
  return e > t;
}
var gW = class extends mW {
  constructor(e) {
    super();
    if (e == null && (e = {}), e.restoreBestWeights)
      throw new Fe("restoreBestWeights = True is not implemented in EarlyStopping yet.");
    this.monitor = e.monitor || "val_loss", this.minDelta = Math.abs(e.minDelta || 0), this.patience = e.patience || 0, this.verbose = e.verbose || 0, this.mode = e.mode || "auto", this.baseline = e.baseline, ["auto", "min", "max"].indexOf(this.mode) === -1 && (console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`), this.mode = "auto"), this.mode === "min" ? this.monitorFunc = qc : this.mode === "max" ? this.monitorFunc = Vx : this.monitor.indexOf("acc") !== -1 ? this.monitorFunc = Vx : this.monitorFunc = qc, this.monitorFunc === qc && (this.minDelta *= -1);
  }
  async onTrainBegin(e) {
    this.wait = 0, this.stoppedEpoch = 0, this.baseline != null ? this.best = this.baseline : this.best = this.monitorFunc === qc ? 1 / 0 : -1 / 0;
  }
  async onEpochEnd(e, t) {
    await rr(t);
    let n10 = this.getMonitorValue(t);
    n10 != null && (this.monitorFunc(n10 - this.minDelta, this.best) ? (this.best = n10, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e, this.model.stopTraining = true)));
  }
  async onTrainEnd(e) {
    this.stoppedEpoch > 0 && this.verbose && console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
  }
  getMonitorValue(e) {
    e == null && (e = {});
    let t = e[this.monitor];
    return t == null && console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`), t;
  }
};
function bW(e) {
  return new gW(e);
}
var fpe = { earlyStopping: bW };
var yW = X2();
yW.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (e) => {
  e && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
});
var V0 = ((e) => (e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_QINT16 = 15] = "DT_QINT16", e[e.DT_QUINT16 = 16] = "DT_QUINT16", e[e.DT_UINT16 = 17] = "DT_UINT16", e[e.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e[e.DT_HALF = 19] = "DT_HALF", e[e.DT_RESOURCE = 20] = "DT_RESOURCE", e[e.DT_VARIANT = 21] = "DT_VARIANT", e[e.DT_UINT32 = 22] = "DT_UINT32", e[e.DT_UINT64 = 23] = "DT_UINT64", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e[e.DT_QINT16_REF = 115] = "DT_QINT16_REF", e[e.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e[e.DT_UINT16_REF = 117] = "DT_UINT16_REF", e[e.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e[e.DT_HALF_REF = 119] = "DT_HALF_REF", e[e.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e[e.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e[e.DT_UINT32_REF = 122] = "DT_UINT32_REF", e[e.DT_UINT64_REF = 123] = "DT_UINT64_REF", e))(V0 || {});
var Wx;
((e) => {
  let t;
  ((n10) => {
    n10[n10.LEGACY = 0] = "LEGACY", n10[n10.V1 = 1] = "V1", n10[n10.V2 = 2] = "V2";
  })(t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));
})(Wx || (Wx = {}));
var qy = {};
function mpe(e, t) {
  let n10 = { tfOpName: e, category: "custom", inputs: [], attrs: [], customExecutor: t };
  qy[e] = n10;
}
function W0(e) {
  return qy[e];
}
function gpe(e) {
  delete qy[e];
}
function I2(e, t, n10, s10, r10) {
  let a10 = t.inputParams[e];
  if (a10 && a10.inputIndexStart !== void 0) {
    let o10 = a10.inputIndexStart, u10 = a10.inputIndexEnd === 0 ? void 0 : a10.inputIndexEnd === void 0 ? o10 + 1 : a10.inputIndexEnd;
    if (a10.type === "tensor")
      return on(t.inputNames[a10.inputIndexStart], n10, s10, r10);
    if (a10.type === "tensors")
      return t.inputNames.slice(o10, u10).map((d10) => on(d10, n10, s10, r10));
    let l10 = on(t.inputNames.slice(o10)[0], n10, s10, r10), c10 = l10.dataSync();
    return a10.type === "number" ? c10[0] : w2.toNestedArray(l10.shape, c10);
  }
  let i10 = t.attrParams[e];
  return i10 && i10.value;
}
function on(e, t, n10, s10) {
  let [r10, a10] = $n(e);
  if (s10 != null) {
    let o10 = s10.getHashTableHandleByName(r10);
    if (o10 != null)
      return o10;
  }
  let i10 = n10.currentContextIds.find((o10) => !!t[Ad(r10, o10)]);
  return i10 !== void 0 ? t[Ad(r10, i10)][a10] : void 0;
}
function vW(e, t, n10) {
  return t[Ad(e, n10.currentContextId)];
}
function Ts(e, t) {
  let [n10, s10, r10] = $n(e);
  return [Ad(n10, t && t.currentContextId), s10, r10];
}
function Ad(e, t) {
  return t ? `${e}-${t}` : e;
}
function $n(e) {
  let t = e.split(":");
  if (t.length === 1)
    return [e, 0, void 0];
  let n10 = t[0], s10 = t.length === 3 ? t[1] : void 0, r10 = Number(t[t.length - 1]);
  return [n10, r10, s10];
}
function nd(e, t, n10) {
  let s10 = I2("pad", e, t, n10);
  if (s10 === "explicit") {
    s10 = I2("explicitPaddings", e, t, n10);
    let r10 = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let a10 = 0; a10 < 4; a10++)
      r10[a10][0] = s10[a10 * 2], r10[a10][1] = s10[a10 * 2 + 1];
    return r10;
  }
  return s10;
}
function Us(e) {
  return e.kept ? e : lr(e);
}
var U0 = {};
Ae(U0, { json: () => xW });
var xW = [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "DivNoNan", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var G0 = {};
Ae(G0, { json: () => wW });
var wW = [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "clipValueMin", type: "number" }, { start: 2, name: "clipValueMax", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Prod", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axes", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsNan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var H0 = {};
Ae(H0, { json: () => kW });
var kW = [{ tfOpName: "EmptyTensorList", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "maxNumElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }] }, { tfOpName: "StatelessIf", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "If", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "StatelessWhile", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "While", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "TensorListScatter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListScatterV2", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }, { start: 3, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGather", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListSetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListReserve", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListFromTensor", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListStack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }, { tfName: "num_elements", name: "numElements", type: "dtype" }] }, { tfOpName: "TensorListSplit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }, { start: 2, name: "lengths", type: "number[]" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcat", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPopBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPushBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }];
var q0 = {};
Ae(q0, { json: () => IW });
var IW = [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [], notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPoolWithArgmax", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number" }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]", notSupported: true }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "FusedDepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "Dilation2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "rates", name: "dilations", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }] }];
var j0 = {};
Ae(j0, { json: () => SW });
var SW = [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }];
var K0 = {};
Ae(K0, { json: () => CW });
var CW = [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV4", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "T_threshold", name: "threshold", type: "dtype", notSupported: true }, { tfName: "pad_to_max_output_size", name: "padToMaxOutputSize", type: "bool" }] }, { tfOpName: "NonMaxSuppressionV5", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }, { start: 5, name: "softNmsSigma", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var X0 = {};
Ae(X0, { json: () => NW });
var NW = [{ tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }, { tfOpName: "Unique", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "UniqueV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }];
var Y0 = {};
Ae(Y0, { json: () => TW });
var TW = [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: true }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }];
var Q0 = {};
Ae(Q0, { json: () => $W });
var $W = [{ tfOpName: "HashTable", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "HashTableV2", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "LookupTableImport", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableImportV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFind", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFindV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableSize", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "LookupTableSizeV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }];
var Z0 = {};
Ae(Z0, { json: () => _W });
var _W = [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }];
var J0 = {};
Ae(J0, { json: () => AW });
var AW = [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SelectV2", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var eS = {};
Ae(eS, { json: () => EW });
var EW = [{ tfOpName: "_FusedMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Einsum", category: "matrices", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "equation", name: "equation", type: "string" }, { tfName: "N", name: "n", type: "number", defaultValue: 2 }, { tfName: "T", name: "dtype", type: "dtype" }] }];
var tS = {};
Ae(tS, { json: () => RW });
var RW = [{ tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "normalization", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: true, notSupported: true }] }];
var nS = {};
Ae(nS, { json: () => DW });
var DW = [{ tfOpName: "Bincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }] }, { tfOpName: "DenseBincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }], attrs: [{ tfName: "binary_output", name: "binaryOutput", type: "bool" }] }, { tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Cumsum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }];
var sS = {};
Ae(sS, { json: () => FW });
var FW = [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }], attrs: [{ tfName: "batch_dims", name: "batchDims", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool[]" }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true }] }];
var rS = {};
Ae(rS, { json: () => OW });
var OW = [{ tfOpName: "SparseFillEmptyRows", category: "sparse", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "denseShape", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }] }, { tfOpName: "SparseReshape", category: "sparse", inputs: [{ start: 0, name: "inputIndices", type: "tensor" }, { start: 1, name: "inputShape", type: "tensor" }, { start: 2, name: "newShape", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SparseSegmentMean", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }, { tfOpName: "SparseSegmentSum", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }];
var aS = {};
Ae(aS, { json: () => PW });
var PW = [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }];
var iS = {};
Ae(iS, { json: () => zW });
var zW = [{ tfOpName: "StringNGrams", category: "string", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "dataSplits", type: "tensor" }], attrs: [{ tfName: "separator", name: "separator", type: "string" }, { tfName: "ngram_widths", name: "nGramWidths", type: "number[]" }, { tfName: "left_pad", name: "leftPad", type: "string" }, { tfName: "right_pad", name: "rightPad", type: "string" }, { tfName: "pad_width", name: "padWidth", type: "number" }, { tfName: "preserve_short_sequences", name: "preserveShortSequences", type: "bool" }], outputs: ["ngrams", "ngrams_splits"] }, { tfOpName: "StringSplit", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "delimiter", type: "tensor" }], attrs: [{ tfName: "skip_empty", name: "skipEmpty", type: "bool" }], outputs: ["indices", "values", "shape"] }, { tfOpName: "StringToHashBucketFast", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "num_buckets", name: "numBuckets", type: "number" }] }];
var oS = {};
Ae(oS, { json: () => MW });
var MW = [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "MirrorPad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "mode", name: "mode", type: "string" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }, { tfOpName: "BroadcastTo", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }], attrs: [] }, { tfOpName: "BroadcastArgs", category: "transformation", inputs: [{ start: 0, name: "s0", type: "tensor" }, { start: 1, name: "s1", type: "tensor" }], attrs: [] }];
var Ux = class {
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  constructor() {
    let e = [U0, G0, H0, q0, j0, K0, X0, Y0, Q0, Z0, J0, eS, tS, nS, sS, rS, aS, iS, oS], t = [].concat(...e.map((n10) => n10.json));
    this.opMappers = t.reduce((n10, s10) => (n10[s10.tfOpName] = s10, n10), {});
  }
  transformGraph(e, t = {}) {
    let n10 = e.node, s10 = [], r10 = [], a10 = [], i10 = n10.reduce((f10, m10) => (f10[m10.name] = this.mapNode(m10), m10.op.startsWith("Placeholder") ? s10.push(f10[m10.name]) : m10.op === "Const" ? r10.push(f10[m10.name]) : (m10.input == null || m10.input.length === 0) && a10.push(f10[m10.name]), f10), {}), o10 = [], u10 = [], l10 = {}, c10 = {};
    t != null && (l10 = this.mapSignatureEntries(t.inputs), c10 = this.mapSignatureEntries(t.outputs));
    let p10 = Object.keys(i10);
    p10.forEach((f10) => {
      let m10 = i10[f10];
      m10.inputNames.forEach((g10, b10) => {
        let [y10, , v10] = Ts(g10), x10 = i10[y10];
        if (x10.outputs != null) {
          let k10 = x10.outputs.indexOf(v10);
          if (k10 !== -1) {
            let C10 = `${y10}:${k10}`;
            m10.inputNames[b10] = C10;
          }
        }
        m10.inputs.push(x10), x10.children.push(m10);
      });
    }), Object.keys(c10).length === 0 ? p10.forEach((f10) => {
      let m10 = i10[f10];
      m10.children.length === 0 && u10.push(m10);
    }) : Object.keys(c10).forEach((f10) => {
      let [m10] = Ts(f10), g10 = i10[m10];
      g10 != null && (g10.signatureKey = c10[f10], u10.push(g10));
    }), Object.keys(l10).length > 0 ? Object.keys(l10).forEach((f10) => {
      let [m10] = Ts(f10), g10 = i10[m10];
      g10 && (g10.signatureKey = l10[f10], o10.push(g10));
    }) : o10 = s10;
    let d10 = {};
    e.library != null && e.library.function != null && (d10 = e.library.function.reduce((f10, m10) => (f10[m10.signature.name] = this.mapFunction(m10), f10), {}));
    let h10 = { nodes: i10, inputs: o10, outputs: u10, weights: r10, placeholders: s10, signature: t, functions: d10 };
    return a10.length > 0 && (h10.initNodes = a10), h10;
  }
  mapSignatureEntries(e) {
    return Object.keys(e || {}).reduce((t, n10) => (t[e[n10].name] = n10, t), {});
  }
  mapNode(e) {
    let t = W0(e.op) || this.opMappers[e.op] || {};
    e.attr == null && (e.attr = {});
    let n10 = { name: e.name, op: e.op, category: t.category, inputNames: (e.input || []).map((s10) => s10.startsWith("^") ? s10.substr(1) : s10), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e.attr, outputs: t.outputs };
    return t.inputs != null && (n10.inputParams = t.inputs.reduce((s10, r10) => (s10[r10.name] = { type: r10.type, inputIndexStart: r10.start, inputIndexEnd: r10.end }, s10), {})), t.attrs != null && (n10.attrParams = t.attrs.reduce((s10, r10) => {
      let a10 = r10.type, i10;
      switch (r10.type) {
        case "string":
          i10 = Sm(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Sm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "string[]":
          i10 = Em(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Em(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "number":
          i10 = Nm(e.attr, r10.tfName, r10.defaultValue || 0), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Nm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "number[]":
          i10 = Am(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Am(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "bool":
          i10 = Cm(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Cm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "bool[]":
          i10 = Dm(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Dm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "shape":
          i10 = _m(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = _m(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "shape[]":
          i10 = Rm(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Rm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "dtype":
          i10 = Tm(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Tm(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "dtype[]":
          i10 = $m(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = $m(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "func":
          i10 = Gx(e.attr, r10.tfName, r10.defaultValue), i10 === void 0 && !!r10.tfDeprecatedName && (i10 = Gx(e.attr, r10.tfDeprecatedName, r10.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error(`Unsupported param type: ${r10.type} for op: ${e.op}`);
      }
      return s10[r10.name] = { value: i10, type: a10 }, s10;
    }, {})), n10;
  }
  mapFunction(e) {
    let t = e.nodeDef, n10 = [], s10 = [], r10 = {};
    t != null && (r10 = t.reduce((c10, p10) => (c10[p10.name] = this.mapNode(p10), p10.op === "Const" && s10.push(c10[p10.name]), c10), {}));
    let a10 = [], i10 = [];
    e.signature.inputArg.forEach((c10) => {
      let [p10] = Ts(c10.name), d10 = { name: p10, op: "Placeholder", inputs: [], inputNames: [], category: "graph", inputParams: {}, attrParams: { dtype: { value: jy(c10.type), type: "dtype" } }, children: [] };
      d10.signatureKey = c10.name, a10.push(d10), r10[p10] = d10;
    }), Object.keys(r10).forEach((c10) => {
      let p10 = r10[c10];
      p10.inputNames.forEach((d10, h10) => {
        let [f10, , m10] = Ts(d10), g10 = r10[f10];
        if (g10.outputs != null) {
          let b10 = g10.outputs.indexOf(m10);
          if (b10 !== -1) {
            let y10 = `${f10}:${b10}`;
            p10.inputNames[h10] = y10;
          }
        }
        p10.inputs.push(g10), g10.children.push(p10);
      });
    });
    let u10 = e.ret;
    e.signature.outputArg.forEach((c10) => {
      let [p10, d10] = Ts(u10[c10.name]), h10 = r10[p10];
      h10 != null && (h10.defaultOutput = d10, i10.push(h10));
    });
    let l10 = this.mapArgsToSignature(e);
    return { nodes: r10, inputs: a10, outputs: i10, weights: s10, placeholders: n10, signature: l10 };
  }
  mapArgsToSignature(e) {
    return { methodName: e.signature.name, inputs: e.signature.inputArg.reduce((t, n10) => (t[n10.name] = this.mapArgToTensorInfo(n10), t), {}), outputs: e.signature.outputArg.reduce((t, n10) => (t[n10.name] = this.mapArgToTensorInfo(n10, e.ret), t), {}) };
  }
  mapArgToTensorInfo(e, t) {
    let n10 = e.name;
    return t != null && (n10 = t[n10]), { name: n10, dtype: e.type };
  }
};
function LW(e) {
  let t = X2().global;
  if (typeof t.atob != "undefined")
    return t.atob(e);
  if (typeof Buffer != "undefined")
    return new Buffer(e, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function uS(e, t) {
  let n10 = Array.isArray(e) ? String.fromCharCode.apply(null, e) : LW(e);
  return t ? n10 : n10.toLowerCase();
}
function Sm(e, t, n10, s10 = false) {
  let r10 = e[t];
  return r10 != null ? uS(r10.s, s10) : n10;
}
function Cm(e, t, n10) {
  let s10 = e[t];
  return s10 ? s10.b : n10;
}
function Nm(e, t, n10) {
  let s10 = e[t] || {}, r10 = s10.i != null ? s10.i : s10.f != null ? s10.f : n10;
  return typeof r10 == "number" ? r10 : parseInt(r10, 10);
}
function jy(e) {
  switch (typeof e == "string" && (e = V0[e]), e) {
    case 1:
    case 19:
      return "float32";
    case 3:
    case 9:
    case 6:
    case 4:
      return "int32";
    case 10:
      return "bool";
    case 2:
      return "float32";
    case 7:
      return "string";
    default:
      return null;
  }
}
function Gx(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.func ? s10.func.name : n10;
}
function Tm(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.type ? jy(s10.type) : n10;
}
function $m(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.list && s10.list.type ? s10.list.type.map((r10) => jy(r10)) : n10;
}
function lS(e) {
  if (!e.unknownRank)
    return e.dim != null ? e.dim.map((t) => typeof t.size == "number" ? t.size : parseInt(t.size, 10)) : [];
}
function _m(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.shape ? lS(s10.shape) : n10;
}
function Am(e, t, n10) {
  let s10 = e[t];
  return s10 ? ((s10.list.f && s10.list.f.length ? s10.list.f : s10.list.i) || []).map((r10) => typeof r10 == "number" ? r10 : parseInt(r10, 10)) : n10;
}
function Em(e, t, n10, s10 = false) {
  let r10 = e[t];
  return r10 && r10.list && r10.list.s ? r10.list.s.map((a10) => uS(a10, s10)) : n10;
}
function Rm(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.list && s10.list.shape ? s10.list.shape.map((r10) => lS(r10)) : n10;
}
function Dm(e, t, n10) {
  let s10 = e[t];
  return s10 && s10.list && s10.list.b ? s10.list.b : n10;
}
var BW = class {
  constructor(e, t, n10) {
    this.node = e, this.tensorMap = t, this.context = n10, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map((s10) => this.getInput(s10)), e.rawAttrs != null && (this.attrs = Object.keys(e.rawAttrs).reduce((s10, r10) => (s10[r10] = this.getAttr(r10), s10), {}));
  }
  getInput(e) {
    return on(e, this.tensorMap, this.context);
  }
  getAttr(e, t) {
    let n10 = this.node.rawAttrs[e];
    if (n10.tensor != null)
      return on(e, this.tensorMap, this.context);
    if (n10.i != null || n10.f != null)
      return Nm(this.node.rawAttrs, e, t);
    if (n10.s != null)
      return Sm(this.node.rawAttrs, e, t);
    if (n10.b != null)
      return Cm(this.node.rawAttrs, e, t);
    if (n10.shape != null)
      return _m(this.node.rawAttrs, e, t);
    if (n10.type != null)
      return Tm(this.node.rawAttrs, e, t);
    if (n10.list != null) {
      if (n10.list.i != null || n10.list.f != null)
        return Am(this.node.rawAttrs, e, t);
      if (n10.list.s != null)
        return Em(this.node.rawAttrs, e, t);
      if (n10.list.shape != null)
        return Rm(this.node.rawAttrs, e, t);
      if (n10.list.b != null)
        return Dm(this.node.rawAttrs, e, t);
      if (n10.list.type != null)
        return $m(this.node.rawAttrs, e, t);
    }
    return t;
  }
};
var VW = (e, t, n10) => {
  switch (e.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [ie2(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "AddN":
      return [LA(I2("tensors", e, t, n10))];
    case "FloorMod":
    case "Mod":
      return [dD(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Mul":
      return [V2(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "RealDiv":
    case "Div":
      return [xe2(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "DivNoNan":
      return [uR(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "FloorDiv":
      return [Lk(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Sub":
      return [ge2(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Minimum":
      return [gp(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Maximum":
      return [Tr(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Pow":
      return [ca(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "SquaredDifference":
      return [mI(I2("a", e, t, n10), I2("b", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var WW = (e, t, n10) => {
  switch (e.op) {
    case "Abs":
    case "ComplexAbs":
      return [Mt(I2("x", e, t, n10))];
    case "Acos":
      return [OA(I2("x", e, t, n10))];
    case "Acosh":
      return [zA(I2("x", e, t, n10))];
    case "Asin":
      return [qA(I2("x", e, t, n10))];
    case "Asinh":
      return [KA(I2("x", e, t, n10))];
    case "Atan":
      return [YA(I2("x", e, t, n10))];
    case "Atan2":
      return [ZA(I2("x", e, t, n10), I2("y", e, t, n10))];
    case "Atanh":
      return [eE(I2("x", e, t, n10))];
    case "Ceil":
      return [_E(I2("x", e, t, n10))];
    case "Complex":
      return [aa(I2("real", e, t, n10), I2("imag", e, t, n10))];
    case "Cos":
      return [Hg(I2("x", e, t, n10))];
    case "Cosh":
      return [Yk(I2("x", e, t, n10))];
    case "Elu":
      return [hp(I2("x", e, t, n10))];
    case "Erf":
      return [fR(I2("x", e, t, n10))];
    case "Exp":
      return [jn(I2("x", e, t, n10))];
    case "Expm1":
      return [yR(I2("x", e, t, n10))];
    case "Floor":
      return [fp(I2("x", e, t, n10))];
    case "Log":
      return [Kn(I2("x", e, t, n10))];
    case "Log1p":
      return [Kg(I2("x", e, t, n10))];
    case "Imag":
      return [qg(I2("x", e, t, n10))];
    case "Neg":
      return [kt(I2("x", e, t, n10))];
    case "Reciprocal":
      return [VD(I2("x", e, t, n10))];
    case "Real":
      return [xd(I2("x", e, t, n10))];
    case "Relu":
      return [Xs(I2("x", e, t, n10))];
    case "Round":
      return [uI(I2("x", e, t, n10))];
    case "Selu":
      return [cI(I2("x", e, t, n10))];
    case "Sigmoid":
      return [qs(I2("x", e, t, n10))];
    case "Sin":
      return [dI(I2("x", e, t, n10))];
    case "Sign":
      return [s3(I2("x", e, t, n10))];
    case "Sinh":
      return [pI(I2("x", e, t, n10))];
    case "Softplus":
      return [Ol(I2("x", e, t, n10))];
    case "Sqrt":
      return [ln(I2("x", e, t, n10))];
    case "Square":
      return [ct(I2("x", e, t, n10))];
    case "Tanh":
      return [Hu(I2("x", e, t, n10))];
    case "Tan":
      return [S3(I2("x", e, t, n10))];
    case "ClipByValue":
      return [Bn(I2("x", e, t, n10), I2("clipValueMin", e, t, n10), I2("clipValueMax", e, t, n10))];
    case "Relu6":
      return [oI(I2("x", e, t, n10))];
    case "Rsqrt":
      return [lI(on(e.inputNames[0], t, n10))];
    case "Prod":
      return [iI(I2("x", e, t, n10), I2("axes", e, t, n10))];
    case "LeakyRelu":
      return [jg(I2("x", e, t, n10), I2("alpha", e, t, n10))];
    case "Prelu":
      return [tb(I2("x", e, t, n10), I2("alpha", e, t, n10))];
    case "IsNan":
      return [_R(on(e.inputNames[0], t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
function Hn(e, t, n10 = "") {
  if (!(typeof e == "number" || typeof t == "number")) {
    w2.assert(e.length === t.length, () => n10 + ` Shapes ${e} and ${t} must match`);
    for (let s10 = 0; s10 < e.length; s10++) {
      let r10 = e[s10], a10 = t[s10];
      w2.assert(r10 < 0 || a10 < 0 || r10 === a10, () => n10 + ` Shapes ${e} and ${t} must match`);
    }
  }
}
function Hx(e) {
  return !(typeof e == "number" || e.some((t) => t < 0));
}
function Cu(e, t, n10) {
  let s10 = Fm(e, n10), r10 = !Hx(s10);
  if (r10 && t.length === 0)
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s10}`);
  if (r10 && t.forEach((a10) => {
    s10 = Fm(a10.shape, s10);
  }), !Hx(s10))
    throw new Error(`Non-fully-defined elementShape: ${s10}`);
  return s10;
}
function Fm(e, t) {
  if (typeof e == "number")
    return t;
  if (typeof t == "number")
    return e;
  if (e.length !== t.length)
    throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);
  let n10 = [];
  for (let s10 = 0; s10 < e.length; ++s10) {
    let r10 = e[s10], a10 = t[s10];
    if (r10 >= 0 && a10 >= 0 && r10 !== a10)
      throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);
    n10[s10] = r10 >= 0 ? r10 : a10;
  }
  return n10;
}
var UW = class {
  constructor(e, t, n10, s10, r10, a10, i10) {
    this.name = e, this.dtype = t, this.maxSize = n10, this.elementShape = s10, this.identicalElementShapes = r10, this.dynamicSize = a10, this.clearAfterRead = i10, this.tensors = [], this.closed_ = false, this.idTensor = Ie2(0), Ht(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  clearAndClose(e) {
    this.tensors.forEach((t) => {
      (e == null || !e.has(t.tensor.id)) && t.tensor.dispose();
    }), this.tensors = [], this.closed_ = true, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  read(e) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || e >= this.size())
      throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
    let t = this.tensors[e];
    if (t.cleared)
      throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    return this.clearAfterRead && (t.cleared = true), t.read = true, t.tensor;
  }
  readMany(e) {
    return e.map((t) => this.read(t));
  }
  write(e, t) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || !this.dynamicSize && e >= this.maxSize)
      throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
    let n10 = this.tensors[e] || {};
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = t.shape), Hn(this.elementShape, t.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), n10.read)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
    if (n10.written)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
    n10.tensor = t, Ht(t), n10.written = true, this.tensors[e] = n10;
  }
  writeMany(e, t) {
    if (e.length !== t.length)
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
    e.forEach((n10, s10) => this.write(n10, t[s10]));
  }
  gather(e, t) {
    if (!!t && t !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);
    if (e)
      e = e.slice(0, this.size());
    else {
      e = [];
      for (let s10 = 0; s10 < this.size(); s10++)
        e.push(s10);
    }
    if (e.length === 0)
      return hs([], [0].concat(this.elementShape));
    let n10 = this.readMany(e);
    return Hn(this.elementShape, n10[0].shape, "TensorArray shape mismatch: "), Qn(n10, 0);
  }
  concat(e) {
    if (!!e && e !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
    if (this.size() === 0)
      return hs([], [0].concat(this.elementShape));
    let t = [];
    for (let s10 = 0; s10 < this.size(); s10++)
      t.push(s10);
    let n10 = this.readMany(t);
    return Hn(this.elementShape, n10[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n10[0].shape})`), Ft(n10, 0);
  }
  scatter(e, t) {
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
    if (e.length !== t.shape[0])
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
    let n10 = Math.max(...e);
    if (!this.dynamicSize && n10 >= this.maxSize)
      throw new Error(`Max index must be < array size (${n10}  vs. ${this.maxSize})`);
    this.writeMany(e, Fs(t, 0));
  }
  split(e, t) {
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
    let n10 = 0, s10 = e.map((o10) => (n10 += o10, n10));
    if (n10 !== t.shape[0])
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n10}, and tensor's shape is: ${t.shape}`);
    if (!this.dynamicSize && e.length !== this.maxSize)
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
    let r10 = n10 === 0 ? 0 : t.size / n10, a10 = [];
    j2(() => {
      t = G2(t, [1, n10, r10]);
      for (let o10 = 0; o10 < e.length; ++o10) {
        let u10 = o10 === 0 ? 0 : s10[o10 - 1], l10 = [0, u10, 0], c10 = [1, e[o10], r10];
        a10[o10] = G2(He(t, l10, c10), this.elementShape);
      }
      return a10;
    });
    let i10 = [];
    for (let o10 = 0; o10 < e.length; o10++)
      i10[o10] = o10;
    this.writeMany(i10, a10);
  }
};
var ql = class {
  constructor(e, t, n10, s10 = -1) {
    this.tensors = e, this.elementShape = t, this.elementDtype = n10, e != null && e.forEach((r10) => {
      if (n10 !== r10.dtype)
        throw new Error(`Invalid data types; op elements ${n10}, but list elements ${r10.dtype}`);
      Hn(t, r10.shape, "TensorList shape mismatch: "), Ht(r10);
    }), this.idTensor = Ie2(0), this.maxNumElements = s10, Ht(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  copy() {
    return new ql([...this.tensors], this.elementShape, this.elementDtype);
  }
  clearAndClose(e) {
    this.tensors.forEach((t) => {
      (e == null || !e.has(t.id)) && t.dispose();
    }), this.tensors.length = 0, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  stack(e, t, n10 = -1) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    if (n10 !== -1 && this.tensors.length !== n10)
      throw new Error(`Operation expected a list with ${n10} elements but got a list with ${this.tensors.length} elements.`);
    Hn(e, this.elementShape, "TensorList shape mismatch: ");
    let s10 = Cu(this.elementShape, this.tensors, e);
    return j2(() => {
      let r10 = this.tensors.map((a10) => G2(a10, s10));
      return Qn(r10, 0);
    });
  }
  popBack(e, t) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    if (this.size() === 0)
      throw new Error("Trying to pop from an empty list.");
    let n10 = Cu(this.elementShape, this.tensors, e), s10 = this.tensors.pop();
    return Hn(s10.shape, e, "TensorList shape mismatch: "), G2(s10, n10);
  }
  pushBack(e) {
    if (e.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
    if (Hn(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size())
      throw new Error("Trying to push element into a full list.");
    Ht(e), this.tensors.push(e);
  }
  resize(e) {
    if (e < 0)
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
    if (this.maxNumElements !== -1 && e > this.maxNumElements)
      throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
    this.tensors.length = e;
  }
  getItem(e, t, n10) {
    if (n10 !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n10}, but list elements ${this.elementDtype}`);
    if (e < 0 || e > this.tensors.length)
      throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
    if (this.tensors[e] == null)
      throw new Error(`element at index ${e} is null.`);
    Hn(this.tensors[e].shape, t, "TensorList shape mismatch: ");
    let s10 = Cu(this.elementShape, this.tensors, t);
    return G2(this.tensors[e], s10);
  }
  setItem(e, t) {
    if (t.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);
    if (e < 0 || this.maxNumElements !== -1 && e >= this.maxNumElements)
      throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
    Hn(this.elementShape, t.shape, "TensorList shape mismatch: "), Ht(t), this.tensors[e] = t;
  }
  gather(e, t, n10) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    Hn(this.elementShape, n10, "TensorList shape mismatch: "), e = e.slice(0, this.size());
    let s10 = Cu(this.elementShape, this.tensors, n10);
    return e.length === 0 ? hs([], [0].concat(s10)) : j2(() => {
      let r10 = e.map((a10) => G2(this.tensors[a10], s10));
      return Qn(r10, 0);
    });
  }
  concat(e, t) {
    if (!!e && e !== this.elementDtype)
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
    Hn(this.elementShape, t, "TensorList shape mismatch: ");
    let n10 = Cu(this.elementShape, this.tensors, t);
    return this.size() === 0 ? hs([], [0].concat(n10)) : j2(() => {
      let s10 = this.tensors.map((r10) => G2(r10, n10));
      return Ft(s10, 0);
    });
  }
};
function GW(e, t, n10) {
  let s10 = e.dtype;
  if (e.shape.length < 1)
    throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);
  if (e.dtype !== n10)
    throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n10}`);
  let r10 = e.shape.slice(1);
  Hn(r10, t, "TensorList shape mismatch: ");
  let a10 = Fs(e);
  return new ql(a10, t, s10);
}
function HW(e, t, n10) {
  return new ql([], e, t, n10);
}
function qW(e, t, n10, s10) {
  if (t.length !== e.shape[0])
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);
  let r10 = Math.max(...t);
  if (s10 != null && s10 !== -1 && r10 >= s10)
    throw new Error(`Max index must be < array size (${r10}  vs. ${s10})`);
  let a10 = new ql([], n10, e.dtype, s10), i10 = Fs(e, 0);
  return t.forEach((o10, u10) => {
    a10.setItem(o10, i10[u10]);
  }), a10;
}
function jW(e, t, n10) {
  let s10 = 0, r10 = t.map((c10) => (s10 += c10, s10));
  if (s10 !== e.shape[0])
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s10}, and tensor's shape is: ${e.shape}`);
  let a10 = e.shape.slice(1), i10 = Fm(a10, n10), o10 = s10 === 0 ? 0 : e.size / s10, u10 = j2(() => {
    let c10 = [];
    e = G2(e, [1, s10, o10]);
    for (let p10 = 0; p10 < t.length; ++p10) {
      let d10 = p10 === 0 ? 0 : r10[p10 - 1], h10 = [0, d10, 0], f10 = [1, t[p10], o10];
      c10[p10] = G2(He(e, h10, f10), i10);
    }
    return e.dispose(), c10;
  }), l10 = new ql([], n10, e.dtype, t.length);
  for (let c10 = 0; c10 < u10.length; c10++)
    l10.setItem(c10, u10[c10]);
  return l10;
}
var KW = async (e, t, n10) => {
  switch (e.op) {
    case "If":
    case "StatelessIf": {
      let s10 = I2("thenBranch", e, t, n10), r10 = I2("elseBranch", e, t, n10), a10 = I2("cond", e, t, n10), i10 = I2("args", e, t, n10);
      return (await a10.data())[0] ? n10.functionMap[s10].executeFunctionAsync(i10, n10.tensorArrayMap, n10.tensorListMap) : n10.functionMap[r10].executeFunctionAsync(i10, n10.tensorArrayMap, n10.tensorListMap);
    }
    case "While":
    case "StatelessWhile": {
      let s10 = I2("body", e, t, n10), r10 = I2("cond", e, t, n10), a10 = I2("args", e, t, n10), i10 = await n10.functionMap[r10].executeFunctionAsync(a10, n10.tensorArrayMap, n10.tensorListMap), o10 = a10.map((c10) => c10.id), u10 = await i10[0].data();
      i10.forEach((c10) => {
        !c10.kept && o10.indexOf(c10.id) === -1 && c10.dispose();
      });
      let l10 = a10;
      for (; u10[0]; ) {
        let c10 = l10;
        l10 = await n10.functionMap[s10].executeFunctionAsync(l10, n10.tensorArrayMap, n10.tensorListMap);
        let p10 = l10.map((h10) => h10.id);
        c10.forEach((h10) => {
          !h10.kept && o10.indexOf(h10.id) === -1 && p10.indexOf(h10.id) === -1 && h10.dispose();
        });
        let d10 = await n10.functionMap[r10].executeFunctionAsync(l10, n10.tensorArrayMap, n10.tensorListMap);
        u10 = await d10[0].data(), d10.forEach((h10) => {
          !h10.kept && o10.indexOf(h10.id) === -1 && p10.indexOf(h10.id) === -1 && h10.dispose();
        });
      }
      return l10;
    }
    case "LoopCond": {
      let s10 = I2("pred", e, t, n10);
      return [Us(s10)];
    }
    case "Switch": {
      let s10 = I2("pred", e, t, n10), r10 = I2("data", e, t, n10);
      return r10.kept || (r10 = Us(r10)), (await s10.data())[0] ? [void 0, r10] : [r10, void 0];
    }
    case "Merge": {
      let s10 = e.inputNames.find((r10) => on(r10, t, n10) !== void 0);
      if (s10) {
        let r10 = on(s10, t, n10);
        return [Us(r10)];
      }
      return;
    }
    case "Enter": {
      let s10 = I2("frameName", e, t, n10), r10 = I2("tensor", e, t, n10);
      return n10.enterFrame(s10), [Us(r10)];
    }
    case "Exit": {
      let s10 = I2("tensor", e, t, n10);
      return n10.exitFrame(), [Us(s10)];
    }
    case "NextIteration": {
      let s10 = I2("tensor", e, t, n10);
      return n10.nextIteration(), [Us(s10)];
    }
    case "TensorArrayV3": {
      let s10 = I2("size", e, t, n10), r10 = I2("dtype", e, t, n10), a10 = I2("elementShape", e, t, n10), i10 = I2("dynamicSize", e, t, n10), o10 = I2("clearAfterRead", e, t, n10), u10 = I2("identicalElementShapes", e, t, n10), l10 = I2("name", e, t, n10), c10 = new UW(l10, r10, s10, a10, u10, i10, o10);
      return n10.addTensorArray(c10), [c10.idTensor, Ie2(1)];
    }
    case "TensorArrayWriteV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = I2("index", e, t, n10), a10 = I2("tensor", e, t, n10), i10 = n10.getTensorArray(s10.id);
      return i10.write(r10, a10), [i10.idTensor];
    }
    case "TensorArrayReadV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = I2("index", e, t, n10);
      return [n10.getTensorArray(s10.id).read(r10)];
    }
    case "TensorArrayGatherV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = I2("indices", e, t, n10), a10 = I2("dtype", e, t, n10);
      return [n10.getTensorArray(s10.id).gather(r10, a10)];
    }
    case "TensorArrayScatterV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = I2("indices", e, t, n10), a10 = I2("tensor", e, t, n10), i10 = n10.getTensorArray(s10.id);
      return i10.scatter(r10, a10), [i10.idTensor];
    }
    case "TensorArrayConcatV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = n10.getTensorArray(s10.id), a10 = I2("dtype", e, t, n10);
      return [r10.concat(a10)];
    }
    case "TensorArraySplitV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = I2("tensor", e, t, n10), a10 = I2("lengths", e, t, n10), i10 = n10.getTensorArray(s10.id);
      return i10.split(a10, r10), [i10.idTensor];
    }
    case "TensorArraySizeV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = n10.getTensorArray(s10.id);
      return [Ie2(r10.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      let s10 = I2("tensorArrayId", e, t, n10), r10 = n10.getTensorArray(s10.id);
      return r10.clearAndClose(), [r10.idTensor];
    }
    case "TensorListSetItem": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("index", e, t, n10), a10 = I2("tensor", e, t, n10), i10 = n10.getTensorList(s10.id);
      return i10.setItem(r10, a10), [i10.idTensor];
    }
    case "TensorListGetItem": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("index", e, t, n10), a10 = I2("elementShape", e, t, n10), i10 = I2("elementDType", e, t, n10);
      return [n10.getTensorList(s10.id).getItem(r10, a10, i10)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      let s10 = I2("indices", e, t, n10), r10 = I2("tensor", e, t, n10), a10 = I2("elementShape", e, t, n10), i10 = I2("numElements", e, t, n10), o10 = qW(r10, s10, a10, i10);
      return n10.addTensorList(o10), [o10.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      let s10 = I2("elementShape", e, t, n10), r10 = I2("elementDType", e, t, n10), a10;
      e.op === "TensorListReserve" ? a10 = "numElements" : a10 = "maxNumElements";
      let i10 = I2(a10, e, t, n10), o10 = HW(s10, r10, i10);
      return n10.addTensorList(o10), [o10.idTensor];
    }
    case "TensorListGather": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("indices", e, t, n10), a10 = I2("elementShape", e, t, n10), i10 = I2("elementDType", e, t, n10);
      return [n10.getTensorList(s10.id).gather(r10, i10, a10)];
    }
    case "TensorListStack": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("elementShape", e, t, n10), a10 = I2("elementDType", e, t, n10), i10 = I2("numElements", e, t, n10);
      return [n10.getTensorList(s10.id).stack(r10, a10, i10)];
    }
    case "TensorListFromTensor": {
      let s10 = I2("tensor", e, t, n10), r10 = I2("elementShape", e, t, n10), a10 = I2("elementDType", e, t, n10), i10 = GW(s10, r10, a10);
      return n10.addTensorList(i10), [i10.idTensor];
    }
    case "TensorListConcat": {
      let s10 = I2("tensorListId", e, t, n10), r10 = n10.getTensorList(s10.id), a10 = I2("dtype", e, t, n10), i10 = I2("elementShape", e, t, n10);
      return [r10.concat(a10, i10)];
    }
    case "TensorListPushBack": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("tensor", e, t, n10), a10 = n10.getTensorList(s10.id);
      return a10.pushBack(r10), [a10.idTensor];
    }
    case "TensorListPopBack": {
      let s10 = I2("tensorListId", e, t, n10), r10 = I2("elementShape", e, t, n10), a10 = I2("elementDType", e, t, n10);
      return [n10.getTensorList(s10.id).popBack(r10, a10)];
    }
    case "TensorListSplit": {
      let s10 = I2("tensor", e, t, n10), r10 = I2("elementShape", e, t, n10), a10 = I2("lengths", e, t, n10), i10 = jW(s10, a10, r10);
      return n10.addTensorList(i10), [i10.idTensor];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
function qx(e, t, n10) {
  let [s10, r10] = I2("fusedOps", e, t, n10), a10 = s10 === "biasadd", i10 = !a10, o10 = r10 === "prelu", u10 = s10 === "fusedbatchnorm", l10 = I2("numArgs", e, t, n10);
  if (a10) {
    if (o10 && l10 !== 2)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!o10 && a10 && l10 !== 1)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (u10)
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  let c10 = I2("strides", e, t, n10), p10 = nd(e, t, n10), d10 = I2("dataFormat", e, t, n10).toUpperCase(), h10 = I2("dilations", e, t, n10), [f10, m10] = I2("args", e, t, n10);
  i10 && (m10 = f10, f10 = void 0);
  let g10 = I2("leakyreluAlpha", e, t, n10);
  return { stride: c10, pad: p10, dataFormat: d10, dilations: h10, biasArg: f10, preluArg: m10, activationFunc: r10, leakyreluAlpha: g10 };
}
var XW = (e, t, n10) => {
  switch (e.op) {
    case "Conv1D": {
      let s10 = I2("stride", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("dataFormat", e, t, n10).toUpperCase(), i10 = I2("dilation", e, t, n10);
      return [qk(I2("x", e, t, n10), I2("filter", e, t, n10), s10, r10, a10, i10)];
    }
    case "Conv2D": {
      let s10 = I2("strides", e, t, n10), r10 = nd(e, t, n10), a10 = I2("dataFormat", e, t, n10).toUpperCase(), i10 = I2("dilations", e, t, n10);
      return [ua(I2("x", e, t, n10), I2("filter", e, t, n10), [s10[1], s10[2]], r10, a10, [i10[1], i10[2]])];
    }
    case "_FusedConv2D": {
      let { stride: s10, pad: r10, dataFormat: a10, dilations: i10, biasArg: o10, preluArg: u10, activationFunc: l10, leakyreluAlpha: c10 } = qx(e, t, n10);
      return [da.conv2d({ x: I2("x", e, t, n10), filter: I2("filter", e, t, n10), strides: [s10[1], s10[2]], pad: r10, dataFormat: a10, dilations: [i10[1], i10[2]], bias: o10, activation: l10, preluActivationWeights: u10, leakyreluAlpha: c10 })];
    }
    case "FusedDepthwiseConv2dNative": {
      let { stride: s10, pad: r10, dataFormat: a10, dilations: i10, biasArg: o10, preluArg: u10, activationFunc: l10, leakyreluAlpha: c10 } = qx(e, t, n10);
      return [da.depthwiseConv2d({ x: I2("x", e, t, n10), filter: I2("filter", e, t, n10), strides: [s10[1], s10[2]], pad: r10, dataFormat: a10, dilations: [i10[1], i10[2]], bias: o10, activation: l10, preluActivationWeights: u10, leakyreluAlpha: c10 })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      let s10 = I2("outputShape", e, t, n10), r10 = I2("strides", e, t, n10), a10 = nd(e, t, n10);
      return [jk(I2("x", e, t, n10), I2("filter", e, t, n10), s10, [r10[1], r10[2]], a10)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      let s10 = I2("strides", e, t, n10), r10 = nd(e, t, n10), a10 = I2("dilations", e, t, n10), i10 = I2("dataFormat", e, t, n10).toUpperCase();
      return [pp(I2("input", e, t, n10), I2("filter", e, t, n10), [s10[1], s10[2]], r10, i10, [a10[1], a10[2]])];
    }
    case "Conv3D": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("dataFormat", e, t, n10).toUpperCase(), i10 = I2("dilations", e, t, n10);
      return [Kk(I2("x", e, t, n10), I2("filter", e, t, n10), [s10[1], s10[2], s10[3]], r10, a10, [i10[1], i10[2], i10[3]])];
    }
    case "AvgPool": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("kernelSize", e, t, n10);
      return [Wg(I2("x", e, t, n10), [a10[1], a10[2]], [s10[1], s10[2]], r10)];
    }
    case "MaxPool": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("kernelSize", e, t, n10);
      return [Zg(I2("x", e, t, n10), [a10[1], a10[2]], [s10[1], s10[2]], r10)];
    }
    case "MaxPoolWithArgmax": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("kernelSize", e, t, n10), i10 = I2("includeBatchInIndex", e, t, n10), { result: o10, indexes: u10 } = sD(I2("x", e, t, n10), [a10[1], a10[2]], [s10[1], s10[2]], r10, i10);
      return [o10, u10];
    }
    case "AvgPool3D": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("kernelSize", e, t, n10);
      return [Gk(I2("x", e, t, n10), [a10[1], a10[2], a10[3]], [s10[1], s10[2], s10[3]], r10)];
    }
    case "MaxPool3D": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("kernelSize", e, t, n10);
      return [aI(I2("x", e, t, n10), [a10[1], a10[2], a10[3]], [s10[1], s10[2], s10[3]], r10)];
    }
    case "Dilation2D": {
      let s10 = I2("strides", e, t, n10), r10 = I2("pad", e, t, n10), a10 = I2("dilations", e, t, n10), i10 = s10[1], o10 = s10[2], u10 = a10[1], l10 = a10[2];
      return [sR(I2("x", e, t, n10), I2("filter", e, t, n10), [i10, o10], r10, [u10, l10], "NHWC")];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var YW = (e, t, n10) => {
  switch (e.op) {
    case "Fill": {
      let s10 = I2("shape", e, t, n10), r10 = I2("dtype", e, t, n10), a10 = I2("value", e, t, n10);
      return [Fl(s10, a10, r10)];
    }
    case "LinSpace": {
      let s10 = I2("start", e, t, n10), r10 = I2("stop", e, t, n10), a10 = I2("num", e, t, n10);
      return [DR(s10, r10, a10)];
    }
    case "Multinomial": {
      let s10 = I2("logits", e, t, n10), r10 = I2("numSamples", e, t, n10), a10 = I2("seed", e, t, n10);
      return [gD(s10, r10, a10)];
    }
    case "OneHot": {
      let s10 = I2("indices", e, t, n10), r10 = I2("depth", e, t, n10), a10 = I2("onValue", e, t, n10), i10 = I2("offValue", e, t, n10);
      return [yd(s10, r10, a10, i10)];
    }
    case "Ones":
      return [zn(I2("shape", e, t, n10), I2("dtype", e, t, n10))];
    case "OnesLike":
      return [Xn(I2("x", e, t, n10))];
    case "RandomUniform":
      return [Pl(I2("shape", e, t, n10), I2("minval", e, t, n10), I2("maxval", e, t, n10), I2("dtype", e, t, n10))];
    case "Range": {
      let s10 = I2("start", e, t, n10), r10 = I2("stop", e, t, n10), a10 = I2("step", e, t, n10);
      return [Xu(s10, r10, a10, I2("dtype", e, t, n10))];
    }
    case "TruncatedNormal": {
      let s10 = I2("shape", e, t, n10), r10 = I2("mean", e, t, n10), a10 = I2("stdDev", e, t, n10), i10 = I2("seed", e, t, n10);
      return [lb(s10, r10, a10, I2("dtype", e, t, n10), i10)];
    }
    case "Zeros":
      return [$t(I2("shape", e, t, n10), I2("dtype", e, t, n10))];
    case "ZerosLike":
      return [je(I2("x", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
function Uf(e, t, n10) {
  let s10 = I2("boxes", e, t, n10), r10 = I2("scores", e, t, n10), a10 = I2("maxOutputSize", e, t, n10), i10 = I2("iouThreshold", e, t, n10), o10 = I2("scoreThreshold", e, t, n10), u10 = I2("softNmsSigma", e, t, n10);
  return { boxes: s10, scores: r10, maxOutputSize: a10, iouThreshold: i10, scoreThreshold: o10, softNmsSigma: u10 };
}
var QW = async (e, t, n10) => {
  switch (e.op) {
    case "NonMaxSuppressionV5": {
      let { boxes: s10, scores: r10, maxOutputSize: a10, iouThreshold: i10, scoreThreshold: o10, softNmsSigma: u10 } = Uf(e, t, n10), l10 = await ds.nonMaxSuppressionWithScoreAsync(s10, r10, a10, i10, o10, u10);
      return [l10.selectedIndices, l10.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      let { boxes: s10, scores: r10, maxOutputSize: a10, iouThreshold: i10, scoreThreshold: o10 } = Uf(e, t, n10), u10 = I2("padToMaxOutputSize", e, t, n10), l10 = await ds.nonMaxSuppressionPaddedAsync(s10, r10, a10, i10, o10, u10);
      return [l10.selectedIndices, l10.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      let { boxes: s10, scores: r10, maxOutputSize: a10, iouThreshold: i10, scoreThreshold: o10 } = Uf(e, t, n10);
      return [await ds.nonMaxSuppressionAsync(s10, r10, a10, i10, o10)];
    }
    case "Where": {
      let s10 = ce2(I2("condition", e, t, n10), "bool"), r10 = [await bI(s10)];
      return s10.dispose(), r10;
    }
    case "ListDiff":
      return t3(I2("x", e, t, n10), I2("y", e, t, n10));
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var ZW = (e, t, n10) => {
  switch (e.op) {
    case "TopKV2": {
      let s10 = I2("x", e, t, n10), r10 = I2("k", e, t, n10), a10 = I2("sorted", e, t, n10), i10 = N3(s10, r10, a10);
      return [i10.values, i10.indices];
    }
    case "Unique": {
      let s10 = I2("x", e, t, n10), r10 = cx(s10);
      return [r10.values, r10.indices];
    }
    case "UniqueV2": {
      let s10 = I2("x", e, t, n10), r10 = I2("axis", e, t, n10), a10 = cx(s10, r10);
      return [a10.values, a10.indices];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var JW = (e, t, n10) => {
  switch (e.op) {
    case "Const":
      return t[e.name];
    case "PlaceholderWithDefault":
      let s10 = I2("default", e, t, n10);
      return [on(e.name, t, n10) || s10];
    case "Placeholder":
      return [on(e.name, t, n10)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      let l10 = I2("x", e, t, n10);
      return [Us(l10)];
    }
    case "IdentityN":
      return I2("x", e, t, n10).map((l10) => Us(l10));
    case "Snapshot":
      let r10 = I2("x", e, t, n10);
      return [Us(r10)];
    case "Shape":
      return [Qt(I2("x", e, t, n10).shape, "int32")];
    case "ShapeN":
      return I2("x", e, t, n10).map((l10) => Qt(l10.shape));
    case "Size":
      return [Ie2(I2("x", e, t, n10).size, "int32")];
    case "Rank":
      return [Ie2(I2("x", e, t, n10).rank, "int32")];
    case "NoOp":
      return [Ie2(1)];
    case "Print":
      let a10 = I2("x", e, t, n10), i10 = I2("data", e, t, n10), o10 = I2("message", e, t, n10), u10 = I2("summarize", e, t, n10);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o10);
      for (let l10 = 0; l10 < i10.length; l10++)
        console.log(Array.prototype.slice.call(i10[l10].dataSync()).slice(0, u10));
      return [a10];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var e4 = class {
  constructor(e, t) {
    this.keyDType = e, this.valueDType = t, this.handle = Ie2(0), this.tensorMap = /* @__PURE__ */ new Map(), Ht(this.handle);
  }
  get id() {
    return this.handle.id;
  }
  clearAndClose() {
    this.tensorMap.forEach((e) => e.dispose()), this.tensorMap.clear(), this.handle.dispose();
  }
  size() {
    return this.tensorMap.size;
  }
  tensorSize() {
    return Ie2(this.size(), "int32");
  }
  async import(e, t) {
    this.checkKeyAndValueTensor(e, t);
    let n10 = await e.data();
    return this.tensorMap.forEach((s10) => s10.dispose()), this.tensorMap.clear(), j2(() => {
      let s10 = Fs(t), r10 = n10.length, a10 = s10.length;
      w2.assert(r10 === a10, () => `The number of elements doesn't match, keys has ${r10} elements, the values has ${a10} elements.`);
      for (let i10 = 0; i10 < r10; i10++) {
        let o10 = n10[i10], u10 = s10[i10];
        Ht(u10), this.tensorMap.set(o10, u10);
      }
      return this.handle;
    });
  }
  async find(e, t) {
    this.checkKeyAndValueTensor(e, t);
    let n10 = await e.data();
    return j2(() => {
      let s10 = [];
      for (let r10 = 0; r10 < n10.length; r10++) {
        let a10 = n10[r10], i10 = this.findWithDefault(a10, t);
        s10.push(i10);
      }
      return Qn(s10);
    });
  }
  findWithDefault(e, t) {
    let n10 = this.tensorMap.get(e);
    return n10 != null ? n10 : t;
  }
  checkKeyAndValueTensor(e, t) {
    if (e.dtype !== this.keyDType)
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
    if (t.dtype !== this.valueDType)
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`);
  }
};
var t4 = async (e, t, n10, s10) => {
  switch (e.op) {
    case "HashTable":
    case "HashTableV2": {
      let r10 = I2("keyDType", e, t, n10), a10 = I2("valueDType", e, t, n10), i10 = new e4(r10, a10);
      return s10.addHashTable(e.name, i10), [i10.handle];
    }
    case "LookupTableImport":
    case "LookupTableImportV2": {
      let r10 = I2("tableHandle", e, t, n10, s10), a10 = I2("keys", e, t, n10), i10 = I2("values", e, t, n10);
      return [await s10.getHashTableById(r10.id).import(a10, i10)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      let r10 = I2("tableHandle", e, t, n10, s10), a10 = I2("keys", e, t, n10), i10 = I2("defaultValue", e, t, n10);
      return [await s10.getHashTableById(r10.id).find(a10, i10)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      let r10 = I2("tableHandle", e, t, n10, s10);
      return [s10.getHashTableById(r10.id).tensorSize()];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var n4 = (e, t, n10) => {
  switch (e.op) {
    case "ResizeBilinear": {
      let s10 = I2("images", e, t, n10), r10 = I2("size", e, t, n10), a10 = I2("alignCorners", e, t, n10), i10 = I2("halfPixelCenters", e, t, n10);
      return [ds.resizeBilinear(s10, [r10[0], r10[1]], a10, i10)];
    }
    case "ResizeNearestNeighbor": {
      let s10 = I2("images", e, t, n10), r10 = I2("size", e, t, n10), a10 = I2("alignCorners", e, t, n10), i10 = I2("halfPixelCenters", e, t, n10);
      return [ds.resizeNearestNeighbor(s10, [r10[0], r10[1]], a10, i10)];
    }
    case "CropAndResize": {
      let s10 = I2("image", e, t, n10), r10 = I2("boxes", e, t, n10), a10 = I2("boxInd", e, t, n10), i10 = I2("cropSize", e, t, n10), o10 = I2("method", e, t, n10), u10 = I2("extrapolationValue", e, t, n10);
      return [ds.cropAndResize(s10, r10, a10, i10, o10, u10)];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var s4 = (e, t, n10) => {
  switch (e.op) {
    case "Equal":
      return [qn(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "NotEqual":
      return [Ku(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Greater":
      return [Wn(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "GreaterEqual":
      return [jo(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Less":
      return [Jk(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "LessEqual":
      return [Ko(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "LogicalAnd":
      return [Ds(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "LogicalNot":
      return [Qg(I2("a", e, t, n10))];
    case "LogicalOr":
      return [rI(I2("a", e, t, n10), I2("b", e, t, n10))];
    case "Select":
    case "SelectV2":
      return [vn(I2("condition", e, t, n10), I2("a", e, t, n10), I2("b", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var r4 = (e, t, n10) => {
  switch (e.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [We(I2("a", e, t, n10), I2("b", e, t, n10), I2("transposeA", e, t, n10), I2("transposeB", e, t, n10))];
    case "Einsum":
      return [dR(I2("equation", e, t, n10), ...I2("tensors", e, t, n10))];
    case "Transpose":
      return [qe(I2("x", e, t, n10), I2("perm", e, t, n10))];
    case "_FusedMatMul":
      let [s10, r10] = I2("fusedOps", e, t, n10), a10 = s10 === "biasadd", i10 = r10 === "prelu", o10 = I2("numArgs", e, t, n10), u10 = I2("leakyreluAlpha", e, t, n10);
      if (a10) {
        if (i10 && o10 !== 2)
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!i10 && o10 !== 1)
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      let [l10, c10] = I2("args", e, t, n10);
      return [da.matMul({ a: I2("a", e, t, n10), b: I2("b", e, t, n10), transposeA: I2("transposeA", e, t, n10), transposeB: I2("transposeB", e, t, n10), bias: l10, activation: r10, preluActivationWeights: c10, leakyreluAlpha: u10 })];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var a4 = (e, t, n10) => {
  switch (e.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
      return [qu(I2("x", e, t, n10), I2("mean", e, t, n10), I2("variance", e, t, n10), I2("offset", e, t, n10), I2("scale", e, t, n10), I2("epsilon", e, t, n10))];
    case "FusedBatchNormV3":
      return [qu(I2("x", e, t, n10), I2("mean", e, t, n10), I2("variance", e, t, n10), I2("offset", e, t, n10), I2("scale", e, t, n10), I2("epsilon", e, t, n10))];
    case "LRN":
      return [OR(I2("x", e, t, n10), I2("radius", e, t, n10), I2("bias", e, t, n10), I2("alpha", e, t, n10), I2("beta", e, t, n10))];
    case "Softmax":
      return [ib(I2("x", e, t, n10))];
    case "LogSoftmax":
      return [eI(I2("x", e, t, n10))];
    case "SparseToDense":
      return [xI(I2("sparseIndices", e, t, n10), I2("outputShape", e, t, n10), I2("sparseValues", e, t, n10), I2("defaultValue", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var i4 = (e, t, n10) => {
  switch (e.op) {
    case "Max": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [As(I2("x", e, t, n10), i10, o10)];
    }
    case "Mean": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [It(I2("x", e, t, n10), i10, o10)];
    }
    case "Min": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [pm(I2("x", e, t, n10), i10, o10)];
    }
    case "Sum": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [ye2(I2("x", e, t, n10), i10, o10)];
    }
    case "All": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [Bk(I2("x", e, t, n10), i10, o10)];
    }
    case "Any": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [cm(I2("x", e, t, n10), i10, o10)];
    }
    case "ArgMax": {
      let i10 = I2("axis", e, t, n10);
      return [Gu(I2("x", e, t, n10), i10)];
    }
    case "ArgMin": {
      let i10 = I2("axis", e, t, n10);
      return [GA(I2("x", e, t, n10), i10)];
    }
    case "Prod": {
      let i10 = I2("axis", e, t, n10), o10 = I2("keepDims", e, t, n10);
      return [iI(I2("x", e, t, n10), i10, o10)];
    }
    case "Cumsum": {
      let i10 = I2("axis", e, t, n10), o10 = I2("exclusive", e, t, n10), u10 = I2("reverse", e, t, n10);
      return [Qk(I2("x", e, t, n10), i10, o10, u10)];
    }
    case "Bincount":
      let s10 = I2("x", e, t, n10), r10 = I2("weights", e, t, n10), a10 = I2("size", e, t, n10);
      return [Hk(s10, r10, a10)];
    case "DenseBincount": {
      let i10 = I2("x", e, t, n10), o10 = I2("weights", e, t, n10), u10 = I2("size", e, t, n10), l10 = I2("binaryOutput", e, t, n10);
      return [QE(i10, o10, u10, l10)];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var o4 = (e, t, n10) => {
  switch (e.op) {
    case "ConcatV2":
    case "Concat": {
      let s10 = I2("n", e, t, n10), r10 = I2("axis", e, t, n10), a10 = I2("tensors", e, t, n10);
      return a10 = a10.slice(0, s10), [Ft(a10, r10)];
    }
    case "Gather": {
      let s10 = I2("x", e, t, n10), r10 = I2("indices", e, t, n10);
      return [ju(s10, ce2(r10, "int32"), 0)];
    }
    case "GatherV2": {
      let s10 = I2("axis", e, t, n10), r10 = I2("batchDims", e, t, n10), a10 = I2("x", e, t, n10), i10 = I2("indices", e, t, n10);
      return [ju(a10, ce2(i10, "int32"), s10, r10)];
    }
    case "Reverse": {
      let s10 = I2("dims", e, t, n10), r10 = [];
      for (let i10 = 0; i10 < s10.length; i10++)
        s10[i10] && r10.push(i10);
      let a10 = I2("x", e, t, n10);
      return [Yn(a10, r10)];
    }
    case "ReverseV2": {
      let s10 = I2("axis", e, t, n10), r10 = I2("x", e, t, n10);
      return [Yn(r10, s10)];
    }
    case "Slice": {
      let s10 = I2("begin", e, t, n10), r10 = I2("size", e, t, n10);
      return [He(I2("x", e, t, n10), s10, r10)];
    }
    case "StridedSlice": {
      let s10 = I2("begin", e, t, n10), r10 = I2("end", e, t, n10), a10 = I2("strides", e, t, n10), i10 = I2("beginMask", e, t, n10), o10 = I2("endMask", e, t, n10), u10 = I2("ellipsisMask", e, t, n10), l10 = I2("newAxisMask", e, t, n10), c10 = I2("shrinkAxisMask", e, t, n10), p10 = I2("x", e, t, n10);
      return [k3(p10, s10, r10, a10, i10, o10, u10, l10, c10)];
    }
    case "Pack":
      return j2(() => {
        let s10 = I2("axis", e, t, n10), r10 = I2("tensors", e, t, n10), a10 = r10[0].shape, i10 = mr(r10[0]).shape, o10 = r10.map((u10) => {
          let l10 = w2.arraysEqual(u10.shape, a10);
          if (!l10 && !w2.arraysEqual(mr(u10).shape, i10))
            throw new Error("the input tensors shape does not match");
          return l10 ? u10 : G2(u10, a10);
        });
        return [Qn(o10, s10)];
      });
    case "Unpack": {
      let s10 = I2("axis", e, t, n10), r10 = I2("tensor", e, t, n10);
      return Fs(r10, s10);
    }
    case "Tile": {
      let s10 = I2("reps", e, t, n10);
      return [cs(I2("x", e, t, n10), s10)];
    }
    case "Split":
    case "SplitV": {
      let s10 = I2("axis", e, t, n10), r10 = I2("numOrSizeSplits", e, t, n10), a10 = I2("x", e, t, n10);
      return Ln(a10, r10, s10);
    }
    case "ScatterNd": {
      let s10 = I2("indices", e, t, n10), r10 = I2("values", e, t, n10), a10 = I2("shape", e, t, n10);
      return [M3(s10, r10, a10)];
    }
    case "GatherNd": {
      let s10 = I2("x", e, t, n10), r10 = I2("indices", e, t, n10);
      return [W3(s10, r10)];
    }
    case "SparseToDense": {
      let s10 = I2("sparseIndices", e, t, n10), r10 = I2("outputShape", e, t, n10), a10 = I2("sparseValues", e, t, n10), i10 = I2("defaultValue", e, t, n10);
      return [xI(s10, a10, r10, a10.dtype === i10.dtype ? i10 : ce2(i10, a10.dtype))];
    }
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var u4 = (e, t, n10) => {
  switch (e.op) {
    case "SparseFillEmptyRows": {
      let { outputIndices: s10, outputValues: r10, emptyRowIndicator: a10, reverseIndexMap: i10 } = Vc.sparseFillEmptyRows(I2("indices", e, t, n10), I2("values", e, t, n10), I2("denseShape", e, t, n10), I2("defaultValue", e, t, n10));
      return [s10, r10, a10, i10];
    }
    case "SparseReshape": {
      let { outputIndices: s10, outputShape: r10 } = Vc.sparseReshape(I2("inputIndices", e, t, n10), I2("inputShape", e, t, n10), I2("newShape", e, t, n10));
      return [s10, r10];
    }
    case "SparseSegmentMean":
      return [Vc.sparseSegmentMean(I2("data", e, t, n10), I2("indices", e, t, n10), I2("segmentIds", e, t, n10))];
    case "SparseSegmentSum":
      return [Vc.sparseSegmentSum(I2("data", e, t, n10), I2("indices", e, t, n10), I2("segmentIds", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var l4 = (e, t, n10) => {
  switch (e.op) {
    case "FFT":
      return [ob(I2("x", e, t, n10))];
    case "IFFT":
      return [kd(I2("x", e, t, n10))];
    case "RFFT":
      return [ub(I2("x", e, t, n10))];
    case "IRFFT":
      return [fI(I2("x", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var c4 = (e, t, n10) => {
  switch (e.op) {
    case "StringNGrams": {
      let { nGrams: s10, nGramsSplits: r10 } = Pf.stringNGrams(I2("data", e, t, n10), I2("dataSplits", e, t, n10), I2("separator", e, t, n10), I2("nGramWidths", e, t, n10), I2("leftPad", e, t, n10), I2("rightPad", e, t, n10), I2("padWidth", e, t, n10), I2("preserveShortSequences", e, t, n10));
      return [s10, r10];
    }
    case "StringSplit": {
      let { indices: s10, values: r10, shape: a10 } = Pf.stringSplit(I2("input", e, t, n10), I2("delimiter", e, t, n10), I2("skipEmpty", e, t, n10));
      return [s10, r10, a10];
    }
    case "StringToHashBucketFast":
      return [Pf.stringToHashBucketFast(I2("input", e, t, n10), I2("numBuckets", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
var d4 = (e, t, n10) => {
  switch (e.op) {
    case "Cast":
      return [ce2(I2("x", e, t, n10), I2("dtype", e, t, n10))];
    case "ExpandDims": {
      let s10 = I2("axis", e, t, n10);
      return [On(I2("x", e, t, n10), s10)];
    }
    case "Squeeze": {
      let s10 = I2("axis", e, t, n10);
      return [mr(I2("x", e, t, n10), s10)];
    }
    case "Reshape":
      return [G2(I2("x", e, t, n10), I2("shape", e, t, n10))];
    case "MirrorPad":
      return [lD(I2("x", e, t, n10), I2("padding", e, t, n10), I2("mode", e, t, n10))];
    case "PadV2":
    case "Pad":
      return [pi(I2("x", e, t, n10), I2("padding", e, t, n10), I2("constantValue", e, t, n10))];
    case "SpaceToBatchND": {
      let s10 = I2("blockShape", e, t, n10), r10 = I2("paddings", e, t, n10);
      return [eb(I2("x", e, t, n10), s10, r10)];
    }
    case "BatchToSpaceND": {
      let s10 = I2("blockShape", e, t, n10), r10 = I2("crops", e, t, n10);
      return [Ug(I2("x", e, t, n10), s10, r10)];
    }
    case "DepthToSpace": {
      let s10 = I2("blockSize", e, t, n10), r10 = I2("dataFormat", e, t, n10).toUpperCase();
      return [JE(I2("x", e, t, n10), s10, r10)];
    }
    case "BroadcastTo":
      return [td(I2("x", e, t, n10), I2("shape", e, t, n10))];
    case "BroadcastArgs":
      return [NE(I2("s0", e, t, n10), I2("s1", e, t, n10))];
    default:
      throw TypeError(`Node type ${e.op} is not implemented`);
  }
};
function jx(e, t, n10, s10) {
  let r10 = ((a10, i10, o10) => {
    switch (a10.category) {
      case "arithmetic":
        return j2(() => VW(a10, i10, o10));
      case "basic_math":
        return j2(() => WW(a10, i10, o10));
      case "control":
        return KW(a10, i10, o10);
      case "convolution":
        return j2(() => XW(a10, i10, o10));
      case "creation":
        return j2(() => YW(a10, i10, o10));
      case "dynamic":
        return QW(a10, i10, o10);
      case "evaluation":
        return j2(() => ZW(a10, i10, o10));
      case "image":
        return j2(() => n4(a10, i10, o10));
      case "graph":
        return j2(() => JW(a10, i10, o10));
      case "logical":
        return j2(() => s4(a10, i10, o10));
      case "matrices":
        return j2(() => r4(a10, i10, o10));
      case "normalization":
        return j2(() => a4(a10, i10, o10));
      case "reduction":
        return j2(() => i4(a10, i10, o10));
      case "slice_join":
        return j2(() => o4(a10, i10, o10));
      case "sparse":
        return j2(() => u4(a10, i10, o10));
      case "spectral":
        return j2(() => l4(a10, i10, o10));
      case "string":
        return j2(() => c4(a10, i10, o10));
      case "transformation":
        return j2(() => d4(a10, i10, o10));
      case "hash_table":
        return t4(a10, i10, o10, s10);
      case "custom":
        let u10 = W0(a10.op);
        if (u10 && u10.customExecutor)
          return u10.customExecutor(new BW(a10, i10, o10));
        throw TypeError(`Custom op ${a10.op} is not registered.`);
      default:
        throw TypeError(`Unknown op '${a10.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(e, t, n10);
  return w2.isPromise(r10) ? r10.then((a10) => [].concat(a10)) : [].concat(r10);
}
var Kx = class {
  constructor(e = {}, t = {}, n10 = {}, s10 = {}) {
    this.weightMap = e, this.tensorArrayMap = t, this.tensorListMap = n10, this.functionMap = s10, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  newFrame(e, t) {
    return { id: e, frameName: t, iterationId: 0 };
  }
  set currentContext(e) {
    this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
  }
  get currentContext() {
    return this.contexts;
  }
  get currentContextId() {
    return this._currentContextIds[0];
  }
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    let e = [];
    for (let t = 0; t < this.contexts.length - 1; t++) {
      let n10 = this.contexts.slice(0, this.contexts.length - t);
      e.push(this.contextIdforContexts(n10));
    }
    e.push(""), this._currentContextIds = e;
  }
  contextIdforContexts(e) {
    return e ? e.map((t) => t.id === 0 && t.iterationId === 0 ? "" : `${t.frameName}-${t.iterationId}`).join("/") : "";
  }
  enterFrame(e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }
  exitFrame() {
    if (this.contexts && this.contexts.length > 1)
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    else
      throw new Error("Cannot exit frame, the context is empty");
  }
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice(), this.lastId++;
      let e = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else
      throw new Error("Cannot increase frame iteration, the context is empty");
  }
  getWeight(e) {
    return this.weightMap[e];
  }
  addTensorArray(e) {
    this.tensorArrayMap[e.id] = e;
  }
  getTensorArray(e) {
    return this.tensorArrayMap[e];
  }
  addTensorList(e) {
    this.tensorListMap[e.id] = e;
  }
  getTensorList(e) {
    return this.tensorListMap[e];
  }
  dispose(e) {
    for (let t in this.tensorArrayMap)
      this.tensorArrayMap[t].clearAndClose(e);
    for (let t in this.tensorListMap)
      this.tensorListMap[t].clearAndClose(e);
  }
};
function Xx(e, t, n10, s10) {
  let r10 = /* @__PURE__ */ new Set(), a10 = [], i10 = null, o10 = null, u10 = /* @__PURE__ */ new Set(), l10 = Object.keys(e).map((d10) => $n(d10)[0]), c10 = [];
  s10 != null && (c10 = s10.map((d10) => $n(d10.name)[0]));
  let p10 = [...t];
  for (; p10.length > 0; ) {
    let d10 = p10.pop();
    if ((cS(d10) || g4(d10) || b4(d10)) && i10 == null && (i10 = d10, o10 = i10.children.map((h10) => h10.name).filter((h10) => r10.has(h10))), r10.add(d10.name), n10[d10.name] == null && l10.indexOf(d10.name) === -1 && c10.indexOf(d10.name) === -1) {
      if (d10.inputs.length === 0) {
        a10.push(d10.name);
        continue;
      }
      d10.inputs.forEach((h10) => {
        u10.has(h10.name) || (u10.add(h10.name), p10.push(h10));
      });
    }
  }
  return { inputs: e, outputs: t, usedNodes: r10, missingInputs: a10, dynamicNode: i10, syncInputs: o10 };
}
function p4(e, t, n10) {
  let { usedNodes: s10, inputs: r10 } = n10, a10 = [], i10 = Object.keys(r10).map((c10) => $n(c10)[0]).map((c10) => e.nodes[c10]), o10 = e.initNodes;
  i10.forEach((c10) => {
    s10.has(c10.name) && a10.push(c10);
  }), e.weights.forEach((c10) => {
    s10.has(c10.name) && a10.push(c10);
  }), o10 != null && o10.forEach((c10) => {
    s10.has(c10.name) && a10.push(c10);
  });
  let u10 = /* @__PURE__ */ new Set(), l10 = [];
  for (; a10.length > 0; ) {
    let c10 = a10.pop();
    u10.add(c10.name), t[c10.name] || l10.push(c10), c10.children.forEach((p10) => {
      !u10.has(p10.name) && s10.has(p10.name) && p10.inputs.every((d10) => u10.has(d10.name)) && a10.push(p10);
    });
  }
  return l10;
}
var h4 = ["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"];
var f4 = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"];
var m4 = ["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"];
function cS(e) {
  return h4.indexOf(e.op) >= 0;
}
function g4(e) {
  return f4.indexOf(e.op) >= 0;
}
function b4(e) {
  return m4.indexOf(e.op) >= 0;
}
var Om = class {
  constructor(e, t) {
    this.graph = e, this.parent = t, this.compiledMap = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPERATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.intermediateTensors = {}, this.keepTensorForDebug = false, this._outputs = e.outputs, this._inputs = e.inputs, this._initNodes = e.initNodes, this._signature = e.signature, this._functions = e.functions, e.functions != null && Object.keys(e.functions).forEach((n10) => {
      this._functionExecutorMap[n10] = new Om(e.functions[n10], this);
    });
  }
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(e) {
    let t = Object.keys(e).map((n10) => e[n10].map((s10) => s10.id));
    this._weightIds = [].concat(...t), this._weightMap = e;
  }
  set resourceManager(e) {
    this._resourceManager = e;
  }
  get inputs() {
    return this._inputs.map((e) => ({ name: e.name, shape: e.attrParams.shape ? e.attrParams.shape.value : void 0, dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0 }));
  }
  get outputs() {
    return this._outputs.map((e) => ({ name: e.name, shape: e.attrParams.shape ? e.attrParams.shape.value : void 0, dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0 }));
  }
  get inputNodes() {
    return this._inputs.map((e) => e.signatureKey || e.name);
  }
  get outputNodes() {
    return this._outputs.map((e) => {
      let t = e.signatureKey || e.name;
      return e.defaultOutput ? `${t}:${e.defaultOutput}` : t;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((e, t) => (e[t] = this._functions[t].signature, e), {});
  }
  getCompilationKey(e, t) {
    let n10 = e.map((r10) => r10.name).sort(), s10 = t.map((r10) => r10.name).sort();
    return n10.join(this.SEPERATOR) + "--" + s10.join(this.SEPERATOR);
  }
  compile(e, t) {
    let n10 = Xx(e, t, this.weightMap, this._initNodes), { missingInputs: s10, dynamicNode: r10, syncInputs: a10 } = n10;
    if (r10 != null)
      throw new Error(`This execution contains the node '${r10.name}', which has the dynamic op '${r10.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a10}]`);
    if (s10.length > 0) {
      let i10 = t.map((u10) => u10.name), o10 = Object.keys(e);
      throw new Error(`Cannot compute the outputs [${i10}] from the provided inputs [${o10}]. Missing the following inputs: [${s10}]`);
    }
    return p4(this.graph, this.weightMap, n10);
  }
  execute(e, t) {
    e = this.mapInputs(e);
    let n10 = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
    let s10 = n10.map((c10) => this.graph.nodes[$n(c10)[0]]), r10 = t.map((c10) => $n(c10)[0]), a10 = r10.map((c10) => this.graph.nodes[c10]);
    this.resetIntermediateTensors(), a10.length === 0 && (a10 = this._outputs);
    let i10 = this.getCompilationKey(s10, a10), o10 = this.compiledMap.get(i10);
    o10 == null && (o10 = this.compile(e, a10), this.compiledMap.set(i10, o10));
    let u10 = {}, l10 = {};
    return j2(() => {
      let c10 = new Kx(this.weightMap, u10, l10, this.functionExecutorMap), p10 = { ...this.weightMap };
      Object.keys(e).forEach((f10) => {
        let [m10, g10] = $n(f10), b10 = [];
        b10[g10] = e[f10], p10[m10] = b10;
      });
      let d10 = this.getFrozenTensorIds(p10), h10 = {};
      for (let f10 = 0; f10 < o10.length; f10++) {
        let m10 = o10[f10];
        if (!p10[m10.name]) {
          let g10 = jx(m10, p10, c10, this._resourceManager);
          if (w2.isPromise(g10))
            throw new Error(`The execution of the op '${m10.op}' returned a promise. Please use model.executeAsync() instead.`);
          p10[m10.name] = g10, this.checkTensorForDisposal(m10.name, m10, p10, c10, d10, r10, h10);
        }
      }
      return this.parent == null && c10.dispose(d10), t.map((f10) => on(f10, p10, c10));
    });
  }
  getFrozenTensorIds(e) {
    let t = [].concat.apply([], Object.keys(e).map((n10) => e[n10]).map((n10) => n10.map((s10) => s10.id)));
    return new Set(t);
  }
  checkTensorForDisposal(e, t, n10, s10, r10, a10, i10) {
    t.category === "control" || a10.indexOf(e) !== -1 || (n10[e].forEach((o10) => {
      o10 != null && (i10[o10.id] = (i10[o10.id] || 0) + t.children.length);
    }), t.inputs.forEach((o10) => {
      if (o10.category !== "control") {
        let u10 = vW(o10.name, n10, s10);
        u10 != null && u10.forEach((l10) => {
          if (l10 && !l10.kept && !r10.has(l10.id)) {
            let c10 = i10[l10.id];
            if (c10 === 1) {
              if (!this.keepTensorForDebug)
                l10.dispose();
              else {
                let [p10, d10] = Ts(t.name, s10);
                this.intermediateTensors[p10] ? this.intermediateTensors[p10][d10] = l10 : (this.intermediateTensors[p10] = [], this.intermediateTensors[p10][d10] = l10);
              }
              delete i10[l10.id];
            } else
              c10 != null && i10[l10.id]--;
          }
        });
      }
    }));
  }
  async executeAsync(e, t) {
    return this._executeAsync(e, t);
  }
  disposeIntermediateTensors() {
    !this.intermediateTensors || (Object.keys(this.intermediateTensors).forEach((e) => this.intermediateTensors[e].forEach((t) => t.dispose())), this.disposeTensorsMap());
  }
  disposeTensorsMap() {
    !this.tensorsMap || Object.keys(this.tensorsMap).forEach((e) => {
      this.tensorsMap[e].forEach((n10) => {
        n10 && !n10.kept && !n10.isDisposed && !this.keepIds.has(n10.id) && n10.dispose();
      });
    });
  }
  getIntermediateTensors() {
    return this.tensorsMap;
  }
  resetIntermediateTensors() {
    for (let e in this.intermediateTensors)
      this.intermediateTensors[e].forEach((t) => t.dispose()), delete this.intermediateTensors[e];
  }
  async _executeAsync(e, t, n10 = false, s10 = {}, r10 = {}) {
    n10 || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t));
    try {
      this.keepTensorForDebug = X2().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (l10) {
      console.warn(l10.message);
    }
    this.resetIntermediateTensors();
    let a10 = new Kx(this.weightMap, s10, r10, this.functionExecutorMap);
    this.tensorsMap = await this.executeWithControlFlow(e, a10, t, n10);
    let i10 = t.map((l10) => on(l10, this.tensorsMap, a10)), o10 = i10.map((l10) => l10.id), u10 = Object.keys(e).map((l10) => e[l10].id);
    return this.keepIds = /* @__PURE__ */ new Set([...o10, ...u10, ...this.weightIds]), this.keepTensorForDebug || this.disposeTensorsMap(), this.parent == null && a10.dispose(this.keepIds), i10;
  }
  async executeFunctionAsync(e, t, n10) {
    let s10 = e.reduce((r10, a10, i10) => (r10[this.inputs[i10].name] = a10, r10), {});
    return this._executeAsync(s10, this.outputNodes, true, t, n10);
  }
  async executeWithControlFlow(e, t, n10, s10) {
    let r10 = Object.keys(e), a10 = r10.map((y10) => this.graph.nodes[$n(y10)[0]]), i10 = n10.map((y10) => $n(y10)[0]), o10 = i10.map((y10) => this.graph.nodes[y10]);
    o10.length === 0 && (o10 = this._outputs);
    let { usedNodes: u10, missingInputs: l10, dynamicNode: c10, syncInputs: p10 } = Xx(e, o10, this.weightMap, this._initNodes), d10 = [...a10, ...this.graph.weights, ...this._initNodes || []].map((y10) => ({ node: y10, contexts: t.currentContext })), h10 = { ...this.weightMap };
    Object.keys(e).forEach((y10) => {
      let [v10, x10] = $n(y10), k10 = [];
      k10[x10] = e[y10], h10[v10] = k10;
    });
    let f10 = {}, m10 = this.getFrozenTensorIds(h10), g10 = {};
    for (; d10.length > 0; ) {
      let y10 = this.processStack(a10, d10, t, h10, g10, m10, i10, f10, u10);
      await Promise.all(y10);
    }
    c10 == null && !s10 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
    let b10 = o10.filter((y10) => !cS(y10) && !on(y10.name, h10, t)).map((y10) => y10.name);
    if (b10.length > 0) {
      let y10 = "";
      throw c10 != null && (y10 = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p10}]`), new Error(`Cannot compute the outputs [${b10}] from the provided inputs [${r10}]. Consider providing the following inputs: [${l10}]. ${y10}`);
    }
    return h10;
  }
  processStack(e, t, n10, s10, r10, a10, i10, o10, u10) {
    let l10 = [];
    for (; t.length > 0; ) {
      let c10 = t.pop();
      n10.currentContext = c10.contexts;
      let p10 = "";
      if (c10.node.op === "Enter" && I2("isConstant", c10.node, s10, n10) && ([p10] = Ts(c10.node.name, n10)), s10[c10.node.name] == null) {
        let d10 = jx(c10.node, s10, n10, this._resourceManager);
        p10 || ([p10] = Ts(c10.node.name, n10));
        let h10 = n10.currentContext;
        w2.isPromise(d10) ? l10.push(d10.then((f10) => (s10[p10] = f10, n10.currentContext = h10, this.checkTensorForDisposal(p10, c10.node, s10, n10, a10, i10, o10), this.processChildNodes(c10.node, t, n10, s10, r10, u10), f10))) : (s10[p10] = d10, this.checkTensorForDisposal(p10, c10.node, s10, n10, a10, i10, o10), this.processChildNodes(c10.node, t, n10, s10, r10, u10));
      } else
        this.processChildNodes(c10.node, t, n10, s10, r10, u10);
    }
    return l10;
  }
  processChildNodes(e, t, n10, s10, r10, a10) {
    e.children.forEach((i10) => {
      let [o10] = Ts(i10.name, n10);
      r10[o10] || !a10.has(i10.name) || (i10.op === "Merge" ? i10.inputNames.some((u10) => !!on(u10, s10, n10)) && (r10[o10] = true, t.push({ contexts: n10.currentContext, node: i10 })) : i10.inputNames.every((u10) => !!on(u10, s10, n10)) && (r10[o10] = true, t.push({ contexts: n10.currentContext, node: i10 })));
    });
  }
  dispose() {
    Object.keys(this.weightMap).forEach((e) => this.weightMap[e].forEach((t) => t.dispose()));
  }
  checkInputShapeAndType(e) {
    Object.keys(e).forEach((t) => {
      let n10 = e[t], [s10] = $n(t), r10 = this.graph.nodes[s10];
      if (r10.attrParams.shape && r10.attrParams.shape.value) {
        let a10 = r10.attrParams.shape.value, i10 = a10.length === n10.shape.length && n10.shape.every((o10, u10) => a10[u10] === -1 || a10[u10] === o10);
        w2.assert(i10, () => `The shape of dict['${r10.name}'] provided in model.execute(dict) must be [${a10}], but was [${n10.shape}]`);
      }
      r10.attrParams.dtype && r10.attrParams.dtype.value && w2.assert(n10.dtype === r10.attrParams.dtype.value, () => `The dtype of dict['${r10.name}'] provided in model.execute(dict) must be ${r10.attrParams.dtype.value}, but was ${n10.dtype}`);
    });
  }
  mapInputs(e) {
    let t = {};
    for (let n10 in e)
      if (this._signature != null && this._signature.inputs != null && this._signature.inputs[n10] != null) {
        let s10 = this._signature.inputs[n10];
        t[s10.name] = e[n10];
      } else
        t[n10] = e[n10];
    return t;
  }
  checkInputs(e) {
    let t = Object.keys(e).filter((n10) => {
      let [s10] = $n(n10);
      return this.graph.nodes[s10] == null;
    });
    if (t.length > 0)
      throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`);
  }
  mapOutputs(e) {
    return e.map((t) => this._signature != null && this._signature.outputs != null && this._signature.outputs[t] != null ? this._signature.outputs[t].name : t, {});
  }
  checkOutputs(e) {
    e.forEach((t) => {
      let [n10] = $n(t);
      if (!this.graph.nodes[n10])
        throw new Error(`The output '${t}' is not found in the graph`);
    });
  }
};
var y4 = class {
  constructor(e = {}, t = {}) {
    this.hashTableNameToHandle = e, this.hashTableMap = t;
  }
  addHashTable(e, t) {
    this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t;
  }
  getHashTableHandleByName(e) {
    return this.hashTableNameToHandle[e];
  }
  getHashTableById(e) {
    return this.hashTableMap[e];
  }
  dispose() {
    for (let e in this.hashTableMap)
      this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
    for (let e in this.hashTableNameToHandle)
      this.hashTableNameToHandle[e].dispose(), delete this.hashTableNameToHandle[e];
  }
};
var v4 = "?tfjs-format=file";
var x4 = "model.json";
var w4 = class {
  constructor(e, t = {}) {
    this.modelUrl = e, this.loadOptions = t, this.version = "n/a", t == null && (this.loadOptions = {}), this.resourceManager = new y4();
  }
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  findIOHandler() {
    let e = this.modelUrl;
    if (e.load != null)
      this.handler = e;
    else if (this.loadOptions.requestInit != null)
      this.handler = _n.browserHTTPRequest(e, this.loadOptions);
    else {
      let t = _n.getLoadHandlers(e, this.loadOptions);
      if (t.length === 0)
        t.push(_n.browserHTTPRequest(e, this.loadOptions));
      else if (t.length > 1)
        throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);
      this.handler = t[0];
    }
  }
  async load() {
    if (this.findIOHandler(), this.handler.load == null)
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    let e = await this.handler.load();
    return this.loadSync(e);
  }
  loadSync(e) {
    this.artifacts = e;
    let t = this.artifacts.modelTopology, n10;
    this.artifacts.userDefinedMetadata != null && this.artifacts.userDefinedMetadata.signature != null ? n10 = this.artifacts.userDefinedMetadata.signature : n10 = this.artifacts.signature, this.signature = n10, this.version = `${t.versions.producer}.${t.versions.minConsumer}`;
    let s10 = _n.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
    if (this.executor = new Om(Ux.Instance.transformGraph(t, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(s10), this.executor.resourceManager = this.resourceManager, e.modelInitializer != null && e.modelInitializer.node != null) {
      let r10 = Ux.Instance.transformGraph(e.modelInitializer);
      this.initializer = new Om(r10), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializer.executeAsync({}, []);
    }
    return true;
  }
  async save(e, t) {
    if (typeof e == "string") {
      let n10 = _n.getSaveHandlers(e);
      if (n10.length === 0)
        throw new Error(`Cannot find any save handlers for URL '${e}'`);
      if (n10.length > 1)
        throw new Error(`Found more than one (${n10.length}) save handlers for URL '${e}'`);
      e = n10[0];
    }
    if (e.save == null)
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    return e.save(this.artifacts);
  }
  predict(e, t) {
    return this.execute(e, this.outputNodes);
  }
  normalizeInputs(e) {
    if (!(e instanceof et) && !Array.isArray(e))
      return e;
    if (e = Array.isArray(e) ? e : [e], e.length !== this.inputNodes.length)
      throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);
    return this.inputNodes.reduce((t, n10, s10) => (t[n10] = e[s10], t), {});
  }
  normalizeOutputs(e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }
  execute(e, t) {
    e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    let n10 = this.executor.execute(e, t);
    return n10.length > 1 ? n10 : n10[0];
  }
  async executeAsync(e, t) {
    e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    let n10 = await this.executor.executeAsync(e, t);
    return n10.length > 1 ? n10 : n10[0];
  }
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(e) {
    return Object.keys(e).reduce((t, n10) => (t[n10] = [e[n10]], t), {});
  }
  dispose() {
    this.executor.dispose(), this.initializer && this.initializer.dispose(), this.resourceManager.dispose();
  }
};
async function bpe(e, t = {}) {
  if (e == null)
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  t == null && (t = {}), t.fromTFHub && e.load == null && (e.endsWith("/") || (e = e + "/"), e = `${e}${x4}${v4}`);
  let n10 = new w4(e, t);
  return await n10.load(), n10;
}
var ype = "0.0.0";
var k4 = {};
Ae(k4, { CSVDataset: () => kS, Dataset: () => Zo, FileDataSource: () => _S, TextLineDataset: () => wS, URLDataSource: () => AS, array: () => H4, csv: () => nU, func: () => sU, generator: () => rU, microphone: () => iU, version_data: () => oU, webcam: () => aU, zip: () => q4 });
var I4 = ya(Vd());
var S4 = ya(Vd());
function C4(e, t) {
  return Ed(e, t);
}
function Ed(e, t, n10 = /* @__PURE__ */ new Map(), s10 = /* @__PURE__ */ new Set()) {
  if (e == null)
    return null;
  if (typeof Blob == "function" && e instanceof Blob)
    return e.slice();
  if (s10.has(e))
    throw new Error("Circular references are not supported.");
  if (n10.has(e))
    return n10.get(e);
  let r10 = t(e);
  if (r10.recurse && r10.value !== null)
    throw new Error("A deep map function may not return both a value and recurse=true.");
  if (r10.recurse)
    if (Ji(e)) {
      let a10 = Array.isArray(e) ? [] : {};
      s10.add(e);
      for (let i10 in e) {
        let o10 = e[i10], u10 = Ed(o10, t, n10, s10);
        a10[i10] = u10;
      }
      return s10.delete(e), e.__proto__ && (a10.__proto__ = e.__proto__), a10;
    } else
      throw new Error(`Can't recurse into non-iterable type: ${e}`);
  else
    return n10.set(e, r10.value), r10.value;
}
function N4(e, t = pS) {
  return dS(e, t);
}
function dS(e, t, n10 = /* @__PURE__ */ new Set()) {
  let s10 = e[0];
  if (n10.has(s10))
    throw new Error("Circular references are not supported.");
  let r10 = t(e);
  if (r10.recurse && r10.value !== null)
    throw new Error("A deep zip function may not return both a value and recurse=true.");
  if (r10.recurse)
    if (Ji(s10)) {
      let a10 = Array.isArray(s10) ? [] : {};
      n10.add(s10);
      for (let i10 in s10) {
        let o10 = e.map((l10) => l10[i10]), u10 = dS(o10, t, n10);
        a10[i10] = u10;
      }
      return n10.delete(s10), a10;
    } else
      throw new Error(`Can't recurse into non-iterable type: ${s10}`);
  else
    return r10.value;
}
function pS(e) {
  return e === null ? null : Ji(e[0]) ? { value: null, recurse: true } : { value: e, recurse: false };
}
async function hS(e, t) {
  let n10 = /* @__PURE__ */ new Map();
  Ed(e, t, n10);
  for (let r10 of Array.from(n10.keys())) {
    let a10 = n10.get(r10);
    if (w2.isPromise(a10)) {
      let i10 = await a10;
      n10.set(r10, i10);
    }
  }
  return Ed(e, t, n10);
}
function Ji(e) {
  let t = false;
  if (X2().get("IS_BROWSER"))
    t = e instanceof TextDecoder;
  else {
    let { StringDecoder: n10 } = Pw();
    t = e instanceof n10;
  }
  return e != null && !ArrayBuffer.isView(e) && (Array.isArray(e) || typeof e == "object" && !(e instanceof et) && !(e instanceof Promise) && !t);
}
function T4(e) {
  return e == null || $4(e) || Array.isArray(e) || typeof e == "object" && e instanceof et || w2.isTypedArray(e);
}
function $4(e) {
  return e === null || typeof e != "object" && typeof e != "function";
}
function _4(e) {
  return C4(e, A4);
}
function A4(e) {
  return e instanceof et ? { value: e.clone(), recurse: false } : Ji(e) ? { value: null, recurse: true } : { value: e, recurse: false };
}
var fS = class {
  constructor(e) {
    if (this.capacity = e, this.begin = 0, this.end = 0, e == null)
      throw new RangeError("Can't create a ring buffer of unknown capacity.");
    if (e < 1)
      throw new RangeError("Can't create ring buffer of capacity < 1.");
    this.data = new Array(e), this.doubledCapacity = 2 * e;
  }
  wrap(e) {
    for (; e < 0; )
      e += this.doubledCapacity;
    return e % this.doubledCapacity;
  }
  get(e) {
    if (e < 0)
      throw new RangeError("Can't get item at a negative index.");
    return this.data[e % this.capacity];
  }
  set(e, t) {
    if (e < 0)
      throw new RangeError("Can't set item at a negative index.");
    this.data[e % this.capacity] = t;
  }
  length() {
    let e = this.end - this.begin;
    return e < 0 && (e = this.doubledCapacity + e), e;
  }
  isFull() {
    return this.length() === this.capacity;
  }
  isEmpty() {
    return this.length() === 0;
  }
  push(e) {
    if (this.isFull())
      throw new RangeError("Ring buffer is full.");
    this.set(this.end, e), this.end = this.wrap(this.end + 1);
  }
  pushAll(e) {
    for (let t of e)
      this.push(t);
  }
  pop() {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    this.end = this.wrap(this.end - 1);
    let e = this.get(this.end);
    return this.set(this.end, void 0), e;
  }
  unshift(e) {
    if (this.isFull())
      throw new RangeError("Ring buffer is full.");
    this.begin = this.wrap(this.begin - 1), this.set(this.begin, e);
  }
  shift() {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    let e = this.get(this.begin);
    return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), e;
  }
  shuffleExcise(e) {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    let t = this.wrap(this.begin + e), n10 = this.get(t);
    return this.set(t, this.pop()), n10;
  }
};
var mS = class extends fS {
  constructor() {
    super(mS.INITIAL_CAPACITY);
  }
  isFull() {
    return false;
  }
  push(e) {
    super.isFull() && this.expand(), super.push(e);
  }
  unshift(e) {
    super.isFull() && this.expand(), super.unshift(e);
  }
  expand() {
    let e = this.capacity * 2, t = new Array(e), n10 = this.length();
    for (let s10 = 0; s10 < n10; s10++)
      t[s10] = this.get(this.wrap(this.begin + s10));
    this.data = t, this.capacity = e, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n10;
  }
};
var gS = mS;
gS.INITIAL_CAPACITY = 32;
function bS(e) {
  return new D4(e);
}
function Ky(e) {
  return new F4(e);
}
function E4(e, t) {
  return new yS(e, t);
}
function R4(e, t = vS.FAIL) {
  return new U4(e, t);
}
var Ut = class {
  async toArray() {
    let e = [], t = await this.next();
    for (; !t.done; )
      e.push(t.value), t = await this.next();
    return e;
  }
  async toArrayForTest() {
    let e = this.prefetch(100), t = [], n10 = await e.next();
    for (; !n10.done; )
      t.push(n10.value), n10 = await e.next();
    return t;
  }
  async resolveFully() {
    let e = await this.next();
    for (; !e.done; )
      e = await this.next();
  }
  async resolveWhile(e) {
    let t = await this.next(), n10 = e(t.value);
    for (; !t.done && n10; )
      t = await this.next(), n10 = e(t.value);
  }
  handleErrors(e) {
    return new V4(this, e);
  }
  filter(e) {
    return new L4(this, e);
  }
  map(e) {
    return new B4(this, e);
  }
  mapAsync(e) {
    return new Yx(this, e);
  }
  serialMapAsync(e) {
    return new Yx(this, e).serial();
  }
  flatmap(e) {
    return new W4(this, e);
  }
  async forEachAsync(e) {
    return this.map(e).resolveFully();
  }
  async serialForEach(e) {
    return this.serialMapAsync(e).resolveWhile((t) => t === true);
  }
  rowMajorBatch(e, t = true) {
    return new M4(this, e, t);
  }
  columnMajorBatch(e, t = true, n10 = pS) {
    return this.rowMajorBatch(e, t).map((r10) => N4(r10, n10));
  }
  concatenate(e, t) {
    return new yS(bS([this, e]), t);
  }
  take(e) {
    return e < 0 || e == null ? this : new z4(this, e);
  }
  skip(e) {
    return e < 0 || e == null ? this : new P4(this, e);
  }
  prefetch(e) {
    return new xS(this, e);
  }
  shuffle(e, t) {
    return new G4(this, e, t);
  }
  serial() {
    return new O4(this);
  }
};
var D4 = class extends Ut {
  constructor(e) {
    super();
    this.items = e, this.trav = 0;
  }
  summary() {
    return `Array of ${this.items.length} items`;
  }
  async next() {
    if (this.trav >= this.items.length)
      return { value: null, done: true };
    let e = this.items[this.trav];
    return this.trav++, { value: _4(e), done: false };
  }
};
var F4 = class extends Ut {
  constructor(e) {
    super();
    this.nextFn = e;
  }
  summary() {
    return "Function call";
  }
  async next() {
    try {
      return this.nextFn();
    } catch (e) {
      throw e.message = `Error thrown while iterating through a dataset: ${e.message}`, e;
    }
  }
};
var O4 = class extends Ut {
  constructor(e) {
    super();
    this.upstream = e, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Serial`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    return this.upstream.next();
  }
};
var P4 = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.maxCount = t, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Skip`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; this.count++ < this.maxCount; ) {
      let e = await this.upstream.next();
      if (e.done)
        return e;
      Re2(e.value);
    }
    return this.upstream.next();
  }
};
var z4 = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.maxCount = t, this.count = 0;
  }
  summary() {
    return `${this.upstream.summary()} -> Take`;
  }
  async next() {
    return this.count++ >= this.maxCount ? { value: null, done: true } : this.upstream.next();
  }
};
var M4 = class extends Ut {
  constructor(e, t, n10 = true) {
    super();
    this.upstream = e, this.batchSize = t, this.enableSmallLastBatch = n10, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> RowMajorBatch`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    let e = [];
    for (; e.length < this.batchSize; ) {
      let t = await this.upstream.next();
      if (t.done)
        return this.enableSmallLastBatch && e.length > 0 ? { value: e, done: false } : { value: null, done: true };
      e.push(t.value);
    }
    return { value: e, done: false };
  }
};
var L4 = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.predicate = t, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Filter`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; ; ) {
      let e = await this.upstream.next();
      if (e.done || this.predicate(e.value))
        return e;
      Re2(e.value);
    }
  }
};
var B4 = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.transform = t;
  }
  summary() {
    return `${this.upstream.summary()} -> Map`;
  }
  async next() {
    let e = await this.upstream.next();
    if (e.done)
      return { value: null, done: true };
    let t = _s.getTensorsInContainer(e.value), n10 = this.transform(e.value), s10 = _s.getTensorsInContainer(n10);
    for (let r10 of t)
      _s.isTensorInList(r10, s10) || r10.dispose();
    return { value: n10, done: false };
  }
};
var V4 = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.handler = t, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> handleErrors`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; ; )
      try {
        return await this.upstream.next();
      } catch (e) {
        if (!this.handler(e))
          return { value: null, done: true };
      }
  }
};
var Yx = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.transform = t;
  }
  summary() {
    return `${this.upstream.summary()} -> AsyncMap`;
  }
  async next() {
    let e = await this.upstream.next();
    if (e.done)
      return { value: null, done: true };
    let t = _s.getTensorsInContainer(e.value), n10 = await this.transform(e.value), s10 = _s.getTensorsInContainer(n10);
    for (let r10 of t)
      _s.isTensorInList(r10, s10) || r10.dispose();
    return { value: n10, done: false };
  }
};
var Xy = class extends Ut {
  constructor() {
    super();
    this.outputQueue = new gS(), this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; this.outputQueue.length() === 0; )
      if (!await this.pump())
        return { value: null, done: true };
    return { value: this.outputQueue.shift(), done: false };
  }
};
var W4 = class extends Xy {
  constructor(e, t) {
    super();
    this.upstream = e, this.transform = t;
  }
  summary() {
    return `${this.upstream.summary()} -> Flatmap`;
  }
  async pump() {
    let e = await this.upstream.next();
    if (e.done)
      return false;
    let t = _s.getTensorsInContainer(e.value), n10 = this.transform(e.value), s10 = _s.getTensorsInContainer(n10);
    this.outputQueue.pushAll(n10);
    for (let r10 of t)
      _s.isTensorInList(r10, s10) || r10.dispose();
    return true;
  }
};
var yS = class extends Ut {
  constructor(e, t) {
    super();
    this.baseErrorHandler = t, this.lastRead = null, this.iterator = null, this.moreIterators = e;
  }
  summary() {
    return "TODO: fill in upstream of chained summaries -> Chained";
  }
  async next() {
    return this.lastRead = this.readFromChain(this.lastRead), this.lastRead;
  }
  async readFromChain(e) {
    if (await e, this.iterator == null) {
      let n10 = await this.moreIterators.next();
      if (n10.done)
        return { value: null, done: true };
      this.iterator = n10.value, this.baseErrorHandler != null && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
    }
    let t = await this.iterator.next();
    return t.done ? (this.iterator = null, this.readFromChain(e)) : t;
  }
};
var vS = ((e) => (e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST", e))(vS || {});
var U4 = class extends Ut {
  constructor(e, t = 0) {
    super();
    this.iterators = e, this.mismatchMode = t, this.count = 0, this.currentPromise = null;
  }
  summary() {
    return "{TODO: fill in upstream of zip summaries} -> Zip";
  }
  async nextState(e) {
    await e;
    let t = 0, n10 = 0;
    function s10(a10) {
      return a10 instanceof Ut ? { value: a10.next().then((o10) => (t++, o10.done && n10++, o10.value)), recurse: false } : { value: null, recurse: true };
    }
    let r10 = await hS(this.iterators, s10);
    if (t === n10)
      return { value: null, done: true };
    if (n10 > 0)
      switch (this.mismatchMode) {
        case 0:
          throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);
        case 1:
          return { value: null, done: true };
        case 2:
        default:
      }
    return this.count++, { value: r10, done: false };
  }
  async next() {
    return this.currentPromise = this.nextState(this.currentPromise), this.currentPromise;
  }
};
var xS = class extends Ut {
  constructor(e, t) {
    super();
    this.upstream = e, this.bufferSize = t, this.buffer = new fS(t);
  }
  summary() {
    return `${this.upstream.summary()} -> Prefetch`;
  }
  refill() {
    for (; !this.buffer.isFull(); ) {
      let e = this.upstream.next();
      this.buffer.push(e);
    }
  }
  next() {
    return this.refill(), this.buffer.shift();
  }
};
var G4 = class extends xS {
  constructor(e, t, n10) {
    super(e, t);
    this.upstream = e, this.windowSize = t, this.upstreamExhausted = false, this.random = S4.alea(n10 || w2.now().toString()), this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  randomInt(e) {
    return Math.floor(this.random() * e);
  }
  chooseIndex() {
    return this.randomInt(this.buffer.length());
  }
  async serialNext() {
    for (this.upstreamExhausted || this.refill(); !this.buffer.isEmpty(); ) {
      let e = this.chooseIndex(), t = await this.buffer.shuffleExcise(e);
      if (t.done)
        this.upstreamExhausted = true;
      else
        return this.refill(), t;
    }
    return { value: null, done: true };
  }
};
var Zo = class {
  constructor() {
    this.size = null;
  }
  batch(e, t = true) {
    let n10 = this;
    w2.assert(e > 0, () => `batchSize needs to be positive, but it is
      ${e}`);
    let s10;
    return this.size === 1 / 0 || this.size == null ? s10 = this.size : t ? s10 = Math.ceil(this.size / e) : s10 = Math.floor(this.size / e), Tn(async () => (await n10.iterator()).columnMajorBatch(e, t, j4), s10);
  }
  concatenate(e) {
    let t = this, n10;
    return this.size === 1 / 0 || e.size === 1 / 0 ? n10 = 1 / 0 : this.size != null && e.size != null ? n10 = this.size + e.size : n10 = null, Tn(async () => (await t.iterator()).concatenate(await e.iterator()), n10);
  }
  filter(e) {
    let t = this, n10;
    return this.size === 1 / 0 ? n10 = 1 / 0 : n10 = null, Tn(async () => (await t.iterator()).filter((s10) => j2(() => e(s10))), n10);
  }
  async forEachAsync(e) {
    return (await this.iterator()).forEachAsync(e);
  }
  map(e) {
    let t = this;
    return Tn(async () => (await t.iterator()).map((n10) => j2(() => e(n10))), this.size);
  }
  mapAsync(e) {
    let t = this;
    return Tn(async () => (await t.iterator()).mapAsync(e), this.size);
  }
  prefetch(e) {
    if (e == null)
      throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    let t = this;
    return Tn(async () => (await t.iterator()).prefetch(e), this.size);
  }
  repeat(e) {
    let t = this, n10;
    return this.size != null && e > 0 ? n10 = this.size * e : e === 0 ? n10 = 0 : this.size != null && (e === void 0 || e < 0) ? n10 = 1 / 0 : n10 = null, Tn(async () => {
      let s10 = Ky(async () => ({ value: await t.iterator(), done: false }));
      return E4(s10.take(e));
    }, n10);
  }
  skip(e) {
    let t = this, n10;
    return this.size != null && e >= 0 && this.size >= e ? n10 = this.size - e : this.size != null && (this.size < e || e === void 0 || e < 0) ? n10 = 0 : n10 = null, Tn(async () => (await t.iterator()).skip(e), n10);
  }
  shuffle(e, t, n10 = true) {
    if (e == null || e < 0)
      throw this.size == null ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
    let s10 = this, r10 = I4.alea(t || w2.now().toString());
    return Tn(async () => {
      let a10 = r10.int32();
      return n10 && (a10 += r10.int32()), (await s10.iterator()).shuffle(e, a10.toString());
    }, this.size);
  }
  take(e) {
    let t = this, n10;
    return this.size != null && this.size > e ? n10 = e : this.size != null && this.size <= e ? n10 = this.size : n10 = null, Tn(async () => (await t.iterator()).take(e), n10);
  }
  async toArray() {
    if (this.size === 1 / 0)
      throw new Error("Can not convert infinite data stream to array.");
    return (await this.iterator()).toArray();
  }
  async toArrayForTest() {
    if (this.size === 1 / 0)
      throw new Error("Can not convert infinite data stream to array.");
    return (await this.iterator()).toArrayForTest();
  }
};
Zo.MAX_BUFFER_SIZE = 1e4;
function Tn(e, t = null) {
  return new class extends Zo {
    constructor() {
      super(...arguments);
      this.size = t;
    }
    async iterator() {
      return e();
    }
  }();
}
function H4(e) {
  return Tn(async () => bS(e), e.length);
}
function q4(e) {
  if (!Ji(e))
    throw new Error("The argument to zip() must be an object or array.");
  let t;
  if (Array.isArray(e))
    for (let n10 = 0; n10 < e.length; n10++)
      t = t == null ? e[n10].size : Math.min(t, e[n10].size);
  else if (e instanceof Object)
    for (let n10 in e)
      t = t == null ? e[n10].size : Math.min(t, e[n10].size);
  return Tn(async () => {
    let n10 = await hS(e, (s10) => {
      if (s10 instanceof Zo)
        return { value: s10.iterator(), recurse: false };
      if (Ji(s10))
        return { value: null, recurse: true };
      throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
    });
    return R4(n10, 1);
  }, t);
}
function j4(e) {
  if (e === null)
    return null;
  let t = e[0];
  return T4(t) ? { value: K4(e), recurse: false } : { value: null, recurse: true };
}
function K4(e) {
  if (e.length === 0)
    throw new Error("Can't make a batch of zero elements.");
  return e[0] instanceof et ? Qn(e) : hs(e);
}
var wS = class extends Zo {
  constructor(e) {
    super();
    this.input = e;
  }
  async iterator() {
    return (await this.input.iterator()).decodeUTF8().split(`
`).map((s10) => (s10.endsWith("\r") && (s10 = s10.slice(0, -1)), s10));
  }
};
var jc = '"';
var Nu = Symbol("out");
var Qx = Symbol("field");
var Kc = Symbol("quote");
var Gf = Symbol("quoteafterquote");
var Zx = Symbol("quoteinquote");
var kS = class extends Zo {
  constructor(e, t) {
    super();
    this.input = e, this.hasHeader = true, this.fullColumnNames = null, this.columnNamesValidated = false, this.columnConfigs = null, this.configuredColumnsOnly = false, this.delimiter = ",", this.delimWhitespace = false, this.base = new wS(e), t || (t = {}), this.hasHeader = t.hasHeader !== false, this.fullColumnNames = t.columnNames, this.columnConfigs = t.columnConfigs, this.configuredColumnsOnly = t.configuredColumnsOnly, t.delimWhitespace ? (w2.assert(t.delimiter == null, () => "Delimiter should not be provided when delimWhitespace is true."), this.delimWhitespace = true, this.delimiter = " ") : this.delimiter = t.delimiter ? t.delimiter : ",";
  }
  async columnNames() {
    return this.columnNamesValidated || await this.setColumnNames(), this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;
  }
  async setColumnNames() {
    let e = await this.maybeReadHeaderLine();
    if (!this.fullColumnNames && !e)
      throw new Error("Column names must be provided if there is no header line.");
    this.fullColumnNames && e && w2.assert(e.length === this.fullColumnNames.length, () => "The length of provided columnNames (" + this.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + e.length.toString() + ")."), this.fullColumnNames || (this.fullColumnNames = e);
    let t = this.fullColumnNames.reduce((s10, r10) => (s10[r10] = s10[r10] + 1 || 1, s10), {}), n10 = Object.keys(t).filter((s10) => t[s10] > 1);
    if (w2.assert(n10.length === 0, () => "Duplicate column names found: " + n10.toString()), this.columnConfigs) {
      for (let s10 of Object.keys(this.columnConfigs))
        if (this.fullColumnNames.indexOf(s10) === -1)
          throw new Error('The key "' + s10 + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
    }
    this.columnNamesValidated = true;
  }
  async maybeReadHeaderLine() {
    if (this.hasHeader) {
      let t = await (await this.base.iterator()).next();
      if (t.done)
        throw new Error("No data was found for CSV parsing.");
      let n10 = t.value;
      return this.parseRow(n10, false);
    } else
      return null;
  }
  async iterator() {
    this.columnNamesValidated || await this.setColumnNames();
    let e = await this.base.iterator();
    return this.hasHeader && (e = e.skip(1)), e.map((t) => this.makeDataElement(t));
  }
  makeDataElement(e) {
    let t = this.parseRow(e), n10 = {}, s10 = {};
    for (let r10 = 0; r10 < this.fullColumnNames.length; r10++) {
      let a10 = this.fullColumnNames[r10], i10 = this.columnConfigs ? this.columnConfigs[a10] : null;
      if (!(this.configuredColumnsOnly && !i10)) {
        let o10 = t[r10], u10 = null;
        if (o10 === "")
          if (i10 && i10.default !== void 0)
            u10 = i10.default;
          else {
            if (i10 && (i10.required || i10.isLabel))
              throw new Error(`Required column ${a10} is empty in this line: ${e}`);
            u10 = void 0;
          }
        else {
          let l10 = Number(o10);
          if (isNaN(l10))
            i10 && i10.dtype === "bool" ? u10 = this.getBoolean(o10) : u10 = o10;
          else if (!i10 || !i10.dtype)
            u10 = l10;
          else
            switch (i10.dtype) {
              case "float32":
                u10 = l10;
                break;
              case "int32":
                u10 = Math.floor(l10);
                break;
              case "bool":
                u10 = this.getBoolean(o10);
                break;
              default:
                u10 = l10;
            }
        }
        i10 && i10.isLabel ? s10[a10] = u10 : n10[a10] = u10;
      }
    }
    return Object.keys(s10).length === 0 ? n10 : { xs: n10, ys: s10 };
  }
  getBoolean(e) {
    return e === "1" || e.toLowerCase() === "true" ? 1 : 0;
  }
  parseRow(e, t = true) {
    let n10 = [], s10 = 0, r10 = e.length, a10 = Nu;
    for (let i10 = 0; i10 < r10; i10++)
      switch (a10) {
        case Nu:
          switch (e.charAt(i10)) {
            case jc:
              s10 = i10 + 1, a10 = Kc;
              break;
            case this.delimiter:
              if (s10 = i10 + 1, this.delimiter === " " && this.delimWhitespace)
                break;
              n10.push(""), a10 = Nu;
              break;
            default:
              a10 = Qx, s10 = i10;
              break;
          }
          break;
        case Qx:
          switch (e.charAt(i10)) {
            case this.delimiter:
              n10.push(e.substring(s10, i10)), a10 = Nu, s10 = i10 + 1;
              break;
            default:
          }
          break;
        case Kc:
          switch (e.charAt(i10)) {
            case jc:
              a10 = Gf;
              break;
            default:
          }
          break;
        case Gf:
          switch (e.charAt(i10)) {
            case this.delimiter:
              n10.push(e.substring(s10, i10 - 1)), a10 = Nu, s10 = i10 + 1;
              break;
            case jc:
              a10 = Kc;
              break;
            default:
              a10 = Zx;
              break;
          }
          break;
        case Zx:
          switch (e.charAt(i10)) {
            case jc:
              a10 = Kc;
              break;
            default:
          }
          break;
        default:
      }
    if (a10 === Gf ? n10.push(e.substring(s10, r10 - 1)) : n10.push(e.substring(s10)), t && n10.length !== this.fullColumnNames.length)
      throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n10}`);
    return n10;
  }
};
var IS = class extends Ut {
  constructor(e) {
    super();
    this.microphoneConfig = e, this.isClosed = false, this.fftSize = e.fftSize || 1024;
    let t = Math.log2(this.fftSize);
    if (this.fftSize < 0 || t < 4 || t > 14 || !Number.isInteger(t))
      throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);
    if (this.numFrames = e.numFramesPerSpectrogram || 43, this.sampleRateHz = e.sampleRateHz, this.columnTruncateLength = e.columnTruncateLength || this.fftSize, this.audioTrackConstraints = e.audioTrackConstraints, this.smoothingTimeConstant = e.smoothingTimeConstant || 0, this.includeSpectrogram = e.includeSpectrogram !== false, this.includeWaveform = e.includeWaveform === true, !this.includeSpectrogram && !this.includeWaveform)
      throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
  }
  summary() {
    return "microphone";
  }
  static async create(e = {}) {
    if (X2().get("IS_NODE"))
      throw new Error("microphone API is only supported in browser environment.");
    let t = new IS(e);
    return await t.start(), t;
  }
  async start() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints, video: false });
    } catch (n10) {
      throw new Error(`Error thrown while initializing video stream: ${n10.message}`);
    }
    if (!this.stream)
      throw new Error("Could not obtain audio from microphone.");
    let e = window.AudioContext || window.webkitAudioContext;
    if (this.audioContext = new e(), !this.sampleRateHz)
      this.sampleRateHz = this.audioContext.sampleRate;
    else if (this.audioContext.sampleRate !== this.sampleRateHz)
      throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);
    let t = this.audioContext.createMediaStreamSource(this.stream);
    this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = this.fftSize * 2, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, t.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize);
  }
  async next() {
    if (this.isClosed)
      return { value: null, done: true };
    let e, t, n10 = await this.getAudioData();
    if (this.includeSpectrogram) {
      let s10 = this.flattenQueue(n10.freqDataQueue);
      e = this.getTensorFromAudioDataArray(s10, [this.numFrames, this.columnTruncateLength, 1]);
    }
    if (this.includeWaveform) {
      let s10 = this.flattenQueue(n10.timeDataQueue);
      t = this.getTensorFromAudioDataArray(s10, [this.numFrames * this.fftSize, 1]);
    }
    return { value: { spectrogram: e, waveform: t }, done: false };
  }
  async capture() {
    return (await this.next()).value;
  }
  async getAudioData() {
    let e = [], t = [], n10 = 0;
    return new Promise((s10) => {
      let r10 = setInterval(() => {
        this.includeSpectrogram && (this.analyser.getFloatFrequencyData(this.freqData), this.freqData[0] === -1 / 0 && s10({ freqDataQueue: e, timeDataQueue: t }), e.push(this.freqData.slice(0, this.columnTruncateLength))), this.includeWaveform && (this.analyser.getFloatTimeDomainData(this.timeData), t.push(this.timeData.slice())), ++n10 === this.numFrames && (clearInterval(r10), s10({ freqDataQueue: e, timeDataQueue: t }));
      }, this.fftSize / this.sampleRateHz * 1e3);
    });
  }
  stop() {
    this.isClosed || (this.isClosed = true, this.analyser.disconnect(), this.audioContext.close(), this.stream != null && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
  }
  toArray() {
    throw new Error("Can not convert infinite audio stream to array.");
  }
  getSampleRate() {
    return this.sampleRateHz;
  }
  flattenQueue(e) {
    let t = e[0].length, n10 = new Float32Array(e.length * t);
    return e.forEach((s10, r10) => n10.set(s10, r10 * t)), n10;
  }
  getTensorFromAudioDataArray(e, t) {
    let n10 = new Float32Array(w2.sizeFromShape(t));
    return n10.set(e, n10.length - e.length), hs(n10, t);
  }
};
var SS = class extends Ut {
  constructor(e, t) {
    super();
    if (this.webcamVideoElement = e, this.webcamConfig = t, this.isClosed = true, this.resize = false, this.needToResize())
      if (this.resize = true, this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth], this.cropBoxInd = Qt([0], "int32"), this.webcamConfig.centerCrop) {
        let n10 = this.webcamConfig.resizeWidth * 1 / this.webcamVideoElement.width, s10 = this.webcamConfig.resizeHeight * 1 / this.webcamVideoElement.height, r10 = (1 - n10) / 2, a10 = (1 - s10) / 2, i10 = r10 + n10, o10 = s10 + a10;
        this.cropBox = ji([a10, r10, o10, i10], [1, 4]);
      } else
        this.cropBox = ji([0, 0, 1, 1], [1, 4]);
  }
  summary() {
    return "webcam";
  }
  static async create(e, t = {}) {
    if (X2().get("IS_NODE"))
      throw new Error("tf.data.webcam is only supported in browser environment.");
    if (!e) {
      if (e = document.createElement("video"), !t.resizeWidth || !t.resizeHeight)
        throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
      e.width = t.resizeWidth, e.height = t.resizeHeight;
    }
    let n10 = new SS(e, t);
    return await n10.start(), n10;
  }
  async start() {
    this.webcamConfig.facingMode && w2.assert(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: this.webcamConfig.deviceId, facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user", width: this.webcamVideoElement.width, height: this.webcamVideoElement.height } });
    } catch (e) {
      throw e.message = `Error thrown while initializing video stream: ${e.message}`, e;
    }
    if (!this.stream)
      throw new Error("Could not obtain video from webcam.");
    try {
      this.webcamVideoElement.srcObject = this.stream;
    } catch (e) {
      console.log(e), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
    }
    return this.webcamVideoElement.play(), this.isClosed = false, new Promise((e) => {
      this.webcamVideoElement.onloadedmetadata = () => {
        e();
      };
    });
  }
  async next() {
    if (this.isClosed)
      return { value: null, done: true };
    let e;
    try {
      e = xk.fromPixels(this.webcamVideoElement);
    } catch (t) {
      throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`);
    }
    if (this.resize)
      try {
        return { value: this.cropAndResizeFrame(e), done: false };
      } catch (t) {
        throw new Error(`Error thrown cropping the video: ${t.message}`);
      } finally {
        e.dispose();
      }
    else
      return { value: e, done: false };
  }
  needToResize() {
    return !!(this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight));
  }
  cropAndResizeFrame(e) {
    return j2(() => {
      let t = On(ce2(e, "float32"), 0), n10;
      n10 = ds.cropAndResize(t, this.cropBox, this.cropBoxInd, this.cropSize, "bilinear");
      let s10 = n10.shape;
      return G2(n10, s10.slice(1));
    });
  }
  async capture() {
    return (await this.next()).value;
  }
  stop() {
    this.stream.getTracks().forEach((t) => t.stop());
    try {
      this.webcamVideoElement.srcObject = null;
    } catch (t) {
      console.log(t), this.webcamVideoElement.src = null;
    }
    this.isClosed = true;
  }
  toArray() {
    throw new Error("Can not convert infinite video stream to array.");
  }
};
var CS = class {
};
var NS = class extends Ut {
  split(e) {
    return new X4(this, e);
  }
};
var X4 = class extends NS {
  constructor(e, t) {
    super();
    this.upstream = e, this.impl = new Y4(e, t);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
};
var Y4 = class extends Xy {
  constructor(e, t) {
    super();
    this.upstream = e, this.separator = t, this.carryover = "";
  }
  summary() {
    return `${this.upstream.summary()} -> Split('${this.separator}')`;
  }
  async pump() {
    let e = await this.upstream.next();
    if (e.done)
      return this.carryover === "" ? false : (this.outputQueue.push(this.carryover), this.carryover = "", true);
    let t = e.value.split(this.separator);
    t[0] = this.carryover + t[0];
    for (let n10 of t.slice(0, -1))
      this.outputQueue.push(n10);
    return this.carryover = t[t.length - 1], true;
  }
};
var Q4 = class extends Ut {
  decodeUTF8() {
    return new Z4(this);
  }
};
var Z4 = class extends NS {
  constructor(e) {
    super();
    this.upstream = e, this.impl = new J4(e);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
};
var J4 = class extends Xy {
  constructor(e) {
    super();
    if (this.upstream = e, X2().get("IS_BROWSER"))
      this.decoder = new TextDecoder("utf-8");
    else {
      let { StringDecoder: t } = Pw();
      this.decoder = new t("utf8");
    }
  }
  summary() {
    return `${this.upstream.summary()} -> Utf8`;
  }
  async pump() {
    let e = await this.upstream.next(), t;
    if (e.done)
      return false;
    t = e.value;
    let n10;
    return X2().get("IS_BROWSER") ? n10 = this.decoder.decode(t, { stream: true }) : n10 = this.decoder.write(Buffer.from(t.buffer)), this.outputQueue.push(n10), true;
  }
};
var TS = class extends Q4 {
  constructor(e, t = {}) {
    super();
    this.file = e, this.options = t, w2.assert(e instanceof Uint8Array || (X2().get("IS_BROWSER") ? e instanceof File || e instanceof Blob : false), () => "FileChunkIterator only supports File, Blob and Uint8Array right now."), this.offset = t.offset || 0, this.chunkSize = t.chunkSize || 1024 * 1024;
  }
  summary() {
    return `FileChunks ${this.file}`;
  }
  async next() {
    return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? { value: null, done: true } : { value: await new Promise((t, n10) => {
      let s10 = this.offset + this.chunkSize;
      if (this.file instanceof Uint8Array)
        t(new Uint8Array(this.file.slice(this.offset, s10)));
      else {
        let r10 = new FileReader();
        r10.onload = (i10) => {
          let o10 = r10.result;
          if (o10 instanceof ArrayBuffer && (o10 = new Uint8Array(o10)), !(o10 instanceof Uint8Array))
            return n10(new TypeError("FileReader returned unknown type."));
          t(o10);
        }, r10.onabort = (i10) => n10(new Error("Aborted")), r10.onerror = (i10) => n10(new Error(i10.type));
        let a10 = this.file.slice(this.offset, s10);
        r10.readAsArrayBuffer(a10);
      }
      this.offset = s10;
    }), done: false };
  }
};
async function eU(e, t = {}, n10) {
  let s10, r10;
  typeof e == "string" ? s10 = e : (s10 = e.url, r10 = tU(e));
  let a10 = await (n10 || w2.fetch)(s10, r10);
  if (a10.ok) {
    let i10 = new Uint8Array(await a10.arrayBuffer());
    return new TS(i10, t);
  } else
    throw new Error(a10.statusText);
}
var tU = (e) => ({ method: e.method, headers: e.headers, body: e.body, mode: e.mode, credentials: e.credentials, cache: e.cache, redirect: e.redirect, referrer: e.referrer, integrity: e.integrity });
function $S(e) {
  return typeof e == "string" && e.substr(0, 7) === "file://";
}
var _S = class extends CS {
  constructor(e, t = {}) {
    super();
    this.input = e, this.options = t;
  }
  async iterator() {
    if ($S(this.input) && X2().get("IS_NODE")) {
      let e = Jm();
      this.input = e.readFileSync(this.input.substr(7));
    }
    return new TS(this.input, this.options);
  }
};
var AS = class extends CS {
  constructor(e, t = {}) {
    super();
    this.url = e, this.fileOptions = t;
  }
  async iterator() {
    return $S(this.url) ? new _S(this.url, this.fileOptions).iterator() : eU(this.url, this.fileOptions);
  }
};
function nU(e, t = {}) {
  return new kS(new AS(e), t);
}
function sU(e) {
  let t = Ky(e);
  return Tn(async () => t);
}
function rU(e) {
  return Tn(async () => {
    let t = await e();
    return Ky(() => t.next());
  });
}
async function aU(e, t) {
  return SS.create(e, t);
}
async function iU(e) {
  return IS.create(e);
}
var oU = "0.0.0";
function ve2(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach((n10) => {
    n10 != null && w2.assert(n10.dtype !== "complex64", () => `${t} does not support complex64 tensors in the CPU backend.`);
  });
}
var uU = xs.whereImpl;
var ES = class extends tl {
  constructor() {
    super();
    this.blockSize = 48, this.firstUse = true, this.data = new Wd(this, Ss());
  }
  nextDataId() {
    return ES.nextDataId++;
  }
  write(e, t, n10) {
    this.firstUse && (this.firstUse = false, X2().get("IS_NODE") && N2.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));
    let s10 = { id: this.nextDataId() };
    return this.data.set(s10, { values: e, dtype: n10, refCount: 1 }), s10;
  }
  makeTensorInfo(e, t, n10) {
    let s10;
    if (t === "string" && n10 != null && n10.length > 0 && w2.isString(n10[0])) {
      let r10 = n10.map((a10) => w2.encodeString(a10));
      s10 = this.write(r10, e, t);
    } else
      s10 = this.write(n10, e, t);
    return { dataId: s10, shape: e, dtype: t };
  }
  refCount(e) {
    return this.data.has(e) ? this.data.get(e).refCount : 0;
  }
  incRef(e) {
    let t = this.data.get(e);
    t.refCount++;
  }
  decRef(e) {
    if (this.data.has(e)) {
      let t = this.data.get(e);
      t.refCount--;
    }
  }
  move(e, t, n10, s10, r10) {
    this.data.set(e, { values: t, dtype: s10, refCount: r10 });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e) {
    let { dtype: t, complexTensorInfos: n10 } = this.data.get(e);
    if (t === "complex64") {
      let s10 = this.readSync(n10.real.dataId), r10 = this.readSync(n10.imag.dataId);
      return N2.mergeRealAndImagArrays(s10, r10);
    }
    return this.data.get(e).values;
  }
  bufferSync(e) {
    let t = this.readSync(e.dataId), n10 = t;
    if (e.dtype === "string")
      try {
        n10 = t.map((s10) => w2.decodeString(s10));
      } catch (s10) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return De(e.shape, e.dtype, n10);
  }
  makeOutput(e, t, n10) {
    let s10 = this.write(e, t, n10);
    return Ss().makeTensorFromDataId(s10, t, n10, this);
  }
  disposeData(e, t = false) {
    if (this.data.has(e)) {
      if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0)
        return false;
      let { complexTensorInfos: n10 } = this.data.get(e);
      n10 != null && (this.disposeData(n10.real.dataId, true), this.disposeData(n10.imag.dataId, true)), this.data.delete(e);
    }
    return true;
  }
  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }
  async time(e) {
    let t = w2.now();
    return e(), { kernelMs: w2.now() - t };
  }
  memory() {
    return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
  }
  where(e) {
    ve2([e], "where");
    let t = this.readSync(e.dataId);
    return uU(e.shape, t);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  epsilon() {
    return super.epsilon();
  }
};
var RS = ES;
RS.nextDataId = 0;
var Yy = {};
Ae(Yy, { addImpl: () => FS, bincountImpl: () => Zy, bincountReduceImpl: () => OS, ceilImpl: () => PS, concatImpl: () => Jy, equalImpl: () => zS, expImpl: () => LS, expm1Impl: () => VS, floorImpl: () => WS, gatherNdImpl: () => US, gatherV2Impl: () => GS, greaterEqualImpl: () => qS, greaterImpl: () => HS, lessEqualImpl: () => KS, lessImpl: () => jS, linSpaceImpl: () => XS, logImpl: () => YS, maxImpl: () => QS, maximumImpl: () => ZS, minimumImpl: () => JS, multiplyImpl: () => ev, negImpl: () => eC, notEqualImpl: () => tC, prodImpl: () => nC, rangeImpl: () => nv, rsqrtImpl: () => sC, sigmoidImpl: () => YU, simpleAbsImpl: () => DS, sliceImpl: () => Dd, sparseFillEmptyRowsImpl: () => aC, sparseReshapeImpl: () => iC, sparseSegmentReductionImpl: () => sv, sqrtImpl: () => JU, squaredDifferenceImpl: () => oC, stridedSliceImpl: () => uC, stringNGramsImpl: () => lC, stringSplitImpl: () => cC, stringToHashBucketFastImpl: () => dC, subImpl: () => pC, tileImpl: () => hC, topKImpl: () => mC, transposeImpl: () => tv, uniqueImpl: () => gC });
function DS(e) {
  let t = new Float32Array(e.length);
  for (let n10 = 0; n10 < e.length; ++n10)
    t[n10] = Math.abs(e[n10]);
  return t;
}
var lU = (e) => {
  let { x: t } = e.inputs, n10 = e.backend;
  ve2(t, "abs");
  let s10 = new Float32Array(w2.sizeFromShape(t.shape)), r10 = n10.data.get(t.dataId).values;
  return s10 = DS(r10), n10.makeOutput(s10, t.shape, t.dtype);
};
var cU = { kernelName: ao, backendName: "cpu", kernelFunc: lU };
function At(e) {
  return (t, n10, s10, r10, a10) => {
    let i10 = N2.assertAndGetBroadcastShape(t, n10), o10 = i10.length, u10 = w2.computeStrides(i10), l10 = w2.sizeFromShape(i10), c10 = w2.getTypedArrayFromDType(a10, l10), p10 = t.length, d10 = n10.length, h10 = w2.computeStrides(t), f10 = w2.computeStrides(n10), m10 = N2.getBroadcastDims(t, i10), g10 = N2.getBroadcastDims(n10, i10);
    if (m10.length + g10.length === 0)
      for (let b10 = 0; b10 < c10.length; ++b10)
        c10[b10] = e(s10[b10 % s10.length], r10[b10 % r10.length]);
    else
      for (let b10 = 0; b10 < c10.length; ++b10) {
        let y10 = w2.indexToLoc(b10, o10, u10), v10 = y10.slice(-p10);
        m10.forEach((T10) => v10[T10] = 0);
        let x10 = w2.locToIndex(v10, p10, h10), k10 = y10.slice(-d10);
        g10.forEach((T10) => k10[T10] = 0);
        let C10 = w2.locToIndex(k10, d10, f10);
        c10[b10] = e(s10[x10], r10[C10]);
      }
    return [c10, i10];
  };
}
function An(e) {
  let { inputs: t, backend: n10 } = e, { real: s10, imag: r10 } = t, a10 = n10.data.get(s10.dataId).values, i10 = n10.data.get(r10.dataId).values, o10 = n10.makeTensorInfo(s10.shape, "complex64"), u10 = n10.data.get(o10.dataId);
  return u10.complexTensorInfos = { real: n10.makeTensorInfo(s10.shape, "float32", a10), imag: n10.makeTensorInfo(r10.shape, "float32", i10) }, o10;
}
var dU = { kernelName: qd, backendName: "cpu", kernelFunc: An };
function Rd(e, t, n10 = "float32") {
  if (n10 === "complex64") {
    let r10 = Rd(e, t, "float32"), a10 = Rd(e, t, "float32");
    return An({ inputs: { real: r10, imag: a10 }, backend: e });
  }
  let s10 = w2.makeZerosTypedArray(w2.sizeFromShape(t), n10);
  return e.makeTensorInfo(t, n10, s10);
}
function Os(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  return n10.incRef(s10.dataId), { dataId: s10.dataId, shape: s10.shape, dtype: s10.dtype };
}
var pU = { kernelName: Ma, backendName: "cpu", kernelFunc: Os };
function ha(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.data.get(s10.dataId).complexTensorInfos.real, a10 = n10.data.get(r10.dataId).values;
  return n10.makeTensorInfo(r10.shape, r10.dtype, a10);
}
var hU = { kernelName: tp, backendName: "cpu", kernelFunc: ha };
function xr(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dtype: a10 } = s10;
  if (a10 === "complex64") {
    if (r10.dtype === "complex64")
      return Os({ inputs: { x: r10 }, backend: n10 });
    let i10 = Rd(n10, r10.shape, r10.dtype), o10 = xr({ inputs: { x: r10 }, backend: n10, attrs: { dtype: "float32" } }), u10 = An({ inputs: { real: o10, imag: i10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), u10;
  }
  if (r10.dtype === "complex64") {
    let i10 = ha({ inputs: { input: r10 }, backend: n10 }), o10 = xr({ inputs: { x: i10 }, backend: n10, attrs: { dtype: a10 } });
    return n10.disposeIntermediateTensorInfo(i10), o10;
  }
  if (!w2.hasEncodingLoss(r10.dtype, a10)) {
    let i10 = Os({ inputs: { x: r10 }, backend: n10 });
    return { dataId: i10.dataId, shape: i10.shape, dtype: a10 };
  }
  if (a10 === "int32") {
    let i10 = n10.data.get(r10.dataId).values, o10 = Int32Array.from(i10);
    return n10.makeTensorInfo(r10.shape, "int32", o10);
  }
  if (a10 === "bool") {
    let i10 = n10.data.get(r10.dataId).values, o10 = w2.toTypedArray([0], r10.dtype), [u10, l10] = At((c10, p10) => c10 !== p10 ? 1 : 0)(r10.shape, [], i10, o10, "bool");
    return n10.makeTensorInfo(l10, "bool", u10);
  }
  throw new Error(`Error in Cast: failed to cast ${r10.dtype} to ${a10}`);
}
var fU = { kernelName: Sa, backendName: "cpu", kernelFunc: xr };
function Gt(e, t, n10, s10) {
  return n10 == null ? ({ inputs: r10, backend: a10 }) => {
    let { a: i10, b: o10 } = r10, u10 = a10;
    ve2([i10, o10], e);
    let l10 = u10.data.get(i10.dataId).values, c10 = u10.data.get(o10.dataId).values, p10 = i10.dtype === "string" ? N2.fromUint8ToStringArray(l10) : l10, d10 = i10.dtype === "string" ? N2.fromUint8ToStringArray(c10) : c10, h10 = s10 || i10.dtype, [f10, m10] = t(i10.shape, o10.shape, p10, d10, h10);
    return u10.makeTensorInfo(m10, h10, f10);
  } : ({ inputs: r10, backend: a10 }) => {
    let { a: i10, b: o10 } = r10, u10 = a10;
    if (i10.dtype === "complex64" || o10.dtype === "complex64") {
      let l10 = xr({ inputs: { x: i10 }, backend: u10, attrs: { dtype: "complex64" } }), c10 = u10.data.get(l10.dataId), p10 = c10.complexTensorInfos.real, d10 = c10.complexTensorInfos.imag, h10 = u10.data.get(p10.dataId).values, f10 = u10.data.get(d10.dataId).values, m10 = xr({ inputs: { x: o10 }, backend: u10, attrs: { dtype: "complex64" } }), g10 = u10.data.get(m10.dataId), b10 = g10.complexTensorInfos.real, y10 = g10.complexTensorInfos.imag, v10 = u10.data.get(b10.dataId).values, x10 = u10.data.get(y10.dataId).values, [k10, C10, T10] = n10(i10.shape, o10.shape, h10, f10, v10, x10), E10 = u10.makeTensorInfo(T10, "float32", k10), A10 = u10.makeTensorInfo(T10, "float32", C10), P10 = An({ inputs: { real: E10, imag: A10 }, backend: u10 });
      return u10.disposeIntermediateTensorInfo(l10), u10.disposeIntermediateTensorInfo(m10), u10.disposeIntermediateTensorInfo(E10), u10.disposeIntermediateTensorInfo(A10), P10;
    } else {
      let l10 = u10.data.get(i10.dataId).values, c10 = u10.data.get(o10.dataId).values, p10 = s10 || i10.dtype, [d10, h10] = t(i10.shape, o10.shape, l10, c10, p10);
      return u10.makeTensorInfo(h10, p10, d10);
    }
  };
}
function Qy(e) {
  return (t, n10, s10, r10, a10, i10) => {
    let o10 = N2.assertAndGetBroadcastShape(t, n10), u10 = w2.sizeFromShape(o10), l10 = o10.length, c10 = w2.computeStrides(o10), p10 = w2.getTypedArrayFromDType("float32", u10), d10 = w2.getTypedArrayFromDType("float32", u10), h10 = N2.getBroadcastDims(t, o10), f10 = N2.getBroadcastDims(n10, o10), m10 = N2.mergeRealAndImagArrays(s10, r10), g10 = N2.mergeRealAndImagArrays(a10, i10), b10 = t.length, y10 = w2.computeStrides(t), v10 = n10.length, x10 = w2.computeStrides(n10);
    if (h10.length + f10.length === 0)
      for (let k10 = 0; k10 < p10.length; k10++) {
        let C10 = k10 % m10.length, T10 = k10 % g10.length, E10 = e(m10[C10 * 2], m10[C10 * 2 + 1], g10[T10 * 2], g10[T10 * 2 + 1]);
        p10[k10] = E10.real, d10[k10] = E10.imag;
      }
    else
      for (let k10 = 0; k10 < p10.length; k10++) {
        let C10 = w2.indexToLoc(k10, l10, c10), T10 = C10.slice(-b10);
        h10.forEach((F10) => T10[F10] = 0);
        let E10 = w2.locToIndex(T10, b10, y10), A10 = C10.slice(-v10);
        f10.forEach((F10) => A10[F10] = 0);
        let P10 = w2.locToIndex(A10, v10, x10), R10 = e(m10[E10 * 2], m10[E10 * 2 + 1], g10[P10 * 2], g10[P10 * 2 + 1]);
        p10[k10] = R10.real, d10[k10] = R10.imag;
      }
    return [p10, d10, o10];
  };
}
var FS = At((e, t) => e + t);
var mU = Qy((e, t, n10, s10) => ({ real: e + n10, imag: t + s10 }));
var jl = Gt(kr, FS, mU);
var gU = { kernelName: kr, backendName: "cpu", kernelFunc: jl };
function Zy(e, t, n10, s10, r10) {
  let a10 = w2.sizeFromShape(s10), i10 = w2.makeZerosTypedArray(r10, n10);
  for (let o10 = 0; o10 < e.length; o10++) {
    let u10 = e[o10];
    if (u10 < 0)
      throw new Error("Input x must be non-negative!");
    u10 >= r10 || (a10 > 0 ? i10[u10] += t[o10] : i10[u10] += 1);
  }
  return i10;
}
function OS(e, t, n10, s10 = false) {
  let r10 = e.shape[0], a10 = e.shape[1], i10 = De([r10, n10], t.dtype);
  for (let o10 = 0; o10 < r10; o10++)
    for (let u10 = 0; u10 < a10; u10++) {
      let l10 = e.get(o10, u10);
      if (l10 < 0)
        throw new Error("Input x must be non-negative!");
      l10 >= n10 || (s10 ? i10.set(1, o10, l10) : t.size > 0 ? i10.set(i10.get(o10, l10) + t.get(o10, u10), o10, l10) : i10.set(i10.get(o10, l10) + 1, o10, l10));
    }
  return i10;
}
function Ar(e) {
  return (t, n10, s10) => {
    let r10 = w2.getTypedArrayFromDType(n10, t.length);
    for (let a10 = 0; a10 < t.length; ++a10)
      r10[a10] = e(t[a10], s10);
    return r10;
  };
}
function st(e, t, n10) {
  return ({ inputs: s10, attrs: r10, backend: a10 }) => {
    let { x: i10 } = s10;
    if (ve2(i10, e), i10.dtype === "string" || n10 === "string")
      throw new Error("unaryKernelFunc does not support string input/output");
    let o10 = a10, u10 = o10.data.get(i10.dataId).values, l10 = w2.sizeFromShape(i10.shape), c10 = n10 || i10.dtype, p10 = w2.getArrayFromDType(c10, l10);
    for (let d10 = 0; d10 < l10; ++d10)
      p10[d10] = t(u10[d10], r10);
    return o10.makeTensorInfo(i10.shape, c10, p10);
  };
}
function Jo(e, t, n10) {
  return ({ inputs: s10, attrs: r10, backend: a10 }) => {
    let { x: i10 } = s10;
    if (ve2(i10, e), i10.dtype === "string" || n10 === "string")
      throw new Error("unaryKernelFunc does not support string input/output");
    let o10 = a10, u10 = o10.data.get(i10.dataId).values, l10 = n10 || i10.dtype, c10 = t(u10, l10, r10);
    return o10.makeTensorInfo(i10.shape, l10, c10);
  };
}
var PS = Ar((e) => Math.ceil(e));
var bU = Jo(Ca, PS);
var yU = { kernelName: Ca, backendName: "cpu", kernelFunc: bU };
function Jy(e, t, n10, s10) {
  let r10 = w2.getArrayFromDType(n10, w2.sizeFromShape(t));
  if (s10 && n10 !== "string") {
    let a10 = 0;
    e.forEach((i10) => {
      let o10 = w2.sizeFromShape(i10.shape);
      r10.set(i10.vals, a10), a10 += o10;
    });
  } else {
    let a10 = 0;
    e.forEach((i10) => {
      let o10 = n10 === "string" ? N2.fromUint8ToStringArray(i10.vals) : i10.vals, u10 = 0;
      for (let l10 = 0; l10 < i10.shape[0]; ++l10) {
        let c10 = l10 * t[1] + a10;
        for (let p10 = 0; p10 < i10.shape[1]; ++p10)
          r10[c10 + p10] = o10[u10++];
      }
      a10 += i10.shape[1];
    });
  }
  return r10;
}
var zS = At((e, t) => e === t ? 1 : 0);
var MS = Gt(po, zS, null, "bool");
var vU = { kernelName: po, backendName: "cpu", kernelFunc: MS };
var LS = Ar((e) => Math.exp(e));
var BS = Jo(Da, LS, "float32");
var xU = { kernelName: Da, backendName: "cpu", kernelFunc: BS };
var VS = Ar((e) => Math.expm1(e));
var wU = Jo(fo, VS);
var kU = { kernelName: fo, backendName: "cpu", kernelFunc: wU };
var WS = Ar((e) => Math.floor(e));
var IU = Jo(Fa, WS);
var SU = { kernelName: Fa, backendName: "cpu", kernelFunc: IU };
function US(e, t, n10, s10, r10, a10, i10, o10, u10) {
  let l10 = De([s10, a10], n10);
  for (let c10 = 0; c10 < s10; c10++) {
    let p10 = [], d10 = 0;
    for (let h10 = 0; h10 < r10; h10++) {
      let f10 = e[c10 * r10 + h10];
      d10 += f10 * i10[h10], p10.push(f10);
    }
    if (d10 < 0 || d10 >= u10 / a10)
      throw new Error(`Invalid indices: ${p10} does not index into ${o10}`);
    for (let h10 = 0; h10 < a10; h10++)
      l10.values[c10 * a10 + h10] = t.get(...t.indexToLoc(d10 * a10 + h10));
  }
  return l10;
}
function GS(e, t, n10) {
  let s10 = De(n10, e.dtype);
  for (let r10 = 0; r10 < s10.size; ++r10) {
    let i10 = s10.indexToLoc(r10).slice(), o10 = i10[0], u10 = i10[2], l10 = t.locToIndex([o10, u10]);
    i10[2] = t.values[l10];
    let c10 = e.locToIndex(i10);
    0 <= c10 && c10 < e.values.length && (s10.values[r10] = e.values[c10]);
  }
  return s10;
}
var HS = At((e, t) => e > t ? 1 : 0);
var CU = Gt(yo, HS, null, "bool");
var NU = { kernelName: yo, backendName: "cpu", kernelFunc: CU };
var qS = At((e, t) => e >= t ? 1 : 0);
var TU = Gt(za, qS, null, "bool");
var $U = { kernelName: za, backendName: "cpu", kernelFunc: TU };
var jS = At((e, t) => e < t ? 1 : 0);
var _U = Gt(vo, jS, null, "bool");
var AU = { kernelName: vo, backendName: "cpu", kernelFunc: _U };
var KS = At((e, t) => e <= t ? 1 : 0);
var EU = Gt(xo, KS, null, "bool");
var RU = { kernelName: xo, backendName: "cpu", kernelFunc: EU };
function XS(e, t, n10) {
  let s10 = (t - e) / (n10 - 1), r10 = w2.makeZerosTypedArray(n10, "float32");
  r10[0] = e;
  for (let a10 = 1; a10 < r10.length; a10++)
    r10[a10] = r10[a10 - 1] + s10;
  return r10;
}
var YS = Ar((e) => Math.log(e));
var DU = Jo(Ba, YS);
var FU = { kernelName: Ba, backendName: "cpu", kernelFunc: DU };
function QS(e, t, n10, s10) {
  let r10 = w2.getTypedArrayFromDType(s10, w2.sizeFromShape(n10));
  for (let a10 = 0; a10 < r10.length; ++a10) {
    let i10 = a10 * t, o10 = e[i10];
    for (let u10 = 0; u10 < t; ++u10) {
      let l10 = e[i10 + u10];
      (Number.isNaN(l10) || l10 > o10) && (o10 = l10);
    }
    r10[a10] = o10;
  }
  return r10;
}
var ZS = At((e, t) => Math.max(e, t));
var OU = Gt(Wa, ZS);
var PU = { kernelName: Wa, backendName: "cpu", kernelFunc: OU };
var JS = At((e, t) => Math.min(e, t));
var zU = Gt(qa, JS);
var MU = { kernelName: qa, backendName: "cpu", kernelFunc: zU };
var ev = At((e, t) => e * t);
var LU = Qy((e, t, n10, s10) => ({ real: e * n10 - t * s10, imag: e * s10 + t * n10 }));
var Gp = Gt(Ka, ev, LU);
var BU = { kernelName: Ka, backendName: "cpu", kernelFunc: Gp };
function eC(e, t, n10) {
  let s10 = w2.createScalarValue(-1, n10);
  return ev([], t, s10, e, n10);
}
function VU(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  ve2(s10, "neg");
  let r10 = n10.data.get(s10.dataId).values, [a10, i10] = eC(r10, s10.shape, s10.dtype);
  return n10.makeTensorInfo(i10, s10.dtype, a10);
}
var WU = { kernelName: ko, backendName: "cpu", kernelFunc: VU };
var tC = At((e, t) => e !== t ? 1 : 0);
var UU = Gt(Io, tC, null, "bool");
var GU = { kernelName: Io, backendName: "cpu", kernelFunc: UU };
function tv(e, t, n10, s10, r10) {
  let a10 = t.length, i10 = w2.sizeFromShape(t), o10 = w2.computeStrides(t), u10 = w2.computeStrides(r10), l10 = w2.getTypedArrayFromDType(n10, w2.sizeFromShape(r10));
  for (let c10 = 0; c10 < i10; ++c10) {
    let p10 = w2.indexToLoc(c10, a10, o10), d10 = new Array(p10.length);
    for (let f10 = 0; f10 < d10.length; f10++)
      d10[f10] = p10[s10[f10]];
    let h10 = w2.locToIndex(d10, a10, u10);
    l10[h10] = e[c10];
  }
  return l10;
}
function Vn(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10 } = t, { perm: a10 } = n10;
  ve2(r10, "transpose");
  let i10 = r10.shape.length, o10 = new Array(i10);
  for (let p10 = 0; p10 < o10.length; p10++)
    o10[p10] = r10.shape[a10[p10]];
  let u10 = s10.data.get(r10.dataId).values, l10 = tv(u10, r10.shape, r10.dtype, a10, o10);
  return { dataId: s10.write(l10, o10, r10.dtype), shape: o10, dtype: r10.dtype };
}
var HU = { kernelName: ci, backendName: "cpu", kernelFunc: Vn };
function nC(e, t, n10, s10) {
  let [r10, a10] = N2.computeOutAndReduceShapes(e, s10), i10 = yn(t, "int32"), o10 = w2.makeZerosTypedArray(w2.sizeFromShape(r10), i10), u10 = w2.sizeFromShape(a10);
  for (let l10 = 0; l10 < o10.length; ++l10) {
    let c10 = l10 * u10, p10 = 1;
    for (let d10 = 0; d10 < u10; ++d10)
      p10 *= n10[c10 + d10];
    o10[l10] = p10;
  }
  return { outVals: o10, outShape: r10, outDtype: i10 };
}
function qU(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  ve2(r10, "prod");
  let o10 = r10.shape.length, u10 = w2.parseAxisParam(a10, r10.shape), l10 = N2.getAxesPermutation(u10, o10), c10 = u10, p10 = r10, d10 = [];
  l10 != null && (p10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: l10 } }), d10.push(p10), c10 = N2.getInnerMostAxes(c10.length, o10));
  let h10 = n10.data.get(p10.dataId).values, { outVals: f10, outShape: m10, outDtype: g10 } = nC(p10.shape, p10.dtype, h10, c10), b10 = m10;
  return i10 && (b10 = N2.expandShapeToKeepDim(m10, u10)), d10.forEach((y10) => n10.disposeIntermediateTensorInfo(y10)), n10.makeTensorInfo(b10, g10, f10);
}
var jU = { kernelName: _o, backendName: "cpu", kernelFunc: qU };
function nv(e, t, n10, s10) {
  let r10 = e === t, a10 = e < t && n10 < 0, i10 = t < e && n10 > 1;
  if (r10 || a10 || i10)
    return w2.makeZerosTypedArray(0, s10);
  let o10 = Math.abs(Math.ceil((t - e) / n10)), u10 = w2.makeZerosTypedArray(o10, s10);
  t < e && n10 === 1 && (n10 = -1), u10[0] = e;
  for (let l10 = 1; l10 < u10.length; l10++)
    u10[l10] = u10[l10 - 1] + n10;
  return u10;
}
var sC = Ar((e) => 1 / Math.sqrt(e));
var KU = Jo(ti, sC);
var XU = { kernelName: ti, backendName: "cpu", kernelFunc: KU };
var YU = Ar((e) => 1 / (1 + Math.exp(-e)));
var rC = st(si, (e) => 1 / (1 + Math.exp(-e)));
var QU = { kernelName: si, backendName: "cpu", kernelFunc: rC };
function Dd(e, t, n10, s10, r10) {
  let a10 = wt.isSliceContinous(s10, t, n10), i10 = w2.sizeFromShape(n10), o10 = w2.computeStrides(s10);
  if (a10) {
    let p10 = wt.computeFlatOffset(t, o10);
    return r10 === "string" ? e.slice(p10, p10 + i10) : e.subarray(p10, p10 + i10);
  }
  let u10 = r10 === "string" ? N2.fromUint8ToStringArray(e) : e, l10 = De(s10, r10, u10), c10 = De(n10, r10);
  for (let p10 = 0; p10 < c10.size; ++p10) {
    let d10 = c10.indexToLoc(p10), h10 = d10.map((f10, m10) => f10 + t[m10]);
    c10.set(l10.get(...h10), ...d10);
  }
  return r10 === "string" ? N2.fromStringArrayToUint8(c10.values) : c10.values;
}
function fa(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, size: i10 } = s10;
  ve2(r10, "slice");
  let [o10, u10] = wt.parseSliceParams(r10, a10, i10);
  wt.assertParamsValid(r10, o10, u10);
  let l10 = n10.data.get(r10.dataId).values, c10 = Dd(l10, o10, u10, r10.shape, r10.dtype);
  return n10.makeTensorInfo(u10, r10.dtype, c10);
}
var ZU = { kernelName: Oo, backendName: "cpu", kernelFunc: fa };
function aC(e, t, n10, s10, r10, a10, i10) {
  let o10 = t[0], u10 = a10[0], l10 = new Array(u10), c10 = new Array(o10), p10 = t[1];
  if (u10 === 0) {
    if (o10 !== 0)
      throw new Error(N2.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o10));
    let g10 = w2.getArrayFromDType(n10, 0), b10 = w2.getArrayFromDType(r10, 0);
    return [g10, [0, p10], b10, l10, c10];
  }
  let d10 = true, h10 = 0, f10 = new Array(u10).fill(0);
  for (let g10 = 0; g10 < o10; ++g10) {
    let b10 = e[g10 * p10];
    if (b10 < 0)
      throw new Error(N2.getSparseFillEmptyRowsNegativeIndexErrorMessage(g10, b10));
    if (b10 >= u10)
      throw new Error(N2.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g10, b10, u10));
    ++f10[b10], d10 = d10 && b10 >= h10, h10 = b10;
  }
  let m10 = true;
  for (let g10 = 0; g10 < u10; ++g10) {
    let b10 = f10[g10] === 0;
    l10[g10] = b10, m10 = m10 && !b10, f10[g10] = Math.max(f10[g10], 1), g10 > 0 && (f10[g10] += f10[g10 - 1]);
  }
  if (m10 && d10) {
    let g10 = e, b10 = s10;
    for (let y10 = 0; y10 < o10; ++y10)
      c10[y10] = y10;
    return [g10, [o10, p10], b10, l10, c10];
  } else {
    let g10 = f10[u10 - 1], b10 = w2.getArrayFromDType(n10, g10 * p10), y10 = w2.getArrayFromDType(r10, g10), v10 = new Array(u10).fill(0);
    for (let x10 = 0; x10 < o10; ++x10) {
      let k10 = e[x10 * p10], C10 = v10[k10], T10 = (k10 === 0 ? 0 : f10[k10 - 1]) + C10;
      v10[k10]++;
      for (let E10 = 0; E10 < p10; ++E10)
        b10[T10 * p10 + E10] = e[x10 * p10 + E10];
      y10[T10] = s10[x10], c10[x10] = T10;
    }
    for (let x10 = 0; x10 < u10; ++x10)
      if (v10[x10] === 0) {
        let C10 = x10 === 0 ? 0 : f10[x10 - 1];
        b10[C10 * p10 + 0] = x10;
        for (let T10 = 1; T10 < p10; ++T10)
          b10[C10 * p10 + T10] = 0;
        y10[C10] = i10;
      }
    return [b10, [g10, p10], y10, l10, c10];
  }
}
function iC(e, t, n10, s10, r10) {
  let a10 = w2.sizeFromShape(s10), i10 = t[0], o10 = r10.length, u10 = [], l10 = 1, c10 = -1;
  for (let g10 = 0; g10 < o10; ++g10) {
    let b10 = r10[g10];
    if (b10 === -1) {
      if (c10 !== -1)
        throw new Error(N2.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c10, g10));
      c10 = g10, u10.push(1);
    } else {
      if (b10 < 0)
        throw new Error(N2.getSparseReshapeNegativeOutputDimErrorMessage(g10, b10));
      l10 *= b10, u10.push(b10);
    }
  }
  if (c10 !== -1) {
    if (l10 <= 0)
      throw new Error(N2.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
    let g10 = Math.trunc(a10 / l10);
    if (l10 * g10 !== a10)
      throw new Error(N2.getSparseReshapeInputOutputMultipleErrorMessage(s10, u10));
    u10[c10] = g10;
  }
  if (w2.sizeFromShape(u10) !== a10)
    throw new Error(N2.getSparseReshapeInputOutputMismatchErrorMessage(s10, u10));
  let d10 = s10.length, h10 = [];
  if (d10 > 0) {
    h10[d10 - 1] = 1;
    for (let g10 = d10 - 2; g10 >= 0; --g10)
      h10[g10] = h10[g10 + 1] * s10[g10 + 1];
  }
  let f10 = [];
  if (o10 > 0) {
    f10[o10 - 1] = 1;
    for (let g10 = o10 - 2; g10 >= 0; --g10)
      f10[g10] = f10[g10 + 1] * u10[g10 + 1];
  }
  let m10 = w2.getArrayFromDType(n10, i10 * o10);
  for (let g10 = 0; g10 < i10; ++g10) {
    let b10 = 0;
    for (let y10 = 0; y10 < d10; ++y10)
      b10 += e[g10 * d10 + y10] * h10[y10];
    for (let y10 = 0; y10 < o10; ++y10)
      m10[g10 * o10 + y10] = Math.trunc(b10 / f10[y10]), b10 %= f10[y10];
  }
  return [m10, [i10, o10], u10];
}
function sv(e, t, n10, s10, r10, a10 = false, i10 = 0) {
  let o10 = s10.length, u10 = [t[0], e.length / t[0]], l10 = u10[1], p10 = o10 > 0 ? r10[o10 - 1] + 1 : 0;
  if (p10 < 0)
    throw new Error(N2.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let d10 = t.slice();
  d10[0] = p10;
  let h10 = d10.reduce((v10, x10) => v10 * x10, 1), f10 = w2.getArrayFromDType(n10, h10);
  if (o10 === 0)
    return p10 > 0 && f10.fill(i10), [f10, d10];
  if (p10 <= 0)
    throw new Error(N2.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let m10 = 0, g10 = 1, b10 = 0, y10 = r10[m10];
  for (; ; ) {
    let v10 = 0;
    if (g10 < o10) {
      if (v10 = r10[g10], y10 === v10) {
        ++g10;
        continue;
      }
      if (y10 >= v10)
        throw new Error(N2.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
    }
    if (y10 < 0 || y10 >= p10)
      throw new Error(N2.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y10, p10));
    y10 > b10 && f10.fill(i10, b10 * l10, y10 * l10);
    for (let x10 = m10; x10 < g10; ++x10) {
      let k10 = s10[x10];
      if (k10 < 0 || k10 >= u10[0])
        throw new Error(N2.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x10, s10[x10], u10[0]));
      for (let C10 = 0; C10 < l10; C10++)
        f10[y10 * l10 + C10] += e[k10 * l10 + C10];
    }
    if (a10)
      for (let x10 = 0; x10 < l10; x10++)
        f10[y10 * l10 + x10] /= g10 - m10;
    if (m10 = g10, ++g10, b10 = y10 + 1, y10 = v10, g10 > o10)
      break;
  }
  return b10 < p10 && f10.fill(i10, b10 * l10, p10 * l10), [f10, d10];
}
var JU = Ar((e) => Math.sqrt(e));
var eG = st(ri, (e) => Math.sqrt(e));
var tG = { kernelName: ri, backendName: "cpu", kernelFunc: eG };
var oC = At((e, t) => {
  let n10 = e - t;
  return n10 * n10;
});
var nG = Gt(oi, oC);
var sG = { kernelName: oi, backendName: "cpu", kernelFunc: nG };
function uC(e, t, n10, s10) {
  let r10 = De(e, t.dtype);
  for (let a10 = 0; a10 < r10.size; a10++) {
    let i10 = r10.indexToLoc(a10), o10 = new Array(i10.length);
    for (let u10 = 0; u10 < o10.length; u10++)
      o10[u10] = i10[u10] * n10[u10] + s10[u10];
    r10.set(t.get(...o10), ...i10);
  }
  return r10;
}
var rG = class {
  constructor(e, t, n10, s10, r10, a10) {
    this.separator = w2.encodeString(e), this.nGramWidths = t, this.leftPad = w2.encodeString(n10), this.rightPad = w2.encodeString(s10), this.padWidth = r10, this.preserveShort = a10;
  }
  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }
  getNumNGrams(e, t) {
    let n10 = this.getPadWidth(t);
    return Math.max(0, e + 2 * n10 - t + 1);
  }
  createNGrams(e, t, n10, s10, r10, a10) {
    for (let i10 = 0; i10 < r10; ++i10) {
      let o10 = this.getPadWidth(a10), u10 = Math.max(0, o10 - i10), l10 = Math.max(0, o10 - (r10 - (i10 + 1))), c10 = a10 - (u10 + l10), p10 = t + (u10 > 0 ? 0 : i10 - o10), d10 = 0;
      d10 += u10 * this.leftPad.length;
      for (let b10 = 0; b10 < c10; ++b10)
        d10 += e[p10 + b10].length;
      d10 += l10 * this.rightPad.length, d10 += (u10 + l10 + c10 - 1) * this.separator.length, n10[s10 + i10] = new Uint8Array(d10);
      let f10 = n10[s10 + i10], m10 = 0, g10 = (b10) => b10.forEach((y10) => f10[m10++] = y10);
      for (let b10 = 0; b10 < u10; ++b10)
        g10(this.leftPad), g10(this.separator);
      for (let b10 = 0; b10 < c10 - 1; ++b10)
        g10(e[p10 + b10]), g10(this.separator);
      if (c10 > 0) {
        g10(e[p10 + c10 - 1]);
        for (let b10 = 0; b10 < l10; ++b10)
          g10(this.separator), g10(this.rightPad);
      } else {
        for (let b10 = 0; b10 < l10 - 1; ++b10)
          g10(this.rightPad), g10(this.separator);
        g10(this.rightPad);
      }
    }
  }
  compute(e, t) {
    let n10 = e.length, s10 = t.length;
    if (s10 > 0) {
      let o10 = t[0];
      if (o10 !== 0)
        throw new Error(`First split value must be 0, got ${o10}`);
      for (let u10 = 1; u10 < s10; ++u10) {
        let l10 = t[u10] >= o10;
        if (l10 = l10 && t[u10] <= n10, !l10)
          throw new Error(`Invalid split value ${t[u10]}, must be in [${o10}, ${n10}]`);
        o10 = t[u10];
      }
      if (o10 !== n10)
        throw new Error(`Last split value must be data size. Expected ${n10}, got ${o10}`);
    }
    let r10 = s10 - 1, a10 = w2.getArrayFromDType("int32", s10);
    if (n10 === 0 || s10 === 0) {
      let o10 = new Array(n10);
      for (let u10 = 0; u10 <= r10; ++u10)
        a10[u10] = 0;
      return [o10, a10];
    }
    a10[0] = 0;
    for (let o10 = 1; o10 <= r10; ++o10) {
      let u10 = t[o10] - t[o10 - 1], l10 = 0;
      this.nGramWidths.forEach((c10) => {
        l10 += this.getNumNGrams(u10, c10);
      }), this.preserveShort && u10 > 0 && l10 === 0 && (l10 = 1), a10[o10] = a10[o10 - 1] + l10;
    }
    let i10 = new Array(a10[r10]);
    for (let o10 = 0; o10 < r10; ++o10) {
      let u10 = t[o10], l10 = a10[o10];
      if (this.nGramWidths.forEach((c10) => {
        let p10 = t[o10 + 1] - t[o10], d10 = this.getNumNGrams(p10, c10);
        this.createNGrams(e, u10, i10, l10, d10, c10), l10 += d10;
      }), this.preserveShort && l10 === a10[o10]) {
        let c10 = t[o10 + 1] - t[o10];
        if (c10 === 0)
          continue;
        let p10 = c10 + 2 * this.padWidth, d10 = 1;
        this.createNGrams(e, u10, i10, l10, d10, p10);
      }
    }
    return [i10, a10];
  }
};
function lC(e, t, n10, s10, r10, a10, i10, o10) {
  return new rG(n10, s10, r10, a10, i10, o10).compute(e, t);
}
function aG(e, t, n10, s10) {
  if (!e.length)
    return;
  if (t.length === 0) {
    for (let a10 = 0; a10 < e.length; ++a10)
      s10.push(e.subarray(a10, a10 + 1));
    return;
  }
  if (t.length === 1) {
    let a10 = t[0], i10 = e.indexOf(a10);
    for (; i10 !== -1; ) {
      let o10 = e.subarray(0, i10);
      (!n10 || o10.length !== 0) && s10.push(o10), e = e.subarray(i10 + 1), i10 = e.indexOf(a10);
    }
    (!n10 || e.length !== 0) && s10.push(e);
    return;
  }
  let r10 = 0;
  for (let a10 = 0; a10 < e.length + 1; a10++)
    if (a10 === e.length || t.indexOf(e[a10]) !== -1) {
      let i10 = e.subarray(r10, a10);
      (!n10 || i10.length !== 0) && s10.push(i10), r10 = a10 + 1;
    }
}
function cC(e, t, n10) {
  let s10 = e.length, r10 = [], a10 = 0, i10 = 0, o10 = new Array(s10);
  for (let d10 = 0; d10 < s10; ++d10) {
    let h10 = r10.length;
    aG(e[d10], t, n10, r10);
    let f10 = r10.length - h10;
    o10[d10] = f10, a10 += f10, i10 = Math.max(i10, f10);
  }
  let u10 = w2.getArrayFromDType("int32", a10 * 2), l10 = new Array(a10), c10 = [s10, i10], p10 = 0;
  for (let d10 = 0; d10 < s10; ++d10)
    for (let h10 = 0; h10 < o10[d10]; ++h10)
      u10[p10 * 2] = d10, u10[p10 * 2 + 1] = h10, l10[p10] = r10[p10], ++p10;
  return [u10, l10, c10];
}
function dC(e, t) {
  let n10 = w2.getArrayFromDType("int32", e.length);
  for (let s10 = 0; s10 < e.length; ++s10)
    n10[s10] = w2.fingerPrint64(e[s10]).modulo(t).getLowBitsUnsigned();
  return n10;
}
var pC = At((e, t) => e - t);
var iG = Qy((e, t, n10, s10) => ({ real: e - n10, imag: t - s10 }));
var rv = Gt(ui, pC, iG);
var oG = { kernelName: ui, backendName: "cpu", kernelFunc: rv };
function hC(e, t) {
  let n10 = new Array(e.rank);
  for (let r10 = 0; r10 < n10.length; r10++)
    n10[r10] = e.shape[r10] * t[r10];
  let s10 = De(n10, e.dtype);
  for (let r10 = 0; r10 < s10.values.length; ++r10) {
    let a10 = s10.indexToLoc(r10), i10 = new Array(e.rank);
    for (let u10 = 0; u10 < i10.length; u10++)
      i10[u10] = a10[u10] % e.shape[u10];
    let o10 = e.locToIndex(i10);
    s10.values[r10] = e.values[o10];
  }
  return s10;
}
var Eu = (e, t) => {
  let n10 = t.value - e.value;
  return n10 === 0 ? e.index - t.index : n10;
};
function fC(e, t, n10 = 0, s10 = e.length - 1) {
  for (; s10 > n10; ) {
    if (s10 - n10 > 600) {
      let o10 = s10 - n10 + 1, u10 = t - n10 + 1, l10 = Math.log(o10), c10 = 0.5 * Math.exp(2 * l10 / 3), p10 = 0.5 * Math.sqrt(l10 * c10 * (o10 - c10) / o10) * Math.sign(u10 - o10 / 2), d10 = Math.max(n10, Math.floor(t - u10 * c10 / o10 + p10)), h10 = Math.min(s10, Math.floor(t + (o10 - u10) * c10 / o10 + p10));
      fC(e, t, d10, h10);
    }
    let r10 = e[t], a10 = n10, i10 = s10;
    for (w2.swap(e, n10, t), Eu(e[s10], r10) > 0 && w2.swap(e, n10, s10); a10 < i10; ) {
      for (w2.swap(e, a10, i10), a10++, i10--; Eu(e[a10], r10) < 0; )
        a10 = a10 + 1;
      for (; Eu(e[i10], r10) > 0; )
        i10 = i10 - 1;
    }
    Eu(e[n10], r10) === 0 ? w2.swap(e, n10, i10) : (i10 = i10 + 1, w2.swap(e, i10, s10)), i10 <= t && (n10 = i10 + 1), t <= i10 && (s10 = i10 - 1);
  }
}
function mC(e, t, n10, s10, r10) {
  let a10 = t[t.length - 1], [i10, o10] = [e.length / a10, a10], u10 = w2.getTypedArrayFromDType(n10, i10 * s10), l10 = w2.getTypedArrayFromDType("int32", i10 * s10);
  for (let p10 = 0; p10 < i10; p10++) {
    let d10 = p10 * o10, h10 = e.subarray(d10, d10 + o10), f10 = new Array(h10.length);
    h10.forEach((y10, v10) => f10[v10] = { value: y10, index: v10 }), s10 < f10.length && (fC(f10, s10), f10 = f10.slice(0, s10)), r10 && f10.sort(Eu);
    let m10 = p10 * s10, g10 = u10.subarray(m10, m10 + s10), b10 = l10.subarray(m10, m10 + s10);
    for (let y10 = 0; y10 < s10; y10++)
      g10[y10] = f10[y10].value, b10[y10] = f10[y10].index;
  }
  let c10 = t.slice();
  return c10[c10.length - 1] = s10, [De(c10, n10, u10), De(c10, "int32", l10)];
}
function gC(e, t, n10, s10) {
  let r10 = w2.parseAxisParam(t, n10)[0], a10 = [1, n10[0], 1];
  for (let f10 = 0; f10 < r10; f10++)
    a10[0] *= n10[f10];
  a10[1] = n10[r10];
  for (let f10 = r10 + 1; f10 < n10.length; f10++)
    a10[2] *= n10[f10];
  let i10 = {}, o10 = new Int32Array(n10[r10]), u10 = new Vt(a10, s10, e), l10 = [], c10 = a10[0] === 1 && a10[2] === 1;
  for (let f10 = 0; f10 < n10[r10]; f10++) {
    let m10;
    if (c10)
      m10 = e[f10].toString();
    else {
      let g10 = [];
      for (let b10 = 0; b10 < a10[0]; b10++)
        for (let y10 = 0; y10 < a10[2]; y10++)
          g10.push(u10.get(b10, f10, y10));
      m10 = g10.join(",");
    }
    if (i10[m10] !== void 0)
      o10[f10] = i10[m10];
    else {
      let g10 = Object.keys(i10).length;
      i10[m10] = g10, o10[f10] = g10, l10.push(f10);
    }
  }
  let p10 = a10.slice();
  p10[1] = Object.keys(i10).length;
  let d10 = new Vt(p10, s10);
  l10.forEach((f10, m10) => {
    for (let g10 = 0; g10 < a10[0]; g10++)
      for (let b10 = 0; b10 < a10[2]; b10++)
        d10.set(u10.get(g10, f10, b10), g10, m10, b10);
  });
  let h10 = n10.slice();
  return h10[r10] = p10[1], { outputValues: d10.values, outputShape: h10, indices: o10 };
}
var vpe = "0.0.0";
dp("cpu", () => new RS(), 1);
var bC = st(Ra, (e) => e >= 0 ? e : Math.exp(e) - 1);
var uG = { kernelName: Ra, backendName: "cpu", kernelFunc: bC };
function yC(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { alpha: a10 } = s10;
  ve2([r10], "leakyRelu");
  let i10 = w2.sizeFromShape(r10.shape), o10 = n10.data.get(r10.dataId).values, u10 = w2.getTypedArrayFromDType("float32", i10);
  for (let l10 = 0; l10 < o10.length; l10++)
    u10[l10] = o10[l10] < 0 ? a10 * o10[l10] : o10[l10];
  return n10.makeTensorInfo(r10.shape, "float32", u10);
}
var lG = { kernelName: La, backendName: "cpu", kernelFunc: yC };
var cG = At((e, t) => e < 0 ? t * e : e);
function vC(e) {
  let { inputs: t, backend: n10 } = e, { x: s10, alpha: r10 } = t;
  ve2([s10, r10], "prelu");
  let a10 = n10.data.get(s10.dataId).values, i10 = n10.data.get(r10.dataId).values, [o10, u10] = cG(s10.shape, r10.shape, a10, i10, "float32");
  return n10.makeTensorInfo(u10, "float32", o10);
}
var dG = { kernelName: Qa, backendName: "cpu", kernelFunc: vC };
var xC = st(Za, (e) => Math.max(0, e));
var pG = { kernelName: Za, backendName: "cpu", kernelFunc: xC };
var wC = st(ei, (e) => Math.min(Math.max(0, e), 6));
var hG = { kernelName: ei, backendName: "cpu", kernelFunc: wC };
function av(e, t, n10, s10, r10) {
  if (n10 === "linear")
    return Os({ inputs: { x: t }, backend: e });
  if (n10 === "relu")
    return xC({ inputs: { x: t }, backend: e });
  if (n10 === "elu")
    return bC({ inputs: { x: t }, backend: e });
  if (n10 === "relu6")
    return wC({ inputs: { x: t }, backend: e });
  if (n10 === "prelu")
    return vC({ inputs: { x: t, alpha: s10 }, backend: e });
  if (n10 === "leakyrelu")
    return yC({ inputs: { x: t }, backend: e, attrs: { alpha: r10 } });
  if (n10 === "sigmoid")
    return rC({ inputs: { x: t }, backend: e });
  throw new Error(`Activation ${n10} has not been implemented for the CPU backend.`);
}
function mt(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { shape: a10 } = s10, i10 = w2.sizeFromShape(r10.shape), o10 = w2.inferFromImplicitShape(a10, i10), u10 = w2.sizeFromShape(o10);
  w2.assert(i10 === u10, () => `The new shape (${o10}) has ${u10} elements and the old shape (${r10.shape}) has ${i10} elements. The new shape and old shape must have the same number of elements.`), n10.incRef(r10.dataId);
  let l10 = n10.data.get(r10.dataId);
  if (l10.complexTensorInfos != null) {
    let c10 = l10.complexTensorInfos.real, p10 = l10.complexTensorInfos.imag;
    c10.shape = o10, p10.shape = o10;
  }
  return { dataId: r10.dataId, shape: o10, dtype: r10.dtype };
}
var fG = { kernelName: Ao, backendName: "cpu", kernelFunc: mt };
function kC(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10 } = t, { transposeA: i10, transposeB: o10 } = s10;
  ve2([r10, a10], "matMul");
  let u10 = r10.shape.length, l10 = a10.shape.length, c10 = i10 ? r10.shape[u10 - 2] : r10.shape[u10 - 1], p10 = o10 ? a10.shape[l10 - 1] : a10.shape[l10 - 2], d10 = i10 ? r10.shape[u10 - 1] : r10.shape[u10 - 2], h10 = o10 ? a10.shape[l10 - 2] : a10.shape[l10 - 1], f10 = r10.shape.slice(0, -2), m10 = a10.shape.slice(0, -2), g10 = w2.sizeFromShape(f10), b10 = w2.sizeFromShape(m10), v10 = qo.assertAndGetBroadcastShape(r10.shape.slice(0, -2), a10.shape.slice(0, -2)).concat([d10, h10]);
  w2.assert(c10 === p10, () => `Error in matMul: inner shapes (${c10}) and (${p10}) of Tensors with shapes ${r10.shape} and ${a10.shape} and transposeA=${i10} and transposeB=${o10} must match.`);
  let x10 = i10 ? [g10, c10, d10] : [g10, d10, c10], k10 = o10 ? [b10, h10, p10] : [b10, p10, h10], C10 = mt({ inputs: { x: r10 }, backend: n10, attrs: { shape: x10 } }), T10 = mt({ inputs: { x: a10 }, backend: n10, attrs: { shape: k10 } }), E10 = i10 ? C10.shape[1] : C10.shape[2], A10 = i10 ? C10.shape[2] : C10.shape[1], P10 = o10 ? T10.shape[1] : T10.shape[2], R10 = Math.max(g10, b10), F10 = n10.data.get(C10.dataId).values, $10 = n10.data.get(T10.dataId).values, z10 = w2.computeStrides(C10.shape), W10 = w2.computeStrides(T10.shape), [q10, K10, Y10] = i10 ? [z10[0], 1, z10[1]] : [z10[0], z10[1], 1], [Z10, te2, ee2] = o10 ? [1, W10[1], W10[0]] : [W10[1], 1, W10[0]], se2 = A10 * P10, ne2 = De([R10, A10, P10], C10.dtype), oe2 = ne2.values, re2 = n10.blockSize;
  for (let le2 = 0; le2 < R10; le2++)
    for (let me2 = 0; me2 < A10; me2 += re2)
      for (let we2 = 0; we2 < P10; we2 += re2)
        for (let Se2 = 0; Se2 < E10; Se2 += re2) {
          let Ee2 = Math.min(me2 + re2, A10), Pe2 = Math.min(we2 + re2, P10), Xe = Math.min(Se2 + re2, E10);
          for (let Je = me2; Je < Ee2; Je++)
            for (let Ye = we2; Ye < Pe2; Ye++) {
              let tt = 0;
              for (let Ce2 = Se2; Ce2 < Xe; Ce2++) {
                let ut = Math.min(le2, g10 - 1) * q10, rt = Math.min(le2, b10 - 1) * ee2, Zt = F10[ut + Je * K10 + Ce2 * Y10], Nt = $10[Ce2 * Z10 + Ye * te2 + rt];
                tt += Zt * Nt;
              }
              oe2[le2 * se2 + (Je * P10 + Ye)] += tt;
            }
        }
  return n10.disposeIntermediateTensorInfo(C10), n10.disposeIntermediateTensorInfo(T10), n10.makeTensorInfo(v10, ne2.dtype, ne2.values);
}
var mG = { kernelName: Ia, backendName: "cpu", kernelFunc: kC };
function gG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10, bias: i10, preluActivationWeights: o10 } = t, { transposeA: u10, transposeB: l10, activation: c10, leakyreluAlpha: p10 } = s10, d10, h10, f10, m10 = [];
  d10 = kC({ inputs: { a: r10, b: a10 }, attrs: { transposeA: u10, transposeB: l10 }, backend: n10 }), i10 && (h10 = jl({ inputs: { a: d10, b: i10 }, backend: n10 }), m10.push(d10), d10 = h10), c10 && (f10 = av(n10, d10, c10, o10, p10), m10.push(d10), d10 = f10);
  for (let b10 of m10)
    n10.disposeIntermediateTensorInfo(b10);
  return d10;
}
var bG = { kernelName: na, backendName: "cpu", kernelFunc: gG };
var yG = st(nl, (e) => Math.acos(e));
var vG = { kernelName: nl, backendName: "cpu", kernelFunc: yG };
var xG = st(sl, (e) => Math.acosh(e));
var wG = { kernelName: sl, backendName: "cpu", kernelFunc: xG };
function kG(e) {
  let { inputs: t, backend: n10 } = e, s10 = t;
  ve2(t, "addN");
  let r10 = s10.map((o10) => n10.data.get(o10.dataId).values), a10 = De(s10[0].shape, s10[0].dtype), i10 = a10.values;
  for (let o10 = 0; o10 < s10.length; o10++) {
    let u10 = r10[o10];
    for (let l10 = 0; l10 < i10.length; l10++)
      i10[l10] += u10[l10];
  }
  return n10.makeTensorInfo(a10.shape, a10.dtype, a10.values);
}
var IG = { kernelName: xa, backendName: "cpu", kernelFunc: kG };
function SG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  ve2(r10, "all");
  let o10 = w2.parseAxisParam(a10, r10.shape), u10 = o10, l10 = N2.getAxesPermutation(u10, r10.shape.length), c10 = r10;
  l10 != null && (c10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: l10 } }), u10 = N2.getInnerMostAxes(u10.length, r10.shape.length)), N2.assertAxesAreInnerMostDims("all", u10, c10.shape.length);
  let [p10, d10] = N2.computeOutAndReduceShapes(c10.shape, u10), h10 = w2.sizeFromShape(d10), f10 = w2.makeZerosTypedArray(w2.sizeFromShape(p10), c10.dtype), m10 = n10.data.get(c10.dataId).values;
  for (let b10 = 0; b10 < f10.length; ++b10) {
    let y10 = b10 * h10, v10 = m10[y10];
    for (let x10 = 0; x10 < h10; ++x10) {
      let k10 = m10[y10 + x10];
      v10 = v10 && k10;
    }
    f10[b10] = v10;
  }
  l10 != null && n10.disposeIntermediateTensorInfo(c10);
  let g10 = n10.makeTensorInfo(p10, c10.dtype, f10);
  if (i10) {
    let b10 = N2.expandShapeToKeepDim(p10, o10), y10 = mt({ inputs: { x: g10 }, backend: n10, attrs: { shape: b10 } });
    return n10.disposeIntermediateTensorInfo(g10), y10;
  }
  return g10;
}
var CG = { kernelName: rl, backendName: "cpu", kernelFunc: SG };
function NG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  ve2(r10, "any");
  let o10 = w2.parseAxisParam(a10, r10.shape), u10 = o10, l10 = N2.getAxesPermutation(u10, r10.shape.length), c10 = r10;
  l10 != null && (c10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: l10 } }), u10 = N2.getInnerMostAxes(u10.length, r10.shape.length)), N2.assertAxesAreInnerMostDims("any", u10, c10.shape.length);
  let [p10, d10] = N2.computeOutAndReduceShapes(c10.shape, u10), h10 = w2.sizeFromShape(d10), f10 = w2.makeZerosTypedArray(w2.sizeFromShape(p10), c10.dtype), m10 = n10.data.get(c10.dataId).values;
  for (let b10 = 0; b10 < f10.length; ++b10) {
    let y10 = b10 * h10, v10 = m10[y10];
    for (let x10 = 0; x10 < h10; ++x10) {
      let k10 = m10[y10 + x10];
      v10 = v10 || k10;
    }
    f10[b10] = v10;
  }
  l10 != null && n10.disposeIntermediateTensorInfo(c10);
  let g10 = n10.makeTensorInfo(p10, c10.dtype, f10);
  if (i10) {
    let b10 = N2.expandShapeToKeepDim(p10, o10), y10 = mt({ inputs: { x: g10 }, backend: n10, attrs: { shape: b10 } });
    return n10.disposeIntermediateTensorInfo(g10), y10;
  }
  return g10;
}
var TG = { kernelName: al, backendName: "cpu", kernelFunc: NG };
function $G(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10;
  ve2(r10, "argMax");
  let i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), i10 = [i10[0]], N2.assertAxesAreInnerMostDims("argMax", i10, u10.shape.length);
  let [c10, p10] = N2.computeOutAndReduceShapes(u10.shape, i10), d10 = w2.sizeFromShape(c10), h10 = w2.makeZerosTypedArray(d10, "int32"), f10 = w2.sizeFromShape(p10), m10 = n10.data.get(u10.dataId).values;
  for (let g10 = 0; g10 < h10.length; ++g10) {
    let b10 = g10 * f10, y10 = m10[b10], v10 = 0;
    for (let x10 = 0; x10 < f10; ++x10) {
      let k10 = m10[b10 + x10];
      k10 > y10 && (y10 = k10, v10 = x10);
    }
    h10[g10] = v10;
  }
  return l10.forEach((g10) => n10.disposeIntermediateTensorInfo(g10)), n10.makeTensorInfo(c10, "int32", h10);
}
var _G = { kernelName: wa, backendName: "cpu", kernelFunc: $G };
function AG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10;
  ve2(r10, "argMin");
  let i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), i10 = [i10[0]], N2.assertAxesAreInnerMostDims("argMin", i10, u10.shape.length);
  let [c10, p10] = N2.computeOutAndReduceShapes(u10.shape, i10), d10 = w2.sizeFromShape(c10), h10 = w2.makeZerosTypedArray(d10, "int32"), f10 = w2.sizeFromShape(p10), m10 = n10.data.get(u10.dataId).values;
  for (let g10 = 0; g10 < h10.length; ++g10) {
    let b10 = g10 * f10, y10 = m10[b10], v10 = 0;
    for (let x10 = 0; x10 < f10; ++x10) {
      let k10 = m10[b10 + x10];
      k10 < y10 && (y10 = k10, v10 = x10);
    }
    h10[g10] = v10;
  }
  return l10.forEach((g10) => n10.disposeIntermediateTensorInfo(g10)), n10.makeTensorInfo(c10, "int32", h10);
}
var EG = { kernelName: il, backendName: "cpu", kernelFunc: AG };
var RG = st(ol, (e) => Math.asin(e));
var DG = { kernelName: ol, backendName: "cpu", kernelFunc: RG };
var FG = st(ul, (e) => Math.asinh(e));
var OG = { kernelName: ul, backendName: "cpu", kernelFunc: FG };
var PG = st(ll, (e) => Math.atan(e));
var zG = { kernelName: ll, backendName: "cpu", kernelFunc: PG };
var MG = At((e, t) => Math.atan2(e, t));
var LG = Gt(dl, MG);
var BG = { kernelName: dl, backendName: "cpu", kernelFunc: LG };
var VG = st(cl, (e) => Math.atanh(e));
var WG = { kernelName: cl, backendName: "cpu", kernelFunc: VG };
function iv(e, t, n10, s10, r10, a10) {
  let i10 = r10.strideHeight, o10 = r10.strideWidth, u10 = r10.dilationHeight, l10 = r10.dilationWidth, c10 = r10.effectiveFilterHeight, p10 = r10.effectiveFilterWidth, d10 = r10.padInfo.top, h10 = r10.padInfo.left, f10 = a10 === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m10 = De(r10.outShape, n10), g10 = m10.values, b10 = r10.outShape[1] * r10.outShape[2] * r10.outShape[3], y10 = r10.outShape[2] * r10.outShape[3], v10 = r10.outShape[3];
  for (let x10 = 0; x10 < r10.batchSize; ++x10) {
    let k10 = x10 * b10, C10 = x10 * s10[0];
    for (let T10 = 0; T10 < r10.inChannels; ++T10)
      for (let E10 = 0; E10 < r10.outHeight; ++E10) {
        let A10 = E10 * i10 - d10, P10 = Math.max(0, A10), R10 = Math.min(r10.inHeight, c10 + A10), F10 = k10 + E10 * y10;
        for (let $10 = 0; $10 < r10.outWidth; ++$10) {
          let z10 = $10 * o10 - h10, W10 = Math.max(0, z10), q10 = Math.min(r10.inWidth, p10 + z10), K10 = f10, Y10 = 0, Z10 = 0;
          for (let ee2 = P10; ee2 < R10; ee2 += u10) {
            let se2 = C10 + ee2 * s10[1];
            for (let ne2 = W10; ne2 < q10; ne2 += l10) {
              let oe2 = se2 + ne2 * s10[2], re2 = e[oe2 + T10];
              a10 === "max" && re2 > K10 ? K10 = re2 : a10 === "avg" && (Y10 += re2, Z10++);
            }
            if (isNaN(K10))
              break;
          }
          let te2 = F10 + $10 * v10 + T10;
          g10[te2] = a10 === "avg" ? Y10 / Z10 : K10;
        }
      }
  }
  return m10;
}
function IC(e, t, n10, s10, r10 = false, a10 = false) {
  let i10 = De(s10.outShape, "int32"), o10 = s10.strideHeight, u10 = s10.strideWidth, l10 = s10.dilationHeight, c10 = s10.dilationWidth, p10 = s10.effectiveFilterHeight, d10 = s10.effectiveFilterWidth, h10 = s10.padInfo.top, f10 = s10.padInfo.left, m10 = De(t, n10, e);
  for (let g10 = 0; g10 < s10.batchSize; ++g10)
    for (let b10 = 0; b10 < s10.inChannels; ++b10)
      for (let y10 = 0; y10 < s10.outHeight; ++y10) {
        let v10 = y10 * o10 - h10, x10 = v10;
        for (; x10 < 0; )
          x10 += l10;
        let k10 = Math.min(s10.inHeight, p10 + v10);
        for (let C10 = 0; C10 < s10.outWidth; ++C10) {
          let T10 = C10 * u10 - f10, E10 = T10;
          for (; E10 < 0; )
            E10 += c10;
          let A10 = Math.min(s10.inWidth, d10 + T10), P10 = Number.NEGATIVE_INFINITY, R10 = -1;
          for (let F10 = x10; F10 < k10; F10 += l10) {
            let $10 = F10 - v10;
            for (let z10 = E10; z10 < A10; z10 += c10) {
              let W10 = z10 - T10, q10 = m10.get(g10, F10, z10, b10);
              q10 > P10 && (P10 = q10, r10 ? R10 = a10 ? ((g10 * s10.inHeight + F10) * s10.inWidth + z10) * s10.inChannels + b10 : (F10 * s10.inWidth + z10) * s10.inChannels + b10 : R10 = $10 * d10 + W10);
            }
          }
          i10.set(R10, g10, y10, C10, b10);
        }
      }
  return i10;
}
function SC(e, t, n10, s10, r10, a10) {
  let i10 = r10.strideDepth, o10 = r10.strideHeight, u10 = r10.strideWidth, l10 = r10.dilationDepth, c10 = r10.dilationHeight, p10 = r10.dilationWidth, d10 = r10.effectiveFilterDepth, h10 = r10.effectiveFilterHeight, f10 = r10.effectiveFilterWidth, m10 = r10.padInfo.front, g10 = r10.padInfo.top, b10 = r10.padInfo.left, y10 = a10 === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v10 = De(r10.outShape, n10), x10 = v10.values, k10 = r10.outShape[1] * r10.outShape[2] * r10.outShape[3] * r10.outShape[4], C10 = r10.outShape[2] * r10.outShape[3] * r10.outShape[4], T10 = r10.outShape[3] * r10.outShape[4], E10 = r10.outShape[4];
  for (let A10 = 0; A10 < r10.batchSize; ++A10) {
    let P10 = A10 * k10, R10 = A10 * s10[0];
    for (let F10 = 0; F10 < r10.inChannels; ++F10)
      for (let $10 = 0; $10 < r10.outDepth; ++$10) {
        let z10 = $10 * i10 - m10, W10 = z10;
        for (; W10 < 0; )
          W10 += l10;
        let q10 = Math.min(r10.inDepth, d10 + z10), K10 = P10 + $10 * C10;
        for (let Y10 = 0; Y10 < r10.outHeight; ++Y10) {
          let Z10 = Y10 * o10 - g10, te2 = Z10;
          for (; te2 < 0; )
            te2 += c10;
          let ee2 = Math.min(r10.inHeight, h10 + Z10), se2 = K10 + Y10 * T10;
          for (let ne2 = 0; ne2 < r10.outWidth; ++ne2) {
            let oe2 = ne2 * u10 - b10, re2 = oe2;
            for (; re2 < 0; )
              re2 += p10;
            let le2 = Math.min(r10.inWidth, f10 + oe2), me2 = se2 + ne2 * E10, we2 = y10, Se2 = 0, Ee2 = 0;
            for (let Xe = W10; Xe < q10; Xe += l10) {
              let Je = R10 + Xe * s10[1];
              for (let Ye = te2; Ye < ee2; Ye += c10) {
                let tt = Je + Ye * s10[2];
                for (let Ce2 = re2; Ce2 < le2; Ce2 += p10) {
                  let ut = tt + Ce2 * s10[3], rt = e[ut + F10];
                  if (a10 === "max" && rt > we2 ? we2 = rt : a10 === "avg" && (Se2 += rt, Ee2++), isNaN(we2))
                    break;
                }
                if (isNaN(we2))
                  break;
              }
              if (isNaN(we2))
                break;
            }
            let Pe2 = me2 + F10;
            x10[Pe2] = a10 === "avg" ? Se2 / Ee2 : we2;
          }
        }
      }
  }
  return v10;
}
function UG(e, t) {
  let n10 = De(t.outShape, "int32"), s10 = t.strideDepth, r10 = t.strideHeight, a10 = t.strideWidth, i10 = t.dilationDepth, o10 = t.dilationHeight, u10 = t.dilationWidth, l10 = t.effectiveFilterDepth, c10 = t.effectiveFilterHeight, p10 = t.effectiveFilterWidth, d10 = t.padInfo.front, h10 = t.padInfo.top, f10 = t.padInfo.left;
  for (let m10 = 0; m10 < t.batchSize; ++m10)
    for (let g10 = 0; g10 < t.inChannels; ++g10)
      for (let b10 = 0; b10 < t.outDepth; ++b10) {
        let y10 = b10 * s10 - d10, v10 = y10;
        for (; v10 < 0; )
          v10 += i10;
        let x10 = Math.min(t.inDepth, l10 + y10);
        for (let k10 = 0; k10 < t.outHeight; ++k10) {
          let C10 = k10 * r10 - h10, T10 = C10;
          for (; T10 < 0; )
            T10 += o10;
          let E10 = Math.min(t.inHeight, c10 + C10);
          for (let A10 = 0; A10 < t.outWidth; ++A10) {
            let P10 = A10 * a10 - f10, R10 = P10;
            for (; R10 < 0; )
              R10 += u10;
            let F10 = Math.min(t.inWidth, p10 + P10), $10 = Number.NEGATIVE_INFINITY, z10 = -1;
            for (let W10 = v10; W10 < x10; W10 += i10) {
              let q10 = W10 - y10;
              for (let K10 = T10; K10 < E10; K10 += o10) {
                let Y10 = K10 - C10;
                for (let Z10 = R10; Z10 < F10; Z10 += u10) {
                  let te2 = Z10 - P10, ee2 = e.get(m10, W10, K10, Z10, g10);
                  ee2 >= $10 && ($10 = ee2, z10 = q10 * c10 * p10 + Y10 * c10 + te2);
                }
              }
            }
            n10.set(z10, m10, b10, k10, A10, g10);
          }
        }
      }
  return n10;
}
function GG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t;
  ve2(r10, "avgPool");
  let { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1;
  w2.assert(N2.eitherStridesOrDilationsAreOne(i10, l10), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i10} and dilations '${l10}'`);
  let c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10), p10;
  if (c10.filterWidth === 1 && c10.filterHeight === 1 && w2.arraysEqual(c10.inShape, c10.outShape))
    p10 = Os({ inputs: { x: r10 }, backend: n10 });
  else {
    let d10 = n10.data.get(r10.dataId).values, h10 = w2.computeStrides(r10.shape), f10 = iv(d10, r10.shape, r10.dtype, h10, c10, "avg");
    p10 = n10.makeTensorInfo(c10.outShape, r10.dtype, f10.values);
  }
  return p10;
}
var HG = { kernelName: ka, backendName: "cpu", kernelFunc: GG };
function qG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10, dataFormat: l10 } = s10;
  ve2(r10, "avgPool3d");
  let c10 = N2.computePool3DInfo(r10.shape, a10, i10, 1, o10, u10, l10), p10 = n10.data.get(r10.dataId).values, d10 = SC(p10, r10.shape, r10.dtype, w2.computeStrides(r10.shape), c10, "avg");
  return n10.makeTensorInfo(d10.shape, "float32", d10.values);
}
var jG = { kernelName: Hd, backendName: "cpu", kernelFunc: qG };
function KG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, { filterSize: i10, strides: o10, pad: u10, dimRoundingMode: l10 } = s10;
  ve2([r10, a10], "avgPool3DGrad");
  let c10 = N2.computePool3DInfo(a10.shape, i10, o10, 1, u10, l10), p10 = c10.strideDepth, d10 = c10.strideHeight, h10 = c10.strideWidth, f10 = c10.filterDepth, m10 = c10.filterHeight, g10 = c10.filterWidth, b10 = c10.dilationDepth, y10 = c10.dilationHeight, v10 = c10.dilationWidth, x10 = c10.effectiveFilterDepth, k10 = c10.effectiveFilterHeight, C10 = c10.effectiveFilterWidth, T10 = x10 - 1 - c10.padInfo.front, E10 = C10 - 1 - c10.padInfo.left, A10 = k10 - 1 - c10.padInfo.top, P10 = De(a10.shape, "float32"), R10 = 1 / (f10 * m10 * g10), F10 = n10.bufferSync(r10);
  for (let $10 = 0; $10 < c10.batchSize; ++$10)
    for (let z10 = 0; z10 < c10.inChannels; ++z10)
      for (let W10 = 0; W10 < c10.inDepth; ++W10)
        for (let q10 = 0; q10 < c10.inHeight; ++q10)
          for (let K10 = 0; K10 < c10.inWidth; ++K10) {
            let Y10 = W10 - T10, Z10 = q10 - A10, te2 = K10 - E10, ee2 = 0;
            for (let se2 = 0; se2 < x10; se2 += b10) {
              let ne2 = (Y10 + se2) / p10;
              if (!(ne2 < 0 || ne2 >= c10.outDepth || Math.floor(ne2) !== ne2))
                for (let oe2 = 0; oe2 < k10; oe2 += y10) {
                  let re2 = (Z10 + oe2) / d10;
                  if (!(re2 < 0 || re2 >= c10.outHeight || Math.floor(re2) !== re2))
                    for (let le2 = 0; le2 < C10; le2 += v10) {
                      let me2 = (te2 + le2) / h10;
                      if (me2 < 0 || me2 >= c10.outWidth || Math.floor(me2) !== me2)
                        continue;
                      ee2 += F10.get($10, ne2, re2, me2, z10);
                    }
                }
            }
            P10.set(ee2 * R10, $10, W10, q10, K10, z10);
          }
  return n10.makeTensorInfo(P10.shape, P10.dtype, P10.values);
}
var XG = { kernelName: ag, backendName: "cpu", kernelFunc: KG };
function YG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, i10 = a10;
  ve2([r10, a10], "avgPoolGrad");
  let { filterSize: o10, strides: u10, pad: l10 } = s10, c10 = N2.computePool2DInfo(i10.shape, o10, u10, 1, l10), p10 = c10.strideHeight, d10 = c10.strideWidth, h10 = c10.filterHeight, f10 = c10.filterWidth, m10 = c10.dilationHeight, g10 = c10.dilationWidth, b10 = c10.effectiveFilterHeight, y10 = c10.effectiveFilterWidth, v10 = y10 - 1 - c10.padInfo.left, x10 = b10 - 1 - c10.padInfo.top, k10 = De(i10.shape, "float32"), C10 = 1 / (h10 * f10), T10 = n10.data.get(r10.dataId).values, E10 = De(r10.shape, "float32", T10);
  for (let A10 = 0; A10 < c10.batchSize; ++A10)
    for (let P10 = 0; P10 < c10.inChannels; ++P10)
      for (let R10 = 0; R10 < c10.inHeight; ++R10)
        for (let F10 = 0; F10 < c10.inWidth; ++F10) {
          let $10 = R10 - x10, z10 = F10 - v10, W10 = 0;
          for (let q10 = 0; q10 < b10; q10 += m10) {
            let K10 = ($10 + q10) / p10;
            if (!(K10 < 0 || K10 >= c10.outHeight || Math.floor(K10) !== K10))
              for (let Y10 = 0; Y10 < y10; Y10 += g10) {
                let Z10 = (z10 + Y10) / d10;
                if (Z10 < 0 || Z10 >= c10.outWidth || Math.floor(Z10) !== Z10)
                  continue;
                W10 += E10.get(A10, K10, Z10, P10);
              }
          }
          k10.set(W10 * C10, A10, R10, F10, P10);
        }
  return n10.makeTensorInfo(k10.shape, k10.dtype, k10.values);
}
var QG = { kernelName: rg, backendName: "cpu", kernelFunc: YG };
function ZG(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, scale: a10, offset: i10, mean: o10, variance: u10 } = t;
  w2.assert(o10.shape.length === u10.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), w2.assert(i10 == null || o10.shape.length === i10.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), w2.assert(a10 == null || o10.shape.length === a10.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), ve2([r10, o10, u10, a10, i10], "batchNorm");
  let { varianceEpsilon: l10 } = s10;
  l10 == null && (l10 = 1e-3);
  let c10 = n10.data.get(r10.dataId).values, p10 = n10.data.get(o10.dataId).values, d10 = n10.data.get(u10.dataId).values, h10 = a10 ? n10.data.get(a10.dataId).values : new Float32Array([1]), f10 = i10 ? n10.data.get(i10.dataId).values : new Float32Array([0]), m10 = new Float32Array(c10.length), g10 = f10.length, b10 = h10.length, y10 = d10.length, v10 = p10.length, x10 = 0, k10 = 0, C10 = 0, T10 = 0;
  for (let E10 = 0; E10 < c10.length; ++E10)
    m10[E10] = f10[x10++] + (c10[E10] - p10[k10++]) * h10[C10++] / Math.sqrt(d10[T10++] + l10), x10 >= g10 && (x10 = 0), k10 >= v10 && (k10 = 0), C10 >= b10 && (C10 = 0), T10 >= y10 && (T10 = 0);
  return n10.makeTensorInfo(r10.shape, r10.dtype, m10);
}
var JG = { kernelName: Pa, backendName: "cpu", kernelFunc: ZG };
function eH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, crops: i10 } = s10;
  ve2([r10], "batchToSpaceND");
  let o10 = a10.reduce((b10, y10) => b10 * y10), u10 = N2.getReshaped(r10.shape, a10, o10), l10 = N2.getPermuted(u10.length, a10.length), c10 = N2.getReshapedPermuted(r10.shape, a10, o10), p10 = N2.getSliceBeginCoords(i10, a10.length), d10 = N2.getSliceSize(c10, i10, a10.length), h10 = mt({ inputs: { x: r10 }, backend: n10, attrs: { shape: u10 } }), f10 = Vn({ inputs: { x: h10 }, backend: n10, attrs: { perm: l10 } }), m10 = mt({ inputs: { x: f10 }, backend: n10, attrs: { shape: c10 } }), g10 = fa({ inputs: { x: m10 }, backend: n10, attrs: { begin: p10, size: d10 } });
  return n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(m10), g10;
}
var tH = { kernelName: io, backendName: "cpu", kernelFunc: eH };
function nH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, weights: a10 } = t, { size: i10 } = s10, o10 = n10.data.get(r10.dataId).values, u10 = n10.data.get(a10.dataId).values, l10 = Zy(o10, u10, a10.dtype, a10.shape, i10);
  return n10.makeTensorInfo([i10], a10.dtype, l10);
}
var sH = { kernelName: ig, backendName: "cpu", kernelFunc: nH };
function rH(e) {
  let { inputs: t, backend: n10 } = e, { s0: s10, s1: r10 } = t, a10 = n10.data.get(s10.dataId).values, i10 = n10.data.get(r10.dataId).values, o10 = N2.assertAndGetBroadcastShape(Array.from(a10), Array.from(i10));
  return n10.makeTensorInfo([o10.length], "int32", Int32Array.from(o10));
}
var aH = { kernelName: og, backendName: "cpu", kernelFunc: rH };
var iH = st(Ir, (e, t) => {
  let n10 = t;
  return e > n10.clipValueMax ? n10.clipValueMax : e < n10.clipValueMin ? n10.clipValueMin : e;
});
var oH = { kernelName: Ir, backendName: "cpu", kernelFunc: iH };
var uH = (e) => {
  let { x: t } = e.inputs, n10 = e.backend, s10 = new Float32Array(w2.sizeFromShape(t.shape)), r10 = n10.data.get(t.dataId), a10 = r10.complexTensorInfos.real, i10 = r10.complexTensorInfos.imag, o10 = n10.data.get(a10.dataId).values, u10 = n10.data.get(i10.dataId).values;
  for (let l10 = 0; l10 < o10.length; l10++) {
    let c10 = o10[l10], p10 = u10[l10];
    s10[l10] = Math.hypot(c10, p10);
  }
  return n10.makeOutput(s10, t.shape, "float32");
};
var lH = { kernelName: jd, backendName: "cpu", kernelFunc: uH };
function eo(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.data.get(s10.dataId).complexTensorInfos.imag, a10 = n10.data.get(r10.dataId).values;
  return n10.makeTensorInfo(r10.shape, r10.dtype, a10);
}
var cH = { kernelName: Qd, backendName: "cpu", kernelFunc: eo };
function to(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10, a10 = w2.parseAxisParam(r10, t[0].shape)[0], i10 = N2.computeOutShape(t.map((m10) => m10.shape), a10);
  if (w2.sizeFromShape(i10) === 0)
    return n10.makeTensorInfo(i10, t[0].dtype, []);
  let o10 = t.filter((m10) => w2.sizeFromShape(m10.shape) > 0);
  if (o10.length === 1)
    return Os({ inputs: { x: o10[0] }, backend: n10 });
  let u10 = o10.map((m10) => m10.shape);
  if (N2.assertParamsConsistent(u10, a10), o10[0].dtype === "complex64") {
    let m10 = o10.map((x10) => ha({ inputs: { input: x10 }, backend: n10 })), g10 = o10.map((x10) => eo({ inputs: { input: x10 }, backend: n10 })), b10 = to({ inputs: m10, backend: n10, attrs: { axis: a10 } }), y10 = to({ inputs: g10, backend: n10, attrs: { axis: a10 } }), v10 = An({ inputs: { real: b10, imag: y10 }, backend: n10 });
    return m10.forEach((x10) => n10.disposeIntermediateTensorInfo(x10)), g10.forEach((x10) => n10.disposeIntermediateTensorInfo(x10)), n10.disposeIntermediateTensorInfo(b10), n10.disposeIntermediateTensorInfo(y10), v10;
  }
  let l10 = o10.map((m10) => {
    let g10 = w2.sizeFromShape(m10.shape.slice(a10));
    return mt({ inputs: { x: m10 }, backend: n10, attrs: { shape: [-1, g10] } });
  }), c10 = l10.map((m10) => ({ vals: n10.data.get(m10.dataId).values, shape: m10.shape }));
  i10 = N2.computeOutShape(l10.map((m10) => m10.shape), 1);
  let p10 = l10[0].shape[0] === 1, d10 = Jy(c10, i10, t[0].dtype, p10), h10 = N2.computeOutShape(o10.map((m10) => m10.shape), a10), f10 = n10.makeTensorInfo(h10, t[0].dtype, d10);
  return l10.forEach((m10) => n10.disposeIntermediateTensorInfo(m10)), f10;
}
var dH = { kernelName: oo, backendName: "cpu", kernelFunc: to };
function CC(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dataFormat: u10, dilations: l10, dimRoundingMode: c10 } = s10;
  ve2([r10, a10], "conv2d");
  let p10 = N2.convertConv2DDataFormat(u10), d10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, l10, o10, c10, false, p10), h10 = d10.filterHeight, f10 = d10.filterWidth, m10 = d10.dilationHeight, g10 = d10.dilationWidth, b10 = d10.padInfo.left, y10 = d10.padInfo.top, v10 = d10.dataFormat === "channelsLast", x10 = new Vt(d10.outShape, r10.dtype), k10 = w2.computeStrides(r10.shape), C10 = w2.computeStrides(a10.shape), T10 = k10[0], E10 = v10 ? k10[1] : k10[2], A10 = v10 ? k10[2] : 1, P10 = v10 ? 1 : k10[1], R10 = x10.strides[0], F10 = v10 ? x10.strides[1] : x10.strides[2], $10 = v10 ? x10.strides[2] : 1, z10 = v10 ? 1 : x10.strides[1], W10 = n10.data.get(r10.dataId).values, q10 = n10.data.get(a10.dataId).values, K10 = x10.values;
  for (let Y10 = 0; Y10 < d10.batchSize; ++Y10) {
    let Z10 = Y10 * T10, te2 = Y10 * R10;
    for (let ee2 = 0; ee2 < d10.outHeight; ++ee2) {
      let se2 = te2 + ee2 * F10, ne2 = ee2 * d10.strideHeight - y10;
      for (let oe2 = 0; oe2 < h10; ++oe2) {
        let re2 = ne2 + oe2 * m10;
        if (re2 < 0 || re2 >= d10.inHeight)
          continue;
        let le2 = oe2 * C10[0], me2 = Z10 + re2 * E10;
        for (let we2 = 0; we2 < d10.outWidth; ++we2) {
          let Se2 = se2 + we2 * $10, Ee2 = we2 * d10.strideWidth - b10;
          for (let Pe2 = 0; Pe2 < f10; ++Pe2) {
            let Xe = Ee2 + Pe2 * g10;
            if (Xe < 0 || Xe >= d10.inWidth)
              continue;
            let Je = le2 + Pe2 * C10[1], Ye = me2 + Xe * A10, tt = Je;
            for (let Ce2 = 0; Ce2 < d10.inChannels; ++Ce2) {
              let ut = W10[Ye + Ce2 * P10];
              for (let rt = 0; rt < d10.outChannels; ++rt)
                K10[Se2 + rt * z10] += ut * q10[tt + rt];
              tt += d10.outChannels;
            }
          }
        }
      }
    }
  }
  return n10.makeTensorInfo(x10.shape, x10.dtype, K10);
}
var pH = { kernelName: Na, backendName: "cpu", kernelFunc: CC };
function hH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, pad: o10, dataFormat: u10, dimRoundingMode: l10, filterShape: c10 } = s10;
  ve2([r10, a10], "conv2dBackpropFilter");
  let p10 = N2.convertConv2DDataFormat(u10), d10 = N2.computeConv2DInfo(r10.shape, c10, i10, 1, o10, l10, false, p10), { strideHeight: h10, strideWidth: f10, filterHeight: m10, filterWidth: g10 } = d10, b10 = d10.dataFormat === "channelsLast", y10 = new Vt(d10.filterShape, "float32"), v10 = d10.padInfo.left, x10 = d10.padInfo.top, k10 = n10.data.get(r10.dataId).values, C10 = n10.data.get(a10.dataId).values, T10 = new Vt(r10.shape, r10.dtype, k10), E10 = new Vt(a10.shape, a10.dtype, C10);
  for (let A10 = 0; A10 < m10; ++A10) {
    let P10 = Math.max(0, Math.ceil((x10 - A10) / h10)), R10 = Math.min(d10.outHeight, (d10.inHeight + x10 - A10) / h10);
    for (let F10 = 0; F10 < g10; ++F10) {
      let $10 = Math.max(0, Math.ceil((v10 - F10) / f10)), z10 = Math.min(d10.outWidth, (d10.inWidth + v10 - F10) / f10);
      for (let W10 = 0; W10 < d10.inChannels; ++W10)
        for (let q10 = 0; q10 < d10.outChannels; ++q10) {
          let K10 = 0;
          for (let Y10 = 0; Y10 < d10.batchSize; ++Y10)
            for (let Z10 = P10; Z10 < R10; ++Z10) {
              let te2 = A10 + Z10 * h10 - x10;
              for (let ee2 = $10; ee2 < z10; ++ee2) {
                let se2 = F10 + ee2 * f10 - v10;
                b10 ? K10 += T10.get(Y10, te2, se2, W10) * E10.get(Y10, Z10, ee2, q10) : K10 += T10.get(Y10, W10, te2, se2) * E10.get(Y10, q10, Z10, ee2);
              }
            }
          y10.set(K10, A10, F10, W10, q10);
        }
    }
  }
  return n10.makeTensorInfo(y10.shape, y10.dtype, y10.values);
}
var fH = { kernelName: ug, backendName: "cpu", kernelFunc: hH };
function mH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { inputShape: i10, strides: o10, pad: u10, dataFormat: l10, dimRoundingMode: c10 } = s10;
  ve2([r10, a10], "conv2dBackpropInput");
  let p10 = w2.computeStrides(a10.shape), d10 = w2.computeStrides(r10.shape), h10 = N2.convertConv2DDataFormat(l10), f10 = N2.computeConv2DInfo(i10, a10.shape, o10, 1, u10, c10, false, h10), m10 = new Vt(f10.inShape, "float32"), g10 = m10.values, b10 = n10.data.get(r10.dataId).values, y10 = n10.data.get(a10.dataId).values, [v10, x10, k10] = p10, { batchSize: C10, filterHeight: T10, filterWidth: E10, inChannels: A10, inHeight: P10, inWidth: R10, outChannels: F10, outHeight: $10, outWidth: z10, strideHeight: W10, strideWidth: q10 } = f10;
  h10 = f10.dataFormat;
  let K10 = T10 - 1 - f10.padInfo.top, Y10 = E10 - 1 - f10.padInfo.left, Z10 = h10 === "channelsLast", te2 = m10.strides[0], ee2 = Z10 ? m10.strides[1] : m10.strides[2], se2 = Z10 ? m10.strides[2] : 1, ne2 = Z10 ? 1 : m10.strides[1], oe2 = d10[0], re2 = Z10 ? d10[1] : d10[2], le2 = Z10 ? d10[2] : 1, me2 = Z10 ? 1 : d10[1];
  for (let we2 = 0; we2 < C10; ++we2)
    for (let Se2 = 0; Se2 < A10; ++Se2)
      for (let Ee2 = 0; Ee2 < P10; ++Ee2) {
        let Pe2 = Ee2 - K10, Xe = Math.max(0, Math.ceil(Pe2 / W10)), Je = Math.min($10, (T10 + Pe2) / W10);
        for (let Ye = 0; Ye < R10; ++Ye) {
          let tt = Ye - Y10, Ce2 = Math.max(0, Math.ceil(tt / q10)), ut = Math.min(z10, (E10 + tt) / q10), rt = 0;
          for (let Nt = Xe; Nt < Je; ++Nt) {
            let In = Nt * W10 - Pe2;
            for (let Et = Ce2; Et < ut; ++Et) {
              let Jt = Et * q10 - tt, Sn = oe2 * we2 + re2 * Nt + le2 * Et, Cn = v10 * (T10 - 1 - In) + x10 * (E10 - 1 - Jt) + k10 * Se2;
              for (let Xt = 0; Xt < F10; ++Xt) {
                let Rn = b10[Sn + me2 * Xt], en = y10[Cn + Xt];
                rt += Rn * en;
              }
            }
          }
          let Zt = te2 * we2 + ee2 * Ee2 + se2 * Ye + ne2 * Se2;
          g10[Zt] = rt;
        }
      }
  return n10.makeTensorInfo(m10.shape, m10.dtype, m10.values);
}
var gH = { kernelName: Ta, backendName: "cpu", kernelFunc: mH };
function bH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10 } = s10;
  ve2([r10, a10], "conv3d");
  let l10 = N2.computeConv3DInfo(r10.shape, a10.shape, i10, u10, o10), { filterDepth: c10, filterHeight: p10, filterWidth: d10, dilationDepth: h10, dilationHeight: f10, dilationWidth: m10, padInfo: g10 } = l10, b10 = g10.front, y10 = g10.left, v10 = g10.top, x10 = new Vt(l10.outShape, r10.dtype), k10 = n10.data.get(r10.dataId).values, C10 = n10.data.get(a10.dataId).values, T10 = x10.values, E10 = w2.computeStrides(r10.shape), A10 = w2.computeStrides(a10.shape);
  for (let P10 = 0; P10 < l10.batchSize; ++P10) {
    let R10 = P10 * E10[0], F10 = P10 * x10.strides[0];
    for (let $10 = 0; $10 < l10.outDepth; ++$10) {
      let z10 = F10 + $10 * x10.strides[1], W10 = $10 * l10.strideDepth - b10;
      for (let q10 = 0; q10 < c10; ++q10) {
        let K10 = W10 + q10 * h10;
        if (K10 < 0 || K10 >= l10.inDepth)
          continue;
        let Y10 = q10 * A10[0], Z10 = R10 + K10 * E10[1];
        for (let te2 = 0; te2 < l10.outHeight; ++te2) {
          let ee2 = z10 + te2 * x10.strides[2], se2 = te2 * l10.strideHeight - v10;
          for (let ne2 = 0; ne2 < p10; ++ne2) {
            let oe2 = se2 + ne2 * f10;
            if (oe2 < 0 || oe2 >= l10.inHeight)
              continue;
            let re2 = Y10 + ne2 * A10[1], le2 = Z10 + oe2 * E10[2];
            for (let me2 = 0; me2 < l10.outWidth; ++me2) {
              let we2 = ee2 + me2 * l10.outChannels, Se2 = me2 * l10.strideWidth - y10;
              for (let Ee2 = 0; Ee2 < d10; ++Ee2) {
                let Pe2 = Se2 + Ee2 * m10;
                if (Pe2 < 0 || Pe2 >= l10.inWidth)
                  continue;
                let Xe = re2 + Ee2 * A10[2], Je = le2 + Pe2 * l10.inChannels, Ye = Xe;
                for (let tt = 0; tt < l10.inChannels; ++tt) {
                  let Ce2 = k10[Je + tt];
                  for (let ut = 0; ut < l10.outChannels; ++ut)
                    T10[we2 + ut] += Ce2 * C10[Ye + ut];
                  Ye += l10.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return n10.makeTensorInfo(x10.shape, x10.dtype, x10.values);
}
var yH = { kernelName: Kd, backendName: "cpu", kernelFunc: bH };
function vH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, pad: o10, filterShape: u10 } = s10;
  ve2([r10, a10], "conv3dBackpropFilterV2");
  let l10 = w2.computeStrides(r10.shape), c10 = w2.computeStrides(a10.shape), p10 = N2.computeConv3DInfo(r10.shape, u10, i10, 1, o10), d10 = p10.strideDepth, h10 = p10.strideHeight, f10 = p10.strideWidth, m10 = p10.filterDepth, g10 = p10.filterHeight, b10 = p10.filterWidth, y10 = new Vt(p10.filterShape, "float32"), v10 = y10.values, [x10, k10, C10, T10] = y10.strides, E10 = n10.data.get(a10.dataId).values, [A10, P10, R10, F10] = c10, $10 = n10.data.get(r10.dataId).values, [z10, W10, q10, K10] = l10, Y10 = p10.padInfo.front, Z10 = p10.padInfo.left, te2 = p10.padInfo.top;
  for (let ee2 = 0; ee2 < m10; ++ee2) {
    let se2 = Math.max(0, Math.ceil((Y10 - ee2) / d10)), ne2 = Math.min(p10.outDepth, (p10.inDepth + Y10 - ee2) / d10), oe2 = ee2 * x10;
    for (let re2 = 0; re2 < g10; ++re2) {
      let le2 = Math.max(0, Math.ceil((te2 - re2) / h10)), me2 = Math.min(p10.outHeight, (p10.inHeight + te2 - re2) / h10), we2 = re2 * k10 + oe2;
      for (let Se2 = 0; Se2 < b10; ++Se2) {
        let Ee2 = Math.max(0, Math.ceil((Z10 - Se2) / f10)), Pe2 = Math.min(p10.outWidth, (p10.inWidth + Z10 - Se2) / f10), Xe = Se2 * C10 + we2;
        for (let Je = 0; Je < p10.inChannels; ++Je) {
          let Ye = Je * T10 + Xe;
          for (let tt = 0; tt < p10.outChannels; ++tt) {
            let Ce2 = 0;
            for (let ut = 0; ut < p10.batchSize; ++ut) {
              let rt = ut * z10, Zt = ut * A10;
              for (let Nt = se2; Nt < ne2; ++Nt) {
                let Et = (ee2 + Nt * d10 - Y10) * W10 + rt, Jt = Nt * P10 + Zt;
                for (let Sn = le2; Sn < me2; ++Sn) {
                  let Xt = (re2 + Sn * h10 - te2) * q10 + Et, Rn = Sn * R10 + Jt;
                  for (let en = Ee2; en < Pe2; ++en) {
                    let Ls = (Se2 + en * f10 - Z10) * K10 + Xt, xi = en * F10 + Rn;
                    Ce2 += $10[Ls + Je] * E10[xi + tt];
                  }
                }
              }
            }
            v10[Ye + tt] = Ce2;
          }
        }
      }
    }
  }
  return n10.makeTensorInfo(y10.shape, y10.dtype, y10.values);
}
var xH = { kernelName: lg, backendName: "cpu", kernelFunc: vH };
function wH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { pad: i10, strides: o10, inputShape: u10 } = s10;
  ve2([r10], "conv3dBackpropInputV2");
  let l10 = w2.computeStrides(r10.shape), c10 = w2.computeStrides(a10.shape), p10 = N2.computeConv3DInfo(u10, a10.shape, o10, 1, i10), d10 = new Vt(p10.inShape, "float32"), h10 = d10.values, [f10, m10, g10, b10] = d10.strides, y10 = n10.data.get(r10.dataId).values, [v10, x10, k10, C10] = l10, T10 = n10.data.get(a10.dataId).values, [E10, A10, P10, R10] = c10, { batchSize: F10, filterDepth: $10, filterHeight: z10, filterWidth: W10, inChannels: q10, inDepth: K10, inHeight: Y10, inWidth: Z10, outChannels: te2, outDepth: ee2, outHeight: se2, outWidth: ne2, strideDepth: oe2, strideHeight: re2, strideWidth: le2 } = p10, me2 = $10 - 1 - p10.padInfo.front, we2 = z10 - 1 - p10.padInfo.top, Se2 = W10 - 1 - p10.padInfo.left;
  for (let Ee2 = 0; Ee2 < F10; ++Ee2)
    for (let Pe2 = 0; Pe2 < q10; ++Pe2)
      for (let Xe = 0; Xe < K10; ++Xe) {
        let Je = Xe - me2, Ye = Math.max(0, Math.ceil(Je / oe2)), tt = Math.min(ee2, ($10 + Je) / oe2);
        for (let Ce2 = 0; Ce2 < Y10; ++Ce2) {
          let ut = Ce2 - we2, rt = Math.max(0, Math.ceil(ut / re2)), Zt = Math.min(se2, (z10 + ut) / re2);
          for (let Nt = 0; Nt < Z10; ++Nt) {
            let In = Nt - Se2, Et = Math.max(0, Math.ceil(In / le2)), Jt = Math.min(ne2, (W10 + In) / le2), Sn = 0;
            for (let Cn = Ye; Cn < tt; ++Cn) {
              let Xt = Cn * oe2 - Je;
              for (let Rn = rt; Rn < Zt; ++Rn) {
                let en = Rn * re2 - ut;
                for (let Ms = Et; Ms < Jt; ++Ms) {
                  let Ls = Ms * le2 - In, xi = v10 * Ee2 + x10 * Cn + k10 * Rn + C10 * Ms, Js = E10 * ($10 - 1 - Xt) + A10 * (z10 - 1 - en) + P10 * (W10 - 1 - Ls) + R10 * Pe2;
                  for (let Bs = 0; Bs < te2; ++Bs) {
                    let du = y10[xi + Bs], wi = T10[Js + Bs];
                    Sn += du * wi;
                  }
                }
              }
            }
            h10[f10 * Ee2 + m10 * Xe + g10 * Ce2 + b10 * Nt + Pe2] = Sn;
          }
        }
      }
  return n10.makeTensorInfo(d10.shape, d10.dtype, d10.values);
}
var kH = { kernelName: cg, backendName: "cpu", kernelFunc: wH };
var IH = st($a, (e) => Math.cos(e));
var SH = { kernelName: $a, backendName: "cpu", kernelFunc: IH };
var CH = st(_a, (e) => Math.cosh(e));
var NH = { kernelName: _a, backendName: "cpu", kernelFunc: CH };
function TH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10, boxes: a10, boxInd: i10 } = t, { cropSize: o10, method: u10, extrapolationValue: l10 } = s10, [c10, p10, d10, h10] = r10.shape, f10 = a10.shape[0], [m10, g10] = o10, b10 = De([f10, m10, g10, h10], "float32"), y10 = n10.data.get(a10.dataId).values, v10 = n10.data.get(i10.dataId).values, x10 = n10.data.get(r10.dataId).values, k10 = w2.computeStrides(r10.shape), C10 = w2.computeStrides(b10.shape);
  for (let T10 = 0; T10 < f10; T10++) {
    let E10 = T10 * 4, A10 = y10[E10], P10 = y10[E10 + 1], R10 = y10[E10 + 2], F10 = y10[E10 + 3], $10 = v10[T10];
    if ($10 >= c10)
      continue;
    let z10 = m10 > 1 ? (R10 - A10) * (p10 - 1) / (m10 - 1) : 0, W10 = g10 > 1 ? (F10 - P10) * (d10 - 1) / (g10 - 1) : 0;
    for (let q10 = 0; q10 < m10; q10++) {
      let K10 = m10 > 1 ? A10 * (p10 - 1) + q10 * z10 : 0.5 * (A10 + R10) * (p10 - 1);
      if (K10 < 0 || K10 > p10 - 1) {
        for (let Y10 = 0; Y10 < g10; Y10++)
          for (let Z10 = 0; Z10 < h10; Z10++) {
            let te2 = Z10 + Y10 * C10[2] + q10 * C10[1] + T10 * C10[0];
            b10.values[te2] = l10;
          }
        continue;
      }
      if (u10 === "bilinear") {
        let Y10 = Math.floor(K10), Z10 = Math.ceil(K10), te2 = K10 - Y10;
        for (let ee2 = 0; ee2 < g10; ee2++) {
          let se2 = g10 > 1 ? P10 * (d10 - 1) + ee2 * W10 : 0.5 * (P10 + F10) * (d10 - 1);
          if (se2 < 0 || se2 > d10 - 1) {
            for (let le2 = 0; le2 < h10; le2++) {
              let me2 = le2 + ee2 * C10[2] + q10 * C10[1] + T10 * C10[0];
              b10.values[me2] = l10;
            }
            continue;
          }
          let ne2 = Math.floor(se2), oe2 = Math.ceil(se2), re2 = se2 - ne2;
          for (let le2 = 0; le2 < h10; le2++) {
            let me2 = le2 + ne2 * k10[2] + Y10 * k10[1] + $10 * k10[0], we2 = x10[me2];
            me2 = le2 + oe2 * k10[2] + Y10 * k10[1] + $10 * k10[0];
            let Se2 = x10[me2];
            me2 = le2 + ne2 * k10[2] + Z10 * k10[1] + $10 * k10[0];
            let Ee2 = x10[me2];
            me2 = le2 + oe2 * k10[2] + Z10 * k10[1] + $10 * k10[0];
            let Pe2 = x10[me2], Xe = we2 + (Se2 - we2) * re2, Je = Ee2 + (Pe2 - Ee2) * re2;
            me2 = le2 + ee2 * C10[2] + q10 * C10[1] + T10 * C10[0], b10.values[me2] = Xe + (Je - Xe) * te2;
          }
        }
      } else
        for (let Y10 = 0; Y10 < g10; ++Y10) {
          let Z10 = g10 > 1 ? P10 * (d10 - 1) + Y10 * W10 : 0.5 * (P10 + F10) * (d10 - 1);
          if (Z10 < 0 || Z10 > d10 - 1) {
            for (let se2 = 0; se2 < h10; se2++) {
              let ne2 = se2 + Y10 * C10[2] + q10 * C10[1] + T10 * C10[0];
              b10.values[ne2] = l10;
            }
            continue;
          }
          let te2 = Math.round(Z10), ee2 = Math.round(K10);
          for (let se2 = 0; se2 < h10; se2++) {
            let ne2 = se2 + te2 * k10[2] + ee2 * k10[1] + $10 * k10[0], oe2 = se2 + Y10 * C10[2] + q10 * C10[1] + T10 * C10[0];
            b10.values[oe2] = x10[ne2];
          }
        }
    }
  }
  return n10.makeTensorInfo(b10.shape, b10.dtype, b10.values);
}
var $H = { kernelName: lo, backendName: "cpu", kernelFunc: TH };
function _H(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, exclusive: i10, reverse: o10 } = s10;
  ve2(r10, "cumsum");
  let u10 = N2.getAxesPermutation([a10], r10.shape.length), l10 = r10;
  u10 != null && (l10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: u10 } }));
  let c10 = N2.getInnerMostAxes(1, r10.shape.length)[0];
  if (c10 !== l10.shape.length - 1)
    throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l10.shape.length - 1} but got axis=${c10}`);
  let p10 = yn(l10.dtype, "int32"), d10 = w2.makeZerosTypedArray(w2.sizeFromShape(l10.shape), p10), h10 = n10.data.get(l10.dataId).values, f10 = l10.shape[l10.shape.length - 1], m10 = o10 ? (b10, y10) => b10 + f10 - y10 - 1 : (b10, y10) => b10 + y10;
  for (let b10 = 0; b10 < h10.length; b10 += f10)
    for (let y10 = 0; y10 < f10; y10++) {
      let v10 = m10(b10, y10);
      if (y10 === 0)
        d10[v10] = i10 ? 0 : h10[v10];
      else {
        let x10 = m10(b10, y10 - 1);
        d10[v10] = i10 ? h10[x10] + d10[x10] : h10[v10] + d10[x10];
      }
    }
  let g10 = n10.makeTensorInfo(l10.shape, p10, d10);
  if (u10 != null) {
    let b10 = N2.getUndoAxesPermutation(u10), y10 = Vn({ inputs: { x: g10 }, backend: n10, attrs: { perm: b10 } });
    return n10.disposeIntermediateTensorInfo(g10), n10.disposeIntermediateTensorInfo(l10), y10;
  }
  return g10;
}
var AH = { kernelName: uo, backendName: "cpu", kernelFunc: _H };
function EH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, weights: a10 } = t, { size: i10, binaryOutput: o10 } = s10;
  if (r10.shape.length === 1) {
    let u10 = n10.data.get(r10.dataId).values, l10 = n10.data.get(a10.dataId).values, c10 = Zy(u10, l10, a10.dtype, a10.shape, i10);
    return n10.makeTensorInfo([i10], a10.dtype, c10);
  } else if (r10.shape.length === 2) {
    let u10 = n10.bufferSync(r10), l10 = n10.bufferSync(a10), c10 = OS(u10, l10, i10, o10);
    return n10.makeTensorInfo(c10.shape, a10.dtype, c10.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r10.shape.length}.`);
}
var RH = { kernelName: dg, backendName: "cpu", kernelFunc: EH };
function DH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockSize: a10, dataFormat: i10 } = s10;
  w2.assert(i10 === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i10}`);
  let o10 = r10.shape[0], u10 = r10.shape[1], l10 = r10.shape[2], c10 = r10.shape[3], p10 = u10 * a10, d10 = l10 * a10, h10 = c10 / (a10 * a10), f10 = n10.data.get(r10.dataId).values, m10 = new Float32Array(o10 * p10 * d10 * h10), g10 = 0;
  for (let b10 = 0; b10 < o10; ++b10)
    for (let y10 = 0; y10 < p10; ++y10) {
      let v10 = Math.floor(y10 / a10), x10 = y10 % a10;
      for (let k10 = 0; k10 < d10; ++k10) {
        let C10 = Math.floor(k10 / a10), T10 = k10 % a10, E10 = (x10 * a10 + T10) * h10;
        for (let A10 = 0; A10 < h10; ++A10) {
          let R10 = A10 + E10 + c10 * (C10 + l10 * (v10 + u10 * b10));
          m10[g10++] = f10[R10];
        }
      }
    }
  return n10.makeTensorInfo([o10, p10, d10, h10], r10.dtype, m10);
}
var FH = { kernelName: co, backendName: "cpu", kernelFunc: DH };
function NC(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10, dimRoundingMode: l10 } = s10;
  ve2([r10, a10], "depthwiseConv2DNative");
  let c10 = w2.computeStrides(r10.shape), p10 = w2.computeStrides(a10.shape), d10 = u10;
  d10 == null && (d10 = [1, 1]), w2.assert(N2.eitherStridesOrDilationsAreOne(i10, d10), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i10} and dilations '${d10}'`);
  let h10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, d10, o10, l10, true), { filterHeight: f10, filterWidth: m10, dilationHeight: g10, dilationWidth: b10, padInfo: y10 } = h10, v10 = y10.left, x10 = y10.top, k10 = h10.outChannels / h10.inChannels, C10 = new Vt(h10.outShape, r10.dtype), T10 = n10.data.get(r10.dataId).values, E10 = n10.data.get(a10.dataId).values, A10 = C10.values;
  for (let P10 = 0; P10 < h10.batchSize; ++P10) {
    let R10 = P10 * c10[0], F10 = P10 * C10.strides[0];
    for (let $10 = 0; $10 < h10.outHeight; ++$10) {
      let z10 = F10 + $10 * C10.strides[1], W10 = $10 * h10.strideHeight - x10;
      for (let q10 = 0; q10 < f10; ++q10) {
        let K10 = W10 + q10 * g10;
        if (K10 < 0 || K10 >= h10.inHeight)
          continue;
        let Y10 = q10 * p10[0], Z10 = R10 + K10 * c10[1];
        for (let te2 = 0; te2 < h10.outWidth; ++te2) {
          let ee2 = z10 + te2 * C10.strides[2], se2 = te2 * h10.strideWidth - v10;
          for (let ne2 = 0; ne2 < m10; ++ne2) {
            let oe2 = se2 + ne2 * b10;
            if (oe2 < 0 || oe2 >= h10.inWidth)
              continue;
            let re2 = Y10 + ne2 * p10[1], le2 = Z10 + oe2 * h10.inChannels, me2 = ee2, we2 = re2;
            for (let Se2 = 0; Se2 < h10.inChannels; ++Se2) {
              let Ee2 = T10[le2 + Se2];
              for (let Pe2 = 0; Pe2 < k10; ++Pe2)
                A10[me2 + Pe2] += Ee2 * E10[we2 + Pe2];
              me2 += k10, we2 += k10;
            }
          }
        }
      }
    }
  }
  return n10.makeTensorInfo(C10.shape, C10.dtype, C10.values);
}
var OH = { kernelName: Aa, backendName: "cpu", kernelFunc: NC };
function PH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, dilations: o10, pad: u10, dimRoundingMode: l10, filterShape: c10 } = s10;
  ve2([r10, a10], "depthwiseConv2dNativeBackpropFilter");
  let p10 = N2.computeConv2DInfo(r10.shape, c10, i10, o10, u10, l10, true), { strideHeight: d10, strideWidth: h10, filterHeight: f10, filterWidth: m10 } = p10, g10 = new Vt(p10.filterShape, "float32"), b10 = p10.padInfo.left, y10 = p10.padInfo.top, v10 = p10.outChannels / p10.inChannels, x10 = n10.data.get(r10.dataId).values, k10 = new Vt(r10.shape, r10.dtype, x10), C10 = n10.data.get(a10.dataId).values, T10 = new Vt(a10.shape, a10.dtype, C10);
  for (let E10 = 0; E10 < f10; ++E10) {
    let A10 = Math.max(0, Math.ceil((y10 - E10) / d10)), P10 = Math.min(p10.outHeight, (p10.inHeight + y10 - E10) / d10);
    for (let R10 = 0; R10 < m10; ++R10) {
      let F10 = Math.max(0, Math.ceil((b10 - R10) / h10)), $10 = Math.min(p10.outWidth, (p10.inWidth + b10 - R10) / h10);
      for (let z10 = 0; z10 < p10.outChannels; ++z10) {
        let W10 = Math.trunc(z10 / v10), q10 = z10 % v10, K10 = 0;
        for (let Y10 = 0; Y10 < p10.batchSize; ++Y10)
          for (let Z10 = A10; Z10 < P10; ++Z10) {
            let te2 = E10 + Z10 * d10 - y10;
            for (let ee2 = F10; ee2 < $10; ++ee2) {
              let se2 = R10 + ee2 * h10 - b10;
              K10 += k10.get(Y10, te2, se2, W10) * T10.get(Y10, Z10, ee2, z10);
            }
          }
        g10.set(K10, E10, R10, W10, q10);
      }
    }
  }
  return n10.makeTensorInfo(g10.shape, g10.dtype, g10.values);
}
var zH = { kernelName: pg, backendName: "cpu", kernelFunc: PH };
function MH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { strides: i10, dilations: o10, pad: u10, dimRoundingMode: l10, inputShape: c10 } = s10;
  ve2([r10, a10], "depthwiseConv2DNativeBackpropInput");
  let p10 = w2.computeStrides(r10.shape), d10 = w2.computeStrides(a10.shape), h10 = N2.computeConv2DInfo(c10, a10.shape, i10, o10, u10, l10, true), f10 = new Vt(h10.inShape, "float32"), m10 = f10.values, [g10, b10, y10] = f10.strides, v10 = n10.data.get(r10.dataId).values, [x10, k10, C10] = p10, T10 = n10.data.get(a10.dataId).values, [E10, A10, P10] = d10, { batchSize: R10, filterHeight: F10, filterWidth: $10, inChannels: z10, inHeight: W10, inWidth: q10, outChannels: K10, outHeight: Y10, outWidth: Z10, strideHeight: te2, strideWidth: ee2 } = h10, se2 = F10 - 1 - h10.padInfo.top, ne2 = $10 - 1 - h10.padInfo.left, oe2 = K10 / z10;
  for (let re2 = 0; re2 < R10; ++re2)
    for (let le2 = 0; le2 < z10; ++le2)
      for (let me2 = 0; me2 < W10; ++me2) {
        let we2 = me2 - se2, Se2 = Math.max(0, Math.ceil(we2 / te2)), Ee2 = Math.min(Y10, (F10 + we2) / te2);
        for (let Pe2 = 0; Pe2 < q10; ++Pe2) {
          let Xe = Pe2 - ne2, Je = Math.max(0, Math.ceil(Xe / ee2)), Ye = Math.min(Z10, ($10 + Xe) / ee2), tt = 0;
          for (let Ce2 = Se2; Ce2 < Ee2; ++Ce2) {
            let ut = Ce2 * te2 - we2;
            for (let rt = Je; rt < Ye; ++rt) {
              let Zt = rt * ee2 - Xe, Nt = x10 * re2 + k10 * Ce2 + C10 * rt, In = E10 * (F10 - 1 - ut) + A10 * ($10 - 1 - Zt) + P10 * le2;
              for (let Et = 0; Et < oe2; ++Et) {
                let Jt = le2 * oe2 + Et, Sn = v10[Nt + Jt], Cn = T10[In + Et];
                tt += Sn * Cn;
              }
            }
          }
          m10[g10 * re2 + b10 * me2 + y10 * Pe2 + le2] = tt;
        }
      }
  return n10.makeTensorInfo(f10.shape, f10.dtype, f10.values);
}
var LH = { kernelName: hg, backendName: "cpu", kernelFunc: MH };
function BH(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t, r10 = w2.sizeFromShape(s10.shape), a10 = n10.data.get(s10.dataId).values, i10 = De([r10, r10], s10.dtype), o10 = i10.values;
  for (let l10 = 0; l10 < a10.length; l10++)
    o10[l10 * r10 + l10] = a10[l10];
  let u10 = [...s10.shape, ...s10.shape];
  return n10.makeTensorInfo(u10, i10.dtype, i10.values);
}
var VH = { kernelName: fg, backendName: "cpu", kernelFunc: BH };
var WH = { kernelName: Xd, backendName: "cpu", kernelFunc: ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10, filter: r10 } = e, { strides: a10, pad: i10, dilations: o10 } = n10, u10 = t, l10 = u10.data.get(s10.dataId).values, c10 = s10.shape.length, p10 = u10.data.get(r10.dataId).values, d10 = r10.shape.length, { batchSize: h10, inHeight: f10, inWidth: m10, inChannels: g10, outHeight: b10, outWidth: y10, padInfo: v10, strideHeight: x10, strideWidth: k10, filterHeight: C10, filterWidth: T10, dilationHeight: E10, dilationWidth: A10, outShape: P10 } = N2.computeDilation2DInfo(s10.shape, r10.shape, a10, i10, "NHWC", o10), R10 = w2.sizeFromShape(P10), F10 = P10.length, $10 = w2.getArrayFromDType(s10.dtype, R10);
  for (let W10 = 0; W10 < h10; ++W10)
    for (let q10 = 0; q10 < b10; ++q10) {
      let K10 = q10 * x10 - v10.top;
      for (let Y10 = 0; Y10 < y10; ++Y10) {
        let Z10 = Y10 * k10 - v10.left;
        for (let te2 = 0; te2 < g10; ++te2) {
          let ee2 = Number.MIN_SAFE_INTEGER;
          for (let ne2 = 0; ne2 < C10; ++ne2) {
            let oe2 = K10 + ne2 * E10;
            if (oe2 >= 0 && oe2 < f10)
              for (let re2 = 0; re2 < T10; ++re2) {
                let le2 = Z10 + re2 * A10;
                if (le2 >= 0 && le2 < m10) {
                  let me2 = w2.locToIndex([W10, oe2, le2, te2], c10, w2.computeStrides(s10.shape)), we2 = w2.locToIndex([ne2, re2, te2], d10, w2.computeStrides(r10.shape)), Se2 = l10[me2] + p10[we2];
                  Se2 > ee2 && (ee2 = Se2);
                }
              }
          }
          let se2 = w2.locToIndex([W10, q10, Y10, te2], F10, w2.computeStrides(P10));
          $10[se2] = ee2;
        }
      }
    }
  return { dataId: u10.write(w2.toTypedArray($10, s10.dtype), P10, s10.dtype), shape: P10, dtype: s10.dtype };
} };
var UH = { kernelName: Xf, backendName: "cpu", kernelFunc: ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10, filter: r10, dy: a10 } = e, { strides: i10, pad: o10, dilations: u10 } = n10, l10 = t, c10 = w2.toNestedArray(s10.shape, l10.data.get(s10.dataId).values), p10 = w2.toNestedArray(r10.shape, l10.data.get(r10.dataId).values), { batchSize: d10, inHeight: h10, inWidth: f10, inChannels: m10, outHeight: g10, outWidth: b10, padInfo: y10, strideHeight: v10, strideWidth: x10, filterHeight: k10, filterWidth: C10, dilationHeight: T10, dilationWidth: E10, outShape: A10 } = N2.computeDilation2DInfo(s10.shape, r10.shape, i10, o10, "NHWC", u10);
  w2.assert(a10.rank === A10.length, () => `Error in ${Xf}, dy must have the same rank as output ${A10.length}, but got ${a10.rank}`);
  let P10 = w2.toNestedArray(A10, l10.data.get(a10.dataId).values), R10 = w2.makeZerosNestedTypedArray(r10.shape, r10.dtype);
  for (let $10 = 0; $10 < d10; ++$10)
    for (let z10 = 0; z10 < g10; ++z10) {
      let W10 = z10 * v10 - y10.top;
      for (let q10 = 0; q10 < b10; ++q10) {
        let K10 = q10 * x10 - y10.left;
        for (let Y10 = 0; Y10 < m10; ++Y10) {
          let Z10 = Number.MIN_SAFE_INTEGER, te2 = 0, ee2 = 0;
          for (let se2 = 0; se2 < k10; ++se2) {
            let ne2 = W10 + se2 * T10;
            if (ne2 >= 0 && ne2 < h10)
              for (let oe2 = 0; oe2 < C10; ++oe2) {
                let re2 = K10 + oe2 * E10;
                if (re2 >= 0 && re2 < f10) {
                  let le2 = c10[$10][ne2][re2][Y10] + p10[se2][oe2][Y10];
                  le2 > Z10 && (Z10 = le2, te2 = se2, ee2 = oe2);
                }
              }
          }
          R10[te2][ee2][Y10] += P10[$10][z10][q10][Y10];
        }
      }
    }
  return { dataId: l10.write(w2.toTypedArray(R10, s10.dtype), r10.shape, r10.dtype), shape: r10.shape, dtype: r10.dtype };
} };
var GH = { kernelName: Kf, backendName: "cpu", kernelFunc: ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10, filter: r10, dy: a10 } = e, { strides: i10, pad: o10, dilations: u10 } = n10, l10 = t, c10 = w2.toNestedArray(s10.shape, l10.data.get(s10.dataId).values), p10 = w2.toNestedArray(r10.shape, l10.data.get(r10.dataId).values), { batchSize: d10, inHeight: h10, inWidth: f10, inChannels: m10, outHeight: g10, outWidth: b10, padInfo: y10, strideHeight: v10, strideWidth: x10, filterHeight: k10, filterWidth: C10, dilationHeight: T10, dilationWidth: E10, outShape: A10 } = N2.computeDilation2DInfo(s10.shape, r10.shape, i10, o10, "NHWC", u10);
  w2.assert(a10.rank === A10.length, () => `Error in ${Kf}, dy must have the same rank as output ${A10.length}, but got ${a10.rank}`);
  let P10 = w2.toNestedArray(A10, l10.data.get(a10.dataId).values), R10 = w2.makeZerosNestedTypedArray(s10.shape, s10.dtype);
  for (let $10 = 0; $10 < d10; ++$10)
    for (let z10 = 0; z10 < g10; ++z10) {
      let W10 = z10 * v10 - y10.top;
      for (let q10 = 0; q10 < b10; ++q10) {
        let K10 = q10 * x10 - y10.left;
        for (let Y10 = 0; Y10 < m10; ++Y10) {
          let Z10 = Number.MIN_SAFE_INTEGER, te2 = W10 < 0 ? 0 : W10, ee2 = K10 < 0 ? 0 : K10;
          for (let se2 = 0; se2 < k10; ++se2) {
            let ne2 = W10 + se2 * T10;
            if (ne2 >= 0 && ne2 < h10)
              for (let oe2 = 0; oe2 < C10; ++oe2) {
                let re2 = K10 + oe2 * E10;
                if (re2 >= 0 && re2 < f10) {
                  let le2 = c10[$10][ne2][re2][Y10] + p10[se2][oe2][Y10];
                  le2 > Z10 && (Z10 = le2, te2 = ne2, ee2 = re2);
                }
              }
          }
          R10[$10][te2][ee2][Y10] += P10[$10][z10][q10][Y10];
        }
      }
    }
  return { dataId: l10.write(w2.toTypedArray(R10, s10.dtype), s10.shape, s10.dtype), shape: s10.shape, dtype: s10.dtype };
} };
function Kl(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  ve2(r10, "sum");
  let o10;
  r10.dtype === "bool" ? o10 = xr({ inputs: { x: r10 }, backend: n10, attrs: { dtype: "int32" } }) : o10 = Os({ inputs: { x: r10 }, backend: n10 });
  let u10 = o10.shape.length, l10 = w2.parseAxisParam(a10, o10.shape), c10 = N2.getAxesPermutation(l10, u10), p10 = l10, d10 = o10;
  c10 != null && (d10 = Vn({ inputs: { x: o10 }, backend: n10, attrs: { perm: c10 } }), p10 = N2.getInnerMostAxes(p10.length, u10)), N2.assertAxesAreInnerMostDims("sum", p10, d10.shape.length);
  let [h10, f10] = N2.computeOutAndReduceShapes(d10.shape, p10), m10 = N2.upcastType(d10.dtype, "int32"), g10 = Rd(n10, h10, m10), b10 = w2.sizeFromShape(f10), y10 = n10.data.get(g10.dataId).values, v10 = n10.data.get(d10.dataId).values;
  for (let x10 = 0; x10 < y10.length; ++x10) {
    let k10 = x10 * b10, C10 = 0;
    for (let T10 = 0; T10 < b10; ++T10)
      C10 += v10[k10 + T10];
    y10[x10] = C10;
  }
  if (i10) {
    let x10 = N2.expandShapeToKeepDim(g10.shape, l10), k10 = g10;
    g10 = mt({ inputs: { x: g10 }, backend: n10, attrs: { shape: x10 } }), n10.disposeIntermediateTensorInfo(k10);
  }
  return n10.disposeIntermediateTensorInfo(o10), c10 != null && n10.disposeIntermediateTensorInfo(d10), g10;
}
var HH = { kernelName: ai, backendName: "cpu", kernelFunc: Kl };
function qH(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { equation: r10 } = s10, a10 = t, { allDims: i10, summedDims: o10, idDims: u10 } = N2.decodeEinsumEquation(r10, a10.length);
  N2.checkEinsumDimSizes(i10.length, u10, a10);
  let { path: l10, steps: c10 } = N2.getEinsumComputePath(o10, u10), p10 = c10.length, d10 = null, h10 = i10.length, f10 = [];
  for (let m10 = 0; m10 < p10; ++m10) {
    for (let g10 of c10[m10]) {
      let { permutationIndices: b10, expandDims: y10 } = N2.getEinsumPermutation(h10, u10[g10]), v10;
      N2.isIdentityPermutation(b10) ? v10 = a10[g10] : (v10 = Vn({ inputs: { x: a10[g10] }, backend: n10, attrs: { perm: b10 } }), f10.push(v10));
      let x10 = v10.shape.slice();
      for (let k10 = 0; k10 < y10.length; ++k10)
        x10.splice(y10[k10], 0, 1);
      w2.arraysEqual(v10.shape, x10) || (v10 = mt({ inputs: { x: v10 }, backend: n10, attrs: { shape: x10 } }), f10.push(v10)), d10 === null ? d10 = v10 : (d10 = Gp({ inputs: { a: v10, b: d10 }, backend: n10 }), f10.push(d10));
    }
    m10 < p10 - 1 && (l10[m10] >= 0 && (d10 = Kl({ inputs: { x: d10 }, backend: n10, attrs: { axis: l10[m10] - (i10.length - h10), keepDims: false } }), f10.push(d10)), h10--);
  }
  for (let m10 of f10)
    m10 !== d10 && n10.disposeIntermediateTensorInfo(m10);
  return d10;
}
var jH = { kernelName: Yd, backendName: "cpu", kernelFunc: qH };
function KH(e) {
  let { inputs: t, backend: n10 } = e, { dy: s10, y: r10 } = t;
  ve2([s10, r10], "eluGrad");
  let a10 = new Float32Array(w2.sizeFromShape(r10.shape)), i10 = n10.data.get(r10.dataId).values, o10 = n10.data.get(s10.dataId).values;
  for (let u10 = 0; u10 < i10.length; ++u10) {
    let l10 = i10[u10];
    l10 >= 1 ? a10[u10] = o10[u10] : a10[u10] = o10[u10] * (l10 + 1);
  }
  return n10.makeTensorInfo(r10.shape, "float32", a10);
}
var XH = { kernelName: mg, backendName: "cpu", kernelFunc: KH };
var YH = N2.ERF_P;
var QH = N2.ERF_A1;
var ZH = N2.ERF_A2;
var JH = N2.ERF_A3;
var e6 = N2.ERF_A4;
var t6 = N2.ERF_A5;
var n6 = st(pl, (e) => {
  let t = Math.sign(e), n10 = Math.abs(e), s10 = 1 / (1 + YH * n10);
  return t * (1 - ((((t6 * s10 + e6) * s10 + JH) * s10 + ZH) * s10 + QH) * s10 * Math.exp(-n10 * n10));
});
var s6 = { kernelName: pl, backendName: "cpu", kernelFunc: n6 };
function Fd(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { input: r10 } = t, { dim: a10 } = s10, i10 = r10.shape.length, o10 = r10.shape.slice(), u10 = a10;
  return a10 < 0 && (w2.assert(-(i10 + 1) <= a10, () => `Axis must be in the interval [${-(i10 + 1)}, ${i10}]`), u10 = i10 + a10 + 1), o10.splice(u10, 0, 1), mt({ inputs: { x: r10 }, backend: n10, attrs: { shape: o10 } });
}
var r6 = { kernelName: ho, backendName: "cpu", kernelFunc: Fd };
var a6 = At((e, t) => e / t);
var ov = Gt(Ea, a6);
var Pm = { kernelName: Ea, backendName: "cpu", kernelFunc: ov };
function TC(e, t, n10) {
  let s10 = e.shape, r10 = s10[0], a10 = s10[1], i10 = n10.data.get(e.dataId), o10 = i10.complexTensorInfos.real, u10 = i10.complexTensorInfos.imag, l10 = [r10, a10], c10 = w2.sizeFromShape(l10), p10 = w2.getTypedArrayFromDType("float32", c10), d10 = w2.getTypedArrayFromDType("float32", c10);
  for (let g10 = 0; g10 < r10; g10++) {
    let b10 = fa({ inputs: { x: o10 }, backend: n10, attrs: { begin: [g10, 0], size: [1, a10] } }), y10 = fa({ inputs: { x: u10 }, backend: n10, attrs: { begin: [g10, 0], size: [1, a10] } }), v10 = An({ inputs: { real: b10, imag: y10 }, backend: n10 }), { real: x10, imag: k10 } = i6(v10, t, n10), C10 = N2.mergeRealAndImagArrays(x10, k10);
    for (let T10 = 0; T10 < a10; T10++) {
      let E10 = N2.getComplexWithIndex(C10, T10);
      p10[g10 * a10 + T10] = E10.real, d10[g10 * a10 + T10] = E10.imag;
    }
    n10.disposeIntermediateTensorInfo(b10), n10.disposeIntermediateTensorInfo(y10), n10.disposeIntermediateTensorInfo(v10);
  }
  let h10 = n10.makeTensorInfo(l10, "float32", p10), f10 = n10.makeTensorInfo(l10, "float32", d10), m10 = An({ inputs: { real: h10, imag: f10 }, backend: n10 });
  return n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(f10), m10;
}
function i6(e, t, n10) {
  let s10 = w2.sizeFromShape(e.shape), r10 = n10.data.get(e.dataId), a10 = n10.data.get(r10.complexTensorInfos.real.dataId).values, i10 = n10.data.get(r10.complexTensorInfos.imag.dataId).values;
  if (o6(s10)) {
    let o10 = zm(a10, i10, s10, t, n10), u10 = [e.shape[0], e.shape[1]];
    if (t) {
      let l10 = n10.makeTensorInfo(u10, "float32", o10.real), c10 = n10.makeTensorInfo(u10, "float32", o10.imag), p10 = n10.makeTensorInfo([], "float32", w2.createScalarValue(s10, "float32")), d10 = Os({ inputs: { x: p10 }, backend: n10 }), h10 = Pm.kernelFunc({ inputs: { a: l10, b: p10 }, backend: n10 }), f10 = Pm.kernelFunc({ inputs: { a: c10, b: d10 }, backend: n10 }), m10 = n10.data.get(h10.dataId).values, g10 = n10.data.get(f10.dataId).values;
      return n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(c10), n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(f10), { real: m10, imag: g10 };
    }
    return o10;
  } else {
    let o10 = N2.mergeRealAndImagArrays(a10, i10), u10 = u6(o10, s10, t);
    return N2.splitRealAndImagArrays(u10);
  }
}
function o6(e) {
  return (e & e - 1) === 0;
}
function zm(e, t, n10, s10, r10) {
  if (n10 === 1)
    return { real: e, imag: t };
  let a10 = N2.mergeRealAndImagArrays(e, t), i10 = n10 / 2, o10 = N2.complexWithEvenIndex(a10), u10 = o10.real, l10 = o10.imag, c10 = [u10.length], p10 = r10.makeTensorInfo(c10, "float32", u10), d10 = r10.makeTensorInfo(c10, "float32", l10), h10 = An({ inputs: { real: p10, imag: d10 }, backend: r10 }), f10 = N2.complexWithOddIndex(a10), m10 = f10.real, g10 = f10.imag, b10 = [m10.length], y10 = r10.makeTensorInfo(b10, "float32", m10), v10 = r10.makeTensorInfo(b10, "float32", g10), x10 = An({ inputs: { real: y10, imag: v10 }, backend: r10 }), k10 = zm(u10, l10, i10, s10, r10), C10 = k10.real, T10 = k10.imag, E10 = [C10.length], A10 = r10.makeTensorInfo(E10, "float32", C10), P10 = r10.makeTensorInfo(E10, "float32", T10), R10 = An({ inputs: { real: A10, imag: P10 }, backend: r10 }), F10 = zm(m10, g10, i10, s10, r10), $10 = F10.real, z10 = F10.imag, W10 = [$10.length], q10 = r10.makeTensorInfo(W10, "float32", $10), K10 = r10.makeTensorInfo(W10, "float32", z10), Y10 = An({ inputs: { real: q10, imag: K10 }, backend: r10 }), Z10 = N2.exponents(n10, s10), te2 = [Z10.real.length], ee2 = r10.makeTensorInfo(te2, "float32", Z10.real), se2 = r10.makeTensorInfo(te2, "float32", Z10.imag), ne2 = An({ inputs: { real: ee2, imag: se2 }, backend: r10 }), oe2 = Gp({ inputs: { a: ne2, b: Y10 }, backend: r10 }), re2 = jl({ inputs: { a: R10, b: oe2 }, backend: r10 }), le2 = rv({ inputs: { a: R10, b: oe2 }, backend: r10 }), me2 = ha({ inputs: { input: re2 }, backend: r10 }), we2 = ha({ inputs: { input: le2 }, backend: r10 }), Se2 = eo({ inputs: { input: re2 }, backend: r10 }), Ee2 = eo({ inputs: { input: le2 }, backend: r10 }), Pe2 = to({ inputs: [me2, we2], backend: r10, attrs: { axis: 0 } }), Xe = to({ inputs: [Se2, Ee2], backend: r10, attrs: { axis: 0 } }), Je = r10.data.get(Pe2.dataId).values, Ye = r10.data.get(Xe.dataId).values;
  return r10.disposeIntermediateTensorInfo(p10), r10.disposeIntermediateTensorInfo(d10), r10.disposeIntermediateTensorInfo(h10), r10.disposeIntermediateTensorInfo(y10), r10.disposeIntermediateTensorInfo(v10), r10.disposeIntermediateTensorInfo(x10), r10.disposeIntermediateTensorInfo(A10), r10.disposeIntermediateTensorInfo(P10), r10.disposeIntermediateTensorInfo(R10), r10.disposeIntermediateTensorInfo(q10), r10.disposeIntermediateTensorInfo(K10), r10.disposeIntermediateTensorInfo(Y10), r10.disposeIntermediateTensorInfo(ee2), r10.disposeIntermediateTensorInfo(se2), r10.disposeIntermediateTensorInfo(ne2), r10.disposeIntermediateTensorInfo(oe2), r10.disposeIntermediateTensorInfo(re2), r10.disposeIntermediateTensorInfo(le2), r10.disposeIntermediateTensorInfo(me2), r10.disposeIntermediateTensorInfo(Se2), r10.disposeIntermediateTensorInfo(we2), r10.disposeIntermediateTensorInfo(Ee2), r10.disposeIntermediateTensorInfo(Pe2), r10.disposeIntermediateTensorInfo(Xe), { real: Je, imag: Ye };
}
function u6(e, t, n10) {
  let s10 = new Float32Array(t * 2);
  for (let r10 = 0; r10 < t; r10++) {
    let a10 = 0, i10 = 0;
    for (let o10 = 0; o10 < t; o10++) {
      let u10 = N2.exponent(r10 * o10, t, n10), l10 = N2.getComplexWithIndex(e, o10);
      a10 += l10.real * u10.real - l10.imag * u10.imag, i10 += l10.real * u10.imag + l10.imag * u10.real;
    }
    n10 && (a10 /= t, i10 /= t), N2.assignToTypedArray(s10, a10, i10, r10);
  }
  return s10;
}
function l6(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = w2.sizeFromShape(s10.shape), a10 = s10.shape[s10.shape.length - 1], i10 = r10 / a10, o10 = mt({ inputs: { x: s10 }, backend: n10, attrs: { shape: [i10, a10] } }), u10 = TC(o10, false, n10), l10 = mt({ inputs: { x: u10 }, backend: n10, attrs: { shape: s10.shape } });
  return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(u10), l10;
}
var c6 = { kernelName: gg, backendName: "cpu", kernelFunc: l6 };
function uv(e) {
  let { backend: t, attrs: n10 } = e, { shape: s10, value: r10, dtype: a10 } = n10, i10 = a10 || w2.inferDtype(r10), o10 = w2.getArrayFromDType(i10, w2.sizeFromShape(s10));
  return p6(o10, r10, i10), t.makeTensorInfo(s10, i10, o10);
}
var d6 = { kernelName: hl, backendName: "cpu", kernelFunc: uv };
function p6(e, t, n10) {
  e.fill(t);
}
var h6 = { kernelName: mo, backendName: "cpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { image: s10 } = e, r10 = n10, a10 = w2.getTypedArrayFromDType(s10.dtype, w2.sizeFromShape(s10.shape)), [i10, o10, u10, l10] = s10.shape, c10 = r10.data.get(s10.dataId).values;
  for (let d10 = 0; d10 < i10; d10++) {
    let h10 = d10 * u10 * o10 * l10;
    for (let f10 = 0; f10 < o10; f10++) {
      let m10 = f10 * (u10 * l10);
      for (let g10 = 0; g10 < u10; g10++) {
        let b10 = g10 * l10;
        for (let y10 = 0; y10 < l10; y10++) {
          let v10 = Math.round(u10 - g10 - 1), x10 = h10 + m10 + b10 + y10, k10 = c10[x10];
          if (v10 >= 0 && v10 < u10) {
            let C10 = v10 * l10, T10 = h10 + m10 + C10 + y10;
            k10 = c10[T10];
          }
          a10[x10] = k10;
        }
      }
    }
  }
  return { dataId: r10.write(a10, s10.shape, s10.dtype), shape: s10.shape, dtype: s10.dtype };
} };
var f6 = At((e, t) => Math.floor(e / t));
var m6 = Gt(Oa, f6, null, "int32");
var g6 = { kernelName: Oa, backendName: "cpu", kernelFunc: m6 };
function b6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = s10, m10 = CC({ inputs: { x: r10, filter: a10 }, backend: n10, attrs: { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10 } });
  if (i10) {
    let g10 = m10;
    m10 = jl({ inputs: { a: m10, b: i10 }, backend: n10 }), n10.disposeIntermediateTensorInfo(g10);
  }
  if (h10) {
    let g10 = m10;
    m10 = av(n10, m10, h10, o10, f10), n10.disposeIntermediateTensorInfo(g10);
  }
  return m10;
}
var y6 = { kernelName: sa, backendName: "cpu", kernelFunc: b6 };
function v6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = s10, m10 = NC({ inputs: { x: r10, filter: a10 }, backend: n10, attrs: { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10 } });
  if (i10) {
    let g10 = m10;
    m10 = jl({ inputs: { a: m10, b: i10 }, backend: n10 }), n10.disposeIntermediateTensorInfo(g10);
  }
  if (h10) {
    let g10 = m10;
    m10 = av(n10, m10, h10, o10, f10), n10.disposeIntermediateTensorInfo(g10);
  }
  return m10;
}
var x6 = { kernelName: ra, backendName: "cpu", kernelFunc: v6 };
function w6(e) {
  let { inputs: t, backend: n10 } = e, { params: s10, indices: r10 } = t, a10 = w2.sizeFromShape(s10.shape), i10 = r10.shape, o10 = i10[i10.length - 1], [u10, l10, c10, p10] = N2.prepareAndValidate(s10, r10);
  if (l10 === 0)
    return n10.makeTensorInfo(u10, s10.dtype, []);
  let d10 = n10.data.get(r10.dataId).values, h10 = n10.bufferSync(s10), f10 = US(d10, h10, s10.dtype, l10, o10, c10, p10, s10.shape, a10);
  return n10.makeTensorInfo(u10, s10.dtype, f10.values);
}
var k6 = { kernelName: bo, backendName: "cpu", kernelFunc: w6 };
function I6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, indices: a10 } = t, { axis: i10, batchDims: o10 } = s10;
  ve2([r10, a10], "gatherV2");
  let u10 = w2.parseAxisParam(i10, r10.shape)[0], l10 = n10.data.get(a10.dataId).values, c10 = r10.shape[u10];
  for (let x10 = 0; x10 < l10.length; ++x10) {
    let k10 = l10[x10];
    w2.assert(k10 <= c10 - 1 && k10 >= 0, () => `GatherV2: the index value ${k10} is not in [0, ${c10 - 1}]`);
  }
  let p10 = o10;
  o10 == null && (p10 = 0);
  let d10 = w2.sizeFromShape(a10.shape), h10 = N2.segment_util.collectGatherOpShapeInfo(r10, a10, u10, p10), f10 = mt({ inputs: { x: r10 }, backend: n10, attrs: { shape: [h10.batchSize, h10.outerSize, h10.dimSize, h10.sliceSize] } }), m10 = mt({ inputs: { x: a10 }, backend: n10, attrs: { shape: [h10.batchSize, d10 / h10.batchSize] } }), g10 = [h10.batchSize, h10.outerSize, d10 / h10.batchSize, h10.sliceSize], b10 = n10.bufferSync(m10), y10 = n10.bufferSync(f10), v10 = GS(y10, b10, g10);
  return n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(m10), n10.makeTensorInfo(h10.outputShape, v10.dtype, v10.values);
}
var S6 = { kernelName: go, backendName: "cpu", kernelFunc: I6 };
function C6(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = w2.sizeFromShape(s10.shape), a10 = s10.shape[s10.shape.length - 1], i10 = r10 / a10, o10 = mt({ inputs: { x: s10 }, backend: n10, attrs: { shape: [i10, a10] } }), u10 = TC(o10, true, n10), l10 = mt({ inputs: { x: u10 }, backend: n10, attrs: { shape: s10.shape } });
  return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(u10), l10;
}
var N6 = { kernelName: bg, backendName: "cpu", kernelFunc: C6 };
var T6 = st(fl, (e) => Number.isFinite(e) ? 1 : 0, "bool");
var $6 = { kernelName: fl, backendName: "cpu", kernelFunc: T6 };
var _6 = st(ml, (e) => Math.abs(e) === 1 / 0 ? 1 : 0, "bool");
var A6 = { kernelName: ml, backendName: "cpu", kernelFunc: _6 };
var E6 = st(gl, (e) => Number.isNaN(e) ? 1 : 0, "bool");
var R6 = { kernelName: gl, backendName: "cpu", kernelFunc: E6 };
function D6(e) {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, num: a10 } = n10, i10 = XS(s10, r10, a10);
  return t.makeTensorInfo([i10.length], "float32", i10);
}
var F6 = { kernelName: yg, backendName: "cpu", kernelFunc: D6 };
var O6 = st(bl, (e) => Math.log1p(e));
var P6 = { kernelName: bl, backendName: "cpu", kernelFunc: O6 };
var z6 = At((e, t) => e && t);
var M6 = Gt(wo, z6, null, "bool");
var L6 = { kernelName: wo, backendName: "cpu", kernelFunc: M6 };
var B6 = st(yl, (e) => e ? 0 : 1, "bool");
var V6 = { kernelName: yl, backendName: "cpu", kernelFunc: B6 };
var W6 = At((e, t) => e || t);
var U6 = Gt(Zd, W6, null, "bool");
var G6 = { kernelName: Zd, backendName: "cpu", kernelFunc: U6 };
function H6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { depthRadius: a10, bias: i10, alpha: o10, beta: u10 } = s10;
  ve2(r10, "LRN");
  let l10 = r10.shape[3], c10 = l10 - 1, p10 = n10.data.get(r10.dataId).values, d10 = w2.sizeFromShape(r10.shape), h10 = new Float32Array(d10);
  function f10(m10) {
    let g10 = m10 % l10, b10 = m10 - g10 + Math.max(0, g10 - a10), y10 = m10 - g10 + Math.min(g10 + a10, c10), v10 = 0;
    for (; b10 <= y10; b10++) {
      let x10 = p10[b10];
      v10 += x10 * x10;
    }
    return v10;
  }
  for (let m10 = 0; m10 < d10; m10++) {
    let g10 = f10(m10), b10 = p10[m10] * Math.pow(i10 + o10 * g10, -u10);
    h10[m10] = b10;
  }
  return n10.makeTensorInfo(r10.shape, r10.dtype, h10);
}
var q6 = { kernelName: Jd, backendName: "cpu", kernelFunc: H6 };
function j6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, y: a10, dy: i10 } = t, { depthRadius: o10, bias: u10, alpha: l10, beta: c10 } = s10;
  ve2(i10, "LRNGrad");
  let p10 = w2.sizeFromShape(i10.shape), d10 = i10.shape[3], h10 = n10.data.get(i10.dataId).values, f10 = n10.data.get(r10.dataId).values, m10 = n10.data.get(a10.dataId).values, g10 = new Float32Array(p10), b10 = p10;
  for (let y10 = 0; y10 < b10; y10++) {
    let v10 = y10 % d10, x10 = y10 - v10 + Math.max(0, v10 - o10), k10 = y10 - v10 + Math.min(d10, v10 + o10 + 1), C10 = 0;
    for (let T10 = x10; T10 < k10; T10++)
      C10 += Math.pow(f10[T10], 2);
    C10 = l10 * C10 + u10;
    for (let T10 = x10; T10 < k10; T10++) {
      let E10 = -2 * l10 * c10 * f10[T10] * m10[y10] / C10;
      y10 === T10 && (E10 += Math.pow(C10, -c10)), E10 *= h10[y10], g10[T10] += E10;
    }
  }
  return n10.makeTensorInfo(i10.shape, r10.dtype, g10);
}
var K6 = { kernelName: vg, backendName: "cpu", kernelFunc: j6 };
function $C(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reductionIndices: a10, keepDims: i10 } = s10, o10 = n10, u10 = r10.shape, l10 = u10.length, c10 = w2.parseAxisParam(a10, u10), p10 = c10, d10 = N2.getAxesPermutation(p10, l10), h10 = o10.data.get(r10.dataId).values;
  if (d10 != null) {
    let x10 = new Array(l10);
    for (let k10 = 0; k10 < x10.length; k10++)
      x10[k10] = u10[d10[k10]];
    h10 = tv(h10, u10, r10.dtype, d10, x10), p10 = N2.getInnerMostAxes(p10.length, l10), u10 = x10;
  }
  ve2(r10, "max"), N2.assertAxesAreInnerMostDims("max", p10, l10);
  let [f10, m10] = N2.computeOutAndReduceShapes(u10, p10), g10 = w2.sizeFromShape(m10), b10 = QS(h10, g10, f10, r10.dtype), y10 = o10.write(b10, f10, r10.dtype), v10 = f10;
  return i10 && (v10 = N2.expandShapeToKeepDim(f10, c10)), { dataId: y10, shape: v10, dtype: r10.dtype };
}
var X6 = { kernelName: Va, backendName: "cpu", kernelFunc: $C };
function Y6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t;
  ve2(r10, "maxPool");
  let { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1;
  w2.assert(N2.eitherStridesOrDilationsAreOne(i10, l10), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i10} and dilations '${l10}'`);
  let c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10), p10;
  if (c10.filterWidth === 1 && c10.filterHeight === 1 && w2.arraysEqual(c10.inShape, c10.outShape))
    p10 = Os({ inputs: { x: r10 }, backend: n10 });
  else {
    let d10 = n10.data.get(r10.dataId).values, h10 = w2.computeStrides(r10.shape), f10 = iv(d10, r10.shape, r10.dtype, h10, c10, "max");
    p10 = n10.makeTensorInfo(c10.outShape, r10.dtype, f10.values);
  }
  return p10;
}
var Q6 = { kernelName: Ua, backendName: "cpu", kernelFunc: Y6 };
function Z6(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10, dataFormat: l10 } = s10;
  ve2(r10, "maxPool3d");
  let c10 = N2.computePool3DInfo(r10.shape, a10, i10, 1, o10, u10, l10), p10 = n10.data.get(r10.dataId).values, d10 = SC(p10, r10.shape, r10.dtype, w2.computeStrides(r10.shape), c10, "max");
  return n10.makeTensorInfo(d10.shape, "float32", d10.values);
}
var J6 = { kernelName: ep, backendName: "cpu", kernelFunc: Z6 };
function eq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, { filterSize: i10, strides: o10, pad: u10, dimRoundingMode: l10 } = s10;
  ve2([r10, a10], "maxPool3DGrad");
  let c10 = N2.computePool3DInfo(a10.shape, i10, o10, 1, u10, l10), p10 = n10.bufferSync(a10), d10 = UG(p10, c10), h10 = c10.strideDepth, f10 = c10.strideHeight, m10 = c10.strideWidth, g10 = c10.dilationDepth, b10 = c10.dilationHeight, y10 = c10.dilationWidth, v10 = c10.effectiveFilterDepth, x10 = c10.effectiveFilterHeight, k10 = c10.effectiveFilterWidth, C10 = v10 - 1 - c10.padInfo.front, T10 = k10 - 1 - c10.padInfo.left, E10 = x10 - 1 - c10.padInfo.top, A10 = De(a10.shape, "float32"), P10 = n10.bufferSync(r10);
  for (let R10 = 0; R10 < c10.batchSize; ++R10)
    for (let F10 = 0; F10 < c10.inChannels; ++F10)
      for (let $10 = 0; $10 < c10.inDepth; ++$10)
        for (let z10 = 0; z10 < c10.inHeight; ++z10)
          for (let W10 = 0; W10 < c10.inWidth; ++W10) {
            let q10 = $10 - C10, K10 = z10 - E10, Y10 = W10 - T10, Z10 = 0;
            for (let te2 = 0; te2 < v10; te2 += g10) {
              let ee2 = (q10 + te2) / h10;
              if (!(ee2 < 0 || ee2 >= c10.outDepth || Math.floor(ee2) !== ee2))
                for (let se2 = 0; se2 < x10; se2 += b10) {
                  let ne2 = (K10 + se2) / f10;
                  if (!(ne2 < 0 || ne2 >= c10.outHeight || Math.floor(ne2) !== ne2))
                    for (let oe2 = 0; oe2 < k10; oe2 += y10) {
                      let re2 = (Y10 + oe2) / m10;
                      if (re2 < 0 || re2 >= c10.outWidth || Math.floor(re2) !== re2)
                        continue;
                      let le2 = v10 * x10 * k10 - 1 - d10.get(R10, ee2, ne2, re2, F10), me2 = te2 * x10 * k10 + se2 * k10 + oe2, we2 = le2 === me2 ? 1 : 0;
                      if (we2 === 0)
                        continue;
                      Z10 += P10.get(R10, ee2, ne2, re2, F10) * we2;
                    }
                }
            }
            A10.set(Z10, R10, $10, z10, W10, F10);
          }
  return n10.makeTensorInfo(A10.shape, A10.dtype, A10.values);
}
var tq = { kernelName: wg, backendName: "cpu", kernelFunc: eq };
function nq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10, output: i10 } = t, o10 = a10;
  ve2([a10, i10], "maxPoolGrad");
  let { filterSize: u10, strides: l10, pad: c10, dimRoundingMode: p10 } = s10, d10 = N2.computePool2DInfo(o10.shape, u10, l10, 1, c10, p10), h10 = n10.data.get(o10.dataId).values, f10 = De(d10.outShape, o10.dtype, IC(h10, o10.shape, o10.dtype, d10).values), m10 = d10.strideHeight, g10 = d10.strideWidth, b10 = d10.dilationHeight, y10 = d10.dilationWidth, v10 = d10.effectiveFilterHeight, x10 = d10.effectiveFilterWidth, k10 = x10 - 1 - d10.padInfo.left, C10 = v10 - 1 - d10.padInfo.top, T10 = De(o10.shape, "float32"), E10 = n10.data.get(r10.dataId).values, A10 = De(r10.shape, "float32", E10);
  for (let P10 = 0; P10 < d10.batchSize; ++P10)
    for (let R10 = 0; R10 < d10.inChannels; ++R10)
      for (let F10 = 0; F10 < d10.inHeight; ++F10)
        for (let $10 = 0; $10 < d10.inWidth; ++$10) {
          let z10 = F10 - C10, W10 = $10 - k10, q10 = 0;
          for (let K10 = 0; K10 < v10; K10 += b10) {
            let Y10 = (z10 + K10) / m10;
            if (!(Y10 < 0 || Y10 >= d10.outHeight || Math.floor(Y10) !== Y10))
              for (let Z10 = 0; Z10 < x10; Z10 += y10) {
                let te2 = (W10 + Z10) / g10;
                if (te2 < 0 || te2 >= d10.outWidth || Math.floor(te2) !== te2)
                  continue;
                let ee2 = v10 * x10 - 1 - f10.get(P10, Y10, te2, R10), se2 = K10 * x10 + Z10, ne2 = ee2 === se2 ? 1 : 0;
                if (ne2 === 0)
                  continue;
                q10 += A10.get(P10, Y10, te2, R10) * ne2;
              }
          }
          T10.set(q10, P10, F10, $10, R10);
        }
  return n10.makeTensorInfo(T10.shape, T10.dtype, T10.values);
}
var sq = { kernelName: xg, backendName: "cpu", kernelFunc: nq };
function rq(e, t, n10, s10, r10) {
  let a10 = w2.computeStrides(t), i10 = iv(e, t, n10, a10, r10, "max"), o10 = IC(e, t, n10, r10, true, s10);
  return [i10.values, o10.values];
}
var aq = { kernelName: kg, backendName: "cpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { x: s10 } = e, { filterSize: r10, strides: a10, pad: i10, includeBatchInIndex: o10 } = t, u10 = n10;
  ve2(s10, "MaxPoolWithArgmax");
  let l10 = u10.data.get(s10.dataId).values, c10 = N2.computePool2DInfo(s10.shape, r10, a10, [1, 1], i10), [p10, d10] = rq(l10, s10.shape, s10.dtype, o10, c10), h10 = u10.write(p10, c10.outShape, s10.dtype), f10 = u10.write(d10, c10.outShape, s10.dtype);
  return [{ dataId: h10, shape: c10.outShape, dtype: s10.dtype }, { dataId: f10, shape: c10.outShape, dtype: "int32" }];
} };
function iq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10, o10 = w2.parseAxisParam(a10, r10.shape), l10 = N2.computeOutAndReduceShapes(r10.shape, o10)[1], c10 = w2.sizeFromShape(l10), p10 = [], d10 = n10.makeTensorInfo([], "float32", new Float32Array([c10]));
  p10.push(d10);
  let h10 = xr({ inputs: { x: r10 }, backend: n10, attrs: { dtype: "float32" } });
  p10.push(h10);
  let f10 = ov({ inputs: { a: h10, b: d10 }, backend: n10 });
  p10.push(f10);
  let m10 = Kl({ inputs: { x: f10 }, backend: n10, attrs: { axis: a10, keepDims: i10 } });
  return p10.forEach((g10) => n10.disposeIntermediateTensorInfo(g10)), m10;
}
var oq = { kernelName: Ga, backendName: "cpu", kernelFunc: iq };
function uq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  ve2(r10, "min");
  let o10 = w2.parseAxisParam(a10, r10.shape), u10 = o10, l10 = N2.getAxesPermutation(u10, r10.shape.length), c10 = r10;
  l10 != null && (c10 = Vn({ inputs: { x: r10 }, backend: n10, attrs: { perm: l10 } }), u10 = N2.getInnerMostAxes(u10.length, r10.shape.length)), N2.assertAxesAreInnerMostDims("min", u10, c10.shape.length);
  let [p10, d10] = N2.computeOutAndReduceShapes(c10.shape, u10), h10 = w2.sizeFromShape(d10), f10 = w2.makeZerosTypedArray(w2.sizeFromShape(p10), c10.dtype), m10 = n10.data.get(c10.dataId).values;
  for (let b10 = 0; b10 < f10.length; ++b10) {
    let y10 = b10 * h10, v10 = m10[y10];
    for (let x10 = 0; x10 < h10; ++x10) {
      let k10 = m10[y10 + x10];
      (Number.isNaN(k10) || k10 < v10) && (v10 = k10);
    }
    f10[b10] = v10;
  }
  l10 != null && n10.disposeIntermediateTensorInfo(c10);
  let g10 = n10.makeTensorInfo(p10, c10.dtype, f10);
  if (i10) {
    let b10 = N2.expandShapeToKeepDim(p10, o10), y10 = mt({ inputs: { x: g10 }, backend: n10, attrs: { shape: b10 } });
    return n10.disposeIntermediateTensorInfo(g10), y10;
  }
  return g10;
}
var lq = { kernelName: Ha, backendName: "cpu", kernelFunc: uq };
function cq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { paddings: a10, mode: i10 } = s10;
  ve2(r10, "mirrorPad");
  let o10 = a10.map((v10, x10) => v10[0] + r10.shape[x10] + v10[1]), u10 = a10.map((v10) => v10[0]), l10 = a10.map((v10, x10) => v10[0] + r10.shape[x10]), c10 = i10 === "reflect" ? 0 : 1, p10 = n10.data.get(r10.dataId).values, d10 = r10.shape.length, h10 = w2.computeStrides(r10.shape), f10 = w2.sizeFromShape(o10), m10 = o10.length, g10 = w2.computeStrides(o10), b10 = w2.getTypedArrayFromDType(r10.dtype, f10);
  for (let v10 = 0; v10 < f10; v10++) {
    let x10 = w2.indexToLoc(v10, m10, g10);
    for (let C10 = 0; C10 < m10; C10++)
      x10[C10] < u10[C10] ? x10[C10] = u10[C10] * 2 - x10[C10] - c10 : x10[C10] >= l10[C10] && (x10[C10] = (l10[C10] - 1) * 2 - x10[C10] + c10);
    x10 = x10.map((C10, T10) => C10 - u10[T10]);
    let k10 = w2.locToIndex(x10, d10, h10);
    b10[v10] = p10[k10];
  }
  return { dataId: n10.write(b10, o10, r10.dtype), shape: o10, dtype: r10.dtype };
}
var dq = { kernelName: ja, backendName: "cpu", kernelFunc: cq };
var pq = At((e, t) => {
  let n10 = e % t;
  return e < 0 && t < 0 || e >= 0 && t >= 0 ? n10 : (n10 + t) % t;
});
var hq = Gt(vl, pq);
var fq = { kernelName: vl, backendName: "cpu", kernelFunc: hq };
var mq = ya(Vd());
function _C(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { logits: r10 } = t, { dim: a10 } = s10, i10 = r10.shape.length, o10 = a10;
  if (o10 === -1 && (o10 = i10 - 1), o10 !== i10 - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i10} and dim was ${o10}`);
  let u10 = w2.parseAxisParam([o10], r10.shape), l10 = $C({ inputs: { x: r10 }, backend: n10, attrs: { reductionIndices: u10, keepDims: false } }), c10 = N2.expandShapeToKeepDim(l10.shape, u10), p10 = mt({ inputs: { x: l10 }, backend: n10, attrs: { shape: c10 } }), d10 = rv({ inputs: { a: r10, b: p10 }, backend: n10 }), h10 = BS({ inputs: { x: d10 }, backend: n10 }), f10 = Kl({ inputs: { x: h10 }, backend: n10, attrs: { axis: u10, keepDims: false } }), m10 = mt({ inputs: { x: f10 }, backend: n10, attrs: { shape: c10 } }), g10 = ov({ inputs: { a: h10, b: m10 }, backend: n10 });
  return n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(m10), g10;
}
var gq = { kernelName: ii, backendName: "cpu", kernelFunc: _C };
function bq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { logits: r10 } = t, { numSamples: a10, seed: i10, normalized: o10 } = s10;
  ve2(r10, "multinomial");
  let u10 = o10 ? r10 : _C({ inputs: { logits: r10 }, backend: n10, attrs: { dim: -1 } }), l10 = u10.shape[0], c10 = u10.shape[1], p10 = n10.data.get(u10.dataId).values, d10 = [l10, a10], h10 = w2.makeZerosTypedArray(w2.sizeFromShape(d10), "int32");
  for (let f10 = 0; f10 < l10; ++f10) {
    let m10 = f10 * c10, g10 = new Float32Array(c10 - 1);
    g10[0] = p10[m10];
    for (let v10 = 1; v10 < g10.length; ++v10)
      g10[v10] = g10[v10 - 1] + p10[m10 + v10];
    let b10 = mq.alea(i10.toString()), y10 = f10 * a10;
    for (let v10 = 0; v10 < a10; ++v10) {
      let x10 = b10();
      h10[y10 + v10] = g10.length;
      for (let k10 = 0; k10 < g10.length; k10++)
        if (x10 < g10[k10]) {
          h10[y10 + v10] = k10;
          break;
        }
    }
  }
  return o10 || n10.disposeIntermediateTensorInfo(u10), n10.makeTensorInfo(d10, "int32", h10);
}
var yq = { kernelName: Ig, backendName: "cpu", kernelFunc: bq };
var vq = xs.nonMaxSuppressionV3Impl;
function xq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10 } = s10;
  ve2(r10, "NonMaxSuppression");
  let l10 = n10.data.get(r10.dataId).values, c10 = n10.data.get(a10.dataId).values, { selectedIndices: p10 } = vq(l10, c10, i10, o10, u10);
  return n10.makeTensorInfo([p10.length], "int32", new Int32Array(p10));
}
var wq = { kernelName: So, backendName: "cpu", kernelFunc: xq };
var kq = xs.nonMaxSuppressionV4Impl;
function Iq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10, padToMaxOutputSize: l10 } = s10;
  ve2(r10, "NonMaxSuppressionPadded");
  let c10 = n10.data.get(r10.dataId).values, p10 = n10.data.get(a10.dataId).values, { selectedIndices: d10, validOutputs: h10 } = kq(c10, p10, i10, o10, u10, l10);
  return [n10.makeTensorInfo([d10.length], "int32", new Int32Array(d10)), n10.makeTensorInfo([], "int32", new Int32Array([h10]))];
}
var Sq = { kernelName: xl, backendName: "cpu", kernelFunc: Iq };
var Cq = xs.nonMaxSuppressionV5Impl;
function Nq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10, softNmsSigma: l10 } = s10;
  ve2(r10, "NonMaxSuppressionWithScore");
  let c10 = n10.data.get(r10.dataId).values, p10 = n10.data.get(a10.dataId).values, d10 = i10, h10 = o10, f10 = u10, m10 = l10, { selectedIndices: g10, selectedScores: b10 } = Cq(c10, p10, d10, h10, f10, m10);
  return [n10.makeTensorInfo([g10.length], "int32", new Int32Array(g10)), n10.makeTensorInfo([b10.length], "float32", new Float32Array(b10))];
}
var Tq = { kernelName: Co, backendName: "cpu", kernelFunc: Nq };
function $q(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10 } = t, { depth: a10, onValue: i10, offValue: o10 } = s10;
  ve2(r10, "oneHot");
  let u10 = w2.sizeFromShape(r10.shape), l10 = new Float32Array(u10 * a10);
  l10.fill(o10);
  let c10 = n10.data.get(r10.dataId).values;
  for (let p10 = 0; p10 < u10; ++p10)
    c10[p10] >= 0 && c10[p10] < a10 && (l10[p10 * a10 + c10[p10]] = i10);
  return n10.makeTensorInfo([...r10.shape, a10], "int32", l10);
}
var _q2 = { kernelName: To, backendName: "cpu", kernelFunc: $q };
function Od(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "string")
    throw new Error("zerosLike is not supported for string tensors");
  if (s10.dtype === "complex64") {
    let r10 = ha({ inputs: { input: s10 }, backend: n10 }), a10 = Od({ inputs: { x: r10 }, backend: n10 }), i10 = eo({ inputs: { input: s10 }, backend: n10 }), o10 = Od({ inputs: { x: i10 }, backend: n10 }), u10 = An({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(r10), n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), u10;
  } else
    return uv({ backend: n10, attrs: { shape: s10.shape, value: 0, dtype: s10.dtype } });
}
var Aq = { kernelName: Go, backendName: "cpu", kernelFunc: Od };
function AC(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "string")
    throw new Error("onesLike is not supported for string tensors");
  if (s10.dtype === "complex64") {
    let r10 = ha({ inputs: { input: s10 }, backend: n10 }), a10 = AC({ inputs: { x: r10 }, backend: n10 }), i10 = eo({ inputs: { input: s10 }, backend: n10 }), o10 = Od({ inputs: { x: i10 }, backend: n10 }), u10 = An({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(r10), n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), u10;
  } else
    return uv({ backend: n10, attrs: { shape: s10.shape, value: 1, dtype: s10.dtype } });
}
var Eq = { kernelName: No, backendName: "cpu", kernelFunc: AC };
function EC(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10;
  if (t.length === 1)
    return Fd({ inputs: { input: t[0] }, backend: n10, attrs: { dim: r10 } });
  let a10 = t[0].shape, i10 = t[0].dtype;
  t.forEach((c10) => {
    w2.assertShapesMatch(a10, c10.shape, "All tensors passed to stack must have matching shapes"), w2.assert(i10 === c10.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o10 = [], u10 = t.map((c10) => {
    let p10 = Fd({ inputs: { input: c10 }, backend: n10, attrs: { dim: r10 } });
    return o10.push(p10), p10;
  }), l10 = to({ inputs: u10, backend: n10, attrs: { axis: r10 } });
  return o10.forEach((c10) => n10.disposeIntermediateTensorInfo(c10)), l10;
}
var Rq = { kernelName: $o, backendName: "cpu", kernelFunc: EC };
function Dq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { paddings: a10, constantValue: i10 } = s10;
  ve2(r10, "pad");
  let o10 = a10.map((y10, v10) => y10[0] + r10.shape[v10] + y10[1]), u10 = a10.map((y10) => y10[0]), l10 = n10.data.get(r10.dataId).values, c10 = w2.sizeFromShape(r10.shape), p10 = r10.shape.length, d10 = w2.computeStrides(r10.shape), h10 = w2.sizeFromShape(o10), f10 = o10.length, m10 = w2.computeStrides(o10), g10 = w2.getTypedArrayFromDType(r10.dtype, h10);
  i10 !== 0 && g10.fill(i10);
  for (let y10 = 0; y10 < c10; y10++) {
    let x10 = w2.indexToLoc(y10, p10, d10).map((C10, T10) => C10 + u10[T10]), k10 = w2.locToIndex(x10, f10, m10);
    g10[k10] = l10[y10];
  }
  return { dataId: n10.write(g10, o10, r10.dtype), shape: o10, dtype: r10.dtype };
}
var RC = { kernelName: Xa, backendName: "cpu", kernelFunc: Dq };
var Fq = At((e, t) => Math.pow(e, t));
var Oq = Gt(Ya, Fq);
var Pq = { kernelName: Ya, backendName: "cpu", kernelFunc: Oq };
function zq(e) {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, dtype: a10, step: i10 } = n10, o10 = nv(s10, r10, i10, a10);
  return t.makeTensorInfo([o10.length], a10, o10);
}
var Mq = { kernelName: wl, backendName: "cpu", kernelFunc: zq };
var Lq = st(kl, (e) => 1 / e);
var Bq = { kernelName: kl, backendName: "cpu", kernelFunc: Lq };
function Vq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10;
  ve2(r10, "resizeBilinear");
  let u10 = w2.computeStrides(r10.shape), [l10, c10] = o10, [p10, d10, h10, f10] = r10.shape, m10 = n10.data.get(r10.dataId).values, g10 = new Float32Array(w2.sizeFromShape([p10, l10, c10, f10])), b10 = [a10 && l10 > 1 ? d10 - 1 : d10, a10 && c10 > 1 ? h10 - 1 : h10], y10 = [a10 && l10 > 1 ? l10 - 1 : l10, a10 && c10 > 1 ? c10 - 1 : c10], v10 = 0, x10 = b10[0] / y10[0], k10 = b10[1] / y10[1];
  for (let C10 = 0; C10 < p10; C10++)
    for (let T10 = 0; T10 < l10; T10++) {
      let E10;
      i10 ? E10 = x10 * (T10 + 0.5) - 0.5 : E10 = x10 * T10;
      let A10 = Math.max(0, Math.floor(E10)), P10 = E10 - A10, R10 = Math.min(d10 - 1, Math.ceil(E10)), F10 = C10 * u10[0] + A10 * u10[1], $10 = C10 * u10[0] + R10 * u10[1];
      for (let z10 = 0; z10 < c10; z10++) {
        let W10;
        i10 ? W10 = k10 * (z10 + 0.5) - 0.5 : W10 = k10 * z10;
        let q10 = Math.max(0, Math.floor(W10)), K10 = W10 - q10, Y10 = Math.min(h10 - 1, Math.ceil(W10)), Z10 = F10 + q10 * u10[2], te2 = $10 + q10 * u10[2], ee2 = F10 + Y10 * u10[2], se2 = $10 + Y10 * u10[2];
        for (let ne2 = 0; ne2 < f10; ne2++) {
          let oe2 = m10[Z10 + ne2], re2 = m10[te2 + ne2], le2 = m10[ee2 + ne2], me2 = m10[se2 + ne2], we2 = oe2 + (le2 - oe2) * K10, Se2 = re2 + (me2 - re2) * K10, Ee2 = we2 + (Se2 - we2) * P10;
          g10[v10++] = Ee2;
        }
      }
    }
  return n10.makeTensorInfo([p10, l10, c10, f10], "float32", g10);
}
var Wq = { kernelName: Ja, backendName: "cpu", kernelFunc: Vq };
function Uq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10, dy: a10 } = t, { alignCorners: i10 } = s10;
  ve2([a10, r10], "resizeBilinearGrad");
  let o10 = w2.computeStrides(r10.shape), [u10, l10, c10, p10] = r10.shape, [, d10, h10] = a10.shape, f10 = new Float32Array(u10 * l10 * c10 * p10), m10 = [i10 && d10 > 1 ? l10 - 1 : l10, i10 && h10 > 1 ? c10 - 1 : c10], g10 = [i10 && d10 > 1 ? d10 - 1 : d10, i10 && h10 > 1 ? h10 - 1 : h10], b10 = m10[0] / g10[0], y10 = m10[1] / g10[1], v10 = n10.data.get(a10.dataId).values, x10 = 0;
  for (let k10 = 0; k10 < u10; k10++) {
    let C10 = k10 * o10[0];
    for (let T10 = 0; T10 < d10; T10++) {
      let E10 = T10 * b10, A10 = Math.floor(E10), P10 = Math.min(Math.ceil(E10), l10 - 1), R10 = C10 + A10 * o10[1], F10 = C10 + P10 * o10[1], $10 = E10 - A10, z10 = 1 - $10;
      for (let W10 = 0; W10 < h10; W10++) {
        let q10 = W10 * y10, K10 = Math.floor(q10), Y10 = Math.min(Math.ceil(q10), c10 - 1), Z10 = q10 - K10, te2 = 1 - Z10, ee2 = R10 + K10 * o10[2], se2 = R10 + Y10 * o10[2], ne2 = F10 + K10 * o10[2], oe2 = F10 + Y10 * o10[2], re2 = z10 * te2, le2 = z10 * Z10, me2 = $10 * te2, we2 = $10 * Z10;
        for (let Se2 = 0; Se2 < p10; Se2++) {
          let Ee2 = v10[x10++];
          f10[ee2 + Se2] += Ee2 * re2, f10[se2 + Se2] += Ee2 * le2, f10[ne2 + Se2] += Ee2 * me2, f10[oe2 + Se2] += Ee2 * we2;
        }
      }
    }
  }
  return n10.makeTensorInfo([u10, c10, l10, p10], "float32", f10);
}
var Gq = { kernelName: Cg, backendName: "cpu", kernelFunc: Uq };
function Hq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10;
  ve2(r10, "resizeNearestNeighbor");
  let u10 = w2.computeStrides(r10.shape), [l10, c10] = o10, [p10, d10, h10, f10] = r10.shape, m10 = n10.data.get(r10.dataId).values, g10 = new Float32Array(p10 * l10 * c10 * f10), b10 = [a10 && l10 > 1 ? d10 - 1 : d10, a10 && c10 > 1 ? h10 - 1 : h10], y10 = [a10 && l10 > 1 ? l10 - 1 : l10, a10 && c10 > 1 ? c10 - 1 : c10], v10 = b10[0] / y10[0], x10 = b10[1] / y10[1], k10 = 0;
  for (let C10 = 0; C10 < p10; C10++) {
    let T10 = C10 * u10[0];
    for (let E10 = 0; E10 < l10; E10++) {
      let A10 = i10 ? v10 * (E10 + 0.5) : v10 * E10, P10 = Math.min(d10 - 1, a10 ? Math.round(A10) : Math.floor(A10));
      i10 && (P10 = Math.max(0, P10));
      let R10 = T10 + P10 * u10[1];
      for (let F10 = 0; F10 < c10; F10++) {
        let $10 = i10 ? x10 * (F10 + 0.5) : x10 * F10, z10 = Math.min(h10 - 1, a10 ? Math.round($10) : Math.floor($10));
        i10 && (z10 = Math.max(0, z10));
        let W10 = R10 + z10 * u10[2];
        for (let q10 = 0; q10 < f10; q10++) {
          let K10 = m10[W10 + q10];
          g10[k10++] = K10;
        }
      }
    }
  }
  return n10.makeTensorInfo([p10, l10, c10, f10], r10.dtype, g10);
}
var qq = { kernelName: Il, backendName: "cpu", kernelFunc: Hq };
function jq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10, dy: a10 } = t, { alignCorners: i10 } = s10;
  ve2([a10, r10], "resizeNearestNeighborGrad");
  let o10 = w2.computeStrides(r10.shape), u10 = w2.computeStrides(a10.shape), [l10, c10, p10, d10] = r10.shape, [, h10, f10] = a10.shape, m10 = new Float32Array(l10 * c10 * p10 * d10), g10 = n10.data.get(a10.dataId).values, b10 = [i10 && h10 > 1 ? c10 - 1 : c10, i10 && f10 > 1 ? p10 - 1 : p10], y10 = [i10 && h10 > 1 ? h10 - 1 : h10, i10 && f10 > 1 ? f10 - 1 : f10], v10 = b10[0] / y10[0], x10 = b10[1] / y10[1], k10 = 1 / v10, C10 = 1 / x10, T10 = Math.ceil(k10) * 2 + 2, E10 = Math.ceil(C10) * 2 + 2;
  for (let A10 = 0; A10 < l10; A10++) {
    let P10 = A10 * o10[0];
    for (let R10 = 0; R10 < c10; R10++) {
      let F10 = P10 + R10 * o10[1], $10 = Math.floor(R10 * k10), z10 = Math.floor($10 - T10 / 2);
      for (let W10 = 0; W10 < p10; W10++) {
        let q10 = F10 + W10 * o10[2], K10 = Math.floor(W10 * C10), Y10 = Math.floor(K10 - E10 / 2);
        for (let Z10 = 0; Z10 < d10; Z10++) {
          let te2 = 0;
          for (let ee2 = 0; ee2 < T10; ee2++) {
            let se2 = ee2 + z10;
            if (se2 < 0 || se2 >= h10)
              continue;
            let ne2 = P10 + se2 * u10[1], oe2 = se2 * v10, re2 = Math.min(c10 - 1, i10 ? Math.round(oe2) : Math.floor(oe2));
            if (R10 === re2)
              for (let le2 = 0; le2 < E10; le2++) {
                let me2 = le2 + Y10;
                if (me2 < 0 || me2 >= f10)
                  continue;
                let we2 = ne2 + me2 * u10[2], Se2 = me2 * x10, Ee2 = Math.min(p10 - 1, i10 ? Math.round(Se2) : Math.floor(Se2));
                W10 === Ee2 && (te2 += g10[we2 + Z10]);
              }
          }
          m10[q10 + Z10] = te2;
        }
      }
    }
  }
  return n10.makeTensorInfo(r10.shape, r10.dtype, m10);
}
var Kq = { kernelName: Sg, backendName: "cpu", kernelFunc: jq };
function Xq(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dims: a10 } = s10;
  ve2(r10, "reverse");
  let i10 = r10.shape.length, o10 = w2.parseAxisParam(a10, r10.shape);
  if (i10 === 0)
    return Os({ inputs: { x: r10 }, backend: n10 });
  let u10 = new Vt(r10.shape, r10.dtype), l10 = n10.bufferSync(r10);
  for (let c10 = 0; c10 < u10.size; c10++) {
    let p10 = u10.indexToLoc(c10), d10 = p10.slice();
    o10.forEach((h10) => d10[h10] = r10.shape[h10] - 1 - d10[h10]), u10.set(l10.get(...d10), ...p10);
  }
  return n10.makeTensorInfo(u10.shape, u10.dtype, u10.values);
}
var Yq = { kernelName: Eo, backendName: "cpu", kernelFunc: Xq };
var Qq = { kernelName: Ho, backendName: "cpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { image: s10 } = e, { radians: r10, fillValue: a10, center: i10 } = t, o10 = n10, u10 = w2.getTypedArrayFromDType(s10.dtype, w2.sizeFromShape(s10.shape)), [l10, c10, p10, d10] = s10.shape, [h10, f10] = N2.getImageCenter(i10, c10, p10), m10 = 255, g10 = Math.sin(r10), b10 = Math.cos(r10), y10 = o10.data.get(s10.dataId).values;
  for (let x10 = 0; x10 < l10; x10++) {
    let k10 = x10 * p10 * c10 * d10;
    for (let C10 = 0; C10 < c10; C10++) {
      let T10 = C10 * (p10 * d10);
      for (let E10 = 0; E10 < p10; E10++) {
        let A10 = E10 * d10;
        for (let P10 = 0; P10 < d10; P10++) {
          let R10 = [l10, C10, E10, P10], F10 = R10[2], $10 = R10[1], z10 = (F10 - h10) * b10 - ($10 - f10) * g10, W10 = (F10 - h10) * g10 + ($10 - f10) * b10;
          z10 = Math.round(z10 + h10), W10 = Math.round(W10 + f10);
          let q10 = a10;
          if (typeof a10 != "number" && (P10 === 3 ? q10 = m10 : q10 = a10[P10]), z10 >= 0 && z10 < p10 && W10 >= 0 && W10 < c10) {
            let Y10 = W10 * (p10 * d10), Z10 = z10 * d10, te2 = k10 + Y10 + Z10 + P10;
            q10 = y10[te2];
          }
          let K10 = k10 + T10 + A10 + P10;
          u10[K10] = q10;
        }
      }
    }
  }
  return { dataId: o10.write(u10, s10.shape, s10.dtype), shape: s10.shape, dtype: s10.dtype };
} };
var Zq = st(Ro, (e) => {
  let t = Math.floor(e);
  return e - t < 0.5 ? Math.floor(e) : e - t > 0.5 ? Math.ceil(e) : t % 2 === 0 ? t : t + 1;
});
var Jq = { kernelName: Ro, backendName: "cpu", kernelFunc: Zq };
function DC(e, t, n10, s10, r10, a10, i10, o10, u10, l10) {
  let c10 = [s10 / r10, r10], p10 = e.values, d10 = t.values;
  if (s10 === 0)
    return De(n10, t.dtype);
  let h10 = De(c10, t.dtype);
  h10.values.fill(u10);
  for (let f10 = 0; f10 < a10; f10++) {
    let m10 = [], g10 = 0;
    for (let b10 = 0; b10 < i10; b10++) {
      let y10 = p10[f10 * i10 + b10];
      m10.push(y10), g10 += y10 * o10[b10];
    }
    if (g10 < 0 || g10 >= s10 / r10)
      throw new Error(`Invalid indices: ${m10} does not index into ${n10}`);
    for (let b10 = 0; b10 < r10; b10++)
      l10 ? h10.values[g10 * r10 + b10] += d10[f10 * r10 + b10] : h10.values[g10 * r10 + b10] = t.rank === 0 ? d10[0] : d10[f10 * r10 + b10];
  }
  return h10;
}
function ej(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10, updates: a10 } = t, { shape: i10 } = s10, { sliceRank: o10, numUpdates: u10, sliceSize: l10, strides: c10, outputSize: p10 } = N2.calculateShapes(a10, r10, i10), d10 = true, h10 = n10.bufferSync(r10), f10 = n10.bufferSync(a10), m10 = DC(h10, f10, i10, p10, l10, u10, o10, c10, 0, d10);
  return n10.makeTensorInfo(i10, m10.dtype, m10.values);
}
var tj = { kernelName: Do, backendName: "cpu", kernelFunc: ej };
function nj(e) {
  let { inputs: t, backend: n10 } = e, { condition: s10, t: r10, e: a10 } = t;
  ve2([s10, r10, a10], "select");
  let i10 = s10.shape.length, o10 = n10.data.get(s10.dataId).values, u10 = n10.data.get(r10.dataId).values, l10 = n10.data.get(a10.dataId).values, c10 = yn(r10.dtype, a10.dtype), p10 = w2.makeZerosTypedArray(w2.sizeFromShape(r10.shape), c10), d10 = 0, h10 = i10 === 0 || i10 > 1 || r10.shape.length === 1 ? 1 : w2.sizeFromShape(r10.shape.slice(1));
  for (let f10 = 0; f10 < o10.length; f10++)
    for (let m10 = 0; m10 < h10; m10++)
      o10[f10] === 1 ? p10[d10++] = u10[f10] : p10[d10++] = l10[f10];
  return n10.makeTensorInfo(r10.shape, c10, p10);
}
var sj = { kernelName: Fo, backendName: "cpu", kernelFunc: nj };
var rj = N2.SELU_SCALEALPHA;
var aj = N2.SELU_SCALE;
var ij = st(Sl, (e) => e >= 0 ? aj * e : rj * (Math.exp(e) - 1));
var oj = { kernelName: Sl, backendName: "cpu", kernelFunc: ij };
var uj = st(Cl, (e) => e < 0 ? -1 : e > 0 ? 1 : 0);
var lj = { kernelName: Cl, backendName: "cpu", kernelFunc: uj };
var cj = st(ni, (e) => Math.sin(e));
var dj = { kernelName: ni, backendName: "cpu", kernelFunc: cj };
var pj = st(Po, (e) => Math.sinh(e));
var hj = { kernelName: Po, backendName: "cpu", kernelFunc: pj };
var fj = 11920928955078125e-23;
var Jx = Math.log(fj) + 2;
var mj = st(Nl, (e) => {
  let t = e > -Jx, n10 = e < Jx, s10 = Math.exp(e), r10;
  return n10 ? r10 = s10 : t ? r10 = e : r10 = Math.log(1 + s10), r10;
});
var gj = { kernelName: Nl, backendName: "cpu", kernelFunc: mj };
function bj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, paddings: i10 } = s10;
  ve2([r10], "spaceToBatchND");
  let o10 = w2.sizeFromShape(a10), u10 = [[0, 0]];
  u10.push(...i10);
  for (let C10 = 1 + a10.length; C10 < r10.shape.length; ++C10)
    u10.push([0, 0]);
  let l10 = RC.kernelFunc({ inputs: { x: r10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), c10 = N2.getReshaped(l10.shape, a10, o10, false), p10 = N2.getPermuted(c10.length, a10.length, false), d10 = N2.getReshapedPermuted(l10.shape, a10, o10, false), m10 = mt({ inputs: { x: l10 }, backend: n10, attrs: { shape: c10 } }), y10 = Vn({ inputs: { x: m10 }, backend: n10, attrs: { perm: p10 } }), k10 = mt({ inputs: { x: y10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(y10), k10;
}
var yj = { kernelName: zo, backendName: "cpu", kernelFunc: bj };
function vj(e) {
  let { inputs: t, backend: n10 } = e, { indices: s10, values: r10, denseShape: a10, defaultValue: i10 } = t;
  if (a10.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
        ${a10.shape}`);
  if (s10.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
        ${s10.shape}`);
  if (r10.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
        ${r10.shape}`);
  if (i10.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${i10.shape}`);
  let o10 = n10.data.get(s10.dataId).values, u10 = n10.data.get(r10.dataId).values, l10 = n10.data.get(a10.dataId).values, c10 = n10.data.get(i10.dataId).values[0], [p10, d10, h10, f10, m10] = aC(o10, s10.shape, s10.dtype, u10, r10.dtype, l10, c10);
  return [n10.makeTensorInfo(d10, s10.dtype, p10), n10.makeTensorInfo([d10[0]], r10.dtype, h10), n10.makeTensorInfo([f10.length], "bool", new Uint8Array(f10.map((g10) => Number(g10)))), n10.makeTensorInfo([m10.length], s10.dtype, new Int32Array(m10))];
}
var xj = { kernelName: np, backendName: "cpu", kernelFunc: vj };
function wj(e) {
  let { inputs: t, backend: n10 } = e, { inputIndices: s10, inputShape: r10, newShape: a10 } = t;
  if (s10.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${s10.shape}`);
  if (r10.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${a10.shape}`);
  let i10 = Array.from(n10.data.get(r10.dataId).values), o10 = n10.data.get(s10.dataId).values, u10 = Array.from(n10.data.get(a10.dataId).values), [l10, c10, p10] = iC(o10, s10.shape, s10.dtype, i10, u10);
  return [n10.makeTensorInfo(c10, s10.dtype, l10), n10.makeTensorInfo([p10.length], a10.dtype, new Int32Array(p10))];
}
var kj = { kernelName: Tl, backendName: "cpu", kernelFunc: wj };
function Ij(e) {
  let { inputs: t, backend: n10 } = e, { data: s10, indices: r10, segmentIds: a10 } = t;
  if (s10.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
          ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
          ${a10.shape}`);
  if (r10.shape[0] !== a10.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  let i10 = n10.data.get(s10.dataId).values, o10 = n10.data.get(r10.dataId).values, u10 = n10.data.get(a10.dataId).values, [l10, c10] = sv(i10, s10.shape, s10.dtype, o10, u10, true);
  return n10.makeTensorInfo(c10, s10.dtype, l10);
}
var Sj = { kernelName: sp, backendName: "cpu", kernelFunc: Ij };
function Cj(e) {
  let { inputs: t, backend: n10 } = e, { data: s10, indices: r10, segmentIds: a10 } = t;
  if (s10.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
         ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
         ${a10.shape}`);
  if (r10.shape[0] !== a10.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  let i10 = n10.data.get(s10.dataId).values, o10 = n10.data.get(r10.dataId).values, u10 = n10.data.get(a10.dataId).values, [l10, c10] = sv(i10, s10.shape, s10.dtype, o10, u10);
  return n10.makeTensorInfo(c10, s10.dtype, l10);
}
var Nj = { kernelName: rp, backendName: "cpu", kernelFunc: Cj };
function Tj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { sparseIndices: r10, sparseValues: a10, defaultValue: i10 } = t, { outputShape: o10 } = s10, { sliceRank: u10, numUpdates: l10, sliceSize: c10, strides: p10, outputSize: d10 } = N2.calculateShapes(a10, r10, o10), h10 = false, f10 = n10.bufferSync(r10), m10 = n10.bufferSync(a10), g10 = n10.data.get(i10.dataId).values[0], b10 = DC(f10, m10, o10, d10, c10, l10, u10, p10, g10, h10);
  return n10.makeTensorInfo(o10, b10.dtype, b10.values);
}
var $j = { kernelName: ap, backendName: "cpu", kernelFunc: Tj };
function _j(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { numOrSizeSplits: a10, axis: i10 } = s10, o10 = w2.parseAxisParam(i10, r10.shape)[0], u10 = N2.prepareSplitSize(r10, a10, o10), l10 = new Array(r10.shape.length).fill(0), c10 = r10.shape.slice();
  return u10.map((p10) => {
    let d10 = [...c10];
    d10[o10] = p10;
    let h10 = fa({ inputs: { x: r10 }, backend: n10, attrs: { begin: l10, size: d10 } });
    return l10[o10] += p10, h10;
  });
}
var Aj = { kernelName: Mo, backendName: "cpu", kernelFunc: _j };
var Ej = { kernelName: $l, backendName: "cpu", kernelFunc: ({ inputs: e, backend: t }) => {
  let { x: n10 } = e, s10 = t;
  ve2(n10, "square");
  let r10 = s10.data.get(n10.dataId).values, a10 = new Float32Array(r10.length);
  for (let o10 = 0; o10 < r10.length; ++o10) {
    let u10 = r10[o10];
    a10[o10] = u10 * u10;
  }
  return { dataId: s10.write(a10, n10.shape, n10.dtype), shape: n10.shape, dtype: n10.dtype };
} };
var Rj = st(di, (e, t) => {
  let n10 = t;
  return isNaN(e) ? NaN : e > 0 ? 1 : n10.alpha;
});
var Dj = { kernelName: di, backendName: "cpu", kernelFunc: Rj };
function Fj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, end: i10, strides: o10, beginMask: u10, endMask: l10, ellipsisMask: c10, newAxisMask: p10, shrinkAxisMask: d10 } = s10;
  ve2(r10, "stridedSlice");
  let { finalShapeSparse: h10, finalShape: f10, isIdentity: m10, sliceDim0: g10, isSimpleSlice: b10, begin: y10, end: v10, strides: x10 } = wt.sliceInfo(r10.shape, a10, i10, o10, u10, l10, c10, p10, d10), k10;
  if (m10)
    k10 = mt({ inputs: { x: r10 }, backend: n10, attrs: { shape: f10 } });
  else if (g10 || b10) {
    w2.assert(r10.shape.length >= 1, () => `Input must have rank at least 1, got: ${r10.shape.length}`);
    let C10 = wt.computeOutShape(y10, v10, x10), T10 = fa({ inputs: { x: r10 }, backend: n10, attrs: { begin: y10, size: C10 } });
    k10 = mt({ inputs: { x: T10 }, backend: n10, attrs: { shape: f10 } }), n10.disposeIntermediateTensorInfo(T10);
  } else {
    let C10 = n10.bufferSync(r10), T10 = uC(h10, C10, x10, y10);
    k10 = n10.makeTensorInfo(f10, T10.dtype, T10.values);
  }
  return k10;
}
var Oj = { kernelName: Lo, backendName: "cpu", kernelFunc: Fj };
function Pj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { separator: r10, nGramWidths: a10, leftPad: i10, rightPad: o10, padWidth: u10, preserveShortSequences: l10 } = s10, { data: c10, dataSplits: p10 } = t, d10 = n10.data.get(c10.dataId).values, h10 = n10.data.get(p10.dataId).values, [f10, m10] = lC(d10, h10, r10, a10, i10, o10, u10, l10);
  return [n10.makeTensorInfo([f10.length], "string", f10), n10.makeTensorInfo(p10.shape, "int32", m10)];
}
var zj = { kernelName: ip, backendName: "cpu", kernelFunc: Pj };
function Mj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { skipEmpty: r10 } = s10, { input: a10, delimiter: i10 } = t;
  if (a10.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (a10.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${a10.shape}`);
  if (i10.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${i10.shape}`);
  let o10 = n10.data.get(a10.dataId).values, u10 = n10.data.get(i10.dataId).values[0], [l10, c10, p10] = cC(o10, u10, r10), d10 = c10.length;
  return [n10.makeTensorInfo([d10, 2], "int32", l10), n10.makeTensorInfo([d10], "string", c10), n10.makeTensorInfo([2], "int32", new Int32Array(p10))];
}
var Lj = { kernelName: Ng, backendName: "cpu", kernelFunc: Mj };
function Bj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { numBuckets: r10 } = s10, { input: a10 } = t;
  if (a10.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r10 <= 0)
    throw new Error("Number of buckets must be at least 1");
  let i10 = n10.data.get(a10.dataId).values, o10 = dC(i10, r10);
  return n10.makeTensorInfo(a10.shape, "int32", o10);
}
var Vj = { kernelName: Tg, backendName: "cpu", kernelFunc: Bj };
var Wj = st(Bo, (e) => Math.tan(e));
var Uj = { kernelName: Bo, backendName: "cpu", kernelFunc: Wj };
var Gj = st(li, (e) => Math.tanh(e));
var Hj = { kernelName: li, backendName: "cpu", kernelFunc: Gj };
function qj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reps: a10 } = s10;
  ve2(r10, "tile");
  let i10 = hC(n10.bufferSync(r10), a10);
  return n10.makeTensorInfo(i10.shape, i10.dtype, i10.values);
}
var jj = { kernelName: Sr, backendName: "cpu", kernelFunc: qj };
function Kj(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { k: a10, sorted: i10 } = s10;
  ve2(r10, "topk");
  let o10 = n10.data.get(r10.dataId).values, [u10, l10] = mC(o10, r10.shape, r10.dtype, a10, i10);
  return [n10.makeTensorInfo(u10.shape, u10.dtype, u10.values), n10.makeTensorInfo(l10.shape, l10.dtype, l10.values)];
}
var Xj = { kernelName: Vo, backendName: "cpu", kernelFunc: Kj };
function Yj(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { image: r10, transforms: a10 } = t, { interpolation: i10, fillMode: o10, fillValue: u10, outputShape: l10 } = n10, [c10, p10, d10, h10] = r10.shape, [f10, m10] = l10 != null ? l10 : [p10, d10], g10 = [c10, f10, m10, h10], b10 = w2.computeStrides(r10.shape), y10 = b10[0], v10 = b10[1], x10 = b10[2], k10 = w2.getTypedArrayFromDType(r10.dtype, w2.sizeFromShape(g10));
  k10.fill(u10);
  let C10 = s10.data.get(r10.dataId).values, T10 = s10.data.get(a10.dataId).values;
  for (let A10 = 0; A10 < c10; ++A10) {
    let P10 = a10.shape[0] === 1 ? T10 : T10.subarray(A10 * 8, A10 * 8 + 8);
    for (let R10 = 0; R10 < f10; ++R10)
      for (let F10 = 0; F10 < m10; ++F10)
        for (let $10 = 0; $10 < h10; ++$10) {
          let z10, W10 = P10[6] * F10 + P10[7] * R10 + 1;
          if (W10 === 0)
            continue;
          let q10 = (P10[0] * F10 + P10[1] * R10 + P10[2]) / W10, K10 = (P10[3] * F10 + P10[4] * R10 + P10[5]) / W10, Y10 = ew(q10, d10, o10), Z10 = ew(K10, p10, o10);
          switch (i10) {
            case "nearest":
              z10 = n5(C10, p10, d10, y10, v10, x10, A10, Z10, Y10, $10, u10);
              break;
            case "bilinear":
              z10 = s5(C10, p10, d10, y10, v10, x10, A10, Z10, Y10, $10, u10);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i10}`);
          }
          let te2 = A10 * y10 + R10 * v10 + F10 * x10 + $10;
          k10[te2] = z10;
        }
    return s10.makeTensorInfo(g10, r10.dtype, k10);
  }
  return { dataId: s10.write(k10, g10, r10.dtype), shape: r10.shape, dtype: r10.dtype };
}
var Qj = { kernelName: Wo, backendName: "cpu", kernelFunc: Yj };
function ew(e, t, n10) {
  switch (n10) {
    case "reflect":
      return Zj(e, t);
    case "wrap":
      return Jj(e, t);
    case "nearest":
      return t5(e, t);
    case "constant":
    default:
      return e5(e, t);
  }
}
function Zj(e, t) {
  let n10 = e;
  if (n10 < 0)
    if (t <= 1)
      n10 = 0;
    else {
      let s10 = 2 * t;
      n10 < s10 && (n10 = s10 * Math.trunc(-n10 / s10) + n10), n10 = n10 < -t ? n10 + s10 : -n10 - 1;
    }
  else if (n10 > t - 1)
    if (t <= 1)
      n10 = 0;
    else {
      let s10 = 2 * t;
      n10 -= s10 * Math.trunc(n10 / s10), n10 >= t && (n10 = s10 - n10 - 1);
    }
  return w2.clamp(0, n10, t - 1);
}
function Jj(e, t) {
  let n10 = e;
  if (n10 < 0)
    if (t <= 1)
      n10 = 0;
    else {
      let s10 = t - 1;
      n10 += t * (Math.trunc(-n10 / s10) + 1);
    }
  else if (n10 > t - 1)
    if (t <= 1)
      n10 = 0;
    else {
      let s10 = t - 1;
      n10 -= t * Math.trunc(n10 / s10);
    }
  return w2.clamp(0, n10, t - 1);
}
function e5(e, t) {
  return e;
}
function t5(e, t) {
  return w2.clamp(0, e, t - 1);
}
function Ru(e, t, n10, s10, r10, a10, i10, o10, u10, l10, c10) {
  let p10 = i10 * s10 + o10 * r10 + u10 * a10 + l10;
  return 0 <= o10 && o10 < t && 0 <= u10 && u10 < n10 ? e[p10] : c10;
}
function n5(e, t, n10, s10, r10, a10, i10, o10, u10, l10, c10) {
  let p10 = Math.round(o10), d10 = Math.round(u10);
  return Ru(e, t, n10, s10, r10, a10, i10, p10, d10, l10, c10);
}
function s5(e, t, n10, s10, r10, a10, i10, o10, u10, l10, c10) {
  let p10 = Math.floor(o10), d10 = Math.floor(u10), h10 = p10 + 1, f10 = d10 + 1, m10 = (f10 - u10) * Ru(e, t, n10, s10, r10, a10, i10, p10, d10, l10, c10) + (u10 - d10) * Ru(e, t, n10, s10, r10, a10, i10, p10, f10, l10, c10), g10 = (f10 - u10) * Ru(e, t, n10, s10, r10, a10, i10, h10, d10, l10, c10) + (u10 - d10) * Ru(e, t, n10, s10, r10, a10, i10, h10, f10, l10, c10);
  return (h10 - o10) * m10 + (o10 - p10) * g10;
}
function r5(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { axis: r10 } = n10, { x: a10 } = t;
  ve2(a10, "unique");
  let i10 = s10.data.get(a10.dataId).values, { outputValues: o10, outputShape: u10, indices: l10 } = gC(i10, r10, a10.shape, a10.dtype);
  return [s10.makeTensorInfo(u10, a10.dtype, o10), s10.makeTensorInfo([l10.length], "int32", l10)];
}
var a5 = { kernelName: $g, backendName: "cpu", kernelFunc: r5 };
function i5(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { value: r10 } = t, { axis: a10 } = s10;
  a10 < 0 && (a10 += r10.shape.length);
  let i10 = r10.shape.length, o10 = r10.shape[a10], u10 = new Array(i10 - 1), l10 = 0;
  for (let h10 = 0; h10 < i10; h10++)
    h10 !== a10 && (u10[l10++] = r10.shape[h10]);
  let c10 = new Array(i10).fill(0), p10 = r10.shape.slice();
  p10[a10] = 1;
  let d10 = new Array(o10);
  for (let h10 = 0; h10 < d10.length; h10++) {
    c10[a10] = h10;
    let f10 = fa({ inputs: { x: r10 }, backend: n10, attrs: { begin: c10, size: p10 } });
    d10[h10] = mt({ inputs: { x: f10 }, backend: n10, attrs: { shape: u10 } }), n10.disposeIntermediateTensorInfo(f10);
  }
  return d10;
}
var o5 = { kernelName: Uo, backendName: "cpu", kernelFunc: i5 };
function u5(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, segmentIds: a10 } = t, { numSegments: i10 } = s10;
  ve2(r10, "unsortedSegmentSum");
  let o10 = r10.shape.length, u10 = a10.shape.length, l10 = [], c10 = [], p10 = o10 - u10, d10 = a10;
  for (let f10 = 0; f10 < p10; ++f10) {
    let m10 = Fd({ inputs: { input: d10 }, backend: n10, attrs: { dim: f10 + 1 } });
    d10 = m10, c10.push(m10);
  }
  for (let f10 = 0; f10 < i10; ++f10) {
    let m10 = w2.createScalarValue(f10, "int32"), g10 = n10.makeTensorInfo([], "int32", m10), b10 = MS({ inputs: { a: g10, b: d10 }, backend: n10 }), y10 = xr({ inputs: { x: b10 }, backend: n10, attrs: { dtype: "float32" } }), v10 = Gp({ inputs: { a: y10, b: r10 }, backend: n10 }), x10 = Kl({ inputs: { x: v10 }, backend: n10, attrs: { axis: 0, keepDims: false } });
    l10.push(x10), c10.push(g10), c10.push(b10), c10.push(y10), c10.push(v10), c10.push(x10);
  }
  let h10 = EC({ inputs: l10, backend: n10, attrs: { axis: 0 } });
  return c10.forEach((f10) => n10.disposeIntermediateTensorInfo(f10)), h10;
}
var l5 = { kernelName: op, backendName: "cpu", kernelFunc: u5 };
var c5 = [bG, cU, vG, wG, gU, IG, CG, TG, _G, EG, DG, OG, zG, BG, WG, HG, jG, XG, QG, mG, JG, tH, sH, aH, fU, yU, oH, dU, lH, dH, pH, fH, gH, yH, xH, kH, SH, NH, $H, AH, RH, FH, OH, zH, LH, VH, WH, UH, GH, jH, uG, XH, vU, s6, xU, r6, kU, c6, d6, h6, SU, g6, y6, x6, k6, S6, NU, $U, pU, N6, cH, $6, A6, R6, lG, AU, RU, F6, FU, P6, L6, V6, G6, q6, K6, X6, PU, Q6, J6, tq, sq, aq, oq, lq, MU, dq, fq, yq, BU, WU, wq, Sq, Tq, GU, _q2, Eq, Rq, RC, Pq, dG, jU, Mq, hU, Pm, Bq, pG, hG, fG, Wq, Gq, qq, Kq, Yq, Qq, Jq, XU, tj, sj, oj, QU, lj, dj, hj, ZU, gq, gj, yj, xj, kj, Sj, Nj, $j, Aj, tG, Ej, sG, Dj, Oj, zj, Lj, Vj, oG, HH, Uj, Hj, jj, Xj, Qj, HU, a5, o5, l5, Aq];
for (let e of c5)
  _l(e);
var d5 = {};
Ae(d5, { assertNotComplex: () => tu, bindCanvasToFramebuffer: () => S5, bindColorTextureToFramebuffer: () => rd, bindTextureToProgramUniformSampler: () => KC, bindTextureUnit: () => HC, bindVertexBufferToProgramAttribute: () => Mm, callAndCheck: () => fe2, canBeRepresented: () => FC, createFragmentShader: () => zC, createFramebuffer: () => GC, createProgram: () => MC, createStaticIndexBuffer: () => VC, createStaticVertexBuffer: () => BC, createTexture: () => WC, createVertexShader: () => PC, getBatchDim: () => ma, getExtensionOrThrow: () => Du, getFramebufferErrorMessage: () => XC, getMaxTexturesInShader: () => JC, getNumChannels: () => k5, getProgramUniformLocation: () => jC, getProgramUniformLocationOrThrow: () => qC, getRowsCols: () => ga, getShapeAs3D: () => ad, getTextureShapeFromLogicalShape: () => QC, getWebGLDisjointQueryTimerVersion: () => e1, getWebGLErrorMessage: () => OC, getWebGLMaxTextureSize: () => ZC, hasExtension: () => Mn, isCapableOfRenderingToFloatTexture: () => t1, isDownloadFloatTextureEnabled: () => n1, isReshapeFree: () => Ju, isWebGLFenceEnabled: () => s1, isWebGLVersionEnabled: () => Bm, linkProgram: () => LC, resetMaxTextureSize: () => C5, resetMaxTexturesInShader: () => N5, unbindColorTextureFromFramebuffer: () => Lm, unbindTextureUnit: () => I5, validateFramebuffer: () => Fu, validateProgram: () => sd, validateTextureSize: () => UC });
var jr = {};
var Hf = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
function p5(e, t) {
  jr[e] = t;
}
function vs(e, t) {
  if (!(e in jr) || t != null) {
    let s10 = f5(e, t);
    if (s10 !== null)
      jr[e] = s10;
    else
      return console.log("Could not get context for WebGL version", e), null;
  }
  let n10 = jr[e];
  return n10 == null || n10.isContextLost() ? (delete jr[e], vs(e)) : (n10.disable(n10.DEPTH_TEST), n10.disable(n10.STENCIL_TEST), n10.disable(n10.BLEND), n10.disable(n10.DITHER), n10.disable(n10.POLYGON_OFFSET_FILL), n10.disable(n10.SAMPLE_COVERAGE), n10.enable(n10.SCISSOR_TEST), n10.enable(n10.CULL_FACE), n10.cullFace(n10.BACK), jr[e]);
}
function h5(e) {
  if (typeof OffscreenCanvas != "undefined" && e === 2)
    return new OffscreenCanvas(300, 150);
  if (typeof document != "undefined")
    return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function f5(e, t) {
  if (e !== 1 && e !== 2)
    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  let n10 = t == null ? h5(e) : t;
  return n10.addEventListener("webglcontextlost", (s10) => {
    s10.preventDefault(), delete jr[e];
  }, false), e === 1 ? n10.getContext("webgl", Hf) || n10.getContext("experimental-webgl", Hf) : n10.getContext("webgl2", Hf);
}
function Xl(e, t) {
  return [t, e];
}
function m5(e, t) {
  return e * t;
}
function Xc(e) {
  let t = w2.sizeFromShape(e), n10 = Math.ceil(t / 4);
  return w2.sizeToSquarishShape(n10);
}
function eu(e, t) {
  return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
}
function g5(e, t) {
  let [n10, s10] = eu(e, t);
  return n10 * s10 * 4;
}
function lv(e, t) {
  let n10 = e, s10, r10, a10, i10, o10, u10, l10, c10, p10, d10;
  return X2().getNumber("WEBGL_VERSION") === 2 ? (s10 = n10.R32F, r10 = n10.R16F, a10 = n10.RGBA16F, i10 = n10.RGBA32F, o10 = n10.RED, l10 = 4, c10 = 1, p10 = n10.HALF_FLOAT, d10 = n10.FLOAT, u10 = n10.RGBA8) : (s10 = e.RGBA, r10 = e.RGBA, a10 = e.RGBA, i10 = n10.RGBA, o10 = e.RGBA, l10 = 4, c10 = 4, p10 = t != null ? t.HALF_FLOAT_OES : null, d10 = e.FLOAT, u10 = e.RGBA), { internalFormatFloat: s10, internalFormatHalfFloat: r10, internalFormatPackedHalfFloat: a10, internalFormatPackedFloat: i10, textureFormatFloat: o10, downloadTextureFormat: u10, downloadUnpackNumChannels: l10, defaultNumChannels: c10, textureTypeHalfFloat: p10, textureTypeFloat: d10 };
}
function fe2(e, t) {
  let n10 = t();
  return X2().getBool("DEBUG") && b5(e), n10;
}
function b5(e) {
  let t = e.getError();
  if (t !== e.NO_ERROR)
    throw new Error("WebGL Error: " + OC(e, t));
}
var y5 = 596e-10;
var v5 = 65504;
function FC(e) {
  return !!(X2().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || e === 0 || y5 < Math.abs(e) && Math.abs(e) < v5);
}
function OC(e, t) {
  switch (t) {
    case e.NO_ERROR:
      return "NO_ERROR";
    case e.INVALID_ENUM:
      return "INVALID_ENUM";
    case e.INVALID_VALUE:
      return "INVALID_VALUE";
    case e.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case e.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case e.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case e.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return `Unknown error code ${t}`;
  }
}
function Du(e, t) {
  return Qs(e, () => e.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
}
function PC(e, t) {
  let n10 = Qs(e, () => e.createShader(e.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  if (fe2(e, () => e.shaderSource(n10, t)), fe2(e, () => e.compileShader(n10)), e.getShaderParameter(n10, e.COMPILE_STATUS) === false)
    throw console.log(e.getShaderInfoLog(n10)), new Error("Failed to compile vertex shader.");
  return n10;
}
function zC(e, t) {
  let n10 = Qs(e, () => e.createShader(e.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  if (fe2(e, () => e.shaderSource(n10, t)), fe2(e, () => e.compileShader(n10)), e.getShaderParameter(n10, e.COMPILE_STATUS) === false)
    throw w5(t, e.getShaderInfoLog(n10)), new Error("Failed to compile fragment shader.");
  return n10;
}
var x5 = /ERROR: [0-9]+:([0-9]+):/g;
function w5(e, t) {
  let n10 = x5.exec(t);
  if (n10 == null) {
    console.log(`Couldn't parse line number in error: ${t}`), console.log(e);
    return;
  }
  let s10 = +n10[1], r10 = e.split(`
`), a10 = r10.length.toString().length + 2, i10 = r10.map((p10, d10) => w2.rightPad((d10 + 1).toString(), a10) + p10), o10 = 0;
  for (let p10 = 0; p10 < i10.length; p10++)
    o10 = Math.max(i10[p10].length, o10);
  let u10 = i10.slice(0, s10 - 1), l10 = i10.slice(s10 - 1, s10), c10 = i10.slice(s10);
  console.log(u10.join(`
`)), console.log(t.split(`
`)[0]), console.log(`%c ${w2.rightPad(l10[0], o10)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c10.join(`
`));
}
function MC(e) {
  return Qs(e, () => e.createProgram(), "Unable to create WebGLProgram.");
}
function LC(e, t) {
  if (fe2(e, () => e.linkProgram(t)), e.getProgramParameter(t, e.LINK_STATUS) === false)
    throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
}
function sd(e, t) {
  if (fe2(e, () => e.validateProgram(t)), e.getProgramParameter(t, e.VALIDATE_STATUS) === false)
    throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}
function BC(e, t) {
  let n10 = Qs(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
  return fe2(e, () => e.bindBuffer(e.ARRAY_BUFFER, n10)), fe2(e, () => e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)), n10;
}
function VC(e, t) {
  let n10 = Qs(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
  return fe2(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n10)), fe2(e, () => e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)), n10;
}
function k5() {
  return X2().getNumber("WEBGL_VERSION") === 2 ? 1 : 4;
}
function WC(e) {
  return Qs(e, () => e.createTexture(), "Unable to create WebGLTexture.");
}
function UC(e, t) {
  let n10 = X2().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e <= 0 || t <= 0) {
    let s10 = `[${e}x${t}]`;
    throw new Error("Requested texture size " + s10 + " is invalid.");
  }
  if (e > n10 || t > n10) {
    let s10 = `[${e}x${t}]`, r10 = `[${n10}x${n10}]`;
    throw new Error("Requested texture size " + s10 + " greater than WebGL maximum on this browser / GPU " + r10 + ".");
  }
}
function GC(e) {
  return Qs(e, () => e.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function Mm(e, t, n10, s10, r10, a10, i10) {
  let o10 = e.getAttribLocation(t, n10);
  return o10 === -1 ? false : (fe2(e, () => e.bindBuffer(e.ARRAY_BUFFER, s10)), fe2(e, () => e.vertexAttribPointer(o10, r10, e.FLOAT, false, a10, i10)), fe2(e, () => e.enableVertexAttribArray(o10)), true);
}
function HC(e, t, n10) {
  YC(e, n10), fe2(e, () => e.activeTexture(e.TEXTURE0 + n10)), fe2(e, () => e.bindTexture(e.TEXTURE_2D, t));
}
function I5(e, t) {
  YC(e, t), fe2(e, () => e.activeTexture(e.TEXTURE0 + t)), fe2(e, () => e.bindTexture(e.TEXTURE_2D, null));
}
function qC(e, t, n10) {
  return Qs(e, () => e.getUniformLocation(t, n10), 'uniform "' + n10 + '" not present in program.');
}
function jC(e, t, n10) {
  return e.getUniformLocation(t, n10);
}
function KC(e, t, n10, s10) {
  fe2(e, () => HC(e, t, s10)), fe2(e, () => e.uniform1i(n10, s10));
}
function S5(e) {
  fe2(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), fe2(e, () => e.viewport(0, 0, e.canvas.width, e.canvas.height)), fe2(e, () => e.scissor(0, 0, e.canvas.width, e.canvas.height));
}
function rd(e, t, n10) {
  fe2(e, () => e.bindFramebuffer(e.FRAMEBUFFER, n10)), fe2(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0));
}
function Lm(e, t) {
  fe2(e, () => e.bindFramebuffer(e.FRAMEBUFFER, t)), fe2(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0));
}
function Fu(e) {
  let t = e.checkFramebufferStatus(e.FRAMEBUFFER);
  if (t !== e.FRAMEBUFFER_COMPLETE)
    throw new Error("Error binding framebuffer: " + XC(e, t));
}
function XC(e, t) {
  switch (t) {
    case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case e.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return `unknown error ${t}`;
  }
}
function Qs(e, t, n10) {
  let s10 = fe2(e, () => t());
  if (s10 == null)
    throw new Error(n10);
  return s10;
}
function YC(e, t) {
  let n10 = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, s10 = t + e.TEXTURE0;
  if (s10 < e.TEXTURE0 || s10 > n10) {
    let r10 = `[gl.TEXTURE0, gl.TEXTURE${n10}]`;
    throw new Error(`textureUnit must be in ${r10}.`);
  }
}
function ma(e, t = 2) {
  return w2.sizeFromShape(e.slice(0, e.length - t));
}
function ga(e) {
  if (e.length === 0)
    throw Error("Cannot get rows and columns of an empty shape array.");
  return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
}
function ad(e) {
  let t = [1, 1, 1];
  return e.length === 0 || e.length === 1 && e[0] === 1 || (t = [ma(e), ...ga(e)]), t;
}
function QC(e, t = false) {
  let n10 = X2().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  t && (n10 = n10 * 2, e = e.map((r10, a10) => a10 >= e.length - 2 ? w2.nearestLargerEven(e[a10]) : e[a10]), e.length === 1 && (e = [2, e[0]])), e.length !== 2 && (e = w2.squeezeShape(e).newShape);
  let s10 = w2.sizeFromShape(e);
  if (e.length <= 1 && s10 <= n10)
    return [1, s10];
  if (e.length === 2 && e[0] <= n10 && e[1] <= n10)
    return e;
  if (e.length === 3 && e[0] * e[1] <= n10 && e[2] <= n10)
    return [e[0] * e[1], e[2]];
  if (e.length === 3 && e[0] <= n10 && e[1] * e[2] <= n10)
    return [e[0], e[1] * e[2]];
  if (e.length === 4 && e[0] * e[1] * e[2] <= n10 && e[3] <= n10)
    return [e[0] * e[1] * e[2], e[3]];
  if (e.length === 4 && e[0] <= n10 && e[1] * e[2] * e[3] <= n10)
    return [e[0], e[1] * e[2] * e[3]];
  if (t) {
    let r10 = ma(e), a10 = 2, i10 = 2;
    return e.length && ([a10, i10] = ga(e)), s10 = r10 * (a10 / 2) * (i10 / 2), w2.sizeToSquarishShape(s10).map((o10) => o10 * 2);
  }
  return w2.sizeToSquarishShape(s10);
}
function Yc(e) {
  return e % 2 === 0;
}
function Ju(e, t) {
  if (e = e.slice(-2), t = t.slice(-2), w2.arraysEqual(e, t) || !e.length || !t.length || e[0] === 0 || e[1] === 0 || t[0] === 0 || t[1] === 0)
    return true;
  if (e.length !== t.length) {
    let n10 = e.slice(-1)[0], s10 = t.slice(-1)[0];
    if (n10 === s10 || Yc(n10) && Yc(s10) && (e[0] === 1 || t[0] === 1))
      return true;
  }
  return e[1] === t[1] && Yc(e[0]) && Yc(t[0]);
}
var id;
var od;
function ZC(e) {
  if (id == null) {
    let t = vs(e);
    id = t.getParameter(t.MAX_TEXTURE_SIZE);
  }
  return id;
}
function C5() {
  id = null;
}
function N5() {
  od = null;
}
function JC(e) {
  if (od == null) {
    let t = vs(e);
    od = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, od);
}
function e1(e) {
  if (e === 0)
    return 0;
  let t, n10 = vs(e);
  return Mn(n10, "EXT_disjoint_timer_query_webgl2") && e === 2 ? t = 2 : Mn(n10, "EXT_disjoint_timer_query") ? t = 1 : t = 0, t;
}
function Mn(e, t) {
  return e.getExtension(t) != null;
}
function Bm(e) {
  try {
    if (vs(e) != null)
      return true;
  } catch (t) {
    return console.log("Error when getting WebGL context: ", t), false;
  }
  return false;
}
function t1(e) {
  if (e === 0)
    return false;
  let t = vs(e);
  if (e === 1) {
    if (!Mn(t, "OES_texture_float"))
      return false;
  } else if (!Mn(t, "EXT_color_buffer_float"))
    return false;
  return Vm(t);
}
function n1(e) {
  if (e === 0)
    return false;
  let t = vs(e);
  if (e === 1) {
    if (!Mn(t, "OES_texture_float") || !Mn(t, "WEBGL_color_buffer_float"))
      return false;
  } else {
    if (Mn(t, "EXT_color_buffer_float"))
      return Vm(t);
    let s10 = "EXT_color_buffer_half_float";
    if (Mn(t, s10)) {
      let r10 = t.getExtension(s10);
      return T5(t, r10);
    }
    return false;
  }
  return Vm(t);
}
function Vm(e) {
  let t = lv(e), n10 = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, n10);
  let s10 = 1, r10 = 1;
  e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, s10, r10, 0, t.textureFormatFloat, t.textureTypeFloat, null);
  let a10 = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, a10), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n10, 0);
  let i10 = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n10), e.deleteFramebuffer(a10), i10;
}
function T5(e, t) {
  let n10 = lv(e, t), s10 = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, s10);
  let r10 = 1, a10 = 1;
  e.texImage2D(e.TEXTURE_2D, 0, n10.internalFormatHalfFloat, r10, a10, 0, n10.textureFormatFloat, n10.textureTypeHalfFloat, null);
  let i10 = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, i10), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, s10, 0);
  let o10 = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(s10), e.deleteFramebuffer(i10), o10;
}
function s1(e) {
  return e !== 2 ? false : vs(e).fenceSync != null;
}
function tu(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach((n10) => {
    n10 != null && w2.assert(n10.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGL backend.`);
  });
}
var Ne = X2();
Ne.registerFlag("HAS_WEBGL", () => Ne.getNumber("WEBGL_VERSION") > 0);
Ne.registerFlag("WEBGL_VERSION", () => Bm(2) ? 2 : Bm(1) ? 1 : 0);
Ne.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
Ne.registerFlag("WEBGL_BUFFER_SUPPORTED", () => Ne.get("WEBGL_VERSION") === 2);
Ne.registerFlag("WEBGL_CPU_FORWARD", () => true);
Ne.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
Ne.registerFlag("WEBGL_PACK", () => Ne.getBool("HAS_WEBGL"));
Ne.registerFlag("WEBGL_PACK_NORMALIZATION", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_CLIP", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_PACK_REDUCE", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_LAZILY_UNPACK", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_CONV_IM2COL", () => Ne.getBool("WEBGL_PACK"));
Ne.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => ZC(Ne.getNumber("WEBGL_VERSION")));
Ne.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => JC(Ne.getNumber("WEBGL_VERSION")));
Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  let e = Ne.getNumber("WEBGL_VERSION");
  return e === 0 ? 0 : e1(e);
});
Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => Ne.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !cp.isMobile());
Ne.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => t1(Ne.getNumber("WEBGL_VERSION")));
Ne.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => Ne.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : Ne.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
Ne.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => n1(Ne.getNumber("WEBGL_VERSION")));
Ne.registerFlag("WEBGL_FENCE_API_ENABLED", () => s1(Ne.getNumber("WEBGL_VERSION")));
Ne.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => Ne.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
Ne.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (e) => {
  if (e < 0 && e !== -1)
    throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`);
});
Ne.registerFlag("WEBGL_FLUSH_THRESHOLD", () => cp.isMobile() ? 1 : -1, (e) => {
  if (e < 0 && e !== -1)
    throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`);
});
Ne.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
Ne.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
Ne.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
Ne.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
function hn() {
  let e, t, n10, s10, r10, a10, i10, o10, u10, l10;
  return X2().getNumber("WEBGL_VERSION") === 2 ? (e = "#version 300 es", t = "in", n10 = "out", s10 = "in", r10 = "texture", a10 = "outputColor", i10 = "out vec4 outputColor;", o10 = `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `, u10 = "", l10 = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (e = "", t = "attribute", n10 = "varying", s10 = "varying", r10 = "texture2D", a10 = "gl_FragColor", i10 = "", o10 = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, u10 = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, l10 = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), { version: e, attribute: t, varyingVs: n10, varyingFs: s10, texture2D: r10, output: a10, defineOutput: i10, defineSpecialNaN: o10, defineSpecialInf: u10, defineRound: l10 };
}
function gi(e, t, n10 = "index") {
  let s10 = w2.computeStrides(t);
  return s10.map((r10, a10) => {
    let i10 = `int ${e[a10]} = ${n10} / ${r10}`, o10 = a10 === s10.length - 1 ? `int ${e[a10 + 1]} = ${n10} - ${e[a10]} * ${r10}` : `index -= ${e[a10]} * ${r10}`;
    return `${i10}; ${o10};`;
  }).join("");
}
function Hp(e, t, n10 = "index") {
  let s10 = w2.computeStrides(t);
  return s10.map((r10, a10) => {
    let i10 = `int ${e[a10]} = ${n10} / outShapeStrides[${a10}]`, o10 = a10 === s10.length - 1 ? `int ${e[a10 + 1]} = ${n10} - ${e[a10]} * outShapeStrides[${a10}]` : `index -= ${e[a10]} * outShapeStrides[${a10}]`;
    return `${i10}; ${o10};`;
  }).join("");
}
function $5(e, t) {
  let n10 = e.length, s10 = e.map((a10) => `${t}[${a10}]`), r10 = new Array(n10 - 1);
  r10[n10 - 2] = s10[n10 - 1];
  for (let a10 = n10 - 3; a10 >= 0; --a10)
    r10[a10] = `(${r10[a10 + 1]} * ${s10[a10 + 1]})`;
  return r10;
}
function _5(e, t, n10 = "index") {
  let s10 = e.map((a10, i10) => i10), r10 = $5(s10, t);
  return r10.map((a10, i10) => {
    let o10 = `int ${e[i10]} = ${n10} / ${r10[i10]}`, u10 = i10 === r10.length - 1 ? `int ${e[i10 + 1]} = ${n10} - ${e[i10]} * ${r10[i10]}` : `index -= ${e[i10]} * ${r10[i10]}`;
    return `${o10}; ${u10};`;
  }).join("");
}
function cv(e) {
  let t = w2.computeStrides(e).map((n10) => n10.toString());
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
}
function dv() {
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
var r1 = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
var { getBroadcastDims: a1 } = N2;
function A5(e, t, n10) {
  let s10 = [];
  if (e.forEach((h10) => {
    let f10 = w2.sizeFromShape(h10.shapeInfo.logicalShape);
    if (h10.shapeInfo.isUniform ? s10.push(`uniform float ${h10.name}${f10 > 1 ? `[${f10}]` : ""};`) : (s10.push(`uniform sampler2D ${h10.name};`), s10.push(`uniform int offset${h10.name};`)), n10.enableShapeUniforms) {
      let { uniformShape: m10 } = pv(n10.packedInputs, h10.shapeInfo.logicalShape, h10.shapeInfo.texShape);
      switch (m10.length) {
        case 1:
          s10.push(`uniform int ${h10.name}Shape;`);
          break;
        case 2:
          s10.push(`uniform ivec2 ${h10.name}Shape;`);
          break;
        case 3:
          s10.push(`uniform ivec3 ${h10.name}Shape;`);
          break;
        case 4:
          s10.push(`uniform ivec4 ${h10.name}Shape;`);
          break;
        default:
          break;
      }
      s10.push(`uniform ivec2 ${h10.name}TexShape;`);
    }
  }), n10.enableShapeUniforms) {
    switch (t.logicalShape.length) {
      case 1:
        s10.push("uniform int outShape;");
        break;
      case 2:
        s10.push("uniform ivec2 outShape;"), s10.push("uniform int outShapeStrides;");
        break;
      case 3:
        s10.push("uniform ivec3 outShape;"), s10.push("uniform ivec2 outShapeStrides;");
        break;
      case 4:
        s10.push("uniform ivec4 outShape;"), s10.push("uniform ivec3 outShapeStrides;");
        break;
      default:
        break;
    }
    s10.push("uniform ivec2 outTexShape;");
  }
  n10.customUniforms && n10.customUniforms.forEach((h10) => {
    s10.push(`uniform ${h10.type} ${h10.name}${h10.arrayIndex ? `[${h10.arrayIndex}]` : ""};`);
  });
  let r10 = s10.join(`
`), a10 = e.map((h10) => E5(h10, t, n10.packedInputs, n10.enableShapeUniforms)).join(`
`), i10 = t.texShape, o10 = hn(), u10 = F5(o10), l10, c10, p10 = z5(o10);
  return t.isPacked ? (l10 = R5(t.logicalShape, i10, n10.enableShapeUniforms), c10 = P5(o10)) : (l10 = D5(t.logicalShape, i10, n10.enableShapeUniforms), c10 = O5(o10)), n10.packedInputs && (p10 += V5), [p10, u10, c10, r10, l10, a10, n10.userCode].join(`
`);
}
function nu(e, t = false) {
  let n10 = e.shapeInfo.logicalShape;
  switch (n10.length) {
    case 0:
      return J5(e, t);
    case 1:
      return tK(e, t);
    case 2:
      return sK(e, t);
    case 3:
      return aK(e, t);
    case 4:
      return oK(e, t);
    case 5:
      return uK(e);
    case 6:
      return lK(e);
    default:
      throw new Error(`${n10.length}-D input sampling is not yet supported`);
  }
}
function i1(e, t) {
  switch (e.shapeInfo.logicalShape.length) {
    case 0:
      return Z5(e);
    case 1:
      return eK(e, t);
    case 2:
      return nK(e, t);
    case 3:
      return rK(e, t);
    default:
      return iK(e, t);
  }
}
function E5(e, t, n10 = false, s10) {
  let r10 = "";
  n10 ? r10 += i1(e, s10) : r10 += nu(e, s10);
  let a10 = e.shapeInfo.logicalShape, i10 = t.logicalShape;
  return a10.length <= i10.length && (n10 ? r10 += cK(e, t) : r10 += dK(e, t)), r10;
}
function R5(e, t, n10) {
  switch (e.length) {
    case 0:
      return o1();
    case 1:
      return W5(e, t, n10);
    case 2:
      return Y5(e, t, n10);
    case 3:
      return G5(e, t, n10);
    default:
      return q5(e, t, n10);
  }
}
function D5(e, t, n10) {
  switch (e.length) {
    case 0:
      return o1();
    case 1:
      return U5(e, t, n10);
    case 2:
      return Q5(e, t, n10);
    case 3:
      return H5(e, t, n10);
    case 4:
      return j5(e, t, n10);
    case 5:
      return K5(e, t);
    case 6:
      return X5(e, t);
    default:
      throw new Error(`${e.length}-D output sampling is not yet supported`);
  }
}
function F5(e) {
  return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `;
}
function O5(e) {
  return `
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function P5(e) {
  return `
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `;
}
function z5(e) {
  return `${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${M5}
    ${L5}
    ${B5}
  `;
}
var M5 = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var L5 = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var B5 = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
var V5 = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function o1() {
  return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function W5(e, t, n10) {
  let s10 = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
  return s10[0] === 1 ? n10 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s10[1]}.0);
      }
    ` : s10[1] === 1 ? n10 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s10[0]}.0);
      }
    ` : n10 ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s10[0]}, ${s10[1]}));
      return 2 * (resTexRC.x * ${s10[1]} + resTexRC.y);
    }
  `;
}
function U5(e, t, n10) {
  return t[0] === 1 ? n10 ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    ` : t[1] === 1 ? n10 ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    ` : n10 ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `;
}
function G5(e, t, n10) {
  if (n10)
    return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
  let s10 = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], r10 = Math.ceil(e[2] / 2), a10 = r10 * Math.ceil(e[1] / 2);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s10[0]}, ${s10[1]}));
      int index = resTexRC.x * ${s10[1]} + resTexRC.y;

      int b = index / ${a10};
      index -= b * ${a10};

      int r = 2 * (index / ${r10});
      int c = imod(index, ${r10}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function H5(e, t, n10) {
  if (n10)
    return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Hp(["r", "c", "d"], e)}
    return ivec3(r, c, d);
  }
`;
  let s10 = gi(["r", "c", "d"], e);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s10}
      return ivec3(r, c, d);
    }
  `;
}
function q5(e, t, n10) {
  if (n10)
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
  let s10 = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], r10 = Math.ceil(e[e.length - 1] / 2), a10 = r10 * Math.ceil(e[e.length - 2] / 2), i10 = a10, o10 = "", u10 = "b, r, c";
  for (let l10 = 2; l10 < e.length - 1; l10++)
    i10 *= e[e.length - l10 - 1], o10 = `
      int b${l10} = index / ${i10};
      index -= b${l10} * ${i10};
    ` + o10, u10 = `b${l10}, ` + u10;
  return `
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s10[0]}, ${s10[1]}));
      int index = resTexRC.x * ${s10[1]} + resTexRC.y;

      ${o10}

      int b = index / ${a10};
      index -= b * ${a10};

      int r = 2 * (index / ${r10});
      int c = imod(index, ${r10}) * 2;

      return ivec${e.length}(${u10});
    }
  `;
}
function j5(e, t, n10) {
  if (n10)
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Hp(["r", "c", "d", "d2"], e)}
      return ivec4(r, c, d, d2);
    }
  `;
  let s10 = gi(["r", "c", "d", "d2"], e);
  return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s10}
      return ivec4(r, c, d, d2);
    }
  `;
}
function K5(e, t) {
  let n10 = gi(["r", "c", "d", "d2", "d3"], e);
  return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n10}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function X5(e, t) {
  let n10 = gi(["r", "c", "d", "d2", "d3", "d4"], e);
  return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n10}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function Y5(e, t, n10) {
  let s10 = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
  if (w2.arraysEqual(e, t))
    return n10 ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s10[0]}, ${s10[1]}));
      }
    `;
  let r10 = Math.ceil(e[1] / 2);
  return n10 ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s10[0]}, ${s10[1]}));

      int index = resTexRC.x * ${s10[1]} + resTexRC.y;
      int r = 2 * (index / ${r10});
      int c = imod(index, ${r10}) * 2;

      return ivec2(r, c);
    }
  `;
}
function Q5(e, t, n10) {
  return w2.arraysEqual(e, t) ? n10 ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    ` : e[1] === 1 ? n10 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : e[0] === 1 ? n10 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : n10 ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `;
}
function bi(e) {
  return `offset${e}`;
}
function Z5(e) {
  let t = e.name, n10 = "get" + t.charAt(0).toUpperCase() + t.slice(1), s10 = hn();
  return `
    vec4 ${n10}() {
      return ${s10.texture2D}(${t}, halfCR);
    }
  `;
}
function J5(e, t) {
  let n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1);
  if (e.shapeInfo.isUniform)
    return `float ${s10}() {return ${n10};}`;
  let [r10, a10] = e.shapeInfo.texShape;
  if (r10 === 1 && a10 === 1)
    return `
      float ${s10}() {
        return sampleTexture(${n10}, halfCR);
      }
    `;
  let i10 = bi(n10);
  if (t)
    return `
    float ${s10}() {
      vec2 uv = uvFromFlat(${n10}TexShape[0], ${n10}TexShape[1], ${i10});
      return sampleTexture(${n10}, uv);
    }
  `;
  let [o10, u10] = e.shapeInfo.texShape;
  return `
    float ${s10}() {
      vec2 uv = uvFromFlat(${o10}, ${u10}, ${i10});
      return sampleTexture(${n10}, uv);
    }
  `;
}
function eK(e, t) {
  let n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), r10 = e.shapeInfo.texShape, a10 = hn();
  if (t)
    return `
    vec4 ${s10}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n10}TexShape[0]) / 2.0), ceil(float(${n10}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a10.texture2D}(${n10}, uv);
    }
  `;
  let i10 = [Math.ceil(r10[0] / 2), Math.ceil(r10[1] / 2)];
  return `
    vec4 ${s10}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i10[0]}, ${i10[1]}, index);
      return ${a10.texture2D}(${n10}, uv);
    }
  `;
}
function tK(e, t) {
  let n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1);
  if (e.shapeInfo.isUniform)
    return `
      float ${s10}(int index) {
        ${su(e)}
      }
    `;
  let r10 = e.shapeInfo.texShape, a10 = r10[0], i10 = r10[1];
  if (i10 === 1 && a10 === 1)
    return `
      float ${s10}(int index) {
        return sampleTexture(${n10}, halfCR);
      }
    `;
  let o10 = bi(n10);
  return i10 === 1 ? t ? `
      float ${s10}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o10}) + 0.5) / float(${n10}TexShape[0]));
        return sampleTexture(${n10}, uv);
      }
    ` : `
      float ${s10}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o10}) + 0.5) / ${a10}.0);
        return sampleTexture(${n10}, uv);
      }
    ` : a10 === 1 ? t ? `
      float ${s10}(int index) {
        vec2 uv = vec2((float(index + ${o10}) + 0.5) / float(${n10}TexShape[1]), 0.5);
        return sampleTexture(${n10}, uv);
      }
    ` : `
      float ${s10}(int index) {
        vec2 uv = vec2((float(index + ${o10}) + 0.5) / ${i10}.0, 0.5);
        return sampleTexture(${n10}, uv);
      }
    ` : t ? `
    float ${s10}(int index) {
      vec2 uv = uvFromFlat(${n10}TexShape[0], ${n10}TexShape[1], index + ${o10});
      return sampleTexture(${n10}, uv);
    }
  ` : `
    float ${s10}(int index) {
      vec2 uv = uvFromFlat(${a10}, ${i10}, index + ${o10});
      return sampleTexture(${n10}, uv);
    }
  `;
}
function nK(e, t) {
  let n10 = e.shapeInfo.logicalShape, s10 = e.name, r10 = "get" + s10.charAt(0).toUpperCase() + s10.slice(1), a10 = e.shapeInfo.texShape, i10 = a10[0], o10 = a10[1], u10 = hn();
  if (a10 != null && w2.arraysEqual(n10, a10))
    return t ? `
      vec4 ${r10}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s10}TexShape[1], ${s10}TexShape[0]);

        return ${u10.texture2D}(${s10}, uv);
      }
    ` : `
      vec4 ${r10}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o10}.0, ${i10}.0);

        return ${u10.texture2D}(${s10}, uv);
      }
    `;
  if (t)
    return `
    vec4 ${r10}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s10}TexShape[0]) / 2.0), ceil(float(${s10}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s10}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u10.texture2D}(${s10}, uv);
    }
  `;
  let l10 = [Math.ceil(a10[0] / 2), Math.ceil(a10[1] / 2)], c10 = Math.ceil(n10[1] / 2);
  return `
    vec4 ${r10}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c10}, ${l10[0]}, ${l10[1]}, row, col);
      return ${u10.texture2D}(${s10}, uv);
    }
  `;
}
function sK(e, t) {
  let n10 = e.shapeInfo.logicalShape, s10 = e.name, r10 = "get" + s10.charAt(0).toUpperCase() + s10.slice(1), a10 = e.shapeInfo.texShape;
  if (a10 != null && w2.arraysEqual(n10, a10)) {
    if (t)
      return `
      float ${r10}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s10}TexShape[1], ${s10}TexShape[0]);
        return sampleTexture(${s10}, uv);
      }
    `;
    let d10 = a10[0], h10 = a10[1];
    return `
    float ${r10}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h10}.0, ${d10}.0);
      return sampleTexture(${s10}, uv);
    }
  `;
  }
  let { newShape: i10, keptDims: o10 } = w2.squeezeShape(n10), u10 = i10;
  if (u10.length < n10.length) {
    let d10 = ru(e, u10), h10 = ["row", "col"];
    return `
      ${nu(d10, t)}
      float ${r10}(int row, int col) {
        return ${r10}(${au(h10, o10)});
      }
    `;
  }
  if (e.shapeInfo.isUniform)
    return `
      float ${r10}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n10[1]}, 1)));
        ${su(e)}
      }
    `;
  let l10 = a10[0], c10 = a10[1], p10 = bi(s10);
  return c10 === 1 ? t ? `
      float ${r10}(int row, int col) {
        float index = dot(vec3(row, col, ${p10}), vec3(${s10}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s10}TexShape[0]));
        return sampleTexture(${s10}, uv);
      }
    ` : `
    float ${r10}(int row, int col) {
      float index = dot(vec3(row, col, ${p10}), vec3(${n10[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l10}.0);
      return sampleTexture(${s10}, uv);
    }
  ` : l10 === 1 ? t ? `
      float ${r10}(int row, int col) {
        float index = dot(vec3(row, col, ${p10}), vec3(${s10}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s10}TexShape[1]), 0.5);
        return sampleTexture(${s10}, uv);
      }
    ` : `
    float ${r10}(int row, int col) {
      float index = dot(vec3(row, col, ${p10}), vec3(${n10[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c10}.0, 0.5);
      return sampleTexture(${s10}, uv);
    }
  ` : t ? `
      float ${r10}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s10}Shape[1] + col + ${p10};
        vec2 uv = uvFromFlat(${s10}TexShape[0], ${s10}TexShape[1], index);
        return sampleTexture(${s10}, uv);
      }
    ` : `
  float ${r10}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n10[1]} + col + ${p10};
    vec2 uv = uvFromFlat(${l10}, ${c10}, index);
    return sampleTexture(${s10}, uv);
  }
`;
}
function rK(e, t) {
  let n10 = e.shapeInfo.logicalShape, s10 = e.name, r10 = "get" + s10.charAt(0).toUpperCase() + s10.slice(1), a10 = e.shapeInfo.texShape, i10 = [Math.ceil(a10[0] / 2), Math.ceil(a10[1] / 2)];
  if (n10[0] === 1) {
    let d10 = n10.slice(1), h10 = [1, 2], f10 = ru(e, d10), m10 = ["b", "row", "col"];
    return `
        ${i1(f10, t)}
        vec4 ${r10}(int b, int row, int col) {
          return ${r10}(${au(m10, h10)});
        }
      `;
  }
  let o10 = hn();
  if (t)
    return `
    vec4 ${r10}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s10}TexShape[0]) / 2.0), ceil(float(${s10}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s10}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s10}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o10.texture2D}(${s10}, uv);
    }
  `;
  let u10 = i10[0], l10 = i10[1], c10 = Math.ceil(n10[2] / 2), p10 = c10 * Math.ceil(n10[1] / 2);
  return `
    vec4 ${r10}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u10}, ${l10}, ${p10}, ${c10}, b, row, col);
      return ${o10.texture2D}(${s10}, uv);
    }
  `;
}
function aK(e, t) {
  let n10 = e.shapeInfo.logicalShape, s10 = e.name, r10 = "get" + s10.charAt(0).toUpperCase() + s10.slice(1), a10 = n10[1] * n10[2], i10 = n10[2], { newShape: o10, keptDims: u10 } = w2.squeezeShape(n10), l10 = o10;
  if (l10.length < n10.length) {
    let m10 = ru(e, l10), g10 = ["row", "col", "depth"];
    return `
        ${nu(m10, t)}
        float ${r10}(int row, int col, int depth) {
          return ${r10}(${au(g10, u10)});
        }
      `;
  }
  if (e.shapeInfo.isUniform)
    return `
      float ${r10}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a10}, ${i10}, 1)));
        ${su(e)}
      }
    `;
  let c10 = e.shapeInfo.texShape, p10 = c10[0], d10 = c10[1], h10 = e.shapeInfo.flatOffset;
  if (d10 === a10 && h10 == null)
    return t ? `
      float ${r10}(int row, int col, int depth) {
        int stride1 = ${s10}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s10}TexShape[1], ${s10}TexShape[0]);
        return sampleTexture(${s10}, uv);
      }
    ` : `
        float ${r10}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i10}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d10}.0, ${p10}.0);
          return sampleTexture(${s10}, uv);
        }
      `;
  if (d10 === i10 && h10 == null)
    return t ? `
      float ${r10}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s10}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s10}TexShape[1], ${s10}TexShape[0]);
        return sampleTexture(${s10}, uv);
      }
    ` : `
    float ${r10}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n10[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d10}.0, ${p10}.0);
      return sampleTexture(${s10}, uv);
    }
  `;
  let f10 = bi(s10);
  return t ? `
    float ${r10}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s10}Shape[1] * ${s10}Shape[2];
      int stride1 = ${s10}Shape[2];
      int index = row * ${a10} + col * ${i10} + depth + ${f10};
      vec2 uv = uvFromFlat(${s10}TexShape[0], ${s10}TexShape[1], index);
      return sampleTexture(${s10}, uv);
    }
    ` : `
      float ${r10}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a10} + col * ${i10} + depth + ${f10};
        vec2 uv = uvFromFlat(${p10}, ${d10}, index);
        return sampleTexture(${s10}, uv);
      }
  `;
}
function iK(e, t) {
  let n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), r10 = hn();
  if (t)
    return `
    vec4 ${s10}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n10}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n10}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n10}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n10}TexShape[0]) / 2.0), ceil(float(${n10}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r10.texture2D}(${n10}, uv);
    }
  `;
  let a10 = e.shapeInfo.logicalShape, i10 = a10.length, o10 = e.shapeInfo.texShape, u10 = [Math.ceil(o10[0] / 2), Math.ceil(o10[1] / 2)], l10 = u10[0], c10 = u10[1], p10 = Math.ceil(a10[i10 - 1] / 2), d10 = p10 * Math.ceil(a10[i10 - 2] / 2), h10 = "int b, int row, int col", f10 = `b * ${d10} + (row / 2) * ${p10} + (col / 2)`;
  for (let m10 = 2; m10 < i10 - 1; m10++)
    h10 = `int b${m10}, ` + h10, d10 *= a10[i10 - m10 - 1], f10 = `b${m10} * ${d10} + ` + f10;
  return `
    vec4 ${s10}(${h10}) {
      int index = ${f10};
      int texR = index / ${c10};
      int texC = index - texR * ${c10};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c10}, ${l10});
      return ${r10.texture2D}(${n10}, uv);
    }
  `;
}
function oK(e, t) {
  let n10 = e.shapeInfo.logicalShape, s10 = e.name, r10 = "get" + s10.charAt(0).toUpperCase() + s10.slice(1), a10 = n10[3], i10 = n10[2] * a10, o10 = n10[1] * i10, { newShape: u10, keptDims: l10 } = w2.squeezeShape(n10);
  if (u10.length < n10.length) {
    let y10 = ru(e, u10), v10 = ["row", "col", "depth", "depth2"];
    return `
      ${nu(y10, t)}
      float ${r10}(int row, int col, int depth, int depth2) {
        return ${r10}(${au(v10, l10)});
      }
    `;
  }
  if (e.shapeInfo.isUniform)
    return `
      float ${r10}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o10}, ${i10}, ${a10}, 1)));
        ${su(e)}
      }
    `;
  let c10 = e.shapeInfo.flatOffset, p10 = e.shapeInfo.texShape, d10 = p10[0], h10 = p10[1], f10 = `int stride2 = ${s10}Shape[3];`, m10 = `int stride1 = ${s10}Shape[2] * stride2;`, g10 = `int stride0 = ${s10}Shape[1] * stride1;`;
  if (h10 === o10 && c10 == null)
    return t ? `
      float ${r10}(int row, int col, int depth, int depth2) {
        ${f10}
        ${m10}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s10}TexShape[1], ${s10}TexShape[0]);
        return sampleTexture(${s10}, uv);
      }
    ` : `
      float ${r10}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i10}, ${a10}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h10}.0, ${d10}.0);
        return sampleTexture(${s10}, uv);
      }
    `;
  if (h10 === a10 && c10 == null)
    return t ? `
      float ${r10}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s10}Shape[1] * ${s10}Shape[2], ${s10}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s10}TexShape[1], ${s10}TexShape[0]);
        return sampleTexture(${s10}, uv);
      }
    ` : `
      float ${r10}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n10[1] * n10[2]}, ${n10[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h10}.0, ${d10}.0);
        return sampleTexture(${s10}, uv);
      }
    `;
  let b10 = bi(s10);
  return t ? `
    float ${r10}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f10}
      ${m10}
      ${g10}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s10}TexShape[0], ${s10}TexShape[1], index + ${b10});
      return sampleTexture(${s10}, uv);
    }
  ` : `
    float ${r10}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o10} + col * ${i10} +
          depth * ${a10} + depth2;
      vec2 uv = uvFromFlat(${d10}, ${h10}, index + ${b10});
      return sampleTexture(${s10}, uv);
    }
  `;
}
function uK(e) {
  let t = e.shapeInfo.logicalShape, n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), r10 = t[4], a10 = t[3] * r10, i10 = t[2] * a10, o10 = t[1] * i10, { newShape: u10, keptDims: l10 } = w2.squeezeShape(t);
  if (u10.length < t.length) {
    let m10 = ru(e, u10), g10 = ["row", "col", "depth", "depth2", "depth3"];
    return `
      ${nu(m10)}
      float ${s10}(int row, int col, int depth, int depth2, int depth3) {
        return ${s10}(${au(g10, l10)});
      }
    `;
  }
  if (e.shapeInfo.isUniform)
    return `
      float ${s10}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o10}, ${i10}, ${a10}, ${r10})) +
          depth3;
        ${su(e)}
      }
    `;
  let c10 = e.shapeInfo.flatOffset, p10 = e.shapeInfo.texShape, d10 = p10[0], h10 = p10[1];
  if (h10 === o10 && c10 == null)
    return `
      float ${s10}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i10}, ${a10}, ${r10}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h10}.0, ${d10}.0);
        return sampleTexture(${n10}, uv);
      }
    `;
  if (h10 === r10 && c10 == null)
    return `
      float ${s10}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3]},
               ${t[2] * t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h10}.0, ${d10}.0);
        return sampleTexture(${n10}, uv);
      }
    `;
  let f10 = bi(n10);
  return `
    float ${s10}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o10} + col * ${i10} + depth * ${a10} +
          depth2 * ${r10} + depth3 + ${f10};
      vec2 uv = uvFromFlat(${d10}, ${h10}, index);
      return sampleTexture(${n10}, uv);
    }
  `;
}
function lK(e) {
  let t = e.shapeInfo.logicalShape, n10 = e.name, s10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), { newShape: r10, keptDims: a10 } = w2.squeezeShape(t);
  if (r10.length < t.length) {
    let g10 = ru(e, r10), b10 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return `
      ${nu(g10)}
      float ${s10}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s10}(${au(b10, a10)});
      }
    `;
  }
  let i10 = t[5], o10 = t[4] * i10, u10 = t[3] * o10, l10 = t[2] * u10, c10 = t[1] * l10;
  if (e.shapeInfo.isUniform)
    return `
      float ${s10}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c10}, ${l10}, ${u10}, ${o10})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i10}, 1)));
        ${su(e)}
      }
    `;
  let p10 = e.shapeInfo.flatOffset, d10 = e.shapeInfo.texShape, h10 = d10[0], f10 = d10[1];
  if (f10 === c10 && p10 == null)
    return `
      float ${s10}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l10}, ${u10}, ${o10}, ${i10})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f10}.0, ${h10}.0);
        return sampleTexture(${n10}, uv);
      }
    `;
  if (f10 === i10 && p10 == null)
    return `
      float ${s10}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3] * t[4]},
               ${t[2] * t[3] * t[4]},
               ${t[3] * t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f10}.0, ${h10}.0);
        return sampleTexture(${n10}, uv);
      }
    `;
  let m10 = bi(n10);
  return `
    float ${s10}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c10} + col * ${l10} + depth * ${u10} +
          depth2 * ${o10} + depth3 * ${i10} + depth4 + ${m10};
      vec2 uv = uvFromFlat(${h10}, ${f10}, index);
      return sampleTexture(${n10}, uv);
    }
  `;
}
function su(e) {
  let t = e.name, n10 = w2.sizeFromShape(e.shapeInfo.logicalShape);
  return n10 < 2 ? `return ${t};` : `
    for (int i = 0; i < ${n10}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
}
function cK(e, t) {
  let n10 = e.name, s10 = n10.charAt(0).toUpperCase() + n10.slice(1), r10 = "get" + s10 + "AtOutCoords", a10 = e.shapeInfo.logicalShape.length, i10 = t.logicalShape.length, o10 = a1(e.shapeInfo.logicalShape, t.logicalShape), u10 = ot(i10), l10 = i10 - a10, c10, p10 = ["x", "y", "z", "w", "u", "v"];
  a10 === 0 ? c10 = "" : i10 < 2 && o10.length >= 1 ? c10 = "coords = 0;" : c10 = o10.map((y10) => `coords.${p10[y10 + l10]} = 0;`).join(`
`);
  let d10 = "";
  i10 < 2 && a10 > 0 ? d10 = "coords" : d10 = e.shapeInfo.logicalShape.map((y10, v10) => `coords.${p10[v10 + l10]}`).join(", ");
  let h10 = "return outputValue;", m10 = w2.sizeFromShape(e.shapeInfo.logicalShape) === 1, b10 = w2.sizeFromShape(t.logicalShape) === 1;
  if (a10 === 1 && !m10 && !b10)
    h10 = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
  else if (m10 && !b10)
    i10 === 1 ? h10 = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : h10 = `
        return vec4(outputValue.x);
      `;
  else if (o10.length) {
    let y10 = a10 - 2, v10 = a10 - 1;
    o10.indexOf(y10) > -1 && o10.indexOf(v10) > -1 ? h10 = "return vec4(outputValue.x);" : o10.indexOf(y10) > -1 ? h10 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o10.indexOf(v10) > -1 && (h10 = "return vec4(outputValue.xx, outputValue.zz);");
  }
  return `
    vec4 ${r10}() {
      ${u10} coords = getOutputCoords();
      ${c10}
      vec4 outputValue = get${s10}(${d10});
      ${h10}
    }
  `;
}
function dK(e, t) {
  let n10 = e.name, s10 = n10.charAt(0).toUpperCase() + n10.slice(1), r10 = "get" + s10 + "AtOutCoords", a10 = t.texShape, i10 = e.shapeInfo.texShape, o10 = e.shapeInfo.logicalShape.length, u10 = t.logicalShape.length;
  if (!e.shapeInfo.isUniform && o10 === u10 && e.shapeInfo.flatOffset == null && w2.arraysEqual(i10, a10))
    return `
      float ${r10}() {
        return sampleTexture(${n10}, resultUV);
      }
    `;
  let l10 = ot(u10), c10 = a1(e.shapeInfo.logicalShape, t.logicalShape), p10 = u10 - o10, d10, h10 = ["x", "y", "z", "w", "u", "v"];
  o10 === 0 ? d10 = "" : u10 < 2 && c10.length >= 1 ? d10 = "coords = 0;" : d10 = c10.map((m10) => `coords.${h10[m10 + p10]} = 0;`).join(`
`);
  let f10 = "";
  return u10 < 2 && o10 > 0 ? f10 = "coords" : f10 = e.shapeInfo.logicalShape.map((m10, g10) => `coords.${h10[g10 + p10]}`).join(", "), `
    float ${r10}() {
      ${l10} coords = getOutputCoords();
      ${d10}
      return get${s10}(${f10});
    }
  `;
}
function ot(e) {
  if (e <= 1)
    return "int";
  if (e === 2)
    return "ivec2";
  if (e === 3)
    return "ivec3";
  if (e === 4)
    return "ivec4";
  if (e === 5)
    return "ivec5";
  if (e === 6)
    return "ivec6";
  throw Error(`GPU for rank ${e} is not yet supported`);
}
function pv(e, t, n10) {
  let { newShape: s10, keptDims: r10 } = w2.squeezeShape(t), a10 = t.length, i10 = e && a10 === 3 && t[0] === 1, o10 = i10 ? t.slice(1) : s10, u10 = !e && a10 > 1 && !w2.arraysEqual(t, n10) && s10.length < a10 || i10;
  return { useSqueezeShape: u10, uniformShape: u10 ? o10 : t, keptDims: r10 };
}
function ru(e, t) {
  let n10 = JSON.parse(JSON.stringify(e));
  return n10.shapeInfo.logicalShape = t, n10;
}
function au(e, t) {
  return t.map((n10) => e[n10]).join(", ");
}
function pK(e, t, n10, s10) {
  let r10 = n10.map((x10, k10) => {
    let C10 = { logicalShape: x10.shape, texShape: x10.isUniform ? null : x10.texData.texShape, isUniform: x10.isUniform, isPacked: x10.isUniform ? false : x10.texData.isPacked, flatOffset: null };
    return x10.texData != null && x10.texData.slice != null && x10.texData.slice.flatOffset > 0 && (C10.flatOffset = x10.texData.slice.flatOffset), { name: t.variableNames[k10], shapeInfo: C10 };
  }), a10 = r10.map((x10) => x10.shapeInfo), i10 = { logicalShape: s10.shape, texShape: s10.texData.texShape, isUniform: false, isPacked: s10.texData.isPacked, flatOffset: null }, o10 = A5(r10, i10, t), u10 = zC(e.gl, o10), l10 = e.createProgram(u10), c10 = null, p10 = e.getUniformLocation(l10, "NAN", false);
  X2().getNumber("WEBGL_VERSION") === 1 && (c10 = e.getUniformLocation(l10, "INFINITY", false));
  let d10 = false, h10 = {}, f10 = {}, m10 = {};
  for (let x10 = 0; x10 < t.variableNames.length; x10++) {
    let k10 = t.variableNames[x10];
    h10[k10] = e.getUniformLocation(l10, k10, d10), h10[`offset${k10}`] = e.getUniformLocation(l10, `offset${k10}`, d10), t.enableShapeUniforms && (f10[`${k10}Shape`] = e.getUniformLocation(l10, `${k10}Shape`, d10), m10[`${k10}TexShape`] = e.getUniformLocation(l10, `${k10}TexShape`, d10));
  }
  let g10, b10, y10;
  t.enableShapeUniforms && (g10 = e.getUniformLocation(l10, "outShape", d10), y10 = e.getUniformLocation(l10, "outShapeStrides", d10), b10 = e.getUniformLocation(l10, "outTexShape", d10));
  let v10 = [];
  return t.customUniforms && t.customUniforms.forEach((x10, k10) => {
    v10[k10] = e.getUniformLocation(l10, x10.name, d10);
  }), { program: t, fragmentShader: u10, source: o10, webGLProgram: l10, uniformLocations: h10, customUniformLocations: v10, inShapeInfos: a10, outShapeInfo: i10, infLoc: c10, nanLoc: p10, inShapesLocations: f10, inTexShapesLocations: m10, outShapeLocation: g10, outShapeStridesLocation: y10, outTexShapeLocation: b10 };
}
function tw(e, t) {
  if (e.length !== t.length)
    throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);
  e.forEach((n10, s10) => {
    let r10 = n10.logicalShape, a10 = t[s10], i10 = a10.shape;
    if (!w2.arraysEqual(r10, i10))
      throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r10} and ${i10} must match`);
    if (n10.isUniform && a10.isUniform)
      return;
    let o10 = n10.texShape, u10 = a10.isUniform ? null : a10.texData.texShape;
    if (!w2.arraysEqual(o10, u10))
      throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o10} and ${u10} must match`);
  });
}
function hK(e, t, n10, s10, r10) {
  t.program.enableShapeUniforms || (tw(t.inShapeInfos, n10), tw([t.outShapeInfo], [s10]));
  let a10 = s10.texData.texture, i10 = s10.texData.texShape;
  s10.texData.isPacked ? e.setOutputPackedMatrixTexture(a10.texture, i10[0], i10[1]) : e.setOutputMatrixTexture(a10.texture, i10[0], i10[1]), e.setProgram(t.webGLProgram), X2().getNumber("WEBGL_VERSION") === 1 && t.infLoc !== null && e.gl.uniform1f(t.infLoc, 1 / 0), t.nanLoc !== null && e.gl.uniform1f(t.nanLoc, NaN), n10.forEach((u10, l10) => {
    let c10 = t.program.variableNames[l10], p10 = t.uniformLocations[c10], d10 = t.uniformLocations[`offset${c10}`], h10 = t.inShapesLocations[`${c10}Shape`], f10 = t.inTexShapesLocations[`${c10}TexShape`];
    if (h10) {
      let { uniformShape: m10 } = pv(t.program.packedInputs, u10.shape, u10.texData.texShape);
      switch (m10.length) {
        case 1:
          e.gl.uniform1iv(h10, new Int32Array(m10));
          break;
        case 2:
          e.gl.uniform2iv(h10, new Int32Array(m10));
          break;
        case 3:
          e.gl.uniform3iv(h10, new Int32Array(m10));
          break;
        case 4:
          e.gl.uniform4iv(h10, new Int32Array(m10));
          break;
        default:
          break;
      }
    }
    if (f10 && e.gl.uniform2i(f10, u10.texData.texShape[0], u10.texData.texShape[1]), p10 != null) {
      if (u10.isUniform) {
        if (w2.sizeFromShape(u10.shape) < 2)
          e.gl.uniform1f(p10, u10.uniformValues[0]);
        else {
          let m10 = u10.uniformValues;
          m10 instanceof Float32Array || (m10 = new Float32Array(m10)), e.gl.uniform1fv(p10, m10);
        }
        return;
      }
      u10.texData.slice != null && d10 != null && e.gl.uniform1i(d10, u10.texData.slice.flatOffset), e.setInputMatrixTexture(u10.texData.texture.texture, p10, l10);
    }
  });
  let o10 = t.outShapeLocation;
  if (o10)
    switch (s10.shape.length) {
      case 1:
        e.gl.uniform1iv(o10, new Int32Array(s10.shape));
        break;
      case 2:
        e.gl.uniform2iv(o10, new Int32Array(s10.shape));
        break;
      case 3:
        e.gl.uniform3iv(o10, new Int32Array(s10.shape));
        break;
      case 4:
        e.gl.uniform4iv(o10, new Int32Array(s10.shape));
        break;
      default:
        break;
    }
  if (t.outShapeStridesLocation) {
    let u10 = w2.computeStrides(s10.shape);
    switch (s10.shape.length) {
      case 2:
        e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(u10));
        break;
      case 3:
        e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(u10));
        break;
      case 4:
        e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(u10));
        break;
      default:
        break;
    }
  }
  t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, s10.texData.texShape[0], s10.texData.texShape[1]), t.program.customUniforms && r10 && t.program.customUniforms.forEach((u10, l10) => {
    let c10 = t.customUniformLocations[l10], p10 = r10[l10];
    if (u10.type === "float")
      e.gl.uniform1fv(c10, p10);
    else if (u10.type === "vec2")
      e.gl.uniform2fv(c10, p10);
    else if (u10.type === "vec3")
      e.gl.uniform3fv(c10, p10);
    else if (u10.type === "vec4")
      e.gl.uniform4fv(c10, p10);
    else if (u10.type === "int")
      e.gl.uniform1iv(c10, p10);
    else if (u10.type === "ivec2")
      e.gl.uniform2iv(c10, p10);
    else if (u10.type === "ivec3")
      e.gl.uniform3iv(c10, p10);
    else if (u10.type === "ivec4")
      e.gl.uniform4iv(c10, p10);
    else
      throw Error(`uniform type ${u10.type} is not supported yet.`);
  }), e.executeProgram();
}
function fK(e, t, n10) {
  let s10 = "";
  t.concat(n10).forEach((i10) => {
    let o10 = i10.texData != null && i10.texData.slice != null && i10.texData.slice.flatOffset > 0;
    if (e.enableShapeUniforms && !i10.isUniform) {
      let u10 = i10.texData.texShape, { useSqueezeShape: l10, uniformShape: c10, keptDims: p10 } = pv(e.packedInputs, i10.shape, u10), d10 = "", h10 = "", f10 = "";
      if (c10.length === 1 && e.packedInputs) {
        let k10 = [Math.ceil(u10[0] / 2), Math.ceil(u10[1] / 2)];
        d10 = `${k10[0] > 1}_${k10[1] > 1}`;
      } else if (c10.length === 2 && !e.packedInputs)
        h10 = `${c10[0] > 1}_${c10[1] > 1}`;
      else if (c10.length > 2 && !e.packedInputs) {
        let k10 = w2.computeStrides(c10);
        f10 = `${k10[0] === u10[1]}_${k10[k10.length - 1] === u10[1]}`;
      }
      let m10 = i10.shape.length, g10 = c10.length === 2 && w2.arraysEqual(i10.shape, u10), b10 = w2.sizeFromShape(i10.shape) === 1, y10 = N2.getBroadcastDims(i10.shape, n10.shape), v10 = !e.packedInputs && m10 === n10.shape.length && w2.arraysEqual(u10, n10.texData.texShape), x10 = e.packedInputs || c10.length > 2 ? "" : `${u10[0] > 1}_${u10[1] > 1}`;
      s10 += `${m10}_${v10}_${l10 ? p10 : ""}_${c10.length}_${b10}_${y10}_${g10}_${d10}_${h10}_${f10}_${x10}_${o10}`;
    } else {
      let u10 = i10.isUniform ? "uniform" : i10.texData.texShape;
      s10 += `${i10.shape}_${u10}_${o10}`;
    }
  });
  let r10 = e.userCode, a10 = e.constructor.name;
  return a10 += "_" + s10 + "_" + r10 + `${X2().getNumber("WEBGL_VERSION")}`, a10;
}
function kn(e) {
  return X2().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
}
var mK = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = 0, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let t = hn();
    this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Hp(["r", "c", "d"], e) : gi(["r", "c", "d"], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `;
  }
};
var gK = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = 0, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let t = hn();
    this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Hp(["r", "c", "d"], e) : gi(["r", "c", "d"], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `;
  }
};
var bK = class {
  constructor(e) {
    this.variableNames = ["A"], this.outTexUsage = 3;
    let t = hn();
    this.outputShape = e, this.userCode = `
      ${r1}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `;
  }
};
var yK = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = 3;
    let t = hn();
    this.outputShape = e, this.userCode = `
      ${r1}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `;
  }
};
var vK = class {
  constructor(e, t = false) {
    this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let n10 = hn();
    this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length);
    let s10 = "result";
    t && (s10 = "floor(result * 255. + 0.5)"), this.userCode = `
      ${this.enableShapeUniforms ? dv() : cv(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n10.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n10.output} = vec4(${s10}, 0., 0., 0.);
      }
    `;
  }
};
var xK = class {
  constructor(e, t = false) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let n10 = hn();
    this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length);
    let s10 = "", r10 = "result";
    t && (r10 = "floor(result * 255. + 0.5)");
    for (let a10 = 0; a10 <= 1; a10++)
      for (let i10 = 0; i10 <= 1; i10++) {
        let o10 = a10 * 2 + i10;
        s10 += `
          localCoords = coords;
          if(localCoords[2] + ${i10} < ${this.enableShapeUniforms ? "outShape[2]" : `${e[2]}`}) {
          localCoords[2] += ${i10};
          if (localCoords[1] + ${a10} < ${this.enableShapeUniforms ? "outShape[1]" : `${e[1]}`}) {
            localCoords[1] += ${a10};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n10.texture2D}(A, uv);

            if (offset == 0) {
              result[${o10}] = values[0];
            } else if (offset == 1) {
              result[${o10}] = values[1];
            } else if (offset == 2) {
              result[${o10}] = values[2];
            } else {
              result[${o10}] = values[3];
            }
          }
        }
        `;
      }
    this.userCode = `
        ${this.enableShapeUniforms ? dv() : cv(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s10}

          ${n10.output} = ${r10};
        }
    `;
  }
};
var wK = {};
Ae(wK, { bindVertexProgramAttributeStreams: () => g1, createBufferFromOutputTexture: () => v1, createFloat16MatrixTexture: () => p1, createFloat16PackedMatrixTexture: () => m1, createFloat32MatrixTexture: () => d1, createIndexBuffer: () => c1, createPackedMatrixTexture: () => f1, createUnsignedBytesMatrixTexture: () => h1, createVertexBuffer: () => l1, createVertexShader: () => u1, downloadByteEncodedFloatMatrixFromOutputTexture: () => w1, downloadFloat32MatrixFromBuffer: () => x1, downloadMatrixFromPackedOutputTexture: () => I1, downloadPackedMatrixFromBuffer: () => k1, getInternalFormatForFloat16MatrixTexture: () => fv, getInternalFormatForFloat16PackedMatrixTexture: () => bv, getInternalFormatForFloat32MatrixTexture: () => hv, getInternalFormatForPackedMatrixTexture: () => gv, getInternalFormatForUnsignedBytesMatrixTexture: () => mv, uploadDenseMatrixToTexture: () => b1, uploadPixelDataToTexture: () => y1 });
function u1(e) {
  let t = hn(), n10 = `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
  return PC(e, n10);
}
function l1(e) {
  let t = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return BC(e, t);
}
function c1(e) {
  let t = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return VC(e, t);
}
function Yl(e, t, n10, s10, r10, a10) {
  UC(t, n10);
  let i10 = WC(e), o10 = e.TEXTURE_2D;
  return fe2(e, () => e.bindTexture(o10, i10)), fe2(e, () => e.texParameteri(o10, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)), fe2(e, () => e.texParameteri(o10, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), fe2(e, () => e.texParameteri(o10, e.TEXTURE_MIN_FILTER, e.NEAREST)), fe2(e, () => e.texParameteri(o10, e.TEXTURE_MAG_FILTER, e.NEAREST)), X2().getNumber("WEBGL_VERSION") === 1 ? fe2(e, () => e.texImage2D(o10, 0, s10, t, n10, 0, r10, a10, null)) : fe2(e, () => e.texStorage2D(o10, 1, s10, t, n10)), fe2(e, () => e.bindTexture(e.TEXTURE_2D, null)), { texture: i10, texShape: [n10, t] };
}
function hv(e) {
  return e.internalFormatFloat;
}
function d1(e, t, n10, s10) {
  let [r10, a10] = Xl(t, n10);
  return Yl(e, r10, a10, hv(s10), s10.textureFormatFloat, e.FLOAT);
}
function fv(e) {
  return e.internalFormatHalfFloat;
}
function p1(e, t, n10, s10) {
  let [r10, a10] = Xl(t, n10);
  return Yl(e, r10, a10, fv(s10), s10.textureFormatFloat, s10.textureTypeHalfFloat);
}
function mv(e) {
  return e.downloadTextureFormat;
}
function h1(e, t, n10, s10) {
  let [r10, a10] = Xl(t, n10);
  return Yl(e, r10, a10, mv(s10), e.RGBA, e.UNSIGNED_BYTE);
}
function gv(e) {
  return e.internalFormatPackedFloat;
}
function f1(e, t, n10, s10) {
  let [r10, a10] = eu(t, n10);
  return Yl(e, r10, a10, gv(s10), e.RGBA, e.FLOAT);
}
function bv(e) {
  return e.internalFormatPackedHalfFloat;
}
function m1(e, t, n10, s10) {
  let [r10, a10] = eu(t, n10);
  return Yl(e, r10, a10, bv(s10), e.RGBA, s10.textureTypeHalfFloat);
}
function g1(e, t, n10) {
  return fe2(e, () => e.bindBuffer(e.ARRAY_BUFFER, n10)), Mm(e, t, "clipSpacePos", n10, 3, 20, 0) && Mm(e, t, "uv", n10, 2, 20, 12);
}
function b1(e, t, n10, s10, r10, a10) {
  fe2(e, () => e.bindTexture(e.TEXTURE_2D, t));
  let i10, o10, u10;
  r10 instanceof Uint8Array ? (i10 = new Uint8Array(n10 * s10 * 4), o10 = e.UNSIGNED_BYTE, u10 = e.RGBA) : (i10 = new Float32Array(n10 * s10 * 4), o10 = e.FLOAT, u10 = a10.internalFormatPackedFloat), i10.set(r10), X2().getNumber("WEBGL_VERSION") === 2 ? fe2(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n10, s10, e.RGBA, o10, i10)) : fe2(e, () => e.texImage2D(e.TEXTURE_2D, 0, u10, n10, s10, 0, e.RGBA, o10, i10)), fe2(e, () => e.bindTexture(e.TEXTURE_2D, null));
}
function y1(e, t, n10) {
  fe2(e, () => e.bindTexture(e.TEXTURE_2D, t)), n10.data instanceof Uint8Array ? X2().getNumber("WEBGL_VERSION") === 2 ? fe2(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n10.width, n10.height, e.RGBA, e.UNSIGNED_BYTE, n10.data)) : fe2(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n10.width, n10.height, 0, e.RGBA, e.UNSIGNED_BYTE, n10.data)) : X2().getNumber("WEBGL_VERSION") === 2 ? fe2(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n10)) : fe2(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n10)), fe2(e, () => e.bindTexture(e.TEXTURE_2D, null));
}
function v1(e, t, n10, s10) {
  let r10 = e.createBuffer();
  fe2(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, r10));
  let o10 = 4 * 4 * t * n10;
  return fe2(e, () => e.bufferData(e.PIXEL_PACK_BUFFER, o10, e.STREAM_READ)), fe2(e, () => e.readPixels(0, 0, n10, t, e.RGBA, e.FLOAT, 0)), fe2(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, null)), r10;
}
function x1(e, t, n10) {
  let s10 = e, r10 = new Float32Array(n10);
  return s10.bindBuffer(s10.PIXEL_PACK_BUFFER, t), s10.getBufferSubData(s10.PIXEL_PACK_BUFFER, 0, r10), s10.bindBuffer(s10.PIXEL_PACK_BUFFER, null), r10;
}
function w1(e, t, n10, s10) {
  let [r10, a10] = Xl(t, n10), i10 = 4, o10 = new Uint8Array(m5(t * n10, i10));
  return fe2(e, () => e.readPixels(0, 0, r10, a10, s10.downloadTextureFormat, e.UNSIGNED_BYTE, o10)), new Float32Array(o10.buffer);
}
function k1(e, t, n10, s10, r10, a10, i10, o10) {
  let u10 = e, l10 = new Float32Array(g5(a10, i10));
  return u10.bindBuffer(u10.PIXEL_PACK_BUFFER, t), u10.getBufferSubData(u10.PIXEL_PACK_BUFFER, 0, l10), u10.bindBuffer(u10.PIXEL_PACK_BUFFER, null), l10;
}
function I1(e, t, n10) {
  let s10 = new Float32Array(t * n10 * 4);
  return fe2(e, () => e.readPixels(0, 0, n10, t, e.RGBA, e.FLOAT, s10)), s10;
}
var qf = class {
  constructor(e) {
    this.outputTexture = null, this.program = null, this.disposed = false, this.vertexAttrsAreBound = false, this.itemsToPoll = [];
    let t = X2().getNumber("WEBGL_VERSION");
    e != null ? (this.gl = e, p5(t, e)) : this.gl = vs(t);
    let n10 = "WEBGL_color_buffer_float", s10 = "EXT_color_buffer_half_float";
    if (X2().getNumber("WEBGL_VERSION") === 1) {
      let r10 = "OES_texture_float", a10 = "OES_texture_half_float";
      if (this.textureFloatExtension = Du(this.gl, r10), Mn(this.gl, a10))
        this.textureHalfFloatExtension = Du(this.gl, a10);
      else if (X2().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n10), Mn(this.gl, s10))
        this.colorBufferHalfFloatExtension = Du(this.gl, s10);
      else if (X2().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n10 = "EXT_color_buffer_float", Mn(this.gl, n10))
      this.colorBufferFloatExtension = this.gl.getExtension(n10);
    else if (Mn(this.gl, s10))
      this.colorBufferHalfFloatExtension = this.gl.getExtension(s10);
    else
      throw new Error("GL context does not support color renderable floats");
    this.vertexBuffer = l1(this.gl), this.indexBuffer = c1(this.gl), this.framebuffer = GC(this.gl), this.textureConfig = lv(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return X2().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed)
      return;
    this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    let e = this.gl;
    fe2(e, () => e.finish()), fe2(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), fe2(e, () => e.deleteFramebuffer(this.framebuffer)), fe2(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), fe2(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), fe2(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = true;
  }
  createFloat32MatrixTexture(e, t) {
    return this.throwIfDisposed(), d1(this.gl, e, t, this.textureConfig);
  }
  createFloat16MatrixTexture(e, t) {
    return this.throwIfDisposed(), p1(this.gl, e, t, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(e, t) {
    return this.throwIfDisposed(), h1(this.gl, e, t, this.textureConfig);
  }
  uploadPixelDataToTexture(e, t) {
    this.throwIfDisposed(), y1(this.gl, e, t);
  }
  uploadDenseMatrixToTexture(e, t, n10, s10) {
    this.throwIfDisposed(), b1(this.gl, e, t, n10, s10, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), m1(this.gl, e, t, this.textureConfig);
  }
  createPackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), f1(this.gl, e, t, this.textureConfig);
  }
  deleteMatrixTexture(e) {
    this.throwIfDisposed(), this.outputTexture === e && (Lm(this.gl, this.framebuffer), this.outputTexture = null), fe2(this.gl, () => this.gl.deleteTexture(e));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n10) {
    return this.downloadMatrixDriver(e, () => w1(this.gl, t, n10, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(e, t, n10, s10, r10, a10) {
    return k1(this.gl, e, t, n10, s10, r10, a10, this.textureConfig);
  }
  downloadFloat32MatrixFromBuffer(e, t) {
    return x1(this.gl, e, t);
  }
  createBufferFromTexture(e, t, n10) {
    this.bindTextureToFrameBuffer(e);
    let s10 = v1(this.gl, t, n10, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), s10;
  }
  createAndWaitForFence() {
    let e = this.createFence(this.gl);
    return this.pollFence(e);
  }
  createFence(e) {
    let t, n10;
    if (X2().getBool("WEBGL_FENCE_API_ENABLED")) {
      let s10 = e, r10 = s10.fenceSync(s10.SYNC_GPU_COMMANDS_COMPLETE, 0);
      e.flush(), n10 = () => {
        let a10 = s10.clientWaitSync(r10, 0, 0);
        return a10 === s10.ALREADY_SIGNALED || a10 === s10.CONDITION_SATISFIED;
      }, t = r10;
    } else
      X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n10 = () => this.isQueryAvailable(t, X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n10 = () => true;
    return { query: t, isFencePassed: n10 };
  }
  downloadMatrixFromPackedTexture(e, t, n10) {
    return this.downloadMatrixDriver(e, () => I1(this.gl, t, n10));
  }
  createProgram(e) {
    this.throwIfDisposed();
    let t = this.gl;
    this.vertexShader == null && (this.vertexShader = u1(t));
    let n10 = MC(t);
    return fe2(t, () => t.attachShader(n10, this.vertexShader)), fe2(t, () => t.attachShader(n10, e)), LC(t, n10), this.debug && sd(t, n10), this.vertexAttrsAreBound || (this.setProgram(n10), this.vertexAttrsAreBound = g1(t, this.program, this.vertexBuffer)), n10;
  }
  deleteProgram(e) {
    this.throwIfDisposed(), e === this.program && (this.program = null), e != null && fe2(this.gl, () => this.gl.deleteProgram(e));
  }
  setProgram(e) {
    this.throwIfDisposed(), this.program = e, this.program != null && this.debug && sd(this.gl, this.program), fe2(this.gl, () => this.gl.useProgram(e));
  }
  getUniformLocation(e, t, n10 = true) {
    return this.throwIfDisposed(), n10 ? qC(this.gl, e, t) : jC(this.gl, e, t);
  }
  getAttributeLocation(e, t) {
    return this.throwIfDisposed(), fe2(this.gl, () => this.gl.getAttribLocation(e, t));
  }
  getUniformLocationNoThrow(e, t) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
  }
  setInputMatrixTexture(e, t, n10) {
    this.throwIfDisposed(), this.throwIfNoProgram(), KC(this.gl, e, t, n10);
  }
  setOutputMatrixTexture(e, t, n10) {
    this.setOutputMatrixTextureDriver(e, n10, t);
  }
  setOutputPackedMatrixTexture(e, t, n10) {
    this.throwIfDisposed();
    let [s10, r10] = eu(t, n10);
    this.setOutputMatrixTextureDriver(e, s10, r10);
  }
  setOutputMatrixWriteRegion(e, t, n10, s10) {
    this.setOutputMatrixWriteRegionDriver(n10, e, s10, t);
  }
  setOutputPackedMatrixWriteRegion(e, t, n10, s10) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    this.program != null && sd(this.gl, this.program), Fu(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    let e = this.gl;
    this.debug && this.debugValidate(), fe2(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), fe2(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = Du(this.gl, X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      let n10 = this.gl, s10 = this.getQueryTimerExtensionWebGL2(), r10 = n10.createQuery();
      return n10.beginQuery(s10.TIME_ELAPSED_EXT, r10), r10;
    }
    let e = this.getQueryTimerExtensionWebGL1(), t = e.createQueryEXT();
    return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
  }
  endQuery() {
    if (X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      let t = this.gl, n10 = this.getQueryTimerExtensionWebGL2();
      t.endQuery(n10.TIME_ELAPSED_EXT);
      return;
    }
    let e = this.getQueryTimerExtensionWebGL1();
    e.endQueryEXT(e.TIME_ELAPSED_EXT);
  }
  async waitForQueryAndGetTime(e) {
    return await w2.repeatedTry(() => this.disposed || this.isQueryAvailable(e, X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(e, X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  getQueryTime(e, t) {
    if (t === 0)
      return null;
    if (t === 2) {
      let n10 = this.gl;
      return n10.getQueryParameter(e, n10.QUERY_RESULT) / 1e6;
    } else {
      let n10 = this.getQueryTimerExtensionWebGL1();
      return n10.getQueryObjectEXT(e, n10.QUERY_RESULT_EXT) / 1e6;
    }
  }
  isQueryAvailable(e, t) {
    if (t === 0)
      return true;
    if (t === 2) {
      let n10 = this.gl, s10 = this.getQueryTimerExtensionWebGL2(), r10 = n10.getQueryParameter(e, n10.QUERY_RESULT_AVAILABLE);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(s10.GPU_DISJOINT_EXT)), r10 && !this.disjoint;
    } else {
      let n10 = this.getQueryTimerExtensionWebGL1(), s10 = n10.getQueryObjectEXT(e, n10.QUERY_RESULT_AVAILABLE_EXT);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(n10.GPU_DISJOINT_EXT)), s10 && !this.disjoint;
    }
  }
  pollFence(e) {
    return new Promise((t) => {
      this.addItemToPoll(() => e.isFencePassed(), () => t());
    });
  }
  pollItems() {
    let e = kK(this.itemsToPoll.map((t) => t.isDoneFn));
    for (let t = 0; t <= e; ++t) {
      let { resolveFn: n10 } = this.itemsToPoll[t];
      n10();
    }
    this.itemsToPoll = this.itemsToPoll.slice(e + 1);
  }
  addItemToPoll(e, t) {
    this.itemsToPoll.push({ isDoneFn: e, resolveFn: t }), !(this.itemsToPoll.length > 1) && w2.repeatedTry(() => (this.pollItems(), this.itemsToPoll.length === 0));
  }
  bindTextureToFrameBuffer(e) {
    this.throwIfDisposed(), rd(this.gl, e, this.framebuffer), this.debug && Fu(this.gl);
  }
  unbindTextureToFrameBuffer() {
    this.outputTexture != null ? (rd(this.gl, this.outputTexture, this.framebuffer), this.debug && Fu(this.gl)) : Lm(this.gl, this.framebuffer);
  }
  downloadMatrixDriver(e, t) {
    this.bindTextureToFrameBuffer(e);
    let n10 = t();
    return this.unbindTextureToFrameBuffer(), n10;
  }
  setOutputMatrixTextureDriver(e, t, n10) {
    this.throwIfDisposed();
    let s10 = this.gl;
    rd(s10, e, this.framebuffer), this.debug && Fu(s10), this.outputTexture = e, fe2(s10, () => s10.viewport(0, 0, t, n10)), fe2(s10, () => s10.scissor(0, 0, t, n10));
  }
  setOutputMatrixWriteRegionDriver(e, t, n10, s10) {
    this.throwIfDisposed(), fe2(this.gl, () => this.gl.scissor(e, t, n10, s10));
  }
  throwIfDisposed() {
    if (this.disposed)
      throw new Error("Attempted to use disposed GPGPUContext.");
  }
  throwIfNoProgram() {
    if (this.program == null)
      throw new Error("No GPU program is currently set.");
  }
};
function kK(e) {
  let t = 0;
  for (; t < e.length && e[t](); ++t)
    ;
  return t - 1;
}
var { addImpl: IK, bincountImpl: S1, bincountReduceImpl: SK, ceilImpl: CK, concatImpl: NK, equalImpl: TK, expImpl: $K, expm1Impl: _K, floorImpl: AK, gatherNdImpl: EK, gatherV2Impl: RK, greaterImpl: DK, greaterEqualImpl: FK, lessImpl: OK, lessEqualImpl: PK, linSpaceImpl: zK, logImpl: MK, maxImpl: LK, maximumImpl: BK, minimumImpl: VK, multiplyImpl: WK, negImpl: UK, notEqualImpl: GK, prodImpl: HK, rangeImpl: qK, rsqrtImpl: jK, sigmoidImpl: KK, simpleAbsImpl: C1, sliceImpl: XK, sparseFillEmptyRowsImpl: YK, sparseReshapeImpl: QK, sparseSegmentReductionImpl: N1, sqrtImpl: ZK, stridedSliceImpl: JK, stringNGramsImpl: eX, stringSplitImpl: tX, stringToHashBucketFastImpl: nX, subImpl: sX, tileImpl: rX, topKImpl: aX, transposeImpl: yv, uniqueImpl: iX } = Yy;
function T1(e, t) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((n10) => `${e}.${n10}`);
}
function un(e, t) {
  return t === 1 ? [e] : T1(e, t);
}
function oX(e, t) {
  if (e === 1)
    return "rc";
  let n10 = "";
  for (let s10 = 0; s10 < e; s10++)
    n10 += t[s10], s10 < e - 1 && (n10 += ",");
  return n10;
}
var uX = class {
  constructor(e) {
    if (this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = e, this.rank = e.length, this.enableShapeUniforms = kn(this.outputShape.length), this.rank === 0)
      this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
    else {
      let t = un("rc", this.rank), n10 = ot(this.rank), s10 = this.getOutOfBoundsCondition(t), r10 = this.getSetup(t), a10 = this.getOutput(t);
      this.userCode = `
        void main() {
          ${n10} rc = getOutputCoords();

          if(${s10}) {
            setOutput(vec4(0));
          } else {
            ${r10}

            setOutput(vec4(${a10}));
          }
        }
      `;
    }
  }
  getSourceCoordsArr(e) {
    let t = [];
    for (let n10 = 0; n10 <= 1; n10++)
      for (let s10 = 0; s10 <= 1; s10++) {
        let r10 = `${n10 === 0 ? "r" : "rp1"}, ${s10 === 0 ? "c" : "cp1"}`;
        for (let a10 = 2; a10 < this.rank; a10++)
          r10 = `${e[e.length - 1 - a10]},` + r10;
        t.push(r10);
      }
    return t;
  }
  getOutOfBoundsCondition(e) {
    if (this.rank === 1)
      return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
    let t = "";
    for (let n10 = this.rank - 2; n10 < this.rank; n10++)
      t += `${e[n10]} >= ${this.enableShapeUniforms ? `outShape[${n10}]` : this.outputShape[n10]}`, n10 < this.rank - 1 && (t += "||");
    return t;
  }
  getSetup(e) {
    if (this.rank === 1)
      return "";
    let t = e.slice(-2), n10 = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], s10 = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
    return `
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n10};
      bool rEdge = rp1 >= ${s10};
    `;
  }
  getOutput(e) {
    let t = this.getSourceCoordsArr(e);
    return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`;
  }
};
var $1 = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length);
    let n10 = "";
    for (let s10 = 0; s10 < 4; s10++) {
      let r10 = "thisRC = rc;";
      s10 % 2 === 1 && (r10 += "thisRC.z += 1;"), s10 > 1 && (r10 += "thisRC.y += 1;"), n10 += `
        ${r10}
        ${s10 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s10}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s10 > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${lX(t, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? dv() : cv(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e[2]};

        ${n10}

        setOutput(result);
      }
    `;
  }
};
function lX(e, t) {
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t ? _5(["r", "c", "d"], "inputShape") : gi(["r", "c", "d"], e)}
      return ivec3(r, c, d);
    }
  `;
}
var cX = class {
  constructor(e) {
    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
  }
  acquireTexture(e, t, n10) {
    let s10 = sw(t, n10), r10 = rw(e, s10, n10);
    r10 in this.freeTextures || (this.freeTextures[r10] = []), r10 in this.usedTextures || (this.usedTextures[r10] = []);
    let a10 = nw(e, s10, this.gpgpu.gl, this.gpgpu.textureConfig, n10);
    if (this.freeTextures[r10].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a10, this.log();
      let o10 = this.freeTextures[r10].shift();
      return this.usedTextures[r10].push(o10), o10;
    }
    let i10;
    return s10 === 3 ? i10 = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : s10 === 4 ? i10 = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : s10 === 1 ? i10 = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : s10 === 0 ? i10 = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : s10 === 2 && (i10 = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r10].push(i10), this.numUsedTextures++, this._numBytesAllocated += a10, this.log(), i10;
  }
  releaseTexture(e, t, n10, s10) {
    if (this.freeTextures == null)
      return;
    let r10 = sw(n10, s10), a10 = rw(t, r10, s10);
    a10 in this.freeTextures || (this.freeTextures[a10] = []);
    let i10 = nw(t, r10, this.gpgpu.gl, this.gpgpu.textureConfig, s10), o10 = X2().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
    o10 !== -1 && this._numBytesAllocated > o10 ? (this.gpgpu.deleteMatrixTexture(e.texture), this._numBytesAllocated -= i10) : (this.freeTextures[a10].push(e), this.numFreeTextures++, this._numBytesFree += i10), this.numUsedTextures--;
    let u10 = this.usedTextures[a10], l10 = u10.indexOf(e);
    if (l10 < 0)
      throw new Error("Cannot release a texture that was never provided by this texture manager");
    u10.splice(l10, 1), this.log();
  }
  log() {
    if (!this.logEnabled)
      return;
    let e = this.numFreeTextures + this.numUsedTextures;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
    let t = this._numBytesFree / this._numBytesAllocated;
    console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * t)}%)`);
  }
  get numBytesAllocated() {
    return this._numBytesAllocated;
  }
  get numBytesFree() {
    return this._numBytesFree;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (this.freeTextures != null) {
      for (let e in this.freeTextures)
        this.freeTextures[e].forEach((t) => {
          this.gpgpu.deleteMatrixTexture(t.texture);
        });
      for (let e in this.usedTextures)
        this.usedTextures[e].forEach((t) => {
          this.gpgpu.deleteMatrixTexture(t.texture);
        });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
    }
  }
};
function dX(e, t) {
  let n10 = e;
  if (t === n10.R32F)
    return 4;
  if (t === n10.R16F)
    return 2;
  if (t === n10.RGBA32F)
    return 16;
  if (t === e.RGBA)
    return 16;
  if (t === n10.RGBA16F)
    return 8;
  if (t === n10.RGBA8)
    return 4;
  throw new Error(`Unknown internal format ${t}`);
}
function nw(e, t, n10, s10, r10) {
  let a10 = pX(t, s10), i10;
  if (r10) {
    let [u10, l10] = eu(e[0], e[1]);
    i10 = u10 * l10;
  } else {
    let [u10, l10] = Xl(e[0], e[1]);
    i10 = u10 * l10;
  }
  let o10 = dX(n10, a10);
  return i10 * o10;
}
function pX(e, t) {
  switch (e) {
    case 3:
      return gv(t);
    case 4:
      return bv(t);
    case 1:
      return hv(t);
    case 0:
      return fv(t);
    case 2:
      return mv(t);
    default:
      throw new Error(`Unknown physical texture type ${e}`);
  }
}
function hX(e) {
  return X2().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? 3 : 1 : e ? 4 : 0;
}
function sw(e, t) {
  if (e === 1)
    return 3;
  if (e === 0 || e == null)
    return hX(t);
  if (e === 3 || e === 2)
    return 2;
  throw new Error(`Unknown logical texture type ${e}`);
}
function rw(e, t, n10) {
  return `${e[0]}_${e[1]}_${t}_${n10}`;
}
var Hs = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var ts = "if (isnan(x)) return x;";
var fX = "return x;";
var aw = "return abs(x);";
var mX = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
var gX = ts + `
  return (x < 0.0) ? 0.0 : x;
`;
var bX = ts + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
var Pi = "return x;";
var yX = "return 1.0 / (1.0 + exp(-1.0 * x));";
var vX = "return x;";
var xX = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
var wX = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var kX = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var IX = "return 1.0 / (1.0 + exp(-1.0 * x));";
var Yr = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var SX = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length);
    let t = e.length, n10 = un("rc", t), s10 = ot(t), r10 = oX(t, n10), a10 = n10.slice(-2), i10 = t <= 1 ? "rc" : `vec2(${a10.join(",")})`;
    this.userCode = `
      void main() {
        ${s10} rc = getOutputCoords();
        vec4 packedInput = getA(${r10});

        setOutput(getChannel(packedInput, ${i10}));
      }
    `;
  }
};
var CX = xs.whereImpl;
var NX = 1e-7;
var TX = 1e-4;
var Qc = {};
function $X(e) {
  return e in Qc || (Qc[e] = {}), Qc[e];
}
var _X = X2().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
var AX = 600;
function EX() {
  return X2().global.screen == null ? 1024 : X2().global.screen.height * X2().global.screen.width * window.devicePixelRatio * AX / 1024 / 1024;
}
var _1 = class extends tl {
  constructor(e) {
    super();
    if (this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !X2().getBool("HAS_WEBGL"))
      throw new Error("WebGL is not supported on this device");
    let t;
    if (e != null) {
      if (e instanceof qf)
        t = e;
      else {
        let n10 = vs(X2().getNumber("WEBGL_VERSION"), e);
        t = new qf(n10);
      }
      this.binaryCache = {}, this.gpgpuCreatedLocally = false;
    } else {
      let n10 = vs(X2().getNumber("WEBGL_VERSION"));
      t = new qf(n10), this.binaryCache = $X(X2().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
    }
    this.gpgpu = t, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new cX(this.gpgpu), this.numMBBeforeWarning = EX(), this.texData = new Wd(this, Ss());
  }
  nextDataId() {
    return _1.nextDataId++;
  }
  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }
  write(e, t, n10) {
    if ((X2().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || X2().getBool("DEBUG")) && this.checkNumericalProblems(e), n10 === "complex64" && e != null)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    let s10 = { id: this.nextDataId() };
    return this.texData.set(s10, { shape: t, dtype: n10, values: e, usage: 1, refCount: 1 }), s10;
  }
  refCount(e) {
    return this.texData.has(e) ? this.texData.get(e).refCount : 0;
  }
  incRef(e) {
    let t = this.texData.get(e);
    t.refCount++;
  }
  decRef(e) {
    if (this.texData.has(e)) {
      let t = this.texData.get(e);
      t.refCount--;
    }
  }
  move(e, t, n10, s10, r10) {
    if (X2().getBool("DEBUG") && this.checkNumericalProblems(t), s10 === "complex64")
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(e, { shape: n10, dtype: s10, values: t, usage: 1, refCount: r10 });
  }
  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }
  readSync(e) {
    let t = this.texData.get(e), { values: n10, dtype: s10, complexTensorInfos: r10, slice: a10, shape: i10, isPacked: o10 } = t;
    if (a10 != null) {
      let p10;
      o10 ? p10 = new Yr(i10, Pi) : p10 = new Hs(i10, Pi);
      let d10 = this.runWebGLProgram(p10, [{ dataId: e, shape: i10, dtype: s10 }], s10), h10 = this.readSync(d10.dataId);
      return this.disposeIntermediateTensorInfo(d10), h10;
    }
    if (n10 != null)
      return this.convertAndCacheOnCPU(e);
    if (s10 === "string")
      return n10;
    let u10 = this.activeTimers != null, l10;
    u10 && (l10 = w2.now());
    let c10;
    if (s10 === "complex64") {
      let p10 = this.readSync(r10.real.dataId), d10 = this.readSync(r10.imag.dataId);
      c10 = N2.mergeRealAndImagArrays(p10, d10);
    } else
      c10 = this.getValuesFromTexture(e);
    return u10 && (this.downloadWaitMs += w2.now() - l10), this.convertAndCacheOnCPU(e, c10);
  }
  async read(e) {
    if (this.pendingRead.has(e)) {
      let h10 = this.pendingRead.get(e);
      return new Promise((f10) => h10.push(f10));
    }
    let t = this.texData.get(e), { values: n10, shape: s10, slice: r10, dtype: a10, complexTensorInfos: i10, isPacked: o10 } = t;
    if (r10 != null) {
      let h10;
      o10 ? h10 = new Yr(s10, Pi) : h10 = new Hs(s10, Pi);
      let f10 = this.runWebGLProgram(h10, [{ dataId: e, shape: s10, dtype: a10 }], a10), m10 = this.read(f10.dataId);
      return this.disposeIntermediateTensorInfo(f10), m10;
    }
    if (n10 != null)
      return this.convertAndCacheOnCPU(e);
    if (X2().getBool("DEBUG") && !X2().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && X2().getNumber("WEBGL_VERSION") === 2)
      throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
    let u10 = null, l10;
    if (a10 !== "complex64" && X2().get("WEBGL_BUFFER_SUPPORTED")) {
      l10 = this.decode(e);
      let h10 = this.texData.get(l10.dataId);
      u10 = this.gpgpu.createBufferFromTexture(h10.texture.texture, ...Xc(s10));
    }
    this.pendingRead.set(e, []), a10 !== "complex64" && await this.gpgpu.createAndWaitForFence();
    let c10;
    if (a10 === "complex64") {
      let h10 = await Promise.all([this.read(i10.real.dataId), this.read(i10.imag.dataId)]), f10 = h10[0], m10 = h10[1];
      c10 = N2.mergeRealAndImagArrays(f10, m10);
    } else if (u10 == null)
      c10 = this.getValuesFromTexture(e);
    else {
      let h10 = w2.sizeFromShape(s10);
      c10 = this.gpgpu.downloadFloat32MatrixFromBuffer(u10, h10);
    }
    if (l10 != null && this.disposeIntermediateTensorInfo(l10), u10 != null) {
      let h10 = this.gpgpu.gl;
      fe2(h10, () => h10.deleteBuffer(u10));
    }
    let p10 = this.convertAndCacheOnCPU(e, c10), d10 = this.pendingRead.get(e);
    return this.pendingRead.delete(e), d10.forEach((h10) => h10(p10)), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e) && Ss().removeDataId(e, this), this.pendingDeletes--), p10;
  }
  readToGPU(e, t = {}) {
    let n10 = this.texData.get(e), { values: s10, shape: r10, slice: a10, dtype: i10, isPacked: o10, texture: u10 } = n10;
    if (i10 === "complex64")
      throw new Error("Does not support reading texture for complex64 dtype.");
    if (a10 != null) {
      let d10;
      o10 ? d10 = new Yr(r10, Pi) : d10 = new Hs(r10, Pi);
      let h10 = this.runWebGLProgram(d10, [{ dataId: e, shape: r10, dtype: i10 }], i10), f10 = this.readToGPU(h10, t);
      return this.disposeIntermediateTensorInfo(h10), f10;
    }
    if (u10 == null)
      throw s10 != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
    let l10 = this.decode(e, t.customTexShape), c10 = Ss().makeTensorFromDataId(l10.dataId, l10.shape, l10.dtype), p10 = this.texData.get(l10.dataId);
    return { tensorRef: c10, ...p10.texture };
  }
  bufferSync(e) {
    let t = this.readSync(e.dataId), n10 = t;
    if (e.dtype === "string")
      try {
        n10 = t.map((s10) => w2.decodeString(s10));
      } catch (s10) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return De(e.shape, e.dtype, n10);
  }
  checkNumericalProblems(e) {
    if (e != null)
      for (let t = 0; t < e.length; t++) {
        let n10 = e[t];
        if (!FC(n10))
          throw X2().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${n10} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${n10} cannot be represented on this device.`);
      }
  }
  getValuesFromTexture(e) {
    let { shape: t, dtype: n10, isPacked: s10 } = this.texData.get(e), r10 = w2.sizeFromShape(t);
    if (X2().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      let p10 = this.decode(e), d10 = this.texData.get(p10.dataId), h10 = this.gpgpu.downloadMatrixFromPackedTexture(d10.texture.texture, ...Xc(t)).subarray(0, r10);
      return this.disposeIntermediateTensorInfo(p10), h10;
    }
    let a10 = X2().getBool("WEBGL_PACK") && s10 === true, i10 = a10 ? ad(t) : t, o10 = a10 ? new yK(i10) : new bK(i10), u10 = this.runWebGLProgram(o10, [{ shape: i10, dtype: n10, dataId: e }], "float32"), l10 = this.texData.get(u10.dataId), c10 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l10.texture.texture, l10.texShape[0], l10.texShape[1]).subarray(0, r10);
    return this.disposeIntermediateTensorInfo(u10), c10;
  }
  timerAvailable() {
    return X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  time(e) {
    let t = this.activeTimers, n10 = [], s10 = false;
    this.programTimersStack == null ? (this.programTimersStack = n10, s10 = true) : this.activeTimers.push(n10), this.activeTimers = n10, e();
    let r10 = w2.flatten(this.activeTimers.map((o10) => o10.query)).filter((o10) => o10 != null), a10 = w2.flatten(this.activeTimers.map((o10) => o10.name)).filter((o10) => o10 != null);
    this.activeTimers = t, s10 && (this.programTimersStack = null);
    let i10 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null };
    return (async () => {
      if (X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        let o10 = await Promise.all(r10);
        i10.kernelMs = w2.sum(o10), i10.getExtraProfileInfo = () => o10.map((u10, l10) => ({ name: a10[l10], ms: u10 })).map((u10) => `${u10.name}: ${u10.ms}`).join(", ");
      } else
        i10.kernelMs = { error: "WebGL query timers are not supported in this environment." };
      return this.uploadWaitMs = 0, this.downloadWaitMs = 0, i10;
    })();
  }
  memory() {
    return { unreliable: false, numBytesInGPU: this.numBytesInGPU, numBytesInGPUAllocated: this.textureManager.numBytesAllocated, numBytesInGPUFree: this.textureManager.numBytesFree };
  }
  startTimer() {
    return X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: w2.now(), endMs: null };
  }
  endTimer(e) {
    return X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = w2.now(), e);
  }
  async getQueryTime(e) {
    if (X2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
      return this.gpgpu.waitForQueryAndGetTime(e);
    let t = e;
    return t.endMs - t.startMs;
  }
  disposeData(e, t = false) {
    if (this.pendingDisposal.has(e))
      return false;
    if (!this.texData.has(e))
      return true;
    if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0)
      return false;
    if (this.pendingRead.has(e))
      return this.pendingDisposal.add(e), this.pendingDeletes++, false;
    this.releaseGPUData(e);
    let { complexTensorInfos: n10 } = this.texData.get(e);
    return n10 != null && (this.disposeData(n10.real.dataId, t), this.disposeData(n10.imag.dataId, t)), this.texData.delete(e), true;
  }
  releaseGPUData(e) {
    let { texture: t, dtype: n10, texShape: s10, usage: r10, isPacked: a10, slice: i10 } = this.texData.get(e), o10 = i10 && i10.origDataId || e, u10 = this.dataRefCount.get(o10);
    u10 > 1 ? this.dataRefCount.set(o10, u10 - 1) : (this.dataRefCount.delete(o10), t != null && (this.numBytesInGPU -= this.computeBytes(s10, n10), this.textureManager.releaseTexture(t, s10, r10, a10)));
    let l10 = this.texData.get(e);
    l10.texture = null, l10.texShape = null, l10.isPacked = false, l10.slice = null;
  }
  getTexture(e) {
    return this.uploadToGPU(e), this.texData.get(e).texture.texture;
  }
  getDataInfo(e) {
    return this.texData.get(e);
  }
  shouldExecuteOnCPU(e, t = _X) {
    return X2().getBool("WEBGL_CPU_FORWARD") && e.every((n10) => this.texData.get(n10.dataId).texture == null && w2.sizeFromShape(n10.shape) < t);
  }
  getGPGPUContext() {
    return this.gpgpu;
  }
  where(e) {
    N2.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    let t = e.dataSync();
    return CX(e.shape, t);
  }
  packedUnaryOp(e, t, n10) {
    let s10 = new Yr(e.shape, t), r10 = this.compileAndRun(s10, [e], n10);
    return Ss().makeTensorFromDataId(r10.dataId, r10.shape, r10.dtype);
  }
  abs(e) {
    if (this.shouldExecuteOnCPU([e]) && e.dtype !== "complex64") {
      let s10 = C1(this.texData.get(e.dataId).values);
      return this.makeOutput(e.shape, e.dtype, s10);
    }
    if (X2().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(e, aw, e.dtype);
    let t = new Hs(e.shape, aw), n10 = this.compileAndRun(t, [e]);
    return Ss().makeTensorFromDataId(n10.dataId, n10.shape, n10.dtype);
  }
  makeTensorInfo(e, t, n10) {
    let s10;
    if (t === "string" && n10 != null && n10.length > 0 && w2.isString(n10[0])) {
      let r10 = n10.map((a10) => w2.encodeString(a10));
      s10 = this.write(r10, e, t);
    } else
      s10 = this.write(n10, e, t);
    return this.texData.get(s10).usage = null, { dataId: s10, shape: e, dtype: t };
  }
  makeOutput(e, t, n10) {
    let { dataId: s10 } = this.makeTensorInfo(e, t, n10);
    return Ss().makeTensorFromDataId(s10, e, t, this);
  }
  unpackTensor(e) {
    let t = new SX(e.shape);
    return this.runWebGLProgram(t, [e], e.dtype);
  }
  packTensor(e) {
    let t = new uX(e.shape), n10 = true;
    return this.runWebGLProgram(t, [e], e.dtype, null, n10);
  }
  packedReshape(e, t) {
    let n10 = [ma(e.shape), ...ga(e.shape)], s10 = { dtype: e.dtype, shape: n10, dataId: e.dataId }, r10 = [ma(t), ...ga(t)], a10 = new $1(r10, n10), i10 = true, o10 = [n10], u10 = this.runWebGLProgram(a10, [s10], e.dtype, o10, i10);
    return { dataId: u10.dataId, shape: t, dtype: u10.dtype };
  }
  decode(e, t) {
    let n10 = this.texData.get(e), { isPacked: s10, shape: r10, dtype: a10 } = n10;
    if (t != null) {
      let p10 = w2.sizeFromShape(r10), d10 = t[0] * t[1] * 4;
      w2.assert(p10 <= d10, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
    }
    let i10 = ad(r10), o10;
    s10 ? o10 = new gK(i10) : o10 = new mK(i10);
    let u10 = true, l10 = [t != null ? t : Xc(i10)], c10 = this.runWebGLProgram(o10, [{ shape: i10, dtype: a10, dataId: e }], a10, l10, u10, t);
    return { dtype: a10, shape: r10, dataId: c10.dataId };
  }
  runWebGLProgram(e, t, n10, s10, r10 = false, a10) {
    let i10 = this.makeTensorInfo(e.outputShape, n10), o10 = this.texData.get(i10.dataId);
    if (e.packedOutput && (o10.isPacked = true), e.outPackingScheme === 0) {
      let g10 = a10 != null ? a10 : Xc(e.outputShape);
      o10.texShape = g10.map((b10) => b10 * 2);
    }
    if (e.outTexUsage != null && (o10.usage = e.outTexUsage), w2.sizeFromShape(i10.shape) === 0)
      return o10.values = w2.getTypedArrayFromDType(i10.dtype, 0), i10;
    let u10 = [], l10 = t.map((g10) => {
      if (g10.dtype === "complex64")
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      let b10 = this.texData.get(g10.dataId);
      if (b10.texture == null) {
        if (!e.packedInputs && w2.sizeFromShape(g10.shape) <= X2().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
          return { shape: g10.shape, texData: null, isUniform: true, uniformValues: b10.values };
        e.packedInputs && (b10.isPacked = true, b10.shape = g10.shape);
      }
      if (this.uploadToGPU(g10.dataId), !!b10.isPacked != !!e.packedInputs)
        g10 = b10.isPacked ? this.unpackTensor(g10) : this.packTensor(g10), u10.push(g10), b10 = this.texData.get(g10.dataId);
      else if (b10.isPacked && !Ju(b10.shape, g10.shape)) {
        let y10 = g10, v10 = g10.shape;
        g10.shape = b10.shape, g10 = this.packedReshape(g10, v10), u10.push(g10), b10 = this.texData.get(g10.dataId), y10.shape = v10;
      }
      return { shape: g10.shape, texData: b10, isUniform: false };
    });
    this.uploadToGPU(i10.dataId);
    let c10 = { shape: i10.shape, texData: o10, isUniform: false }, p10 = fK(e, l10, c10), d10 = this.getAndSaveBinary(p10, () => pK(this.gpgpu, e, l10, c10)), h10 = this.activeTimers != null, f10;
    h10 && (f10 = this.startTimer()), hK(this.gpgpu, d10, l10, c10, s10), u10.forEach((g10) => this.disposeIntermediateTensorInfo(g10)), h10 && (f10 = this.endTimer(f10), this.activeTimers.push({ name: e.constructor.name, query: this.getQueryTime(f10) }));
    let m10 = X2().get("WEBGL_FLUSH_THRESHOLD");
    if (m10 > 0) {
      let g10 = w2.now();
      g10 - this.lastGlFlushTime > m10 && (this.gpgpu.gl.flush(), this.lastGlFlushTime = g10);
    }
    if (!X2().getBool("WEBGL_LAZILY_UNPACK") && o10.isPacked && r10 === false) {
      let g10 = this.unpackTensor(i10);
      return this.disposeIntermediateTensorInfo(i10), g10;
    }
    return i10;
  }
  compileAndRun(e, t, n10, s10, r10 = false) {
    return n10 = n10 || t[0].dtype, this.runWebGLProgram(e, t, n10, s10, r10);
  }
  getAndSaveBinary(e, t) {
    return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
  }
  getTextureManager() {
    return this.textureManager;
  }
  dispose() {
    this.disposed || (X2().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((t) => {
      this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram), delete this.binaryCache[t];
    }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement != "undefined" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
  }
  floatPrecision() {
    return this.floatPrecisionValue == null && (this.floatPrecisionValue = j2(() => {
      if (!X2().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        let e = X2().getBool("DEBUG");
        X2().set("DEBUG", false);
        let t = this.abs(Ie2(1e-8)).dataSync()[0];
        if (X2().set("DEBUG", e), t > 0)
          return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }
  epsilon() {
    return this.floatPrecision() === 32 ? NX : TX;
  }
  uploadToGPU(e) {
    let t = this.texData.get(e), { shape: n10, dtype: s10, values: r10, texture: a10, usage: i10, isPacked: o10 } = t;
    if (a10 != null)
      return;
    let u10 = this.activeTimers != null, l10;
    u10 && (l10 = w2.now());
    let c10 = t.texShape;
    if (c10 == null && (c10 = QC(n10, o10), t.texShape = c10), r10 != null) {
      let p10 = ad(n10), d10, h10 = c10[1], f10 = c10[0], m10 = r10 instanceof Uint8Array || r10 instanceof Uint8ClampedArray;
      (o10 || !m10) && ([h10, f10] = eu(c10[0], c10[1])), o10 ? d10 = new xK(p10, m10) : d10 = new vK(p10, m10);
      let g10 = m10 ? [f10, h10] : c10, b10 = this.makeTensorInfo(g10, s10), y10 = this.texData.get(b10.dataId);
      m10 ? y10.usage = 2 : y10.usage = 1, y10.texShape = g10, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b10.dataId), h10, f10, r10);
      let v10 = [[f10, h10]], x10 = true, k10 = this.runWebGLProgram(d10, [b10], s10, v10, x10), C10 = this.texData.get(k10.dataId);
      t.texture = C10.texture, t.texShape = C10.texShape, t.isPacked = C10.isPacked, t.usage = C10.usage, this.disposeIntermediateTensorInfo(b10), this.texData.delete(k10.dataId), t.values = null, u10 && (this.uploadWaitMs += w2.now() - l10);
    } else {
      let p10 = this.acquireTexture(c10, i10, s10, o10);
      t.texture = p10;
    }
  }
  convertAndCacheOnCPU(e, t) {
    let n10 = this.texData.get(e), { dtype: s10 } = n10;
    return this.releaseGPUData(e), t != null && (n10.values = RX(t, s10)), n10.values;
  }
  acquireTexture(e, t, n10, s10) {
    if (this.numBytesInGPU += this.computeBytes(e, n10), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
      let r10 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${r10} MB, most likely due to a memory leak`);
    }
    return this.textureManager.acquireTexture(e, t, s10);
  }
  computeBytes(e, t) {
    return e[0] * e[1] * w2.bytesPerElement(t);
  }
};
var A1 = _1;
A1.nextDataId = 0;
function RX(e, t) {
  if (t === "float32" || t === "complex64")
    return e;
  if (t === "int32" || t === "bool") {
    let n10 = t === "int32" ? new Int32Array(e.length) : new Uint8Array(e.length);
    for (let s10 = 0; s10 < n10.length; ++s10)
      n10[s10] = Math.round(e[s10]);
    return n10;
  } else
    throw new Error(`Unknown dtype ${t}`);
}
var xpe = "0.0.0";
function DX() {
  X2().set("WEBGL_FORCE_F16_TEXTURES", true);
}
cp.isBrowser() && dp("webgl", () => new A1(), 2);
var wpe = { forceHalfFloat: DX };
var E1 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
var no = class {
  constructor(e, t, n10) {
    this.variableNames = ["A", "B"], this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.enableShapeUniforms = kn(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
};
var qp = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
var Ql = class {
  constructor(e, t, n10, s10 = false) {
    this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = N2.assertAndGetBroadcastShape(t, n10);
    let r10 = this.outputShape.length;
    this.enableShapeUniforms = kn(r10);
    let a10 = "";
    if (s10)
      if (r10 === 0 || w2.sizeFromShape(this.outputShape) === 1)
        a10 = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (a10 = `
          ${ot(r10)} coords = getOutputCoords();
        `, r10 === 1)
        this.enableShapeUniforms ? a10 += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : a10 += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        let o10 = un("coords", r10);
        this.enableShapeUniforms ? a10 += `
            bool nextRowOutOfBounds =
              (${o10[r10 - 2]} + 1) >= outShape[${r10} - 2];
            bool nextColOutOfBounds =
              (${o10[r10 - 1]} + 1) >= outShape[${r10} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : a10 += `
            bool nextRowOutOfBounds =
              (${o10[r10 - 2]} + 1) >= ${this.outputShape[r10 - 2]};
            bool nextColOutOfBounds =
              (${o10[r10 - 1]} + 1) >= ${this.outputShape[r10 - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a10}

        setOutput(result);
      }
    `;
  }
};
function En(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  return n10.incRef(s10.dataId), { dataId: s10.dataId, shape: s10.shape, dtype: s10.dtype };
}
var FX = { kernelName: Ma, backendName: "webgl", kernelFunc: En };
function Er(e) {
  let { inputs: t, backend: n10 } = e, { real: s10, imag: r10 } = t, a10 = n10.makeTensorInfo(s10.shape, "complex64"), i10 = n10.texData.get(a10.dataId), o10 = En({ inputs: { x: s10 }, backend: n10 }), u10 = En({ inputs: { x: r10 }, backend: n10 });
  return i10.complexTensorInfos = { real: o10, imag: u10 }, a10;
}
var OX = { kernelName: qd, backendName: "webgl", kernelFunc: Er };
var R1 = "return (a < 0.) ? b * a : a;";
var D1 = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function PX(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { alpha: a10 } = s10, i10 = n10.makeTensorInfo([], "float32", w2.createScalarValue(a10, "float32")), o10 = X2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ql(D1, r10.shape, i10.shape) : new no(R1, r10.shape, i10.shape), u10 = n10.runWebGLProgram(o10, [r10, i10], "float32");
  return n10.disposeIntermediateTensorInfo(i10), u10;
}
var zX = { kernelName: La, backendName: "webgl", kernelFunc: PX };
var F1 = "return (a < 0.) ? b * a : a;";
var O1 = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function MX(e) {
  let { inputs: t, backend: n10 } = e, { x: s10, alpha: r10 } = t, a10 = X2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ql(O1, s10.shape, r10.shape) : new no(F1, s10.shape, r10.shape);
  return n10.runWebGLProgram(a10, [s10, r10], "float32");
}
var LX = { kernelName: Qa, backendName: "webgl", kernelFunc: MX };
var iu = "if (isnan(x)) return x;";
var BX = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
var VX = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
function Ke({ opSnippet: e, packedOpSnippet: t, cpuKernelImpl: n10, dtype: s10 }) {
  return ({ inputs: r10, backend: a10 }) => {
    let { x: i10 } = r10, o10 = a10, u10 = s10 || i10.dtype;
    if (o10.shouldExecuteOnCPU([i10]) && n10 != null) {
      let p10 = o10.texData.get(i10.dataId), d10 = n10(p10.values, u10);
      return o10.makeTensorInfo(i10.shape, u10, d10);
    }
    let l10 = X2().getBool("WEBGL_PACK_UNARY_OPERATIONS") && t != null, c10;
    return l10 ? c10 = new Yr(i10.shape, t) : c10 = new Hs(i10.shape, e), o10.runWebGLProgram(c10, [i10], u10);
  };
}
function qt({ opSnippet: e, packedOpSnippet: t, checkOutOfBounds: n10 = false, supportsComplex: s10 = false, cpuKernelImpl: r10, dtype: a10 }) {
  return ({ inputs: i10, backend: o10 }) => {
    let { a: u10, b: l10 } = i10, c10 = o10;
    if (s10 && u10.dtype === "complex64") {
      let f10 = c10.texData.get(u10.dataId), m10 = c10.texData.get(l10.dataId), [g10, b10] = [[f10.complexTensorInfos.real, m10.complexTensorInfos.real], [f10.complexTensorInfos.imag, m10.complexTensorInfos.imag]].map((v10) => {
        let [x10, k10] = v10, C10 = { dataId: x10.dataId, dtype: x10.dtype, shape: u10.shape }, T10 = { dataId: k10.dataId, dtype: k10.dtype, shape: l10.shape }, E10 = new no(e, u10.shape, l10.shape);
        return c10.runWebGLProgram(E10, [C10, T10], yn(x10.dtype, k10.dtype));
      }), y10 = Er({ inputs: { real: g10, imag: b10 }, backend: c10 });
      return c10.disposeIntermediateTensorInfo(g10), c10.disposeIntermediateTensorInfo(b10), y10;
    }
    let p10 = a10 || yn(u10.dtype, l10.dtype);
    if ((u10.dtype === "string" || l10.dtype === "string" || c10.shouldExecuteOnCPU([u10, l10])) && r10 != null) {
      let f10 = c10.texData.get(u10.dataId).values, m10 = c10.texData.get(l10.dataId).values, g10 = u10.dtype === "string" ? N2.fromUint8ToStringArray(f10) : f10, b10 = u10.dtype === "string" ? N2.fromUint8ToStringArray(m10) : m10, [y10, v10] = r10(u10.shape, l10.shape, g10, b10, p10), x10 = c10.makeTensorInfo(v10, p10), k10 = c10.texData.get(x10.dataId);
      return k10.values = y10, x10;
    }
    let d10 = X2().getBool("WEBGL_PACK_BINARY_OPERATIONS") && t != null, h10;
    return d10 ? h10 = new Ql(t, u10.shape, l10.shape, n10) : h10 = new no(e, u10.shape, l10.shape), c10.runWebGLProgram(h10, [u10, l10], p10);
  };
}
function jp(e, t = false) {
  if (e === "linear")
    return t ? vX : fX;
  if (e === "relu")
    return t ? wX : gX;
  if (e === "elu")
    return t ? xX : mX;
  if (e === "relu6")
    return t ? kX : bX;
  if (e === "prelu")
    return t ? O1 : F1;
  if (e === "leakyrelu")
    return t ? D1 : R1;
  if (e === "sigmoid")
    return t ? IX : yX;
  throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`);
}
var P1 = class {
  constructor(e, t, n10, s10 = false, r10 = false, a10 = false, i10 = null, o10 = false, u10 = false) {
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = n10, this.enableShapeUniforms = kn(this.outputShape.length);
    let l10 = s10 ? e[1] : e[2], c10 = Math.ceil(l10 / 2), p10 = s10 ? "i * 2, rc.y" : "rc.y, i * 2", d10 = r10 ? "rc.z, i * 2" : "i * 2, rc.z", h10 = s10 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], f10 = r10 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], m10 = "", g10 = "";
    i10 && (o10 ? m10 = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i10}
        }` : u10 ? m10 = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i10}
        }` : m10 = `vec4 activation(vec4 x) {
          ${i10}
        }`, g10 = "result = activation(result);");
    let b10 = a10 ? "result += getBiasAtOutCoords();" : "";
    a10 && this.variableNames.push("bias"), o10 && this.variableNames.push("preluActivationWeights"), u10 && this.variableNames.push("leakyreluAlpha");
    let y10 = "rc.x", v10 = "rc.x";
    e[0] < t[0] ? y10 = `int(min(float(rc.x), ${e[0] - 1}.))` : t[0] < e[0] && (v10 = `int(min(float(rc.x), ${t[0] - 1}.))`), this.userCode = `
      ${m10}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c10}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${c10}; i++) {
          int batchA = ${y10};
          int batchB = ${v10};
          vec4 a = getMatrixA(batchA, ${p10});
          vec4 b = getMatrixB(batchB, ${d10});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h10[0]} * ${f10[0]});
          result += (${h10[1]} * ${f10[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b10}

        ${g10}

        setOutput(result);
      }
    `;
  }
};
var iw = { REAL: "return areal * breal - aimag * bimag;", IMAG: "return areal * bimag + aimag * breal;" };
var ow = class {
  constructor(e, t, n10) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
};
var uw = "return a * b;";
function vv(e) {
  let { inputs: t, backend: n10 } = e, { a: s10, b: r10 } = t, a10 = N2.upcastType(s10.dtype, r10.dtype);
  if (s10.dtype === "complex64") {
    let o10 = n10.texData.get(s10.dataId), u10 = n10.texData.get(r10.dataId), l10 = new ow(iw.REAL, s10.shape, r10.shape), c10 = new ow(iw.IMAG, s10.shape, r10.shape), p10 = [{ dataId: o10.complexTensorInfos.real.dataId, dtype: o10.complexTensorInfos.real.dtype, shape: s10.shape }, { dataId: o10.complexTensorInfos.imag.dataId, dtype: o10.complexTensorInfos.imag.dtype, shape: s10.shape }, { dataId: u10.complexTensorInfos.real.dataId, dtype: u10.complexTensorInfos.real.dtype, shape: r10.shape }, { dataId: u10.complexTensorInfos.imag.dataId, dtype: u10.complexTensorInfos.imag.dtype, shape: r10.shape }], d10 = n10.runWebGLProgram(l10, p10, "float32"), h10 = n10.runWebGLProgram(c10, p10, "float32"), f10 = Er({ inputs: { real: d10, imag: h10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), f10;
  }
  if (n10.shouldExecuteOnCPU([s10, r10])) {
    let o10 = n10.texData.get(s10.dataId), u10 = n10.texData.get(r10.dataId), [l10, c10] = WK(s10.shape, r10.shape, o10.values, u10.values, a10), p10 = n10.makeTensorInfo(c10, a10), d10 = n10.texData.get(p10.dataId);
    return d10.values = l10, p10;
  }
  let i10;
  return X2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? i10 = new Ql(uw, s10.shape, r10.shape) : i10 = new no(uw, s10.shape, r10.shape), n10.runWebGLProgram(i10, [s10, r10], a10);
}
var WX = { kernelName: Ka, backendName: "webgl", kernelFunc: vv };
function UX(e, t, n10) {
  let s10 = [ma(e.shape), ...ga(e.shape)], r10 = { dtype: e.dtype, shape: s10, dataId: e.dataId }, a10 = [ma(t), ...ga(t)], i10 = new $1(a10, s10), o10 = true, u10 = [s10], l10 = n10.runWebGLProgram(i10, [r10], e.dtype, u10, o10);
  return { dataId: l10.dataId, shape: t, dtype: l10.dtype };
}
function he2(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { shape: a10 } = s10, i10 = n10, o10 = w2.sizeFromShape(r10.shape), u10 = w2.inferFromImplicitShape(a10, o10), l10 = w2.sizeFromShape(u10);
  w2.assert(o10 === l10, () => `The new shape (${u10}) has ${l10} elements and the old shape (${r10.shape}) has ${o10} elements. The new shape and old shape must have the same number of elements.`);
  let c10 = i10.texData.get(r10.dataId);
  return c10.isPacked && !Ju(r10.shape, u10) && !(c10.texture !== null && Ju(c10.shape, u10)) ? UX(r10, u10, i10) : (i10.incRef(r10.dataId), { dataId: r10.dataId, shape: u10, dtype: r10.dtype });
}
var GX = { kernelName: Ao, backendName: "webgl", kernelFunc: he2 };
var lw = class {
  constructor(e, t) {
    this.variableNames = ["x"];
    let { windowSize: n10, batchSize: s10, inSize: r10, outSize: a10 } = e;
    this.outputShape = [s10, a10];
    let i10 = Math.floor(n10 / 4) * 4, o10 = n10 % 4, u10 = "sumValue += dot(values, ones);";
    if (t != null) {
      let c10 = 1 / t;
      u10 = `sumValue += dot(values * ${w2.isInt(c10) ? c10.toPrecision(2) : c10}, ones);`;
    }
    let l10 = "";
    r10 % n10 > 0 && (l10 = `
        if (inIdx < 0 || inIdx >= ${r10}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l10}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n10};

        float sumValue = 0.0;

        for (int i = 0; i < ${i10}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u10}
        }

        int inIdx = inOffset + ${i10};
        if (${o10 === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u10}
        } else if (${o10 === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u10}
        } else if (${o10 === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u10}
        }
        setOutput(sumValue);
      }
    `;
  }
};
var HX = class {
  constructor(e, t) {
    this.variableNames = ["x"];
    let { windowSize: n10, batchSize: s10, inSize: r10, outSize: a10 } = e;
    this.outputShape = [s10, a10];
    let i10 = "0.0", o10 = "";
    t === "prod" ? i10 = "1.0" : t === "min" ? (i10 = "1.0 / 1e-20", o10 = "min") : t === "max" && (i10 = "-1.0 / 1e-20", o10 = "max");
    let u10 = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    t === "sum" ? u10 = "sumValue" : t === "prod" ? u10 = "prodValue" : t === "all" ? u10 = "allValue" : t === "any" && (u10 = "anyValue");
    let l10 = Math.floor(n10 / 4) * 4, c10 = n10 % 4, p10 = `
      if (${t === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${t === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o10}(values, minMaxValue);
        if (${t === "min"} || ${t === "max"}) {
          minMaxValue = ${o10}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, d10 = "vec4";
    t === "all" ? (i10 = "1.0", p10 = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d10 = "bvec4") : t === "any" && (i10 = "0.0", p10 = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d10 = "bvec4");
    let h10 = "";
    r10 % n10 > 0 && (h10 = `
        if (inIdx < 0 || inIdx >= ${r10}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${i10};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h10}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n10};

        vec4 minMaxValue = vec4(${i10});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l10}; i += 4) {
          int inIdx = inOffset + i;
          ${d10} values = ${d10}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p10}
        }

        int inIdx = inOffset + ${l10};
        if (${c10 === 1}) {
          ${d10} values = ${d10}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p10}
        } else if (${c10 === 2}) {
          ${d10} values = ${d10}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p10}
        } else if (${c10 === 3}) {
          ${d10} values = ${d10}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p10}
        }
        setOutput(${u10});
      }
    `;
  }
};
function qX(e) {
  let t = [];
  for (; t.length === 0 || t[t.length - 1].outSize !== 1; ) {
    let n10 = t.length ? t[t.length - 1].outSize : e[1], s10 = N2.computeOptimalWindowSize(n10);
    t.push({ inSize: n10, windowSize: s10, outSize: Math.ceil(n10 / s10) });
  }
  return t;
}
function yi(e, t, n10, s10) {
  let r10 = qX(e.shape), a10 = e;
  for (let i10 = 0; i10 < r10.length; i10++) {
    let { inSize: o10, windowSize: u10, outSize: l10 } = r10[i10], c10, p10;
    n10 === "mean" ? c10 = i10 === 0 ? new lw({ windowSize: u10, inSize: o10, batchSize: e.shape[0], outSize: l10 }, o10) : new lw({ windowSize: u10, inSize: o10, batchSize: e.shape[0], outSize: l10 }) : c10 = new HX({ windowSize: u10, inSize: o10, batchSize: e.shape[0], outSize: l10 }, n10), p10 = a10, a10 = s10.runWebGLProgram(c10, [a10], t), p10.dataId !== e.dataId && s10.disposeIntermediateTensorInfo(p10);
  }
  return a10;
}
var jX = class {
  constructor(e, t) {
    this.variableNames = ["A"];
    let n10 = new Array(e.length);
    for (let a10 = 0; a10 < n10.length; a10++)
      n10[a10] = e[t[a10]];
    this.outputShape = n10, this.rank = n10.length;
    let s10 = ot(this.rank), r10 = KX(t);
    this.userCode = `
    void main() {
      ${s10} resRC = getOutputCoords();
      setOutput(getA(${r10}));
    }
    `;
  }
};
function KX(e) {
  let t = e.length;
  if (t > 6)
    throw Error(`Transpose for rank ${t} is not yet supported`);
  let n10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], s10 = new Array(t);
  for (let r10 = 0; r10 < e.length; r10++)
    s10[e[r10]] = n10[r10];
  return s10.join();
}
var XX = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
    let n10 = new Array(e.length);
    for (let l10 = 0; l10 < n10.length; l10++)
      n10[l10] = e[t[l10]];
    if (this.outputShape = n10, this.rank = n10.length, this.rank > 6)
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    let s10 = ot(this.rank), r10 = T1("rc", this.rank), a10 = new Array(this.rank);
    for (let l10 = 0; l10 < t.length; l10++)
      a10[t[l10]] = r10[l10];
    let i10 = `vec2(${a10.slice(-2).join()})`, o10 = `++${r10[this.rank - 1]} < ${n10[this.rank - 1]}`, u10 = `getChannel(getA(${a10.join()}), ${i10})`;
    this.userCode = `
    void main() {
      ${s10} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u10};
      if(${o10}) {
        result[1] = ${u10};
      }
      --${r10[this.rank - 1]};
      if(++${r10[this.rank - 2]} < ${n10[this.rank - 2]}) {
        result[2] = ${u10};
        if(${o10}) {
          result[3] = ${u10};
        }
      }
      setOutput(result);
    }
    `;
  }
};
function Kp(e, t, n10) {
  let s10 = X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new XX(e.shape, t) : new jX(e.shape, t);
  return n10.runWebGLProgram(s10, [e], e.dtype);
}
function YX(e, t, n10, s10) {
  let r10 = t, a10 = e.shape.length, i10 = w2.parseAxisParam(r10, e.shape), o10 = i10, u10 = N2.getAxesPermutation(o10, a10), l10 = u10 != null, c10 = e;
  l10 && (c10 = Kp(e, u10, s10), o10 = N2.getInnerMostAxes(o10.length, a10)), N2.assertAxesAreInnerMostDims("sum", o10, a10);
  let [p10, d10] = N2.computeOutAndReduceShapes(c10.shape, o10), h10 = p10;
  n10 && (h10 = N2.expandShapeToKeepDim(p10, i10));
  let f10 = w2.sizeFromShape(d10), g10 = w2.sizeFromShape(e.shape) / f10, b10 = he2({ inputs: { x: c10 }, attrs: { shape: [g10, f10] }, backend: s10 }), y10 = lp(e.dtype), v10 = yi(b10, y10, "sum", s10), x10 = he2({ inputs: { x: v10 }, attrs: { shape: h10 }, backend: s10 });
  return s10.disposeIntermediateTensorInfo(b10), s10.disposeIntermediateTensorInfo(v10), l10 && s10.disposeIntermediateTensorInfo(c10), x10;
}
function Xp(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  return YX(r10, a10, i10, n10);
}
var QX = { kernelName: ai, backendName: "webgl", kernelFunc: Xp };
function cn(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { perm: a10 } = s10, i10 = n10, o10 = r10.shape.length, u10 = new Array(o10);
  for (let c10 = 0; c10 < u10.length; c10++)
    u10[c10] = r10.shape[a10[c10]];
  let l10;
  if (i10.shouldExecuteOnCPU([r10])) {
    let p10 = i10.texData.get(r10.dataId).values, d10 = yv(p10, r10.shape, r10.dtype, a10, u10);
    l10 = i10.makeTensorInfo(u10, r10.dtype);
    let h10 = i10.texData.get(l10.dataId);
    h10.values = d10;
  } else
    l10 = Kp(r10, a10, i10);
  return l10;
}
var ZX = { kernelName: ci, backendName: "webgl", kernelFunc: cn };
var z1 = 1e3;
function Pd({ a: e, b: t, transposeA: n10, transposeB: s10, backend: r10, bias: a10 = null, preluActivationWeights: i10 = null, leakyreluAlpha: o10 = 0, activation: u10 = null }) {
  let l10 = e.shape.length, c10 = t.shape.length, p10 = n10 ? e.shape[l10 - 2] : e.shape[l10 - 1], d10 = s10 ? t.shape[c10 - 1] : t.shape[c10 - 2], h10 = n10 ? e.shape[l10 - 1] : e.shape[l10 - 2], f10 = s10 ? t.shape[c10 - 2] : t.shape[c10 - 1], m10 = e.shape.slice(0, -2), g10 = t.shape.slice(0, -2), b10 = w2.sizeFromShape(m10), y10 = w2.sizeFromShape(g10), x10 = qo.assertAndGetBroadcastShape(e.shape.slice(0, -2), t.shape.slice(0, -2)).concat([h10, f10]);
  w2.assert(p10 === d10, () => `Error in matMul: inner shapes (${p10}) and (${d10}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n10} and transposeB=${s10} must match.`);
  let k10 = n10 ? [b10, p10, h10] : [b10, h10, p10], C10 = s10 ? [y10, f10, d10] : [y10, d10, f10], T10 = he2({ inputs: { x: e }, backend: r10, attrs: { shape: k10 } }), E10 = he2({ inputs: { x: t }, backend: r10, attrs: { shape: C10 } }), A10 = [T10, E10], P10 = Math.max(b10, y10), R10 = n10 ? T10.shape[1] : T10.shape[2], F10 = a10 != null, $10 = i10 != null, z10 = u10 === "leakyrelu", W10 = u10 != null ? jp(u10, true) : null, q10 = F10 || $10 || z10 || W10 != null, K10;
  if ((h10 === 1 || f10 === 1) && R10 > z1 && q10 === false) {
    let Z10 = T10, te2 = E10;
    n10 && (Z10 = cn({ inputs: { x: T10 }, backend: r10, attrs: { perm: [0, 2, 1] } }), A10.push(Z10)), s10 && (te2 = cn({ inputs: { x: E10 }, backend: r10, attrs: { perm: [0, 2, 1] } }), A10.push(te2));
    let ee2 = f10 !== 1, se2 = f10 === 1, ne2 = Z10;
    ee2 && (ne2 = he2({ inputs: { x: Z10 }, backend: r10, attrs: { shape: [P10, R10, 1] } }), A10.push(ne2));
    let oe2 = f10 === 1 ? 2 : 1, re2 = te2;
    se2 && (re2 = he2({ inputs: { x: te2 }, backend: r10, attrs: { shape: [P10, 1, R10] } }), A10.push(re2));
    let le2 = vv({ inputs: { a: ne2, b: re2 }, backend: r10 });
    K10 = Xp({ inputs: { x: le2 }, backend: r10, attrs: { axis: oe2, keepDims: true } }), A10.push(le2);
  } else {
    let Z10 = yn(e.dtype, t.dtype), te2 = new P1(k10, C10, [P10, h10, f10], n10, s10, F10, W10, $10, z10), ee2 = [T10, E10];
    if (a10 != null && ee2.push(a10), $10 && ee2.push(i10), z10) {
      let se2 = r10.makeTensorInfo([], "float32", w2.createScalarValue(o10, "float32"));
      ee2.push(se2), A10.push(se2);
    }
    K10 = r10.runWebGLProgram(te2, ee2, Z10);
  }
  let Y10 = he2({ inputs: { x: K10 }, backend: r10, attrs: { shape: x10 } });
  A10.push(K10);
  for (let Z10 of A10)
    r10.disposeIntermediateTensorInfo(Z10);
  return Y10;
}
function JX(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10, bias: i10, preluActivationWeights: o10 } = t, { transposeA: u10, transposeB: l10, activation: c10, leakyreluAlpha: p10 } = s10;
  return Pd({ a: r10, b: a10, transposeA: u10, transposeB: l10, backend: n10, bias: i10, preluActivationWeights: o10, leakyreluAlpha: p10, activation: c10 });
}
var e8 = { kernelName: na, backendName: "webgl", kernelFunc: JX };
var cw = "return abs(x);";
function t8(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (n10.shouldExecuteOnCPU([s10]) && s10.dtype !== "complex64") {
    let a10 = n10.texData.get(s10.dataId), i10 = C1(a10.values);
    return n10.makeTensorInfo(s10.shape, s10.dtype, i10);
  }
  let r10;
  return X2().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? r10 = new Yr(s10.shape, cw) : r10 = new Hs(s10.shape, cw), n10.runWebGLProgram(r10, [s10], s10.dtype);
}
var n8 = { kernelName: ao, backendName: "webgl", kernelFunc: t8 };
var s8 = ts + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
var r8 = Ke({ opSnippet: s8 });
var a8 = { kernelName: nl, backendName: "webgl", kernelFunc: r8 };
var i8 = ts + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
var o8 = Ke({ opSnippet: i8 });
var u8 = { kernelName: sl, backendName: "webgl", kernelFunc: o8 };
var dw = "return a + b;";
var l8 = qt({ opSnippet: dw, packedOpSnippet: dw, supportsComplex: true, cpuKernelImpl: IK });
var c8 = { kernelName: kr, backendName: "webgl", kernelFunc: l8 };
var d8 = class {
  constructor(e, t) {
    this.outputShape = [], this.outputShape = e, this.variableNames = t.map((r10, a10) => `T${a10}`);
    let n10 = [];
    this.variableNames.forEach((r10) => {
      n10.push(`float v${r10} = get${r10}AtOutCoords();`);
    });
    let s10 = this.variableNames.map((r10) => `v${r10}`).join(" + ");
    this.userCode = `
      void main() {
        ${n10.join(`
        `)}

        float result = ${s10};
        setOutput(result);
      }
    `;
  }
};
var p8 = class {
  constructor(e, t) {
    this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.variableNames = t.map((r10, a10) => `T${a10}`);
    let n10 = [];
    this.variableNames.forEach((r10) => {
      n10.push(`vec4 v${r10} = get${r10}AtOutCoords();`);
    });
    let s10 = this.variableNames.map((r10) => `v${r10}`).join(" + ");
    this.userCode = `
      void main() {
        ${n10.join(`
        `)}

        vec4 result = ${s10};
        setOutput(result);
      }
    `;
  }
};
function ud(e) {
  let { inputs: t, backend: n10 } = e, s10 = t;
  if (s10.length === 1)
    return En({ inputs: { x: s10[0] }, backend: n10 });
  if (s10.length > X2().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    let u10 = Math.floor(s10.length / 2), l10 = ud({ inputs: s10.slice(0, u10), backend: n10 }), c10 = ud({ inputs: s10.slice(u10), backend: n10 });
    return ud({ inputs: [l10, c10], backend: n10 });
  }
  let r10 = s10.map((u10) => u10.dtype).reduce((u10, l10) => yn(u10, l10)), a10 = s10.map((u10) => u10.shape), o10 = X2().getBool("WEBGL_PACK") ? new p8(s10[0].shape, a10) : new d8(s10[0].shape, a10);
  return n10.runWebGLProgram(o10, s10, r10);
}
var h8 = { kernelName: xa, backendName: "webgl", kernelFunc: ud };
function f8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10, o10 = r10.shape.length, u10 = w2.parseAxisParam(a10, r10.shape), l10 = u10, c10 = N2.getAxesPermutation(l10, o10), p10 = r10;
  c10 != null && (p10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: c10 } }), l10 = N2.getInnerMostAxes(l10.length, o10)), N2.assertAxesAreInnerMostDims("all", l10, o10);
  let [d10, h10] = N2.computeOutAndReduceShapes(p10.shape, l10), f10 = w2.sizeFromShape(h10), m10 = he2({ inputs: { x: p10 }, backend: n10, attrs: { shape: [-1, f10] } }), g10 = yi(m10, m10.dtype, "all", n10), b10;
  if (i10) {
    let y10 = N2.expandShapeToKeepDim(d10, u10);
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: y10 } });
  } else
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(g10), c10 != null && n10.disposeIntermediateTensorInfo(p10), b10;
}
var m8 = { kernelName: rl, backendName: "webgl", kernelFunc: f8 };
function g8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10, o10 = r10.shape.length, u10 = w2.parseAxisParam(a10, r10.shape), l10 = u10, c10 = N2.getAxesPermutation(l10, o10), p10 = r10;
  c10 != null && (p10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: c10 } }), l10 = N2.getInnerMostAxes(l10.length, o10)), N2.assertAxesAreInnerMostDims("any", l10, o10);
  let [d10, h10] = N2.computeOutAndReduceShapes(p10.shape, l10), f10 = w2.sizeFromShape(h10), m10 = he2({ inputs: { x: p10 }, backend: n10, attrs: { shape: [-1, f10] } }), g10 = yi(m10, m10.dtype, "any", n10), b10;
  if (i10) {
    let y10 = N2.expandShapeToKeepDim(d10, u10);
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: y10 } });
  } else
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(g10), c10 != null && n10.disposeIntermediateTensorInfo(p10), b10;
}
var b8 = { kernelName: al, backendName: "webgl", kernelFunc: g8 };
var y8 = class {
  constructor(e, t, n10) {
    this.variableNames = ["A"];
    let { windowSize: s10, batchSize: r10, outSize: a10 } = e;
    n10 || this.variableNames.push("bestIndicesA"), this.outputShape = [r10, a10];
    let i10 = t === "max" ? ">" : "<", o10 = n10 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s10};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s10}; i++) {
          int inIdx = ${o10};
          float candidate = getA(batch, inIdx);
          if (candidate ${i10} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
};
var v8 = class {
  constructor(e, t, n10, s10) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, w2.assert(e.length > 2, () => `Packed arg${n10.charAt(0).toUpperCase() + n10.slice(1)} supports only inputs with rank above 2.`);
    let r10 = e[e.length - 1], a10 = Math.ceil(r10 / t);
    this.outputShape = e.slice(0, -1), a10 > 1 && this.outputShape.push(a10), s10 || this.variableNames.push("bestIndicesA");
    let i10 = this.outputShape, o10 = i10.length, u10 = ot(o10), l10 = un("coords", o10), c10, p10;
    if (a10 === 1) {
      p10 = o10 + 1;
      let T10 = ot(p10);
      c10 = `
        ${T10} sourceLocR = ${T10}(${l10.join()}, 0);
        ++${l10[o10 - 1]};
        ${T10} sourceLocG = ${T10}(${l10.join()}, 0);
        ++${l10[o10 - 2]};
        ${T10} sourceLocA = ${T10}(${l10.join()}, 0);
        --${l10[o10 - 1]};
        ${T10} sourceLocB = ${T10}(${l10.join()}, 0);
        --${l10[o10 - 2]};`;
    } else
      p10 = o10, c10 = `
        ${u10} sourceLocR = coords;
        ++${l10[o10 - 1]};
        ${u10} sourceLocG = coords;
        ++${l10[o10 - 2]};
        ${u10} sourceLocA = coords;
        --${l10[o10 - 1]};
        ${u10} sourceLocB = coords;
        --${l10[o10 - 2]};`;
    let d10 = ["x", "y", "z", "w", "u", "v"].slice(0, p10), h10 = "." + d10[p10 - 1], f10 = d10.map((T10) => "int " + T10), m10 = un("sourceLocR", p10 - 1).concat("inIdx.r"), g10 = un("sourceLocG", p10 - 1).concat("inIdx.g"), b10 = un("sourceLocB", p10 - 1).concat("inIdx.b"), y10 = un("sourceLocA", p10 - 1).concat("inIdx.a"), v10 = n10 === "max" ? "greaterThan" : "lessThan", x10 = s10 ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${m10.join()}),
                             getBestIndicesAChannel(${g10.join()}),
                             getBestIndicesAChannel(${b10.join()}),
                             getBestIndicesAChannel(${y10.join()})));`, k10 = `vec4(
            getAChannel(${m10.join()}),
            hasNextCol ? getAChannel(${g10.join()}) : 0.,
            hasNextRow ? getAChannel(${b10.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y10.join()}) : 0.)`, C10 = s10 ? "" : `
      float getBestIndicesAChannel(${f10.join()}) {
        return getChannel(getBestIndicesA(${d10.join()}),
                                          vec2(${d10.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${f10.join()}) {
        return getChannel(getA(${d10.join()}),
                               vec2(${d10.slice(-2).join()}));
      }
      ${C10}
      void main() {
        ${u10} coords = getOutputCoords();
        bool hasNextCol = ${l10[o10 - 1]} < ${i10[o10 - 1] - 1};
        bool hasNextRow = ${l10[o10 - 2]} < ${i10[o10 - 2] - 1};
        ${c10}
        ivec4 srcIdx = ivec4(sourceLocR${h10}, sourceLocG${h10},
          sourceLocB${h10}, sourceLocA${h10}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k10};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${x10}
          vec4 candidate = ${k10};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v10}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
};
function M1(e, t, n10, s10 = null) {
  let r10 = t.shape[0], a10 = t.shape[1];
  s10 != null && (r10 = s10.shape[0], a10 = s10.shape[1]);
  let i10 = N2.computeOptimalWindowSize(a10), o10 = { windowSize: i10, inSize: a10, batchSize: r10, outSize: Math.ceil(a10 / i10) }, u10 = new y8(o10, n10, s10 == null), l10 = [t];
  s10 != null && l10.push(s10);
  let c10 = e.runWebGLProgram(u10, l10, "int32");
  if (c10.shape[1] === 1)
    return c10;
  let p10 = M1(e, t, n10, c10);
  return e.disposeIntermediateTensorInfo(c10), p10;
}
function L1(e, t, n10, s10 = null) {
  let r10 = s10 != null ? s10.shape : t.shape, a10 = r10[r10.length - 1], i10 = N2.computeOptimalWindowSize(a10), o10 = new v8(r10, i10, n10, s10 == null), u10 = s10 == null ? [t] : [t, s10], l10 = e.runWebGLProgram(o10, u10, "int32");
  if (l10.shape.length === t.shape.length) {
    let c10 = L1(e, t, n10, l10);
    return e.disposeIntermediateTensorInfo(l10), c10;
  }
  return l10;
}
function B1(e, t, n10, s10) {
  let r10 = [n10];
  if (N2.assertAxesAreInnerMostDims("arg" + s10.charAt(0).toUpperCase() + s10.slice(1), r10, t.shape.length), !X2().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
    let a10 = [], i10 = e.texData.get(t.dataId), o10 = i10 !== null && i10.isPacked, u10 = t;
    o10 && (u10 = e.unpackTensor(t), a10.push(u10));
    let [l10, c10] = N2.computeOutAndReduceShapes(u10.shape, r10), p10 = w2.sizeFromShape(c10), d10 = he2({ inputs: { x: u10 }, backend: e, attrs: { shape: [-1, p10] } });
    a10.push(d10);
    let h10 = M1(e, d10, s10);
    a10.push(h10);
    let f10 = he2({ inputs: { x: h10 }, backend: e, attrs: { shape: l10 } });
    return a10.forEach((m10) => e.disposeIntermediateTensorInfo(m10)), f10;
  }
  return L1(e, t, s10);
}
function x8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10, i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), N2.assertAxesAreInnerMostDims("argMax", [i10[0]], u10.shape.length);
  let c10 = B1(n10, u10, i10[0], "max");
  return l10.forEach((p10) => n10.disposeIntermediateTensorInfo(p10)), c10;
}
var w8 = { kernelName: wa, backendName: "webgl", kernelFunc: x8 };
function k8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10, i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), N2.assertAxesAreInnerMostDims("argMin", [i10[0]], u10.shape.length);
  let c10 = B1(n10, u10, i10[0], "min");
  return l10.forEach((p10) => n10.disposeIntermediateTensorInfo(p10)), c10;
}
var I8 = { kernelName: il, backendName: "webgl", kernelFunc: k8 };
var S8 = ts + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
var C8 = Ke({ opSnippet: S8 });
var N8 = { kernelName: ol, backendName: "webgl", kernelFunc: C8 };
var T8 = ts + "return log(x + sqrt(x * x + 1.0));";
var $8 = Ke({ opSnippet: T8 });
var _8 = { kernelName: ul, backendName: "webgl", kernelFunc: $8 };
var A8 = ts + `
  return atan(x);
`;
var E8 = Ke({ opSnippet: A8 });
var R8 = { kernelName: ll, backendName: "webgl", kernelFunc: E8 };
var D8 = BX + `
  return atan(a, b);
`;
var F8 = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + VX + `
  return result;
`;
var O8 = qt({ opSnippet: D8, packedOpSnippet: F8 });
var P8 = { kernelName: dl, backendName: "webgl", kernelFunc: O8 };
var z8 = ts + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
var M8 = Ke({ opSnippet: z8 });
var L8 = { kernelName: cl, backendName: "webgl", kernelFunc: M8 };
var el = class {
  constructor(e, t, n10, s10 = false, r10 = false) {
    if (this.variableNames = ["x"], t === "avg" && n10)
      throw new Error("Cannot compute positions for average pool.");
    let a10 = e.filterWidth, i10 = e.strideHeight, o10 = e.strideWidth, u10 = e.dilationHeight, l10 = e.dilationWidth, c10 = e.effectiveFilterHeight, p10 = e.effectiveFilterWidth, d10 = e.padInfo.top, h10 = e.padInfo.left;
    this.outputShape = e.outShape;
    let f10 = t === "avg", m10 = `((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`, g10 = `(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`, b10 = "0.0";
    if (f10 || (b10 = "-1.0 / 1e-20"), n10) {
      let T10 = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${i10}, ${o10});
        const ivec2 pads = ivec2(${d10}, ${h10});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c10};
              wR += ${u10}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p10};
                wC += ${l10}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T10} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s10 ? r10 ? m10 : g10 : `wR * ${p10} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    let y10 = "max", v10 = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    t === "avg" && (v10 = "avgValue / count");
    let x10 = Math.floor(a10 / 4) * 4, k10 = a10 % 4, C10 = `
      if (${f10}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${y10}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${i10}, ${o10});
      const ivec2 pads = ivec2(${d10}, ${h10});
      const float initializationValue = ${b10};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b10});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c10};
            wR += ${u10}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x10}; wC += 4) {
            int xC = xCCorner + wC * ${l10};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l10}, d),
              getValue(batch, xR, xC + 2 * ${l10}, d),
              getValue(batch, xR, xC + 3 * ${l10}, d)
            );

            ${C10}
          }

          int xC = xCCorner + ${x10};
          if (${k10 === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${C10}
          } else if (${k10 === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l10}, d),
              initializationValue,
              initializationValue
            );

            ${C10}
          } else if (${k10 === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l10}, d),
              getValue(batch, xR, xC + 2 * ${l10}, d),
              initializationValue
            );

            ${C10}
          }
        }
        setOutput(${v10});
      }
    `;
  }
};
var xv = class {
  constructor(e, t, n10, s10 = false, r10 = false) {
    if (this.variableNames = ["x"], t === "avg" && n10)
      throw new Error("Cannot compute positions for average pool.");
    let a10 = e.filterWidth, i10 = e.strideDepth, o10 = e.strideHeight, u10 = e.strideWidth, l10 = e.dilationDepth, c10 = e.dilationHeight, p10 = e.dilationWidth, d10 = e.effectiveFilterDepth, h10 = e.effectiveFilterHeight, f10 = e.effectiveFilterWidth, m10 = e.padInfo.front, g10 = e.padInfo.top, b10 = e.padInfo.left;
    this.outputShape = e.outShape;
    let y10 = t === "avg", v10 = "0.0";
    if (y10 || (v10 = "-1.0 / 1e-20"), n10) {
      let A10 = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${i10}, ${o10}, ${u10});
        const ivec3 pads = ivec3(${m10}, ${g10}, ${b10});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d10};
              wD += ${l10}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h10};
                wR += ${c10}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f10};
                  wC += ${p10}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A10} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s10 ? r10 ? `(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `wD * ${h10} * ${f10} +
                      wR * ${f10} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    let x10 = "max", k10 = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    t === "avg" && (k10 = "avgValue / count");
    let C10 = Math.floor(a10 / 4) * 4, T10 = a10 % 4, E10 = `
      if (${y10}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x10}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${i10}, ${o10}, ${u10});
      const ivec3 pads = ivec3(${m10}, ${g10}, ${b10});
      const float initializationValue = ${v10};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v10});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d10};
            wD += ${l10}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h10};
            wR += ${c10}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${C10}; wC += 4) {
              int xC = xCCorner + wC * ${p10};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p10}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p10}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p10}, ch)
              );

              ${E10}
            }

            int xC = xCCorner + ${C10};
            if (${T10 === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E10}
            } else if (${T10 === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p10}, ch),
                initializationValue,
                initializationValue
              );

              ${E10}
            } else if (${T10 === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p10}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p10}, ch),
                initializationValue
              );

              ${E10}
            }
          }
          setOutput(${k10});
        }
      }
    `;
  }
};
function B8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t;
  tu(r10, "avgPool");
  let { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1;
  w2.assert(N2.eitherStridesOrDilationsAreOne(i10, l10), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i10} and dilations '${l10}'`);
  let c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10);
  if (c10.filterWidth === 1 && c10.filterHeight === 1 && w2.arraysEqual(c10.inShape, c10.outShape))
    return En({ inputs: { x: r10 }, backend: n10 });
  let p10 = new el(c10, "avg", false);
  return n10.runWebGLProgram(p10, [r10], "float32");
}
var V8 = { kernelName: ka, backendName: "webgl", kernelFunc: B8 };
function W8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10, dataFormat: l10 } = s10, c10 = [1, 1, 1], p10 = N2.computePool3DInfo(r10.shape, a10, i10, c10, o10, u10, l10), d10 = new xv(p10, "avg", false);
  return n10.runWebGLProgram(d10, [r10], "float32");
}
var U8 = { kernelName: Hd, backendName: "webgl", kernelFunc: W8 };
var G8 = class {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    let t = e.filterHeight, n10 = e.filterWidth, s10 = e.strideHeight, r10 = e.strideWidth, a10 = e.dilationHeight, i10 = e.dilationWidth, o10 = e.effectiveFilterHeight, u10 = e.effectiveFilterWidth, l10 = o10 - 1 - e.padInfo.top, c10 = u10 - 1 - e.padInfo.left, p10 = 1 / (t * n10);
    this.userCode = `
      const ivec2 pads = ivec2(${l10}, ${c10});
      const float avgMultiplier = float(${p10});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o10};
            wR += ${a10}) {
          float dyR = float(dyRCorner + wR) / ${s10}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u10};
            wC+= ${i10}) {
            float dyC = float(dyCCorner + wC) / ${r10}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var H8 = class {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    let t = e.filterDepth, n10 = e.filterHeight, s10 = e.filterWidth, r10 = e.strideDepth, a10 = e.strideHeight, i10 = e.strideWidth, o10 = e.dilationDepth, u10 = e.dilationHeight, l10 = e.dilationWidth, c10 = e.effectiveFilterDepth, p10 = e.effectiveFilterHeight, d10 = e.effectiveFilterWidth, h10 = c10 - 1 - e.padInfo.front, f10 = p10 - 1 - e.padInfo.top, m10 = d10 - 1 - e.padInfo.left, g10 = 1 / (t * n10 * s10);
    this.userCode = `
      const ivec3 pads = ivec3(${h10}, ${f10}, ${m10});
      const float avgMultiplier = float(${g10});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c10};
            wD += ${o10}) {
          float dyD = float(dyDCorner + wD) / ${r10}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p10};
              wR += ${u10}) {
            float dyR = float(dyRCorner + wR) / ${a10}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d10};
                wC += ${l10}) {
              float dyC = float(dyCCorner + wC) / ${i10}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function q8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, i10 = a10, { filterSize: o10, strides: u10, pad: l10, dimRoundingMode: c10 } = s10, p10 = [1, 1, 1], d10 = N2.computePool3DInfo(i10.shape, o10, u10, p10, l10, c10), h10 = new H8(d10);
  return n10.runWebGLProgram(h10, [r10], i10.dtype);
}
var j8 = { kernelName: ag, backendName: "webgl", kernelFunc: q8 };
function K8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, i10 = a10;
  tu([r10, a10], "avgPoolGrad");
  let { filterSize: o10, strides: u10, pad: l10 } = s10, c10 = N2.computePool2DInfo(i10.shape, o10, u10, 1, l10), p10 = new G8(c10);
  return n10.runWebGLProgram(p10, [r10], i10.dtype);
}
var X8 = { kernelName: rg, backendName: "webgl", kernelFunc: K8 };
function Y8(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10 } = t, { transposeA: i10, transposeB: o10 } = s10;
  return Pd({ a: r10, b: a10, transposeA: i10, transposeB: o10, backend: n10 });
}
var Q8 = { kernelName: Ia, backendName: "webgl", kernelFunc: Y8 };
var Z8 = class {
  constructor(e, t, n10, s10, r10, a10) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], N2.assertAndGetBroadcastShape(e, t), N2.assertAndGetBroadcastShape(e, n10);
    let i10 = "0.0";
    s10 != null && (N2.assertAndGetBroadcastShape(e, s10), this.variableNames.push("offset"), i10 = "getOffsetAtOutCoords()");
    let o10 = "1.0";
    r10 != null && (N2.assertAndGetBroadcastShape(e, r10), this.variableNames.push("scale"), o10 = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i10};
        float scale = ${o10};
        float inv = scale * inversesqrt(variance + float(${a10}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
};
var J8 = class {
  constructor(e, t, n10, s10, r10, a10) {
    this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], N2.assertAndGetBroadcastShape(e, t), N2.assertAndGetBroadcastShape(e, n10);
    let i10 = "vec4(0.0)";
    s10 != null && (N2.assertAndGetBroadcastShape(e, s10), this.variableNames.push("offset"), i10 = "getOffsetAtOutCoords()");
    let o10 = "vec4(1.0)";
    r10 != null && (N2.assertAndGetBroadcastShape(e, r10), this.variableNames.push("scale"), o10 = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        vec4 offset = ${i10};
        vec4 scale = ${o10};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a10}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
};
var eY = ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10, mean: r10, variance: a10, offset: i10, scale: o10 } = e;
  w2.assert(r10.shape.length === a10.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), w2.assert(i10 == null || r10.shape.length === i10.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), w2.assert(o10 == null || r10.shape.length === o10.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let { varianceEpsilon: u10 } = n10;
  u10 == null && (u10 = 1e-3);
  let l10 = [s10, r10, a10], c10 = null;
  i10 != null && (c10 = i10.shape, l10.push(i10));
  let p10 = null;
  o10 != null && (p10 = o10.shape, l10.push(o10));
  let d10 = X2().getBool("WEBGL_PACK_NORMALIZATION") ? new J8(s10.shape, r10.shape, a10.shape, c10, p10, u10) : new Z8(s10.shape, r10.shape, a10.shape, c10, p10, u10);
  return t.runWebGLProgram(d10, l10, l10[0].dtype);
};
var tY = { kernelName: Pa, backendName: "webgl", kernelFunc: eY };
var nY = class {
  constructor(e) {
    this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
    let t = ot(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    let n10 = sY(this.rank), s10, r10 = e.map((a10, i10) => `sourceLoc.${Wm[i10]} = start[${i10}] + coords.${Wm[i10]};`);
    s10 = `
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r10.join(`
`)}
      `, this.userCode = `
      void main() {
        ${s10}
        setOutput(getSource(${n10}));
      }
    `;
  }
};
var Wm = ["x", "y", "z", "w", "u", "v"];
function sY(e) {
  if (e === 1)
    return "sourceLoc";
  if (e <= 6)
    return Wm.slice(0, e).map((t) => "sourceLoc." + t).join(",");
  throw Error(`Slicing for rank ${e} is not yet supported`);
}
var rY = class {
  constructor(e) {
    this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.rank = e.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    let t = ot(this.rank), n10 = un("coords", this.rank), s10 = un("sourceLoc", this.rank), r10 = this.rank === 1 ? "sourceLoc" : `vec2(${s10.slice(-2).join()})`, a10 = `getChannel(getSource(${s10.join()}), ${r10})`, i10 = `
      result.x = ${a10};
      if (++${n10[this.rank - 1]} < ${e[this.rank - 1]}) {
        ++${s10[this.rank - 1]};
        result.y = ${a10};
        --${s10[this.rank - 1]};
      }
    `, o10 = this.rank === 1 ? "" : `
      --${n10[this.rank - 1]};
      if (++${n10[this.rank - 2]} < ${e[this.rank - 2]}) {
        ++${s10[this.rank - 2]};
        result.z = ${a10};
        if (++${n10[this.rank - 1]} < ${e[this.rank - 1]}) {
          ++${s10[this.rank - 1]};
          result.w = ${a10};
        }
      }
    `, u10 = this.rank <= 4 ? `sourceLoc = coords +
            ${t}(${e.map((l10, c10) => `start[${c10}]`).join()});` : e.map((l10, c10) => `${s10[c10]} = ${n10[c10]} + start[${c10}];`).join(`
`);
    this.userCode = `
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u10}
        vec4 result = vec4(0.);
        ${i10}
        ${o10}
        setOutput(result);
      }
    `;
  }
};
function aY(e, t, n10, s10) {
  let r10 = s10.texData.get(e.dataId), a10 = s10.makeTensorInfo(n10, e.dtype), i10 = s10.texData.get(a10.dataId);
  Object.assign(i10, r10), i10.refCount = 1, i10.shape = n10, i10.dtype = e.dtype;
  let o10 = wt.computeFlatOffset(t, w2.computeStrides(e.shape));
  r10.slice && (o10 += r10.slice.flatOffset), i10.slice = { flatOffset: o10, origDataId: r10.slice && r10.slice.origDataId || e.dataId };
  let u10 = s10.dataRefCount.get(i10.slice.origDataId) || 1;
  return s10.dataRefCount.set(i10.slice.origDataId, u10 + 1), a10;
}
function ou(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, size: i10 } = s10, [o10, u10] = wt.parseSliceParams(r10, a10, i10);
  if (wt.assertParamsValid(r10, o10, u10), w2.sizeFromShape(u10) === 0)
    return n10.makeTensorInfo(u10, r10.dtype, []);
  if (n10.shouldExecuteOnCPU([r10]) || r10.dtype === "string") {
    let p10 = n10.texData.get(r10.dataId), d10 = XK(p10.values, o10, u10, r10.shape, r10.dtype);
    return n10.makeTensorInfo(u10, r10.dtype, d10);
  }
  let { isPacked: l10 } = n10.texData.get(r10.dataId), c10 = wt.isSliceContinous(r10.shape, o10, u10);
  if (l10 || !c10) {
    let p10 = X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new rY(u10) : new nY(u10), d10 = [o10];
    return n10.runWebGLProgram(p10, [r10], r10.dtype, d10);
  }
  return n10.uploadToGPU(r10.dataId), aY(r10, o10, u10, n10);
}
var iY = { kernelName: Oo, backendName: "webgl", kernelFunc: ou };
var oY = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, crops: i10 } = s10;
  w2.assert(r10.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
  let o10 = a10.reduce((y10, v10) => y10 * v10), u10 = N2.getReshaped(r10.shape, a10, o10), l10 = N2.getPermuted(u10.length, a10.length), c10 = N2.getReshapedPermuted(r10.shape, a10, o10), p10 = N2.getSliceBeginCoords(i10, a10.length), d10 = N2.getSliceSize(c10, i10, a10.length), h10 = [], f10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: u10 } }), m10 = cn({ inputs: { x: f10 }, backend: n10, attrs: { perm: l10 } }), g10 = he2({ inputs: { x: m10 }, backend: n10, attrs: { shape: c10 } }), b10 = ou({ inputs: { x: g10 }, backend: n10, attrs: { begin: p10, size: d10 } });
  return h10.push(f10), h10.push(m10), h10.push(g10), h10.forEach((y10) => n10.disposeIntermediateTensorInfo(y10)), b10;
};
var uY = { kernelName: io, backendName: "webgl", kernelFunc: oY };
function lY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, weights: a10 } = t, { size: i10 } = s10, o10 = n10.readSync(r10.dataId), u10 = n10.readSync(a10.dataId), l10 = S1(o10, u10, a10.dtype, a10.shape, i10);
  return n10.makeTensorInfo([i10], a10.dtype, l10);
}
var cY = { kernelName: ig, backendName: "webgl", kernelFunc: lY };
function dY(e) {
  let { inputs: t, backend: n10 } = e, { s0: s10, s1: r10 } = t, a10 = n10.readSync(s10.dataId), i10 = n10.readSync(r10.dataId), o10 = N2.assertAndGetBroadcastShape(Array.from(a10), Array.from(i10));
  return n10.makeTensorInfo([o10.length], "int32", Int32Array.from(o10));
}
var pY = { kernelName: og, backendName: "webgl", kernelFunc: dY };
var hY = "return float(a != b);";
var V1 = qt({ opSnippet: hY, cpuKernelImpl: GK, dtype: "bool" });
var fY = { kernelName: Io, backendName: "webgl", kernelFunc: V1 };
function Zl(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.texData.get(s10.dataId);
  return En({ inputs: { x: r10.complexTensorInfos.real }, backend: n10 });
}
var mY = { kernelName: tp, backendName: "webgl", kernelFunc: Zl };
var gY = "return float(int(x));";
function bY(e, t) {
  let n10 = new Hs(e.shape, gY), s10 = t.runWebGLProgram(n10, [e], "int32");
  return { dataId: s10.dataId, shape: s10.shape, dtype: s10.dtype };
}
function Um(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dtype: a10 } = s10;
  if (a10 === "complex64") {
    if (r10.dtype === "complex64")
      return En({ inputs: { x: r10 }, backend: n10 });
    let i10 = $t(r10.shape), o10 = Um({ inputs: { x: r10 }, backend: n10, attrs: { dtype: "float32" } }), u10 = Er({ inputs: { real: o10, imag: i10 }, backend: n10 });
    return i10.dispose(), n10.disposeIntermediateTensorInfo(o10), u10;
  }
  if (r10.dtype === "complex64") {
    let i10 = Zl({ inputs: { input: r10 }, backend: n10 }), o10 = Um({ inputs: { x: i10 }, backend: n10, attrs: { dtype: a10 } });
    return n10.disposeIntermediateTensorInfo(i10), o10;
  }
  if (!w2.hasEncodingLoss(r10.dtype, a10)) {
    let i10 = En({ inputs: { x: r10 }, backend: n10 });
    return { dataId: i10.dataId, shape: i10.shape, dtype: a10 };
  }
  if (a10 === "int32")
    return bY(r10, n10);
  if (a10 === "bool") {
    let i10 = n10.makeTensorInfo([], "bool", w2.getTypedArrayFromDType("bool", 1)), u10 = V1({ inputs: { a: r10, b: i10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(i10), u10;
  }
  throw new Error(`Error in Cast: failed to cast ${r10.dtype} to ${a10}`);
}
var yY = { kernelName: Sa, backendName: "webgl", kernelFunc: Um };
var pw = "return ceil(x);";
var vY = Ke({ opSnippet: pw, packedOpSnippet: pw, cpuKernelImpl: CK });
var xY = { kernelName: Ca, backendName: "webgl", kernelFunc: vY };
var wY = class {
  constructor(e) {
    this.variableNames = ["A"], this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
};
var kY = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
};
function IY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { clipValueMin: a10, clipValueMax: i10 } = s10, o10;
  X2().getBool("WEBGL_PACK_CLIP") ? o10 = new kY(r10.shape) : o10 = new wY(r10.shape);
  let u10 = [[a10], [i10]];
  return n10.runWebGLProgram(o10, [r10], r10.dtype, u10);
}
var SY = { kernelName: Ir, backendName: "webgl", kernelFunc: IY };
var CY = class {
  constructor(e) {
    this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
  }
};
function hw(e, t) {
  return { dataId: t.dataId, dtype: t.dtype, shape: e.shape };
}
function NY(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t, r10 = n10.texData.get(s10.dataId), a10 = new CY(s10.shape), i10 = [hw(s10, r10.complexTensorInfos.real), hw(s10, r10.complexTensorInfos.imag)];
  return n10.runWebGLProgram(a10, i10, i10[0].dtype);
}
var TY = { kernelName: jd, backendName: "webgl", kernelFunc: NY };
var $Y = class {
  constructor(e) {
    this.outputShape = [], this.outputShape = N2.computeOutShape(e, 1), this.variableNames = e.map((a10, i10) => `T${i10}`);
    let t = new Array(e.length - 1);
    t[0] = e[0][1];
    for (let a10 = 1; a10 < t.length; a10++)
      t[a10] = t[a10 - 1] + e[a10][1];
    let n10 = [`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];
    for (let a10 = 1; a10 < t.length; a10++) {
      let i10 = t[a10 - 1];
      n10.push(`else if (yC < ${t[a10]}) setOutput(getT${a10}(yR, yC-${i10}));`);
    }
    let s10 = t.length, r10 = t[t.length - 1];
    n10.push(`else setOutput(getT${s10}(yR, yC-${r10}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n10.join(`
        `)}
      }
    `;
  }
};
var _Y = class {
  constructor(e, t) {
    this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = N2.computeOutShape(e, t);
    let n10 = this.outputShape, s10 = n10.length, r10 = ot(s10), a10 = un("coords", s10), i10 = ["x", "y", "z", "w", "u", "v"].slice(0, s10);
    this.variableNames = e.map((f10, m10) => `T${m10}`);
    let o10 = new Array(e.length - 1);
    o10[0] = e[0][t];
    for (let f10 = 1; f10 < o10.length; f10++)
      o10[f10] = o10[f10 - 1] + e[f10][t];
    let u10 = i10[t], l10 = i10.slice(-2), c10 = i10.join(), p10 = `if (${u10} < ${o10[0]}) {
        return getChannel(
            getT0(${c10}), vec2(${l10.join()}));
        }`;
    for (let f10 = 1; f10 < o10.length; f10++) {
      let m10 = o10[f10 - 1];
      p10 += `
        if (${u10} < ${o10[f10]}  && ${u10} >= ${o10[f10 - 1]}) {
          return getChannel(
            getT${f10}(${Zc(i10, u10, m10)}),
            vec2(${Zc(l10, u10, m10)}));
        }`;
    }
    let d10 = o10.length, h10 = o10[o10.length - 1];
    p10 += `
        return getChannel(
          getT${d10}(${Zc(i10, u10, h10)}),
          vec2(${Zc(l10, u10, h10)}));`, this.userCode = `
      float getValue(${i10.map((f10) => "int " + f10)}) {
        ${p10}
      }

      void main() {
        ${r10} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a10}), 0., 0., 0.);

        ${a10[s10 - 1]} = ${a10[s10 - 1]} + 1;
        if (${a10[s10 - 1]} < ${n10[s10 - 1]}) {
          result.g = getValue(${a10});
        }

        ${a10[s10 - 2]} = ${a10[s10 - 2]} + 1;
        if (${a10[s10 - 2]} < ${n10[s10 - 2]}) {
          result.a = getValue(${a10});
        }

        ${a10[s10 - 1]} = ${a10[s10 - 1]} - 1;
        if (${a10[s10 - 2]} < ${n10[s10 - 2]} &&
            ${a10[s10 - 1]} < ${n10[s10 - 1]}) {
          result.b = getValue(${a10});
        }
        setOutput(result);
      }
    `;
  }
};
function Zc(e, t, n10) {
  let s10 = e.indexOf(t);
  return e.map((a10, i10) => i10 === s10 ? `${a10} - ${n10}` : a10).join();
}
function Yp(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.texData.get(s10.dataId);
  return En({ inputs: { x: r10.complexTensorInfos.imag }, backend: n10 });
}
var AY = { kernelName: Qd, backendName: "webgl", kernelFunc: Yp };
function Wi(e, t, n10) {
  let s10 = e[0].dtype;
  if (s10 === "complex64") {
    let c10 = e.map((m10) => Zl({ inputs: { input: m10 }, backend: n10 })), p10 = e.map((m10) => Yp({ inputs: { input: m10 }, backend: n10 })), d10 = Wi(c10, t, n10), h10 = Wi(p10, t, n10), f10 = Er({ inputs: { real: d10, imag: h10 }, backend: n10 });
    return c10.forEach((m10) => n10.disposeIntermediateTensorInfo(m10)), p10.forEach((m10) => n10.disposeIntermediateTensorInfo(m10)), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), f10;
  }
  let r10 = n10.shouldExecuteOnCPU(e);
  if (s10 === "string" && (r10 = true), r10) {
    let c10 = e.map((b10) => {
      let y10 = w2.sizeFromShape(b10.shape.slice(t));
      return he2({ inputs: { x: b10 }, backend: n10, attrs: { shape: [-1, y10] } });
    }), p10 = c10.map((b10) => ({ vals: n10.readSync(b10.dataId), shape: b10.shape })), d10 = N2.computeOutShape(c10.map((b10) => b10.shape), 1), h10 = c10[0].shape[0] === 1, f10 = NK(p10, d10, s10, h10), m10 = N2.computeOutShape(e.map((b10) => b10.shape), t), g10 = n10.makeTensorInfo(m10, s10, f10);
    return c10.forEach((b10) => n10.disposeIntermediateTensorInfo(b10)), g10;
  }
  if (e.length > X2().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    let c10 = Math.floor(e.length / 2), p10 = Wi(e.slice(0, c10), t, n10), d10 = Wi(e.slice(c10), t, n10), h10 = Wi([p10, d10], t, n10);
    return n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(d10), h10;
  }
  if (X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
    let c10 = new _Y(e.map((p10) => p10.shape), t);
    return n10.runWebGLProgram(c10, e, s10);
  }
  let { tensors2D: a10, outShape: i10 } = EY(e, t, n10), o10 = new $Y(a10.map((c10) => c10.shape)), u10 = n10.runWebGLProgram(o10, a10, s10);
  a10.forEach((c10) => n10.disposeIntermediateTensorInfo(c10));
  let l10 = he2({ inputs: { x: u10 }, attrs: { shape: i10 }, backend: n10 });
  return n10.disposeIntermediateTensorInfo(u10), l10;
}
function EY(e, t, n10) {
  let s10 = N2.computeOutShape(e.map((a10) => a10.shape), t);
  return { tensors2D: e.map((a10) => he2({ inputs: { x: a10 }, attrs: { shape: [-1, w2.sizeFromShape(a10.shape.slice(t))] }, backend: n10 })), outShape: s10 };
}
function W1(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10, a10 = w2.parseAxisParam(r10, t[0].shape)[0], i10 = N2.computeOutShape(t.map((l10) => l10.shape), a10);
  if (w2.sizeFromShape(i10) === 0)
    return n10.makeTensorInfo(i10, t[0].dtype, []);
  let o10 = t.filter((l10) => w2.sizeFromShape(l10.shape) > 0);
  if (o10.length === 1)
    return En({ inputs: { x: o10[0] }, backend: n10 });
  let u10 = o10.map((l10) => l10.shape);
  return N2.assertParamsConsistent(u10, a10), Wi(o10, a10, n10);
}
var RY = { kernelName: oo, backendName: "webgl", kernelFunc: W1 };
var U1 = class {
  constructor(e, t = false, n10 = null, s10 = false, r10 = false) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    let a10 = e.padInfo.top, i10 = e.padInfo.left, o10 = e.strideHeight, u10 = e.strideWidth, l10 = e.dilationHeight, c10 = e.dilationWidth, p10 = e.filterHeight, d10 = e.filterWidth, h10 = Math.floor(e.inChannels / 4) * 4, f10 = e.inChannels % 4, m10 = e.dataFormat === "channelsLast", g10 = m10 ? 1 : 2, b10 = m10 ? 2 : 3, y10 = m10 ? 3 : 1, v10 = "", x10 = "";
    n10 && (s10 ? v10 = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n10}
        }` : r10 ? v10 = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n10}
        }` : v10 = `
          float activation(float x) {
            ${n10}
          }
        `, x10 = "result = activation(result);");
    let k10 = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), r10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${v10}

      const ivec2 strides = ivec2(${o10}, ${u10});
      const ivec2 pads = ivec2(${a10}, ${i10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${y10}];

        ivec2 xRCCorner =
            ivec2(coords[${g10}], coords[${b10}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p10}; wR++) {
          int xR = xRCorner + wR * ${l10};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d10}; wC++) {
            int xC = xCCorner + wC * ${c10};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h10}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m10}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f10 === 1}) {

              if (${m10}) {
                dotProd +=
                    getX(batch, xR, xC, ${h10}) *
                    getW(wR, wC, ${h10}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h10}, xR, xC) *
                    getW(wR, wC, ${h10}, d2);
              }

            } else if (${f10 === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h10}, d2),
                getW(wR, wC, ${h10} + 1, d2)
              );

              if (${m10}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h10}),
                  getX(batch, xR, xC, ${h10} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h10}, xR, xC),
                  getX(batch, ${h10} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f10 === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h10}, d2),
                getW(wR, wC, ${h10} + 1, d2),
                getW(wR, wC, ${h10} + 2, d2)
              );

              if (${m10}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h10}),
                  getX(batch, xR, xC, ${h10} + 1),
                  getX(batch, xR, xC, ${h10} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h10}, xR, xC),
                  getX(batch, ${h10} + 1, xR, xC),
                  getX(batch, ${h10} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k10}
        ${x10}
        setOutput(result);
      }
    `;
  }
};
var DY = class {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    let t = e.padInfo.front, n10 = e.padInfo.top, s10 = e.padInfo.left, r10 = e.strideDepth, a10 = e.strideHeight, i10 = e.strideWidth, o10 = e.dilationDepth, u10 = e.dilationHeight, l10 = e.dilationWidth, c10 = e.filterDepth, p10 = e.filterHeight, d10 = e.filterWidth, h10 = Math.floor(e.inChannels / 4) * 4, f10 = e.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${r10}, ${a10}, ${i10});
      const ivec3 pads = ivec3(${t}, ${n10}, ${s10});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c10}; wF++) {
          int xF = xFCorner + wF * ${o10};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p10}; wR++) {
            int xR = xRCorner + wR * ${u10};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d10}; wC++) {
              int xC = xCCorner + wC * ${l10};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h10}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f10 === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h10}) *
                  getW(wF, wR, wC, ${h10}, d2);
              } else if (${f10 === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h10}),
                  getX(batch, xF, xR, xC, ${h10} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h10}, d2),
                  getW(wF, wR, wC, ${h10} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f10 === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h10}),
                  getX(batch, xF, xR, xC, ${h10} + 1),
                  getX(batch, xF, xR, xC, ${h10} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h10}, d2),
                  getW(wF, wR, wC, ${h10} + 1, d2),
                  getW(wF, wR, wC, ${h10} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var FY = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }, { name: "pad", type: "ivec2" }, { name: "stride", type: "ivec2" }, { name: "dilation", type: "ivec2" }, { name: "inChannels", type: "int" }, { name: "itemsPerBlockRow", type: "int" }, { name: "outWidth", type: "int" }], this.outputShape = e, this.enableShapeUniforms = kn(this.outputShape.length);
    let { dataFormat: n10 } = t, s10 = hn(), r10 = n10 === "channelsLast", a10 = r10 ? 0 : 1, i10 = r10 ? 1 : 2, o10 = this.enableShapeUniforms ? "if(blockIndex < outShape[1] && pos < outShape[0]) {" : `if(blockIndex < ${e[1]} && pos < ${e[0]}) {`, u10 = "";
    for (let l10 = 0; l10 <= 1; l10++)
      for (let c10 = 0; c10 <= 1; c10++)
        u10 += `
          blockIndex = rc.y + ${c10};
          pos = rc.x + ${l10};

          ${o10}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a10}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i10}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r10}) {
                  innerDims = vec2(d1, ch);
                  result[${l10 * 2 + c10}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l10 * 2 + c10}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
    this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u10}

        ${s10.output} = result;
      }
    `;
  }
};
function G1({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10 = null, preluActivationWeights: a10 = null, leakyreluAlpha: i10 = 0, activation: o10 = null }) {
  let u10 = e.shape, l10 = s10.texData.get(e.dataId), c10 = n10.inChannels, p10 = u10[0] * u10[1] * u10[2], d10 = n10.outChannels, h10 = n10.dataFormat === "channelsLast", f10 = false, m10 = false, g10, b10 = [];
  if (!((p10 === 1 || d10 === 1) && c10 > z1) && l10.isPacked && h10 && l10.texture != null && u10[2] % 2 !== 0 && w2.arraysEqual(l10.shape.slice(-3), u10.slice(-3))) {
    let x10 = u10[0] * u10[1] * (u10[2] + 1), k10 = { dataId: e.dataId, shape: [1, x10, n10.inChannels], dtype: e.dtype }, C10 = l10.shape;
    l10.shape = l10.shape.slice(), l10.shape[l10.shape.length - 2]++, w2.assert(Ju(l10.shape, k10.shape), () => `packed reshape ${l10.shape} to ${k10.shape} isn't free`);
    let T10 = he2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, n10.inChannels, n10.outChannels] } });
    b10.push(T10);
    let E10 = Pd({ a: k10, b: T10, backend: s10, transposeA: f10, transposeB: m10, bias: r10, activation: o10, preluActivationWeights: a10, leakyreluAlpha: i10 }), A10 = s10.texData.get(E10.dataId);
    w2.assert(A10.isPacked, () => "batchMatMul result is expected to be packed"), l10.shape = C10, A10.shape = n10.outShape, g10 = En({ inputs: { x: E10 }, backend: s10 }), g10.shape = n10.outShape, b10.push(E10);
  } else {
    let x10 = h10 ? u10[0] * u10[1] * u10[2] : u10[0] * u10[2] * u10[3], k10 = he2({ inputs: { x: e }, backend: s10, attrs: { shape: [1, x10, n10.inChannels] } }), C10 = he2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, n10.inChannels, n10.outChannels] } }), T10 = Pd({ a: k10, b: C10, transposeA: f10, transposeB: m10, backend: s10, bias: r10, activation: o10, preluActivationWeights: a10, leakyreluAlpha: i10 });
    g10 = he2({ inputs: { x: T10 }, backend: s10, attrs: { shape: n10.outShape } }), b10.push(k10), b10.push(C10), b10.push(T10);
  }
  for (let x10 of b10)
    s10.disposeIntermediateTensorInfo(x10);
  return g10;
}
function H1({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10 = null, preluActivationWeights: a10 = null, leakyreluAlpha: i10 = 0, activation: o10 = null }) {
  let { filterWidth: u10, filterHeight: l10, inChannels: c10, outWidth: p10, outHeight: d10, dataFormat: h10 } = n10, f10 = h10 === "channelsLast", m10 = u10 * l10 * c10, g10 = d10 * p10, b10 = [m10, g10], y10 = true, v10 = false, x10 = [], k10 = he2({ inputs: { x: e }, backend: s10, attrs: { shape: e.shape.slice(1) } }), C10 = he2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, m10, w2.sizeFromShape(t.shape) / m10] } });
  x10.push(k10), x10.push(C10);
  let T10 = new FY(b10, n10), E10 = [k10.shape, [n10.padInfo.top, n10.padInfo.left], [n10.strideHeight, n10.strideWidth], [n10.dilationHeight, n10.dilationWidth], [n10.inChannels], [n10.filterWidth * n10.inChannels], [n10.outWidth]], A10 = s10.runWebGLProgram(T10, [k10], "float32", E10), P10 = he2({ inputs: { x: A10 }, backend: s10, attrs: { shape: [1, b10[0], b10[1]] } });
  x10.push(A10), x10.push(P10);
  let R10 = r10 != null, F10 = a10 != null, $10 = o10 === "leakyrelu", z10 = o10 ? jp(o10, true) : null, W10 = new P1(P10.shape, C10.shape, [1, g10, n10.outChannels], y10, v10, R10, z10, F10, $10), q10 = [P10, C10];
  if (r10 && q10.push(r10), F10 && q10.push(a10), $10) {
    let te2 = s10.makeTensorInfo([], "float32", w2.createScalarValue(i10, "float32"));
    q10.push(te2), x10.push(te2);
  }
  let K10 = s10.runWebGLProgram(W10, q10, "float32"), Y10 = f10 ? [1, d10, p10, n10.outChannels] : [1, n10.outChannels, d10, p10], Z10 = he2({ inputs: { x: K10 }, backend: s10, attrs: { shape: Y10 } });
  x10.push(K10);
  for (let te2 of x10)
    s10.disposeIntermediateTensorInfo(te2);
  return Z10;
}
function OY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dataFormat: u10, dilations: l10, dimRoundingMode: c10 } = s10, p10 = N2.convertConv2DDataFormat(u10), d10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, l10, o10, c10, false, p10), h10;
  if (d10.filterHeight === 1 && d10.filterWidth === 1 && d10.dilationHeight === 1 && d10.dilationWidth === 1 && d10.strideHeight === 1 && d10.strideWidth === 1 && (d10.padInfo.type === "SAME" || d10.padInfo.type === "VALID"))
    h10 = G1({ x: r10, filter: a10, convInfo: d10, backend: n10 });
  else if (X2().getBool("WEBGL_CONV_IM2COL") && r10.shape[0] === 1)
    h10 = H1({ x: r10, filter: a10, convInfo: d10, backend: n10 });
  else {
    let m10 = new U1(d10);
    h10 = n10.runWebGLProgram(m10, [r10, a10], "float32");
  }
  let f10 = he2({ inputs: { x: h10 }, backend: n10, attrs: { shape: d10.outShape } });
  return n10.disposeIntermediateTensorInfo(h10), f10;
}
var PY = { kernelName: Na, backendName: "webgl", kernelFunc: OY };
var zY = class {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    let t = e.strideHeight, n10 = e.strideWidth, s10 = e.padInfo.top, r10 = e.padInfo.left, a10 = e.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s10};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n10} - ${r10};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a10}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var MY = class {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    let t = e.filterHeight, n10 = e.filterWidth, s10 = e.strideHeight, r10 = e.strideWidth, a10 = e.dataFormat === "channelsLast", i10 = t - 1 - e.padInfo.top, o10 = n10 - 1 - e.padInfo.left, u10 = a10 ? 1 : 2, l10 = a10 ? 2 : 3, c10 = a10 ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${i10}, ${o10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c10}];

        ivec2 dyCorner = ivec2(coords[${u10}], coords[${l10}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s10}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n10}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r10}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n10} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a10}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var LY = class {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    let t = e.strideDepth, n10 = e.strideHeight, s10 = e.strideWidth, r10 = e.padInfo.front, a10 = e.padInfo.top, i10 = e.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r10};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n10} - ${a10};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s10} - ${i10};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var BY = class {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    let t = e.filterDepth, n10 = e.filterHeight, s10 = e.filterWidth, r10 = e.strideDepth, a10 = e.strideHeight, i10 = e.strideWidth, o10 = t - 1 - e.padInfo.front, u10 = n10 - 1 - e.padInfo.top, l10 = s10 - 1 - e.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${o10}, ${u10}, ${l10});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r10}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n10}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a10}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n10} - 1 - wR;

            for (int wC = 0; wC < ${s10}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i10}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s10} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function VY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, pad: o10, dataFormat: u10, dimRoundingMode: l10, filterShape: c10 } = s10, p10 = N2.convertConv2DDataFormat(u10), d10 = N2.computeConv2DInfo(r10.shape, c10, i10, 1, o10, l10, false, p10), h10 = new zY(d10);
  return n10.runWebGLProgram(h10, [r10, a10], "float32");
}
var WY = { kernelName: ug, backendName: "webgl", kernelFunc: VY };
function UY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { inputShape: i10, strides: o10, pad: u10, dataFormat: l10, dimRoundingMode: c10 } = s10, p10 = N2.convertConv2DDataFormat(l10), d10 = N2.computeConv2DInfo(i10, a10.shape, o10, 1, u10, c10, false, p10), h10 = new MY(d10);
  return n10.runWebGLProgram(h10, [r10, a10], "float32");
}
var GY = { kernelName: Ta, backendName: "webgl", kernelFunc: UY };
function HY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10 } = s10, l10 = N2.computeConv3DInfo(r10.shape, a10.shape, i10, u10, o10), c10 = new DY(l10);
  return n10.runWebGLProgram(c10, [r10, a10], "float32");
}
var qY = { kernelName: Kd, backendName: "webgl", kernelFunc: HY };
function jY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, pad: o10, filterShape: u10 } = s10, l10 = N2.computeConv3DInfo(r10.shape, u10, i10, 1, o10), c10 = new LY(l10);
  return n10.runWebGLProgram(c10, [r10, a10], "float32");
}
var KY = { kernelName: lg, backendName: "webgl", kernelFunc: jY };
function XY(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { pad: i10, strides: o10, inputShape: u10 } = s10, l10 = N2.computeConv3DInfo(u10, a10.shape, o10, 1, i10), c10 = new BY(l10);
  return n10.runWebGLProgram(c10, [r10, a10], "float32");
}
var YY = { kernelName: cg, backendName: "webgl", kernelFunc: XY };
var QY = iu + `
  return cos(x);
`;
var ZY = Ke({ opSnippet: QY });
var JY = { kernelName: $a, backendName: "webgl", kernelFunc: ZY };
var e9 = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
var t9 = Ke({ opSnippet: e9 });
var n9 = { kernelName: _a, backendName: "webgl", kernelFunc: t9 };
var s9 = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    let [a10, i10, o10, u10] = e, [l10] = t, [c10, p10] = n10;
    this.outputShape = [l10, c10, p10, u10];
    let d10 = s10 === "bilinear" ? 1 : 0, [h10, f10] = [`${i10 - 1}.0`, `${o10 - 1}.0`], [m10, g10, b10] = c10 > 1 ? [`${(i10 - 1) / (c10 - 1)}`, "(y2-y1) * height_ratio", `y1*${h10} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${h10}`], [y10, v10, x10] = p10 > 1 ? [`${(o10 - 1) / (p10 - 1)}`, "(x2-x1) * width_ratio", `x1*${f10} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${f10}`];
    this.userCode = `
      const float height_ratio = float(${m10});
      const float width_ratio = float(${y10});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a10}) {
          return;
        }

        float height_scale = ${g10};
        float width_scale = ${v10};

        float in_y = ${b10};
        if( in_y < 0.0 || in_y > ${h10} ) {
          setOutput(float(${r10}));
          return;
        }
        float in_x = ${x10};
        if( in_x < 0.0 || in_x > ${f10} ) {
          setOutput(float(${r10}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d10} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
};
var r9 = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10, boxes: a10, boxInd: i10 } = t, { cropSize: o10, method: u10, extrapolationValue: l10 } = s10, c10 = new s9(r10.shape, a10.shape, o10, u10, l10);
  return n10.runWebGLProgram(c10, [r10, a10, i10], "float32");
};
var a9 = { kernelName: lo, backendName: "webgl", kernelFunc: r9 };
var fw = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }], this.outputShape = e;
    let s10 = e.length, r10 = t ? "0.0" : `getX(${mw(s10, "coords")})`, a10 = e[e.length - 1], i10 = "", o10 = "";
    t ? (i10 = n10 ? `end != ${a10 - 1}` : "end != 0", o10 = n10 ? "end + 1" : "end - 1") : (i10 = n10 ? `end + pow2 < ${a10}` : "end >= pow2", o10 = n10 ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${ot(s10)} coords = getOutputCoords();
        int end = ${gw(s10, "coords")};
        float val = ${r10};
        int pow2 = int(pow(2.0, index));
        if (${i10}) {
          int idx = ${o10};
          ${gw(s10, "coords")} = idx;
          val += getX(${mw(s10, "coords")});
        }
        setOutput(val);
      }
    `;
  }
};
function mw(e, t) {
  if (e === 1)
    return `${t}`;
  if (e === 2)
    return `${t}.x, ${t}.y`;
  if (e === 3)
    return `${t}.x, ${t}.y, ${t}.z`;
  if (e === 4)
    return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
  throw Error(`Cumulative sum for rank ${e} is not yet supported`);
}
function gw(e, t) {
  if (e === 1)
    return `${t}`;
  if (e === 2)
    return `${t}.y`;
  if (e === 3)
    return `${t}.z`;
  if (e === 4)
    return `${t}.w`;
  throw Error(`Cumulative sum for rank ${e} is not yet supported`);
}
function i9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, exclusive: i10, reverse: o10 } = s10, u10 = r10.shape.length, l10 = N2.getAxesPermutation([a10], u10), c10 = r10;
  l10 != null && (c10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: l10 } }));
  let p10 = N2.getInnerMostAxes(1, u10)[0];
  if (p10 !== u10 - 1)
    throw new Error(`WebGL cumsum shader expects an inner-most axis=${r10.shape.length - 1} but got axis=${a10}`);
  let d10 = c10.shape[p10], h10 = En({ inputs: { x: c10 }, backend: n10 });
  for (let f10 = 0; f10 <= Math.ceil(Math.log2(d10)) - 1; f10++) {
    let m10 = new fw(c10.shape, false, o10), g10 = [[f10]], b10 = h10;
    h10 = n10.runWebGLProgram(m10, [h10], h10.dtype, g10), n10.disposeIntermediateTensorInfo(b10);
  }
  if (i10) {
    let f10 = new fw(c10.shape, i10, o10), m10 = h10;
    h10 = n10.runWebGLProgram(f10, [h10], h10.dtype), n10.disposeIntermediateTensorInfo(m10);
  }
  if (l10 != null) {
    let f10 = N2.getUndoAxesPermutation(l10), m10 = cn({ inputs: { x: h10 }, backend: n10, attrs: { perm: f10 } });
    return n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(c10), m10;
  }
  return h10;
}
var o9 = { kernelName: uo, backendName: "webgl", kernelFunc: i9 };
function u9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, weights: a10 } = t, { size: i10, binaryOutput: o10 } = s10;
  if (r10.shape.length === 1) {
    let u10 = n10.readSync(r10.dataId), l10 = n10.readSync(a10.dataId), c10 = S1(u10, l10, a10.dtype, a10.shape, i10);
    return n10.makeTensorInfo([i10], a10.dtype, c10);
  } else if (r10.shape.length === 2) {
    let u10 = n10.bufferSync(r10), l10 = n10.bufferSync(a10), c10 = SK(u10, l10, i10, o10);
    return n10.makeTensorInfo(c10.shape, a10.dtype, c10.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r10.shape.length}.`);
}
var l9 = { kernelName: dg, backendName: "webgl", kernelFunc: u9 };
var c9 = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n10, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
  }
  getInputSamplingString() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
};
function d9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockSize: a10, dataFormat: i10 } = s10, o10 = r10.shape[0], u10 = i10 === "NHWC" ? r10.shape[1] : r10.shape[2], l10 = i10 === "NHWC" ? r10.shape[2] : r10.shape[3], c10 = i10 === "NHWC" ? r10.shape[3] : r10.shape[1], p10 = u10 * a10, d10 = l10 * a10, h10 = c10 / (a10 * a10), f10 = i10 === "NHWC" ? [o10, p10, d10, h10] : [o10, h10, p10, d10], m10 = new c9(f10, a10, i10);
  return n10.runWebGLProgram(m10, [r10], r10.dtype);
}
var p9 = { kernelName: co, backendName: "webgl", kernelFunc: d9 };
var q1 = class {
  constructor(e, t = false, n10 = null, s10 = false, r10 = false) {
    this.variableNames = ["x", "W"], this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e.outShape, this.enableShapeUniforms = kn(this.outputShape.length);
    let a10 = e.filterHeight, i10 = e.filterWidth, o10 = e.outChannels / e.inChannels, u10 = "", l10 = "";
    n10 && (s10 ? u10 = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n10}
        }` : r10 ? u10 = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n10}
        }` : u10 = `
          float activation(float x) {
            ${n10}
          }
        `, l10 = "result = activation(result);");
    let c10 = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), r10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${u10}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o10};
        int q = d2 - d1 * ${o10};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a10}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i10}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c10}
        ${l10}
        setOutput(result);
      }
    `;
  }
};
var j1 = class {
  constructor(e, t = false, n10 = null, s10 = false, r10 = false) {
    this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e.outShape, this.enableShapeUniforms = kn(this.outputShape.length);
    let a10 = e.outChannels / e.inChannels, i10 = e.padInfo.left, o10 = e.strideWidth, u10 = e.dilationWidth, l10 = e.filterHeight, c10 = e.filterWidth, p10 = c10, d10 = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
    for (let g10 = 0; g10 < c10; g10++)
      d10 += `
          vec4 xTexelC${g10 * 2};
          int xTexelC${g10 * 2}Ready;
          vec4 xTexelC${g10 * 2 + 1};
          int xTexelC${g10 * 2 + 1}Ready;
          vec4 xC${g10};`;
    d10 += `
    for (int r = 0; r < ${l10}; r++) {
      `;
    for (let g10 = 0; g10 < c10; g10++)
      d10 += `
          xTexelC${g10 * 2} = vec4(0.0);
          xTexelC${g10 * 2}Ready = 0;
          xTexelC${g10 * 2 + 1} = vec4(0.0);
          xTexelC${g10 * 2 + 1}Ready = 0;
          xC${g10} = vec4(0.0);`;
    d10 += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
    for (let g10 = 0; g10 < (p10 + 1) / 2; g10++) {
      let b10 = g10 * 2;
      if (d10 += `
          xC = xCCorner + ${b10 * u10};
          `, o10 === 1) {
        if (b10 < c10 && (i10 % 2 === 1 ? (d10 += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10}Ready == 0) {
                  xTexelC${b10} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b10}.zw = vec2(0.0);
                  }
                  xTexelC${b10}Ready = 1;
                }
              `, u10 === 1 && b10 > 0 ? d10 += `
                xC${b10} = vec4(xTexelC${b10 - 2}.zw, xTexelC${b10}.xy);
                ` : d10 += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b10} = vec4(previous.zw, xTexelC${b10}.xy);
                  } else {
                    xC${b10} = vec4(0.0, 0.0, xTexelC${b10}.xy);
                  }
                  `) : d10 += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${b10}Ready == 0) {
                  xTexelC${b10} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b10}.zw = vec2(0.0);
                  }
                  xTexelC${b10}Ready = 1;
                }

                xC${b10} = xTexelC${b10};
                `, b10 + 1 < c10)) {
          let y10 = i10 % 2 === 0 ? w2.nearestLargerEven(u10) : u10;
          u10 % 2 === 0 && i10 % 2 === 1 || u10 % 2 !== 0 && i10 % 2 !== 1 ? (d10 += `
                  xCOffset = xC + imod(pads[1], 2) + ${y10};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10 + 1}Ready == 0) {
                    xTexelC${b10 + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b10 + 1}.zw = vec2(0.0);
                    }
                    xTexelC${b10 + 1}Ready = 1;
                  }
                  `, u10 > 1 && (d10 += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10}Ready == 0) {
                      xTexelC${b10} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b10}Ready = 1;
                    }
                    `), d10 += `
                  xC${b10 + 1} = vec4(xTexelC${b10}.zw, xTexelC${b10 + 1}.xy);
                  `) : y10 === 1 ? d10 += `
                    xC${b10 + 1} = xTexelC${b10};
                    ` : d10 += `
                    xCOffset = xC + ${y10};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10 + 1}Ready == 0) {
                      xTexelC${b10 + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b10 + 1}.zw = vec2(0.0);
                      }
                      xTexelC${b10 + 1}Ready = 1;
                    }

                    xC${b10 + 1} = xTexelC${b10 + 1};
                    `;
        }
      } else
        b10 < c10 && (i10 % 2 === 1 ? (d10 += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10}Ready == 0) {
                  xTexelC${b10} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b10}.zw = vec2(0.0);
                  }
                  xTexelC${b10}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b10 + 1}Ready == 0) {
                  xTexelC${b10 + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b10 + 1}.zw = vec2(0.0);
                  }
                  xTexelC${b10 + 1}Ready = 1;
                }

                xC${b10} = vec4(xTexelC${b10}.zw, xTexelC${b10 + 1}.zw);
              `, b10 + 1 < c10 && (d10 += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b10 + 1} = vec4(xTexelC${b10 + 1}.xy, final.xy);
                `)) : (d10 += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${b10}Ready == 0) {
                  xTexelC${b10} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b10}.zw = vec2(0.0);
                  }
                  xTexelC${b10}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b10 + 1}Ready == 0) {
                  xTexelC${b10 + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b10 + 1}.zw = vec2(0.);
                  }
                  xTexelC${b10 + 1}Ready = 1;
                }

                xC${b10} = vec4(
                  xTexelC${b10}.xy, xTexelC${b10 + 1}.xy);
              `, b10 + 1 < c10 && (d10 += `
                  xC${b10 + 1} = vec4(xTexelC${b10}.zw, xTexelC${b10 + 1}.zw);
                `)));
      b10 < c10 && (d10 += `
            wTexel = getW(r, ${b10}, d1, q);
            dotProd += xC${b10} * vec4(wTexel.xz, wTexel.xz);
          `, b10 + 1 < c10 && (d10 += `
              wTexel = getW(r, ${b10 + 1}, d1, q);
              dotProd += xC${b10 + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
    }
    d10 += `
    }
  `, d10 += `
      }
    `;
    let h10 = "", f10 = "";
    n10 && (s10 ? h10 = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n10}
        }` : r10 ? h10 = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n10}
        }` : h10 = `vec4 activation(vec4 x) {
          ${n10}
        }`, f10 = "result = activation(result);");
    let m10 = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), r10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${h10}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a10};
        int q = d2 - d1 * ${a10};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d10}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m10}
        ${f10}
        setOutput(result);
      }
    `;
  }
};
function h9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10, dimRoundingMode: l10 } = s10, c10 = u10;
  c10 == null && (c10 = [1, 1]), w2.assert(N2.eitherStridesOrDilationsAreOne(i10, c10), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i10} and dilations '${c10}'`);
  let p10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, c10, o10, l10, true), d10;
  X2().getBool("WEBGL_PACK_DEPTHWISECONV") && p10.strideWidth <= 2 && p10.outChannels / p10.inChannels === 1 ? d10 = new j1(p10) : d10 = new q1(p10);
  let h10 = [[p10.padInfo.top, p10.padInfo.left], [p10.strideHeight, p10.strideWidth], [p10.dilationHeight, p10.dilationWidth], [p10.inHeight, p10.inWidth]];
  return n10.runWebGLProgram(d10, [r10, a10], "float32", h10);
}
var f9 = { kernelName: Aa, backendName: "webgl", kernelFunc: h9 };
var m9 = class {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    let t = e.strideHeight, n10 = e.strideWidth, s10 = e.padInfo.top, r10 = e.padInfo.left, a10 = e.outChannels / e.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a10} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s10};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n10} - ${r10};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var g9 = class {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    let t = e.filterHeight, n10 = e.filterWidth, s10 = e.strideHeight, r10 = e.strideWidth, a10 = t - 1 - e.padInfo.top, i10 = n10 - 1 - e.padInfo.left, o10 = e.outChannels / e.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${a10}, ${i10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s10}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n10}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r10}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n10} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o10}; dm++) {
              int d2 = d1 * ${o10} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function b9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, dy: a10 } = t, { strides: i10, dilations: o10, pad: u10, dimRoundingMode: l10, filterShape: c10 } = s10, p10 = N2.computeConv2DInfo(r10.shape, c10, i10, o10, u10, l10, true), d10 = new m9(p10);
  return n10.runWebGLProgram(d10, [r10, a10], "float32");
}
var y9 = { kernelName: pg, backendName: "webgl", kernelFunc: b9 };
function v9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { strides: i10, dilations: o10, pad: u10, dimRoundingMode: l10, inputShape: c10 } = s10, p10 = N2.computeConv2DInfo(c10, a10.shape, i10, o10, u10, l10, true), d10 = new g9(p10);
  return n10.runWebGLProgram(d10, [r10, a10], "float32");
}
var x9 = { kernelName: hg, backendName: "webgl", kernelFunc: v9 };
var w9 = class {
  constructor(e) {
    this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
  }
};
function k9(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t, r10 = [...s10.shape, ...s10.shape], a10 = w2.sizeFromShape(s10.shape), i10 = he2({ inputs: { x: s10 }, backend: n10, attrs: { shape: [a10] } }), o10 = new w9(a10), u10 = n10.runWebGLProgram(o10, [i10], i10.dtype), l10 = he2({ inputs: { x: u10 }, backend: n10, attrs: { shape: r10 } });
  return n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(u10), l10;
}
var I9 = { kernelName: fg, backendName: "webgl", kernelFunc: k9 };
var S9 = class {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    let { inHeight: t, inWidth: n10, padInfo: s10, strideHeight: r10, strideWidth: a10, filterHeight: i10, filterWidth: o10, dilationHeight: u10, dilationWidth: l10 } = e, { top: c10, left: p10 } = s10;
    this.userCode = `
      const ivec2 strides = ivec2(${r10}, ${a10});
      const ivec2 pads = ivec2(${c10}, ${p10});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i10}; h++) {
          int hIn = hBeg + h * ${u10};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o10}; w++) {
              int wIn = wBeg + w * ${l10};

              if (wIn >= 0 && wIn < ${n10}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
};
function C9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10 } = s10, l10 = N2.computeDilation2DInfo(r10.shape, a10.shape, i10, o10, "NHWC", u10), c10, p10 = new S9(l10);
  c10 = n10.runWebGLProgram(p10, [r10, a10], "float32");
  let d10 = he2({ inputs: { x: c10 }, backend: n10, attrs: { shape: l10.outShape } });
  return n10.disposeIntermediateTensorInfo(c10), d10;
}
var N9 = { kernelName: Xd, backendName: "webgl", kernelFunc: C9 };
function T9(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { equation: r10 } = s10, a10 = t, { allDims: i10, summedDims: o10, idDims: u10 } = N2.decodeEinsumEquation(r10, a10.length);
  N2.checkEinsumDimSizes(i10.length, u10, a10);
  let { path: l10, steps: c10 } = N2.getEinsumComputePath(o10, u10), p10 = c10.length, d10 = null, h10 = i10.length, f10 = [];
  for (let m10 = 0; m10 < p10; ++m10) {
    for (let g10 of c10[m10]) {
      let { permutationIndices: b10, expandDims: y10 } = N2.getEinsumPermutation(h10, u10[g10]), v10;
      N2.isIdentityPermutation(b10) ? v10 = a10[g10] : (v10 = cn({ inputs: { x: a10[g10] }, backend: n10, attrs: { perm: b10 } }), f10.push(v10));
      let x10 = v10.shape.slice();
      for (let k10 = 0; k10 < y10.length; ++k10)
        x10.splice(y10[k10], 0, 1);
      w2.arraysEqual(v10.shape, x10) || (v10 = he2({ inputs: { x: v10 }, backend: n10, attrs: { shape: x10 } }), f10.push(v10)), d10 === null ? d10 = v10 : (d10 = vv({ inputs: { a: v10, b: d10 }, backend: n10 }), f10.push(d10));
    }
    m10 < p10 - 1 && (l10[m10] >= 0 && (d10 = Xp({ inputs: { x: d10 }, backend: n10, attrs: { axis: l10[m10] - (i10.length - h10), keepDims: false } }), f10.push(d10)), h10--);
  }
  for (let m10 of f10)
    m10 !== d10 && n10.disposeIntermediateTensorInfo(m10);
  return d10;
}
var $9 = { kernelName: Yd, backendName: "webgl", kernelFunc: T9 };
var _9 = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
var A9 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
var E9 = Ke({ opSnippet: _9, packedOpSnippet: A9 });
var R9 = { kernelName: Ra, backendName: "webgl", kernelFunc: E9 };
var D9 = "return (b >= 1.0) ? a : a * (b + 1.0);";
var F9 = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
var O9 = (e) => {
  let { inputs: t, backend: n10 } = e, { dy: s10, y: r10 } = t, a10 = X2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ql(F9, s10.shape, r10.shape) : new no(D9, s10.shape, r10.shape);
  return n10.runWebGLProgram(a10, [s10, r10], s10.dtype);
};
var P9 = { kernelName: mg, backendName: "webgl", kernelFunc: O9 };
var z9 = `
  return vec4(equal(a, b));
`;
var M9 = "return float(a == b);";
var L9 = qt({ opSnippet: M9, packedOpSnippet: z9, dtype: "bool", cpuKernelImpl: TK });
var B9 = { kernelName: po, backendName: "webgl", kernelFunc: L9 };
var V9 = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${N2.ERF_P};
  float a1 = ${N2.ERF_A1};
  float a2 = ${N2.ERF_A2};
  float a3 = ${N2.ERF_A3};
  float a4 = ${N2.ERF_A4};
  float a5 = ${N2.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
var W9 = Ke({ opSnippet: V9 });
var U9 = { kernelName: pl, backendName: "webgl", kernelFunc: W9 };
var G9 = iu + `
  return exp(x);
`;
var H9 = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var K1 = Ke({ opSnippet: G9, packedOpSnippet: H9, cpuKernelImpl: $K, dtype: "float32" });
var q9 = { kernelName: Da, backendName: "webgl", kernelFunc: K1 };
function Gm(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { dim: r10 } = n10, { input: a10 } = t, i10 = a10.shape.length, o10 = a10.shape.slice(), u10 = r10;
  return r10 < 0 && (w2.assert(-(i10 + 1) <= r10, () => `Axis must be in the interval [${-(i10 + 1)}, ${i10}]`), u10 = i10 + r10 + 1), o10.splice(u10, 0, 1), he2({ inputs: { x: a10 }, backend: s10, attrs: { shape: o10 } });
}
var j9 = { kernelName: ho, backendName: "webgl", kernelFunc: Gm };
var bw = "return exp(x) - 1.0;";
var K9 = Ke({ opSnippet: bw, packedOpSnippet: bw, cpuKernelImpl: _K });
var X9 = { kernelName: fo, backendName: "webgl", kernelFunc: K9 };
var yw = class {
  constructor(e, t, n10) {
    this.variableNames = ["real", "imag"];
    let s10 = t[1];
    this.outputShape = t;
    let r10 = n10 ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, a10 = n10 ? `${s10}.0` : "1.0", i10;
    if (e === "real")
      i10 = "return real * expR - imag * expI;";
    else if (e === "imag")
      i10 = "return real * expI + imag * expR;";
    else
      throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);
    this.userCode = `
      const float exponentMultiplier = ${r10};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i10}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s10});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s10}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a10};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
};
function X1(e, t, n10) {
  let s10 = n10.texData.get(e.dataId), r10 = w2.sizeFromShape(e.shape), a10 = e.shape[e.shape.length - 1], i10 = r10 / a10, o10 = he2({ inputs: { x: e }, backend: n10, attrs: { shape: [i10, a10] } }), u10 = o10.shape, l10 = new yw("real", u10, t), c10 = new yw("imag", u10, t), p10 = [{ dataId: s10.complexTensorInfos.real.dataId, dtype: s10.complexTensorInfos.real.dtype, shape: u10 }, { dataId: s10.complexTensorInfos.imag.dataId, dtype: s10.complexTensorInfos.imag.dtype, shape: u10 }], d10 = n10.runWebGLProgram(l10, p10, "float32"), h10 = n10.runWebGLProgram(c10, p10, "float32"), f10 = Er({ inputs: { real: d10, imag: h10 }, backend: n10 });
  n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10);
  let m10 = he2({ inputs: { x: f10 }, backend: n10, attrs: { shape: e.shape } });
  return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(f10), m10;
}
function Y9(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t;
  return X1(s10, false, n10);
}
var Q9 = { kernelName: gg, backendName: "webgl", kernelFunc: Y9 };
var Z9 = class {
  constructor(e, t) {
    this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = e, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
};
function Jl(e) {
  let { backend: t, attrs: n10 } = e, { shape: s10, value: r10 } = n10, { dtype: a10 } = n10;
  if (a10 = a10 || w2.inferDtype(r10), a10 === "string") {
    let i10 = w2.getArrayFromDType(a10, w2.sizeFromShape(s10));
    return i10.fill(r10), t.makeTensorInfo(s10, a10, i10);
  } else {
    let i10 = new Z9(s10, r10), o10 = [[r10]];
    return t.runWebGLProgram(i10, [], a10, o10);
  }
}
var J9 = { kernelName: hl, backendName: "webgl", kernelFunc: Jl };
var eQ = class {
  constructor(e) {
    this.variableNames = ["Image"], this.outputShape = [];
    let t = e[2];
    this.outputShape = e, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var tQ = { kernelName: mo, backendName: "webgl", kernelFunc: ({ inputs: e, backend: t }) => {
  let { image: n10 } = e, s10 = t, r10 = new eQ(n10.shape);
  return s10.runWebGLProgram(r10, [n10], n10.dtype);
} };
var vw = "return floor(x);";
var nQ = Ke({ opSnippet: vw, packedOpSnippet: vw, cpuKernelImpl: AK });
var sQ = { kernelName: Fa, backendName: "webgl", kernelFunc: nQ };
var rQ = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
var aQ = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
var iQ = qt({ opSnippet: rQ, packedOpSnippet: aQ, dtype: "int32" });
var oQ = { kernelName: Oa, backendName: "webgl", kernelFunc: iQ };
var uQ = class {
  constructor(e) {
    this.variableNames = ["A"];
    let t = hn(), [n10, s10] = e;
    this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s10}.0, ${n10}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
};
var lQ = class {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    let t = hn(), [n10, s10] = e;
    this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s10}.0, ${n10}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `;
  }
};
var cQ = { kernelName: hd, backendName: "webgl", kernelFunc: dQ };
var zi;
function dQ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { pixels: r10 } = t, { numChannels: a10 } = s10, i10 = typeof HTMLVideoElement != "undefined" && r10 instanceof HTMLVideoElement, o10 = typeof HTMLImageElement != "undefined" && r10 instanceof HTMLImageElement, [u10, l10] = i10 ? [r10.videoWidth, r10.videoHeight] : [r10.width, r10.height], c10 = [l10, u10], p10 = [l10, u10, a10];
  (o10 || i10) && (zi == null && (zi = document.createElement("canvas").getContext("2d")), zi.canvas.width = u10, zi.canvas.height = l10, zi.drawImage(r10, 0, 0, u10, l10), r10 = zi.canvas);
  let d10 = n10.makeTensorInfo(c10, "int32");
  n10.texData.get(d10.dataId).usage = 2, n10.gpgpu.uploadPixelDataToTexture(n10.getTexture(d10.dataId), r10);
  let h10 = X2().getBool("WEBGL_PACK") ? new lQ(p10) : new uQ(p10), f10 = n10.runWebGLProgram(h10, [d10], "int32");
  return n10.disposeData(d10.dataId), f10;
}
function pQ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = s10, m10 = N2.convertConv2DDataFormat(c10), g10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, p10, l10, d10, false, m10), b10, y10 = [];
  if (g10.filterHeight === 1 && g10.filterWidth === 1 && g10.dilationHeight === 1 && g10.dilationWidth === 1 && g10.strideHeight === 1 && g10.strideWidth === 1 && (g10.padInfo.type === "SAME" || g10.padInfo.type === "VALID"))
    b10 = G1({ x: r10, filter: a10, convInfo: g10, backend: n10, bias: i10, activation: h10, preluActivationWeights: o10, leakyreluAlpha: f10 });
  else if (X2().getBool("WEBGL_CONV_IM2COL") && r10.shape[0] === 1)
    b10 = H1({ x: r10, filter: a10, convInfo: g10, backend: n10, bias: i10, activation: h10, preluActivationWeights: o10, leakyreluAlpha: f10 });
  else {
    let x10 = i10 != null, k10 = o10 != null, C10 = h10 === "leakyrelu", T10 = h10 ? jp(h10, false) : null, E10 = new U1(g10, x10, T10, k10, C10), A10 = [r10, a10];
    if (i10 && A10.push(i10), o10 && A10.push(o10), C10) {
      let P10 = n10.makeTensorInfo([], "float32", w2.createScalarValue(f10, "float32"));
      A10.push(P10), y10.push(P10);
    }
    b10 = n10.runWebGLProgram(E10, A10, "float32");
  }
  let v10 = he2({ inputs: { x: b10 }, backend: n10, attrs: { shape: g10.outShape } });
  return y10.push(b10), y10.forEach((x10) => n10.disposeIntermediateTensorInfo(x10)), v10;
}
var hQ = { kernelName: sa, backendName: "webgl", kernelFunc: pQ };
function fQ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dilations: c10, dimRoundingMode: p10, activation: d10, leakyreluAlpha: h10 } = s10, f10 = [], m10 = c10;
  m10 == null && (m10 = [1, 1]), w2.assert(N2.eitherStridesOrDilationsAreOne(u10, m10), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u10} and dilations '${m10}'`);
  let g10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, m10, l10, p10, true), b10 = X2().getBool("WEBGL_PACK_DEPTHWISECONV") && g10.strideWidth <= 2 && g10.outChannels / g10.inChannels === 1, y10 = d10 ? jp(d10, b10) : null, v10 = [r10, a10], x10 = i10 != null, k10 = o10 != null, C10 = d10 === "leakyrelu";
  if (x10 && v10.push(i10), k10 && v10.push(o10), C10) {
    let P10 = n10.makeTensorInfo([], "float32", w2.createScalarValue(h10, "float32"));
    v10.push(P10), f10.push(P10);
  }
  let T10;
  b10 ? T10 = new j1(g10, x10, y10, k10, C10) : T10 = new q1(g10, x10, y10, k10, C10);
  let E10 = [[g10.padInfo.top, g10.padInfo.left], [g10.strideHeight, g10.strideWidth], [g10.dilationHeight, g10.dilationWidth], [g10.inHeight, g10.inWidth]], A10 = n10.runWebGLProgram(T10, v10, "float32", E10);
  return f10.forEach((P10) => n10.disposeIntermediateTensorInfo(P10)), A10;
}
var mQ = { kernelName: ra, backendName: "webgl", kernelFunc: fQ };
var gQ = class {
  constructor(e, t, n10) {
    this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n10;
    let s10 = ot(t.length), r10 = ot(n10.length), a10 = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${s10} strides = ${s10}(${this.strides});
         void main() {
          ${r10} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a10};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
  }
};
function bQ(e) {
  let { inputs: t, backend: n10 } = e, { params: s10, indices: r10 } = t, a10 = r10.shape, i10 = a10[a10.length - 1], o10 = w2.sizeFromShape(s10.shape), [u10, l10, c10, p10] = N2.prepareAndValidate(s10, r10), d10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [l10, i10] } }), h10 = he2({ inputs: { x: s10 }, backend: n10, attrs: { shape: [w2.sizeFromShape(s10.shape) / c10, c10] } });
  if (n10.shouldExecuteOnCPU([s10, r10]) || s10.dtype === "string") {
    let b10 = n10.readSync(r10.dataId), y10 = n10.bufferSync(s10), v10 = EK(b10, y10, s10.dtype, l10, i10, c10, p10, s10.shape, o10);
    return n10.makeTensorInfo(u10, s10.dtype, v10.values);
  }
  let f10 = new gQ(i10, p10, [l10, c10]), m10 = n10.runWebGLProgram(f10, [h10, d10], h10.dtype), g10 = he2({ inputs: { x: m10 }, backend: n10, attrs: { shape: u10 } });
  return n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(m10), g10;
}
var yQ = { kernelName: bo, backendName: "webgl", kernelFunc: bQ };
var vQ = class {
  constructor(e, t) {
    this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;
    let n10 = ot(this.rank), s10 = xQ(e, 2);
    this.userCode = `
      void main() {
        ${n10} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s10}));
      }
    `;
  }
};
function xQ(e, t) {
  let n10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s10 = [];
  for (let r10 = 0; r10 < e.length; r10++)
    r10 === 2 ? s10.push("index") : s10.push(`${n10[r10]}`);
  return s10.join();
}
function Y1(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, indices: a10 } = t, { axis: i10, batchDims: o10 } = s10, u10 = w2.parseAxisParam(i10, r10.shape)[0];
  if (X2().get("DEBUG")) {
    let y10 = n10.readSync(a10.dataId), v10 = r10.shape[u10];
    for (let x10 = 0; x10 < y10.length; ++x10) {
      let k10 = y10[x10];
      w2.assert(k10 <= v10 - 1 && k10 >= 0, () => `GatherV2: the index value ${k10} is not in [0, ${v10 - 1}]`);
    }
  }
  let l10 = N2.segment_util.collectGatherOpShapeInfo(r10, a10, u10, o10), c10 = w2.sizeFromShape(a10.shape), p10 = [], d10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [l10.batchSize, l10.outerSize, l10.dimSize, l10.sliceSize] } }), h10 = he2({ inputs: { x: a10 }, backend: n10, attrs: { shape: [l10.batchSize, c10 / l10.batchSize] } });
  p10.push(d10), p10.push(h10);
  let f10 = [l10.batchSize, l10.outerSize, c10 / l10.batchSize, l10.sliceSize];
  if (n10.shouldExecuteOnCPU([r10, a10]) || r10.dtype === "string") {
    let y10 = n10.bufferSync(h10), v10 = n10.bufferSync(d10), x10 = RK(v10, y10, f10);
    return p10.forEach((k10) => n10.disposeIntermediateTensorInfo(k10)), n10.makeTensorInfo(l10.outputShape, x10.dtype, x10.values);
  }
  let m10 = new vQ(d10.shape, f10), g10 = n10.runWebGLProgram(m10, [d10, h10], d10.dtype);
  p10.push(g10);
  let b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: l10.outputShape } });
  return p10.forEach((y10) => n10.disposeIntermediateTensorInfo(y10)), b10;
}
var wQ = { kernelName: go, backendName: "webgl", kernelFunc: Y1 };
var kQ = "return float(a > b);";
var IQ = `
  return vec4(greaterThan(a, b));
`;
var SQ = qt({ opSnippet: kQ, packedOpSnippet: IQ, cpuKernelImpl: DK, dtype: "bool" });
var CQ = { kernelName: yo, backendName: "webgl", kernelFunc: SQ };
var NQ = "return float(a >= b);";
var TQ = `
  return vec4(greaterThanEqual(a, b));
`;
var $Q = qt({ opSnippet: NQ, packedOpSnippet: TQ, dtype: "bool", cpuKernelImpl: FK });
var _Q = { kernelName: za, backendName: "webgl", kernelFunc: $Q };
function AQ(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t;
  return X1(s10, true, n10);
}
var EQ = { kernelName: bg, backendName: "webgl", kernelFunc: AQ };
var RQ = "return float(!isnan(x) && !isinf(x));";
var DQ = Ke({ opSnippet: RQ, dtype: "bool" });
var FQ = { kernelName: fl, backendName: "webgl", kernelFunc: DQ };
var OQ = "return float(isinf(x));";
var PQ = Ke({ opSnippet: OQ, dtype: "bool" });
var zQ = { kernelName: ml, backendName: "webgl", kernelFunc: PQ };
var MQ = "return float(isnan(x));";
var LQ = Ke({ opSnippet: MQ, dtype: "bool" });
var BQ = { kernelName: gl, backendName: "webgl", kernelFunc: LQ };
var VQ = "return float(a < b);";
var WQ = `
  return vec4(lessThan(a, b));
`;
var UQ = qt({ opSnippet: VQ, packedOpSnippet: WQ, cpuKernelImpl: OK, dtype: "bool" });
var GQ = { kernelName: vo, backendName: "webgl", kernelFunc: UQ };
var HQ = "return float(a <= b);";
var qQ = `
  return vec4(lessThanEqual(a, b));
`;
var jQ = qt({ opSnippet: HQ, packedOpSnippet: qQ, cpuKernelImpl: PK, dtype: "bool" });
var KQ = { kernelName: xo, backendName: "webgl", kernelFunc: jQ };
function XQ(e) {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, num: a10 } = n10, i10 = zK(s10, r10, a10);
  return t.makeTensorInfo([i10.length], "float32", i10);
}
var YQ = { kernelName: yg, backendName: "webgl", kernelFunc: XQ };
var QQ = iu + `
  return x < 0.0 ? 0./0. : log(x);
`;
var ZQ = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
var JQ = Ke({ opSnippet: QQ, packedOpSnippet: ZQ, cpuKernelImpl: MK });
var eZ = { kernelName: Ba, backendName: "webgl", kernelFunc: JQ };
var tZ = iu + `
  return log(1.0 + x);
`;
var nZ = Ke({ opSnippet: tZ });
var sZ = { kernelName: bl, backendName: "webgl", kernelFunc: nZ };
var rZ = "return float(a >= 1.0 && b >= 1.0);";
var aZ = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
var iZ = qt({ opSnippet: rZ, packedOpSnippet: aZ, dtype: "bool" });
var oZ = { kernelName: wo, backendName: "webgl", kernelFunc: iZ };
var uZ = "return float(!(x >= 1.0));";
var lZ = Ke({ opSnippet: uZ });
var cZ = { kernelName: yl, backendName: "webgl", kernelFunc: lZ };
var dZ = "return float(a >= 1.0 || b >= 1.0);";
var pZ = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
var hZ = qt({ opSnippet: dZ, packedOpSnippet: pZ, dtype: "bool" });
var fZ = { kernelName: Zd, backendName: "webgl", kernelFunc: hZ };
var mZ = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["x"], this.outputShape = [];
    let a10 = t, i10 = e[3] - 1;
    this.outputShape = e;
    let o10, u10 = `float(${n10}) + float(${s10}) * sum`;
    r10 === 0.5 ? o10 = `inversesqrt(${u10})` : r10 === 1 ? o10 = `1.0/(${u10})` : o10 = `exp(log(${u10}) * float(-${r10}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a10}; j <= ${a10}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i10}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o10};
        setOutput(val);
      }
    `;
  }
};
var gZ = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
    let a10 = t, i10 = e[3] - 1;
    this.outputShape = e;
    let o10, u10 = `float(${n10}) + float(${s10}) * sum`;
    r10 === 0.5 ? o10 = `inversesqrt(${u10})` : r10 === 1 ? o10 = `1.0/(${u10})` : o10 = `exp(log(${u10}) * float(-${r10}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a10};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a10}; j <= ${a10}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i10}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o10};
        setOutput(result);
      }
    `;
  }
};
var bZ = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { depthRadius: a10, bias: i10, alpha: o10, beta: u10 } = s10, l10 = X2().getBool("WEBGL_PACK_NORMALIZATION") ? new gZ(r10.shape, a10, i10, o10, u10) : new mZ(r10.shape, a10, i10, o10, u10);
  return n10.runWebGLProgram(l10, [r10], r10.dtype);
};
var yZ = { kernelName: Jd, backendName: "webgl", kernelFunc: bZ };
var vZ = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n10, this.alpha = s10, this.beta = r10, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s10}) * norm + float(${n10});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s10})
                * float(${r10})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r10});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
};
var xZ = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, y: a10, dy: i10 } = t, { depthRadius: o10, bias: u10, alpha: l10, beta: c10 } = s10, p10 = new vZ(r10.shape, o10, u10, l10, c10);
  return n10.runWebGLProgram(p10, [r10, a10, i10], r10.dtype);
};
var wZ = { kernelName: vg, backendName: "webgl", kernelFunc: xZ };
function kZ(e, t, n10, s10) {
  let r10 = w2.sizeFromShape(t), i10 = w2.sizeFromShape(e.shape) / r10, o10 = he2({ inputs: { x: e }, attrs: { shape: [i10, r10] }, backend: s10 }), u10 = yi(o10, e.dtype, "max", s10), l10 = he2({ inputs: { x: u10 }, attrs: { shape: n10 }, backend: s10 });
  return s10.disposeIntermediateTensorInfo(o10), s10.disposeIntermediateTensorInfo(u10), l10;
}
function Q1(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reductionIndices: a10, keepDims: i10 } = s10, o10 = r10.shape.length, u10 = w2.parseAxisParam(a10, r10.shape), l10 = u10, c10 = N2.getAxesPermutation(l10, o10), p10 = c10 != null, d10 = n10.shouldExecuteOnCPU([r10]), h10 = r10;
  if (p10) {
    if (d10) {
      let v10 = n10.texData.get(h10.dataId).values, x10 = new Array(o10);
      for (let T10 = 0; T10 < x10.length; T10++)
        x10[T10] = r10.shape[c10[T10]];
      let k10 = yv(v10, r10.shape, r10.dtype, c10, x10);
      h10 = n10.makeTensorInfo(x10, r10.dtype);
      let C10 = n10.texData.get(h10.dataId);
      C10.values = k10;
    } else
      h10 = Kp(r10, c10, n10);
    l10 = N2.getInnerMostAxes(l10.length, o10);
  }
  N2.assertAxesAreInnerMostDims("max", l10, o10);
  let [f10, m10] = N2.computeOutAndReduceShapes(h10.shape, l10), g10 = f10;
  i10 && (g10 = N2.expandShapeToKeepDim(f10, u10));
  let b10;
  if (d10) {
    let v10 = n10.texData.get(h10.dataId).values, x10 = LK(v10, w2.sizeFromShape(m10), g10, r10.dtype);
    b10 = n10.makeTensorInfo(g10, r10.dtype);
    let k10 = n10.texData.get(b10.dataId);
    k10.values = x10;
  } else
    b10 = kZ(h10, m10, g10, n10);
  return p10 && n10.disposeIntermediateTensorInfo(h10), b10;
}
var IZ = { kernelName: Va, backendName: "webgl", kernelFunc: Q1 };
var SZ = E1 + `
  return max(a, b);
`;
var CZ = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + qp + `
  return result;
`;
var NZ = qt({ opSnippet: SZ, packedOpSnippet: CZ, cpuKernelImpl: BK });
var TZ = { kernelName: Wa, backendName: "webgl", kernelFunc: NZ };
function $Z(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t;
  tu(r10, "maxPool");
  let { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1;
  w2.assert(N2.eitherStridesOrDilationsAreOne(i10, l10), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i10} and dilations '${l10}'`);
  let c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10);
  if (c10.filterWidth === 1 && c10.filterHeight === 1 && w2.arraysEqual(c10.inShape, c10.outShape))
    return En({ inputs: { x: r10 }, backend: n10 });
  let p10 = new el(c10, "max", false);
  return n10.runWebGLProgram(p10, [r10], r10.dtype);
}
var _Z = { kernelName: Ua, backendName: "webgl", kernelFunc: $Z };
function AZ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dataFormat: u10, dimRoundingMode: l10 } = s10, c10 = [1, 1, 1], p10 = N2.computePool3DInfo(r10.shape, a10, i10, c10, o10, l10, u10), d10 = new xv(p10, "max", false);
  return n10.runWebGLProgram(d10, [r10], r10.dtype);
}
var EZ = { kernelName: ep, backendName: "webgl", kernelFunc: AZ };
var RZ = class {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    let t = e.strideHeight, n10 = e.strideWidth, s10 = e.dilationHeight, r10 = e.effectiveFilterHeight, a10 = e.effectiveFilterWidth, i10 = r10 - 1 - e.padInfo.top, o10 = a10 - 1 - e.padInfo.left, u10 = r10 * a10 - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${i10}, ${o10});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r10};
          wR += ${s10}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a10}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n10}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u10} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a10} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var DZ = class {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    let t = e.strideDepth, n10 = e.strideHeight, s10 = e.strideWidth, r10 = e.dilationDepth, a10 = e.dilationHeight, i10 = e.dilationWidth, o10 = e.effectiveFilterDepth, u10 = e.effectiveFilterHeight, l10 = e.effectiveFilterWidth, c10 = o10 - 1 - e.padInfo.front, p10 = u10 - 1 - e.padInfo.top, d10 = l10 - 1 - e.padInfo.left, h10 = o10 * u10 * l10 - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${c10}, ${p10}, ${d10});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o10};
           wD += ${r10}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u10};
              wR += ${a10}) {
            float dyR = float(dyRCorner + wR) / ${n10}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l10};
                wC += ${i10}) {
              float dyC = float(dyCCorner + wC) / ${s10}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h10} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u10} * ${l10} +
                  wR * ${l10} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
function FZ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10 } = t, i10 = a10, { filterSize: o10, strides: u10, pad: l10, dimRoundingMode: c10 } = s10, p10 = [1, 1, 1], d10 = N2.computePool3DInfo(i10.shape, o10, u10, p10, l10, c10), h10 = new xv(d10, "max", true), f10 = n10.runWebGLProgram(h10, [i10], i10.dtype), m10 = new DZ(d10), g10 = n10.runWebGLProgram(m10, [r10, f10], i10.dtype);
  return n10.disposeIntermediateTensorInfo(f10), g10;
}
var OZ = { kernelName: wg, backendName: "webgl", kernelFunc: FZ };
function PZ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, input: a10, output: i10 } = t, o10 = a10;
  tu([a10, i10], "maxPoolGrad");
  let { filterSize: u10, strides: l10, pad: c10, dimRoundingMode: p10 } = s10, d10 = N2.computePool2DInfo(o10.shape, u10, l10, 1, c10, p10), h10 = true, f10 = new el(d10, "max", h10), m10 = n10.runWebGLProgram(f10, [o10], o10.dtype), g10 = new RZ(d10), b10 = n10.runWebGLProgram(g10, [r10, m10], o10.dtype);
  return n10.disposeIntermediateTensorInfo(m10), b10;
}
var zZ = { kernelName: xg, backendName: "webgl", kernelFunc: PZ };
function MZ(e, t, n10, s10) {
  let r10 = new el(n10, "max", false), a10 = s10.runWebGLProgram(r10, [e], "float32");
  r10 = new el(n10, "max", true, true, t);
  let i10 = s10.runWebGLProgram(r10, [e], "float32");
  return [a10, i10];
}
var LZ = { kernelName: kg, backendName: "webgl", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { x: s10 } = e, { filterSize: r10, strides: a10, pad: i10, includeBatchInIndex: o10 } = t, u10 = n10;
  w2.assert(s10.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${s10.shape.length}.`);
  let l10 = [1, 1];
  w2.assert(N2.eitherStridesOrDilationsAreOne(a10, l10), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a10} and dilations '${l10}'`);
  let c10 = N2.computePool2DInfo(s10.shape, r10, a10, l10, i10), [p10, d10] = MZ(s10, o10, c10, u10);
  return [p10, d10];
} };
function BZ(e, t, n10, s10) {
  let r10 = w2.sizeFromShape(t), i10 = w2.sizeFromShape(e.shape) / r10, o10 = he2({ inputs: { x: e }, attrs: { shape: [i10, r10] }, backend: s10 }), u10 = yi(o10, "float32", "mean", s10), l10 = he2({ inputs: { x: u10 }, attrs: { shape: n10 }, backend: s10 });
  return s10.disposeIntermediateTensorInfo(o10), s10.disposeIntermediateTensorInfo(u10), l10;
}
var VZ = { kernelName: Ga, backendName: "webgl", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { x: s10 } = e, { keepDims: r10, axis: a10 } = t, i10 = n10, o10 = s10.shape.length, u10 = w2.parseAxisParam(a10, s10.shape), l10 = u10, c10 = N2.getAxesPermutation(l10, o10), p10 = c10 != null, d10 = i10.shouldExecuteOnCPU([s10]), h10 = [], f10 = s10;
  if (p10) {
    if (d10) {
      let x10 = i10.texData.get(f10.dataId).values, k10 = new Array(o10);
      for (let E10 = 0; E10 < k10.length; E10++)
        k10[E10] = s10.shape[c10[E10]];
      let C10 = yv(x10, s10.shape, s10.dtype, c10, k10);
      f10 = i10.makeTensorInfo(k10, s10.dtype);
      let T10 = i10.texData.get(f10.dataId);
      T10.values = C10;
    } else
      f10 = Kp(s10, c10, i10);
    h10.push(f10), l10 = N2.getInnerMostAxes(l10.length, o10);
  }
  N2.assertAxesAreInnerMostDims("sum", l10, o10);
  let [m10, g10] = N2.computeOutAndReduceShapes(f10.shape, l10), b10 = m10;
  r10 && (b10 = N2.expandShapeToKeepDim(m10, u10));
  let y10 = BZ(f10, g10, b10, i10);
  for (let v10 of h10)
    i10.disposeIntermediateTensorInfo(v10);
  return y10;
} };
function WZ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10, o10 = r10.shape.length, u10 = w2.parseAxisParam(a10, r10.shape), l10 = u10, c10 = N2.getAxesPermutation(l10, o10), p10 = r10;
  c10 != null && (p10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: c10 } }), l10 = N2.getInnerMostAxes(l10.length, r10.shape.length)), N2.assertAxesAreInnerMostDims("min", l10, o10);
  let [d10, h10] = N2.computeOutAndReduceShapes(p10.shape, l10), f10 = w2.sizeFromShape(h10), m10 = he2({ inputs: { x: p10 }, backend: n10, attrs: { shape: [-1, f10] } }), g10 = yi(m10, m10.dtype, "min", n10), b10;
  if (i10) {
    let y10 = N2.expandShapeToKeepDim(d10, u10);
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: y10 } });
  } else
    b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(g10), c10 != null && n10.disposeIntermediateTensorInfo(p10), b10;
}
var UZ = { kernelName: Ha, backendName: "webgl", kernelFunc: WZ };
var GZ = E1 + `
  return min(a, b);
`;
var HZ = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + qp + `
  return result;
`;
var qZ = qt({ opSnippet: GZ, packedOpSnippet: HZ, cpuKernelImpl: VK });
var jZ = { kernelName: qa, backendName: "webgl", kernelFunc: qZ };
var KZ = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.outputShape = t.map((l10, c10) => l10[0] + e[c10] + l10[1]);
    let s10 = e.length, r10 = ot(s10), a10 = t.map((l10) => l10[0]).join(","), i10 = t.map((l10, c10) => l10[0] + e[c10]).join(","), o10 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s10), u10 = n10 === "reflect" ? 0 : 1;
    if (s10 === 1) {
      this.userCode = `
        int start = ${a10};
        int end = ${i10};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u10};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u10};
          }
          setOutput(getX(outC - start));
        }
      `;
      return;
    }
    this.userCode = `
      ${r10} start = ${r10}(${a10});
      ${r10} end = ${r10}(${i10});

      void main() {
        ${r10} outC = getOutputCoords();
        for (int i = 0; i < ${s10}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u10};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u10};
          }
        }
        ${r10} coords = outC - start;
        setOutput(getX(${o10}));
      }
    `;
  }
};
var XZ = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t.map((h10, f10) => h10[0] + e[f10] + h10[1]);
    let s10 = e.length, r10 = ot(s10), a10 = t.map((h10) => h10[0]).join(","), i10 = t.map((h10, f10) => h10[0] + e[f10]).join(","), o10 = un("rc", s10), u10 = un("source", s10), l10 = `${o10[s10 - 1]} < ${this.outputShape[s10 - 1]}`, c10 = s10 === 1 ? "source" : `vec2(${u10.slice(-2).join()})`, p10 = n10 === "reflect" ? 0 : 1, d10 = "";
    if (s10 === 1) {
      let h10 = `
        ${r10} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p10};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p10};
        }
        source -= start;
      `;
      d10 = `
        ${r10} rc = outputLoc;
        ${h10}
        result[0] = getChannel(getX(${u10.join()}), ${c10});
        ${o10[s10 - 1]} += 1;
        if(${l10}) {
          ${h10}
          result[1] = getChannel(getX(${u10.join()}), ${c10});
        }
      `;
    } else {
      let h10 = `
        ${r10} source = rc;
        ${r10} lt = ${r10}(lessThan(source, start));
        ${r10} gte = ${r10}(greaterThanEqual(source, end));
        ${r10} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p10}) +
                gte * ((end - 1) * 2 - source + ${p10});
        source -= start;
      `;
      d10 = `
        ${r10} rc = outputLoc;
        ${h10}
        result[0] = getChannel(getX(${u10.join()}), ${c10});
        ${o10[s10 - 1]} += 1;
        if(${l10}) {
          ${h10}
          result[1] = getChannel(getX(${u10.join()}), ${c10});
        }
        rc = outputLoc;
        ${o10[s10 - 2]} += 1;
        if(${o10[s10 - 2]} < ${this.outputShape[s10 - 2]}) {
          ${h10}
          result[2] = getChannel(getX(${u10.join()}), ${c10});
          ${o10[s10 - 1]} += 1;
          if(${l10}) {
            ${h10}
            result[3] = getChannel(getX(${u10.join()}), ${c10});
          }
        }
      `;
    }
    this.userCode = `
      const ${r10} start = ${r10}(${a10});
      const ${r10} end = ${r10}(${i10});

      void main() {
        ${r10} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d10}
        setOutput(result);
      }
    `;
  }
};
var YZ = ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10 } = e, { paddings: r10, mode: a10 } = n10, i10 = X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new XZ(s10.shape, r10, a10) : new KZ(s10.shape, r10, a10);
  return t.runWebGLProgram(i10, [s10], s10.dtype);
};
var QZ = { kernelName: ja, backendName: "webgl", kernelFunc: YZ };
var ZZ = `if (b == 0.0) return NAN;
  return mod(a, b);`;
var JZ = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` + qp + `
  return result;
`;
var e7 = qt({ opSnippet: ZZ, packedOpSnippet: JZ });
var t7 = { kernelName: vl, backendName: "webgl", kernelFunc: e7 };
var n7 = class {
  constructor(e, t, n10) {
    this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [e, n10], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t - 1}));
      }
    `;
  }
};
var s7 = `
if (a == b) {
  return 1.0;
};
return a / b;`;
var r7 = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
var Z1 = qt({ opSnippet: s7, packedOpSnippet: r7, checkOutOfBounds: true });
var a7 = { kernelName: Ea, backendName: "webgl", kernelFunc: Z1 };
var xw = "return a - b;";
var J1 = qt({ opSnippet: xw, packedOpSnippet: xw, supportsComplex: true, cpuKernelImpl: sX });
var i7 = { kernelName: ui, backendName: "webgl", kernelFunc: J1 };
function e2(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { logits: r10 } = t, { dim: a10 } = s10, i10 = w2.parseAxisParam([a10], r10.shape), o10 = Q1({ inputs: { x: r10 }, backend: n10, attrs: { reductionIndices: i10, keepDims: false } }), u10 = N2.expandShapeToKeepDim(o10.shape, i10), l10 = he2({ inputs: { x: o10 }, backend: n10, attrs: { shape: u10 } }), c10 = J1({ inputs: { a: r10, b: l10 }, backend: n10 }), p10 = K1({ inputs: { x: c10 }, backend: n10 }), d10 = Xp({ inputs: { x: p10 }, backend: n10, attrs: { axis: i10, keepDims: false } }), h10 = he2({ inputs: { x: d10 }, backend: n10, attrs: { shape: u10 } }), f10 = Z1({ inputs: { a: p10, b: h10 }, backend: n10 });
  return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(c10), n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(h10), f10;
}
var o7 = { kernelName: ii, backendName: "webgl", kernelFunc: e2 };
function u7(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { logits: r10 } = t, { numSamples: a10, seed: i10, normalized: o10 } = s10, u10 = o10 ? r10 : e2({ inputs: { logits: r10 }, backend: n10, attrs: { dim: r10.shape.length - 1 } }), l10 = u10.shape[0], c10 = u10.shape[1], p10 = new n7(l10, c10, a10), d10 = [[i10]], h10 = n10.runWebGLProgram(p10, [u10], "int32", d10);
  return o10 || n10.disposeIntermediateTensorInfo(u10), h10;
}
var l7 = { kernelName: Ig, backendName: "webgl", kernelFunc: u7 };
var c7 = ts + `
  return -x;
`;
var d7 = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
function p7(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (n10.shouldExecuteOnCPU([s10])) {
    let a10 = n10.texData.get(s10.dataId), [i10, o10] = UK(a10.values, s10.shape, s10.dtype);
    return n10.makeTensorInfo(o10, s10.dtype, i10);
  }
  let r10;
  return X2().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? r10 = new Yr(s10.shape, d7) : r10 = new Hs(s10.shape, c7), n10.runWebGLProgram(r10, [s10], s10.dtype);
}
var h7 = { kernelName: ko, backendName: "webgl", kernelFunc: p7 };
var f7 = xs.nonMaxSuppressionV3Impl;
function m7(e) {
  N2.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10 } = s10, l10 = n10.readSync(r10.dataId), c10 = n10.readSync(a10.dataId), { selectedIndices: p10 } = f7(l10, c10, i10, o10, u10);
  return n10.makeTensorInfo([p10.length], "int32", new Int32Array(p10));
}
var g7 = { kernelName: So, backendName: "webgl", kernelFunc: m7 };
var b7 = xs.nonMaxSuppressionV4Impl;
function y7(e) {
  N2.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10, padToMaxOutputSize: l10 } = s10, c10 = n10.readSync(r10.dataId), p10 = n10.readSync(a10.dataId), { selectedIndices: d10, validOutputs: h10 } = b7(c10, p10, i10, o10, u10, l10);
  return [n10.makeTensorInfo([d10.length], "int32", new Int32Array(d10)), n10.makeTensorInfo([], "int32", new Int32Array([h10]))];
}
var v7 = { kernelName: xl, backendName: "webgl", kernelFunc: y7 };
var x7 = xs.nonMaxSuppressionV5Impl;
function w7(e) {
  N2.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10, softNmsSigma: l10 } = s10, c10 = n10.readSync(r10.dataId), p10 = n10.readSync(a10.dataId), d10 = i10, h10 = o10, f10 = u10, m10 = l10, { selectedIndices: g10, selectedScores: b10 } = x7(c10, p10, d10, h10, f10, m10);
  return [n10.makeTensorInfo([g10.length], "int32", new Int32Array(g10)), n10.makeTensorInfo([b10.length], "float32", new Float32Array(b10))];
}
var k7 = { kernelName: Co, backendName: "webgl", kernelFunc: w7 };
var I7 = class {
  constructor(e, t, n10, s10) {
    this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s10}), float(${n10}),
                      float(index == coords.y)));
      }
    `;
  }
};
var S7 = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10 } = t, { depth: a10, onValue: i10, offValue: o10 } = s10, u10 = w2.sizeFromShape(r10.shape), l10 = new I7(u10, a10, i10, o10), c10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [u10] } }), p10 = n10.runWebGLProgram(l10, [c10], r10.dtype);
  n10.disposeIntermediateTensorInfo(c10);
  let d10 = [...r10.shape, a10], h10 = he2({ inputs: { x: p10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeIntermediateTensorInfo(p10), h10;
};
var C7 = { kernelName: To, backendName: "webgl", kernelFunc: S7 };
function zd(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "complex64") {
    let r10 = Zl({ inputs: { input: s10 }, backend: n10 }), a10 = zd({ inputs: { x: r10 }, backend: n10 }), i10 = Yp({ inputs: { input: s10 }, backend: n10 }), o10 = zd({ inputs: { x: i10 }, backend: n10 }), u10 = Er({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(r10), n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), u10;
  } else
    return Jl({ attrs: { shape: s10.shape, dtype: s10.dtype, value: s10.dtype === "string" ? "" : 0 }, backend: n10 });
}
var N7 = { kernelName: Go, backendName: "webgl", kernelFunc: zd };
function t2(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "string")
    throw new Error("onesLike is not supported under string dtype");
  if (s10.dtype === "complex64") {
    let r10 = Zl({ inputs: { input: s10 }, backend: n10 }), a10 = t2({ inputs: { x: r10 }, backend: n10 }), i10 = Yp({ inputs: { input: s10 }, backend: n10 }), o10 = zd({ inputs: { x: i10 }, backend: n10 }), u10 = Er({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeIntermediateTensorInfo(r10), n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), u10;
  } else
    return Jl({ attrs: { shape: s10.shape, dtype: s10.dtype, value: 1 }, backend: n10 });
}
var T7 = { kernelName: No, backendName: "webgl", kernelFunc: t2 };
function $7(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10;
  if (t.length === 1)
    return Gm({ inputs: { input: t[0] }, backend: n10, attrs: { dim: r10 } });
  let a10 = t[0].shape, i10 = t[0].dtype;
  t.forEach((c10) => {
    w2.assertShapesMatch(a10, c10.shape, "All tensors passed to stack must have matching shapes"), w2.assert(i10 === c10.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o10 = [], u10 = t.map((c10) => {
    let p10 = Gm({ inputs: { input: c10 }, backend: n10, attrs: { dim: r10 } });
    return o10.push(p10), p10;
  }), l10 = W1({ inputs: u10, backend: n10, attrs: { axis: r10 } });
  return o10.forEach((c10) => n10.disposeIntermediateTensorInfo(c10)), l10;
}
var _7 = { kernelName: $o, backendName: "webgl", kernelFunc: $7 };
var A7 = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t.map((u10, l10) => u10[0] + e[l10] + u10[1]);
    let s10 = e.length, r10 = ot(s10), a10 = t.map((u10) => u10[0]).join(","), i10 = t.map((u10, l10) => u10[0] + e[l10]).join(","), o10 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s10);
    if (s10 === 1) {
      this.userCode = `
        int start = ${a10};
        int end = ${i10};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
      return;
    }
    this.userCode = `
      ${r10} start = ${r10}(${a10});
      ${r10} end = ${r10}(${i10});

      void main() {
        ${r10} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r10} coords = outC - start;
          setOutput(getX(${o10}));
        }
      }
    `;
  }
};
var E7 = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t.map((f10, m10) => f10[0] + e[m10] + f10[1]);
    let s10 = e.length, r10 = ot(s10), a10 = t.map((f10) => f10[0]).join(","), i10 = t.map((f10, m10) => f10[0] + e[m10]).join(","), o10 = un("rc", s10), u10 = un("source", s10), l10 = `${o10[s10 - 1]} < ${this.outputShape[s10 - 1]}`, c10 = s10 === 1 ? "source" : `vec2(${u10.slice(-2).join()})`, p10 = [`${r10} rc = outputLoc;`, `${o10[s10 - 1]} += 1;
       if(${l10}) {
      `, s10 === 1 ? "" : `}
       rc = outputLoc;
       ${o10[s10 - 2]} += 1;
       if(${o10[s10 - 2]} < ${this.outputShape[s10 - 2]}) {`, s10 === 1 ? "" : `  ${o10[s10 - 1]} += 1;
         if(${l10}) {`], d10 = s10 === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", h10 = "";
    for (let f10 = 0, m10 = s10 === 1 ? 2 : 4; f10 < m10; f10++)
      h10 += `
        ${p10[f10]}
        if (${d10}) {
          result[${f10}] = float(value);
        } else {
          ${r10} source = rc - start;
          result[${f10}] = getChannel(getX(${u10.join()}), ${c10});
        }
      `;
    h10 += s10 === 1 ? "} " : "}}", this.userCode = `
      const ${r10} start = ${r10}(${a10});
      const ${r10} end = ${r10}(${i10});

      void main() {
        ${r10} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h10}
        setOutput(result);
      }
    `;
  }
};
var n2 = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { paddings: a10, constantValue: i10 } = s10;
  if (w2.sizeFromShape(r10.shape) === 0) {
    let l10 = a10.map((c10, p10) => c10[0] + r10.shape[p10] + c10[1]);
    return Jl({ backend: n10, attrs: { shape: l10, value: i10, dtype: r10.dtype } });
  }
  let o10 = X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new E7(r10.shape, a10, i10) : new A7(r10.shape, a10, i10), u10 = [[i10]];
  return n10.runWebGLProgram(o10, [r10], r10.dtype, u10);
};
var R7 = { kernelName: Xa, backendName: "webgl", kernelFunc: n2 };
var D7 = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
var F7 = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` + qp + `
  return result;
`;
var O7 = qt({ opSnippet: D7, packedOpSnippet: F7 });
var P7 = { kernelName: Ya, backendName: "webgl", kernelFunc: O7 };
function z7(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10, o10 = r10.shape.length, u10 = [], l10 = w2.parseAxisParam(a10, r10.shape), c10 = l10, p10 = N2.getAxesPermutation(c10, o10), d10 = r10;
  p10 != null && (d10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: p10 } }), c10 = N2.getInnerMostAxes(c10.length, o10), u10.push(d10)), N2.assertAxesAreInnerMostDims("prod", c10, o10);
  let h10;
  if (n10.shouldExecuteOnCPU([d10])) {
    let f10 = n10.texData.get(d10.dataId).values, { outVals: m10, outShape: g10, outDtype: b10 } = HK(d10.shape, d10.dtype, f10, c10);
    h10 = n10.makeTensorInfo(g10, b10, m10);
  } else {
    let [f10, m10] = N2.computeOutAndReduceShapes(d10.shape, c10), g10 = w2.sizeFromShape(m10), b10 = he2({ inputs: { x: d10 }, backend: n10, attrs: { shape: [-1, g10] } }), y10 = lp(r10.dtype), v10 = yi(b10, y10, "prod", n10);
    h10 = he2({ inputs: { x: v10 }, backend: n10, attrs: { shape: f10 } }), u10.push(b10), u10.push(v10);
  }
  if (i10) {
    u10.push(h10);
    let f10 = N2.expandShapeToKeepDim(h10.shape, l10);
    h10 = he2({ inputs: { x: h10 }, backend: n10, attrs: { shape: f10 } });
  }
  return u10.forEach((f10) => n10.disposeIntermediateTensorInfo(f10)), h10;
}
var M7 = { kernelName: _o, backendName: "webgl", kernelFunc: z7 };
var s2 = (e) => {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, step: a10, dtype: i10 } = n10, o10 = qK(s10, r10, a10, i10);
  return t.makeTensorInfo([o10.length], i10, o10);
};
var L7 = { kernelName: wl, backendName: "webgl", kernelFunc: s2 };
var B7 = "return 1.0 / x;";
var V7 = Ke({ opSnippet: B7 });
var W7 = { kernelName: kl, backendName: "webgl", kernelFunc: V7 };
var U7 = ts + `
  return (x < 0.0) ? 0.0 : x;
`;
var G7 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var H7 = Ke({ opSnippet: U7, packedOpSnippet: G7 });
var q7 = { kernelName: Za, backendName: "webgl", kernelFunc: H7 };
var j7 = ts + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
var K7 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var X7 = Ke({ opSnippet: j7, packedOpSnippet: K7 });
var Y7 = { kernelName: ei, backendName: "webgl", kernelFunc: X7 };
var Q7 = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["A"], this.outputShape = [];
    let [a10, i10, o10, u10] = e;
    this.outputShape = [a10, t, n10, u10];
    let l10 = [s10 && t > 1 ? i10 - 1 : i10, s10 && n10 > 1 ? o10 - 1 : o10], c10 = [s10 && t > 1 ? t - 1 : t, s10 && n10 > 1 ? n10 - 1 : n10], p10;
    r10 ? p10 = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : p10 = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l10[0] / c10[0]},
          ${l10[1] / c10[1]});
      const vec2 inputShapeRC = vec2(${i10}.0, ${o10}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p10};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
};
var Z7 = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    let [a10, i10, o10, u10] = e;
    this.outputShape = [a10, t, n10, u10];
    let l10 = [s10 && t > 1 ? i10 - 1 : i10, s10 && n10 > 1 ? o10 - 1 : o10], c10 = [s10 && t > 1 ? t - 1 : t, s10 && n10 > 1 ? n10 - 1 : n10], p10;
    r10 ? p10 = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : p10 = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l10[0] / c10[0]},
          ${l10[1] / c10[1]},
          ${l10[1] / c10[1]});
      const vec3 inputShapeRC = vec3(${i10}.0, ${o10}.0,
                                     ${o10}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p10};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u10 - 1};
        bool hasNextRow = coords.z < ${n10 - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
};
function J7(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10, [u10, l10] = o10, c10 = X2().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Z7(r10.shape, u10, l10, a10, i10) : new Q7(r10.shape, u10, l10, a10, i10);
  return n10.runWebGLProgram(c10, [r10], "float32");
}
var eJ = { kernelName: Ja, backendName: "webgl", kernelFunc: J7 };
var tJ = class {
  constructor(e, t, n10) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    let [, s10, r10] = t, [, a10, i10] = e, o10 = [n10 && a10 > 1 ? s10 - 1 : s10, n10 && i10 > 1 ? r10 - 1 : r10], u10 = [n10 && a10 > 1 ? a10 - 1 : a10, n10 && i10 > 1 ? i10 - 1 : i10], l10 = o10[0] / u10[0], c10 = o10[1] / u10[1], p10 = 1 / l10, d10 = 1 / c10, h10 = Math.ceil(p10) * 2 + 2, f10 = Math.ceil(d10) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l10});
        const float widthScale = float(${c10});

        const float invHeightScale = float(${p10});
        const float invWidthScale = float(${d10});

        const int winHeight = int(${h10});
        const int winWidth = int(${f10});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a10}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i10}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s10 - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r10 - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
function nJ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10, dy: a10 } = t, { alignCorners: i10 } = s10, o10 = new tJ(a10.shape, r10.shape, i10);
  return n10.runWebGLProgram(o10, [a10], a10.dtype);
}
var sJ = { kernelName: Cg, backendName: "webgl", kernelFunc: nJ };
var rJ = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["A"], this.outputShape = [];
    let [a10, i10, o10, u10] = e;
    this.outputShape = [a10, t, n10, u10];
    let l10 = [s10 && t > 1 ? i10 - 1 : i10, s10 && n10 > 1 ? o10 - 1 : o10], c10 = [s10 && t > 1 ? t - 1 : t, s10 && n10 > 1 ? n10 - 1 : n10], p10 = s10 ? "0.5" : "0.0", d10;
    r10 ? d10 = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : d10 = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l10[0] / c10[0]},
          ${l10[1] / c10[1]});
      const vec2 inputShapeRC = vec2(${i10}.0, ${o10}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d10};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p10})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
};
var aJ = class {
  constructor(e, t, n10, s10, r10) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    let [a10, i10, o10, u10] = e;
    this.outputShape = [a10, t, n10, u10];
    let l10 = [s10 && t > 1 ? i10 - 1 : i10, s10 && n10 > 1 ? o10 - 1 : o10], c10 = [s10 && t > 1 ? t - 1 : t, s10 && n10 > 1 ? n10 - 1 : n10], p10 = s10 ? "0.5" : "0.0", d10;
    r10 ? d10 = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : d10 = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l10[0] / c10[0]},
          ${l10[1] / c10[1]},
          ${l10[1] / c10[1]});
      const vec3 inputShapeRC = vec3(${i10}.0, ${o10}.0,
                                     ${o10}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d10};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p10})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u10 - 1};
        bool hasNextRow = coords.z < ${n10 - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
};
function iJ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10, [u10, l10] = o10, c10 = X2().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new aJ(r10.shape, u10, l10, a10, i10) : new rJ(r10.shape, u10, l10, a10, i10);
  return n10.runWebGLProgram(c10, [r10], r10.dtype);
}
var oJ = { kernelName: Il, backendName: "webgl", kernelFunc: iJ };
var uJ = class {
  constructor(e, t, n10) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    let [, s10, r10] = t, [, a10, i10] = e, o10 = [n10 && a10 > 1 ? s10 - 1 : s10, n10 && i10 > 1 ? r10 - 1 : r10], u10 = [n10 && a10 > 1 ? a10 - 1 : a10, n10 && i10 > 1 ? i10 - 1 : i10], l10 = o10[0] / u10[0], c10 = o10[1] / u10[1], p10 = 1 / l10, d10 = 1 / c10, h10 = Math.ceil(p10) * 2 + 2, f10 = Math.ceil(d10) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l10});
        const float widthScale = float(${c10});

        const float invHeightScale = float(${p10});
        const float invWidthScale = float(${d10});

        const int winHeight = int(${h10});
        const int winWidth = int(${f10});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a10}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i10}) {
              continue;
            }

            float sourceFracRow =
              float(${o10[0]}) *
                (float(dyR) / float(${u10[0]}));

            float sourceFracCol =
                float(${o10[1]}) *
                  (float(dyC) / float(${u10[1]}));

            int sourceNearestRow = int(min(
                float(int(${s10}) - 1),
                ${n10} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r10}) - 1),
                ${n10} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
function lJ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10, dy: a10 } = t, { alignCorners: i10 } = s10, o10 = new uJ(a10.shape, r10.shape, i10);
  return n10.runWebGLProgram(o10, [a10], a10.dtype);
}
var cJ = { kernelName: Sg, backendName: "webgl", kernelFunc: lJ };
var dJ = class {
  constructor(e, t) {
    this.variableNames = ["x"];
    let n10 = e.length;
    if (n10 > 4)
      throw new Error(`WebGL backend: Reverse of rank-${n10} tensor is not yet supported`);
    if (this.outputShape = e, n10 === 1) {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;
      return;
    }
    let s10 = (i10) => t.indexOf(i10) !== -1 && e[i10] !== 1 ? `${e[i10]} - coords[${i10}] - 1` : `coords[${i10}]`, r10 = e.map((i10, o10) => s10(o10)).join(","), a10 = ot(n10);
    this.userCode = `
      void main() {
        ${a10} coords = getOutputCoords();
        setOutput(getX(${r10}));
      }
    `;
  }
};
var pJ = class {
  constructor(e, t) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
    let n10 = e.length;
    if (n10 > 4)
      throw new Error(`WebGL backend: Reverse of rank-${n10} tensor is not yet supported`);
    this.outputShape = e;
    let s10 = un("rc", n10), r10 = `${s10[n10 - 1]} + 1 < ${this.outputShape[n10 - 1]}`, a10 = `${s10[n10 - 2]} + 1 < ${this.outputShape[n10 - 2]}`, i10 = ot(n10);
    n10 === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r10}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${i10} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o10(s10.slice())};
          if(${r10}){
            result.g = ${u10(s10.slice())};
          }
          if(${a10}) {
            result.b = ${l10(s10.slice())};
            if(${r10}) {
              result.a = ${c10(s10.slice())};
            }
          }
          setOutput(result);
        }
    `;
    function o10(h10) {
      return p10(h10);
    }
    function u10(h10) {
      return h10[n10 - 1] = "(" + h10[n10 - 1] + " + 1)", p10(h10);
    }
    function l10(h10) {
      return h10[n10 - 2] = "(" + h10[n10 - 2] + " + 1)", p10(h10);
    }
    function c10(h10) {
      return h10[n10 - 1] = "(" + h10[n10 - 1] + " + 1)", h10[n10 - 2] = "(" + h10[n10 - 2] + " + 1)", p10(h10);
    }
    function p10(h10) {
      let f10 = e.map((b10, y10) => d10(y10, h10)), m10 = f10.join(","), g10 = f10.slice(-2).join(",");
      return `getChannel(getX(${m10}), vec2(${g10}))`;
    }
    function d10(h10, f10) {
      return t.indexOf(h10) !== -1 && e[h10] !== 1 ? `${e[h10]} - ${f10[h10]} - 1` : `${f10[h10]}`;
    }
  }
};
function hJ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dims: a10 } = s10, i10 = r10.shape.length, o10 = w2.parseAxisParam(a10, r10.shape);
  if (i10 === 0)
    return En({ inputs: { x: r10 }, backend: n10 });
  let u10 = X2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new pJ(r10.shape, o10) : new dJ(r10.shape, o10);
  return n10.runWebGLProgram(u10, [r10], r10.dtype);
}
var fJ = { kernelName: Eo, backendName: "webgl", kernelFunc: hJ };
var mJ = class {
  constructor(e, t) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
    let n10 = e[1], s10 = e[2];
    this.outputShape = e;
    let r10 = "";
    typeof t == "number" ? r10 = `float outputValue = ${t.toFixed(2)};` : r10 = `
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r10}
          if(coordX >= 0 && coordX < ${s10} && coordY >= 0 && coordY < ${n10}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var gJ = { kernelName: Ho, backendName: "webgl", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { image: s10 } = e, { radians: r10, fillValue: a10, center: i10 } = t, o10 = n10, u10 = new mJ(s10.shape, a10), [l10, c10] = N2.getImageCenter(i10, s10.shape[1], s10.shape[2]), p10 = [[l10, c10, Math.sin(r10), Math.cos(r10)]];
  return o10.runWebGLProgram(u10, [s10], s10.dtype, p10);
} };
var bJ = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
var yJ = Ke({ opSnippet: bJ });
var vJ = { kernelName: Ro, backendName: "webgl", kernelFunc: yJ };
var xJ = "return inversesqrt(x);";
var wJ = Ke({ opSnippet: xJ, cpuKernelImpl: jK });
var kJ = { kernelName: ti, backendName: "webgl", kernelFunc: wJ };
var r2 = class {
  constructor(e, t, n10, s10, r10, a10, i10 = true) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a10;
    let o10 = ot(r10.length), u10 = ot(a10.length), l10 = "";
    n10 === 1 ? l10 = "i" : n10 === 2 && (l10 = "i, j");
    let c10 = `getIndices(${l10})`, p10 = "";
    s10 === 1 ? p10 = "i" : s10 === 2 && (p10 = "i, coords[1]");
    let d10 = `getUpdates(${p10})`, h10 = t > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${o10} strides = ${o10}(${r10});

        void main() {
          ${u10} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c10});
              flattenedIndex += index * ${h10};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d10};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
  }
};
function IJ(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10, updates: a10 } = t, { shape: i10 } = s10, { sliceRank: o10, numUpdates: u10, sliceSize: l10, strides: c10, outputSize: p10 } = N2.calculateShapes(a10, r10, i10), d10 = [p10 / l10, l10];
  if (p10 === 0)
    return n10.makeTensorInfo(i10, r10.dtype);
  let h10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [u10, o10] } }), f10 = he2({ inputs: { x: a10 }, backend: n10, attrs: { shape: [u10, l10] } }), m10 = n10.makeTensorInfo([], "float32", new Float32Array([0])), g10 = new r2(u10, o10, h10.shape.length, f10.shape.length, c10, d10), b10 = n10.runWebGLProgram(g10, [f10, h10, m10], f10.dtype), y10 = he2({ inputs: { x: b10 }, backend: n10, attrs: { shape: i10 } });
  return n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(b10), n10.disposeIntermediateTensorInfo(m10), y10;
}
var SJ = { kernelName: Do, backendName: "webgl", kernelFunc: IJ };
var CJ = class {
  constructor(e, t, n10) {
    this.variableNames = ["c", "a", "b"], this.outputShape = t;
    let s10, r10;
    if (n10 > 4)
      throw Error(`Where for rank ${n10} is not yet supported`);
    if (n10 === 1)
      r10 = "resRC", s10 = "resRC";
    else {
      let i10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o10 = [], u10 = [];
      for (let l10 = 0; l10 < t.length; l10++)
        u10.push(`${i10[l10]}`), l10 < e && o10.push(`${i10[l10]}`);
      s10 = o10.join(), r10 = u10.join();
    }
    let a10 = ot(n10);
    this.userCode = `
      void main() {
        ${a10} resRC = getOutputCoords();
        float cVal = getC(${s10});
        if (cVal >= 1.0) {
          setOutput(getA(${r10}));
        } else {
          setOutput(getB(${r10}));
        }
      }
    `;
  }
};
function NJ(e) {
  let { inputs: t, backend: n10 } = e, { condition: s10, t: r10, e: a10 } = t, i10 = new CJ(s10.shape.length, r10.shape, r10.shape.length);
  return n10.runWebGLProgram(i10, [s10, r10, a10], yn(r10.dtype, a10.dtype));
}
var TJ = { kernelName: Fo, backendName: "webgl", kernelFunc: NJ };
var $J = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N2.SELU_SCALEALPHA};
  float scale = ${N2.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
var _J = Ke({ opSnippet: $J });
var AJ = { kernelName: Sl, backendName: "webgl", kernelFunc: _J };
var EJ = iu + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
var RJ = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
var DJ = Ke({ opSnippet: EJ, packedOpSnippet: RJ, cpuKernelImpl: KK });
var FJ = { kernelName: si, backendName: "webgl", kernelFunc: DJ };
var OJ = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
var PJ = Ke({ opSnippet: OJ });
var zJ = { kernelName: Cl, backendName: "webgl", kernelFunc: PJ };
var MJ = iu + `
  return sin(x);
`;
var LJ = Ke({ opSnippet: MJ });
var BJ = { kernelName: ni, backendName: "webgl", kernelFunc: LJ };
var VJ = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
var WJ = Ke({ opSnippet: VJ });
var UJ = { kernelName: Po, backendName: "webgl", kernelFunc: WJ };
var GJ = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
var HJ = Ke({ opSnippet: GJ });
var qJ = { kernelName: Nl, backendName: "webgl", kernelFunc: HJ };
var jJ = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, paddings: i10 } = s10;
  w2.assert(r10.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
  let o10 = a10.reduce((b10, y10) => b10 * y10), u10 = [[0, 0]];
  u10.push(...i10);
  for (let b10 = 1 + a10.length; b10 < r10.shape.length; ++b10)
    u10.push([0, 0]);
  let l10 = [], c10 = n2({ inputs: { x: r10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), p10 = N2.getReshaped(c10.shape, a10, o10, false), d10 = N2.getPermuted(p10.length, a10.length, false), h10 = N2.getReshapedPermuted(c10.shape, a10, o10, false), f10 = he2({ inputs: { x: c10 }, backend: n10, attrs: { shape: p10 } }), m10 = cn({ inputs: { x: f10 }, backend: n10, attrs: { perm: d10 } }), g10 = he2({ inputs: { x: m10 }, backend: n10, attrs: { shape: h10 } });
  return l10.push(c10), l10.push(f10), l10.push(m10), l10.forEach((b10) => n10.disposeIntermediateTensorInfo(b10)), g10;
};
var KJ = { kernelName: zo, backendName: "webgl", kernelFunc: jJ };
function XJ(e) {
  let { inputs: t, backend: n10 } = e, { indices: s10, values: r10, denseShape: a10, defaultValue: i10 } = t;
  if (a10.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
         ${a10.shape}`);
  if (s10.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
         ${s10.shape}`);
  if (r10.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
         ${r10.shape}`);
  if (i10.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${i10.shape}`);
  let o10 = n10.readSync(s10.dataId), u10 = n10.readSync(r10.dataId), l10 = n10.readSync(a10.dataId), c10 = n10.readSync(i10.dataId)[0], [p10, d10, h10, f10, m10] = YK(o10, s10.shape, s10.dtype, u10, r10.dtype, l10, c10);
  return [n10.makeTensorInfo(d10, s10.dtype, p10), n10.makeTensorInfo([d10[0]], r10.dtype, h10), n10.makeTensorInfo([f10.length], "bool", new Uint8Array(f10.map((g10) => Number(g10)))), n10.makeTensorInfo([m10.length], s10.dtype, new Int32Array(m10))];
}
var YJ = { kernelName: np, backendName: "webgl", kernelFunc: XJ };
function QJ(e) {
  let { inputs: t, backend: n10 } = e, { inputIndices: s10, inputShape: r10, newShape: a10 } = t;
  if (s10.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape ${s10.shape}`);
  if (r10.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${a10.shape}`);
  let i10 = Array.from(n10.readSync(r10.dataId)), o10 = n10.readSync(s10.dataId), u10 = Array.from(n10.readSync(a10.dataId)), [l10, c10, p10] = QK(o10, s10.shape, s10.dtype, i10, u10);
  return [n10.makeTensorInfo(c10, s10.dtype, l10), n10.makeTensorInfo([p10.length], a10.dtype, new Int32Array(p10))];
}
var ZJ = { kernelName: Tl, backendName: "webgl", kernelFunc: QJ };
function JJ(e) {
  let { inputs: t, backend: n10 } = e, { data: s10, indices: r10, segmentIds: a10 } = t;
  if (s10.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
              ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
              ${a10.shape}`);
  let i10 = n10.readSync(s10.dataId), o10 = n10.readSync(r10.dataId), u10 = n10.readSync(a10.dataId), [l10, c10] = N1(i10, s10.shape, s10.dtype, o10, u10, true);
  return n10.makeTensorInfo(c10, s10.dtype, l10);
}
var eee = { kernelName: sp, backendName: "webgl", kernelFunc: JJ };
function tee(e) {
  let { inputs: t, backend: n10 } = e, { data: s10, indices: r10, segmentIds: a10 } = t;
  if (s10.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (r10.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
             ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
             ${a10.shape}`);
  let i10 = n10.readSync(s10.dataId), o10 = n10.readSync(r10.dataId), u10 = n10.readSync(a10.dataId), [l10, c10] = N1(i10, s10.shape, s10.dtype, o10, u10);
  return n10.makeTensorInfo(c10, s10.dtype, l10);
}
var nee = { kernelName: rp, backendName: "webgl", kernelFunc: tee };
function see(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { sparseIndices: r10, sparseValues: a10, defaultValue: i10 } = t, { outputShape: o10 } = s10, { sliceRank: u10, numUpdates: l10, strides: c10, outputSize: p10 } = N2.calculateShapes(a10, r10, o10), d10 = false, h10 = new r2(l10, u10, r10.shape.length, a10.shape.length, c10, [p10, 1], d10), f10 = n10.runWebGLProgram(h10, [a10, r10, i10], a10.dtype), m10 = he2({ inputs: { x: f10 }, backend: n10, attrs: { shape: o10 } });
  return n10.disposeIntermediateTensorInfo(f10), m10;
}
var ree = { kernelName: ap, backendName: "webgl", kernelFunc: see };
function aee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { numOrSizeSplits: a10, axis: i10 } = s10, o10 = w2.parseAxisParam(i10, r10.shape)[0], u10 = N2.prepareSplitSize(r10, a10, o10), l10 = r10.shape.length, c10 = new Array(l10).fill(0), p10 = r10.shape.slice();
  return u10.map((d10) => {
    let h10 = [...p10];
    h10[o10] = d10;
    let f10 = ou({ inputs: { x: r10 }, backend: n10, attrs: { begin: c10, size: h10 } });
    return c10[o10] += d10, f10;
  });
}
var iee = { kernelName: Mo, backendName: "webgl", kernelFunc: aee };
var ww = "return sqrt(x);";
var oee = Ke({ opSnippet: ww, packedOpSnippet: ww, cpuKernelImpl: ZK });
var uee = { kernelName: ri, backendName: "webgl", kernelFunc: oee };
var lee = "return x * x;";
var cee = Ke({ opSnippet: lee });
var dee = { kernelName: $l, backendName: "webgl", kernelFunc: cee };
var kw = "return (a - b) * (a - b);";
var pee = qt({ opSnippet: kw, packedOpSnippet: kw });
var hee = { kernelName: oi, backendName: "webgl", kernelFunc: pee };
function fee({ inputs: e, attrs: t, backend: n10 }) {
  let { x: s10 } = e, r10 = ts + `
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `, a10 = new Hs(s10.shape, r10);
  return n10.runWebGLProgram(a10, [s10], s10.dtype);
}
var mee = { kernelName: di, backendName: "webgl", kernelFunc: fee };
var gee = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.outputShape = n10;
    let s10 = n10.length, r10 = ot(n10.length), a10 = ot(n10.length), i10 = "";
    if (s10 === 1)
      i10 = "coords * strides + begin";
    else {
      let o10 = 0;
      i10 = n10.map((u10, l10) => (o10++, n10.length === 1 ? `coords * strides[${l10}] + begin[${l10}]` : `coords[${o10 - 1}] * strides[${l10}] + begin[${l10}]`)).join(",");
    }
    this.userCode = `
      ${r10} begin = ${r10}(${e});
      ${r10} strides = ${r10}(${t});

      void main() {
        ${a10} coords = getOutputCoords();
        setOutput(getX(${i10}));
      }
    `;
  }
};
function bee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, end: i10, strides: o10, beginMask: u10, endMask: l10, ellipsisMask: c10, newAxisMask: p10, shrinkAxisMask: d10 } = s10, { finalShapeSparse: h10, finalShape: f10, isIdentity: m10, sliceDim0: g10, isSimpleSlice: b10, begin: y10, end: v10, strides: x10 } = wt.sliceInfo(r10.shape, a10, i10, o10, u10, l10, c10, p10, d10), k10;
  if (m10)
    k10 = he2({ inputs: { x: r10 }, backend: n10, attrs: { shape: f10 } });
  else if (g10 || b10) {
    w2.assert(r10.shape.length >= 1, () => `Input must have rank at least 1, got: ${r10.shape.length}`);
    let T10 = wt.computeOutShape(y10, v10, x10), E10 = ou({ inputs: { x: r10 }, backend: n10, attrs: { begin: y10, size: T10 } });
    k10 = he2({ inputs: { x: E10 }, backend: n10, attrs: { shape: f10 } }), n10.disposeIntermediateTensorInfo(E10);
  } else if (n10.shouldExecuteOnCPU([r10])) {
    let E10 = n10.readSync(r10.dataId), A10 = De(r10.shape, r10.dtype, E10), P10 = JK(h10, A10, x10, y10);
    k10 = n10.makeTensorInfo(f10, r10.dtype, P10.values);
  } else {
    let E10 = new gee(y10, x10, h10);
    k10 = n10.runWebGLProgram(E10, [r10], r10.dtype);
  }
  let C10 = he2({ inputs: { x: k10 }, backend: n10, attrs: { shape: f10 } });
  return n10.disposeIntermediateTensorInfo(k10), C10;
}
var yee = { kernelName: Lo, backendName: "webgl", kernelFunc: bee };
function vee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { separator: r10, nGramWidths: a10, leftPad: i10, rightPad: o10, padWidth: u10, preserveShortSequences: l10 } = s10, { data: c10, dataSplits: p10 } = t, d10 = n10.readSync(c10.dataId), h10 = n10.readSync(p10.dataId), [f10, m10] = eX(d10, h10, r10, a10, i10, o10, u10, l10);
  return [n10.makeTensorInfo([f10.length], "string", f10), n10.makeTensorInfo(p10.shape, "int32", m10)];
}
var xee = { kernelName: ip, backendName: "webgl", kernelFunc: vee };
function wee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { skipEmpty: r10 } = s10, { input: a10, delimiter: i10 } = t;
  if (a10.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (a10.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${a10.shape}`);
  if (i10.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${i10.shape}`);
  let o10 = n10.readSync(a10.dataId), u10 = n10.readSync(i10.dataId)[0], [l10, c10, p10] = tX(o10, u10, r10), d10 = c10.length;
  return [n10.makeTensorInfo([d10, 2], "int32", l10), n10.makeTensorInfo([d10], "string", c10), n10.makeTensorInfo([2], "int32", new Int32Array(p10))];
}
var kee = { kernelName: Ng, backendName: "webgl", kernelFunc: wee };
function Iee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { numBuckets: r10 } = s10, { input: a10 } = t;
  if (a10.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r10 <= 0)
    throw new Error("Number of buckets must be at least 1");
  let i10 = n10.readSync(a10.dataId), o10 = nX(i10, r10);
  return n10.makeTensorInfo(a10.shape, "int32", o10);
}
var See = { kernelName: Tg, backendName: "webgl", kernelFunc: Iee };
var Cee = "return tan(x);";
var Nee = Ke({ opSnippet: Cee });
var Tee = { kernelName: Bo, backendName: "webgl", kernelFunc: Nee };
var $ee = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
var _ee = Ke({ opSnippet: $ee });
var Aee = { kernelName: li, backendName: "webgl", kernelFunc: _ee };
var Eee = class {
  constructor(e, t) {
    this.variableNames = ["A"];
    let n10 = new Array(e.length);
    for (let a10 = 0; a10 < n10.length; a10++)
      n10[a10] = e[a10] * t[a10];
    this.outputShape = n10, this.rank = n10.length;
    let s10 = ot(this.rank), r10 = Ree(e);
    this.userCode = `
      void main() {
        ${s10} resRC = getOutputCoords();
        setOutput(getA(${r10}));
      }
    `;
  }
};
function Ree(e) {
  let t = e.length;
  if (t > 5)
    throw Error(`Tile for rank ${t} is not yet supported`);
  if (t === 1)
    return `imod(resRC, ${e[0]})`;
  let n10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], s10 = [];
  for (let r10 = 0; r10 < e.length; r10++)
    s10.push(`imod(${n10[r10]}, ${e[r10]})`);
  return s10.join();
}
function a2(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reps: a10 } = s10;
  if (r10.dtype === "string" || r10.shape.length > 5) {
    let u10 = n10.readSync(r10.dataId), l10 = r10.dtype === "string" ? u10.map((d10) => w2.decodeString(d10)) : u10, c10 = De(r10.shape, r10.dtype, l10), p10 = rX(c10, a10);
    return n10.makeTensorInfo(p10.shape, p10.dtype, p10.values);
  }
  let i10 = new Eee(r10.shape, a10);
  return n10.runWebGLProgram(i10, [r10], r10.dtype);
}
var Dee = { kernelName: Sr, backendName: "webgl", kernelFunc: a2 };
var Fee = class {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "negativeInf", type: "float" }, { name: "dir", type: "int" }, { name: "inc", type: "int" }], this.outputShape = e, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
  }
};
var Oee = class {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "k", type: "int" }], this.outputShape = e, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
  }
};
function Wr(e, t) {
  t !== null && e.disposeIntermediateTensorInfo(t);
}
function Iw(e) {
  let t = 1;
  for (; t < e; )
    t *= 2;
  return t;
}
function Pee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { k: a10, sorted: i10 } = s10, o10 = X2().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), u10 = X2().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), l10 = r10.shape, c10 = l10[l10.length - 1];
  if (n10.shouldExecuteOnCPU([r10]) || c10 < o10 || a10 > u10) {
    let P10 = n10.readSync(r10.dataId), [R10, F10] = aX(P10, l10, r10.dtype, a10, i10);
    return [n10.makeTensorInfo(R10.shape, R10.dtype, R10.values), n10.makeTensorInfo(F10.shape, F10.dtype, F10.values)];
  }
  if (a10 === 0)
    return l10[l10.length - 1] = 0, [n10.makeTensorInfo(l10, r10.dtype, []), n10.makeTensorInfo(l10, "int32", [])];
  if (c10 === 1)
    return [r10, Jl({ attrs: { shape: l10, dtype: "int32", value: 0 }, backend: n10 })];
  let p10 = n10.texData.get(r10.dataId), d10 = p10 !== null && p10.isPacked, h10 = d10 ? n10.unpackTensor(r10) : r10, m10 = w2.sizeFromShape(l10) / c10, g10 = he2({ inputs: { x: h10 }, attrs: { shape: [m10, c10] }, backend: n10 });
  d10 && Wr(n10, h10);
  let b10 = Iw(a10), y10 = Iw(c10), v10 = null, x10 = () => v10 === null ? [g10, g10] : [g10, v10], k10 = (P10, R10, F10) => {
    let $10 = x10(), z10 = new Fee(F10), q10 = [[c10], [v10 === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [P10], [R10]], K10 = v10;
    v10 = n10.runWebGLProgram(z10, $10, "int32", q10), Wr(n10, K10);
  };
  for (let P10 = 1; P10 < b10; P10 *= 2) {
    let R10 = P10 * 2;
    for (let F10 = P10; F10 >= 1; F10 /= 2)
      k10(R10, F10, [m10, y10]);
  }
  for (let P10 = y10; P10 > b10; P10 /= 2) {
    let R10 = x10(), F10 = new Oee([m10, P10 / 2]), z10 = [[c10], [v10 === null ? 1 : 0], [b10]], W10 = v10;
    v10 = n10.runWebGLProgram(F10, R10, "int32", z10), Wr(n10, W10);
    let q10 = b10 / 2, K10 = q10 * 2;
    for (let Y10 = q10; Y10 >= 1; Y10 /= 2)
      k10(K10, Y10, v10.shape);
  }
  let C10 = v10;
  v10 = ou({ inputs: { x: v10 }, backend: n10, attrs: { begin: 0, size: [m10, a10] } }), Wr(n10, C10);
  let T10 = Y1({ inputs: { x: g10, indices: v10 }, backend: n10, attrs: { axis: 1, batchDims: 1 } });
  Wr(n10, g10);
  let E10 = l10.slice(0, -1);
  E10.push(a10), C10 = v10, v10 = he2({ inputs: { x: v10 }, attrs: { shape: E10 }, backend: n10 }), Wr(n10, C10);
  let A10 = T10;
  return T10 = he2({ inputs: { x: T10 }, attrs: { shape: E10 }, backend: n10 }), Wr(n10, A10), [T10, v10];
}
var zee = { kernelName: Vo, backendName: "webgl", kernelFunc: Pee };
var Mee = class {
  constructor(e, t, n10, s10, r10, a10) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = a10;
    let i10 = n10 === "nearest" ? 1 : 2, o10;
    switch (s10) {
      case "constant":
        o10 = 1;
        break;
      case "reflect":
        o10 = 2;
        break;
      case "wrap":
        o10 = 3;
        break;
      case "nearest":
        o10 = 4;
        break;
      default:
        o10 = 1;
        break;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o10} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o10} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o10} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r10});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r10});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i10} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
};
function Lee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10, transforms: a10 } = t, { interpolation: i10, fillMode: o10, fillValue: u10, outputShape: l10 } = s10, [c10, p10, d10, h10] = r10.shape, [f10, m10] = l10 != null ? l10 : [p10, d10], g10 = [c10, f10, m10, h10], b10 = new Mee(p10, d10, i10, o10, u10, g10);
  return n10.runWebGLProgram(b10, [r10, a10], "float32");
}
var Bee = { kernelName: Wo, backendName: "webgl", kernelFunc: Lee };
function Vee(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { axis: r10 } = n10, { x: a10 } = t;
  tu(a10, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  let i10 = s10.readSync(a10.dataId), { outputValues: o10, outputShape: u10, indices: l10 } = iX(i10, r10, a10.shape, a10.dtype);
  return [s10.makeTensorInfo(u10, a10.dtype, o10), s10.makeTensorInfo([l10.length], "int32", l10)];
}
var Wee = { kernelName: $g, backendName: "webgl", kernelFunc: Vee };
function Uee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { value: r10 } = t, { axis: a10 } = s10;
  a10 < 0 && (a10 += r10.shape.length);
  let i10 = r10, o10 = i10.shape.length, u10 = r10.shape[a10], l10 = new Array(o10 - 1), c10 = 0;
  for (let m10 = 0; m10 < o10; m10++)
    m10 !== a10 && (l10[c10++] = i10.shape[m10]);
  let p10 = [], d10 = new Array(o10).fill(0), h10 = i10.shape.slice();
  h10[a10] = 1;
  let f10 = new Array(u10);
  for (let m10 = 0; m10 < f10.length; m10++) {
    d10[a10] = m10;
    let g10 = ou({ inputs: { x: i10 }, backend: n10, attrs: { begin: d10, size: h10 } }), b10 = he2({ inputs: { x: g10 }, backend: n10, attrs: { shape: l10 } });
    f10[m10] = b10, p10.push(g10);
  }
  return p10.forEach((m10) => n10.disposeIntermediateTensorInfo(m10)), f10;
}
var Gee = { kernelName: Uo, backendName: "webgl", kernelFunc: Uee };
var Hee = class {
  constructor(e, t) {
    this.variableNames = ["x", "segmentIds"];
    let n10 = e.windowSize, s10 = e.batchSize, r10 = e.inSize, a10 = e.numSegments, i10 = a10 * Math.ceil(r10 / n10);
    this.outputShape = [s10, i10];
    let o10 = "0.0", u10 = "sumValue", l10 = Math.floor(n10 / 4) * 4, c10 = n10 % 4, p10 = `
        sumValue += dot(values, segFilter);
    `, d10 = "";
    r10 % n10 > 0 && (d10 = `
        if (inIdx < 0 || inIdx >= ${r10}) {
          return initializationValue;
        }
      `);
    let h10 = "";
    r10 % n10 > 0 && (h10 = `
        if (inIdx < 0 || inIdx >= ${r10}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${o10};

      float getValue(int batch, int inIdx) {
        ${d10}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h10}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a10})) * float(${n10}));
        int currentSeg = int(mod(float(outIdx), float(${a10})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l10}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p10}
        }

        int inIdx = inOffset + ${l10};
        if (${c10 === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p10}
        } else if (${c10 === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p10}
        } else if (${c10 === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p10}
        }
        setOutput(${u10});
      }
    `;
  }
};
function qee(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, segmentIds: a10 } = t, { numSegments: i10 } = s10, o10 = r10.shape.length, u10 = [], l10 = 0, c10 = N2.getAxesPermutation([l10], o10), p10 = r10;
  c10 != null && (p10 = cn({ inputs: { x: r10 }, backend: n10, attrs: { perm: c10 } }), u10.push(p10), l10 = N2.getInnerMostAxes(1, o10)[0]);
  let d10 = N2.segment_util.computeOutShape(p10.shape, l10, i10), h10 = w2.sizeFromShape([p10.shape[l10]]), f10 = he2({ inputs: { x: p10 }, backend: n10, attrs: { shape: [-1, h10] } });
  u10.push(f10);
  let m10 = lp(r10.dtype), g10 = (x10, k10, C10, T10, E10) => {
    let A10 = x10.shape[0], P10 = x10.shape[1], R10 = N2.segment_util.segOpComputeOptimalWindowSize(P10, E10), F10 = { windowSize: R10, inSize: P10, batchSize: A10, numSegments: E10 }, $10 = new Hee(F10, k10), z10 = n10.compileAndRun($10, [x10, C10], T10);
    if (u10.push(z10), z10.shape[1] === E10)
      return z10;
    let W10 = s2({ backend: n10, attrs: { start: 0, stop: E10, step: 1, dtype: "float32" } }), q10 = a2({ inputs: { x: W10 }, backend: n10, attrs: { reps: [P10 / R10] } });
    return u10.push(W10), u10.push(q10), g10(z10, k10, q10, T10, E10);
  }, b10 = g10(f10, "unsortedSegmentSum", a10, m10, i10), y10 = he2({ inputs: { x: b10 }, backend: n10, attrs: { shape: d10 } }), v10 = y10;
  if (c10 != null) {
    u10.push(y10);
    let x10 = N2.getUndoAxesPermutation(c10);
    v10 = cn({ inputs: { x: v10 }, backend: n10, attrs: { perm: x10 } });
  }
  return u10.forEach((x10) => n10.disposeIntermediateTensorInfo(x10)), v10;
}
var jee = { kernelName: op, backendName: "webgl", kernelFunc: qee };
var Kee = [e8, n8, a8, u8, c8, h8, m8, b8, w8, I8, N8, _8, R8, P8, L8, V8, U8, j8, X8, Q8, tY, uY, cY, pY, yY, xY, SY, OX, TY, RY, PY, WY, GY, qY, KY, YY, JY, n9, a9, o9, l9, p9, f9, y9, x9, I9, N9, $9, R9, P9, B9, U9, q9, j9, X9, Q9, J9, tQ, sQ, oQ, cQ, hQ, mQ, yQ, wQ, CQ, _Q, FX, EQ, AY, FQ, zQ, BQ, zX, GQ, KQ, YQ, eZ, sZ, oZ, cZ, fZ, yZ, wZ, IZ, TZ, _Z, EZ, OZ, zZ, LZ, VZ, UZ, jZ, QZ, t7, l7, WX, h7, g7, v7, k7, fY, C7, T7, _7, R7, P7, LX, M7, L7, mY, a7, W7, q7, Y7, GX, eJ, sJ, oJ, cJ, fJ, gJ, vJ, kJ, SJ, TJ, AJ, FJ, zJ, BJ, UJ, iY, o7, qJ, KJ, YJ, ZJ, eee, nee, ree, iee, uee, dee, hee, mee, yee, xee, kee, See, i7, QX, Tee, Aee, Dee, zee, Bee, ZX, Wee, Gee, jee, N7];
for (let e of Kee)
  _l(e);
var zs = X2();
zs.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
zs.registerFlag("WEBGPU_CPU_FORWARD", () => true);
zs.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD", () => 4);
zs.registerFlag("WEBGPU_USE_NAIVE_CONV2D", () => false);
zs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => false);
zs.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
zs.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
zs.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3);
zs.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
zs.registerFlag("WEBGPU_USE_IMPORT", () => false);
function Xee(e, t) {
  if (Math.max(...e) > 3)
    throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");
  let n10 = e.length, s10 = e.map((a10) => `${t}[${a10}]`), r10 = new Array(n10 - 1);
  r10[n10 - 2] = s10[n10 - 1];
  for (let a10 = n10 - 3; a10 >= 0; --a10)
    r10[a10] = `(${r10[a10 + 1]} * ${s10[a10 + 1]})`;
  return r10;
}
function Wt(e) {
  if (e <= 1)
    return "i32";
  if (e === 2)
    return "vec2<i32>";
  if (e === 3)
    return "vec3<i32>";
  if (e === 4)
    return "vec4<i32>";
  throw Error(`GPU for rank ${e} is not yet supported`);
}
function ld(e, t) {
  return e === "float32" ? t ? "vec4<f32>" : "f32" : e === "int32" || e === "bool" ? t ? "vec4<i32>" : "i32" : e;
}
function wv() {
  return `
  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`;
}
function Rr() {
  return `
  ${wv()}
  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,
          @builtin(global_invocation_id) GlobalId : vec3<u32>,
          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;
`;
}
function Ue() {
  return `
    ${Rr()}
      let index = getGlobalIndex();
`;
}
function Yee(e, t, n10, s10 = false) {
  let r10 = [];
  if (r10.push(`
    let workGroupSizeX = ${n10.workGroupSize[0]}u;
    let workGroupSizeY = ${n10.workGroupSize[1]}u;
    let workGroupSizeZ = ${n10.workGroupSize[2]}u;

    var<private> localId: vec3<u32>;
    var<private> globalId: vec3<u32>;
    var<private> numWorkgroups: vec3<u32>;

    // Only used when the y/z dimension of workgroup size is 1.
    fn getGlobalIndex() -> i32 {
      if (numWorkgroups.y == 1u && numWorkgroups.z == 1u) {
        return i32(globalId.x);
      }

      let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
          localId.y * workGroupSizeX + localId.x;
      let workGroupID = (globalId - localId)/vec3<u32>(
          workGroupSizeX, workGroupSizeY, workGroupSizeZ);

      return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
        workGroupID.y * numWorkgroups.x + workGroupID.x) *
        (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
        localInvocationIndex);
    }
  `), s10 === true)
    return r10.push(`
      struct Matrix0 {
        numbers: array<${ld(t.dtype, n10.isVec4)}>;
      };
      struct Uniform {
        size            : i32;
        numChannels     : i32;
        outShapeStrides : vec2<i32>;
        dispatchSize    : vec3<u32>;
      };

      @group(0) @binding(0) var<storage, write> result : Matrix0;
      @group(0) @binding(2) var<uniform> uniforms: Uniform;
    `), [Sw, r10.join(`
`), Cw(t.shape), n10.getUserCode()].join(`
`);
  let a10 = "struct Uniforms { NAN : f32; ";
  n10.variableNames.forEach((p10, d10) => {
    a10 += `${p10.charAt(0).toLowerCase() + p10.slice(1)}Shape : ${Wt(e[d10].shape.length)}; `;
  }), a10 += `outShape : ${Wt(t.shape.length)} ; `;
  let i10 = t.shape.length - 1;
  a10 += `
       outShapeStrides: ${Wt(i10)}; `, n10.size && (a10 += "size : i32; "), n10.uniforms && (a10 += n10.uniforms), a10 += "};", r10.push(a10), n10.atomic ? r10.push(`
    struct Matrix0 {
        numbers: array<atomic<i32>>;
    };

    @group(0) @binding(0) var<storage, read_write> result : Matrix0;
  `) : r10.push(`
    struct Matrix0 {
        numbers: array<${ld(t.dtype, n10.isVec4)}>;
    };

    @group(0) @binding(0) var<storage, write> result : Matrix0;
  `), n10.variableNames.forEach((p10, d10) => {
    r10.push(`
    struct Matrix${1 + d10} {
      numbers: array<${ld(e[d10].dtype, n10.isVec4)}>;
    };
    @group(0) @binding(${1 + d10}) var<storage, read> ${p10} : Matrix${1 + d10};
    `);
  }), a10 !== "" && r10.push(`
    @group(0) @binding(${1 + n10.variableNames.length}) var<uniform> uniforms : Uniforms;
    `);
  let [o10, u10] = nte(t.shape, n10.dispatchLayout), l10 = [Sw, r10.join(`
`), Cw(t.shape), o10, Qee(t.shape.length)];
  if (n10.atomic || l10.push(Zee(t.shape, t.dtype, n10.isVec4)), u10 === t.shape.length) {
    let p10 = e.map((d10) => Jee(d10, t.shape, n10.isVec4, n10.dispatchLayout.x.length === t.shape.length)).join(`
`);
    l10.push(p10);
  }
  return l10.push(n10.getUserCode()), l10.join(`
`);
}
var Sw = `
  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let mod: i32 = a % b;
    if (sign < 0. && mod != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;
function Qee(e) {
  let t = "";
  switch (e) {
    case 0:
    case 1:
      t += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
      break;
    case 2:
      t += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
      break;
    case 3:
      t += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
      break;
    case 4:
      t += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
      break;
    default:
      w2.assert(false, () => `Unsupported ${e}D shape`);
      break;
  }
  return t;
}
function Zee(e, t, n10) {
  let s10 = e.length, r10 = ld(t, n10), a10;
  if (n10 ? a10 = `fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result.numbers[flatIndex] = ${r10}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result.numbers[flatIndex] = ${r10}(value);
    }` : a10 = `fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result.numbers[flatIndex] = ${r10}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result.numbers[flatIndex] = ${r10}(value);
    }`, s10 >= 2) {
    let i10 = ["d0", "d1", "d2", "d3"].slice(0, s10), o10 = Wt(s10);
    n10 ? a10 += `
      fn setOutputAtCoords(${i10.map((u10) => `${u10} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${o10}(${i10.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${i10.map((u10) => `${u10} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${o10}(${i10.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    ` : a10 += `
      fn setOutputAtCoords(${i10.map((u10) => `${u10} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${o10}(${i10.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${i10.map((u10) => `${u10} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${o10}(${i10.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `;
  }
  return a10;
}
function Jee(e, t, n10, s10) {
  let r10 = ete(e, n10);
  return e.shape.length <= t.length && (r10 += tte(e, t, n10, s10)), r10;
}
function ete(e, t) {
  let n10 = e.name, s10 = e.shape.length, r10 = Wt(s10), a10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), i10 = ["d0", "d1", "d2", "d3"].slice(0, s10), o10 = i10.map((c10) => `${c10} : i32`).join(", ");
  if (s10 < 1)
    return t ? `
        fn ${a10}() -> vec4<f32> {
          return vec4<f32>(${n10}.numbers[0]);
        }
      ` : `
      fn ${a10}() ->f32 {
        return f32(${n10}.numbers[0]);
      }
    `;
  let u10 = `uniforms.${n10.charAt(0).toLowerCase() + n10.slice(1)}Shape`, l10 = `${s10}D`;
  return s10 === 0 && (l10 = "1D"), t ? `
      fn ${a10}(${o10}) -> vec4<f32> {
        return vec4<f32>(${n10}.numbers[getIndexFromCoords${l10}(${r10}(${i10.join(",")}),
          ${u10}) / 4]);
      }
      ` : `
    fn ${a10}(${o10}) -> f32 {
      return f32(${n10}.numbers[getIndexFromCoords${l10}(${r10}(${i10.join(",")}),
        ${u10})]);
    }
   `;
}
function tte(e, t, n10, s10) {
  let r10 = e.name, a10 = r10.charAt(0).toUpperCase() + r10.slice(1), i10 = "get" + a10 + "ByOutput", o10 = e.shape.length, u10 = t.length, l10 = Wt(u10);
  if (w2.arraysEqual(e.shape, t) && s10)
    return n10 ? `
        fn ${i10}Index(globalIndex : i32) -> vec4<f32> {
          return vec4<f32>(${r10}.numbers[globalIndex]);
        }

        fn ${i10}Coords(coords : ${l10}) -> vec4<f32> {
          return vec4<f32>(${r10}.numbers[${u10 > 1 ? "getOutputIndexFromCoords(coords)" : "coords"} / 4]);
        }
        ` : `
      fn ${i10}Index(globalIndex : i32) -> f32 {
        return f32(${r10}.numbers[globalIndex]);
      }

      fn ${i10}Coords(coords : ${l10}) -> f32 {
        return f32(${r10}.numbers[${u10 > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}]);
      }
      `;
  let c10 = N2.getBroadcastDims(e.shape, t), p10 = u10 - o10, d10 = "";
  if (o10 === 0)
    return n10 ? `
      fn ${i10}Index(globalIndex : i32) -> vec4<f32> {
        return get${a10}();
      }

      fn ${i10}Coords(coords : ${l10}) -> vec4<f32> {
        return get${a10}();
      }
    ` : `
      fn ${i10}Index(globalIndex : i32) -> f32{
        return get${a10}();
      }

      fn ${i10}Coords(coords : ${l10}) -> f32{
        return get${a10}();
      }
    `;
  u10 < 2 && c10.length >= 1 ? d10 = "coords = 0;" : d10 = c10.map((g10) => `coords[${g10 + p10}] = 0;`).join(`
`);
  let h10 = "";
  if (u10 < 2 && o10 > 0)
    h10 = "coords";
  else if (u10 > 1) {
    let g10 = Wt(o10), b10 = e.shape.map((y10, v10) => `coords[${v10 + p10}]`).join(", ");
    h10 = `${g10}(${b10})`;
  } else
    h10 = "coords";
  let f10 = `uniforms.${r10.charAt(0).toLowerCase() + r10.slice(1)}Shape`, m10 = `${o10}D`;
  return n10 ? `
      fn ${i10}Index(globalIndex : i32) -> vec4<f32> {
        var coords = getCoordsFromIndex(globalIndex);
        ${d10}
        return ${r10}.numbers[getIndexFromCoords${m10}(${h10}, ${f10}) / 4];
      }

      fn ${i10}Coords(coordsIn : ${l10}) -> vec4<f32> {
        var coords = coordsIn;
        ${d10}
        return ${r10}.numbers[getIndexFromCoords${m10}(${h10}, ${f10}) / 4];
      }
    ` : `
    fn ${i10}Index(globalIndex : i32) -> f32 {
      var coords = getCoordsFromIndex(globalIndex);
      ${d10}
      return f32(${r10}.numbers[getIndexFromCoords${m10}(${h10}, ${f10})]);
    }

    fn ${i10}Coords(coordsIn : ${l10}) -> f32 {
      var coords = coordsIn;
      ${d10}
      return f32(${r10}.numbers[getIndexFromCoords${m10}(${h10}, ${f10})]);
    }
  `;
}
function nte(e, t) {
  let { x: n10, y: s10 = [], z: r10 = [] } = t, a10 = e.length;
  if (n10.length === a10)
    return [`fn getOutputCoords() -> ${Wt(a10)}{
      let globalIndex = getGlobalIndex();
      return getCoordsFromIndex(globalIndex);
    }
    `, a10];
  let i10 = "", o10 = [n10, s10, r10], u10 = 0;
  for (let d10 = 0; d10 < o10.length; d10++) {
    let h10 = o10[d10];
    if (h10.length !== 0)
      if (u10 += h10.length, h10.length === 1)
        i10 += `let d${h10[0]} = i32(globalId[${d10}]);`;
      else {
        let f10 = Xee(h10, "uniforms.outShape");
        i10 += `var index${d10} = i32(globalId[${d10}]);`;
        for (let m10 = 0; m10 < f10.length; m10++)
          i10 += `let d${h10[m10]} = index${d10} / ${f10[m10]};`, m10 === f10.length - 1 ? i10 += `let d${h10[m10 + 1]} = index${d10} - d${h10[m10]} * ${f10[m10]};` : i10 += `index${d10} = index${d10} - d${h10[m10]} * ${f10[m10]};`;
      }
  }
  let l10 = [];
  for (let d10 = 0; d10 < u10; d10++)
    l10.push(`d${d10}`);
  let c10 = Wt(u10), p10 = `fn getOutputCoords() -> ${c10} {
    ${i10}
  `;
  return l10.length === 0 ? p10 += `return ${c10}(0); }` : p10 += `return ${c10}(${l10.join(",")}); }`, [p10, u10];
}
function Cw(e) {
  let t = e.length;
  if (t <= 1)
    return "fn getCoordsFromIndex(index : i32) -> i32 { return index; }";
  let n10 = w2.computeStrides(e), s10 = Wt(t), r10 = [];
  for (let i10 = 0; i10 < t; i10++)
    r10.push(`d${i10}`);
  if (n10.length === 1)
    return `    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;
  let a10 = "var index2 = index;" + n10.map((i10, o10) => {
    let u10 = `let ${r10[o10]} = index2 / uniforms.outShapeStrides[${o10}]`, l10 = o10 === n10.length - 1 ? `let ${r10[o10 + 1]} = index2 - ${r10[o10]} * uniforms.outShapeStrides[${o10}]` : `index2 = index2 - ${r10[o10]} * uniforms.outShapeStrides[${o10}]`;
    return `${u10}; ${l10};`;
  }).join("");
  return `
    fn getCoordsFromIndex(index : i32) -> ${s10} {
      ${a10}
      return ${s10}(${r10.join(",")});
    }
  `;
}
var i2 = {};
Ae(i2, { ArrayBufferToTypedArray: () => u2, GPUBytesPerElement: () => Hm, computeDispatch: () => _e2, computeWorkGroupSizeForConv2d: () => kv, computeWorkGroupSizeForMatMul: () => o2, computeWorkPerThreadForConv2d: () => Iv, flatDispatchLayout: () => Be, isWebGPUSupported: () => Sv, tilesFitEvenlyIntoShape: () => Ks });
var ea = (e) => {
  let t = 1;
  for (let n10 = 0; n10 < e.length; n10++)
    t *= e[n10];
  return t;
};
function Ks(e, t) {
  if (e.length !== t.length)
    throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);
  return t.every((n10, s10) => n10 % e[s10] === 0);
}
function _e2(e, t, n10 = [1, 1, 1], s10 = [1, 1, 1]) {
  let [r10, a10, i10] = [Math.ceil(ea(e.x.map((o10) => t[o10])) / (n10[0] * s10[0])), e.y ? Math.ceil(ea(e.y.map((o10) => t[o10])) / (n10[1] * s10[1])) : 1, e.z ? Math.ceil(ea(e.z.map((o10) => t[o10])) / (n10[2] * s10[2])) : 1];
  return [r10, a10, i10];
}
function kv(e, t) {
  let n10 = ea(e.x.map((r10) => t[r10])), s10 = ea(e.y.map((r10) => t[r10]));
  return n10 <= 4 ? [4, 16, 1] : s10 <= 4 ? [16, 4, 1] : [16, 16, 1];
}
function o2(e, t, n10) {
  return e === 1 ? [32, 1, 1] : n10 === 1 ? [1, 32, 1] : [8, 8, 1];
}
function Iv(e, t) {
  let n10 = ea(e.x.map((r10) => t[r10])), s10 = ea(e.y.map((r10) => t[r10]));
  return n10 <= 4 ? [1, 2, 1] : s10 <= 4 ? [2, 1, 1] : [2, 2, 1];
}
function Be(e) {
  return { x: e.map((t, n10) => n10) };
}
function Hm(e) {
  if (e === "float32" || e === "int32" || e === "bool" || e === "string")
    return 4;
  if (e === "complex64")
    return 8;
  throw new Error(`Unknown dtype ${e}`);
}
function u2(e, t) {
  if (t === "float32")
    return new Float32Array(e);
  if (t === "int32")
    return new Int32Array(e);
  if (t === "bool" || t === "string")
    return Uint8Array.from(new Int32Array(e));
  throw new Error(`Unknown dtype ${t}`);
}
function Sv() {
  return (typeof window != "undefined" || typeof WorkerGlobalScope != "undefined") && !!navigator.gpu;
}
var ste = "return a + b;";
var rte = "return areal * breal - aimag * bimag;";
var ate = "return areal * bimag + aimag * breal;";
var ite = "return a / b;";
var ote = "return a * b;";
var ute = "return (a - b) * (a - b);";
var lte = "return a - b;";
var cte = "return f32(a == b);";
var dte = "return vec4<f32>(a == b);";
var pte = "return f32(a > b);";
var hte = "return vec4<f32>(a > b);";
var fte = "return f32(a >= b);";
var mte = "return vec4<f32>(a >= b);";
var gte = "return f32(a < b);";
var bte = "return vec4<f32>(a < b);";
var yte = "return f32(a <= b);";
var vte = "return vec4<f32>(a <= b);";
var xte = "return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";
var wte = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`;
var kte = `
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `;
var l2 = `
  if (isNaN.r) {
    resultTemp.r = uniforms.NAN;
  }
  if (isNaN.g) {
    resultTemp.g = uniforms.NAN;
  }
  if (isNaN.b) {
    resultTemp.b = uniforms.NAN;
  }
  if (isNaN.a) {
    resultTemp.a = uniforms.NAN;
  }
  `;
var Ite = `
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `;
var Ste = `
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `;
var Cte = "return f32(a != b);";
var Nte = "return vec4<f32>(a != b);";
var Tte = `
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `;
var $te = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;
  ${l2}
  return resultTemp;
  `;
var _te = "if (a < 0.0) { return b * a; }  return a;";
var Ate = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;
function Nw(e, t) {
  let n10 = t ? l2 : kte;
  return t ? `
    var resultTemp = vec4<f32>(${e}(a, b));
    let isNaN = isnanVec4(a) | isnanVec4(b);
    ` + n10 + `
    return resultTemp;
  ` : n10 + `
    return ${e}(a, b);
  `;
}
function ec(e, t) {
  switch (e) {
    case 0:
      return ote;
    case 1:
      return ste;
    case 2:
      return lte;
    case 3:
      return ite;
    case 4:
      return t ? dte : cte;
    case 5:
      return t ? hte : pte;
    case 6:
      return t ? mte : fte;
    case 7:
      return t ? bte : gte;
    case 8:
      return t ? vte : yte;
    case 9:
      return t ? wte : xte;
    case 10:
      return t ? Nte : Cte;
    case 11:
      return ute;
    case 12:
      return t ? Ste : Ite;
    case 14:
      return t ? Ate : _te;
    case 15:
      return Nw("max", t);
    case 16:
      return Nw("min", t);
    case 13:
      return t ? $te : Tte;
    case 17:
      return rte;
    case 18:
      return ate;
    default:
      throw new Error(`BinaryType ${e} is not implemented!`);
  }
}
var Ete = "return abs(a);";
var Rte = "return ceil(a);";
var Dte = "return cos(a);";
var Fte = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;
var Ote = "return exp(a) - 1.0;";
var Pte = "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";
var zte = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
var Mte = "return exp(a);";
var Lte = "return floor(a);";
var Bte = "return a;";
var Vte = `if (a < 0.0) { return 1.0/0.0; }
  return log(a);`;
var Wte = "return f32(!(a >= 1.0));";
var Ute = "return -a;";
var Gte = "return (a < 0.0) ? b * a : a;";
var Hte = "if (a < 0.0) { return uniforms.alpha * a; } return a;";
var qte = "if(a < 0.0) { return 0.0; } return a;";
var jte = "return clamp(a, 0.0, 6.0);";
var Kte = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));";
var Xte = `
  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));
  let isNaN = isnanVec4(a);

  if (isNaN.r) {
    resFloat.r = a.r;
  }
  if (isNaN.g) {
    resFloat.g = a.g;
  }
  if (isNaN.b) {
    resFloat.b = a.b;
  }
  if (isNaN.a) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
var Yte = "return 1.0/sqrt(a);";
var Qte = "return 1.0 / (1.0 + exp(-1.0 * a));";
var Zte = "return sin(a);";
var Jte = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;
var ene = "return sqrt(a);";
var tne = "return a * a;";
var nne = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;
var sne = "return f32(i32((a)));";
function Ui(e, t) {
  switch (e) {
    case 0:
      return Ete;
    case 2:
      return Dte;
    case 3:
      return Fte;
    case 1:
      return Rte;
    case 4:
      return t ? zte : Pte;
    case 5:
      return Mte;
    case 6:
      return Ote;
    case 7:
      return Lte;
    case 8:
      return Bte;
    case 9:
      return Vte;
    case 10:
      return Wte;
    case 11:
      return Ute;
    case 12:
      return Gte;
    case 15:
      return Hte;
    case 13:
      return t ? Xte : qte;
    case 14:
      return t ? Kte : jte;
    case 16:
      return Yte;
    case 19:
      return Qte;
    case 17:
      return Zte;
    case 18:
      return Jte;
    case 20:
      return ene;
    case 21:
      return tne;
    case 22:
      return nne;
    case 23:
      return sne;
    default:
      throw new Error(`BinaryType ${e} is not implemented!`);
  }
}
function Zs(e, t = false) {
  if (e === null)
    return null;
  if (e === "linear")
    return Ui(8);
  if (e === "relu")
    return Ui(13, t);
  if (e === "elu")
    return Ui(4, t);
  if (e === "relu6")
    return Ui(14, t);
  if (e === "prelu")
    return ec(14, t);
  if (e === "sigmoid")
    return Ui(19);
  throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);
}
function c2(e, t, n10, s10) {
  return w2.assert(s10 % 4 === 0 && e[0] === 4, () => "tileInner must be divisible by 4. And ColPerThread must be 4"), `
  var<workgroup> mm_Asub : array<array<vec4<f32>, ${s10 / e[0]}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${n10 / e[0]}>, ${s10}>;

  let RowPerThread = ${e[1]};
  let ColPerThread = ${e[0]};
  let TileInner = ${s10};

  ${Rr()}

    let tileRow = ${t === 1 ? "0" : "i32(localId.y) * RowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${t === 1 ? "0" : "i32(globalId.y) * RowPerThread"};
    let globalCol = i32(globalId.x);
    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;

    var acc: array<vec4<f32>, RowPerThread>;
    var ACached : vec4<f32>;
    var BCached : array<vec4<f32>, 4>;

    // Loop over shared dimension.
    var globalColA = tileCol;
    let RowPerThreadB = TileInner / i32(workGroupSizeY);
    let tileRowB = i32(localId.y) * RowPerThreadB;
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);
        }
        globalColA = globalColA + TileInner / ColPerThread;

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {
            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];
            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];
            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];
            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];

            for (var i = 0; i < RowPerThread; i = i + 1) {
                ACached = mm_Asub[tileRow + i][k];
                acc[i] = BCached[0] * ACached.x + acc[i];
                acc[i] = BCached[1] * ACached.y + acc[i];
                acc[i] = BCached[2] * ACached.z + acc[i];
                acc[i] = BCached[3] * ACached.w + acc[i];
            }
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(globalRow + innerRow,
                 globalCol,
                 acc[innerRow], globalId);
    }
  }`;
}
var rne = class {
  constructor(e, t, n10, s10 = null, r10 = null, a10 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.workGroupSize = [8, 8, 1], this.isVec4 = true, this.outputShape = t, this.dispatchLayout = { x: [2], y: [1], z: [0] }, t[1] === 1 ? this.elementsPerThread = [4, 1, 1] : this.elementsPerThread = [4, 4, 1], this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread);
    let i10 = s10 != null, o10 = a10 != null;
    i10 && this.variableNames.push("bias"), o10 && this.variableNames.push("preluActivationWeights"), this.tileAOuter = t[1] === 1 ? 1 : this.workGroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workGroupSize[0] * this.elementsPerThread[0], this.tileInner = this.tileBOuter, this.aShape = e, this.addBias = i10, this.activation = r10, this.hasPreluActivationWeights = o10, [this.fitA, this.fitB] = this.getShapeFit(), this.shaderKey = `matMulPackedVec4_${this.activation}_${this.fitA}_${this.fitB}_${this.elementsPerThread}`;
  }
  getShapeFit() {
    let e = this.aShape[2], t = this.outputShape[2], n10 = [this.outputShape[0], e, t], s10 = [this.tileAOuter, this.tileInner], r10 = [this.tileInner, this.tileBOuter];
    return [Ks(s10, this.aShape.slice(1)), Ks(r10, n10.slice(1))];
  }
  getUserCode() {
    let e = this.fitA ? "return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]" : `if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];
        }
        return vec4<f32>(0.0)`, t = this.fitB ? "return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]" : `if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];
        }
        return vec4<f32>(0.0)`, n10 = "", s10 = "";
    if (this.activation) {
      let i10 = Zs(this.activation, this.isVec4);
      this.hasPreluActivationWeights ? n10 = `fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
                  let b = getPreluActivationWeightsByOutputCoords(outCoord);
                  ${i10}
                }` : n10 = `
            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
              ${i10}
            }`, s10 = "value = activation(value, outCoord);";
    }
    let r10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
      ${n10}
      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / 4;
        let batch = i32(globalId.z);
        ${e};
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / 4;
        let batch = i32(globalId.z);
        ${t};
      }

      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {
        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])
        {
          var value = valueIn;
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col * 4);
          ${r10}
          ${s10}
          setOutputAtCoords(outCoord[0], outCoord[1], outCoord[2], value);
        }
      }
      ${c2(this.elementsPerThread, this.tileAOuter, this.tileBOuter, this.tileInner)}
    `;
  }
};
function Cv(e, t) {
  let n10 = t[1] * e[1], s10 = t[0] * e[0], r10 = n10 > s10 ? n10 : s10;
  return `
    var<workgroup> mm_Asub : array<array<f32, ${r10}>, ${n10}>;
    var<workgroup> mm_Bsub : array<array<f32, ${s10}>, ${r10}>;
    ${Rr()}
      let tileRow = i32(localId.y) * ${e[1]};
      let tileCol = i32(localId.x) * ${e[0]};

      let globalRow = i32(globalId.y) * ${e[1]};
      let globalCol = i32(globalId.x) * ${e[0]};

      let numTiles = (uniforms.dimInner - 1) / ${r10} + 1;

      var acc : array<array<f32, ${e[0]}>, ${e[1]}>;
      var ACached : f32;
      var BCached : array<f32, ${e[0]}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let ColPerThreadA = ${r10} / ${t[0]};
      let tileColA = i32(localId.x) * ColPerThreadA;
      let RowPerThreadB = ${r10} / ${t[1]};
      let tileRowB = i32(localId.y) * RowPerThreadB;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileColA + innerCol;

            mm_Asub[inputRow][inputCol] = mm_readA(
                globalRow + innerRow,
                t * ${r10} + inputCol, globalId);
          }
        }
        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;

            mm_Bsub[inputRow][inputCol] = mm_readB(
              t * ${r10} + inputRow,
              globalCol + innerCol, globalId);
          }
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${r10}; k = k + 1) {
          for (var inner = 0; inner < ${e[0]}; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
            ACached = mm_Asub[tileRow + innerRow][k];
            for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {

          if ((globalCol + innerCol) < uniforms.dimBOuter &&
              (globalRow + innerRow) < uniforms.dimAOuter) {
            mm_write(globalRow + innerRow,
                     globalCol + innerCol,
                     acc[innerRow][innerCol], globalId);
          }
        }
      }
    }
  `;
}
function ane(e) {
  return `
    let TileSize = ${e[0] * 4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;

    ${Rr()}
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;

      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),
                                mm_readA(globalRow, colA + 1, globalId),
                                mm_readA(globalRow, colA + 2, globalId),
                                mm_readA(globalRow, colA + 3, globalId));
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),
                              mm_readB(rowB + 1, globalCol, globalId),
                              mm_readB(rowB + 2, globalCol, globalId),
                              mm_readB(rowB + 3, globalCol, globalId));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
        mm_write(globalRow, globalCol, acc, globalId);
      }
    }
  `;
}
var d2 = class {
  constructor(e, t, n10, s10 = false, r10 = false, a10 = null, i10 = null, o10 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.workGroupSize = [16, 16, 1], this.outputShape = t, this.dispatchLayout = { x: [2], y: [1], z: [0] };
    let u10 = s10 ? e[1] : e[2];
    this.workGroupSize = o2(t[1], u10, t[2]), (t[1] === 1 || t[2] === 1) && (n10 = 1), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [n10, n10, 1]), w2.arraysEqual(this.dispatch, [1, 1, 1]) && (n10 = 1, this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [n10, n10, 1]));
    let l10 = a10 != null, c10 = o10 != null;
    l10 && this.variableNames.push("bias"), c10 && this.variableNames.push("preluActivationWeights"), this.workPerThread = n10, this.aShape = e, this.transposeA = s10, this.transposeB = r10, this.addBias = l10, this.activation = i10, this.hasPreluActivationWeights = c10;
    let p10 = this.outputShape[2], d10 = this.transposeB ? [this.outputShape[0], p10, u10] : [this.outputShape[0], u10, p10];
    [this.fitA, this.fitB] = this.getShapeFit(d10), this.shaderKey = `matMulPacked_${this.workPerThread}_${s10}_${r10}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1] > 1}`;
  }
  getShapeFit(e) {
    let t = this.workGroupSize[1] * this.workPerThread, n10 = this.workGroupSize[0] * this.workPerThread, s10 = t > n10 ? t : n10;
    this.outputShape[1] === 1 && (s10 *= 4), w2.assert(s10 % this.workGroupSize[0] === 0 && s10 % this.workGroupSize[1] === 0, () => "tileInner must be multiple of workgroupsize.x and workgroupsize.y");
    let r10 = [t, s10], a10 = [s10, n10];
    return [Ks(r10, this.aShape.slice(1)), Ks(a10, e.slice(1))];
  }
  getUserCode() {
    let e;
    this.transposeA === false ? e = this.fitA ? "return A.numbers[batch * batchASize + row * uniforms.dimInner + col];" : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
           }
           return 0.0;` : e = this.fitA ? "return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];" : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];
           }
           return 0.0;`;
    let t;
    this.transposeB === false ? t = this.fitB ? "return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];" : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
           }
           return 0.0;` : t = this.fitB ? "return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];" : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];
           }
           return 0.0;`;
    let n10 = "", s10 = "";
    if (this.activation) {
      let i10 = Zs(this.activation, false);
      this.hasPreluActivationWeights ? n10 = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsByOutputCoords(outCoord);
               ${i10}
            }` : n10 = `
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${i10}
              }
            `, s10 = "value = activation(value, outCoord);";
    }
    let r10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
      ${n10}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        var value = valueIn;
        let batch = i32(globalId.z);
        let outCoord = vec3<i32>(batch, row, col);
        ${r10}
        ${s10}
        setOutputAtCoords(batch, row, col, value);
      }
      ${this.outputShape[1] > 1 ? Cv([this.workPerThread, this.workPerThread, 1], this.workGroupSize) : ane(this.workGroupSize)}
    `;
  }
};
function ine() {
  return `
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${Rr()}
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
}
var one = class {
  constructor(e, t = false, n10 = false, s10 = null, r10 = null, a10 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.workGroupSize = [256, 1, 1], this.outputShape = e, this.dispatchLayout = { x: [], y: [1, 2], z: [0] }, this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize);
    let i10 = s10 != null, o10 = a10 != null;
    i10 && this.variableNames.push("bias"), o10 && this.variableNames.push("preluActivationWeights"), this.transposeA = t, this.transposeB = n10, this.addBias = i10, this.activation = r10, this.hasPreluActivationWeights = o10, this.shaderKey = `matMulReduce_${this.activation}_${t}_${n10}`;
  }
  getUserCode() {
    let e;
    this.transposeA === false ? e = "return A.numbers[batch * batchASize + row * uniforms.dimInner + col];" : e = "return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];";
    let t;
    this.transposeB === false ? t = "return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];" : t = "return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];";
    let n10 = "", s10 = "";
    if (this.activation) {
      let i10 = Zs(this.activation, false);
      this.hasPreluActivationWeights ? n10 = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsByOutputCoords(outCoord);
               ${i10}
            }` : n10 = `
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${i10}
              }
            `, s10 = "value = activation(value, outCoord);";
    }
    let r10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
      ${n10}

      fn mm_readA(batch: i32, row : i32, col : i32) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        ${e}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> f32 {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {
        var value = valueIn;
        let outCoord = vec3<i32>(batch, row, col);
        ${r10}
        ${s10}
        setOutputAtCoords(batch, row, col, value);
      }
      ${ine()}
    `;
  }
};
function une(e) {
  let t = e[1] / 2, n10 = e[0], s10 = t > n10 ? t : n10;
  return `
  var<workgroup> mm_Asub1 : array<array<f32, ${s10}>, ${t}>;
  var<workgroup> mm_Bsub1 : array<array<f32, ${n10}>, ${s10}>;
  var<workgroup> mm_Asub2 : array<array<f32, ${s10}>, ${t}>;
  var<workgroup> mm_Bsub2 : array<array<f32, ${n10}>, ${s10}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Introduces two shared memory buffers, some logical threads could handle
  // arithmetic operations and others handle IO operations between barrier api,
  // makes ALUs and load/store units work simultaneously, could improves
  // the performance.
  ${Rr()}
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s10} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = tileRow;
    for (var t = 0; t < numTiles; t = t + 1) {
      if (t == 0) {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${s10};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${s10};
        }
      } else {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${s10};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${s10};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${s10}; k = k + 1) {
            let subRow = tileRow - ${t};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];
          }
        }
      }
      workgroupBarrier();
      if (t != 0) {
        t = t + 1;
      }

      if (t < numTiles) {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub2[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${s10};
          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${s10};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${s10}; k = k + 1) {
            let subRow = tileRow - ${t};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];
          }
        }
      }
      workgroupBarrier();
    }
    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${t};
    if (tileRow >= ${t} && writeCol >= 0) {
      mm_write(writeCol, globalCol, acc, globalId);
    }
  }
  `;
}
var lne = class {
  constructor(e, t, n10, s10 = null, r10 = null, a10 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.workGroupSize = [8, 16, 1], w2.assert(e[1] <= 16 || t[2] <= 16, () => "This program can be only used when A width or B Height are small"), this.outputShape = n10, this.dispatchLayout = { x: [2], y: [1], z: [0] }, this.dispatch = [Math.ceil(n10[2] / this.workGroupSize[0]), Math.ceil(n10[1] * 2 / this.workGroupSize[1]), n10[0]];
    let i10 = s10 != null;
    i10 && this.variableNames.push("bias");
    let o10 = a10 != null;
    o10 && this.variableNames.push("preluActivationWeights"), this.addBias = i10, this.activation = r10, this.hasPreluActivationWeights = o10, this.shaderKey = `matMulSmallOutputSize_${this.activation}`;
  }
  getUserCode() {
    let e = `if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
        }
        return 0.0;`, t = `if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
         }
         return 0.0;`, n10 = "", s10 = "";
    if (this.activation) {
      let i10 = Zs(this.activation, false);
      this.hasPreluActivationWeights ? n10 = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            let b = getPreluActivationWeightsByOutputCoords(outCoord);
            ${i10}
            }` : n10 = `fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            ${i10}
        }`, s10 = "value = activation(value, outCoord);";
    }
    let r10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
      ${n10}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }
      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }
      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col);
          var value = valueIn;
          ${r10}
          ${s10}
          setOutputAtCoords(batch, row, col, value);
        }
      }
      ${une(this.workGroupSize)}
    `;
  }
};
function Me2(e) {
  let { inputs: t, attrs: n10 } = e, { x: s10 } = t, { shape: r10 } = n10, a10 = w2.sizeFromShape(s10.shape), i10 = w2.inferFromImplicitShape(r10, a10), o10 = w2.sizeFromShape(i10);
  return w2.assert(a10 === o10, () => `The new shape (${i10}) has ${o10} elements and the old shape (${s10.shape}) has ${a10} elements. The new shape and old shape must have the same number of elements.`), e.backend.incRef(s10.dataId), { dataId: s10.dataId, shape: i10, dtype: s10.dtype };
}
var cne = { kernelName: Ao, backendName: "webgpu", kernelFunc: Me2 };
function Nv({ a: e, b: t, transposeA: n10, transposeB: s10, backend: r10, bias: a10 = null, preluActivationWeights: i10 = null, leakyreluAlpha: o10 = 0, activation: u10 = null }) {
  let l10 = e.shape.length, c10 = t.shape.length, p10 = n10 ? e.shape[l10 - 2] : e.shape[l10 - 1], d10 = s10 ? t.shape[c10 - 1] : t.shape[c10 - 2], h10 = n10 ? e.shape[l10 - 1] : e.shape[l10 - 2], f10 = s10 ? t.shape[c10 - 2] : t.shape[c10 - 1], m10 = e.shape.slice(0, -2), g10 = t.shape.slice(0, -2), b10 = w2.sizeFromShape(m10), y10 = w2.sizeFromShape(g10), x10 = qo.assertAndGetBroadcastShape(e.shape.slice(0, -2), t.shape.slice(0, -2)).concat([h10, f10]);
  w2.assert(p10 === d10, () => `Error in matMul: inner shapes (${p10}) and (${d10}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n10} and transposeB=${s10} must match.`);
  let k10 = n10 ? [b10, p10, h10] : [b10, h10, p10], C10 = s10 ? [y10, f10, d10] : [y10, d10, f10], T10 = Me2({ inputs: { x: e }, backend: r10, attrs: { shape: k10 } }), E10 = Me2({ inputs: { x: t }, backend: r10, attrs: { shape: C10 } }), A10 = [T10, E10], P10 = Math.max(b10, y10), R10 = p10 % 4 === 0 && f10 % 4 === 0 && !n10 && !s10 && f10 >= 32, F10;
  h10 * f10 <= 32 ? F10 = new one([P10, h10, f10], n10, s10, a10, u10, i10) : !n10 && !s10 && (h10 <= 16 && (f10 <= 512 || d10 >= 2 * f10) || f10 <= 16 && (h10 <= 512 || p10 >= 2 * h10)) ? F10 = new lne(k10, C10, [P10, h10, f10], a10, u10, i10) : R10 ? F10 = new rne(k10, [P10, h10, f10], X2().get("WEBGPU_MATMUL_WORK_PER_THREAD"), a10, u10, i10) : F10 = new d2(k10, [P10, h10, f10], X2().get("WEBGPU_MATMUL_WORK_PER_THREAD"), n10, s10, a10, u10, i10);
  let $10 = [T10, E10];
  a10 && $10.push(a10), i10 && $10.push(i10);
  let z10 = [{ type: "int32", data: [h10] }, { type: "int32", data: [f10] }, { type: "int32", data: [p10] }], W10 = r10.runWebGPUProgram(F10, $10, e.dtype, z10), q10 = Me2({ inputs: { x: W10 }, backend: r10, attrs: { shape: x10 } });
  A10.push(W10);
  for (let K10 of A10)
    r10.disposeData(K10.dataId);
  return q10;
}
function dne(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10, bias: i10, preluActivationWeights: o10 } = t, { transposeA: u10, transposeB: l10, activation: c10, leakyreluAlpha: p10 } = s10;
  return Nv({ a: r10, b: a10, transposeA: u10, transposeB: l10, backend: n10, bias: i10, preluActivationWeights: o10, leakyreluAlpha: p10, activation: c10 });
}
var pne = { kernelName: na, backendName: "webgpu", kernelFunc: dne };
var Tw = class {
  constructor(e, t, n10) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.workGroupSize = [128, 1, 1], this.size = true, this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = `binaryOpComplex_${e}`, this.op = e;
  }
  getUserCode() {
    return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${ec(this.op, false)}
      }

      ${Ue()}
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
  }
};
var hne = class {
  constructor(e, t, n10, s10) {
    this.variableNames = ["A", "B"], this.size = true;
    let r10 = 256;
    this.workGroupSize = [r10, 1, 1], this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.dispatchLayout = Be(this.outputShape), this.lastDimensionSize = s10 ? n10[0] : t[0], this.lastDimensionSize < 256 ? this.workPerThread = 1 : this.lastDimensionSize < 512 ? this.workPerThread = 2 : this.workPerThread = 4, this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.useSharedMemoryWithB = s10, this.op = e, this.shaderKey = `binaryShared_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`;
  }
  getUserCode() {
    let e = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", t = this.useSharedMemoryWithB ? `let a = getAByOutputCoords(coords);
         let b = sharedBuf[${e}];` : `let a = sharedBuf[${e}];
         let b = getBByOutputCoords(coords);`;
    return `
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${ec(this.op, false)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ue()}

          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}.numbers[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;
            if(flatIndex < uniforms.size) {
              let coords = getCoordsFromIndex(flatIndex);

              ${t}
              setOutputAtIndex(flatIndex, binaryOperation(a, b));
            }
          }
        }
        `;
  }
};
var fne = class {
  constructor(e, t, n10) {
    this.variableNames = ["A", "B"], this.workPerThread = 4, this.isVec4 = true, this.size = true;
    let s10 = 128;
    this.workGroupSize = [s10, 1, 1], this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.op = e, this.shaderKey = `binaryVec4_${e}`;
  }
  getUserCode() {
    return `
      fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
        ${ec(this.op, this.isVec4)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          let b = getBByOutputIndex(index);
          setOutputAtIndex(index, binaryOperation(a, b));
        }
      }
    `;
  }
};
var p2 = class {
  constructor(e, t, n10) {
    this.variableNames = ["A", "B"], this.size = true;
    let s10 = 128;
    this.workGroupSize = [s10, 1, 1], this.outputShape = N2.assertAndGetBroadcastShape(t, n10), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = `binary_${e}`, this.op = e;
  }
  getUserCode() {
    return `
      fn binaryOperation(a : f32, b : f32) -> f32 {
        ${ec(this.op, false)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          let b = getBByOutputIndex(index);
          setOutputAtIndex(index, binaryOperation(a, b));
        }
      }
      `;
  }
};
function $w(e, t, n10) {
  if (w2.arraysEqual(t, n10) && w2.sizeFromShape(t) % 4 === 0)
    return new fne(e, t, n10);
  let r10 = t.length === 1 && n10.length > 1 && t[0] < 1024, a10 = n10.length === 1 && t.length > 1 && n10[0] < 1024;
  return r10 || a10 ? new hne(e, t, n10, a10) : new p2(e, t, n10);
}
function Zn(e) {
  let { inputs: t } = e, { x: n10 } = t;
  return e.backend.incRef(n10.dataId), { dataId: n10.dataId, shape: n10.shape, dtype: n10.dtype };
}
var mne = { kernelName: Ma, backendName: "webgpu", kernelFunc: Zn };
function uu(e) {
  let { inputs: t, backend: n10 } = e, { real: s10, imag: r10 } = t, a10 = n10.makeTensorInfo(s10.shape, "complex64"), i10 = n10.tensorMap.get(a10.dataId), o10 = Zn({ inputs: { x: s10 }, backend: n10 }), u10 = Zn({ inputs: { x: r10 }, backend: n10 });
  return i10.complexTensorInfos = { real: o10, imag: u10 }, a10;
}
var gne = { kernelName: qd, backendName: "webgpu", kernelFunc: uu };
var tc = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.size = true;
    let n10 = 128;
    this.workGroupSize = [n10, 1, 1], this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.op = t, this.shaderKey = `unary_${t}`;
  }
  getUserCode() {
    return `
      fn unaryOperation(a : f32) -> f32 {
        ${Ui(this.op, false)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
  }
};
function jt({ opType: e, cpuKernelImpl: t, dtype: n10 }) {
  return ({ inputs: s10, backend: r10 }) => {
    let { x: a10 } = s10, i10 = r10, o10 = n10 || a10.dtype;
    if (i10.shouldExecuteOnCPU([a10]) && t != null) {
      let l10 = i10.tensorMap.get(a10.dataId), c10 = t(l10.values, o10);
      return i10.makeTensorInfo(a10.shape, o10, c10);
    }
    let u10 = new tc(a10.shape, e);
    return i10.runWebGPUProgram(u10, [a10], o10);
  };
}
function fn({ opSnippet: e, cpuKernelImpl: t, supportsComplex: n10 = false, dtype: s10 }) {
  return ({ inputs: r10, backend: a10 }) => {
    let { a: i10, b: o10 } = r10, u10 = a10;
    if (n10 && i10.dtype === "complex64") {
      let p10 = u10.tensorMap.get(i10.dataId), d10 = u10.tensorMap.get(o10.dataId), h10, f10;
      if (e !== 0)
        [h10, f10] = [[p10.complexTensorInfos.real, d10.complexTensorInfos.real], [p10.complexTensorInfos.imag, d10.complexTensorInfos.imag]].map((g10) => {
          let [b10, y10] = g10, v10 = { dataId: b10.dataId, dtype: b10.dtype, shape: i10.shape }, x10 = { dataId: y10.dataId, dtype: y10.dtype, shape: o10.shape }, k10 = $w(e, i10.shape, o10.shape);
          return u10.runWebGPUProgram(k10, [v10, x10], yn(b10.dtype, y10.dtype));
        });
      else {
        let g10 = new Tw(17, i10.shape, o10.shape), b10 = new Tw(18, i10.shape, o10.shape), y10 = [{ dataId: p10.complexTensorInfos.real.dataId, dtype: p10.complexTensorInfos.real.dtype, shape: i10.shape }, { dataId: p10.complexTensorInfos.imag.dataId, dtype: p10.complexTensorInfos.imag.dtype, shape: i10.shape }, { dataId: d10.complexTensorInfos.real.dataId, dtype: d10.complexTensorInfos.real.dtype, shape: o10.shape }, { dataId: d10.complexTensorInfos.imag.dataId, dtype: d10.complexTensorInfos.imag.dtype, shape: o10.shape }];
        h10 = u10.runWebGPUProgram(g10, y10, "float32"), f10 = u10.runWebGPUProgram(b10, y10, "float32");
      }
      let m10 = uu({ inputs: { real: h10, imag: f10 }, backend: u10 });
      return u10.disposeData(h10.dataId), u10.disposeData(f10.dataId), m10;
    }
    let l10 = s10 || yn(i10.dtype, o10.dtype);
    if ((i10.dtype === "string" || o10.dtype === "string" || u10.shouldExecuteOnCPU([i10, o10])) && t != null) {
      let p10 = u10.tensorMap.get(i10.dataId).values, d10 = u10.tensorMap.get(o10.dataId).values, h10 = i10.dtype === "string" ? N2.fromUint8ToStringArray(p10) : p10, f10 = i10.dtype === "string" ? N2.fromUint8ToStringArray(d10) : d10, [m10, g10] = t(i10.shape, o10.shape, h10, f10, l10);
      return u10.makeTensorInfo(g10, l10, m10);
    }
    let c10 = $w(e, i10.shape, o10.shape);
    return u10.runWebGPUProgram(c10, [i10, o10], l10);
  };
}
var { addImpl: bne, ceilImpl: yne, concatImpl: vne, equalImpl: xne, expImpl: wne, expm1Impl: kne, floorImpl: Ine, gatherNdImpl: Sne, gatherV2Impl: Cne, greaterEqualImpl: Nne, greaterImpl: Tne, lessEqualImpl: $ne, lessImpl: _ne, logImpl: Ane, maxImpl: Ene, maximumImpl: Rne, minimumImpl: Dne, multiplyImpl: Fne, negImpl: One, notEqualImpl: Pne, prodImpl: zne, rangeImpl: Mne, rsqrtImpl: Lne, simpleAbsImpl: Bne, sliceImpl: Vne, stridedSliceImpl: Wne, stringNGramsImpl: Une, subImpl: Gne, tileImpl: Hne, topKImpl: qne, transposeImpl: jne, uniqueImpl: kpe } = Yy;
var Kne = jt({ opType: 0, cpuKernelImpl: Bne });
var Xne = { kernelName: ao, backendName: "webgpu", kernelFunc: Kne };
var Yne = fn({ opSnippet: 1, cpuKernelImpl: bne, supportsComplex: true });
var Qne = { kernelName: kr, backendName: "webgpu", kernelFunc: Yne };
var Zne = class {
  constructor(e) {
    this.workPerThread = 4, this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e[0], this.variableNames = e.map((t, n10) => `T${n10}`), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "addN";
  }
  getUserCode() {
    let e = [];
    this.variableNames.forEach((s10) => {
      e.push(`let v${s10} = get${s10}ByOutputCoords(coords);`);
    });
    let t = this.variableNames.map((s10) => `v${s10}`).join(" + ");
    return `
      ${Ue()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `;
  }
};
function Jne(e) {
  let { inputs: t, backend: n10 } = e, s10 = t;
  if (s10.length === 1)
    return Zn({ inputs: { x: s10[0] }, backend: n10 });
  let r10 = s10.map((o10) => o10.dtype).reduce((o10, u10) => yn(o10, u10)), a10 = s10.map((o10) => o10.shape), i10 = new Zne(a10);
  return n10.runWebGPUProgram(i10, s10, r10);
}
var ese = { kernelName: xa, backendName: "webgpu", kernelFunc: Jne };
var h2 = class {
  constructor(e, t, n10) {
    this.workGroupSize = [64, 1, 1], this.variableNames = ["x"], this.uniforms = "axis : i32; infinityValue : f32;", this.size = true;
    let s10 = [t];
    N2.assertAxesAreInnerMostDims("arg" + n10.charAt(0).toUpperCase() + n10.slice(1), s10, e.length), this.op = n10 === "min" ? "<" : ">";
    let [r10] = N2.computeOutAndReduceShapes(e, s10);
    this.outputShape = r10.length === 0 ? [1] : r10, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, [1, 1, 1]), this.inputShape = e, this.shaderKey = `argMinMax${this.op}`;
  }
  getUserCode() {
    let e = `
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `, t = (r10, a10) => this.outputShape.length === 1 ? r10 : `${r10}[${a10}]`, n10 = (r10) => this.inputShape.length === 1 ? "uniforms.xShape" : `uniforms.xShape[${r10}]`;
    return `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${e}

      // In order to get a flattened index into the input tensor, we need to
      // add back the index along the reduced dimension to |outputCoords|.
      // This function outputs the offset to the first value along
      // |axis| and the stride to get the next value of the input along |axis|.
      fn getInputCoordInfo(outputIndex : i32) -> vec2<i32>{
        let outputCoords = getCoordsFromIndex(outputIndex);
        var i = ${this.outputShape.length - 1};

        var stride = 1;
        var inputStride = 1;
        var offset = 0;

        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {
          let length = ${n10(`${this.inputShape.length} - r`)};
          if (${this.inputShape.length} - r == uniforms.axis) {
            inputStride = stride;
          } else {
            offset = offset + ${t("outputCoords", "i")} * stride;
            i = i - 1;
          }
          stride = stride * length;
        }

        return vec2<i32>(offset, inputStride);
      }

      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{
        return coordInfo[0] + coordInfo[1] * index;
      }

      ${Ue()}
        let outputIndex = index / i32(workGroupSizeX);
        let coordInfo = getInputCoordInfo(outputIndex);
        let Length = ${n10("uniforms.axis")};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;

        for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = f32(x.numbers[getInputIndex(coordInfo, k)]);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(Length), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `;
  }
};
var tse = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.workGroupSize = [16, 16, 1];
    let n10 = new Array(e.length);
    for (let s10 = 0; s10 < n10.length; s10++)
      n10[s10] = e[t[s10]];
    this.outputShape = n10, this.dispatchLayout = { x: [0], y: [1] }, this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 1, 1]), this.shaderKey = "transposeShared";
  }
  getUserCode() {
    return `
      let TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0] + 1}>, ${this.workGroupSize[0]}>;
      ${wv()}
      fn main(@builtin(local_invocation_id) localId : vec3<u32>,
              @builtin(workgroup_id) workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] =
              A.numbers[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
  }
};
var nse = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.workPerThread = 4, this.workGroupSize = [64, 1, 1], this.size = true;
    let n10 = new Array(e.length);
    for (let s10 = 0; s10 < n10.length; s10++)
      n10[s10] = e[t[s10]];
    this.outputShape = n10, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.newDim = t, this.shaderKey = `transpose_${t}`;
  }
  getUserCode() {
    let e = Wt(this.outputShape.length), t = sse(this.newDim);
    return `
      ${Ue()}

        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A.numbers[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `;
  }
};
function sse(e) {
  let t = e.length;
  if (t > 4)
    throw Error(`Transpose for rank ${t} is not yet supported`);
  let n10 = new Array(t);
  for (let s10 = 0; s10 < e.length; s10++)
    n10[e[s10]] = `resRC[${s10}]`;
  return n10.join();
}
function vi(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { perm: a10 } = s10, i10 = n10, o10 = r10.shape.length, u10 = new Array(o10);
  for (let c10 = 0; c10 < u10.length; c10++)
    u10[c10] = r10.shape[a10[c10]];
  if (n10.shouldExecuteOnCPU([r10])) {
    let p10 = i10.tensorMap.get(r10.dataId).values, d10 = jne(p10, r10.shape, r10.dtype, a10, u10);
    return n10.makeTensorInfo(u10, r10.dtype, d10);
  }
  if (r10.shape.length === 2 && w2.arraysEqual(a10, [1, 0])) {
    let c10 = new tse(r10.shape, a10);
    return i10.runWebGPUProgram(c10, [r10], r10.dtype);
  }
  let l10 = new nse(r10.shape, a10);
  return i10.runWebGPUProgram(l10, [r10], r10.dtype);
}
var rse = { kernelName: ci, backendName: "webgpu", kernelFunc: vi };
function ase(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10, i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = vi({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), N2.assertAxesAreInnerMostDims("argMax", [i10[0]], u10.shape.length);
  let c10 = new h2(u10.shape, i10[0], "max"), p10 = [{ type: "int32", data: [i10[0]] }, { type: "float32", data: [Number.NEGATIVE_INFINITY] }], d10 = n10.runWebGPUProgram(c10, [u10], "int32", p10);
  return l10.forEach((h10) => n10.disposeData(h10.dataId)), d10;
}
var ise = { kernelName: wa, backendName: "webgpu", kernelFunc: ase };
function ose(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10 } = s10, i10 = w2.parseAxisParam(a10, r10.shape), o10 = N2.getAxesPermutation(i10, r10.shape.length), u10 = r10, l10 = [];
  o10 != null && (u10 = vi({ inputs: { x: r10 }, backend: n10, attrs: { perm: o10 } }), l10.push(u10), i10 = N2.getInnerMostAxes(i10.length, u10.shape.length)), N2.assertAxesAreInnerMostDims("argMin", [i10[0]], u10.shape.length);
  let c10 = new h2(u10.shape, i10[0], "min"), p10 = [{ type: "int32", data: [i10[0]] }, { type: "float32", data: [Number.POSITIVE_INFINITY] }], d10 = n10.runWebGPUProgram(c10, [u10], "int32", p10);
  return l10.forEach((h10) => n10.disposeData(h10.dataId)), d10;
}
var use = { kernelName: il, backendName: "webgpu", kernelFunc: ose };
var f2 = class {
  constructor(e, t) {
    this.variableNames = ["x"], this.uniforms = "stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;", this.workGroupSize = [128, 1, 1], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = `pool2D_${t}`, this.poolType = t;
  }
  getUserCode() {
    let e = "resultValue = max(value, resultValue);";
    this.poolType === "avg" && (e = "resultValue = resultValue + value; count = count + 1.0;");
    let t = "resultValue";
    return this.poolType === "avg" && (t = "resultValue / count"), `
      ${Ue()}
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputAtIndex(index, ${t});
        }
      }
    `;
  }
};
var m2 = class {
  constructor(e) {
    this.variableNames = ["x"], this.uniforms = "stride : vec2<i32>;", this.workGroupSize = [256, 1, 1], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "poolWithFilterSizeEqualsOne";
  }
  getUserCode() {
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
  }
};
function lse(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1, c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10);
  if (c10.filterWidth === 1 && c10.filterHeight === 1 && w2.arraysEqual(c10.inShape, c10.outShape))
    return Zn({ inputs: { x: r10 }, backend: n10 });
  let p10, d10 = [{ type: "int32", data: [c10.strideHeight, c10.strideWidth] }];
  return c10.filterHeight === 1 && c10.filterWidth === 1 ? p10 = new m2(c10) : (p10 = new f2(c10, "avg"), d10.push({ type: "int32", data: [c10.padInfo.top, c10.padInfo.left] }, { type: "int32", data: [c10.dilationHeight, c10.dilationWidth] }, { type: "int32", data: [c10.inHeight, c10.inWidth] }, { type: "int32", data: [c10.effectiveFilterHeight, c10.effectiveFilterWidth] })), n10.runWebGPUProgram(p10, [r10], r10.dtype, d10);
}
var cse = { kernelName: ka, backendName: "webgpu", kernelFunc: lse };
function dse(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10 } = t, { transposeA: i10, transposeB: o10 } = s10;
  return Nv({ a: r10, b: a10, transposeA: i10, transposeB: o10, backend: n10 });
}
var pse = { kernelName: Ia, backendName: "webgpu", kernelFunc: dse };
var hse = class {
  constructor(e, t) {
    this.variableNames = ["source"], this.workPerThread = 1, this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = t, this.rank = t.length, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.start = e, this.uniforms = `start : ${Wt(e.length)}; `, this.shaderKey = "slice";
  }
  getUserCode() {
    let e = Wt(this.rank), t = fse(this.rank), n10;
    return this.start.length === 1 ? n10 = this.outputShape.map((r10, a10) => "sourceLoc = uniforms.start + coords;") : n10 = this.outputShape.map((r10, a10) => `sourceLoc.${qm[a10]} = uniforms.start[${a10}] + coords.${qm[a10]};`), `
      ${Ue()}
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${n10.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `;
  }
};
var qm = ["x", "y", "z", "w", "u", "v"];
function fse(e) {
  if (e === 1)
    return "sourceLoc";
  if (e <= 6)
    return qm.slice(0, e).map((t) => `sourceLoc.${t}`).join(",");
  throw Error(`Slicing for rank ${e} is not yet supported`);
}
function lu(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, size: i10 } = s10, [o10, u10] = wt.parseSliceParams(r10, a10, i10);
  if (wt.assertParamsValid(r10, o10, u10), n10.shouldExecuteOnCPU([r10]) || r10.dtype === "string") {
    let p10 = n10.tensorMap.get(r10.dataId), d10 = Vne(p10.values, o10, u10, r10.shape, r10.dtype);
    return n10.makeTensorInfo(u10, r10.dtype, d10);
  }
  if (w2.sizeFromShape(u10) === 0)
    return n10.makeTensorInfo(u10, r10.dtype, []);
  let l10 = new hse(o10, u10), c10 = [{ type: "int32", data: o10 }];
  return n10.runWebGPUProgram(l10, [r10], r10.dtype, c10);
}
var mse = { kernelName: Oo, backendName: "webgpu", kernelFunc: lu };
var gse = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, crops: i10 } = s10;
  w2.assert(r10.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
  let o10 = a10.reduce((y10, v10) => y10 * v10), u10 = N2.getReshaped(r10.shape, a10, o10), l10 = N2.getPermuted(u10.length, a10.length), c10 = N2.getReshapedPermuted(r10.shape, a10, o10), p10 = N2.getSliceBeginCoords(i10, a10.length), d10 = N2.getSliceSize(c10, i10, a10.length), h10 = [], f10 = Me2({ inputs: { x: r10 }, backend: n10, attrs: { shape: u10 } }), m10 = vi({ inputs: { x: f10 }, backend: n10, attrs: { perm: l10 } }), g10 = Me2({ inputs: { x: m10 }, backend: n10, attrs: { shape: c10 } }), b10 = lu({ inputs: { x: g10 }, backend: n10, attrs: { begin: p10, size: d10 } });
  return h10.push(f10), h10.push(m10), h10.push(g10), h10.forEach((y10) => n10.disposeData(y10.dataId)), b10;
};
var bse = { kernelName: io, backendName: "webgpu", kernelFunc: gse };
var g2 = fn({ opSnippet: 10, dtype: "bool", cpuKernelImpl: Pne });
var yse = { kernelName: Io, backendName: "webgpu", kernelFunc: g2 };
function nc(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.tensorMap.get(s10.dataId);
  return Zn({ inputs: { x: r10.complexTensorInfos.real }, backend: n10 });
}
var vse = { kernelName: tp, backendName: "webgpu", kernelFunc: nc };
function xse(e, t) {
  let n10 = new tc(e.shape, 23), s10 = t.runWebGPUProgram(n10, [e], "int32");
  return { dataId: s10.dataId, shape: s10.shape, dtype: s10.dtype };
}
function jm(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dtype: a10 } = s10;
  if (a10 === "complex64") {
    if (r10.dtype === "complex64")
      return Zn({ inputs: { x: r10 }, backend: n10 });
    let i10 = $t(r10.shape), o10 = jm({ inputs: { x: r10 }, backend: n10, attrs: { dtype: "float32" } }), u10 = uu({ inputs: { real: o10, imag: i10 }, backend: n10 });
    return i10.dispose(), n10.disposeData(o10.dataId), u10;
  }
  if (r10.dtype === "complex64") {
    let i10 = nc({ inputs: { input: r10 }, backend: n10 }), o10 = jm({ inputs: { x: i10 }, backend: n10, attrs: { dtype: a10 } });
    return n10.disposeData(i10.dataId), o10;
  }
  if (!w2.hasEncodingLoss(r10.dtype, a10)) {
    let i10 = Zn({ inputs: { x: r10 }, backend: n10 });
    return { dataId: i10.dataId, shape: i10.shape, dtype: a10 };
  }
  if (a10 === "int32")
    return xse(r10, n10);
  if (a10 === "bool") {
    let i10 = n10.makeTensorInfo([], "bool", w2.getTypedArrayFromDType("bool", 1)), u10 = g2({ inputs: { a: r10, b: i10 }, backend: n10 });
    return n10.disposeData(i10.dataId), u10;
  }
  throw new Error(`Error in Cast: failed to cast ${r10.dtype} to ${a10}`);
}
var wse = { kernelName: Sa, backendName: "webgpu", kernelFunc: jm };
var kse = jt({ opType: 1, cpuKernelImpl: yne });
var Ise = { kernelName: Ca, backendName: "webgpu", kernelFunc: kse };
var Sse = class {
  constructor(e) {
    this.variableNames = ["A"], this.uniforms = "minVal : f32; maxVal : f32;", this.workPerThread = 4, this.workGroupSize = [64, 1, 1], this.isVec4 = true, this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "clipVec4";
  }
  getUserCode() {
    return `
      ${Ue()}
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
  }
};
var Cse = class {
  constructor(e) {
    this.variableNames = ["A"], this.uniforms = "minVal : f32; maxVal : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "clip";
  }
  getUserCode() {
    return `
      ${Ue()}
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
  }
};
function Nse(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { clipValueMin: a10, clipValueMax: i10 } = s10, o10, u10 = [{ type: "float32", data: [a10] }, { type: "float32", data: [i10] }];
  return w2.sizeFromShape(r10.shape) % 4 === 0 ? o10 = new Sse(r10.shape) : o10 = new Cse(r10.shape), n10.runWebGPUProgram(o10, [r10], r10.dtype, u10);
}
var Tse = { kernelName: Ir, backendName: "webgpu", kernelFunc: Nse };
var $se = class {
  constructor(e) {
    this.uniforms = "", this.workPerThread = 4, this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = N2.computeOutShape(e, 1), this.variableNames = e.map((t, n10) => `T${n10}`), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.offsetLength = e.length - 1;
    for (let t = 0; t < this.offsetLength; t++)
      this.uniforms += `offset${t} : i32;`;
    this.shaderKey = "concat";
  }
  getUserCode() {
    let e = [];
    if (this.offsetLength > 0) {
      e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
      for (let r10 = 1; r10 < this.offsetLength; r10++)
        e.push(`else if (yC < uniforms.offset${[r10]}){ setOutputAtCoords(coords.x, coords.y, getT${r10}(yR, yC - uniforms.offset${r10 - 1})); }`);
      let n10 = this.offsetLength, s10 = this.offsetLength - 1;
      e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n10}(yR, yC - uniforms.offset${s10})); }`);
    } else
      e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
    return `
      ${Ue()}
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `;
  }
};
function Qp(e) {
  let { inputs: t, backend: n10 } = e, { input: s10 } = t, r10 = n10.tensorMap.get(s10.dataId);
  return Zn({ inputs: { x: r10.complexTensorInfos.imag }, backend: n10 });
}
var _se = { kernelName: Qd, backendName: "webgpu", kernelFunc: Qp };
function Km(e, t, n10) {
  let s10 = e[0].dtype;
  if (s10 === "complex64") {
    let h10 = e.map((y10) => nc({ inputs: { input: y10 }, backend: n10 })), f10 = e.map((y10) => Qp({ inputs: { input: y10 }, backend: n10 })), m10 = Km(h10, t, n10), g10 = Km(f10, t, n10), b10 = uu({ inputs: { real: m10, imag: g10 }, backend: n10 });
    return h10.forEach((y10) => n10.disposeData(y10.dataId)), f10.forEach((y10) => n10.disposeData(y10.dataId)), n10.disposeData(m10.dataId), n10.disposeData(g10.dataId), b10;
  }
  let r10 = n10.shouldExecuteOnCPU(e);
  if (s10 === "string" && (r10 = true), r10) {
    let h10 = e.map((x10) => {
      let k10 = w2.sizeFromShape(x10.shape.slice(t));
      return Me2({ inputs: { x: x10 }, backend: n10, attrs: { shape: [-1, k10] } });
    }), f10 = h10.map((x10) => ({ vals: n10.readSync(x10.dataId), shape: x10.shape })), m10 = N2.computeOutShape(h10.map((x10) => x10.shape), 1), g10 = h10[0].shape[0] === 1, b10 = vne(f10, m10, s10, g10), y10 = N2.computeOutShape(e.map((x10) => x10.shape), t), v10 = n10.makeTensorInfo(y10, s10, b10);
    return h10.forEach((x10) => n10.disposeData(x10.dataId)), v10;
  }
  let { tensors2D: a10, outShape: i10 } = Ase(e, t, n10), o10 = a10.map((h10) => h10.shape), u10 = new $se(o10), l10 = [], c10 = new Array(o10.length - 1);
  if (c10.length > 0) {
    c10[0] = o10[0][1], l10.push({ type: "int32", data: [c10[0]] });
    for (let h10 = 1; h10 < c10.length; h10++)
      c10[h10] = c10[h10 - 1] + o10[h10][1], l10.push({ type: "int32", data: [c10[h10]] });
  }
  let p10 = n10.runWebGPUProgram(u10, a10, a10[0].dtype, l10);
  a10.forEach((h10) => n10.disposeData(h10.dataId));
  let d10 = Me2({ inputs: { x: p10 }, backend: n10, attrs: { shape: i10 } });
  return n10.disposeData(p10.dataId), d10;
}
function Ase(e, t, n10) {
  let s10 = N2.computeOutShape(e.map((a10) => a10.shape), t);
  return { tensors2D: e.map((a10) => Me2({ inputs: { x: a10 }, backend: n10, attrs: { shape: [w2.sizeFromShape(a10.shape.slice(0, t)), w2.sizeFromShape(a10.shape.slice(t))] } })), outShape: s10 };
}
function b2(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10, a10 = w2.parseAxisParam(r10, t[0].shape)[0], i10 = N2.computeOutShape(t.map((l10) => l10.shape), a10);
  if (w2.sizeFromShape(i10) === 0)
    return n10.makeTensorInfo(i10, t[0].dtype, []);
  let o10 = t.filter((l10) => w2.sizeFromShape(l10.shape) > 0);
  if (o10.length === 1)
    return Zn({ inputs: { x: o10[0] }, backend: n10 });
  let u10 = o10.map((l10) => l10.shape);
  return N2.assertParamsConsistent(u10, a10), Km(o10, a10, n10);
}
var Ese = { kernelName: oo, backendName: "webgpu", kernelFunc: b2 };
var Rse = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.uniforms = `pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;
      inChannels : i32;`, this.workPerThread = 4, this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]), this.isChannelsLast = t, this.shaderKey = `im2col_${this.isChannelsLast}`;
  }
  getUserCode() {
    let e = this.isChannelsLast ? 0 : 1, t = this.isChannelsLast ? 1 : 2;
    return `
    ${Ue()}

      for(var i = 0; i<${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;

        let rc = getCoordsFromIndex(flatIndex);

        if(flatIndex < uniforms.size) {
          let blockIndex = rc[0];
          let pos = rc[1];

          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];
          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;
          var value = 0.0;
          if(d0 < uniforms.aShape[${e}] && d0 >= 0) {
            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -
              uniforms.pad[0];
            let d1 = offsetX + uniforms.dilation[0] * ((pos %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
            let ch = pos % uniforms.inChannels;
            if(d1 < uniforms.aShape[${t}] && d1 >= 0) {
              value = getA(d0, d1, ch);
            }
          }
          setOutputAtIndex(flatIndex, value);
        }
      }
    }
  `;
  }
};
var Dse = class {
  constructor(e, t = false, n10 = null, s10 = false, r10 = false) {
    this.variableNames = ["x", "W"], this.uniforms = `filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      dimAOuter : i32; dimBOuter : i32; dimInner : i32;`, this.workGroupSize = [8, 8, 1], this.isVec4 = true, this.outputShape = e.outShape, w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.dispatchLayout = { x: [3], y: [1, 2], z: [0] }, this.outputShape[1] === 1 ? this.elementsPerThread = [4, 1, 1] : this.elementsPerThread = [4, 4, 1], this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread), this.convInfo = e, this.addBias = t, this.activation = n10, this.hasPreluActivationWeights = s10, this.hasLeakyreluAlpha = r10, this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), this.hasLeakyreluAlpha && this.variableNames.push("leakyreluAlpha"), this.tileAOuter = this.outputShape[1] === 1 ? 1 : this.workGroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workGroupSize[0] * this.elementsPerThread[0], this.tileInner = this.tileBOuter, [this.fitA, this.fitB] = this.getShapeFit(), this.shaderKey = `conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}_${this.elementsPerThread}`;
  }
  getShapeFit() {
    let e = [this.tileAOuter, this.tileInner], t = [this.tileInner, this.tileBOuter], n10 = this.outputShape[1] * this.outputShape[2], s10 = this.outputShape[3], r10 = this.convInfo.filterHeight * this.convInfo.filterWidth * this.convInfo.inChannels;
    return [Ks(e, [n10, r10]), Ks(t, [r10, s10])];
  }
  getSampleAWithRemainder(e) {
    return `let flatIndex${e} = getIndexFromCoords4D(coord, uniforms.xShape);
    let divBy4Remainder${e} = flatIndex${e} % 4;
    let divBy4Index${e} = flatIndex${e} / 4;
    let curData${e} = x.numbers[divBy4Index${e}];
    if (divBy4Remainder${e} == 0) {
      temp = curData${e};
    } else {
      // TODO: This could end up being a redundant load with another one in
      // the same shader invocation. Perhaps there's an opportunity for
      // optimization
      let nextData${e} = x.numbers[divBy4Index${e} + 1];
      if (divBy4Remainder${e} == 1) {
        temp = vec4<f32>(curData${e}.yzw, nextData${e}.x);
      } else if (divBy4Remainder${e} == 2) {
        temp = vec4<f32>(curData${e}.zw, nextData${e}.xy);
      } else if (divBy4Remainder${e} == 3) {
        temp = vec4<f32>(curData${e}.w, nextData${e}.xyz);
      }
    }
    `;
  }
  getUserCode() {
    let e = c2(this.elementsPerThread, this.tileAOuter, this.tileBOuter, this.tileInner), s10 = `let outRow = r / uniforms.outShape[2];
        let outCol = r % uniforms.outShape[2];
        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);
        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];
        let inChCoord = c % uniforms.xShape[3];
        var coord = vec4<i32>(
            batch,
            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
            inChCoord);
        var resData = vec4<f32>(0.0);
        ${this.convInfo.inChannels % 4 === 0 ? `// The bounds checking is always needed since we use it to pad zero for
          // the 'same' padding type.
          if (coordsInBounds4D(coord, uniforms.xShape)) {
            resData = x.numbers[getIndexFromCoords4D(coord, uniforms.xShape) / 4];
          } else {
            resData = vec4<f32>(0.0); }` : `var temp = vec4<f32>(0.0);
          ${this.getSampleAWithRemainder(1)}
          resData = temp;
          if (WCol == (uniforms.filterDims[1] - 1)) {
            coord = vec4<i32>(
              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);
              ${this.getSampleAWithRemainder(2)}
            if (inChCoord == 0) {
              resData = vec4<f32>(resData.xyz, temp.x);
            } else if (inChCoord == 1) {
              resData = vec4<f32>(resData.xy, temp.xy);
            } else {
              resData = vec4<f32>(resData.x, temp.xyz);
            }
          }
          `}
        return resData;`, r10 = this.fitA ? `${s10}` : `if (r < uniforms.dimAOuter && c < uniforms.dimInner) {
          ${s10}
         }
         return vec4<f32>(0.0);
        `, a10 = this.fitB ? "return W.numbers[row * uniforms.dimBOuter / 4 + col];" : `if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter / 4 + col];
         }
         return vec4<f32>(0.0);
        `, i10 = "", o10 = "";
    if (this.activation) {
      let c10 = Zs(this.activation, this.isVec4);
      if (this.hasPreluActivationWeights)
        i10 = `fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsByOutputCoords(outCoord);
          ${c10}
        }`;
      else {
        if (this.hasLeakyreluAlpha)
          throw i10 = `fn activation(outCoord: vec4<f32>) -> vec4<f32> {
          let b = getLeakyreluAlphaByOutputCoords(outCoord);
          ${c10}
        }`, new Error("Leakyrelu is not supported.");
        i10 = `
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          ${c10}
        }`;
      }
      o10 = "value = activation(value, outCoord);";
    }
    let u10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
        ${i10}
        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          let r = row;
          let c = col * 4;
          var batch = i32(globalId.z);
          ${r10}
        }

        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          ${a10}
        }

        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {
          var batch = i32(globalId.z);
          var value = valueInput;
          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)
          {
            let outCoord = vec4<i32>(
              batch,
              row / uniforms.outShape[2],
              row % uniforms.outShape[2],
              col * 4);
            ${u10}
            ${o10}
            setOutputAtCoords(outCoord[0], outCoord[1], outCoord[2], outCoord[3],
              value);
          }
        }
        ${e}
      `;
  }
};
var Fse = class {
  constructor(e, t = false, n10 = null, s10 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.outputShape = e.outShape, w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.dispatchLayout = { x: [3], y: [1, 2], z: [0] }, this.workGroupSize = kv(this.dispatchLayout, this.outputShape), this.elementsPerThread = Iv(this.dispatchLayout, this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread), t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n10, this.hasPreluActivationWeights = s10, [this.fitA, this.fitB] = this.getShapeFit(), this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`;
  }
  getShapeFit() {
    let e = this.workGroupSize[1] * this.elementsPerThread[1], t = this.workGroupSize[0] * this.elementsPerThread[0], n10 = e > t ? e : t;
    w2.assert(n10 % this.workGroupSize[0] === 0 && n10 % this.workGroupSize[1] === 0, () => "tileInner must be multiple of workgroupsize.x and workgroupsize.y");
    let s10 = [e, n10], r10 = [n10, t], a10 = this.outputShape[1] * this.outputShape[2], i10 = this.outputShape[3], o10 = this.convInfo.filterHeight * this.convInfo.filterWidth * this.convInfo.inChannels;
    return [Ks(s10, [a10, o10]), Ks(r10, [o10, i10])];
  }
  getUserCode() {
    let e = Cv(this.elementsPerThread, this.workGroupSize), t = `
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);
    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];
    let coord = vec4<i32>(
        batch,
        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
        col % uniforms.xShape[3]);
    // The bounds checking is always needed since we use it to pad zero for the
    // 'same' padding type.
    if(coordsInBounds4D(coord, uniforms.xShape)) {
      return x.numbers[getIndexFromCoords4D(coord, uniforms.xShape)];
    }
    return 0.0;`, n10 = this.fitA ? `${t}` : `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${t}
    }
    return 0.0;
    `, s10 = this.fitB ? "return W.numbers[row * uniforms.dimBOuter + col];" : `if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter + col];
	 }
	 return 0.0;
	 `, r10 = "", a10 = "";
    if (this.activation) {
      let u10 = Zs(this.activation, false);
      this.hasPreluActivationWeights ? r10 = `fn activation(a: f32, outCoord : vec4<i32>) -> f32 {
                  let b = getPreluActivationWeightsByOutputCoords(outCoord);
                  ${u10}
                }` : r10 = `
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
                    ${u10}
                  }
                `, a10 = "value = activation(value, outCoord);";
    }
    let i10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
    ${r10}
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${n10}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      ${s10}
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      ${i10}
      ${a10}
      result.numbers[getIndexFromCoords4D(outCoord, uniforms.outShape)] = value;
    }
    ${e}
  `;
  }
};
var Ose = class {
  constructor(e, t = false, n10 = null, s10 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;", this.workGroupSize = [128, 1, 1], this.outputShape = e.outShape, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n10, this.hasPreluActivationWeights = s10, this.shaderKey = `conv2DNaive_${this.activation}`;
  }
  getUserCode() {
    let e = "", t = "";
    if (this.activation) {
      let r10 = Zs(this.activation);
      this.hasPreluActivationWeights ? e = `fn activation(a : f32, outCoord : vec4<i32>) -> f32{
               let b = getPreluActivationWeightsByOutputCoords(outCoord);
               ${r10}
             }` : e = `
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{
                    ${r10}
                  }
                `, t = "value = activation(value, outCoord);";
    }
    let n10 = this.addBias ? "value = value + getBiasByOutputCoords(outCoord);" : "";
    return `
      ${e}
      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {
        let coord = vec4<i32>(batch, row, col, chan);
        if(coordsInBounds4D(coord, uniforms.xShape)) {
          return getX(batch, row, col, chan);
        }
        return 0.0;
      }

      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
        let coord = vec4<i32>(row, col, xChannel, outChannel);
        if(coordsInBounds4D(coord, uniforms.wShape)) {
          return getW(row, col, xChannel, outChannel);
        }
        return 0.0;
      }

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          ${n10}
          ${t}
          setOutputAtCoords(batch, row, col, chan, value);
        }
      }

      ${Rr()}
        let coords = getOutputCoords();
        let batch = coords[0];
        let outChannel = coords[3];

        var acc = 0.0;

        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {
              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
              let v = readInp(batch, coordRow, coordCol, xChannel);
              let f = readFilt(row, col, xChannel, outChannel);
              acc = acc + v * f;
            }
          }
        }

        writeResult(batch, coords[1], coords[2], outChannel, acc);
      }
    `;
  }
};
function Pse({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10 = null, preluActivationWeights: a10 = null, leakyreluAlpha: i10 = 0, activation: o10 = null }) {
  let u10 = e.shape, l10 = n10.dataFormat === "channelsLast", c10 = false, p10 = false, d10 = n10.filterHeight === n10.inHeight && n10.filterWidth === n10.inWidth && n10.padInfo.type === "VALID", h10, f10;
  if (d10) {
    let b10 = n10.inHeight * n10.inWidth * n10.inChannels;
    h10 = Me2({ inputs: { x: e }, backend: s10, attrs: { shape: [1, n10.batchSize, b10] } }), f10 = Me2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, b10, n10.outChannels] } });
  } else {
    let b10 = l10 ? u10[0] * u10[1] * u10[2] : u10[0] * u10[2] * u10[3];
    h10 = Me2({ inputs: { x: e }, backend: s10, attrs: { shape: [1, b10, n10.inChannels] } }), f10 = Me2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, n10.inChannels, n10.outChannels] } });
  }
  let m10 = Nv({ a: h10, b: f10, transposeA: c10, transposeB: p10, backend: s10, bias: r10, activation: o10, preluActivationWeights: a10, leakyreluAlpha: i10 }), g10 = Me2({ inputs: { x: m10 }, backend: s10, attrs: { shape: n10.outShape } });
  return s10.disposeData(h10.dataId), s10.disposeData(f10.dataId), s10.disposeData(m10.dataId), g10;
}
function zse({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10 = null, preluActivationWeights: a10 = null, leakyreluAlpha: i10 = 0, activation: o10 = null }) {
  let { filterWidth: u10, filterHeight: l10, inChannels: c10, strideWidth: p10, strideHeight: d10, padInfo: h10, outWidth: f10, outHeight: m10, dilationWidth: g10, dilationHeight: b10, dataFormat: y10 } = n10, v10 = y10 === "channelsLast", x10 = u10 * l10 * c10, k10 = m10 * f10, C10 = [k10, x10], T10 = false, E10 = false, A10 = [], P10 = Me2({ inputs: { x: e }, backend: s10, attrs: { shape: e.shape.slice(1) } }), R10 = Me2({ inputs: { x: t }, backend: s10, attrs: { shape: [1, x10, -1] } });
  A10.push(P10), A10.push(R10);
  let F10 = new Rse(C10, v10), $10 = [{ type: "int32", data: [h10.left, h10.top] }, { type: "int32", data: [p10, d10] }, { type: "int32", data: [g10, b10] }, { type: "int32", data: [f10] }, { type: "int32", data: [c10 * u10] }, { type: "int32", data: [c10] }], z10 = s10.runWebGPUProgram(F10, [P10], P10.dtype, $10), W10 = Me2({ inputs: { x: z10 }, backend: s10, attrs: { shape: [1, C10[0], C10[1]] } });
  A10.push(z10), A10.push(W10);
  let q10 = [1, C10[0], C10[1]], K10 = new d2(q10, [1, k10, n10.outChannels], X2().get("WEBGPU_MATMUL_WORK_PER_THREAD"), T10, E10, r10, o10, a10), Y10 = q10[1], Z10 = q10[2], te2 = n10.outChannels, ee2 = [{ type: "int32", data: [Y10] }, { type: "int32", data: [te2] }, { type: "int32", data: [Z10] }], se2 = [W10, R10];
  r10 && se2.push(r10), a10 && se2.push(a10);
  let ne2 = s10.runWebGPUProgram(K10, se2, W10.dtype, ee2), oe2 = v10 ? [1, m10, f10, n10.outChannels] : [1, n10.outChannels, m10, f10], re2 = Me2({ inputs: { x: ne2 }, backend: s10, attrs: { shape: oe2 } });
  A10.push(ne2);
  for (let le2 of A10)
    s10.disposeData(le2.dataId);
  return re2;
}
function y2({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10 = null, preluActivationWeights: a10 = null, leakyreluAlpha: i10 = 0, activation: o10 = null }) {
  let u10 = r10 != null, l10 = a10 != null, c10;
  if (n10.filterHeight === n10.inHeight && n10.filterWidth === n10.inWidth && n10.padInfo.type === "VALID" || n10.filterHeight === 1 && n10.filterWidth === 1 && n10.dilationHeight === 1 && n10.dilationWidth === 1 && n10.strideHeight === 1 && n10.strideWidth === 1 && (n10.padInfo.type === "SAME" || n10.padInfo.type === "VALID"))
    return Pse({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10, activation: o10, preluActivationWeights: a10, leakyreluAlpha: i10 });
  if (X2().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") && e.shape[0] === 1)
    return zse({ x: e, filter: t, convInfo: n10, backend: s10, bias: r10, preluActivationWeights: a10, leakyreluAlpha: i10, activation: o10 });
  let d10 = X2().getBool("WEBGPU_USE_NAIVE_CONV2D"), h10 = (n10.inChannels % 4 === 0 || n10.inChannels === 3 && n10.padInfo.type === "VALID") && n10.outChannels % 4 === 0 && n10.outChannels >= 32, f10 = [n10.padInfo.top, n10.padInfo.left], m10 = [{ type: "int32", data: [n10.filterHeight, n10.filterWidth] }, { type: "int32", data: [...f10] }, { type: "int32", data: [n10.strideHeight, n10.strideWidth] }, { type: "int32", data: [n10.dilationHeight, n10.dilationWidth] }];
  if (d10)
    c10 = new Ose(n10, u10, o10, l10);
  else {
    h10 ? c10 = new Dse(n10, u10, o10, l10) : c10 = new Fse(n10, u10, o10, l10);
    let b10 = n10.outShape[1] * n10.outShape[2], y10 = n10.outShape[3], v10 = n10.filterHeight * n10.filterWidth * n10.inShape[3];
    m10.push({ type: "int32", data: [b10] }, { type: "int32", data: [y10] }, { type: "int32", data: [v10] });
  }
  let g10 = [e, t];
  return u10 && g10.push(r10), l10 && g10.push(a10), s10.runWebGPUProgram(c10, g10, e.dtype, m10);
}
function Mse(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dataFormat: u10, dilations: l10, dimRoundingMode: c10 } = n10, p10 = N2.convertConv2DDataFormat(u10), d10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, l10, o10, c10, false, p10);
  return y2({ x: r10, filter: a10, convInfo: d10, backend: s10 });
}
var Lse = { kernelName: Na, backendName: "webgpu", kernelFunc: Mse };
var Bse = class {
  constructor(e) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;", this.outputShape = e.inShape, w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.dispatchLayout = { x: [3], y: [1, 2], z: [0] }, this.workGroupSize = kv(this.dispatchLayout, this.outputShape), this.elementsPerThread = Iv(this.dispatchLayout, this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread), this.shaderKey = `conv2DDerInputMM_${this.elementsPerThread}`;
  }
  getUserCode() {
    return `
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
      return 0.0;
    }
    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
      return 0.0;
    }
    let coord = vec4<i32>(
        batch,
        i32(xR),
        i32(xC),
        col % uniforms.outBackprop[3]);
    return x.numbers[getIndexFromCoords4D(coord, uniforms.xShape)];
    }
    return 0.0;
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      let coordX = uniforms.filterDims.x - 1 -
          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let coordY = uniforms.filterDims.y - 1 -
          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
          coordX >= 0 && coordY >= 0) {
        let coord = vec4<i32>(coordX, coordY, col,
            row % uniforms.outBackprop[3]);
        return W.numbers[getIndexFromCoords4D(coord, uniforms.wShape)];
      }
      return 0.0;
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result.numbers[getIndexFromCoords4D(outCoord, uniforms.outShape)] = value;
    }

    ${Cv(this.elementsPerThread, this.workGroupSize)}
  `;
  }
};
var Vse = class {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.uniforms = "filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.isChannelsLast = e.dataFormat === "channelsLast", this.shaderKey = `conv2DDerInput_${this.isChannelsLast}`;
  }
  getUserCode() {
    let e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, n10 = this.isChannelsLast ? 3 : 1;
    return `
    ${Ue()} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n10}];

        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
};
function Wse(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = t, { inputShape: i10, strides: o10, pad: u10, dataFormat: l10, dimRoundingMode: c10 } = s10, p10 = N2.convertConv2DDataFormat(l10), d10 = N2.computeConv2DInfo(i10, a10.shape, o10, 1, u10, c10, false, p10), h10 = [{ type: "int32", data: [d10.filterHeight, d10.filterWidth] }, { type: "int32", data: [d10.filterHeight - 1 - d10.padInfo.top, d10.filterWidth - 1 - d10.padInfo.left] }, { type: "int32", data: [d10.strideHeight, d10.strideWidth] }, { type: "int32", data: [d10.batchSize, d10.outHeight, d10.outWidth, d10.outChannels] }], f10;
  if (X2().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))
    f10 = new Vse(d10);
  else {
    f10 = new Bse(d10);
    let m10 = d10.inShape[1] * d10.inShape[2], g10 = d10.inShape[3], b10 = d10.filterHeight * d10.filterWidth * d10.outChannels;
    h10.push({ type: "uint32", data: [m10] }, { type: "uint32", data: [g10] }, { type: "uint32", data: [b10] });
  }
  return n10.runWebGPUProgram(f10, [r10, a10], "float32", h10);
}
var Use = { kernelName: Ta, backendName: "webgpu", kernelFunc: Wse };
var Gse = jt({ opType: 2 });
var Hse = { kernelName: $a, backendName: "webgpu", kernelFunc: Gse };
var qse = jt({ opType: 3 });
var jse = { kernelName: _a, backendName: "webgpu", kernelFunc: qse };
var Kse = class {
  constructor(e, t, n10, s10) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.uniforms = "extrapolationValue : f32;", this.workGroupSize = [64, 1, 1], this.size = true;
    let [r10] = t;
    this.outputShape = [r10, n10[0], n10[1], e], this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.methodId = s10 === "bilinear" ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
  }
  getUserCode() {
    let [e, t] = ["f32(uniforms.imageShape[1] - 1)", "f32(uniforms.imageShape[2] - 1)"], [n10, s10, r10] = this.cropHeightBiggerThan1 ? [`(${e} / f32(uniforms.outShape[1] - 1))`, "(y2-y1) * height_ratio", `y1*${e} + f32(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${e}`], [a10, i10, o10] = this.cropWidthBiggerThan1 ? [`(${t} / f32(uniforms.outShape[2] - 1))`, "(x2-x1) * width_ratio", `x1*${t} + f32(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${t}`];
    return `
      ${Ue()}
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n10});
        let width_ratio = f32(${a10});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s10};
        let width_scale = ${i10};
        let in_y = ${r10};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${o10};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
  }
};
var Xse = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10, boxes: a10, boxInd: i10 } = t, { cropSize: o10, method: u10, extrapolationValue: l10 } = s10, c10 = new Kse(r10.shape[3], a10.shape, o10, u10), p10 = [{ type: "float32", data: [l10] }];
  return n10.runWebGPUProgram(c10, [r10, a10, i10], "float32", p10);
};
var Yse = { kernelName: lo, backendName: "webgpu", kernelFunc: Xse };
var Qse = class {
  constructor(e, t) {
    this.variableNames = ["x"], this.workGroupSize = [64, 1, 1], this.size = true, this.uniforms = "blockSize : i32;", this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = `depthToSpace_${t}`, this.dataFormat = t;
  }
  getUserCode() {
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
  }
  getHeightCoordString() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return this.dataFormat === "NHWC" ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
  }
  getInputSamplingString() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
};
function Zse(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockSize: a10, dataFormat: i10 } = s10, o10 = r10.shape[0], u10 = i10 === "NHWC" ? r10.shape[1] : r10.shape[2], l10 = i10 === "NHWC" ? r10.shape[2] : r10.shape[3], c10 = i10 === "NHWC" ? r10.shape[3] : r10.shape[1], p10 = u10 * a10, d10 = l10 * a10, h10 = c10 / (a10 * a10), f10 = i10 === "NHWC" ? [o10, p10, d10, h10] : [o10, h10, p10, d10], m10 = [{ type: "int32", data: [a10] }], g10 = new Qse(f10, i10);
  return n10.runWebGPUProgram(g10, [r10], r10.dtype, m10);
}
var Jse = { kernelName: co, backendName: "webgpu", kernelFunc: Zse };
var v2 = class {
  constructor(e, t = false, n10 = null, s10 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;", this.workGroupSize = [4, 4, 4], this.isVec4 = true, this.outputShape = e.outShape, this.dispatchLayout = { x: [0, 1], y: [2], z: [3] }, this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 4, 4]), w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n10, this.hasPreluActivation = s10, this.shaderKey = `depthwise3x3_${n10}`;
  }
  getUserCode() {
    let e = "", t = "";
    if (this.activation) {
      let r10 = Zs(this.activation, this.isVec4);
      this.hasPreluActivation ? e = `fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsByOutputCoords(outCoord);
          ${r10}
        }` : e = `
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
            ${r10}
          }
        `, t = "dotProd[i] = activation(dotProd[i], coords);";
    }
    let n10 = this.addBias ? "dotProd[i] = dotProd[i] + getBiasByOutputCoords(coords);" : "";
    return `
      ${e}

      ${wv()}
      fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = 0;
        let r = i32(globalId.x);
        let c = i32(globalId.y) * 4;
        let d2 = i32(globalId.z) * 4;
        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;
        let d1 = d2;
        let q = 0;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;

        var wVals : array<vec4<f32>, 9>;
        wVals[0] = getW(0, 0, d1, q);
        wVals[1] = getW(0, 1, d1, q);
        wVals[2] = getW(0, 2, d1, q);
        wVals[3] = getW(1, 0, d1, q);
        wVals[4] = getW(1, 1, d1, q);
        wVals[5] = getW(1, 2, d1, q);
        wVals[6] = getW(2, 0, d1, q);
        wVals[7] = getW(2, 1, d1, q);
        wVals[8] = getW(2, 2, d1, q);

        var xVals : array<array<vec4<f32>, 6>, 3>;
        for (var wR = 0; wR < 3; wR = wR + 1) {
          let xR = xRCorner + wR * uniforms.dilation[0];
          for (var wC = 0; wC < 6; wC = wC + 1) {
            let xC = xCCorner + wC * uniforms.dilation[1];
            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {
              xVals[wR][wC] = vec4<f32>(0.0);
            } else {
              xVals[wR][wC] = getX(batch, xR, xC, d1);
            }
          }
        }

        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        for (var wR = 0; wR < 3; wR = wR + 1) {
          for (var wC = 0; wC < 3; wC = wC + 1) {
            let indexW = wR * 3 + wC;
            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];
            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];
            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];
            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d2);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            ${n10}
            ${t}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
          }
        }
      }
    `;
  }
};
var x2 = class {
  constructor(e, t = false, n10 = null, s10 = false) {
    this.variableNames = ["x", "W"], this.uniforms = `pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      inDims : vec2<i32>; filterHeight : i32; filterWidth : i32;
      channelMul : i32;`, this.workGroupSize = [256, 1, 1], this.outputShape = e.outShape, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), w2.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t && this.variableNames.push("bias"), s10 && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n10, this.hasPreluActivation = s10, this.shaderKey = `depthwise_${this.activation}`;
  }
  getUserCode() {
    let e = "", t = "";
    if (this.activation) {
      let r10 = Zs(this.activation, false);
      this.hasPreluActivation ? e = `fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
          let b = getPreluActivationWeightsByOutputCoords(outCoord);
          ${r10}
        }` : e = `
          fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
            ${r10}
          }
        `, t = "dotProd = activation(dotProd, coords);";
    }
    let n10 = this.addBias ? "dotProd = dotProd + getBiasByOutputCoords(coords);" : "";
    return `
      ${e}

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32,
          value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          setOutputAtCoords(batch, row, col, chan, value);
        }
      }

      ${Rr()}
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
        let d2 = coords[3];
        let d1 = d2 / uniforms.channelMul;
        let q = d2 - d1 * uniforms.channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            // Here using a constant value |this.convInfo.filterHeight| instead
            // of uniform value is in order to loop unrolling.
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          }

        ${n10}
        ${t}
        writeResult(batch, coords[1], coords[2], d2, dotProd);
      }
    `;
  }
};
function ere(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10 } = t, { strides: i10, pad: o10, dilations: u10, dimRoundingMode: l10 } = s10, c10 = u10;
  c10 == null && (c10 = [1, 1]);
  let p10 = N2.computeConv2DInfo(r10.shape, a10.shape, i10, c10, o10, l10, true), d10 = [{ type: "int32", data: [p10.padInfo.top, p10.padInfo.left] }, { type: "int32", data: [p10.strideHeight, p10.strideWidth] }, { type: "int32", data: [p10.dilationHeight, p10.dilationWidth] }, { type: "int32", data: [p10.inHeight, p10.inWidth] }], h10;
  return p10.batchSize === 1 && p10.inHeight === p10.outHeight && p10.inWidth === p10.outWidth && p10.strideHeight === 1 && p10.strideWidth === 1 && p10.filterHeight === p10.filterWidth && p10.inChannels === p10.outChannels && p10.filterHeight === 3 && p10.inChannels % 4 === 0 ? h10 = new v2(p10) : (h10 = new x2(p10), d10.push({ type: "int32", data: [p10.filterHeight] }, { type: "int32", data: [p10.filterWidth] }, { type: "int32", data: [p10.outChannels / p10.inChannels] })), n10.runWebGPUProgram(h10, [r10, a10], r10.dtype, d10);
}
var tre = { kernelName: Aa, backendName: "webgpu", kernelFunc: ere };
var w22 = fn({ opSnippet: 0, cpuKernelImpl: Fne, supportsComplex: true });
var nre = { kernelName: Ka, backendName: "webgpu", kernelFunc: w22 };
var sre = class {
  constructor(e, t) {
    this.workGroupSize = [64, 1, 1], this.variableNames = ["x"], this.uniforms = "reduceSize : i32;", this.size = true, this.inputShape = [e.batchSize, e.inSize];
    let [n10] = N2.computeOutAndReduceShapes(this.inputShape, [1]);
    this.outputShape = n10.length === 0 ? [1] : n10, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, [1, 1, 1]), this.reduceType = t, this.shaderKey = `reduce_${t}`;
  }
  getUserCode() {
    let e = "", t = "0.0";
    this.reduceType === "min" || this.reduceType === "max" ? (e = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t = "f32(x.numbers[offset])") : this.reduceType === "sum" || this.reduceType === "mean" ? e = " bestValue = bestValue + candidate; " : this.reduceType === "prod" && (e = " bestValue = bestValue * candidate; ", t = "1.0");
    let n10 = this.reduceType === "mean" ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
    return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ue()}
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x.numbers[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n10}
        }
       }
     `;
  }
};
function sc(e, t, n10, s10, r10) {
  let a10 = e.shape.length, i10 = [], o10 = w2.parseAxisParam(t, e.shape), u10 = o10, l10 = N2.getAxesPermutation(u10, a10), c10 = e;
  l10 != null && (c10 = vi({ inputs: { x: e }, attrs: { perm: l10 }, backend: r10 }), u10 = N2.getInnerMostAxes(u10.length, a10), i10.push(c10)), N2.assertAxesAreInnerMostDims(s10, u10, a10);
  let [p10, d10] = N2.computeOutAndReduceShapes(c10.shape, u10), h10 = p10;
  n10 && (h10 = N2.expandShapeToKeepDim(p10, o10));
  let f10;
  if ((s10 === "max" || s10 === "prod") && r10.shouldExecuteOnCPU([c10])) {
    let m10 = r10.tensorMap.get(c10.dataId).values;
    switch (s10) {
      case "max":
        let g10 = Ene(m10, w2.sizeFromShape(d10), h10, e.dtype);
        f10 = r10.makeTensorInfo(h10, e.dtype, g10);
        break;
      case "prod":
        let { outVals: b10, outShape: y10, outDtype: v10 } = zne(c10.shape, c10.dtype, m10, u10);
        f10 = r10.makeTensorInfo(y10, v10, b10);
        break;
      default:
        throw new Error(`${s10} CPU implementation is not yet supported.`);
    }
  } else {
    let m10 = w2.sizeFromShape(d10), b10 = w2.sizeFromShape(c10.shape) / m10, y10 = { windowSize: m10, inSize: m10, batchSize: b10, outSize: 1 }, v10 = s10 === "mean" ? "float32" : lp(e.dtype), x10 = [{ type: "int32", data: [m10] }], k10 = new sre(y10, s10), C10 = r10.runWebGPUProgram(k10, [c10], v10, x10);
    i10.push(C10), f10 = Me2({ inputs: { x: C10 }, attrs: { shape: h10 }, backend: r10 });
  }
  return i10.forEach((m10) => r10.disposeData(m10.dataId)), f10;
}
function Tv(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  return sc(r10, a10, i10, "sum", n10);
}
var rre = { kernelName: ai, backendName: "webgpu", kernelFunc: Tv };
function are(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { equation: r10 } = s10, a10 = t, { allDims: i10, summedDims: o10, idDims: u10 } = N2.decodeEinsumEquation(r10, a10.length);
  N2.checkEinsumDimSizes(i10.length, u10, a10);
  let { path: l10, steps: c10 } = N2.getEinsumComputePath(o10, u10), p10 = c10.length, d10 = null, h10 = i10.length, f10 = [];
  for (let m10 = 0; m10 < p10; ++m10) {
    for (let g10 of c10[m10]) {
      let { permutationIndices: b10, expandDims: y10 } = N2.getEinsumPermutation(h10, u10[g10]), v10;
      N2.isIdentityPermutation(b10) ? v10 = a10[g10] : (v10 = vi({ inputs: { x: a10[g10] }, backend: n10, attrs: { perm: b10 } }), f10.push(v10));
      let x10 = v10.shape.slice();
      for (let k10 = 0; k10 < y10.length; ++k10)
        x10.splice(y10[k10], 0, 1);
      w2.arraysEqual(v10.shape, x10) || (v10 = Me2({ inputs: { x: v10 }, backend: n10, attrs: { shape: x10 } }), f10.push(v10)), d10 === null ? d10 = v10 : (d10 = w22({ inputs: { a: v10, b: d10 }, backend: n10 }), f10.push(d10));
    }
    m10 < p10 - 1 && (l10[m10] >= 0 && (d10 = Tv({ inputs: { x: d10 }, backend: n10, attrs: { axis: l10[m10] - (i10.length - h10), keepDims: false } }), f10.push(d10)), h10--);
  }
  for (let m10 of f10)
    m10 !== d10 && n10.disposeData(m10.dataId);
  return d10;
}
var ire = { kernelName: Yd, backendName: "webgpu", kernelFunc: are };
var ore = jt({ opType: 4 });
var ure = { kernelName: Ra, backendName: "webgpu", kernelFunc: ore };
var lre = fn({ opSnippet: 4, dtype: "bool", cpuKernelImpl: xne });
var cre = { kernelName: po, backendName: "webgpu", kernelFunc: lre };
var k2 = jt({ opType: 5, cpuKernelImpl: wne, dtype: "float32" });
var dre = { kernelName: Da, backendName: "webgpu", kernelFunc: k2 };
function Xm(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { dim: r10 } = n10, { input: a10 } = t, i10 = a10.shape.length, o10 = a10.shape.slice(), u10 = r10;
  return r10 < 0 && (w2.assert(-(i10 + 1) <= r10, () => `Axis must be in the interval [${-(i10 + 1)}, ${i10}]`), u10 = i10 + r10 + 1), o10.splice(u10, 0, 1), Me2({ inputs: { x: a10 }, backend: s10, attrs: { shape: o10 } });
}
var pre = { kernelName: ho, backendName: "webgpu", kernelFunc: Xm };
var hre = jt({ opType: 6, cpuKernelImpl: kne });
var fre = { kernelName: fo, backendName: "webgpu", kernelFunc: hre };
var mre = class {
  constructor(e) {
    this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "fill";
  }
  getUserCode() {
    return `
    ${Ue()}
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
  }
};
function cu(e) {
  let { backend: t, attrs: n10 } = e, { shape: s10, value: r10 } = n10, { dtype: a10 } = n10;
  if (a10 = a10 || w2.inferDtype(r10), a10 === "string") {
    let i10 = w2.getArrayFromDType(a10, w2.sizeFromShape(s10));
    return i10.fill(r10), t.makeTensorInfo(s10, a10, i10);
  } else {
    let i10 = new mre(s10), o10 = [{ type: "float32", data: [r10] }];
    return t.runWebGPUProgram(i10, [], a10, o10);
  }
}
var gre = { kernelName: hl, backendName: "webgpu", kernelFunc: cu };
var bre = class {
  constructor(e) {
    this.outputShape = [], this.variableNames = ["x"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "flipLeftRight";
  }
  getUserCode() {
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
  }
};
var yre = { kernelName: mo, backendName: "webgpu", kernelFunc: ({ inputs: e, backend: t }) => {
  let { image: n10 } = e, s10 = t, r10 = new bre(n10.shape);
  return s10.runWebGPUProgram(r10, [n10], n10.dtype);
} };
var vre = jt({ opType: 7, cpuKernelImpl: Ine });
var xre = { kernelName: Fa, backendName: "webgpu", kernelFunc: vre };
var wre = fn({ opSnippet: 12, dtype: "int32" });
var kre = { kernelName: Oa, backendName: "webgpu", kernelFunc: wre };
var Ire = (e, t, n10, s10, r10) => {
  let a10 = [s10, ...n10];
  return r10 && a10.push(r10), e.createBindGroup({ layout: t, entries: a10.map((i10, o10) => ({ binding: o10, resource: i10 })) });
};
var I22 = (e, t, n10, s10, r10, a10 = false) => {
  let i10 = { dtype: r10.dtype, shape: r10.shape }, o10 = Yee(s10, i10, t, a10), u10 = e.createShaderModule({ code: o10, label: t.constructor.name });
  return e.createComputePipeline({ layout: n10, compute: { module: u10, entryPoint: "main" }, label: t.constructor.name });
};
function S2(e, t, n10, s10 = "", r10 = "") {
  return e.shaderKey + "_" + (e.workGroupSize ? e.workGroupSize.join(",") : "") + t.map((i10) => i10.length).join(",") + n10.join(",") + e.variableNames.join(",") + s10 + r10;
}
function _w(e) {
  let { externalImage: t, backend: n10, attrs: s10, outShape: r10, useImport: a10 } = e, { numChannels: i10 } = s10, o10 = w2.sizeFromShape(r10), u10 = w2.computeStrides(r10), l10 = n10.makeTensorInfo(r10, "int32"), c10 = n10.getFromPixelsProgram(a10 ? "import" : "copyExternal");
  c10.updateOutputShape(r10);
  let p10 = [l10.shape], d10 = [l10.dtype, a10 ? "import" : "copyExternal"], h10 = S2(c10, p10, d10), f10 = c10.getLayout(n10.device), m10 = n10.getAndSavePipeline(h10, () => I22(n10.device, c10, f10.pipelineLayout, [], l10, true));
  c10.setPipeline(m10), a10 || n10.queue.copyExternalImageToTexture({ source: t, origin: { x: 0, y: 0 } }, { texture: c10.makeInputTexture(n10.device, r10[1], r10[0]) }, [r10[1], r10[0]]);
  let g10 = n10.tensorMap.get(l10.dataId);
  g10.bufferInfo.buffer = n10.acquireBuffer(g10.bufferInfo.byteSize);
  let b10 = [o10, i10, ...u10, ...c10.dispatch];
  c10.setUniform(n10.device, b10);
  let y10;
  if (a10) {
    let v10 = { source: t };
    y10 = n10.device.importExternalTexture(v10);
  } else
    y10 = c10.inputTexture.createView();
  return n10.runFromPixelsProgram(c10, g10.bufferInfo.buffer, f10, y10, l10.dataId), l10;
}
var Sre = { kernelName: hd, backendName: "webgpu", kernelFunc: Cre };
var Mi;
function Cre(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { pixels: r10 } = t, { numChannels: a10 } = s10;
  if (r10 == null)
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let i10 = typeof HTMLVideoElement != "undefined" && r10 instanceof HTMLVideoElement, o10 = typeof HTMLImageElement != "undefined" && r10 instanceof HTMLImageElement, u10 = typeof HTMLCanvasElement != "undefined" && r10 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && r10 instanceof OffscreenCanvas, l10 = typeof ImageBitmap != "undefined" && r10 instanceof ImageBitmap, [c10, p10] = i10 ? [r10.videoWidth, r10.videoHeight] : [r10.width, r10.height], d10 = [p10, c10, a10];
  if (X2().getBool("WEBGPU_USE_IMPORT") && i10)
    return _w({ externalImage: r10, backend: n10, attrs: s10, outShape: d10, useImport: true });
  if ((i10 || o10) && (Mi == null && (Mi = document.createElement("canvas").getContext("2d")), Mi.canvas.width = c10, Mi.canvas.height = p10, Mi.drawImage(r10, 0, 0, c10, p10), r10 = Mi.canvas), l10 || u10 || i10 || o10)
    return _w({ externalImage: r10, backend: n10, attrs: s10, outShape: d10, useImport: false });
  let h10 = r10.data, f10 = h10;
  if (a10 != null && a10 !== 4) {
    f10 = new Uint8Array(r10.width * r10.height * a10);
    let b10 = h10.length, y10 = 0;
    for (let v10 = 0; v10 < b10; v10++)
      v10 % 4 < a10 && (f10[y10++] = h10[v10]);
  }
  let m10 = n10.makeTensorInfo(d10, "int32"), g10 = n10.tensorMap.get(m10.dataId);
  return g10.values = new Int32Array(f10), n10.maybeReleaseBuffer(m10.dataId), n10.uploadToGPU(m10.dataId), m10;
}
var Nre = class {
  constructor(e, t, n10, s10, r10) {
    this.uniforms = "varianceEpsilon : f32;", this.workGroupSize = [128, 1, 1], this.size = true, this.variableNames = ["x", "mean", "variance"], N2.assertAndGetBroadcastShape(e, t), N2.assertAndGetBroadcastShape(e, n10), this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), s10 != null && (N2.assertAndGetBroadcastShape(e, s10), this.variableNames.push("offset")), r10 != null && (N2.assertAndGetBroadcastShape(e, r10), this.variableNames.push("scale")), this.offsetShape = s10, this.scaleShape = r10, this.shaderKey = "batchNorm";
  }
  getUserCode() {
    let e = "0.0";
    this.offsetShape != null && (e = "getOffsetByOutputIndex(index)");
    let t = "1.0";
    return this.scaleShape != null && (t = "getScaleByOutputIndex(index)"), `
      ${Ue()}
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
  }
};
var Tre = { kernelName: Pa, backendName: "webgpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { x: s10, scale: r10, offset: a10, mean: i10, variance: o10 } = e, { varianceEpsilon: u10 } = t, l10 = n10, c10 = [s10, i10, o10], p10 = null;
  a10 != null && (p10 = a10.shape, c10.push(a10));
  let d10 = null;
  r10 != null && (d10 = r10.shape, c10.push(r10));
  let h10 = new Nre(s10.shape, i10.shape, o10.shape, p10, d10), f10 = [{ type: "float32", data: [u10] }];
  return l10.runWebGPUProgram(h10, c10, s10.dtype, f10);
} };
function $re(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dataFormat: c10, dilations: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = s10, m10 = N2.convertConv2DDataFormat(c10), g10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, p10, l10, d10, false, m10);
  return y2({ x: r10, filter: a10, convInfo: g10, backend: n10, bias: i10, preluActivationWeights: o10, leakyreluAlpha: f10, activation: h10 });
}
var _re = { kernelName: sa, backendName: "webgpu", kernelFunc: $re };
function Are(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dilations: c10, dimRoundingMode: p10, activation: d10 } = s10, h10 = c10;
  h10 == null && (h10 = [1, 1]), w2.assert(N2.eitherStridesOrDilationsAreOne(u10, h10), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u10} and dilations '${h10}'`);
  let f10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, h10, l10, p10, true), m10 = [r10, a10], g10 = i10 != null, b10 = o10 != null;
  g10 && m10.push(i10), b10 && m10.push(o10);
  let y10 = [{ type: "int32", data: [f10.padInfo.top, f10.padInfo.left] }, { type: "int32", data: [f10.strideHeight, f10.strideWidth] }, { type: "int32", data: [f10.dilationHeight, f10.dilationWidth] }, { type: "int32", data: [f10.inHeight, f10.inWidth] }], v10;
  return f10.batchSize === 1 && f10.inHeight === f10.outHeight && f10.inWidth === f10.outWidth && f10.strideHeight === 1 && f10.strideWidth === 1 && f10.filterHeight === f10.filterWidth && f10.inChannels === f10.outChannels && f10.filterHeight === 3 && f10.inChannels % 4 === 0 ? v10 = new v2(f10, g10, d10, b10) : (v10 = new x2(f10, g10, d10, b10), y10.push({ type: "int32", data: [f10.filterHeight] }, { type: "int32", data: [f10.filterWidth] }, { type: "int32", data: [f10.outChannels / f10.inChannels] })), n10.runWebGPUProgram(v10, m10, "float32", y10);
}
var Ere = { kernelName: ra, backendName: "webgpu", kernelFunc: Are };
var Rre = class {
  constructor(e, t) {
    this.variableNames = ["A", "indices"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = t, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = `gathernd_${e}`, this.sliceDim = e, this.uniforms = `sliceDim : i32; strides : ${Wt(e)};`;
  }
  getUserCode() {
    let e;
    return this.sliceDim > 1 ? e = "uniforms.strides[j]" : e = "uniforms.strides", `
        ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
  }
};
function Dre(e) {
  let { inputs: t, backend: n10 } = e, { params: s10, indices: r10 } = t, a10 = r10.shape, i10 = a10[a10.length - 1], o10 = w2.sizeFromShape(s10.shape), [u10, l10, c10, p10] = N2.prepareAndValidate(s10, r10), d10 = Me2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [l10, i10] } }), h10 = Me2({ inputs: { x: s10 }, backend: n10, attrs: { shape: [w2.sizeFromShape(s10.shape) / c10, c10] } });
  if (n10.shouldExecuteOnCPU([s10, r10]) || s10.dtype === "string") {
    let y10 = n10.readSync(r10.dataId), v10 = n10.bufferSync(s10), x10 = Sne(y10, v10, s10.dtype, l10, i10, c10, p10, s10.shape, o10);
    return n10.makeTensorInfo(u10, s10.dtype, x10.values);
  }
  let f10 = new Rre(i10, [l10, c10]), m10 = [{ type: "int32", data: [i10] }, { type: "int32", data: p10 }], g10 = n10.runWebGPUProgram(f10, [h10, d10], h10.dtype, m10), b10 = Me2({ inputs: { x: g10 }, backend: n10, attrs: { shape: u10 } });
  return n10.disposeData(d10.dataId), n10.disposeData(h10.dataId), n10.disposeData(g10.dataId), b10;
}
var Fre = { kernelName: bo, backendName: "webgpu", kernelFunc: Dre };
var Ore = class {
  constructor(e, t) {
    this.variableNames = ["A", "indices"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e.slice(), this.aShape = e, this.outputShape = t, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "gather";
  }
  getUserCode() {
    let e = Pre(this.aShape, "i32");
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;
  }
};
function Pre(e, t = "int") {
  let n10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s10 = [];
  for (let r10 = 0; r10 < e.length; r10++)
    r10 === 2 ? s10.push(`${t}(getIndices(resRC.x, resRC.z))`) : s10.push(`${n10[r10]}`);
  return s10.join();
}
function C2(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10, indices: a10 } = t, { axis: i10, batchDims: o10 } = s10, u10 = w2.parseAxisParam(i10, r10.shape)[0], l10 = N2.segment_util.collectGatherOpShapeInfo(r10, a10, u10, o10), c10 = w2.sizeFromShape(a10.shape), p10 = [], d10 = Me2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [l10.batchSize, l10.outerSize, l10.dimSize, l10.sliceSize] } }), h10 = Me2({ inputs: { x: a10 }, backend: n10, attrs: { shape: [l10.batchSize, c10 / l10.batchSize] } });
  p10.push(d10), p10.push(h10);
  let f10 = [l10.batchSize, l10.outerSize, c10 / l10.batchSize, l10.sliceSize];
  if (n10.shouldExecuteOnCPU([r10, a10])) {
    let v10 = n10.tensorMap.get(h10.dataId).values, x10 = De(h10.shape, h10.dtype, v10), C10 = n10.tensorMap.get(d10.dataId).values, T10 = De(d10.shape, d10.dtype, C10), E10 = Cne(T10, x10, f10);
    return p10.forEach((A10) => n10.disposeData(A10.dataId)), n10.makeTensorInfo(l10.outputShape, E10.dtype, E10.values);
  }
  let m10 = new Ore(d10.shape, f10), g10 = n10.runWebGPUProgram(m10, [d10, h10], d10.dtype);
  p10.push(g10);
  let b10 = Me2({ inputs: { x: g10 }, backend: n10, attrs: { shape: l10.outputShape } });
  return p10.forEach((y10) => n10.disposeData(y10.dataId)), b10;
}
var zre = { kernelName: go, backendName: "webgpu", kernelFunc: C2 };
var Mre = fn({ opSnippet: 5, cpuKernelImpl: Tne, dtype: "bool" });
var Lre = { kernelName: yo, backendName: "webgpu", kernelFunc: Mre };
var Bre = fn({ opSnippet: 6, dtype: "bool", cpuKernelImpl: Nne });
var Vre = { kernelName: za, backendName: "webgpu", kernelFunc: Bre };
function Wre(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { alpha: a10 } = s10, i10 = [{ type: "float32", data: [a10] }], o10 = new tc(r10.shape, 15);
  return o10.uniforms = "alpha : f32;", n10.runWebGPUProgram(o10, [r10], "float32", i10);
}
var Ure = { kernelName: La, backendName: "webgpu", kernelFunc: Wre };
var Gre = fn({ opSnippet: 7, dtype: "bool", cpuKernelImpl: _ne });
var Hre = { kernelName: vo, backendName: "webgpu", kernelFunc: Gre };
var qre = fn({ opSnippet: 8, dtype: "bool", cpuKernelImpl: $ne });
var jre = { kernelName: xo, backendName: "webgpu", kernelFunc: qre };
var Kre = jt({ opType: 9, cpuKernelImpl: Ane });
var Xre = { kernelName: Ba, backendName: "webgpu", kernelFunc: Kre };
var Yre = fn({ opSnippet: 9, dtype: "bool" });
var Qre = { kernelName: wo, backendName: "webgpu", kernelFunc: Yre };
var Zre = jt({ opType: 10 });
var Jre = { kernelName: yl, backendName: "webgpu", kernelFunc: Zre };
function N22(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reductionIndices: a10, keepDims: i10 } = s10;
  return sc(r10, a10, i10, "max", n10);
}
var eae = { kernelName: Va, backendName: "webgpu", kernelFunc: N22 };
var tae = fn({ opSnippet: 15, cpuKernelImpl: Rne });
var nae = { kernelName: Wa, backendName: "webgpu", kernelFunc: tae };
function sae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { filterSize: a10, strides: i10, pad: o10, dimRoundingMode: u10 } = s10, l10 = 1, c10 = N2.computePool2DInfo(r10.shape, a10, i10, l10, o10, u10), p10, d10 = [];
  if (c10.filterHeight === 1 && c10.filterWidth === 1) {
    if (w2.arraysEqual(c10.inShape, c10.outShape))
      return Zn({ inputs: { x: r10 }, backend: n10 });
    p10 = new m2(c10), d10.push({ type: "int32", data: [c10.strideHeight, c10.strideWidth] });
  } else
    p10 = new f2(c10, "max"), d10.push({ type: "int32", data: [c10.strideHeight, c10.strideWidth] }, { type: "int32", data: [c10.padInfo.top, c10.padInfo.left] }, { type: "int32", data: [c10.dilationHeight, c10.dilationWidth] }, { type: "int32", data: [c10.inHeight, c10.inWidth] }, { type: "int32", data: [c10.effectiveFilterHeight, c10.effectiveFilterWidth] });
  return n10.runWebGPUProgram(p10, [r10], r10.dtype, d10);
}
var rae = { kernelName: Ua, backendName: "webgpu", kernelFunc: sae };
function aae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { keepDims: a10, axis: i10 } = s10;
  return sc(r10, i10, a10, "mean", n10);
}
var iae = { kernelName: Ga, backendName: "webgpu", kernelFunc: aae };
function oae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  return sc(r10, a10, i10, "min", n10);
}
var uae = { kernelName: Ha, backendName: "webgpu", kernelFunc: oae };
var lae = fn({ opSnippet: 16, cpuKernelImpl: Dne });
var cae = { kernelName: qa, backendName: "webgpu", kernelFunc: lae };
var dae = class {
  constructor(e, t, n10) {
    this.uniforms = "", this.variableNames = ["x"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = t.map((s10, r10) => s10[0] + e[r10] + s10[1]), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.xShape = e, t.map((s10, r10) => {
      this.uniforms += ` pad${r10} : vec2<i32>;`;
    }), this.offset = n10 === "reflect" ? 0 : 1, this.shaderKey = `mirrorPad_${n10}`;
  }
  getUserCode() {
    let e = this.xShape.length, t = this.xShape.map((u10, l10) => `uniforms.pad${l10}[0]`).join(","), n10 = this.xShape.map((u10, l10) => `uniforms.pad${l10}[0] + uniforms.xShape${e > 1 ? `[${l10}]` : ""}`).join(","), s10 = e === 1 ? "start" : "start[i]", r10 = e === 1 ? "end" : "end[i]", a10 = e === 1 ? "outC" : "outC[i]", i10 = Wt(e), o10 = e > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, e) : "coords";
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let start = ${i10}(${t});
          let end = ${i10}(${n10});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a10} < ${s10}) {
              ${a10} = ${s10} * 2 - ${a10} - ${this.offset};
            } else if(${a10} >= ${r10}) {
              ${a10} = (${r10} - 1) * 2 - ${a10} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${o10}));
        }
      }
    `;
  }
};
var pae = { kernelName: ja, backendName: "webgpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { x: s10 } = e, { paddings: r10, mode: a10 } = t, i10 = n10, o10 = r10.map((c10) => ({ type: "int32", data: [c10[0], c10[1]] })), u10 = new dae(s10.shape, r10, a10);
  return i10.runWebGPUProgram(u10, [s10], s10.dtype, o10);
} };
function hae(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (n10.shouldExecuteOnCPU([s10])) {
    let a10 = n10.tensorMap.get(s10.dataId), [i10, o10] = One(a10.values, s10.shape, s10.dtype);
    return n10.makeTensorInfo(o10, s10.dtype, i10);
  }
  let r10 = new tc(s10.shape, 11);
  return n10.runWebGPUProgram(r10, [s10], s10.dtype);
}
var fae = { kernelName: ko, backendName: "webgpu", kernelFunc: hae };
function mae(e) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10 } = s10, l10 = n10.readSync(r10.dataId), c10 = n10.readSync(a10.dataId), { selectedIndices: p10 } = xs.nonMaxSuppressionV3Impl(l10, c10, i10, o10, u10);
  return n10.makeTensorInfo([p10.length], "int32", new Int32Array(p10));
}
var gae = { kernelName: So, backendName: "webgpu", kernelFunc: mae };
function bae(e) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t, backend: n10, attrs: s10 } = e, { boxes: r10, scores: a10 } = t, { maxOutputSize: i10, iouThreshold: o10, scoreThreshold: u10, softNmsSigma: l10 } = s10, c10 = n10.readSync(r10.dataId), p10 = n10.readSync(a10.dataId), d10 = i10, h10 = o10, f10 = u10, m10 = l10, { selectedIndices: g10, selectedScores: b10 } = xs.nonMaxSuppressionV5Impl(c10, p10, d10, h10, f10, m10);
  return [n10.makeTensorInfo([g10.length], "int32", new Int32Array(g10)), n10.makeTensorInfo([b10.length], "float32", new Float32Array(b10))];
}
var yae = { kernelName: Co, backendName: "webgpu", kernelFunc: bae };
function Md(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "complex64") {
    let r10 = nc({ inputs: { input: s10 }, backend: n10 }), a10 = Md({ inputs: { x: r10 }, backend: n10 }), i10 = Qp({ inputs: { input: s10 }, backend: n10 }), o10 = Md({ inputs: { x: i10 }, backend: n10 }), u10 = uu({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeData(r10.dataId), n10.disposeData(a10.dataId), n10.disposeData(i10.dataId), n10.disposeData(o10.dataId), u10;
  } else
    return cu({ attrs: { shape: s10.shape, dtype: s10.dtype, value: s10.dtype === "string" ? "" : 0 }, backend: n10 });
}
var vae = { kernelName: Go, backendName: "webgpu", kernelFunc: Md };
function T2(e) {
  let { inputs: t, backend: n10 } = e, { x: s10 } = t;
  if (s10.dtype === "string")
    throw new Error("onesLike is not supported under string dtype");
  if (s10.dtype === "complex64") {
    let r10 = nc({ inputs: { input: s10 }, backend: n10 }), a10 = T2({ inputs: { x: r10 }, backend: n10 }), i10 = Qp({ inputs: { input: s10 }, backend: n10 }), o10 = Md({ inputs: { x: i10 }, backend: n10 }), u10 = uu({ inputs: { real: a10, imag: o10 }, backend: n10 });
    return n10.disposeData(r10.dataId), n10.disposeData(a10.dataId), n10.disposeData(i10.dataId), n10.disposeData(o10.dataId), u10;
  } else
    return cu({ attrs: { shape: s10.shape, dtype: s10.dtype, value: 1 }, backend: n10 });
}
var xae = { kernelName: No, backendName: "webgpu", kernelFunc: T2 };
function wae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10;
  if (t.length === 1)
    return Xm({ inputs: { input: t[0] }, backend: n10, attrs: { dim: r10 } });
  let a10 = t[0].shape, i10 = t[0].dtype;
  t.forEach((c10) => {
    w2.assertShapesMatch(a10, c10.shape, "All tensors passed to stack must have matching shapes"), w2.assert(i10 === c10.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o10 = [], u10 = t.map((c10) => {
    let p10 = Xm({ inputs: { input: c10 }, backend: n10, attrs: { dim: r10 } });
    return o10.push(p10), p10;
  }), l10 = b2({ inputs: u10, backend: n10, attrs: { axis: r10 } });
  return o10.forEach((c10) => n10.disposeData(c10.dataId)), l10;
}
var kae = { kernelName: $o, backendName: "webgpu", kernelFunc: wae };
var Iae = class {
  constructor(e, t) {
    this.variableNames = ["x"], this.uniforms = "constantValue : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = t.map((n10, s10) => n10[0] + e[s10] + n10[1]), this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), t.map((n10, s10) => {
      this.uniforms += ` pad${s10} : vec2<i32>;`;
    }), this.xShape = e, this.shaderKey = "pad";
  }
  getUserCode() {
    let e = this.xShape.length, t = Wt(e), n10 = this.xShape.map((c10, p10) => `uniforms.pad${p10}[0]`).join(","), s10 = this.xShape.map((c10, p10) => `uniforms.pad${p10}[0] + uniforms.xShape${e > 1 ? `[${p10}]` : ""}`).join(","), r10 = e > 1 ? `${t}(${n10})` : `${n10}`, a10 = e > 1 ? `${t}(${s10})` : `${s10}`, i10 = e > 1 ? "any(outC < start)" : "outC < start", o10 = e > 1 ? "any(outC >= end)" : "outC >= end", u10 = e > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, e) : "coords";
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let start = ${r10};
          let end = ${a10};
          let outC = getCoordsFromIndex(index);

          if (${i10} || ${o10}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${u10}));
          }
        }
      }
    `;
  }
};
var $2 = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { paddings: a10, constantValue: i10 } = s10;
  if (a10.every((l10) => w2.arraysEqual(l10, [0, 0])))
    return Zn({ inputs: { x: r10 }, backend: n10 });
  if (w2.sizeFromShape(r10.shape) === 0) {
    let l10 = a10.map((c10, p10) => c10[0] + r10.shape[p10] + c10[1]);
    return cu({ backend: n10, attrs: { shape: l10, value: i10, dtype: r10.dtype } });
  }
  let o10 = [{ type: "float32", data: [i10] }];
  a10.map((l10) => o10.push({ type: "int32", data: [l10[0], l10[1]] }));
  let u10 = new Iae(r10.shape, a10);
  return n10.runWebGPUProgram(u10, [r10], r10.dtype, o10);
};
var Sae = { kernelName: Xa, backendName: "webgpu", kernelFunc: $2 };
var Cae = fn({ opSnippet: 13 });
var Nae = { kernelName: Ya, backendName: "webgpu", kernelFunc: Cae };
function Tae(e) {
  let { inputs: t, backend: n10 } = e, { x: s10, alpha: r10 } = t, a10 = new p2(14, s10.shape, r10.shape);
  return n10.runWebGPUProgram(a10, [s10, r10], "float32");
}
var $ae = { kernelName: Qa, backendName: "webgpu", kernelFunc: Tae };
function _ae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, keepDims: i10 } = s10;
  return sc(r10, a10, i10, "prod", n10);
}
var Aae = { kernelName: _o, backendName: "webgpu", kernelFunc: _ae };
var Eae = (e) => {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, step: a10, dtype: i10 } = n10, o10 = Mne(s10, r10, a10, i10);
  return t.makeTensorInfo([o10.length], i10, o10);
};
var Rae = { kernelName: wl, backendName: "webgpu", kernelFunc: Eae };
var _22 = fn({ opSnippet: 3 });
var Dae = { kernelName: Ea, backendName: "webgpu", kernelFunc: _22 };
var Fae = jt({ opType: 13 });
var Oae = { kernelName: Za, backendName: "webgpu", kernelFunc: Fae };
var Pae = jt({ opType: 14 });
var zae = { kernelName: ei, backendName: "webgpu", kernelFunc: Pae };
var Mae = class {
  constructor(e, t, n10) {
    this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>; halfPixelCenters : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = [e[0], t, n10, e[3]], this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "resizeBilinear";
  }
  getUserCode() {
    return `
      ${Ue()}
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
  }
};
function Lae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, size: i10, halfPixelCenters: o10 } = s10, [u10, l10] = i10, c10 = a10 && u10 > 1 ? 1 : 0, p10 = a10 && l10 > 1 ? 1 : 0, h10 = [{ type: "float32", data: [c10, p10] }, { type: "float32", data: [o10 ? 0.5 : 0] }], f10 = new Mae(r10.shape, u10, l10);
  return n10.runWebGPUProgram(f10, [r10], "float32", h10);
}
var Bae = { kernelName: Ja, backendName: "webgpu", kernelFunc: Lae };
var Vae = class {
  constructor(e, t, n10, s10) {
    this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>; roundBase : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = [e[0], t, n10, e[3]], this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.halfPixelCenters = s10, this.shaderKey = `resizeNearest_${s10}`;
  }
  getUserCode() {
    let e;
    return this.halfPixelCenters ? e = "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : e = "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", `
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
  }
};
function Wae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { images: r10 } = t, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10, [u10, l10] = o10, c10 = a10 && u10 > 1 ? 1 : 0, p10 = a10 && l10 > 1 ? 1 : 0, h10 = [{ type: "float32", data: [c10, p10] }, { type: "float32", data: [a10 ? 0.5 : 0] }], f10 = new Vae(r10.shape, u10, l10, i10);
  return n10.runWebGPUProgram(f10, [r10], r10.dtype, h10);
}
var Uae = { kernelName: Il, backendName: "webgpu", kernelFunc: Wae };
var Gae = class {
  constructor(e, t) {
    this.outputShape = [], this.variableNames = ["x"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.uniforms = `centerX : f32; centerY : f32; sinRadians : f32;
          cosRadians : f32;`, this.shaderKey = "rotate", this.outputShape = e, typeof t == "number" ? (this.uniforms += " fillValue : f32;", this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>;", this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
  }
  getUserCode() {
    return `
        ${Ue()}

          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
  }
};
var Hae = { kernelName: Ho, backendName: "webgpu", kernelFunc: ({ inputs: e, attrs: t, backend: n10 }) => {
  let { image: s10 } = e, { radians: r10, fillValue: a10, center: i10 } = t, o10 = n10, u10 = new Gae(s10.shape, a10), [l10, c10] = N2.getImageCenter(i10, s10.shape[1], s10.shape[2]), p10 = [{ type: "float32", data: [l10] }, { type: "float32", data: [c10] }, { type: "float32", data: [Math.sin(r10)] }, { type: "float32", data: [Math.cos(r10)] }];
  return typeof a10 == "number" ? p10.push({ type: "float32", data: [Number.parseFloat(a10.toFixed(2))] }) : p10.push({ type: "float32", data: a10 }), o10.runWebGPUProgram(u10, [s10], s10.dtype, p10);
} };
var qae = jt({ opType: 16, cpuKernelImpl: Lne });
var jae = { kernelName: ti, backendName: "webgpu", kernelFunc: qae };
var Kae = class {
  constructor(e, t, n10, s10, r10, a10, i10) {
    this.variableNames = ["updates", "indices"], this.workGroupSize = [64, 1, 1], this.atomic = true, this.outputShape = a10, this.type = i10, this.dispatchLayout = Be(e), this.dispatch = _e2(this.dispatchLayout, e, this.workGroupSize), this.sliceDimGreaterThanOne = t > 1, this.shaderKey = `scatter_${n10}_${s10}_${this.sliceDimGreaterThanOne}_${i10}`;
    let o10 = Wt(r10.length);
    this.uniforms = `sliceDim : i32; strides: ${o10}; size: i32;`, this.updatesRank = s10, this.indicesRank = n10;
  }
  getUserCode() {
    let e = "";
    this.indicesRank === 1 ? e = "coords[0]" : this.indicesRank === 2 && (e = "coords[0], j");
    let t = `getIndices(${e})`, n10 = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides", s10 = "", r10 = "", a10 = "";
    this.updatesRank === 1 ? (s10 = "coords[0]", r10 = "flattenedIndex", a10 = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `) : this.updatesRank === 2 && (s10 = "coords[0], coords[1]", r10 = "vec2<i32>(flattenedIndex, coords[1])", a10 = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        let d0 = index / uniforms.updatesShape[1];
        let d1 = index - d0 * uniforms.updatesShape[1];
        return vec2<i32>(d0, d1);
      }
      `);
    let i10 = `getUpdates(${s10})`, o10 = this.type === "int32" ? "atomicAdd(&(result.numbers[flatIndex]), i32(updateValue));" : `
     var assumed = atomicLoad(&(result.numbers[flatIndex]));
     var success = 0;
     for (; success == 0;) {
       let new = bitcast<f32>(assumed) + updateValue;
       let newI32 = bitcast<i32>(new);
       let resValue = atomicCompareExchangeWeak(&(result.numbers[flatIndex]), assumed, newI32);
       assumed = resValue[0];
       success = resValue[1];
     }
     `;
    return `
    ${a10}

      ${Ue()}

        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n10};
          }
          let updateValue = ${i10};
          let flatIndex = getOutputIndexFromCoords(${r10});

         ${o10}
        }
      }`;
  }
};
function Xae(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10, updates: a10 } = t, { shape: i10 } = s10, { sliceRank: o10, numUpdates: u10, sliceSize: l10, strides: c10, outputSize: p10 } = N2.calculateShapes(a10, r10, i10), d10 = [p10 / l10, l10];
  if (p10 === 0)
    return n10.makeTensorInfo(i10, r10.dtype);
  let h10 = Me2({ inputs: { x: r10 }, backend: n10, attrs: { shape: [u10, o10] } }), f10 = Me2({ inputs: { x: a10 }, backend: n10, attrs: { shape: [u10, l10] } }), m10 = f10.dtype, g10 = cu({ backend: n10, attrs: { shape: d10, value: 0, dtype: m10 } }), b10 = w2.sizeFromShape(f10.shape), y10 = [{ type: "int32", data: [o10] }, { type: "int32", data: c10 }, { type: "int32", data: [b10] }], v10 = new Kae(f10.shape, o10, h10.shape.length, f10.shape.length, c10, d10, m10), x10 = n10.runWebGPUProgram(v10, [f10, h10], m10, y10, g10), k10 = Me2({ inputs: { x: x10 }, backend: n10, attrs: { shape: i10 } });
  return n10.disposeData(h10.dataId), n10.disposeData(f10.dataId), n10.disposeData(x10.dataId), k10;
}
var Yae = { kernelName: Do, backendName: "webgpu", kernelFunc: Xae };
var Qae = class {
  constructor(e, t, n10) {
    this.variableNames = ["c", "a", "b"], this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = t, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.cRank = e, this.rank = n10, this.shaderKey = "select";
  }
  getUserCode() {
    let e, t;
    if (this.rank > 4)
      throw Error(`Where for rank ${this.rank} is not yet supported`);
    if (this.rank === 1)
      t = "resRC", e = "resRC";
    else {
      let s10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r10 = [], a10 = [];
      for (let i10 = 0; i10 < this.outputShape.length; i10++)
        a10.push(`${s10[i10]}`), i10 < this.cRank && r10.push(`${s10[i10]}`);
      e = r10.join(), t = a10.join();
    }
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `;
  }
};
function Zae(e) {
  let { inputs: t, backend: n10 } = e, { condition: s10, t: r10, e: a10 } = t, i10 = new Qae(s10.shape.length, r10.shape, r10.shape.length);
  return n10.runWebGPUProgram(i10, [s10, r10, a10], yn(r10.dtype, a10.dtype));
}
var Jae = { kernelName: Fo, backendName: "webgpu", kernelFunc: Zae };
var eie = jt({ opType: 19 });
var tie = { kernelName: si, backendName: "webgpu", kernelFunc: eie };
var nie = jt({ opType: 17 });
var sie = { kernelName: ni, backendName: "webgpu", kernelFunc: nie };
var rie = jt({ opType: 18 });
var aie = { kernelName: Po, backendName: "webgpu", kernelFunc: rie };
var A2 = fn({ opSnippet: 2, cpuKernelImpl: Gne, supportsComplex: true });
var iie = { kernelName: ui, backendName: "webgpu", kernelFunc: A2 };
function oie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { logits: r10 } = t, { dim: a10 } = s10, i10 = w2.parseAxisParam([a10], r10.shape), o10 = N22({ inputs: { x: r10 }, backend: n10, attrs: { reductionIndices: i10, keepDims: false } }), u10 = N2.expandShapeToKeepDim(o10.shape, i10), l10 = Me2({ inputs: { x: o10 }, backend: n10, attrs: { shape: u10 } }), c10 = A2({ inputs: { a: r10, b: l10 }, backend: n10 }), p10 = k2({ inputs: { x: c10 }, backend: n10 }), d10 = Tv({ inputs: { x: p10 }, backend: n10, attrs: { axis: i10, keepDims: false } }), h10 = Me2({ inputs: { x: d10 }, backend: n10, attrs: { shape: u10 } }), f10 = _22({ inputs: { a: p10, b: h10 }, backend: n10 });
  return n10.disposeData(o10.dataId), n10.disposeData(l10.dataId), n10.disposeData(c10.dataId), n10.disposeData(p10.dataId), n10.disposeData(d10.dataId), n10.disposeData(h10.dataId), f10;
}
var uie = { kernelName: ii, backendName: "webgpu", kernelFunc: oie };
var lie = (e) => {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, paddings: i10 } = s10;
  w2.assert(r10.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
  let o10 = a10.reduce((b10, y10) => b10 * y10), u10 = [[0, 0]];
  u10.push(...i10);
  for (let b10 = 1 + a10.length; b10 < r10.shape.length; ++b10)
    u10.push([0, 0]);
  let l10 = [], c10 = $2({ inputs: { x: r10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), p10 = N2.getReshaped(c10.shape, a10, o10, false), d10 = N2.getPermuted(p10.length, a10.length, false), h10 = N2.getReshapedPermuted(c10.shape, a10, o10, false), f10 = Me2({ inputs: { x: c10 }, backend: n10, attrs: { shape: p10 } }), m10 = vi({ inputs: { x: f10 }, backend: n10, attrs: { perm: d10 } }), g10 = Me2({ inputs: { x: m10 }, backend: n10, attrs: { shape: h10 } });
  return l10.push(c10), l10.push(f10), l10.push(m10), l10.forEach((b10) => n10.disposeData(b10.dataId)), g10;
};
var cie = { kernelName: zo, backendName: "webgpu", kernelFunc: lie };
var die = class {
  constructor(e, t, n10, s10, r10, a10, i10 = true) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.workGroupSize = [64, 1, 1], this.workPerThread = 4, this.size = true, this.outputShape = a10, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    let o10 = t > 1;
    this.shaderKey = `scatter_${n10}_${s10}_${o10}`;
    let u10 = Wt(r10.length);
    this.uniforms = `updateSize : i32; sliceDim : i32; strides: ${u10};`;
    let l10 = "";
    n10 === 1 ? l10 = "i" : n10 === 2 && (l10 = "i, j"), this.indicesSnippet = `getIndices(${l10})`;
    let c10 = "";
    s10 === 1 ? c10 = "i" : s10 === 2 && (c10 = "i, coords[1]"), this.updatesSnippet = `getUpdates(${c10})`, this.strideString = o10 ? "uniforms.strides[j]" : "uniforms.strides";
  }
  getUserCode() {
    return `
      ${Ue()}

        let globalIndex = index * ${this.workPerThread};
        if (globalIndex < uniforms.size) {
          var sum = vec4<f32>(0.0);
          var found = vec4<bool>(false);
          for (var i = 0; i < uniforms.updateSize; i = i + 1) {
            var flattenedIndex = 0;
            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
              let indexInside = i32(round(${this.indicesSnippet}));
              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};
            }
            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
              let curIndex = globalIndex + innerIndex;
              let coords = getCoordsFromIndex(curIndex);
              if (flattenedIndex == coords[0]) {
                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};
                found[innerIndex] = true;
              }
            }
          }
          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
            let curIndex = globalIndex + innerIndex;
            if (curIndex < uniforms.size)
            {
              setOutputAtIndex(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));
            }
          }
        }
      }`;
  }
};
function pie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { sparseIndices: r10, sparseValues: a10, defaultValue: i10 } = t, { outputShape: o10 } = s10, { sliceRank: u10, numUpdates: l10, strides: c10, outputSize: p10 } = N2.calculateShapes(a10, r10, o10), d10 = false, h10 = [{ type: "int32", data: [l10] }, { type: "int32", data: [u10] }, { type: "int32", data: c10 }], f10 = new die(l10, u10, r10.shape.length, a10.shape.length, c10, [p10, 1], d10), m10 = n10.runWebGPUProgram(f10, [a10, r10, i10], a10.dtype, h10), g10 = Me2({ inputs: { x: m10 }, backend: n10, attrs: { shape: o10 } });
  return n10.disposeData(m10.dataId), g10;
}
var hie = { kernelName: ap, backendName: "webgpu", kernelFunc: pie };
function fie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { numOrSizeSplits: a10, axis: i10 } = s10, o10 = w2.parseAxisParam(i10, r10.shape)[0], u10 = N2.prepareSplitSize(r10, a10, o10), l10 = r10.shape.length, c10 = new Array(l10).fill(0), p10 = r10.shape.slice();
  return u10.map((d10) => {
    let h10 = [...p10];
    h10[o10] = d10;
    let f10 = lu({ inputs: { x: r10 }, backend: n10, attrs: { begin: c10, size: h10 } });
    return c10[o10] += d10, f10;
  });
}
var mie = { kernelName: Mo, backendName: "webgpu", kernelFunc: fie };
var gie = jt({ opType: 20 });
var bie = { kernelName: ri, backendName: "webgpu", kernelFunc: gie };
var yie = { kernelName: $l, backendName: "webgpu", kernelFunc: ({ inputs: e, backend: t }) => {
  let { x: n10 } = e, s10 = t, r10 = new tc(n10.shape, 21);
  return s10.runWebGPUProgram(r10, [n10], n10.dtype);
} };
var vie = fn({ opSnippet: 11 });
var xie = { kernelName: oi, backendName: "webgpu", kernelFunc: vie };
var wie = class {
  constructor(e) {
    this.variableNames = ["x"], this.workPerThread = 1, this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]);
    let t = Wt(this.outputShape.length);
    this.uniforms = `begin : ${t};  strides : ${t}; `, this.shaderKey = "stridedSlice";
  }
  getUserCode() {
    let e = this.outputShape.length, t = "";
    if (e === 1)
      t = "coords * uniforms.strides + uniforms.begin";
    else {
      let s10 = 0;
      t = this.outputShape.map((r10, a10) => (s10++, this.outputShape.length === 1 ? `coords * uniforms.strides[${a10}] + uniforms.begin[${a10}]` : `coords[${s10 - 1}] * uniforms.strides[${a10}] + uniforms.begin[${a10}]`)).join(",");
    }
    return `
       ${Ue()}
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `;
  }
};
function kie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { begin: a10, end: i10, strides: o10, beginMask: u10, endMask: l10, ellipsisMask: c10, newAxisMask: p10, shrinkAxisMask: d10 } = s10, { finalShapeSparse: h10, finalShape: f10, isIdentity: m10, sliceDim0: g10, isSimpleSlice: b10, begin: y10, end: v10, strides: x10 } = wt.sliceInfo(r10.shape, a10, i10, o10, u10, l10, c10, p10, d10), k10;
  if (m10)
    k10 = Me2({ inputs: { x: r10 }, backend: n10, attrs: { shape: f10 } });
  else if (g10 || b10) {
    w2.assert(r10.shape.length >= 1, () => `Input must have rank at least 1, got: ${r10.shape.length}`);
    let C10 = wt.computeOutShape(y10, v10, x10), T10 = lu({ inputs: { x: r10 }, backend: n10, attrs: { begin: y10, size: C10 } });
    k10 = Me2({ inputs: { x: T10 }, backend: n10, attrs: { shape: f10 } }), n10.disposeData(T10.dataId);
  } else if (n10.shouldExecuteOnCPU([r10])) {
    let T10 = n10.readSync(r10.dataId), E10 = De(r10.shape, r10.dtype, T10), A10 = Wne(h10, E10, x10, y10);
    k10 = n10.makeTensorInfo(f10, r10.dtype, A10.values);
  } else {
    let T10 = new wie(h10), E10 = [{ type: "int32", data: y10 }, { type: "int32", data: x10 }], A10 = n10.runWebGPUProgram(T10, [r10], r10.dtype, E10);
    k10 = Me2({ inputs: { x: A10 }, backend: n10, attrs: { shape: f10 } }), n10.disposeData(A10.dataId);
  }
  return k10;
}
var Iie = { kernelName: Lo, backendName: "webgpu", kernelFunc: kie };
function Sie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { separator: r10, nGramWidths: a10, leftPad: i10, rightPad: o10, padWidth: u10, preserveShortSequences: l10 } = s10, { data: c10, dataSplits: p10 } = t, d10 = n10.readSync(c10.dataId), h10 = n10.readSync(p10.dataId), [f10, m10] = Une(d10, h10, r10, a10, i10, o10, u10, l10);
  return [n10.makeTensorInfo([f10.length], "string", f10), n10.makeTensorInfo(p10.shape, "int32", m10)];
}
var Cie = { kernelName: ip, backendName: "webgpu", kernelFunc: Sie };
var Nie = jt({ opType: 22 });
var Tie = { kernelName: li, backendName: "webgpu", kernelFunc: Nie };
var $ie = class {
  constructor(e, t) {
    this.variableNames = ["A"], this.workGroupSize = [64, 1, 1], this.size = true;
    let n10 = new Array(e.length);
    for (let s10 = 0; s10 < n10.length; s10++)
      n10[s10] = e[s10] * t[s10];
    this.outputShape = n10, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.rank = this.outputShape.length, this.shaderKey = "tile";
  }
  getUserCode() {
    let e = _ie(this.rank, "uniforms.");
    return `
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;
  }
};
function _ie(e, t = "") {
  if (e >= 5)
    throw Error(`Tile for rank ${e} is not yet supported`);
  if (e === 1)
    return `(resRC % ${t}aShape)`;
  let n10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s10 = [];
  for (let r10 = 0; r10 < e; r10++)
    s10.push(`(${n10[r10]} % ${t}aShape[${r10}])`);
  return s10.join();
}
function Aie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { reps: a10 } = s10;
  if (n10.shouldExecuteOnCPU([r10]) || r10.dtype === "string" || r10.shape.length >= 5) {
    let u10 = n10.readSync(r10.dataId), l10 = r10.dtype === "string" ? u10.map((d10) => w2.decodeString(d10)) : u10, c10 = De(r10.shape, r10.dtype, l10), p10 = Hne(c10, a10);
    return n10.makeTensorInfo(p10.shape, p10.dtype, p10.values);
  }
  let i10 = new $ie(r10.shape, a10);
  return n10.runWebGPUProgram(i10, [r10], r10.dtype);
}
var Eie = { kernelName: Sr, backendName: "webgpu", kernelFunc: Aie };
var Rie = class {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.workGroupSize = [256, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.uniforms = `inputSize : i32; firstPass : i32; negativeInf : f32;
        dir : i32; inc : i32;`, this.shaderKey = "swap";
  }
  getUserCode() {
    return `
        ${Ue()}
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
  }
};
var Die = class {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.workGroupSize = [256, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.uniforms = "inputSize : i32; firstPass : i32; k : i32;", this.shaderKey = "merge";
  }
  getUserCode() {
    return `
        ${Ue()}
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
  }
};
function Li(e, t) {
  t !== null && e.disposeData(t.dataId);
}
function Aw(e) {
  let t = 1;
  for (; t < e; )
    t *= 2;
  return t;
}
function Fie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { k: a10, sorted: i10 } = s10, o10 = r10.shape, u10 = o10[o10.length - 1];
  if (n10.shouldExecuteOnCPU([r10])) {
    let k10 = n10.readSync(r10.dataId), [C10, T10] = qne(k10, o10, r10.dtype, a10, i10);
    return [n10.makeTensorInfo(C10.shape, C10.dtype, C10.values), n10.makeTensorInfo(T10.shape, T10.dtype, T10.values)];
  }
  if (a10 === 0)
    return o10[o10.length - 1] = 0, [n10.makeTensorInfo(o10, r10.dtype, []), n10.makeTensorInfo(o10, "int32", [])];
  if (u10 === 1)
    return [r10, cu({ attrs: { shape: o10, dtype: "int32", value: 0 }, backend: n10 })];
  let c10 = w2.sizeFromShape(o10) / u10, p10 = Me2({ inputs: { x: r10 }, attrs: { shape: [c10, u10] }, backend: n10 }), d10 = Aw(a10), h10 = Aw(u10), f10 = null, m10 = () => f10 === null ? [p10, p10] : [p10, f10], g10 = (k10, C10, T10) => {
    let E10 = m10(), A10 = new Rie(T10), R10 = [{ type: "int32", data: [u10] }, { type: "int32", data: [f10 === null ? 1 : 0] }, { type: "float32", data: [Number.NEGATIVE_INFINITY] }, { type: "int32", data: [k10] }, { type: "int32", data: [C10] }], F10 = f10;
    f10 = n10.runWebGPUProgram(A10, E10, "int32", R10), Li(n10, F10);
  };
  for (let k10 = 1; k10 < d10; k10 *= 2) {
    let C10 = k10 * 2;
    for (let T10 = k10; T10 >= 1; T10 /= 2)
      g10(C10, T10, [c10, h10]);
  }
  for (let k10 = h10; k10 > d10; k10 /= 2) {
    let C10 = m10(), T10 = new Die([c10, k10 / 2]), A10 = [{ type: "int32", data: [u10] }, { type: "int32", data: [f10 === null ? 1 : 0] }, { type: "int32", data: [d10] }], P10 = f10;
    f10 = n10.runWebGPUProgram(T10, C10, "int32", A10), Li(n10, P10);
    let R10 = d10 / 2, F10 = R10 * 2;
    for (let $10 = R10; $10 >= 1; $10 /= 2)
      g10(F10, $10, f10.shape);
  }
  let b10 = f10;
  f10 = lu({ inputs: { x: f10 }, backend: n10, attrs: { begin: 0, size: [c10, a10] } }), Li(n10, b10);
  let y10 = C2({ inputs: { x: p10, indices: f10 }, backend: n10, attrs: { axis: 1, batchDims: 1 } });
  Li(n10, p10);
  let v10 = o10.slice(0, -1);
  v10.push(a10), b10 = f10, f10 = Me2({ inputs: { x: f10 }, attrs: { shape: v10 }, backend: n10 }), Li(n10, b10);
  let x10 = y10;
  return y10 = Me2({ inputs: { x: y10 }, attrs: { shape: v10 }, backend: n10 }), Li(n10, x10), [y10, f10];
}
var Oie = { kernelName: Vo, backendName: "webgpu", kernelFunc: Fie };
var Pie = class {
  constructor(e) {
    this.variableNames = ["Image", "Transforms"], this.uniforms = "interpolationModeId : i32; fillModeId : i32; fillValue : f32;", this.workGroupSize = [64, 1, 1], this.size = true, this.outputShape = e, this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize), this.shaderKey = "transform";
  }
  getUserCode() {
    return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ue()}
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
  }
};
function zie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10, transforms: a10 } = t, { interpolation: i10, fillMode: o10, fillValue: u10, outputShape: l10 } = s10, [c10, p10, d10, h10] = r10.shape, [f10, m10] = l10 != null ? l10 : [p10, d10], g10 = [c10, f10, m10, h10], b10 = new Pie(g10), y10 = i10 === "nearest" ? 1 : 2, v10;
  switch (o10) {
    case "constant":
      v10 = 1;
      break;
    case "reflect":
      v10 = 2;
      break;
    case "wrap":
      v10 = 3;
      break;
    case "nearest":
      v10 = 4;
      break;
    default:
      v10 = 1;
      break;
  }
  let x10 = [{ type: "int32", data: [y10] }, { type: "int32", data: [v10] }, { type: "float32", data: [u10] }];
  return n10.runWebGPUProgram(b10, [r10, a10], "float32", x10);
}
var Mie = { kernelName: Wo, backendName: "webgpu", kernelFunc: zie };
function Lie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { value: r10 } = t, { axis: a10 } = s10;
  a10 < 0 && (a10 += r10.shape.length);
  let i10 = r10, o10 = i10.shape.length, u10 = r10.shape[a10], l10 = new Array(o10 - 1), c10 = 0;
  for (let m10 = 0; m10 < o10; m10++)
    m10 !== a10 && (l10[c10++] = i10.shape[m10]);
  let p10 = [], d10 = new Array(o10).fill(0), h10 = i10.shape.slice();
  h10[a10] = 1;
  let f10 = new Array(u10);
  for (let m10 = 0; m10 < f10.length; m10++) {
    d10[a10] = m10;
    let g10 = lu({ inputs: { x: i10 }, backend: n10, attrs: { begin: d10, size: h10 } }), b10 = Me2({ inputs: { x: g10 }, backend: n10, attrs: { shape: l10 } });
    f10[m10] = b10, p10.push(g10);
  }
  return p10.forEach((m10) => n10.disposeData(m10.dataId)), f10;
}
var Bie = { kernelName: Uo, backendName: "webgpu", kernelFunc: Lie };
var Vie = [pne, Xne, Qne, ese, ise, use, cse, pse, bse, wse, Ise, Tse, gne, Ese, Lse, Use, Hse, jse, Yse, Jse, tre, ire, ure, cre, dre, pre, fre, gre, yre, Sre, xre, kre, Tre, _re, Ere, Fre, zre, Lre, Vre, mne, _se, Ure, Hre, jre, Xre, Qre, Jre, eae, nae, rae, iae, uae, cae, pae, nre, fae, gae, yae, yse, xae, kae, Sae, Nae, $ae, Aae, Rae, vse, Dae, Oae, zae, cne, Bae, Uae, Hae, jae, Yae, Jae, tie, sie, aie, mse, Iie, Cie, uie, cie, hie, mie, bie, yie, xie, iie, rre, Tie, Eie, Oie, Mie, rse, Bie, vae];
for (let e of Vie)
  _l(e);
var Wie = class {
  constructor(e) {
    this.device = e, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
  acquireUploadBuffer(e, t) {
    return this.acquireBuffer(e, t, true);
  }
  acquireBuffer(e, t, n10 = false) {
    let s10 = Ew(e, t);
    if (this.freeBuffers.has(s10) || this.freeBuffers.set(s10, []), this.usedBuffers.has(s10) || this.usedBuffers.set(s10, []), this.numBytesUsed += e, this.numUsedBuffers++, this.freeBuffers.get(s10).length > 0) {
      this.numFreeBuffers--;
      let a10 = this.freeBuffers.get(s10).shift();
      return this.usedBuffers.get(s10).push(a10), a10;
    }
    this.numBytesAllocated += e;
    let r10 = this.device.createBuffer({ mappedAtCreation: n10, size: e, usage: t });
    return this.usedBuffers.get(s10).push(r10), r10;
  }
  releaseBuffer(e, t, n10) {
    if (this.freeBuffers.size === 0)
      return;
    let s10 = Ew(t, n10);
    this.freeBuffers.has(s10) || this.freeBuffers.set(s10, []), this.freeBuffers.get(s10).push(e), this.numFreeBuffers++, this.numUsedBuffers--;
    let r10 = this.usedBuffers.get(s10), a10 = r10.indexOf(e);
    if (a10 < 0)
      throw new Error("Cannot release a buffer that was never provided by this buffer manager");
    r10.splice(a10, 1), this.numBytesUsed -= t;
  }
  releaseUploadBuffer(e, t, n10) {
    e.mapAsync(GPUMapMode.WRITE).then(() => {
      this.releaseBuffer(e, t, n10);
    }, (s10) => {
    });
  }
  getNumUsedBuffers() {
    return this.numUsedBuffers;
  }
  getNumFreeBuffers() {
    return this.numFreeBuffers;
  }
  dispose() {
    this.freeBuffers.forEach((e, t) => {
      e.forEach((n10) => {
        n10.destroy();
      });
    }), this.usedBuffers.forEach((e, t) => {
      e.forEach((n10) => {
        n10.destroy();
      });
    }), this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
};
function Ew(e, t) {
  return `${e}_${t}`;
}
var E2 = class {
  constructor() {
    this.outputShape = [0], this.variableNames = [], this.workGroupSize = [256, 1, 1], this.lastUniformData = [], this.inputTexture = null, this.layout = null, this.lastPixelSize = { width: 0, height: 0 }, this.disposed = false, this.shaderKey = "fromPixels", this.useImport = false;
  }
  updateOutputShape(e) {
    w2.arraysEqual(this.outputShape, e) || (this.outputShape = e, this.workPerThread = e[2], this.dispatchLayout = Be(this.outputShape), this.dispatch = _e2(this.dispatchLayout, this.outputShape, this.workGroupSize, [this.workPerThread, 1, 1]));
  }
  makeFromPixelsSource() {
    let e = this.useImport ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
    return `
      @binding(1) @group(0) var src: ${this.useImport ? "texture_external" : "texture_2d<f32>"};

      ${Ue()}
        let flatIndexBase = index * uniforms.numChannels;
        for (var i = 0; i < uniforms.numChannels; i = i + 1) {
          let flatIndex = flatIndexBase + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndexBase);
            let values = ${e};
            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
  }
  getUserCode() {
    return this.makeFromPixelsSource();
  }
  setPipeline(e) {
    this.pipeline = e;
  }
  setUniform(e, t) {
    if (!this.uniform) {
      let n10 = e.createBuffer({ size: t.length * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      this.uniform = n10;
    }
    !t || t.length === this.lastUniformData.length && t.every((n10, s10) => n10 === this.lastUniformData[s10]) || (e.queue.writeBuffer(this.uniform, 0, new Uint32Array(t)), this.lastUniformData = t);
  }
  makeInputTexture(e, t, n10) {
    return (!this.inputTexture || this.lastPixelSize.width !== t || this.lastPixelSize.height !== n10) && (this.inputTexture && this.inputTexture.destroy(), this.inputTexture = e.createTexture({ size: [t, n10], format: "rgba8unorm", usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING }), this.lastPixelSize.width = t, this.lastPixelSize.height = n10), this.inputTexture;
  }
  dispose() {
    this.disposed || (this.uniform && this.uniform.destroy(), this.inputTexture && this.inputTexture.destroy(), this.disposed = true);
  }
  getLayout(e) {
    return this.layout === null && (this.layout = this.createTextureLayout(e)), this.layout;
  }
  createTextureLayout(e) {
    let t = [];
    t.push({ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } }), t.push({ binding: 1, visibility: GPUShaderStage.COMPUTE, texture: {} }), t.push({ binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {} });
    let n10 = e.createBindGroupLayout({ entries: t }), s10 = e.createPipelineLayout({ bindGroupLayouts: [n10] });
    return { bindGroupLayout: n10, pipelineLayout: s10 };
  }
};
var Uie = class extends E2 {
  constructor() {
    super(...arguments);
    this.layout = null, this.useImport = true;
  }
  getUserCode() {
    return this.makeFromPixelsSource();
  }
  getLayout(e) {
    return this.layout === null && (this.layout = this.createTextureImportLayout(e)), this.layout;
  }
  createTextureImportLayout(e) {
    let t = [];
    t.push({ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } }), t.push({ binding: 1, visibility: GPUShaderStage.COMPUTE, externalTexture: {} }), t.push({ binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {} });
    let n10 = e.createBindGroupLayout({ entries: t }), s10 = e.createPipelineLayout({ bindGroupLayouts: [n10] });
    return { bindGroupLayout: n10, pipelineLayout: s10 };
  }
};
var Gie = X2().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");
var Rw = (e, t) => {
  let n10 = e.limits.maxComputeWorkgroupsPerDimension, s10 = t.dispatchLayout, r10 = t.dispatch;
  if (r10.every((i10) => i10 <= n10))
    return r10;
  w2.assert(r10[0] > n10 && s10.y === void 0 && s10.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
  let a10 = Math.ceil(Math.sqrt(r10[0]));
  return a10 > n10 ? (a10 = Math.ceil(Math.cbrt(r10[0])), w2.assert(a10 <= n10, () => "Total dispatch size exceeds WebGPU maximum."), [a10, a10, a10]) : [a10, a10, 1];
};
var R2 = class extends tl {
  constructor(e, t = false) {
    super();
    if (this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.tensorDisposalQueue = [], this.uniformDisposalQueue = [], this.stagingDisposalQueue = [], this.disposed = false, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.dispatchNumberInEncoder = 0, !Sv())
      throw new Error("WebGPU is not supported on this device");
    this.layoutCache = {}, this.pipelineCache = {}, this.device = e, this.queue = e.queue, this.currentCommandEncoder = null, this.currentComputePass = null, this.supportTimeQuery = t, this.bufferManager = new Wie(this.device), this.tensorMap = new Wd(this, Ss()), this.supportTimeQuery && (this.querySet = this.device.createQuerySet({ type: "timestamp", count: 2 })), X2().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), this.dummyContext.configure({ device: e, format: "bgra8unorm" }), document.body.appendChild(this.dummyCanvas));
  }
  nextDataId() {
    return R2.nextDataId++;
  }
  floatPrecision() {
    return 32;
  }
  defaultGpuBufferUsage() {
    return GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
  }
  flushDisposalQueue() {
    this.tensorDisposalQueue.forEach((e) => {
      this.maybeReleaseBuffer(e), this.tensorMap.delete(e);
    }), this.uniformDisposalQueue.forEach((e) => this.bufferManager.releaseBuffer(e.buffer, e.byteSize, e.usage)), this.stagingDisposalQueue.forEach((e) => this.bufferManager.releaseUploadBuffer(e.buffer, e.byteSize, e.usage)), this.tensorDisposalQueue = [], this.uniformDisposalQueue = [], this.stagingDisposalQueue = [];
  }
  disposeData(e, t = false) {
    if (this.tensorMap.has(e)) {
      let n10 = this.tensorMap.get(e);
      if (n10.refCount--, !t && n10.refCount > 0)
        return false;
      if (this.commandQueueOwnedIds.has(e))
        return this.tensorDisposalQueue.push(e), false;
      this.maybeReleaseBuffer(e);
      let { complexTensorInfos: s10 } = this.tensorMap.get(e);
      s10 != null && (this.disposeData(s10.real.dataId, true), this.disposeData(s10.imag.dataId, true)), this.tensorMap.delete(e);
    }
    return true;
  }
  memory() {
    return { numBytesInGPU: this.bufferManager.numBytesUsed, numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated, unreliable: false };
  }
  getBufferManager() {
    return this.bufferManager;
  }
  acquireBuffer(e, t = this.defaultGpuBufferUsage()) {
    return this.bufferManager.acquireBuffer(e, t);
  }
  maybeReleaseBuffer(e) {
    let t = this.tensorMap.get(e);
    t != null && t.bufferInfo.buffer != null && (this.bufferManager.releaseBuffer(t.bufferInfo.buffer, t.bufferInfo.byteSize, t.bufferInfo.usage), t.bufferInfo.buffer = null);
  }
  refCount(e) {
    return this.tensorMap.has(e) ? this.tensorMap.get(e).refCount : 0;
  }
  incRef(e) {
    let t = this.tensorMap.get(e);
    t.refCount++;
  }
  decRef(e) {
    if (this.tensorMap.has(e)) {
      let t = this.tensorMap.get(e);
      t.refCount--;
    }
  }
  write(e, t, n10) {
    if (n10 === "complex64" && e != null)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    let s10 = { id: this.nextDataId() }, r10 = w2.sizeFromShape(t) * Hm(n10);
    return this.tensorMap.set(s10, { dtype: n10, values: e, bufferInfo: { byteSize: r10, usage: this.defaultGpuBufferUsage() }, refCount: 1 }), s10;
  }
  move(e, t, n10, s10, r10) {
    if (s10 === "complex64")
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    let a10 = w2.sizeFromShape(n10) * Hm(s10);
    this.tensorMap.set(e, { dtype: s10, values: t, bufferInfo: { byteSize: a10, usage: this.defaultGpuBufferUsage() }, refCount: r10 });
  }
  submitQueue() {
    this.ensureComputePassEnded(), this.queue.submit([this.currentCommandEncoder.finish()]), this.currentCommandEncoder = null, this.dispatchNumberInEncoder = 0, this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.flushDisposalQueue();
  }
  getBuffer(e) {
    return this.uploadToGPU(e), this.tensorMap.get(e).bufferInfo.buffer;
  }
  getFromPixelsProgram(e) {
    switch (e) {
      case "copyExternal":
        return this.fromPixelProgram || (this.fromPixelProgram = new E2()), this.fromPixelProgram;
      case "import":
        return this.fromPixelImportProgram || (this.fromPixelImportProgram = new Uie()), this.fromPixelImportProgram;
      default:
        w2.assert(false, () => "Unsupported fromPixels shape");
        return;
    }
  }
  ensureCommandEncoderReady() {
    this.currentCommandEncoder || (this.currentCommandEncoder = this.device.createCommandEncoder());
  }
  ensureComputePassEnded() {
    this.currentComputePass && (this.currentComputePass.endPass(), this.currentComputePass = null);
  }
  getComputePass() {
    return this.currentComputePass || (this.currentComputePass = this.currentCommandEncoder.beginComputePass()), this.currentComputePass;
  }
  async getBufferData(e) {
    if (e.values != null)
      return e.values;
    let t = this.acquireBuffer(e.bufferInfo.byteSize, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
    this.ensureCommandEncoderReady(), this.ensureComputePassEnded(), this.currentCommandEncoder.copyBufferToBuffer(e.bufferInfo.buffer, 0, t, 0, e.bufferInfo.byteSize), this.submitQueue(), await t.mapAsync(GPUMapMode.READ);
    let n10 = t.getMappedRange().slice(0);
    return t.unmap(), t != null && this.bufferManager.releaseBuffer(t, e.bufferInfo.byteSize, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ), X2().getBool("WEBGPU_USE_PROFILE_TOOL") && (w2.assert(this.dummyContext !== void 0, () => "Fail to get context for profiling tool"), this.dummyContext.getCurrentTexture()), n10;
  }
  convertAndCacheOnCPU(e, t) {
    let n10 = this.tensorMap.get(e);
    return this.maybeReleaseBuffer(e), n10.values = t, n10.values;
  }
  readSync(e) {
    let t = this.tensorMap.get(e), { values: n10 } = t;
    if (n10 == null)
      throw new Error("WebGPU readSync is only available for CPU-resident tensors.");
    return n10;
  }
  async read(e) {
    if (!this.tensorMap.has(e))
      throw new Error(`Tensor ${e} was not registered!`);
    let t = this.tensorMap.get(e), { values: n10 } = t;
    if (n10 != null)
      return this.convertAndCacheOnCPU(e, n10);
    let s10;
    if (t.dtype === "complex64") {
      let r10 = await Promise.all([this.read(t.complexTensorInfos.real.dataId), this.read(t.complexTensorInfos.imag.dataId)]), a10 = r10[0], i10 = r10[1];
      s10 = N2.mergeRealAndImagArrays(a10, i10);
    } else {
      let r10 = await this.getBufferData(t);
      s10 = u2(r10, t.dtype);
    }
    return this.convertAndCacheOnCPU(e, s10), s10;
  }
  bufferSync(e) {
    let t = this.readSync(e.dataId), n10 = t;
    if (e.dtype === "string")
      try {
        n10 = t.map((s10) => w2.decodeString(s10));
      } catch (s10) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return De(e.shape, e.dtype, n10);
  }
  async time(e) {
    let t = this.activeTimers, n10 = [], s10 = false;
    this.programTimersStack == null ? (this.programTimersStack = n10, s10 = true) : this.activeTimers.push(n10), this.activeTimers = n10, e();
    let r10 = w2.flatten(this.activeTimers.map((u10) => u10.query)).filter((u10) => u10 != null), a10 = w2.flatten(this.activeTimers.map((u10) => u10.name)).filter((u10) => u10 != null);
    this.activeTimers = t, s10 && (this.programTimersStack = null);
    let i10 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, o10 = await Promise.all(r10);
    return i10.kernelMs = w2.sum(o10), i10.getExtraProfileInfo = () => o10.map((u10, l10) => ({ name: a10[l10], ms: u10 })).map((u10) => `${u10.name}: ${u10.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, i10;
  }
  getAndSavePipeline(e, t) {
    return e in this.pipelineCache || (this.pipelineCache[e] = t()), this.pipelineCache[e];
  }
  makeTensorInfo(e, t, n10) {
    let s10;
    if (t === "string" && n10 != null && n10.length > 0 && w2.isString(n10[0])) {
      let r10 = n10.map((a10) => w2.encodeString(a10));
      s10 = this.write(r10, e, t);
    } else
      s10 = this.write(n10, e, t);
    return { dataId: s10, shape: e, dtype: t };
  }
  tensorToBinding(e) {
    if (!e)
      return null;
    let t = this.tensorMap.get(e.dataId);
    return { offset: 0, size: t.bufferInfo.byteSize, buffer: t.bufferInfo.buffer };
  }
  async getQueryTime(e) {
    return this.supportTimeQuery ? this.getTimeFromQuerySet(e) : 0;
  }
  uploadToGPU(e) {
    let t = this.tensorMap.get(e);
    if (t.bufferInfo.buffer == null && (t.bufferInfo.buffer = this.acquireBuffer(t.bufferInfo.byteSize), t.values)) {
      let n10 = this.bufferManager.acquireUploadBuffer(t.bufferInfo.byteSize, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC), s10 = n10.getMappedRange();
      t.dtype === "int32" || t.dtype === "bool" ? new Int32Array(s10).set(t.values) : new Float32Array(s10).set(t.values), n10.unmap(), this.ensureCommandEncoderReady(), this.ensureComputePassEnded(), this.currentCommandEncoder.copyBufferToBuffer(n10, 0, t.bufferInfo.buffer, 0, t.bufferInfo.byteSize);
      let r10 = { byteSize: t.bufferInfo.byteSize, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, buffer: n10 };
      this.stagingDisposalQueue.push(r10);
    }
  }
  makeUniforms(e) {
    let t = 0, n10 = [];
    e.forEach((a10) => {
      a10.data.length === 0 && (a10.data = [1]);
      let i10;
      switch (a10.data.length) {
        case 1:
          i10 = 4;
          break;
        case 2:
          i10 = 8;
          break;
        case 3:
          i10 = 16;
          break;
        case 4:
          i10 = 16;
          break;
        default:
          w2.assert(false, () => `Unsupported ${a10.data.length}D shape`);
      }
      t = Math.ceil(t / i10) * i10, n10.push(t), t += a10.data.length * 4;
    });
    let s10 = new ArrayBuffer(t);
    e.forEach((a10, i10) => {
      let o10 = n10[i10];
      a10.type === "int32" ? new Int32Array(s10, o10, a10.data.length).set(a10.data) : a10.type === "uint32" ? new Uint32Array(s10, o10, a10.data.length).set(a10.data) : new Float32Array(s10, o10, a10.data.length).set(a10.data);
    });
    let r10 = this.acquireBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
    return this.queue.writeBuffer(r10, 0, s10, 0, t), { offset: 0, size: t, buffer: r10 };
  }
  createLayout(e) {
    let t = [];
    t.push({ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } });
    for (let r10 = 0; r10 < e; r10++)
      t.push({ binding: r10 + 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } });
    t.push({ binding: e + 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } });
    let n10 = this.device.createBindGroupLayout({ entries: t }), s10 = this.device.createPipelineLayout({ bindGroupLayouts: [n10] });
    return { bindGroupLayout: n10, pipelineLayout: s10 };
  }
  getCachedOrCreateLayout(e) {
    return e in this.layoutCache || (this.layoutCache[e] = this.createLayout(e)), this.layoutCache[e];
  }
  runWebGPUProgram(e, t, n10, s10, r10) {
    if (!r10) {
      if (r10 = this.makeTensorInfo(e.outputShape, n10), w2.sizeFromShape(r10.shape) === 0) {
        let T10 = this.tensorMap.get(r10.dataId);
        return T10.values = w2.getTypedArrayFromDType(r10.dtype, 0), r10;
      }
      this.uploadToGPU(r10.dataId);
    }
    e.dispatch = Rw(this.device, e);
    let a10 = [{ type: "float32", data: [NaN] }], i10 = t.concat(r10).map((T10) => T10.shape), o10 = "int32";
    i10.map((T10) => {
      a10.push({ type: o10, data: T10 });
    });
    let u10 = w2.computeStrides(r10.shape);
    if (a10.push({ type: o10, data: u10 }), e.size) {
      let T10 = w2.sizeFromShape(e.outputShape);
      a10.push({ type: o10, data: [e.isVec4 ? T10 / 4 : T10] });
    }
    s10 && (a10 = [...a10, ...s10]);
    let l10 = this.makeUniforms(a10), c10 = t.map((T10, E10) => {
      if (T10.dtype === "complex64")
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      return this.uploadToGPU(T10.dataId), { dtype: this.tensorMap.get(T10.dataId).dtype, shape: T10.shape, name: e.variableNames[E10] };
    }), p10 = c10.map((T10) => T10.dtype).concat(r10.dtype), d10 = c10.map((T10) => N2.getBroadcastDims(T10.shape, r10.shape)), h10 = c10.map((T10) => w2.arraysEqual(T10.shape, r10.shape)).join("_"), f10 = d10.map((T10) => T10.join("_")).join(";"), m10 = S2(e, i10, p10, f10, h10), { bindGroupLayout: g10, pipelineLayout: b10 } = this.getCachedOrCreateLayout(e.variableNames.length), y10 = this.getAndSavePipeline(m10, () => I22(this.device, e, b10, c10, r10)), v10 = this.activeTimers != null, x10 = Ire(this.device, g10, t.map((T10) => this.tensorToBinding(T10)), this.tensorToBinding(r10), l10);
    this.ensureCommandEncoderReady();
    let k10 = this.getComputePass();
    v10 && this.supportTimeQuery && k10.writeTimestamp(this.querySet, 0), k10.setPipeline(y10), k10.setBindGroup(0, x10), k10.dispatch(e.dispatch[0], e.dispatch[1], e.dispatch[2]), v10 && this.supportTimeQuery && k10.writeTimestamp(this.querySet, 1), this.dispatchNumberInEncoder++, t.forEach((T10) => {
      this.commandQueueOwnedIds.add(T10.dataId);
    }), this.commandQueueOwnedIds.add(r10.dataId);
    let C10 = { byteSize: l10.size, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, buffer: l10.buffer };
    return this.uniformDisposalQueue.push(C10), X2().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchNumberInEncoder && this.submitQueue(), v10 && this.activeTimers.push({ name: e.constructor.name, query: this.getQueryTime(this.querySet) }), r10;
  }
  runFromPixelsProgram(e, t, n10, s10, r10) {
    e.dispatch = Rw(this.device, e);
    let a10 = this.device.createBindGroup({ layout: n10.bindGroupLayout, entries: [{ binding: 0, resource: { buffer: t } }, { binding: 1, resource: s10 }, { binding: 2, resource: { buffer: e.uniform } }] });
    this.ensureCommandEncoderReady();
    let i10 = this.getComputePass(), o10 = this.activeTimers != null;
    o10 && this.supportTimeQuery && i10.writeTimestamp(this.querySet, 0), i10.setPipeline(e.pipeline), i10.setBindGroup(0, a10), i10.dispatch(e.dispatch[0], e.dispatch[1], e.dispatch[2]), o10 && this.supportTimeQuery && i10.writeTimestamp(this.querySet, 1), this.commandQueueOwnedIds.add(r10), this.submitQueue(), o10 && this.activeTimers.push({ name: e.constructor.name, query: this.getQueryTime(this.querySet) });
  }
  async getTimeFromQuerySet(e) {
    let t = this.acquireBuffer(16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE), n10 = this.acquireBuffer(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    this.ensureCommandEncoderReady(), this.ensureComputePassEnded(), this.currentCommandEncoder.resolveQuerySet(e, 0, 2, t, 0), this.currentCommandEncoder.copyBufferToBuffer(t, 0, n10, 0, 16), this.submitQueue(), await n10.mapAsync(GPUMapMode.READ);
    let s10 = new BigUint64Array(n10.getMappedRange()), r10 = Number(s10[1] - s10[0]);
    return n10.unmap(), this.bufferManager.releaseBuffer(n10, 16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST), this.bufferManager.releaseBuffer(t, 16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE), r10 / 1e6;
  }
  shouldExecuteOnCPU(e, t = Gie) {
    return X2().getBool("WEBGPU_CPU_FORWARD") && e.every((n10) => this.tensorMap.get(n10.dataId).bufferInfo.buffer == null && w2.sizeFromShape(n10.shape) < t);
  }
  numDataIds() {
    return this.tensorMap.numDataIds() - this.tensorDisposalQueue.length;
  }
  dispose() {
    this.disposed || (this.bufferManager.dispose(), this.fromPixelProgram && this.fromPixelProgram.dispose(), this.fromPixelImportProgram && this.fromPixelImportProgram.dispose(), this.disposed = true);
  }
};
var $v = R2;
$v.nextDataId = 0;
var Hie = {};
Ae(Hie, { WebGPUBackend: () => $v, webgpu_util: () => i2 });
Sv() && dp("webgpu", async () => {
  X2().set("CHECK_COMPUTATION_FOR_ERRORS", false);
  let e = { powerPreference: X2().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance" }, t = await navigator.gpu.requestAdapter(e), n10 = t.limits, s10 = {}, r10 = t.features.has("timestamp-query");
  s10.requiredLimits = { maxComputeWorkgroupStorageSize: n10.maxComputeWorkgroupStorageSize, maxComputeWorkgroupsPerDimension: n10.maxComputeWorkgroupsPerDimension }, r10 ? s10.requiredFeatures = ["timestamp-query"] : console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");
  let a10 = await t.requestDevice(s10);
  return new $v(a10, r10);
}, 3);
var Ct = ((e) => (e[e.float32 = 0] = "float32", e[e.int32 = 1] = "int32", e[e.bool = 2] = "bool", e[e.string = 3] = "string", e[e.complex64 = 4] = "complex64", e))(Ct || {});
var Zp = ((e) => (e[e.linear = 0] = "linear", e[e.relu = 1] = "relu", e[e.relu6 = 2] = "relu6", e[e.prelu = 3] = "prelu", e[e.leakyrelu = 4] = "leakyrelu", e[e.sigmoid = 5] = "sigmoid", e[e.elu = 6] = "elu", e))(Zp || {});
var D2;
function qie(e) {
  D2 = e.wasm.cwrap(na, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function jie(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10, bias: i10, preluActivationWeights: o10 } = t;
  if (r10.dtype !== "float32" || a10.dtype !== "float32")
    throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
  let { transposeA: u10, transposeB: l10, activation: c10, leakyreluAlpha: p10 } = s10, d10 = n10.dataIdMap.get(r10.dataId).id, h10 = n10.dataIdMap.get(a10.dataId).id, f10 = 0;
  if (i10 != null) {
    let E10 = n10.dataIdMap.get(i10.dataId);
    if (E10.shape.length !== 1)
      throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E10.shape.length}.`);
    f10 = E10.id;
  }
  let m10 = o10 == null ? 0 : n10.dataIdMap.get(o10.dataId).id, g10 = Zp[c10];
  if (g10 == null)
    throw new Error(`${c10} activation not yet supported for FusedConv2D in the wasm backend.`);
  let b10 = u10 ? r10.shape[2] : r10.shape[1], y10 = l10 ? a10.shape[1] : a10.shape[2], v10 = qo.assertAndGetBroadcastShape(r10.shape.slice(0, -2), a10.shape.slice(0, -2)), x10 = n10.makeOutput([...v10, b10, y10], r10.dtype), k10 = n10.dataIdMap.get(x10.dataId).id, C10 = new Uint8Array(new Int32Array(r10.shape).buffer), T10 = new Uint8Array(new Int32Array(a10.shape).buffer);
  return D2(d10, C10, r10.shape.length, h10, T10, a10.shape.length, u10, l10, g10, f10, m10, p10 || 0, k10), x10;
}
var Kie = { kernelName: na, backendName: "wasm", setupFunc: qie, kernelFunc: jie };
function Kt(e, t) {
  let n10;
  function s10(a10) {
    n10 = a10.wasm.cwrap(e, null, ["number", "number", "number"]);
  }
  function r10(a10) {
    let { backend: i10, inputs: { x: o10 } } = a10, u10 = i10.dataIdMap.get(o10.dataId).id, l10 = i10.makeOutput(o10.shape, t || o10.dtype), c10 = i10.dataIdMap.get(l10.dataId).id;
    return w2.sizeFromShape(l10.shape) === 0 || n10(u10, Ct[o10.dtype], c10), l10;
  }
  return { kernelName: e, backendName: "wasm", setupFunc: s10, kernelFunc: r10 };
}
var Xie = Kt(ao);
function mn(e, t, n10) {
  let s10;
  function r10(i10) {
    s10 = i10.wasm.cwrap(e, null, ["number", "array", "number", "number", "array", "number", "number", "number"]);
  }
  function a10(i10) {
    let { backend: o10, inputs: u10 } = i10, { a: l10, b: c10 } = u10, p10 = o10.dataIdMap.get(l10.dataId).id, d10 = o10.dataIdMap.get(c10.dataId).id, h10 = n10 != null ? n10 : l10.dtype, f10 = N2.assertAndGetBroadcastShape(l10.shape, c10.shape), m10 = o10.makeOutput(f10, h10);
    if (w2.sizeFromShape(f10) === 0)
      return m10;
    let g10 = new Uint8Array(new Int32Array(l10.shape).buffer), b10 = new Uint8Array(new Int32Array(c10.shape).buffer), y10 = o10.dataIdMap.get(m10.dataId).id;
    return (() => s10(p10, g10, l10.shape.length, d10, b10, c10.shape.length, Ct[l10.dtype], y10))(), m10;
  }
  return { kernelName: e, backendName: "wasm", setupFunc: r10, kernelFunc: a10 };
}
var Yie = true;
var Qie = mn(kr, Yie);
var F2;
function Zie(e) {
  F2 = e.wasm.cwrap(xa, null, ["array", "number", "number", "number"]);
}
function Jie(e) {
  let { inputs: t, backend: n10 } = e, s10 = n10.makeOutput(t[0].shape, t[0].dtype);
  if (w2.sizeFromShape(s10.shape) === 0)
    return s10;
  let r10 = t.map((o10) => n10.dataIdMap.get(o10.dataId).id), a10 = new Uint8Array(new Int32Array(r10).buffer), i10 = n10.dataIdMap.get(s10.dataId).id;
  return F2(a10, r10.length, Ct[s10.dtype], i10), s10;
}
var eoe = { kernelName: xa, backendName: "wasm", setupFunc: Zie, kernelFunc: Jie };
function Jp(e) {
  let { inputs: { x: t }, backend: n10 } = e, s10 = n10.makeOutput(t.shape, t.dtype), r10 = n10.typedArrayFromHeap(t);
  return n10.typedArrayFromHeap(s10).set(r10), s10;
}
var toe = { kernelName: Ma, backendName: "wasm", kernelFunc: Jp };
var O22;
function noe(e) {
  O22 = e.wasm.cwrap(ci, null, ["number", "array", "number", "number", "number", "array", "number"]);
}
function so(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, [r10, a10] = roe(t.x.shape, s10.perm), i10 = true;
  for (let f10 = 0; f10 < a10.length; f10++)
    a10[f10] !== f10 && (i10 = false);
  let o10 = soe(t.x.shape, s10.perm), u10 = { dataId: t.x.dataId, shape: r10, dtype: t.x.dtype };
  if (i10) {
    let f10 = Jp({ inputs: t, backend: n10 });
    return f10.shape = o10, f10;
  }
  let l10 = n10.makeOutput(o10, u10.dtype), c10 = n10.dataIdMap.get(u10.dataId).id, p10 = n10.dataIdMap.get(l10.dataId).id, d10 = new Uint8Array(new Int32Array(a10).buffer), h10 = new Uint8Array(new Int32Array(u10.shape).buffer);
  return O22(c10, h10, u10.shape.length, Ct[u10.dtype], p10, d10, a10.length), l10;
}
function soe(e, t) {
  let n10 = new Array(e.length);
  for (let s10 = 0; s10 < n10.length; s10++)
    n10[s10] = e[t[s10]];
  return n10;
}
function roe(e, t) {
  let n10 = [], s10 = [];
  for (let r10 = 0; r10 < e.length; ++r10)
    e[r10] !== 1 && n10.push(e[r10]), e[t[r10]] !== 1 && s10.push(t[r10]);
  for (let r10 = 0; r10 < s10.length; ++r10) {
    let a10 = -1;
    for (let i10 = 0; i10 < s10.length; ++i10)
      s10[i10] >= r10 && (a10 === -1 || s10[a10] > s10[i10]) && (a10 = i10);
    s10[a10] = r10;
  }
  return [n10, s10];
}
var aoe = { kernelName: ci, backendName: "wasm", kernelFunc: so, setupFunc: noe };
function Dr(e, t, n10) {
  let s10 = e.shape, r10 = e.shape.length, a10 = w2.parseAxisParam(t, s10), i10 = a10, o10 = N2.getAxesPermutation(i10, r10), u10 = null, l10 = false;
  if (o10 != null) {
    let c10 = new Array(r10);
    for (let h10 = 0; h10 < c10.length; h10++)
      c10[h10] = s10[o10[h10]];
    i10 = N2.getInnerMostAxes(i10.length, r10), u10 = so({ inputs: { x: e }, attrs: { perm: o10 }, backend: n10 });
    let p10 = n10.dataIdMap.get(e.dataId).id;
    n10.dataIdMap.get(u10.dataId).id !== p10 && (l10 = true);
  }
  return { transposed: u10, originalAxes: a10, axes: i10, inputWasTransposed: l10 };
}
var P2;
function ioe(e) {
  P2 = e.wasm.cwrap(rl, null, ["number, number, number"]);
}
function ooe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, u10 = t.dataIdMap.get(i10.dataId).id, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t);
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    l10 = c10, u10 = v10;
  }
  let f10 = l10.shape.length;
  N2.assertAxesAreInnerMostDims("all", p10, f10);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, p10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, i10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    P2(u10, b10, v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var uoe = { kernelName: rl, backendName: "wasm", setupFunc: ioe, kernelFunc: ooe };
var z2;
function loe(e) {
  z2 = e.wasm.cwrap(al, null, ["number, number, number"]);
}
function coe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, u10 = t.dataIdMap.get(i10.dataId).id, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t);
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    l10 = c10, u10 = v10;
  }
  let f10 = l10.shape.length;
  N2.assertAxesAreInnerMostDims("any", p10, f10);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, p10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, i10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    z2(u10, b10, v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var doe = { kernelName: al, backendName: "wasm", setupFunc: loe, kernelFunc: coe };
var M22;
function poe(e) {
  M22 = e.wasm.cwrap(wa, null, ["number", "number", "number", "number", "number"]);
}
function hoe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10 } = s10, { x: a10 } = n10, i10 = t.dataIdMap.get(a10.dataId).id, o10 = i10, u10 = a10, { transposed: l10, axes: c10, inputWasTransposed: p10 } = Dr(a10, r10, t);
  if (p10) {
    let b10 = t.dataIdMap.get(l10.dataId).id;
    b10 !== i10 && (u10 = l10, o10 = b10);
  }
  let d10 = u10.shape.slice(0, -1), h10 = t.makeOutput(d10, "int32"), f10 = t.dataIdMap.get(h10.dataId).id, m10 = w2.sizeFromShape(h10.shape), g10 = u10.shape[c10[0]];
  return M22(o10, Ct[u10.dtype], m10, g10, f10), p10 && t.disposeData(l10.dataId), h10;
}
var foe = { kernelName: wa, backendName: "wasm", kernelFunc: hoe, setupFunc: poe };
var L22;
function moe(e) {
  L22 = e.wasm.cwrap(ka, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function goe(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, r10 = t.x, a10 = s10.dataIdMap.get(r10.dataId).id, { filterSize: i10, strides: o10, pad: u10, dimRoundingMode: l10 } = n10, c10 = N2.computePool2DInfo(r10.shape, i10, o10, 1, u10, l10), p10 = c10.filterHeight, d10 = c10.filterWidth, h10 = c10.padInfo.top, f10 = c10.padInfo.right, m10 = c10.padInfo.bottom, g10 = c10.padInfo.left, b10 = c10.strideHeight, y10 = c10.strideWidth, v10 = c10.inChannels;
  if (c10.dataFormat !== "channelsLast")
    throw new Error(`wasm backend does not support dataFormat:'${c10.dataFormat}'. Please use 'channelsLast'.`);
  if (c10.dilationWidth !== 1 || c10.dilationHeight !== 1)
    throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c10.dilationHeight}, ${c10.dilationWidth}].`);
  let x10 = s10.makeOutput(c10.outShape, "float32"), k10 = s10.dataIdMap.get(x10.dataId).id;
  return L22(a10, r10.shape[0], r10.shape[1], r10.shape[2], p10, d10, h10, f10, m10, g10, b10, y10, v10, k10), x10;
}
var boe = { kernelName: ka, backendName: "wasm", setupFunc: moe, kernelFunc: goe };
function bn(e) {
  let { inputs: t, attrs: n10 } = e, { x: s10 } = t, { shape: r10 } = n10, a10 = w2.sizeFromShape(s10.shape), i10 = w2.inferFromImplicitShape(r10, a10);
  return w2.assert(a10 === w2.sizeFromShape(i10), () => `new shape: ${i10}, old shape: ${s10.shape}. New shape and old shape must have the same number of elements.`), e.backend.incRef(s10.dataId), { dataId: s10.dataId, shape: i10, dtype: s10.dtype };
}
var yoe = { kernelName: Ao, backendName: "wasm", kernelFunc: bn };
var B2;
function voe(e) {
  B2 = e.wasm.cwrap(Ia, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number"]);
}
function xoe(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { a: r10, b: a10 } = t, { transposeA: i10, transposeB: o10 } = s10;
  if (r10.dtype !== "float32" || a10.dtype !== "float32")
    throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
  let u10 = r10.shape.length, l10 = a10.shape.length, c10 = i10 ? r10.shape[u10 - 2] : r10.shape[u10 - 1], p10 = o10 ? a10.shape[l10 - 1] : a10.shape[l10 - 2], d10 = i10 ? r10.shape[u10 - 1] : r10.shape[u10 - 2], h10 = o10 ? a10.shape[l10 - 2] : a10.shape[l10 - 1], f10 = r10.shape.slice(0, -2), m10 = a10.shape.slice(0, -2), g10 = w2.sizeFromShape(f10), b10 = w2.sizeFromShape(m10), v10 = qo.assertAndGetBroadcastShape(r10.shape.slice(0, -2), a10.shape.slice(0, -2)).concat([d10, h10]);
  w2.assert(c10 === p10, () => `Error in matMul: inner shapes (${c10}) and (${p10}) of Tensors with shapes ${r10.shape} and ${a10.shape} and transposeA=${i10} and transposeB=${o10} must match.`);
  let x10 = i10 ? [g10, c10, d10] : [g10, d10, c10], k10 = o10 ? [b10, h10, p10] : [b10, p10, h10], C10 = bn({ inputs: { x: r10 }, backend: n10, attrs: { shape: x10 } }), T10 = bn({ inputs: { x: a10 }, backend: n10, attrs: { shape: k10 } }), E10 = n10.dataIdMap.get(C10.dataId).id, A10 = n10.dataIdMap.get(T10.dataId).id, P10 = i10 ? C10.shape[2] : C10.shape[1], R10 = o10 ? T10.shape[1] : T10.shape[2], F10 = Math.max(g10, b10), $10 = n10.makeOutput([F10, P10, R10], C10.dtype), z10 = n10.dataIdMap.get($10.dataId).id, W10 = new Uint8Array(new Int32Array(C10.shape).buffer), q10 = new Uint8Array(new Int32Array(T10.shape).buffer);
  return B2(E10, W10, C10.shape.length, A10, q10, T10.shape.length, i10, o10, z10), n10.disposeData(C10.dataId), n10.disposeData(T10.dataId), $10.shape = v10, $10;
}
var woe = { kernelName: Ia, backendName: "wasm", setupFunc: voe, kernelFunc: xoe };
function ba(e) {
  let { inputs: { x: t }, attrs: { begin: n10, size: s10 }, backend: r10 } = e, [a10, i10] = wt.parseSliceParams(t, n10, s10), o10 = wt.isSliceContinous(t.shape, a10, i10), u10 = r10.readSync(t.dataId), l10 = r10.makeOutput(i10, t.dtype), c10 = w2.computeStrides(t.shape), p10 = r10.dataIdMap.get(l10.dataId);
  if (o10) {
    let f10 = wt.computeFlatOffset(a10, c10);
    return t.dtype === "string" ? p10.stringBytes = u10.slice(f10, f10 + w2.sizeFromShape(i10)) : r10.typedArrayFromHeap(l10).set(u10.subarray(f10, f10 + w2.sizeFromShape(i10))), l10;
  }
  if (t.dtype === "string") {
    let f10 = Dd(u10, a10, i10, t.shape, t.dtype);
    return p10.stringBytes = f10, l10;
  }
  let d10 = r10.typedArrayFromHeap(l10), h10 = t.shape.length;
  if (h10 === 2)
    koe(u10, c10[0], d10, a10, i10);
  else if (h10 === 3)
    Ioe(u10, c10[0], c10[1], d10, a10, i10);
  else if (h10 === 4)
    Soe(u10, c10[0], c10[1], c10[2], d10, a10, i10);
  else {
    let f10 = Dd(u10, a10, i10, t.shape, t.dtype);
    d10.set(f10);
  }
  return l10;
}
function koe(e, t, n10, s10, r10) {
  let a10 = 0, i10 = s10[0], o10 = s10[1], u10 = i10 + r10[0];
  for (let l10 = i10; l10 < u10; l10++) {
    let c10 = l10 * t + o10;
    n10.set(e.subarray(c10, c10 + r10[1]), a10), a10 += r10[1];
  }
}
function Ioe(e, t, n10, s10, r10, a10) {
  let i10 = 0, o10 = r10[0], u10 = r10[1], l10 = r10[2], c10 = o10 + a10[0], p10 = u10 + a10[1];
  for (let d10 = o10; d10 < c10; d10++)
    for (let h10 = u10; h10 < p10; h10++) {
      let f10 = d10 * t + h10 * n10 + l10;
      s10.set(e.subarray(f10, f10 + a10[2]), i10), i10 += a10[2];
    }
}
function Soe(e, t, n10, s10, r10, a10, i10) {
  let o10 = 0, u10 = a10[0], l10 = a10[1], c10 = a10[2], p10 = u10 + i10[0], d10 = l10 + i10[1], h10 = c10 + i10[2], f10 = a10[3];
  for (let m10 = u10; m10 < p10; m10++)
    for (let g10 = l10; g10 < d10; g10++)
      for (let b10 = c10; b10 < h10; b10++) {
        let y10 = m10 * t + g10 * n10 + b10 * s10 + f10;
        r10.set(e.subarray(y10, y10 + i10[3]), o10), o10 += i10[3];
      }
}
var Coe = { kernelName: Oo, backendName: "wasm", kernelFunc: ba };
function Noe(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, crops: i10 } = s10, o10 = a10.reduce((b10, y10) => b10 * y10), u10 = N2.getReshaped(r10.shape, a10, o10), l10 = N2.getPermuted(u10.length, a10.length), c10 = N2.getReshapedPermuted(r10.shape, a10, o10), p10 = N2.getSliceBeginCoords(i10, a10.length), d10 = N2.getSliceSize(c10, i10, a10.length), h10 = bn({ inputs: { x: r10 }, backend: n10, attrs: { shape: u10 } }), f10 = so({ inputs: { x: h10 }, backend: n10, attrs: { perm: l10 } }), m10 = bn({ inputs: { x: f10 }, backend: n10, attrs: { shape: c10 } }), g10 = ba({ inputs: { x: m10 }, backend: n10, attrs: { begin: p10, size: d10 } });
  return n10.disposeData(h10.dataId), n10.disposeData(f10.dataId), n10.disposeData(h10.dataId), g10;
}
var Toe = { kernelName: io, backendName: "wasm", kernelFunc: Noe };
function rc(e) {
  let { inputs: { x: t }, attrs: { dtype: n10 }, backend: s10 } = e, r10 = s10.makeOutput(t.shape, n10), a10 = s10.typedArrayFromHeap(t);
  return s10.typedArrayFromHeap(r10).set(a10), r10;
}
var $oe = { kernelName: Sa, backendName: "wasm", kernelFunc: rc };
var _oe = Kt(Ca);
var V22;
function Aoe(e) {
  V22 = e.wasm.cwrap(Ir, null, ["number", "number", "number", "number"]);
}
function Eoe(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { clipValueMin: a10, clipValueMax: i10 } = s10, o10 = n10.dataIdMap.get(r10.dataId).id, u10 = n10.makeOutput(r10.shape, r10.dtype), l10 = n10.dataIdMap.get(u10.dataId).id;
  return V22(o10, a10, i10, l10), u10;
}
var Roe = { kernelName: Ir, backendName: "wasm", setupFunc: Aoe, kernelFunc: Eoe };
function W2(e) {
  let { inputs: t, backend: n10 } = e, s10 = w2.parseAxisParam(e.attrs.axis, t[0].shape)[0], r10 = N2.computeOutShape(t.map((h10) => h10.shape), s10), a10 = t.filter((h10) => w2.sizeFromShape(h10.shape) > 0);
  if (a10.length === 1)
    return Jp({ inputs: { x: a10[0] }, backend: n10 });
  let i10 = n10.makeOutput(r10, t[0].dtype);
  if (w2.sizeFromShape(r10) === 0)
    return i10;
  let o10 = a10.map((h10) => h10.shape);
  if (N2.assertParamsConsistent(o10, s10), a10[0].dtype === "string") {
    let h10 = a10.map((v10) => {
      let x10 = w2.sizeFromShape(v10.shape.slice(s10));
      return bn({ inputs: { x: v10 }, backend: n10, attrs: { shape: [-1, x10] } });
    }), f10 = h10.map((v10) => ({ vals: n10.readSync(v10.dataId), shape: v10.shape }));
    r10 = N2.computeOutShape(h10.map((v10) => v10.shape), 1);
    let m10 = h10[0].shape[0] === 1, g10 = Jy(f10, r10, t[0].dtype, m10), b10 = N2.computeOutShape(a10.map((v10) => v10.shape), s10);
    i10.shape = b10;
    let y10 = n10.dataIdMap.get(i10.dataId);
    return y10.stringBytes = N2.fromStringArrayToUint8(g10), h10.forEach((v10) => n10.disposeData(v10.dataId)), i10;
  }
  let u10 = w2.sizeFromShape(a10[0].shape.slice(0, s10)), l10 = 0, c10 = a10.map((h10) => {
    let f10 = w2.sizeFromShape(h10.shape.slice(s10));
    return l10 += f10, f10;
  }), p10 = a10.map((h10) => n10.typedArrayFromHeap(h10)), d10 = n10.typedArrayFromHeap(i10);
  for (let h10 = 0; h10 < u10; h10++) {
    let f10 = h10 * l10;
    for (let m10 = 0; m10 < p10.length; m10++) {
      let g10 = c10[m10], b10 = h10 * g10, y10 = p10[m10].subarray(b10, b10 + g10);
      d10.set(y10, f10), f10 += g10;
    }
  }
  return i10;
}
var Doe = { kernelName: oo, backendName: "wasm", kernelFunc: W2 };
var U22;
function Foe(e) {
  U22 = e.wasm.cwrap(Na, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function Ooe(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10, filter: a10 } = t, i10 = s10.dataIdMap.get(r10.dataId).id, o10 = s10.dataIdMap.get(a10.dataId).id, { strides: u10, dilations: l10, pad: c10, dimRoundingMode: p10, dataFormat: d10 } = n10, h10 = N2.convertConv2DDataFormat(d10), f10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, l10, c10, p10, false, h10), m10 = f10.filterHeight, g10 = f10.filterWidth, b10 = f10.padInfo.top, y10 = f10.padInfo.right, v10 = f10.padInfo.bottom, x10 = f10.padInfo.left, k10 = f10.dilationHeight, C10 = f10.dilationWidth, T10 = f10.strideHeight, E10 = f10.strideWidth, A10 = f10.inChannels, P10 = f10.outChannels, R10 = f10.padInfo.type === "SAME" ? 1 : 0;
  if (f10.dataFormat !== "channelsLast")
    throw new Error(`wasm backend Conv2D does not support dataFormat:'${f10.dataFormat}'. Please use 'channelsLast'.`);
  let F10 = s10.makeOutput(f10.outShape, "float32"), $10 = s10.dataIdMap.get(F10.dataId).id;
  return U22(i10, r10.shape[0], r10.shape[1], r10.shape[2], o10, m10, g10, b10, y10, v10, x10, R10, k10, C10, T10, E10, A10, P10, $10), F10;
}
var Poe = { kernelName: Na, backendName: "wasm", setupFunc: Foe, kernelFunc: Ooe };
var G22;
function zoe(e) {
  G22 = e.wasm.cwrap(Ta, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function Moe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { dy: r10, filter: a10 } = n10, { strides: i10, pad: o10, dataFormat: u10, dimRoundingMode: l10, inputShape: c10 } = s10, p10 = 1, d10 = N2.convertConv2DDataFormat(u10), h10 = N2.computeConv2DInfo(c10, a10.shape, i10, p10, o10, l10, false, d10), { batchSize: f10, filterHeight: m10, filterWidth: g10, inChannels: b10, inHeight: y10, inWidth: v10, outChannels: x10, outHeight: k10, outWidth: C10, strideHeight: T10, strideWidth: E10 } = h10, A10 = m10 - 1 - h10.padInfo.top, P10 = g10 - 1 - h10.padInfo.left, R10 = h10.dataFormat === "channelsLast", F10 = w2.computeStrides(h10.inShape), $10 = w2.computeStrides(r10.shape), [z10, W10, q10] = w2.computeStrides(a10.shape), K10 = F10[0], Y10 = R10 ? F10[1] : F10[2], Z10 = R10 ? F10[2] : 1, te2 = R10 ? 1 : F10[1], ee2 = $10[0], se2 = R10 ? $10[1] : $10[2], ne2 = R10 ? $10[2] : 1, oe2 = R10 ? 1 : $10[1], re2 = t.makeOutput(h10.inShape, "float32"), le2 = t.dataIdMap.get(re2.dataId).id, me2 = t.dataIdMap.get(r10.dataId).id, we2 = t.dataIdMap.get(a10.dataId).id;
  return G22(me2, we2, f10, m10, g10, y10, v10, b10, k10, C10, x10, T10, E10, A10, P10, z10, W10, q10, K10, Y10, Z10, te2, ee2, se2, ne2, oe2, le2), re2;
}
var Loe = { kernelName: Ta, backendName: "wasm", setupFunc: zoe, kernelFunc: Moe };
var Boe = Kt($a);
var Voe = Kt(_a);
var H2 = ((e) => (e[e.bilinear = 0] = "bilinear", e[e.nearest = 1] = "nearest", e))(H2 || {});
var q2;
function Woe(e) {
  q2 = e.wasm.cwrap(lo, null, ["number", "number", "number", "number", "array", "number", "number", "number", "number", "number"]);
}
function Uoe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { method: r10, extrapolationValue: a10, cropSize: i10 } = s10, { image: o10, boxes: u10, boxInd: l10 } = n10, c10 = u10.shape[0], [p10, d10] = i10, h10 = [c10, p10, d10, o10.shape[3]], f10 = t.dataIdMap.get(o10.dataId), m10;
  o10.dtype !== "float32" && (m10 = rc({ backend: t, inputs: { x: o10 }, attrs: { dtype: "float32" } }), f10 = t.dataIdMap.get(m10.dataId));
  let g10 = f10.id, b10 = t.dataIdMap.get(u10.dataId).id, y10 = t.dataIdMap.get(l10.dataId).id, v10 = t.makeOutput(h10, "float32"), x10 = t.dataIdMap.get(v10.dataId).id, k10 = new Uint8Array(new Int32Array(o10.shape).buffer);
  return q2(g10, b10, y10, c10, k10, p10, d10, H2[r10], a10, x10), m10 != null && t.disposeData(m10.dataId), v10;
}
var Goe = { kernelName: lo, backendName: "wasm", setupFunc: Woe, kernelFunc: Uoe };
var j22;
function Hoe(e) {
  j22 = e.wasm.cwrap(uo, null, ["number", "number", "number", "number", "number", "number"]);
}
function qoe(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { axis: a10, exclusive: i10, reverse: o10 } = s10, u10 = r10.shape.length;
  w2.assert(r10.dtype === "float32" || r10.dtype === "int32", () => `cumsum does not support ${r10.dtype} tensors in the WASM backend`);
  let l10 = N2.getAxesPermutation([a10], u10), c10 = r10;
  l10 !== null && (c10 = so({ inputs: { x: r10 }, attrs: { perm: l10 }, backend: n10 }));
  let p10 = N2.getInnerMostAxes(1, u10)[0];
  N2.assertAxesAreInnerMostDims("cumsum", [p10], u10);
  let d10 = n10.makeOutput(c10.shape, c10.dtype), h10 = c10.shape[p10], f10 = n10.dataIdMap.get(c10.dataId).id, m10 = n10.dataIdMap.get(d10.dataId).id;
  j22(f10, i10 ? 1 : 0, o10 ? 1 : 0, h10, m10, Ct[r10.dtype]);
  let g10 = d10;
  if (l10 !== null) {
    let b10 = N2.getUndoAxesPermutation(l10);
    g10 = so({ inputs: { x: d10 }, attrs: { perm: b10 }, backend: n10 }), n10.disposeData(c10.dataId), n10.disposeData(d10.dataId);
  }
  return g10;
}
var joe = { kernelName: uo, backendName: "wasm", setupFunc: Hoe, kernelFunc: qoe };
var K2;
function Koe(e) {
  K2 = e.wasm.cwrap(co, null, ["number", "number", "number", "array", "number", "array", "array", "number", "number"]);
}
function Xoe(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { x: r10 } = n10, { blockSize: a10, dataFormat: i10 } = s10, o10 = r10.shape[0], u10 = i10 === "NHWC" ? r10.shape[1] : r10.shape[2], l10 = i10 === "NHWC" ? r10.shape[2] : r10.shape[3], c10 = i10 === "NHWC" ? r10.shape[3] : r10.shape[1], p10 = u10 * a10, d10 = l10 * a10, h10 = c10 / (a10 * a10), f10 = i10 === "NHWC" ? [o10, p10, d10, h10] : [o10, h10, p10, d10], m10 = t.makeOutput(f10, "float32"), b10 = t.dataIdMap.get(r10.dataId).id, y10 = new Uint8Array(new Int32Array(w2.computeStrides(r10.shape)).buffer), v10 = new Uint8Array(new Int32Array(f10).buffer), x10 = new Uint8Array(new Int32Array(w2.computeStrides(f10)).buffer), k10 = t.dataIdMap.get(m10.dataId).id;
  return K2(b10, a10, i10 === "NHWC" ? 1 : 0, y10, r10.shape.length - 1, v10, x10, f10.length, k10), m10;
}
var Yoe = { kernelName: co, backendName: "wasm", setupFunc: Koe, kernelFunc: Xoe };
var X22;
function Qoe(e) {
  X22 = e.wasm.cwrap(Aa, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function Zoe(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10, filter: a10 } = t, i10 = s10.dataIdMap.get(r10.dataId).id, o10 = s10.dataIdMap.get(a10.dataId).id, { strides: u10, dilations: l10, pad: c10, dimRoundingMode: p10 } = n10, d10 = l10 == null ? [1, 1] : l10, h10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, d10, c10, p10, true), f10 = h10.filterHeight, m10 = h10.filterWidth, g10 = h10.padInfo.top, b10 = h10.padInfo.right, y10 = h10.padInfo.bottom, v10 = h10.padInfo.left, x10 = h10.dilationHeight, k10 = h10.dilationWidth, C10 = h10.strideHeight, T10 = h10.strideWidth, E10 = h10.inChannels, A10 = h10.outChannels, P10 = h10.padInfo.type === "SAME" ? 1 : 0;
  if (h10.dataFormat !== "channelsLast")
    throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h10.dataFormat}'. Please use 'channelsLast'.`);
  let R10 = s10.makeOutput(h10.outShape, "float32"), F10 = s10.dataIdMap.get(R10.dataId).id;
  return X22(i10, r10.shape[0], r10.shape[1], r10.shape[2], o10, f10, m10, g10, b10, y10, v10, P10, x10, k10, C10, T10, E10, A10, F10), R10;
}
var Joe = { kernelName: Aa, backendName: "wasm", setupFunc: Qoe, kernelFunc: Zoe };
var eue = Kt(Ra);
var tue = false;
var nue = mn(po, tue, "bool");
var sue = Kt(Da, "float32");
function Ym(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { input: r10 } = t, { dim: a10 } = n10, i10 = r10.shape.length, o10 = r10.shape.slice(), u10 = a10;
  return a10 < 0 && (w2.assert(-(i10 + 1) <= a10, () => `Axis must be in the interval [${-(i10 + 1)}, ${i10}]`), u10 = i10 + a10 + 1), o10.splice(u10, 0, 1), bn({ inputs: { x: r10 }, backend: s10, attrs: { shape: o10 } });
}
var rue = { kernelName: ho, backendName: "wasm", kernelFunc: Ym };
function Y2(e) {
  let { attrs: { shape: t, value: n10, dtype: s10 }, backend: r10 } = e, a10 = r10.makeOutput(t, s10);
  return r10.typedArrayFromHeap(a10).fill(n10), a10;
}
var aue = { kernelName: hl, backendName: "wasm", kernelFunc: Y2 };
var Q2;
function iue(e) {
  Q2 = e.wasm.cwrap(mo, null, ["number", "number", "number", "number", "number", "number"]);
}
function oue(e) {
  let { inputs: t, backend: n10 } = e, { image: s10 } = t, r10 = n10.makeOutput(s10.shape, s10.dtype), a10 = n10.dataIdMap.get(s10.dataId).id, i10 = n10.dataIdMap.get(r10.dataId).id, [o10, u10, l10, c10] = s10.shape;
  return Q2(a10, o10, u10, l10, c10, i10), r10;
}
var uue = { kernelName: mo, backendName: "wasm", kernelFunc: oue, setupFunc: iue };
var lue = Kt(Fa);
var cue = false;
var due = mn(Oa, cue);
var Z2;
function pue(e) {
  Z2 = e.wasm.cwrap(Pa, null, ["number", "number", "number", "number", "number", "number", "number"]);
}
function hue(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { varianceEpsilon: r10 } = s10, { x: a10, mean: i10, variance: o10, offset: u10, scale: l10 } = n10, c10 = t.dataIdMap.get(a10.dataId).id, p10 = t.dataIdMap.get(i10.dataId).id, d10 = t.dataIdMap.get(o10.dataId).id, h10 = u10 != null ? t.dataIdMap.get(u10.dataId).id : 0, f10 = l10 != null ? t.dataIdMap.get(l10.dataId).id : 0, m10 = t.makeOutput(a10.shape, a10.dtype);
  if (w2.sizeFromShape(a10.shape) === 0)
    return m10;
  let g10 = t.dataIdMap.get(m10.dataId).id;
  return Z2(c10, p10, d10, h10, f10, r10, g10), m10;
}
var fue = { kernelName: Pa, backendName: "wasm", setupFunc: pue, kernelFunc: hue };
var J2;
function mue(e) {
  J2 = e.wasm.cwrap(sa, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function gue(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dilations: c10, dataFormat: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = n10, m10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, c10, l10, d10), g10 = Zp[h10];
  if (g10 == null)
    throw new Error(`${h10} activation not yet supported for FusedConv2D in the wasm backend.`);
  let b10 = s10.dataIdMap.get(r10.dataId).id, y10 = s10.dataIdMap.get(a10.dataId).id, v10 = m10.outChannels, x10 = 0;
  if (i10 != null) {
    let ne2 = s10.dataIdMap.get(i10.dataId);
    if (ne2.shape.length !== 1)
      throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ne2.shape.length}.`);
    if (ne2.shape[0] !== v10)
      throw new Error(`FusedConv2D bias shape (${ne2.shape}) does not match the number of output channels (${v10})`);
    x10 = ne2.id;
  }
  let k10 = m10.filterHeight, C10 = m10.filterWidth, T10 = m10.padInfo.top, E10 = m10.padInfo.right, A10 = m10.padInfo.bottom, P10 = m10.padInfo.left, R10 = m10.dilationHeight, F10 = m10.dilationWidth, $10 = m10.strideHeight, z10 = m10.strideWidth, W10 = m10.inChannels, q10 = m10.padInfo.type === "SAME" ? 1 : 0, K10 = m10.batchSize, Y10 = m10.inHeight, Z10 = m10.inWidth;
  if (p10 !== "NHWC")
    throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p10}'. Please use 'NHWC'.`);
  let te2 = s10.makeOutput(m10.outShape, "float32"), ee2 = s10.dataIdMap.get(te2.dataId).id, se2 = o10 == null ? 0 : s10.dataIdMap.get(o10.dataId).id;
  return J2(b10, K10, Y10, Z10, y10, k10, C10, x10, T10, E10, A10, P10, q10, R10, F10, $10, z10, W10, v10, g10, se2, f10 || 0, ee2), te2;
}
var bue = { kernelName: sa, backendName: "wasm", setupFunc: mue, kernelFunc: gue };
var eN;
function yue(e) {
  eN = e.wasm.cwrap(ra, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function vue(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10, filter: a10, bias: i10, preluActivationWeights: o10 } = t, { strides: u10, pad: l10, dilations: c10, dataFormat: p10, dimRoundingMode: d10, activation: h10, leakyreluAlpha: f10 } = n10, m10 = N2.computeConv2DInfo(r10.shape, a10.shape, u10, c10, l10, d10, true), g10 = Zp[h10];
  if (g10 == null)
    throw new Error(`${h10} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
  let b10 = s10.dataIdMap.get(r10.dataId).id, y10 = s10.dataIdMap.get(a10.dataId).id, v10 = m10.outChannels, x10 = 0;
  if (i10 != null) {
    let ne2 = s10.dataIdMap.get(i10.dataId);
    if (ne2.shape.length !== 1)
      throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ne2.shape.length}.`);
    if (ne2.shape[0] !== v10)
      throw new Error(`FusedDepthwiseConv2D bias shape (${ne2.shape}) does not match the number of output channels (${v10})`);
    x10 = ne2.id;
  }
  let k10 = m10.filterHeight, C10 = m10.filterWidth, T10 = m10.padInfo.top, E10 = m10.padInfo.right, A10 = m10.padInfo.bottom, P10 = m10.padInfo.left, R10 = m10.dilationHeight, F10 = m10.dilationWidth, $10 = m10.strideHeight, z10 = m10.strideWidth, W10 = m10.inChannels, q10 = m10.padInfo.type === "SAME" ? 1 : 0, K10 = m10.batchSize, Y10 = m10.inHeight, Z10 = m10.inWidth;
  if (p10 !== "NHWC")
    throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p10}'. Please use 'NHWC'.`);
  let te2 = s10.makeOutput(m10.outShape, "float32"), ee2 = s10.dataIdMap.get(te2.dataId).id, se2 = o10 == null ? 0 : s10.dataIdMap.get(o10.dataId).id;
  return eN(b10, K10, Y10, Z10, y10, k10, C10, x10, T10, E10, A10, P10, q10, R10, F10, $10, z10, W10, v10, g10, se2, f10 || 0, ee2), te2;
}
var xue = { kernelName: ra, backendName: "wasm", setupFunc: yue, kernelFunc: vue };
var tN;
function wue(e) {
  tN = e.wasm.cwrap(bo, null, ["number", "number", "number", "number", "number", "number", "array", "number"]);
}
function kue(e) {
  let { backend: t, inputs: n10 } = e, { params: s10, indices: r10 } = n10, [a10, i10, o10, u10] = kk.prepareAndValidate(s10, r10), l10 = t.makeOutput(a10, s10.dtype);
  if (i10 === 0)
    return l10;
  let c10 = r10.shape, p10 = c10[c10.length - 1], h10 = t.dataIdMap.get(s10.dataId).id, m10 = t.dataIdMap.get(r10.dataId).id, g10 = new Uint8Array(new Int32Array(u10).buffer), b10 = t.dataIdMap.get(l10.dataId).id;
  return tN(h10, Ct[s10.dtype], m10, i10, p10, o10, g10, b10), l10;
}
var Iue = { kernelName: bo, backendName: "wasm", setupFunc: wue, kernelFunc: kue };
var nN;
function Sue(e) {
  nN = e.wasm.cwrap("Gather", null, ["number", "number", "array", "number", "number", "number", "array", "number"]);
}
function Cue(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { x: r10, indices: a10 } = n10, { axis: i10, batchDims: o10 } = s10, u10 = w2.parseAxisParam(i10, r10.shape)[0], l10 = t.readSync(a10.dataId), c10 = r10.shape[u10];
  for (let A10 = 0; A10 < l10.length; ++A10) {
    let P10 = l10[A10];
    w2.assert(P10 <= c10 - 1 && P10 >= 0, () => `GatherV2: the index value ${P10} is not in [0, ${c10 - 1}]`);
  }
  let p10 = N2.segment_util.collectGatherOpShapeInfo(r10, a10, u10, o10), d10 = bn({ inputs: { x: r10 }, attrs: { shape: [p10.batchSize, p10.outerSize, p10.dimSize, p10.sliceSize] }, backend: t }), h10 = w2.sizeFromShape(a10.shape), f10 = bn({ inputs: { x: a10 }, attrs: { shape: [p10.batchSize, h10 / p10.batchSize] }, backend: t }), m10 = [p10.batchSize, p10.outerSize, h10 / p10.batchSize, p10.sliceSize], g10 = t.makeOutput(m10, r10.dtype);
  if (w2.sizeFromShape(r10.shape) === 0)
    return g10;
  let b10 = d10.shape.length - 1, v10 = t.dataIdMap.get(d10.dataId).id, k10 = t.dataIdMap.get(f10.dataId).id, C10 = t.dataIdMap.get(g10.dataId).id, T10 = new Uint8Array(new Int32Array(w2.computeStrides(d10.shape)).buffer), E10 = new Uint8Array(new Int32Array(w2.computeStrides(m10)).buffer);
  return nN(v10, Ct[r10.dtype], T10, b10, k10, p10.batchSize, E10, C10), t.disposeData(d10.dataId), t.disposeData(f10.dataId), g10.shape = p10.outputShape, g10;
}
var Nue = { kernelName: go, backendName: "wasm", setupFunc: Sue, kernelFunc: Cue };
var Tue = false;
var $ue = mn(yo, Tue, "bool");
var _ue = false;
var Aue = mn(za, _ue, "bool");
var sN;
function Eue(e) {
  sN = e.wasm.cwrap(La, null, ["number", "number", "number", "number"]);
}
function Rue(e) {
  let { inputs: { x: t }, attrs: { alpha: n10 }, backend: s10 } = e, r10 = s10.dataIdMap.get(t.dataId).id, a10 = s10.makeOutput(t.shape, "float32");
  if (w2.sizeFromShape(t.shape) !== 0) {
    let i10 = s10.dataIdMap.get(a10.dataId).id;
    sN(r10, Ct[t.dtype], n10, i10);
  }
  return a10;
}
var Due = { kernelName: La, backendName: "wasm", setupFunc: Eue, kernelFunc: Rue };
var Fue = false;
var Oue = mn(vo, Fue, "bool");
var Pue = false;
var zue = mn(xo, Pue, "bool");
var Mue = Kt(Ba);
var Lue = false;
var Bue = mn(wo, Lue, "bool");
var rN;
function Vue(e) {
  rN = e.wasm.cwrap(Va, null, ["number", "number", "number", "number"]);
}
function Wue(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { reductionIndices: r10, keepDims: a10 } = s10, { x: i10 } = n10, u10 = t.dataIdMap.get(i10.dataId).id, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t);
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    l10 = c10, u10 = v10;
  }
  let f10 = l10.shape.length;
  N2.assertAxesAreInnerMostDims("max", p10, f10);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, p10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, i10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    rN(u10, Ct[i10.dtype], b10, v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var Uue = { kernelName: Va, backendName: "wasm", setupFunc: Vue, kernelFunc: Wue };
var Gue = false;
var Hue = mn(Wa, Gue);
var aN;
function que(e) {
  aN = e.wasm.cwrap(Ua, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function jue(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, r10 = t.x, a10 = s10.dataIdMap.get(r10.dataId).id;
  w2.assert(r10.dtype === "float32", () => `Error in MaxPool: only float32 input is supported. Got ${r10.dtype}.`);
  let { filterSize: i10, strides: o10, pad: u10, dimRoundingMode: l10 } = n10, c10 = N2.computePool2DInfo(r10.shape, i10, o10, 1, u10, l10), p10 = c10.filterHeight, d10 = c10.filterWidth, h10 = c10.padInfo.top, f10 = c10.padInfo.right, m10 = c10.padInfo.bottom, g10 = c10.padInfo.left, b10 = c10.dilationHeight, y10 = c10.dilationWidth, v10 = c10.strideHeight, x10 = c10.strideWidth, k10 = c10.inChannels, C10 = c10.outChannels;
  if (c10.dataFormat !== "channelsLast")
    throw new Error(`wasm backend does not support dataFormat:'${c10.dataFormat}'. Please use 'channelsLast'.`);
  let T10 = s10.makeOutput(c10.outShape, "float32"), E10 = s10.dataIdMap.get(T10.dataId).id;
  return aN(a10, r10.shape[0], r10.shape[1], r10.shape[2], p10, d10, h10, f10, m10, g10, b10, y10, v10, x10, k10, C10, E10), T10;
}
var Kue = { kernelName: Ua, backendName: "wasm", setupFunc: que, kernelFunc: jue };
var iN;
function Xue(e) {
  iN = e.wasm.cwrap(Ga, null, ["number, number, number"]);
}
function Yue(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, o10 = t.dataIdMap.get(i10.dataId).id, u10 = o10, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t), f10 = p10;
  if (h10) {
    let x10 = t.dataIdMap.get(c10.dataId).id;
    x10 !== o10 && (l10 = c10, u10 = x10, f10 = N2.getInnerMostAxes(f10.length, l10.shape.length));
  }
  N2.assertAxesAreInnerMostDims("mean", f10, l10.shape.length);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, f10), b10 = w2.sizeFromShape(g10), y10 = l10;
  l10.dtype !== "float32" && (y10 = rc({ backend: t, inputs: { x: l10 }, attrs: { dtype: "float32" } }), u10 = t.dataIdMap.get(y10.dataId).id);
  let v10 = t.makeOutput(m10, "float32");
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let x10 = t.dataIdMap.get(v10.dataId).id;
    iN(u10, b10, x10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let x10 = N2.expandShapeToKeepDim(v10.shape, d10);
    v10.shape = x10;
  }
  return l10.dtype !== "float32" && t.disposeData(y10.dataId), v10;
}
var Que = { kernelName: Ga, backendName: "wasm", setupFunc: Xue, kernelFunc: Yue };
var oN;
function Zue(e) {
  oN = e.wasm.cwrap(Ha, null, ["number", "number", "number", "number"]);
}
function Jue(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, o10 = t.dataIdMap.get(i10.dataId).id, u10 = o10, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t);
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    v10 !== o10 && (l10 = c10, u10 = v10);
  }
  let f10 = l10.shape.length;
  N2.assertAxesAreInnerMostDims("min", p10, f10);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, p10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, l10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    oN(u10, Ct[i10.dtype], b10, v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var ele = { kernelName: Ha, backendName: "wasm", setupFunc: Zue, kernelFunc: Jue };
var tle = false;
var nle = mn(qa, tle);
var uN = ((e) => (e[e.reflect = 0] = "reflect", e[e.symmetric = 1] = "symmetric", e))(uN || {});
var lN;
function sle(e) {
  lN = e.wasm.cwrap(ja, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
}
function rle(e) {
  let { inputs: { x: t }, backend: n10, attrs: { paddings: s10, mode: r10 } } = e, a10 = s10.map((f10, m10) => f10[0] + t.shape[m10] + f10[1]), i10 = n10.dataIdMap.get(t.dataId).id, o10 = n10.makeOutput(a10, t.dtype), u10 = n10.dataIdMap.get(o10.dataId).id, l10 = new Uint8Array(new Int32Array(t.shape).buffer), c10 = s10.map((f10) => f10[0]), p10 = s10.map((f10) => f10[1]), d10 = new Uint8Array(new Int32Array(c10).buffer), h10 = new Uint8Array(new Int32Array(p10).buffer);
  return lN(i10, l10, t.shape.length, Ct[t.dtype], d10, h10, uN[r10], u10), o10;
}
var ale = { kernelName: ja, backendName: "wasm", kernelFunc: rle, setupFunc: sle };
var ile = true;
var ole = mn(Ka, ile);
var ule = Kt(ko);
function _v(e, t) {
  let n10 = new Int32Array(e.wasm.HEAPU8.buffer, t, 4), s10 = n10[0], r10 = n10[1], a10 = n10[2], i10 = n10[3];
  return e.wasm._free(t), { pSelectedIndices: s10, selectedSize: r10, pSelectedScores: a10, pValidOutputs: i10 };
}
var cN;
function lle(e) {
  cN = e.wasm.cwrap(So, "number", ["number", "number", "number", "number", "number"]);
}
function cle(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { iouThreshold: r10, maxOutputSize: a10, scoreThreshold: i10 } = s10, { boxes: o10, scores: u10 } = n10, l10 = t.dataIdMap.get(o10.dataId).id, c10 = t.dataIdMap.get(u10.dataId).id, p10 = cN(l10, c10, a10, r10, i10), { pSelectedIndices: d10, selectedSize: h10, pSelectedScores: f10, pValidOutputs: m10 } = _v(t, p10);
  return t.wasm._free(f10), t.wasm._free(m10), t.makeOutput([h10], "int32", d10);
}
var dle = { kernelName: So, backendName: "wasm", setupFunc: lle, kernelFunc: cle };
var dN;
function ple(e) {
  dN = e.wasm.cwrap(xl, "number", ["number", "number", "number", "number", "number", "bool"]);
}
function hle(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { iouThreshold: r10, maxOutputSize: a10, scoreThreshold: i10, padToMaxOutputSize: o10 } = s10, { boxes: u10, scores: l10 } = n10, c10 = t.dataIdMap.get(u10.dataId).id, p10 = t.dataIdMap.get(l10.dataId).id, d10 = dN(c10, p10, a10, r10, i10, o10), { pSelectedIndices: h10, selectedSize: f10, pSelectedScores: m10, pValidOutputs: g10 } = _v(t, d10);
  t.wasm._free(m10);
  let b10 = t.makeOutput([f10], "int32", h10), y10 = t.makeOutput([], "int32", g10);
  return [b10, y10];
}
var fle = { kernelName: xl, backendName: "wasm", setupFunc: ple, kernelFunc: hle };
var pN;
function mle(e) {
  pN = e.wasm.cwrap(Co, "number", ["number", "number", "number", "number", "number", "number"]);
}
function gle(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { iouThreshold: r10, maxOutputSize: a10, scoreThreshold: i10, softNmsSigma: o10 } = s10, { boxes: u10, scores: l10 } = n10, c10 = t.dataIdMap.get(u10.dataId).id, p10 = t.dataIdMap.get(l10.dataId).id, d10 = pN(c10, p10, a10, r10, i10, o10), { pSelectedIndices: h10, selectedSize: f10, pSelectedScores: m10, pValidOutputs: g10 } = _v(t, d10);
  t.wasm._free(g10);
  let b10 = t.makeOutput([f10], "int32", h10), y10 = t.makeOutput([f10], "float32", m10);
  return [b10, y10];
}
var ble = { kernelName: Co, backendName: "wasm", setupFunc: mle, kernelFunc: gle };
var yle = false;
var vle = mn(Io, yle, "bool");
var hN;
function xle(e) {
  hN = e.wasm.cwrap(To, null, ["number", "number", "number", "number", "number"]);
}
function wle(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { indices: r10 } = t, { depth: a10, onValue: i10, offValue: o10 } = s10, u10 = n10.makeOutput([...r10.shape, a10], "int32"), l10 = n10.dataIdMap.get(u10.dataId).id, p10 = n10.dataIdMap.get(r10.dataId).id;
  return hN(p10, a10, i10, o10, l10), u10;
}
var kle = { kernelName: To, backendName: "wasm", setupFunc: xle, kernelFunc: wle };
function Ile(e) {
  let { inputs: { x: t }, backend: n10 } = e, s10 = n10.makeOutput(t.shape, t.dtype);
  return n10.typedArrayFromHeap(s10).fill(1), s10;
}
var Sle = { kernelName: No, backendName: "wasm", kernelFunc: Ile };
function Cle(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { axis: r10 } = s10;
  if (t.length === 1)
    return Ym({ inputs: { input: t[0] }, backend: n10, attrs: { dim: r10 } });
  let a10 = t[0].shape, i10 = t[0].dtype;
  t.forEach((c10) => {
    w2.assertShapesMatch(a10, c10.shape, "All tensors passed to stack must have matching shapes"), w2.assert(i10 === c10.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o10 = [], u10 = t.map((c10) => {
    let p10 = Ym({ inputs: { input: c10 }, backend: n10, attrs: { dim: r10 } });
    return o10.push(p10), p10;
  }), l10 = W2({ inputs: u10, backend: n10, attrs: { axis: r10 } });
  return o10.forEach((c10) => n10.disposeData(c10.dataId)), l10;
}
var Nle = { kernelName: $o, backendName: "wasm", kernelFunc: Cle };
var fN;
function Tle(e) {
  fN = e.wasm.cwrap(Xa, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
}
function $le(e) {
  let { inputs: { x: t }, backend: n10, attrs: { paddings: s10, constantValue: r10 } } = e, a10 = s10.map((m10, g10) => m10[0] + t.shape[g10] + m10[1]);
  if (w2.sizeFromShape(t.shape) === 0)
    return Y2({ backend: n10, attrs: { shape: a10, value: r10, dtype: t.dtype } });
  let i10 = n10.dataIdMap.get(t.dataId).id, o10 = n10.makeOutput(a10, t.dtype), l10 = n10.dataIdMap.get(o10.dataId).id, c10 = new Uint8Array(new Int32Array(t.shape).buffer), p10 = s10.map((m10) => m10[0]), d10 = s10.map((m10) => m10[1]), h10 = new Uint8Array(new Int32Array(p10).buffer), f10 = new Uint8Array(new Int32Array(d10).buffer);
  return fN(i10, c10, t.shape.length, Ct[t.dtype], h10, f10, r10, l10), o10;
}
var mN = { kernelName: Xa, backendName: "wasm", kernelFunc: $le, setupFunc: Tle };
var _le = false;
var Ale = mn(Ya, _le);
var gN;
function Ele(e) {
  gN = e.wasm.cwrap(Qa, null, ["number", "number", "number"]);
}
function Rle(e) {
  let { inputs: t, backend: n10 } = e, { x: s10, alpha: r10 } = t, a10 = n10.dataIdMap.get(s10.dataId).id, i10 = n10.dataIdMap.get(r10.dataId).id, o10 = a10, u10 = s10, l10 = u10;
  u10.dtype !== "float32" && (l10 = rc({ backend: n10, inputs: { x: s10 }, attrs: { dtype: "float32" } }), o10 = n10.dataIdMap.get(l10.dataId).id);
  let c10 = n10.makeOutput(s10.shape, "float32"), p10 = n10.dataIdMap.get(c10.dataId).id;
  return gN(o10, i10, p10), u10.dtype !== "float32" && n10.disposeData(l10.dataId), c10;
}
var Dle = { kernelName: Qa, backendName: "wasm", setupFunc: Ele, kernelFunc: Rle };
var bN;
function Fle(e) {
  bN = e.wasm.cwrap(_o, null, ["number", "number", "number", "number"]);
}
function Ole(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, o10 = t.dataIdMap.get(i10.dataId).id, u10 = o10, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t), f10 = p10;
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    v10 !== o10 && (l10 = c10, u10 = v10, f10 = N2.getInnerMostAxes(f10.length, l10.shape.length));
  }
  N2.assertAxesAreInnerMostDims("prod", f10, l10.shape.length);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, f10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, l10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    bN(u10, b10, Ct[y10.dtype], v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var Ple = { kernelName: _o, backendName: "wasm", setupFunc: Fle, kernelFunc: Ole };
var zle = (e) => {
  let { backend: t, attrs: n10 } = e, { start: s10, stop: r10, step: a10, dtype: i10 } = n10, o10 = nv(s10, r10, a10, i10), u10 = t.makeOutput([o10.length], i10);
  return t.typedArrayFromHeap(u10).set(o10), u10;
};
var Mle = { kernelName: wl, backendName: "wasm", kernelFunc: zle };
var Lle = true;
var Ble = mn(Ea, Lle);
var Vle = Kt(Za);
var Wle = Kt(ei);
var yN;
function Ule(e) {
  yN = e.wasm.cwrap(Ja, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function Gle(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { images: r10 } = n10, { alignCorners: a10, halfPixelCenters: i10, size: o10 } = s10, [u10, l10] = o10, [c10, p10, d10, h10] = r10.shape, f10 = [c10, u10, l10, h10], m10 = t.dataIdMap.get(r10.dataId), g10;
  m10.dtype !== "float32" && (g10 = rc({ backend: t, inputs: { x: r10 }, attrs: { dtype: "float32" } }), m10 = t.dataIdMap.get(g10.dataId));
  let b10 = m10.id, y10 = t.makeOutput(f10, "float32");
  if (w2.sizeFromShape(r10.shape) === 0)
    return y10;
  let v10 = t.dataIdMap.get(y10.dataId).id;
  return yN(b10, c10, p10, d10, h10, u10, l10, a10 ? 1 : 0, i10 ? 1 : 0, v10), g10 != null && t.disposeData(g10.dataId), y10;
}
var Hle = { kernelName: Ja, backendName: "wasm", setupFunc: Ule, kernelFunc: Gle };
var vN;
function qle(e) {
  vN = e.wasm.cwrap(Eo, null, ["number", "array", "number", "array", "number", "number"]);
}
function jle(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { dims: a10 } = s10, i10 = w2.parseAxisParam(a10, r10.shape);
  if (r10.shape.length === 0)
    return Jp({ inputs: { x: r10 }, backend: n10 });
  let o10 = n10.makeOutput(r10.shape, r10.dtype), u10 = n10.dataIdMap.get(r10.dataId).id, l10 = n10.dataIdMap.get(o10.dataId).id, c10 = new Uint8Array(new Int32Array(i10).buffer), p10 = new Uint8Array(new Int32Array(r10.shape).buffer);
  vN(u10, c10, i10.length, p10, r10.shape.length, l10);
  let d10 = bn({ inputs: { x: o10 }, attrs: { shape: r10.shape }, backend: n10 });
  return n10.disposeData(o10.dataId), d10;
}
var Kle = { kernelName: Eo, backendName: "wasm", kernelFunc: jle, setupFunc: qle };
var xN;
function Xle(e) {
  xN = e.wasm.cwrap(Ho, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"]);
}
function Yle(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { image: r10 } = t, { radians: a10, fillValue: i10, center: o10 } = s10, u10 = n10.makeOutput(r10.shape, r10.dtype), l10 = n10.dataIdMap.get(r10.dataId).id, c10 = n10.dataIdMap.get(u10.dataId).id, [p10, d10, h10, f10] = r10.shape, [m10, g10] = N2.getImageCenter(o10, d10, h10), b10 = i10 === 0, y10 = 255, v10 = typeof i10 == "number" ? [i10, i10, i10, b10 ? 0 : y10] : [...i10, y10], x10 = new Uint8Array(new Int32Array(v10).buffer);
  return xN(l10, p10, d10, h10, f10, a10, m10, g10, x10, v10.length, c10), u10;
}
var Qle = { kernelName: Ho, backendName: "wasm", kernelFunc: Yle, setupFunc: Xle };
var Zle = Kt(Ro);
var Jle = Kt(ti);
var wN;
function ece(e) {
  wN = e.wasm.cwrap(Do, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number"]);
}
function tce(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { indices: r10, updates: a10 } = n10, { shape: i10 } = s10, o10 = t.makeOutput(i10, a10.dtype);
  if (w2.sizeFromShape(i10) === 0)
    return o10;
  let { sliceRank: u10, numUpdates: l10, sliceSize: c10, strides: p10, outputSize: d10 } = Sk.calculateShapes(a10, r10, i10), f10 = t.dataIdMap.get(r10.dataId).id, g10 = t.dataIdMap.get(a10.dataId).id, b10 = new Uint8Array(new Int32Array(p10).buffer), y10 = t.dataIdMap.get(o10.dataId).id;
  return wN(f10, g10, Ct[a10.dtype], u10, l10, c10, b10, d10, y10), o10;
}
var nce = { kernelName: Do, backendName: "wasm", setupFunc: ece, kernelFunc: tce };
var kN;
function sce(e) {
  kN = e.wasm.cwrap("SelectV2", null, ["number", "number", "number", "number", "number"]);
}
function rce(e) {
  let { inputs: t, backend: n10 } = e, { condition: s10, t: r10, e: a10 } = t, i10 = n10.dataIdMap.get(s10.dataId).id, o10 = n10.dataIdMap.get(r10.dataId).id, u10 = n10.dataIdMap.get(a10.dataId).id, l10 = n10.makeOutput(r10.shape, r10.dtype), c10 = n10.dataIdMap.get(l10.dataId).id, p10 = s10.shape.length, d10 = r10.shape.length, h10 = p10 === 0 || p10 > 1 || d10 === 1 ? 1 : w2.sizeFromShape(r10.shape.slice(1));
  return kN(i10, o10, u10, h10, c10), l10;
}
var ace = { kernelName: Fo, backendName: "wasm", kernelFunc: rce, setupFunc: sce };
var IN;
function ice(e) {
  IN = e.wasm.cwrap(si, null, ["number", "number"]);
}
function oce(e) {
  let { backend: t, inputs: { x: n10 } } = e, s10 = t.dataIdMap.get(n10.dataId).id, r10 = t.makeOutput(n10.shape, n10.dtype), a10 = t.dataIdMap.get(r10.dataId).id;
  return w2.sizeFromShape(r10.shape) === 0 || IN(s10, a10), r10;
}
var uce = { kernelName: "Sigmoid", backendName: "wasm", setupFunc: ice, kernelFunc: oce };
var lce = Kt(ni);
var SN;
function cce(e) {
  SN = e.wasm.cwrap(ii, null, ["number", "number", "number", "number"]);
}
function dce(e) {
  let { backend: t, inputs: { logits: n10 }, attrs: { dim: s10 } } = e, r10 = t.dataIdMap.get(n10.dataId).id, a10 = t.makeOutput(n10.shape, n10.dtype), i10 = t.dataIdMap.get(a10.dataId).id, o10 = n10.shape[s10], u10 = w2.sizeFromShape(n10.shape) / o10;
  return w2.sizeFromShape(a10.shape) === 0 || SN(r10, i10, o10, u10), a10;
}
var pce = { kernelName: ii, backendName: "wasm", setupFunc: cce, kernelFunc: dce };
function hce(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, { blockShape: a10, paddings: i10 } = s10, o10 = w2.sizeFromShape(a10), u10 = [[0, 0]];
  u10.push(...i10);
  for (let C10 = 1 + a10.length; C10 < r10.shape.length; ++C10)
    u10.push([0, 0]);
  let l10 = mN.kernelFunc({ inputs: { x: r10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), c10 = N2.getReshaped(l10.shape, a10, o10, false), p10 = N2.getPermuted(c10.length, a10.length, false), d10 = N2.getReshapedPermuted(l10.shape, a10, o10, false), m10 = bn({ inputs: { x: l10 }, backend: n10, attrs: { shape: c10 } }), y10 = so({ inputs: { x: m10 }, backend: n10, attrs: { perm: p10 } }), k10 = bn({ inputs: { x: y10 }, backend: n10, attrs: { shape: d10 } });
  return n10.disposeData(l10.dataId), n10.disposeData(m10.dataId), n10.disposeData(y10.dataId), k10;
}
var fce = { kernelName: zo, backendName: "wasm", kernelFunc: hce };
var CN;
function mce(e) {
  CN = e.wasm.cwrap("SparseFillEmptyRows", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function gce(e) {
  let { backend: t, inputs: n10 } = e, { indices: s10, values: r10, denseShape: a10, defaultValue: i10 } = n10, o10 = s10.shape[0], u10 = s10.shape[1], l10 = t.readSync(a10.dataId)[0], c10 = [o10 + l10, u10], p10 = t.dataIdMap.get(s10.dataId).id, d10 = t.dataIdMap.get(r10.dataId).id, h10 = t.dataIdMap.get(i10.dataId).id, f10 = t.makeOutput(c10, s10.dtype), m10 = t.dataIdMap.get(f10.dataId).id, g10 = t.makeOutput(c10.slice(0, 1), r10.dtype), b10 = t.dataIdMap.get(g10.dataId).id, y10 = t.makeOutput([l10], "bool"), v10 = t.dataIdMap.get(y10.dataId).id, x10 = t.makeOutput([o10], s10.dtype), k10 = t.dataIdMap.get(x10.dataId).id, C10 = t.makeOutput([4], "int32"), T10 = t.dataIdMap.get(C10.dataId).id, E10 = CN(p10, d10, Ct[r10.dtype], o10, l10, u10, h10, m10, b10, v10, k10, T10), A10 = t.readSync(C10.dataId), P10;
  switch (A10[0]) {
    case 1: {
      P10 = N2.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A10[1]);
      break;
    }
    case 2: {
      P10 = N2.getSparseFillEmptyRowsNegativeIndexErrorMessage(A10[1], A10[2]);
      break;
    }
    case 3:
      P10 = N2.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A10[1], A10[2], A10[3]);
      break;
    default:
      P10 = "";
  }
  if (t.disposeData(C10.dataId), P10)
    throw t.disposeData(f10.dataId), t.disposeData(g10.dataId), t.disposeData(y10.dataId), t.disposeData(x10.dataId), new Error(P10);
  let R10 = f10, F10 = g10;
  return E10 !== c10[0] && (R10 = ba({ inputs: { x: f10 }, attrs: { begin: 0, size: [E10, u10] }, backend: t }), F10 = ba({ inputs: { x: g10 }, attrs: { begin: 0, size: E10 }, backend: t }), t.disposeData(f10.dataId), t.disposeData(g10.dataId)), [R10, F10, y10, x10];
}
var bce = { kernelName: np, backendName: "wasm", setupFunc: mce, kernelFunc: gce };
var NN;
function yce(e) {
  NN = e.wasm.cwrap(Tl, null, ["number", "number", "number", "number", "number", "number", "number"]);
}
function vce(e) {
  let { backend: t, inputs: n10 } = e, { inputIndices: s10, inputShape: r10, newShape: a10 } = n10;
  if (s10.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${s10.shape}`);
  if (r10.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${r10.shape}`);
  if (a10.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${a10.shape}`);
  let i10 = t.dataIdMap.get(s10.dataId).id, o10 = t.dataIdMap.get(r10.dataId).id, u10 = t.dataIdMap.get(a10.dataId).id, l10 = s10.shape[0], c10 = w2.sizeFromShape(a10.shape), p10 = t.makeOutput([l10, c10], s10.dtype), d10 = t.dataIdMap.get(p10.dataId).id, h10 = t.makeOutput([c10], a10.dtype), f10 = t.dataIdMap.get(h10.dataId).id, m10 = t.makeOutput([3], "int32"), g10 = t.dataIdMap.get(m10.dataId).id;
  NN(i10, o10, u10, l10, d10, f10, g10);
  let b10 = t.readSync(m10.dataId), y10;
  switch (b10[0]) {
    case 0: {
      y10 = N2.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b10[1], b10[2]);
      break;
    }
    case 1: {
      y10 = N2.getSparseReshapeNegativeOutputDimErrorMessage(b10[1], b10[2]);
      break;
    }
    case 2:
      y10 = N2.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
      break;
    case 3: {
      let v10 = Array.from(t.readSync(r10.dataId)), x10 = Array.from(t.readSync(h10.dataId));
      y10 = N2.getSparseReshapeInputOutputMultipleErrorMessage(v10, x10);
      break;
    }
    case 4: {
      let v10 = Array.from(t.readSync(r10.dataId)), x10 = Array.from(t.readSync(h10.dataId));
      y10 = N2.getSparseReshapeInputOutputMismatchErrorMessage(v10, x10);
      break;
    }
    default:
      y10 = "";
  }
  if (t.disposeData(m10.dataId), y10)
    throw t.disposeData(p10.dataId), t.disposeData(h10.dataId), new Error(y10);
  return [p10, h10];
}
var xce = { kernelName: Tl, backendName: "wasm", setupFunc: yce, kernelFunc: vce };
var TN;
function $N(e) {
  TN = e.wasm.cwrap("SparseSegmentReduction", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function _N(e, t) {
  let { backend: n10, inputs: s10 } = e, { data: r10, indices: a10, segmentIds: i10 } = s10, o10 = a10.shape[0], u10 = n10.readSync(i10.dataId, o10 - 1, o10)[0], c10 = o10 > 0 ? u10 + 1 : 0;
  if (c10 < 0)
    throw new Error(N2.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let p10 = r10.shape.slice();
  p10[0] = c10;
  let d10 = n10.dataIdMap.get(r10.dataId).id, h10 = n10.dataIdMap.get(a10.dataId).id, f10 = n10.dataIdMap.get(i10.dataId).id, m10 = n10.makeOutput(p10, r10.dtype), g10 = n10.dataIdMap.get(m10.dataId).id, b10 = n10.makeOutput([4], "int32"), y10 = n10.dataIdMap.get(b10.dataId).id;
  TN(d10, Ct[r10.dtype], r10.shape[0], h10, f10, g10, y10, t, 0);
  let v10 = n10.readSync(b10.dataId), x10;
  switch (v10[0]) {
    case 0: {
      x10 = N2.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
      break;
    }
    case 1: {
      x10 = N2.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
      break;
    }
    case 2:
      x10 = N2.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v10[1], v10[2]);
      break;
    case 3:
      x10 = N2.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v10[1], v10[2], v10[3]);
      break;
    default:
      x10 = "";
  }
  if (n10.disposeData(b10.dataId), x10)
    throw n10.disposeData(m10.dataId), new Error(x10);
  return m10;
}
function wce(e) {
  return _N(e, true);
}
var kce = { kernelName: sp, backendName: "wasm", setupFunc: $N, kernelFunc: wce };
function Ice(e) {
  return _N(e, false);
}
var Sce = { kernelName: rp, backendName: "wasm", setupFunc: $N, kernelFunc: Ice };
function Cce(e) {
  let { inputs: t, attrs: n10, backend: s10 } = e, { x: r10 } = t, { numOrSizeSplits: a10, axis: i10 } = n10, o10 = w2.parseAxisParam(i10, r10.shape)[0], u10 = N2.prepareSplitSize(r10, a10, o10), l10 = new Array(r10.shape.length).fill(0), c10 = r10.shape.slice();
  return u10.map((p10) => {
    let d10 = [...c10];
    d10[o10] = p10;
    let h10 = ba({ inputs: { x: r10 }, attrs: { begin: l10, size: d10 }, backend: s10 });
    return l10[o10] += p10, h10;
  });
}
var Nce = { kernelName: Mo, backendName: "wasm", kernelFunc: Cce };
var Tce = Kt(ri);
var $ce = Kt($l);
var _ce = true;
var Ace = mn(oi, _ce);
var AN;
function Ece(e) {
  AN = e.wasm.cwrap(di, null, ["number", "number", "number", "number"]);
}
function Rce(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { alpha: r10 } = s10, { x: a10 } = n10, i10 = t.dataIdMap.get(a10.dataId).id, o10 = t.makeOutput(a10.shape, a10.dtype), u10 = t.dataIdMap.get(o10.dataId).id;
  return AN(i10, r10, Ct[a10.dtype], u10), o10;
}
var Dce = { kernelName: di, backendName: "wasm", setupFunc: Ece, kernelFunc: Rce };
var EN;
function Fce(e) {
  EN = e.wasm.cwrap(Lo, null, ["number", "array", "number", "array", "array", "array", "array", "array", "number", "number"]);
}
function Oce(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { x: r10 } = n10, { begin: a10, end: i10, strides: o10, beginMask: u10, endMask: l10, ellipsisMask: c10, newAxisMask: p10, shrinkAxisMask: d10 } = s10, { finalShapeSparse: h10, finalShape: f10, isIdentity: m10, sliceDim0: g10, isSimpleSlice: b10, begin: y10, end: v10, strides: x10 } = wt.sliceInfo(r10.shape, a10, i10, o10, u10, l10, c10, p10, d10), k10;
  if (m10)
    k10 = bn({ inputs: { x: r10 }, backend: t, attrs: { shape: f10 } });
  else if (g10 || b10) {
    w2.assert(r10.shape.length >= 1, () => `Input must have rank at least 1, got: ${r10.shape.length}`);
    let C10 = wt.computeOutShape(y10, v10, x10), T10 = ba({ inputs: { x: r10 }, backend: t, attrs: { begin: y10, size: C10 } });
    k10 = bn({ inputs: { x: T10 }, backend: t, attrs: { shape: f10 } }), t.disposeData(T10.dataId);
  } else {
    let C10 = t.makeOutput(h10, "float32"), T10 = t.dataIdMap.get(r10.dataId).id, E10 = new Uint8Array(new Int32Array(w2.computeStrides(r10.shape)).buffer), A10 = new Uint8Array(new Int32Array(y10).buffer), P10 = new Uint8Array(new Int32Array(v10).buffer), R10 = new Uint8Array(new Int32Array(x10).buffer), F10 = new Uint8Array(new Int32Array(h10).buffer), $10 = new Uint8Array(new Int32Array(w2.computeStrides(h10)).buffer), z10 = t.dataIdMap.get(C10.dataId).id;
    EN(T10, E10, r10.shape.length, A10, P10, R10, F10, $10, h10.length, z10), k10 = bn({ inputs: { x: C10 }, backend: t, attrs: { shape: f10 } }), t.disposeData(C10.dataId);
  }
  return k10;
}
var Pce = { kernelName: Lo, backendName: "wasm", setupFunc: Fce, kernelFunc: Oce };
var zce = true;
var Mce = mn(ui, zce);
var RN;
function Lce(e) {
  RN = e.wasm.cwrap(ai, null, ["number", "number", "number", "number"]);
}
function Bce(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { axis: r10, keepDims: a10 } = s10, { x: i10 } = n10, o10 = t.dataIdMap.get(i10.dataId).id, u10 = o10, l10 = i10, { transposed: c10, axes: p10, originalAxes: d10, inputWasTransposed: h10 } = Dr(i10, r10, t), f10 = p10;
  if (h10) {
    let v10 = t.dataIdMap.get(c10.dataId).id;
    v10 !== o10 && (l10 = c10, u10 = v10, f10 = N2.getInnerMostAxes(f10.length, l10.shape.length));
  }
  N2.assertAxesAreInnerMostDims("sum", f10, l10.shape.length);
  let [m10, g10] = N2.computeOutAndReduceShapes(l10.shape, f10), b10 = w2.sizeFromShape(g10), y10 = t.makeOutput(m10, l10.dtype);
  if (w2.sizeFromShape(l10.shape) !== 0) {
    let v10 = t.dataIdMap.get(y10.dataId).id;
    RN(u10, b10, Ct[y10.dtype], v10);
  }
  if (h10 && t.disposeData(c10.dataId), a10) {
    let v10 = N2.expandShapeToKeepDim(y10.shape, d10);
    y10.shape = v10;
  }
  return y10;
}
var Vce = { kernelName: ai, backendName: "wasm", setupFunc: Lce, kernelFunc: Bce };
var Wce = Kt(Bo);
var Uce = Kt(li);
var DN;
function Gce(e) {
  DN = e.wasm.cwrap(Sr, null, ["number", "array", "number", "array", "number", "number"]);
}
function Hce(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { x: r10 } = t, a10 = n10.dataIdMap.get(r10.dataId).id, { reps: i10 } = s10, o10 = new Array(r10.shape.length);
  for (let d10 = 0; d10 < o10.length; d10++)
    o10[d10] = r10.shape[d10] * i10[d10];
  let u10 = new Uint8Array(new Int32Array(r10.shape).buffer), l10 = new Uint8Array(new Int32Array(o10).buffer), c10 = n10.makeOutput(o10, r10.dtype), p10 = n10.dataIdMap.get(c10.dataId).id;
  return DN(a10, u10, r10.shape.length, l10, o10.length, Ct[c10.dtype], p10), c10;
}
var qce = { kernelName: Sr, backendName: "wasm", setupFunc: Gce, kernelFunc: Hce };
var FN;
function jce(e) {
  FN = e.wasm.cwrap(Vo, null, ["number", "array", "number", "number", "number", "bool", "number", "number"]);
}
var Kce = ({ inputs: e, backend: t, attrs: n10 }) => {
  let { x: s10 } = e, { k: r10, sorted: a10 } = n10, i10 = t.dataIdMap.get(s10.dataId).id, o10 = new Uint8Array(new Int32Array(s10.shape).buffer), u10 = s10.shape.slice();
  u10[u10.length - 1] = r10;
  let l10 = t.makeOutput(u10, s10.dtype), c10 = t.dataIdMap.get(l10.dataId).id, p10 = t.makeOutput(u10, "int32"), d10 = t.dataIdMap.get(p10.dataId).id;
  return FN(i10, o10, s10.shape.length, Ct[s10.dtype], r10, a10, c10, d10), [l10, p10];
};
var Xce = { kernelName: Vo, backendName: "wasm", setupFunc: jce, kernelFunc: Kce };
var ON;
function Yce(e) {
  ON = e.wasm.cwrap(Wo, null, ["number", "number", "bool", "number", "number", "number", "number", "number", "number", "array", "number", "number", "number", "number", "number"]);
}
function Qce(e) {
  let { backend: t, inputs: n10, attrs: s10 } = e, { image: r10, transforms: a10 } = n10, { interpolation: i10, fillMode: o10, fillValue: u10, outputShape: l10 } = s10, [c10, p10, d10, h10] = r10.shape, [f10, m10] = l10 != null ? l10 : [p10, d10], g10 = [c10, f10, m10, h10], b10 = new Uint8Array(new Int32Array(w2.computeStrides(r10.shape)).buffer), y10 = t.makeOutput(g10, r10.dtype), v10 = t.dataIdMap.get(y10.dataId).id, k10 = t.dataIdMap.get(r10.dataId).id, T10 = t.dataIdMap.get(a10.dataId).id, E10 = i10 === "nearest" ? 1 : 2, A10;
  switch (o10) {
    case "constant":
      A10 = 1;
      break;
    case "reflect":
      A10 = 2;
      break;
    case "wrap":
      A10 = 3;
      break;
    case "nearest":
      A10 = 4;
      break;
    default:
      A10 = 1;
      break;
  }
  return ON(k10, T10, a10.shape[0] > 1, c10, f10, m10, h10, d10, p10, b10, r10.shape.length - 1, E10, A10, u10, v10), y10;
}
var Zce = { kernelName: Wo, backendName: "wasm", setupFunc: Yce, kernelFunc: Qce };
function Jce(e) {
  let { inputs: t, backend: n10, attrs: s10 } = e, { value: r10 } = t, { axis: a10 } = s10;
  a10 < 0 && (a10 += r10.shape.length);
  let i10 = r10.shape[a10], o10 = r10.shape.length, u10 = new Array(o10 - 1), l10 = 0;
  for (let h10 = 0; h10 < o10; h10++)
    h10 !== a10 && (u10[l10++] = r10.shape[h10]);
  let c10 = new Array(i10), p10 = new Array(o10).fill(0), d10 = r10.shape.slice();
  d10[a10] = 1;
  for (let h10 = 0; h10 < c10.length; h10++)
    p10[a10] = h10, c10[h10] = ba({ inputs: { x: r10 }, attrs: { begin: p10, size: d10 }, backend: n10 });
  return c10.map(({ dataId: h10, dtype: f10 }) => ({ dataId: h10, dtype: f10, shape: u10 }));
}
var ede = { kernelName: Uo, backendName: "wasm", kernelFunc: Jce };
function tde(e) {
  let { inputs: { x: t }, backend: n10 } = e, s10 = n10.makeOutput(t.shape, t.dtype);
  return n10.typedArrayFromHeap(s10).fill(0), s10;
}
var nde = { kernelName: Go, backendName: "wasm", kernelFunc: tde };
var sde = [Kie, Xie, Qie, eoe, uoe, doe, foe, boe, woe, Toe, $oe, _oe, Roe, Doe, Poe, Loe, Boe, Voe, Goe, joe, Yoe, Joe, eue, nue, sue, rue, aue, uue, lue, due, fue, bue, xue, Iue, Nue, $ue, Aue, toe, Due, Oue, zue, Mue, Bue, Uue, Hue, Kue, Que, ele, nle, ale, ole, ule, dle, fle, ble, vle, kle, Sle, Nle, mN, Ale, Dle, Ple, Mle, Ble, Vle, Wle, yoe, Hle, Kle, Qle, Zle, Jle, nce, ace, uce, lce, Coe, pce, fce, bce, xce, kce, Sce, Nce, Tce, $ce, Ace, Dce, Pce, Mce, Vce, Wce, Uce, qce, Xce, Zce, aoe, ede, nde];
for (let e of sde)
  _l(e);
var Qm = X2();
Qm.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11])));
Qm.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
  if (Qm.get("IS_NODE"))
    return false;
  try {
    return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
  } catch (e) {
    return false;
  }
});
var Dw = ya(YT());
var rde = `"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`;
var ade = ya(QT());
var ide = class extends tl {
  constructor(e) {
    super();
    this.wasm = e, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(PN), Zm = this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new Wd(this, Ss());
  }
  write(e, t, n10) {
    let s10 = { id: this.dataIdNextNumber++ };
    return this.move(s10, e, t, n10, 1), s10;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  async time(e) {
    let t = w2.now();
    return e(), { kernelMs: w2.now() - t };
  }
  move(e, t, n10, s10, r10) {
    let a10 = this.dataIdNextNumber++;
    if (s10 === "string") {
      let l10 = t;
      this.dataIdMap.set(e, { id: a10, stringBytes: l10, shape: n10, dtype: s10, memoryOffset: null, refCount: r10 });
      return;
    }
    let i10 = w2.sizeFromShape(n10), o10 = i10 * w2.bytesPerElement(s10), u10 = this.wasm._malloc(o10);
    this.dataIdMap.set(e, { id: a10, memoryOffset: u10, shape: n10, dtype: s10, refCount: r10 }), this.wasm.tfjs.registerTensor(a10, i10, u10), t != null && this.wasm.HEAPU8.set(new Uint8Array(t.buffer, t.byteOffset, o10), u10);
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e, t, n10) {
    let { memoryOffset: s10, dtype: r10, shape: a10, stringBytes: i10 } = this.dataIdMap.get(e);
    if (r10 === "string")
      return (t == null || t === 0) && (n10 == null || n10 >= i10.length) ? i10 : i10.slice(t, n10);
    t = t || 0, n10 = n10 || w2.sizeFromShape(a10);
    let o10 = w2.bytesPerElement(r10), u10 = this.wasm.HEAPU8.slice(s10 + t * o10, s10 + n10 * o10);
    return lde(u10.buffer, r10);
  }
  disposeData(e, t = false) {
    if (this.dataIdMap.has(e)) {
      let n10 = this.dataIdMap.get(e);
      if (n10.refCount--, !t && n10.refCount > 0)
        return false;
      this.wasm._free(n10.memoryOffset), this.wasm.tfjs.disposeData(n10.id), this.dataIdMap.delete(e);
    }
    return true;
  }
  refCount(e) {
    return this.dataIdMap.has(e) ? this.dataIdMap.get(e).refCount : 0;
  }
  incRef(e) {
    let t = this.dataIdMap.get(e);
    t != null && t.refCount++;
  }
  floatPrecision() {
    return 32;
  }
  getMemoryOffset(e) {
    return this.dataIdMap.get(e).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), this.wasm = null;
  }
  memory() {
    return { unreliable: false };
  }
  makeOutput(e, t, n10) {
    let s10;
    if (n10 == null)
      s10 = this.write(null, e, t);
    else {
      let r10 = this.dataIdNextNumber++;
      s10 = { id: r10 }, this.dataIdMap.set(s10, { id: r10, memoryOffset: n10, shape: e, dtype: t, refCount: 1 });
      let a10 = w2.sizeFromShape(e);
      this.wasm.tfjs.registerTensor(r10, a10, n10);
    }
    return { dataId: s10, shape: e, dtype: t };
  }
  typedArrayFromHeap({ shape: e, dtype: t, dataId: n10 }) {
    let s10 = this.wasm.HEAPU8.buffer, { memoryOffset: r10 } = this.dataIdMap.get(n10), a10 = w2.sizeFromShape(e);
    switch (t) {
      case "float32":
        return new Float32Array(s10, r10, a10);
      case "int32":
        return new Int32Array(s10, r10, a10);
      case "bool":
        return new Uint8Array(s10, r10, a10);
      default:
        throw new Error(`Unknown dtype ${t}`);
    }
  }
};
function ode(e) {
  return (t, n10) => (w2.fetch(e, { credentials: "same-origin" }).then((s10) => {
    s10.ok || t.env.a(`failed to load wasm binary file at '${e}'`), s10.arrayBuffer().then((r10) => {
      WebAssembly.instantiate(r10, t).then((a10) => {
        n10(a10.instance, a10.module);
      });
    });
  }), {});
}
function Fw(e, t, n10) {
  if (Ld != null)
    return Ld;
  let s10 = "tfjs-backend-wasm.wasm";
  return e && t ? s10 = "tfjs-backend-wasm-threaded-simd.wasm" : e && (s10 = "tfjs-backend-wasm-simd.wasm"), Mu != null && Mu[s10] != null ? Mu[s10] : n10 + s10;
}
async function ude() {
  let [e, t] = await Promise.all([X2().getAsync("WASM_HAS_SIMD_SUPPORT"), X2().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);
  return new Promise((n10, s10) => {
    let r10 = {};
    r10.locateFile = (o10, u10) => {
      if (o10.endsWith(".worker.js")) {
        let l10 = rde, c10 = new Blob([l10], { type: "application/javascript" });
        return URL.createObjectURL(c10);
      }
      return o10.endsWith(".wasm") ? Fw(e, t, Ou != null ? Ou : u10) : u10 + o10;
    }, Av && (r10.instantiateWasm = ode(Fw(e, t, Ou != null ? Ou : "")));
    let a10 = false;
    r10.onAbort = () => {
      if (a10 || Lu)
        return;
      Lu = true, s10({ message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers" });
    };
    let i10;
    t && e && Ld == null ? (r10.mainScriptUrlOrBlob = new Blob(["var WasmBackendModuleThreadedSimd = " + Dw.default.toString()], { type: "text/javascript" }), i10 = (0, Dw.default)(r10)) : i10 = (0, ade.default)(r10), i10.then((o10) => {
      a10 = true, Lu = false;
      let u10 = null;
      o10.tfjs = { init: o10.cwrap("init", null, []), initWithThreadsCount: o10.cwrap("init_with_threads_count", null, ["number"]), getThreadsCount: o10.cwrap("get_threads_count", "number", []), registerTensor: o10.cwrap("register_tensor", null, ["number", "number", "number"]), disposeData: o10.cwrap("dispose_data", u10, ["number"]), dispose: o10.cwrap("dispose", u10, []) }, n10({ wasm: o10 });
    });
  });
}
function lde(e, t) {
  switch (t) {
    case "float32":
      return new Float32Array(e);
    case "int32":
      return new Int32Array(e);
    case "bool":
      return new Uint8Array(e);
    default:
      throw new Error(`Unknown dtype ${t}`);
  }
}
var cde = ["tfjs-backend-wasm.wasm", "tfjs-backend-wasm-simd.wasm", "tfjs-backend-wasm-threaded-simd.wasm"];
var Ld = null;
var Ou = null;
var Mu = {};
var Lu = false;
var Av = false;
function Ipe(e, t = false) {
  if (Mk("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."), Lu)
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
  Ld = e, Av = t;
}
function Spe(e, t = false) {
  if (Lu)
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
  if (typeof e == "string")
    Ou = e;
  else {
    Mu = e;
    let n10 = cde.filter((s10) => Mu[s10] == null);
    if (n10.length > 0)
      throw new Error(`There were no entries found for the following binaries: ${n10.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
  }
  Av = t;
}
var PN = -1;
var Zm = -1;
function Cpe(e) {
  PN = e;
}
function Npe() {
  if (Zm === -1)
    throw new Error("WASM backend not initialized.");
  return Zm;
}
var Tpe = "0.0.0";
var dde = 2;
dp("wasm", async () => {
  let { wasm: e } = await ude();
  return new ide(e);
}, dde);
var sr = "3.14.0-20220307";
var $pe = { tfjs: sr, "tfjs-core": sr, "tfjs-data": sr, "tfjs-layers": sr, "tfjs-converter": sr, "tfjs-backend-cpu": sr, "tfjs-backend-webgl": sr, "tfjs-backend-wasm": sr };
var vertexIdentity = `
  precision highp float;
  attribute vec2 pos;
  attribute vec2 uv;
  varying vec2 vUv;
  uniform float flipY;
  void main(void) {
    vUv = uv;
    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);
  }
`;
var colorMatrixWithAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];
    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];
  }
`;
var colorMatrixWithoutAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];
    gl_FragColor.a = c.a;
  }
`;
var pixelate = `
  precision highp float;
  varying vec2 vUv;
  uniform vec2 size;
  uniform sampler2D texture;
  vec2 pixelate(vec2 coord, vec2 size) {
    return floor( coord / size ) * size;
  }
  void main(void) {
    gl_FragColor = vec4(0.0);
    vec2 coord = pixelate(vUv, size);
    gl_FragColor += texture2D(texture, coord);
  }
`;
var blur = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  void main(void) {
    gl_FragColor = vec4(0.0);
    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;
    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;
    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;
  }
`;
var convolution = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  uniform float m[9];
  void main(void) {
    vec4 c11 = texture2D(texture, vUv - px); // top left
    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center
    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right
    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left
    vec4 c22 = texture2D(texture, vUv); // mid center
    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right
    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left
    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center
    vec4 c33 = texture2D(texture, vUv + px ); // bottom right
    gl_FragColor = 
    c11 * m[0] + c12 * m[1] + c22 * m[2] +
    c21 * m[3] + c22 * m[4] + c23 * m[5] +
    c31 * m[6] + c32 * m[7] + c33 * m[8];
    gl_FragColor.a = c22.a;
  }
`;
var collect = (source, prefix, collection) => {
  const r10 = new RegExp("\\b" + prefix + " \\w+ (\\w+)", "ig");
  source.replace(r10, (match3, name) => {
    collection[name] = 0;
    return match3;
  });
};
var GLProgram = class {
  constructor(gl2, vertexSource, fragmentSource) {
    __publicField(this, "uniform", {});
    __publicField(this, "attribute", {});
    __publicField(this, "gl");
    __publicField(this, "id");
    __publicField(this, "compile", (source, type) => {
      const shader = this.gl.createShader(type);
      if (!shader) {
        log("filter: could not create shader");
        return null;
      }
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        log(`filter: gl compile failed: ${this.gl.getShaderInfoLog(shader)}`);
        return null;
      }
      return shader;
    });
    this.gl = gl2;
    const vertexShader = this.compile(vertexSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compile(fragmentSource, this.gl.FRAGMENT_SHADER);
    this.id = this.gl.createProgram();
    if (!vertexShader || !fragmentShader)
      return;
    if (!this.id) {
      log("filter: could not create webgl program");
      return;
    }
    this.gl.attachShader(this.id, vertexShader);
    this.gl.attachShader(this.id, fragmentShader);
    this.gl.linkProgram(this.id);
    if (!this.gl.getProgramParameter(this.id, this.gl.LINK_STATUS)) {
      log(`filter: gl link failed: ${this.gl.getProgramInfoLog(this.id)}`);
      return;
    }
    this.gl.useProgram(this.id);
    collect(vertexSource, "attribute", this.attribute);
    for (const a10 in this.attribute)
      this.attribute[a10] = this.gl.getAttribLocation(this.id, a10);
    collect(vertexSource, "uniform", this.uniform);
    collect(fragmentSource, "uniform", this.uniform);
    for (const u10 in this.uniform)
      this.uniform[u10] = this.gl.getUniformLocation(this.id, u10);
  }
};
function GLImageFilter() {
  let drawCount = 0;
  let sourceTexture = null;
  let lastInChain = false;
  let currentFramebufferIndex = -1;
  let tempFramebuffers = [null, null];
  let filterChain = [];
  let vertexBuffer = null;
  let currentProgram = null;
  const fxcanvas = canvas(100, 100);
  const shaderProgramCache = {};
  const DRAW = { INTERMEDIATE: 1 };
  const gl2 = fxcanvas.getContext("webgl");
  this.gl = gl2;
  if (!gl2) {
    log("filter: cannot get webgl context");
    return;
  }
  function resize(width, height) {
    if (width === fxcanvas.width && height === fxcanvas.height)
      return;
    fxcanvas.width = width;
    fxcanvas.height = height;
    if (!vertexBuffer) {
      const vertices = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0]);
      vertexBuffer = gl2.createBuffer();
      gl2.bindBuffer(gl2.ARRAY_BUFFER, vertexBuffer);
      gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW);
      gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    }
    gl2.viewport(0, 0, fxcanvas.width, fxcanvas.height);
    tempFramebuffers = [null, null];
  }
  function createFramebufferTexture(width, height) {
    const fbo = gl2.createFramebuffer();
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, fbo);
    const renderbuffer = gl2.createRenderbuffer();
    gl2.bindRenderbuffer(gl2.RENDERBUFFER, renderbuffer);
    const texture = gl2.createTexture();
    gl2.bindTexture(gl2.TEXTURE_2D, texture);
    gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, width, height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, null);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
    gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0);
    gl2.bindTexture(gl2.TEXTURE_2D, null);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
    return { fbo, texture };
  }
  function getTempFramebuffer(index2) {
    tempFramebuffers[index2] = tempFramebuffers[index2] || createFramebufferTexture(fxcanvas.width, fxcanvas.height);
    return tempFramebuffers[index2];
  }
  function draw(flags = 0) {
    if (!currentProgram)
      return;
    let source = null;
    let target = null;
    let flipY = false;
    if (drawCount === 0)
      source = sourceTexture;
    else
      source = getTempFramebuffer(currentFramebufferIndex).texture || null;
    drawCount++;
    if (lastInChain && !(flags & DRAW.INTERMEDIATE)) {
      target = null;
      flipY = drawCount % 2 === 0;
    } else {
      currentFramebufferIndex = (currentFramebufferIndex + 1) % 2;
      target = getTempFramebuffer(currentFramebufferIndex).fbo || null;
    }
    gl2.bindTexture(gl2.TEXTURE_2D, source);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, target);
    gl2.uniform1f(currentProgram.uniform["flipY"], flipY ? -1 : 1);
    gl2.drawArrays(gl2.TRIANGLES, 0, 6);
  }
  function compileShader(fragmentSource) {
    if (shaderProgramCache[fragmentSource]) {
      currentProgram = shaderProgramCache[fragmentSource];
      gl2.useProgram((currentProgram ? currentProgram.id : null) || null);
      return currentProgram;
    }
    currentProgram = new GLProgram(gl2, vertexIdentity, fragmentSource);
    if (!currentProgram) {
      log("filter: could not get webgl program");
      return null;
    }
    const floatSize = Float32Array.BYTES_PER_ELEMENT;
    const vertSize = 4 * floatSize;
    gl2.enableVertexAttribArray(currentProgram.attribute["pos"]);
    gl2.vertexAttribPointer(currentProgram.attribute["pos"], 2, gl2.FLOAT, false, vertSize, 0 * floatSize);
    gl2.enableVertexAttribArray(currentProgram.attribute["uv"]);
    gl2.vertexAttribPointer(currentProgram.attribute["uv"], 2, gl2.FLOAT, false, vertSize, 2 * floatSize);
    shaderProgramCache[fragmentSource] = currentProgram;
    return currentProgram;
  }
  const filter = {
    colorMatrix: (matrix) => {
      const m10 = new Float32Array(matrix);
      m10[4] /= 255;
      m10[9] /= 255;
      m10[14] /= 255;
      m10[19] /= 255;
      const shader = m10[18] === 1 && m10[3] === 0 && m10[8] === 0 && m10[13] === 0 && m10[15] === 0 && m10[16] === 0 && m10[17] === 0 && m10[19] === 0 ? colorMatrixWithoutAlpha : colorMatrixWithAlpha;
      const program = compileShader(shader);
      if (!program)
        return;
      gl2.uniform1fv(program.uniform["m"], m10);
      draw();
    },
    brightness: (brightness) => {
      const b10 = (brightness || 0) + 1;
      filter.colorMatrix([
        b10,
        0,
        0,
        0,
        0,
        0,
        b10,
        0,
        0,
        0,
        0,
        0,
        b10,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    saturation: (amount) => {
      const x10 = (amount || 0) * 2 / 3 + 1;
      const y10 = (x10 - 1) * -0.5;
      filter.colorMatrix([
        x10,
        y10,
        y10,
        0,
        0,
        y10,
        x10,
        y10,
        0,
        0,
        y10,
        y10,
        x10,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    desaturate: () => {
      filter.saturation(-1);
    },
    contrast: (amount) => {
      const v10 = (amount || 0) + 1;
      const o10 = -128 * (v10 - 1);
      filter.colorMatrix([
        v10,
        0,
        0,
        0,
        o10,
        0,
        v10,
        0,
        0,
        o10,
        0,
        0,
        v10,
        0,
        o10,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    negative: () => {
      filter.contrast(-2);
    },
    hue: (rotation) => {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const lumR = 0.213;
      const lumG = 0.715;
      const lumB = 0.072;
      filter.colorMatrix([
        lumR + cos * (1 - lumR) + sin * -lumR,
        lumG + cos * -lumG + sin * -lumG,
        lumB + cos * -lumB + sin * (1 - lumB),
        0,
        0,
        lumR + cos * -lumR + sin * 0.143,
        lumG + cos * (1 - lumG) + sin * 0.14,
        lumB + cos * -lumB + sin * -0.283,
        0,
        0,
        lumR + cos * -lumR + sin * -(1 - lumR),
        lumG + cos * -lumG + sin * lumG,
        lumB + cos * (1 - lumB) + sin * lumB,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    desaturateLuminance: () => {
      filter.colorMatrix([
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    sepia: () => {
      filter.colorMatrix([
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    brownie: () => {
      filter.colorMatrix([
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    vintagePinhole: () => {
      filter.colorMatrix([
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    kodachrome: () => {
      filter.colorMatrix([
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    technicolor: () => {
      filter.colorMatrix([
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    polaroid: () => {
      filter.colorMatrix([
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    shiftToBGR: () => {
      filter.colorMatrix([
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    },
    convolution: (matrix) => {
      const m10 = new Float32Array(matrix);
      const pixelSizeX = 1 / fxcanvas.width;
      const pixelSizeY = 1 / fxcanvas.height;
      const program = compileShader(convolution);
      if (!program)
        return;
      gl2.uniform1fv(program.uniform["m"], m10);
      gl2.uniform2f(program.uniform["px"], pixelSizeX, pixelSizeY);
      draw();
    },
    detectEdges: () => {
      filter.convolution.call(this, [
        0,
        1,
        0,
        1,
        -4,
        1,
        0,
        1,
        0
      ]);
    },
    sobelX: () => {
      filter.convolution.call(this, [
        -1,
        0,
        1,
        -2,
        0,
        2,
        -1,
        0,
        1
      ]);
    },
    sobelY: () => {
      filter.convolution.call(this, [
        -1,
        -2,
        -1,
        0,
        0,
        0,
        1,
        2,
        1
      ]);
    },
    sharpen: (amount) => {
      const a10 = amount || 1;
      filter.convolution.call(this, [
        0,
        -1 * a10,
        0,
        -1 * a10,
        1 + 4 * a10,
        -1 * a10,
        0,
        -1 * a10,
        0
      ]);
    },
    emboss: (size2) => {
      const s10 = size2 || 1;
      filter.convolution.call(this, [
        -2 * s10,
        -1 * s10,
        0,
        -1 * s10,
        1,
        1 * s10,
        0,
        1 * s10,
        2 * s10
      ]);
    },
    blur: (size2) => {
      const blurSizeX = size2 / 7 / fxcanvas.width;
      const blurSizeY = size2 / 7 / fxcanvas.height;
      const program = compileShader(blur);
      if (!program)
        return;
      gl2.uniform2f(program.uniform["px"], 0, blurSizeY);
      draw(DRAW.INTERMEDIATE);
      gl2.uniform2f(program.uniform["px"], blurSizeX, 0);
      draw();
    },
    pixelate: (size2) => {
      const blurSizeX = size2 / fxcanvas.width;
      const blurSizeY = size2 / fxcanvas.height;
      const program = compileShader(pixelate);
      if (!program)
        return;
      gl2.uniform2f(program.uniform["size"], blurSizeX, blurSizeY);
      draw();
    }
  };
  this.add = function(name) {
    const args = Array.prototype.slice.call(arguments, 1);
    const func = filter[name];
    filterChain.push({ func, args });
  };
  this.reset = function() {
    filterChain = [];
  };
  this.get = function() {
    return filterChain;
  };
  this.apply = function(image) {
    resize(image.width, image.height);
    drawCount = 0;
    if (!sourceTexture)
      sourceTexture = gl2.createTexture();
    gl2.bindTexture(gl2.TEXTURE_2D, sourceTexture);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
    gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
    gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, image);
    for (let i10 = 0; i10 < filterChain.length; i10++) {
      lastInChain = i10 === filterChain.length - 1;
      const f10 = filterChain[i10];
      f10.func.apply(this, f10.args || []);
    }
    return fxcanvas;
  };
  this.draw = function(image) {
    this.add("brightness", 0);
    return this.apply(image);
  };
}
async function histogramEqualization(inputImage) {
  const squeeze = inputImage.shape.length === 4 ? mr(inputImage) : inputImage;
  const channels = Ln(squeeze, 3, 2);
  const min = [pm(channels[0]), pm(channels[1]), pm(channels[2])];
  const max = [As(channels[0]), As(channels[1]), As(channels[2])];
  const absMax = await Promise.all(max.map((channel) => channel.data()));
  const maxValue = 0.99 * Math.max(absMax[0][0], absMax[1][0], absMax[2][0]);
  const sub = [ge2(channels[0], min[0]), ge2(channels[1], min[1]), ge2(channels[2], min[2])];
  const range = [ge2(max[0], min[0]), ge2(max[1], min[1]), ge2(max[2], min[2])];
  const fact = [xe2(maxValue, range[0]), xe2(maxValue, range[1]), xe2(maxValue, range[2])];
  const enh = [V2(sub[0], fact[0]), V2(sub[1], fact[1]), V2(sub[2], fact[2])];
  const rgb2 = Qn([enh[0], enh[1], enh[2]], 2);
  const reshape = G2(rgb2, [1, squeeze.shape[0], squeeze.shape[1], 3]);
  Re2([...channels, ...min, ...max, ...sub, ...range, ...fact, ...enh, rgb2, squeeze]);
  return reshape;
}
var maxSize = 2048;
var inCanvas = null;
var outCanvas = null;
var tmpCanvas = null;
var fx2;
var last = {
  inputSum: 0,
  cacheDiff: 1,
  sumMethod: 0,
  inputTensor: void 0
};
function canvas(width, height) {
  let c10;
  if (env.browser) {
    if (env.worker) {
      if (typeof OffscreenCanvas === "undefined")
        throw new Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");
      c10 = new OffscreenCanvas(width, height);
    } else {
      if (typeof document === "undefined")
        throw new Error("canvas error: attempted to run in browser but DOM is not defined");
      c10 = document.createElement("canvas");
      c10.width = width;
      c10.height = height;
    }
  } else {
    if (typeof env.Canvas !== "undefined")
      c10 = new env.Canvas(width, height);
    else if (typeof globalThis.Canvas !== "undefined")
      c10 = new globalThis.Canvas(width, height);
  }
  return c10;
}
function copy(input, output) {
  const outputCanvas = output || canvas(input.width, input.height);
  const ctx = outputCanvas.getContext("2d");
  ctx.drawImage(input, 0, 0);
  return outputCanvas;
}
async function process2(input, config3, getTensor = true) {
  if (!input) {
    if (config3.debug)
      log("input error: input is missing");
    return { tensor: null, canvas: null };
  }
  if (!(input instanceof et) && !(typeof Image !== "undefined" && input instanceof Image) && !(typeof env.Canvas !== "undefined" && input instanceof env.Canvas) && !(typeof globalThis.Canvas !== "undefined" && input instanceof globalThis.Canvas) && !(typeof ImageData !== "undefined" && input instanceof ImageData) && !(typeof ImageBitmap !== "undefined" && input instanceof ImageBitmap) && !(typeof HTMLImageElement !== "undefined" && input instanceof HTMLImageElement) && !(typeof HTMLMediaElement !== "undefined" && input instanceof HTMLMediaElement) && !(typeof HTMLVideoElement !== "undefined" && input instanceof HTMLVideoElement) && !(typeof HTMLCanvasElement !== "undefined" && input instanceof HTMLCanvasElement) && !(typeof OffscreenCanvas !== "undefined" && input instanceof OffscreenCanvas)) {
    throw new Error("input error: type is not recognized");
  }
  if (input instanceof et) {
    let tensor = null;
    if (input["isDisposedInternal"])
      throw new Error("input error: attempted to use tensor but it is disposed");
    if (!input["shape"])
      throw new Error("input error: attempted to use tensor without a shape");
    if (input.shape.length === 3) {
      if (input.shape[2] === 3) {
        tensor = On(input, 0);
      } else if (input.shape[2] === 4) {
        const rgb2 = ab(input, [0, 0, 0], [-1, -1, 3]);
        tensor = On(rgb2, 0);
        Re2(rgb2);
      }
    } else if (input.shape.length === 4) {
      if (input.shape[3] === 3) {
        tensor = lr(input);
      } else if (input.shape[3] === 4) {
        tensor = wd(input, [0, 0, 0, 0], [-1, -1, -1, 3]);
      }
    }
    if (tensor == null || tensor.shape.length !== 4 || tensor.shape[0] !== 1 || tensor.shape[3] !== 3)
      throw new Error(`input error: attempted to use tensor with unrecognized shape: ${input["shape"]}`);
    if (tensor.dtype === "int32") {
      const cast = ce2(tensor, "float32");
      Re2(tensor);
      tensor = cast;
    }
    return { tensor, canvas: config3.filter.return ? outCanvas : null };
  } else {
    if (typeof input["readyState"] !== "undefined" && input["readyState"] <= 2) {
      if (config3.debug)
        log("input stream is not ready");
      return { tensor: null, canvas: inCanvas };
    }
    const originalWidth = input["naturalWidth"] || input["videoWidth"] || input["width"] || input["shape"] && input["shape"][1] > 0;
    const originalHeight = input["naturalHeight"] || input["videoHeight"] || input["height"] || input["shape"] && input["shape"][2] > 0;
    if (!originalWidth || !originalHeight) {
      if (config3.debug)
        log("cannot determine input dimensions");
      return { tensor: null, canvas: inCanvas };
    }
    let targetWidth = originalWidth;
    let targetHeight = originalHeight;
    if (targetWidth > maxSize) {
      targetWidth = maxSize;
      targetHeight = Math.trunc(targetWidth * originalHeight / originalWidth);
    }
    if (targetHeight > maxSize) {
      targetHeight = maxSize;
      targetWidth = Math.trunc(targetHeight * originalWidth / originalHeight);
    }
    if ((config3.filter.width || 0) > 0)
      targetWidth = config3.filter.width;
    else if ((config3.filter.height || 0) > 0)
      targetWidth = originalWidth * ((config3.filter.height || 0) / originalHeight);
    if ((config3.filter.height || 0) > 0)
      targetHeight = config3.filter.height;
    else if ((config3.filter.width || 0) > 0)
      targetHeight = originalHeight * ((config3.filter.width || 0) / originalWidth);
    if (!targetWidth || !targetHeight)
      throw new Error("input error: cannot determine dimension");
    if (!inCanvas || (inCanvas == null ? void 0 : inCanvas.width) !== targetWidth || (inCanvas == null ? void 0 : inCanvas.height) !== targetHeight)
      inCanvas = canvas(targetWidth, targetHeight);
    const inCtx = inCanvas.getContext("2d");
    if (typeof ImageData !== "undefined" && input instanceof ImageData) {
      inCtx.putImageData(input, 0, 0);
    } else {
      if (config3.filter.flip && typeof inCtx.translate !== "undefined") {
        inCtx.translate(originalWidth, 0);
        inCtx.scale(-1, 1);
        inCtx.drawImage(input, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas == null ? void 0 : inCanvas.width, inCanvas == null ? void 0 : inCanvas.height);
        inCtx.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        inCtx.drawImage(input, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas == null ? void 0 : inCanvas.width, inCanvas == null ? void 0 : inCanvas.height);
      }
    }
    if (!outCanvas || inCanvas.width !== outCanvas.width || (inCanvas == null ? void 0 : inCanvas.height) !== (outCanvas == null ? void 0 : outCanvas.height))
      outCanvas = canvas(inCanvas.width, inCanvas.height);
    if (config3.filter.enabled && env.webgl.supported) {
      if (!fx2)
        fx2 = env.browser ? new GLImageFilter() : null;
      env.filter = !!fx2;
      if (!fx2 || !fx2.add) {
        if (config3.debug)
          log("input process error: cannot initialize filters");
        return { tensor: null, canvas: inCanvas };
      }
      fx2.reset();
      if (config3.filter.brightness !== 0)
        fx2.add("brightness", config3.filter.brightness);
      if (config3.filter.contrast !== 0)
        fx2.add("contrast", config3.filter.contrast);
      if (config3.filter.sharpness !== 0)
        fx2.add("sharpen", config3.filter.sharpness);
      if (config3.filter.blur !== 0)
        fx2.add("blur", config3.filter.blur);
      if (config3.filter.saturation !== 0)
        fx2.add("saturation", config3.filter.saturation);
      if (config3.filter.hue !== 0)
        fx2.add("hue", config3.filter.hue);
      if (config3.filter.negative)
        fx2.add("negative");
      if (config3.filter.sepia)
        fx2.add("sepia");
      if (config3.filter.vintage)
        fx2.add("brownie");
      if (config3.filter.sepia)
        fx2.add("sepia");
      if (config3.filter.kodachrome)
        fx2.add("kodachrome");
      if (config3.filter.technicolor)
        fx2.add("technicolor");
      if (config3.filter.polaroid)
        fx2.add("polaroid");
      if (config3.filter.pixelate !== 0)
        fx2.add("pixelate", config3.filter.pixelate);
      if (fx2.get() > 0)
        outCanvas = fx2.apply(inCanvas);
      else
        outCanvas = fx2.draw(inCanvas);
    } else {
      copy(inCanvas, outCanvas);
      if (fx2)
        fx2 = null;
      env.filter = !!fx2;
    }
    if (!getTensor)
      return { tensor: null, canvas: outCanvas };
    if (!outCanvas)
      throw new Error("canvas error: cannot create output");
    let pixels;
    let depth = 3;
    if (typeof ImageData !== "undefined" && input instanceof ImageData || input["data"] && input["width"] && input["height"]) {
      if (env.browser && xk) {
        pixels = xk ? xk.fromPixels(input) : null;
      } else {
        depth = input["data"].length / input["height"] / input["width"];
        const arr = new Uint8Array(input["data"]["buffer"]);
        pixels = hs(arr, [input["height"], input["width"], depth], "int32");
      }
    } else {
      if (!tmpCanvas || outCanvas.width !== tmpCanvas.width || outCanvas.height !== tmpCanvas.height)
        tmpCanvas = canvas(outCanvas.width, outCanvas.height);
      if (xk && env.browser) {
        if (config3.backend === "webgl" || config3.backend === "humangl" || config3.backend === "webgpu") {
          pixels = xk.fromPixels(outCanvas);
        } else {
          tmpCanvas = copy(outCanvas);
          pixels = xk.fromPixels(tmpCanvas);
        }
      } else {
        const tempCanvas = copy(outCanvas);
        const tempCtx = tempCanvas.getContext("2d");
        const tempData = tempCtx.getImageData(0, 0, targetWidth, targetHeight);
        depth = tempData.data.length / targetWidth / targetHeight;
        const arr = new Uint8Array(tempData.data.buffer);
        pixels = hs(arr, [targetWidth, targetHeight, depth]);
      }
    }
    if (depth === 4) {
      const rgb2 = ab(pixels, [0, 0, 0], [-1, -1, 3]);
      Re2(pixels);
      pixels = rgb2;
    }
    if (!pixels)
      throw new Error("input error: cannot create tensor");
    const casted = ce2(pixels, "float32");
    const tensor = config3.filter.equalization ? await histogramEqualization(casted) : On(casted, 0);
    Re2([pixels, casted]);
    return { tensor, canvas: config3.filter.return ? outCanvas : null };
  }
}
async function skip(config3, input) {
  let skipFrame = false;
  if (config3.cacheSensitivity === 0 || !input.shape || input.shape.length !== 4 || input.shape[1] > 2048 || input.shape[2] > 2048)
    return skipFrame;
  if (!last.inputTensor) {
    last.inputTensor = lr(input);
  } else if (last.inputTensor.shape[1] !== input.shape[1] || last.inputTensor.shape[2] !== input.shape[2]) {
    Re2(last.inputTensor);
    last.inputTensor = lr(input);
  } else {
    const t = {};
    t.diff = ge2(input, last.inputTensor);
    t.squared = V2(t.diff, t.diff);
    t.sum = ye2(t.squared);
    const diffSum = await t.sum.data();
    const diffRelative = diffSum[0] / (input.shape[1] || 1) / (input.shape[2] || 1) / 255 / 3;
    Re2([last.inputTensor, t.diff, t.squared, t.sum]);
    last.inputTensor = lr(input);
    skipFrame = diffRelative <= (config3.cacheSensitivity || 0);
  }
  return skipFrame;
}
async function compare(config3, input1, input2) {
  const t = {};
  if (!input1 || !input2 || input1.shape.length !== 4 || input1.shape.length !== input2.shape.length) {
    if (!config3.debug)
      log("invalid input tensor or tensor shapes do not match:", input1.shape, input2.shape);
    return 0;
  }
  if (input1.shape[0] !== 1 || input2.shape[0] !== 1 || input1.shape[3] !== 3 || input2.shape[3] !== 3) {
    if (!config3.debug)
      log("input tensors must be of shape [1, height, width, 3]:", input1.shape, input2.shape);
    return 0;
  }
  t.input1 = lr(input1);
  t.input2 = input1.shape[1] !== input2.shape[1] || input1.shape[2] !== input2.shape[2] ? ds.resizeBilinear(input2, [input1.shape[1], input1.shape[2]]) : lr(input2);
  t.diff = ge2(t.input1, t.input2);
  t.squared = V2(t.diff, t.diff);
  t.sum = ye2(t.squared);
  const diffSum = await t.sum.data();
  const diffRelative = diffSum[0] / (input1.shape[1] || 1) / (input1.shape[2] || 1) / 255 / 3;
  Re2([t.input1, t.input2, t.diff, t.squared, t.sum]);
  return diffRelative;
}
var Env = class {
  constructor() {
    __publicField(this, "browser");
    __publicField(this, "node");
    __publicField(this, "worker");
    __publicField(this, "platform", "");
    __publicField(this, "agent", "");
    __publicField(this, "backends", []);
    __publicField(this, "initial");
    __publicField(this, "filter");
    __publicField(this, "tfjs");
    __publicField(this, "offscreen");
    __publicField(this, "perfadd", false);
    __publicField(this, "wasm", {
      supported: void 0,
      backend: void 0,
      simd: void 0,
      multithread: void 0
    });
    __publicField(this, "webgl", {
      supported: void 0,
      backend: void 0,
      version: void 0,
      renderer: void 0
    });
    __publicField(this, "webgpu", {
      supported: void 0,
      backend: void 0,
      adapter: void 0
    });
    __publicField(this, "cpu", {
      model: void 0,
      flags: []
    });
    __publicField(this, "kernels", []);
    __publicField(this, "Canvas");
    __publicField(this, "Image");
    __publicField(this, "ImageData");
    this.browser = typeof navigator !== "undefined";
    this.node = typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    this.tfjs = { version: $pe["tfjs-core"] };
    this.offscreen = typeof OffscreenCanvas !== "undefined";
    this.initial = true;
    this.worker = this.browser && this.offscreen ? typeof WorkerGlobalScope !== "undefined" : void 0;
    if (typeof navigator !== "undefined") {
      const raw = navigator.userAgent.match(/\(([^()]+)\)/g);
      if (raw && raw[0]) {
        const platformMatch = raw[0].match(/\(([^()]+)\)/g);
        this.platform = platformMatch && platformMatch[0] ? platformMatch[0].replace(/\(|\)/g, "") : "";
        this.agent = navigator.userAgent.replace(raw[0], "");
        if (this.platform[1])
          this.agent = this.agent.replace(raw[1], "");
        this.agent = this.agent.replace(/  /g, " ");
      }
    } else if (typeof process !== "undefined") {
      this.platform = `${process.platform} ${process.arch}`;
      this.agent = `NodeJS ${process.version}`;
    }
  }
  async updateBackend() {
    this.backends = Object.keys(Ss().registryFactory);
    this.wasm.supported = typeof WebAssembly !== "undefined";
    this.wasm.backend = this.backends.includes("wasm");
    if (this.wasm.supported && this.wasm.backend && Cde() === "wasm") {
      this.wasm.simd = await X2().getAsync("WASM_HAS_SIMD_SUPPORT");
      this.wasm.multithread = await X2().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
    }
    const c10 = canvas(100, 100);
    const ctx = c10 ? c10.getContext("webgl2") : void 0;
    this.webgl.supported = typeof ctx !== "undefined";
    this.webgl.backend = this.backends.includes("webgl");
    if (this.webgl.supported && this.webgl.backend && (Cde() === "webgl" || Cde() === "humangl")) {
      const gl2 = $A().gpgpu !== "undefined" ? await $A().getGPGPUContext().gl : null;
      if (gl2) {
        this.webgl.version = gl2.getParameter(gl2.VERSION);
        this.webgl.renderer = gl2.getParameter(gl2.RENDERER);
      }
    }
    this.webgpu.supported = this.browser && typeof navigator["gpu"] !== "undefined";
    this.webgpu.backend = this.backends.includes("webgpu");
    try {
      if (this.webgpu.supported)
        this.webgpu.adapter = (await navigator["gpu"].requestAdapter()).name;
    } catch (e) {
      this.webgpu.supported = false;
    }
    try {
      this.kernels = Qf(Cde()).map((kernel) => kernel.kernelName.toLowerCase());
    } catch (e) {
    }
  }
  async updateCPU() {
    const cpu = { model: "", flags: [] };
    if (this.node && this.platform.startsWith("linux")) {
    }
    if (!this["cpu"])
      Object.defineProperty(this, "cpu", { value: cpu });
    else
      this["cpu"] = cpu;
  }
};
var env = new Env();
var options = {
  cacheModels: false,
  verbose: true,
  debug: false,
  modelBasePath: ""
};
async function httpHandler(url, init2) {
  if (options.debug)
    log("load model fetch:", url, init2);
  return fetch(url, init2);
}
function setModelLoadOptions(config3) {
  options.cacheModels = config3.cacheModels;
  options.verbose = config3.debug;
  options.modelBasePath = config3.modelBasePath;
}
async function loadModel(modelPath) {
  const modelUrl = join(options.modelBasePath, modelPath || "");
  const modelPathSegments = modelUrl.split("/");
  const cachedModelName = "indexeddb://" + modelPathSegments[modelPathSegments.length - 1].replace(".json", "");
  const cachedModels = await _n.listModels();
  const modelCached = options.cacheModels && Object.keys(cachedModels).includes(cachedModelName);
  const tfLoadOptions = typeof fetch === "undefined" ? {} : { fetchFunc: (url, init2) => httpHandler(url, init2) };
  const model182 = new w4(modelCached ? cachedModelName : modelUrl, tfLoadOptions);
  try {
    model182.findIOHandler();
    if (options.debug)
      log("model load handler:", model182.handler);
    const artifacts = await model182.handler.load();
    model182.loadSync(artifacts);
    if (options.verbose)
      log("load model:", model182["modelUrl"]);
  } catch (err) {
    log("error loading model:", modelUrl, err);
  }
  if (options.cacheModels && !modelCached) {
    try {
      const saveResult = await model182.save(cachedModelName);
      log("model saved:", cachedModelName, saveResult);
    } catch (err) {
      log("error saving model:", modelUrl, err);
    }
  }
  return model182;
}
var version = "2.6.4";
var model;
var last2 = [];
var raceNames = ["white", "black", "asian", "indian", "other"];
var ageWeights = [15, 23, 28, 35.5, 45.5, 55.5, 65];
var lastCount = 0;
var lastTime = 0;
var skipped = Number.MAX_SAFE_INTEGER;
async function load(config3) {
  if (env.initial)
    model = null;
  if (!model)
    model = await loadModel(config3.face["gear"]);
  else if (config3.debug)
    log("cached model:", model["modelUrl"]);
  return model;
}
async function predict(image, config3, idx, count2) {
  var _a2, _b2;
  if (!model)
    return { age: 0, gender: "unknown", genderScore: 0, race: [] };
  const skipFrame = skipped < (((_a2 = config3.face["gear"]) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face["gear"]) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime;
  if (config3.skipAllowed && skipTime && skipFrame && lastCount === count2 && last2[idx]) {
    skipped++;
    return last2[idx];
  }
  skipped = 0;
  return new Promise(async (resolve) => {
    var _a3, _b3;
    if (!(model == null ? void 0 : model.inputs[0].shape))
      return;
    const t = {};
    const box = [[0, 0.1, 0.9, 0.9]];
    t.resize = ds.cropAndResize(image, box, [0], [model.inputs[0].shape[2], model.inputs[0].shape[1]]);
    const obj = { age: 0, gender: "unknown", genderScore: 0, race: [] };
    if ((_a3 = config3.face["gear"]) == null ? void 0 : _a3.enabled)
      [t.age, t.gender, t.race] = model.execute(t.resize, ["age_output", "gender_output", "race_output"]);
    const gender = await t.gender.data();
    obj.gender = gender[0] > gender[1] ? "male" : "female";
    obj.genderScore = Math.round(100 * (gender[0] > gender[1] ? gender[0] : gender[1])) / 100;
    const race = await t.race.data();
    for (let i10 = 0; i10 < race.length; i10++) {
      if (race[i10] > (((_b3 = config3.face["gear"]) == null ? void 0 : _b3.minConfidence) || 0.2))
        obj.race.push({ score: Math.round(100 * race[i10]) / 100, race: raceNames[i10] });
    }
    obj.race.sort((a10, b10) => b10.score - a10.score);
    const ageDistribution = Array.from(await t.age.data());
    const ageSorted = ageDistribution.map((a10, i10) => [ageWeights[i10], a10]).sort((a10, b10) => b10[1] - a10[1]);
    let age = ageSorted[0][0];
    for (let i10 = 1; i10 < ageSorted.length; i10++)
      age += ageSorted[i10][1] * (ageSorted[i10][0] - age);
    obj.age = Math.round(10 * age) / 10;
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    last2[idx] = obj;
    lastCount = count2;
    lastTime = now2();
    resolve(obj);
  });
}
var constants = {
  tf255: 255,
  tf1: 1,
  tf2: 2,
  tf05: 0.5,
  tf127: 127.5,
  rgb: [0.2989, 0.587, 0.114]
};
function init() {
  constants.tf255 = Ie2(255, "float32");
  constants.tf1 = Ie2(1, "float32");
  constants.tf2 = Ie2(2, "float32");
  constants.tf05 = Ie2(0.5, "float32");
  constants.tf127 = Ie2(127.5, "float32");
  constants.rgb = Qt([0.2989, 0.587, 0.114], "float32");
}
var model2;
var last3 = [];
var lastCount2 = 0;
var lastTime2 = 0;
var skipped2 = Number.MAX_SAFE_INTEGER;
async function load2(config3) {
  if (env.initial)
    model2 = null;
  if (!model2)
    model2 = await loadModel(config3.face["ssrnet"].modelPathAge);
  else if (config3.debug)
    log("cached model:", model2["modelUrl"]);
  return model2;
}
async function predict2(image, config3, idx, count2) {
  var _a2, _b2, _c, _d2;
  if (!model2)
    return { age: 0 };
  const skipFrame = skipped2 < (((_a2 = config3.face["ssrnet"]) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face["ssrnet"]) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime2;
  if (config3.skipAllowed && skipFrame && skipTime && lastCount2 === count2 && ((_c = last3[idx]) == null ? void 0 : _c.age) && ((_d2 = last3[idx]) == null ? void 0 : _d2.age) > 0) {
    skipped2++;
    return last3[idx];
  }
  skipped2 = 0;
  return new Promise(async (resolve) => {
    if (!(model2 == null ? void 0 : model2.inputs) || !model2.inputs[0] || !model2.inputs[0].shape)
      return;
    const t = {};
    t.resize = ds.resizeBilinear(image, [model2.inputs[0].shape[2], model2.inputs[0].shape[1]], false);
    t.enhance = V2(t.resize, constants.tf255);
    const obj = { age: 0 };
    if (config3.face["ssrnet"].enabled)
      t.age = model2.execute(t.enhance);
    if (t.age) {
      const data = await t.age.data();
      obj.age = Math.trunc(10 * data[0]) / 10;
    }
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    last3[idx] = obj;
    lastCount2 = count2;
    lastTime2 = now2();
    resolve(obj);
  });
}
var model3;
var last4 = [];
var lastCount3 = 0;
var lastTime3 = 0;
var skipped3 = Number.MAX_SAFE_INTEGER;
var rgb = [0.2989, 0.587, 0.114];
async function load3(config3) {
  if (env.initial)
    model3 = null;
  if (!model3)
    model3 = await loadModel(config3.face["ssrnet"].modelPathGender);
  else if (config3.debug)
    log("cached model:", model3["modelUrl"]);
  return model3;
}
async function predict3(image, config3, idx, count2) {
  var _a2, _b2, _c, _d2;
  if (!model3)
    return { gender: "unknown", genderScore: 0 };
  const skipFrame = skipped3 < (((_a2 = config3.face["ssrnet"]) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face["ssrnet"]) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime3;
  if (config3.skipAllowed && skipFrame && skipTime && lastCount3 === count2 && ((_c = last4[idx]) == null ? void 0 : _c.gender) && ((_d2 = last4[idx]) == null ? void 0 : _d2.genderScore) > 0) {
    skipped3++;
    return last4[idx];
  }
  skipped3 = 0;
  return new Promise(async (resolve) => {
    if (!(model3 == null ? void 0 : model3.inputs[0].shape))
      return;
    const t = {};
    t.resize = ds.resizeBilinear(image, [model3.inputs[0].shape[2], model3.inputs[0].shape[1]], false);
    t.enhance = j2(() => {
      const [red, green, blue] = Ln(t.resize, 3, 3);
      const redNorm = V2(red, rgb[0]);
      const greenNorm = V2(green, rgb[1]);
      const blueNorm = V2(blue, rgb[2]);
      const grayscale = LA([redNorm, greenNorm, blueNorm]);
      const normalize = V2(ge2(grayscale, constants.tf05), 2);
      return normalize;
    });
    const obj = { gender: "unknown", genderScore: 0 };
    if (config3.face["ssrnet"].enabled)
      t.gender = model3.execute(t.enhance);
    const data = await t.gender.data();
    obj.gender = data[0] > data[1] ? "female" : "male";
    obj.genderScore = data[0] > data[1] ? Math.trunc(100 * data[0]) / 100 : Math.trunc(100 * data[1]) / 100;
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    last4[idx] = obj;
    lastCount3 = count2;
    lastTime3 = now2();
    resolve(obj);
  });
}
var model4;
var cached = [];
var skipped4 = Number.MAX_SAFE_INTEGER;
var lastCount4 = 0;
var lastTime4 = 0;
async function load4(config3) {
  var _a2;
  if (env.initial)
    model4 = null;
  if (!model4)
    model4 = await loadModel((_a2 = config3.face.antispoof) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model4["modelUrl"]);
  return model4;
}
async function predict4(image, config3, idx, count2) {
  var _a2, _b2;
  if (!model4)
    return 0;
  const skipTime = (((_a2 = config3.face.antispoof) == null ? void 0 : _a2.skipTime) || 0) > now2() - lastTime4;
  const skipFrame = skipped4 < (((_b2 = config3.face.antispoof) == null ? void 0 : _b2.skipFrames) || 0);
  if (config3.skipAllowed && skipTime && skipFrame && lastCount4 === count2 && cached[idx]) {
    skipped4++;
    return cached[idx];
  }
  skipped4 = 0;
  return new Promise(async (resolve) => {
    const resize = ds.resizeBilinear(image, [(model4 == null ? void 0 : model4.inputs[0].shape) ? model4.inputs[0].shape[2] : 0, (model4 == null ? void 0 : model4.inputs[0].shape) ? model4.inputs[0].shape[1] : 0], false);
    const res2 = model4 == null ? void 0 : model4.execute(resize);
    const num = (await res2.data())[0];
    cached[idx] = Math.round(100 * num) / 100;
    lastCount4 = count2;
    lastTime4 = now2();
    Re2([resize, res2]);
    resolve(cached[idx]);
  });
}
var meshAnnotations = {
  silhouette: [
    10,
    338,
    297,
    332,
    284,
    251,
    389,
    356,
    454,
    323,
    361,
    288,
    397,
    365,
    379,
    378,
    400,
    377,
    152,
    148,
    176,
    149,
    150,
    136,
    172,
    58,
    132,
    93,
    234,
    127,
    162,
    21,
    54,
    103,
    67,
    109
  ],
  lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],
  lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],
  lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],
  lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],
  rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],
  rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],
  rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],
  rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],
  rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],
  rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],
  rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],
  rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],
  rightEyebrowLower: [35, 124, 46, 53, 52, 65],
  rightEyeIris: [473, 474, 475, 476, 477],
  leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],
  leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],
  leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],
  leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],
  leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],
  leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],
  leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],
  leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],
  leftEyebrowLower: [265, 353, 276, 283, 282, 295],
  leftEyeIris: [468, 469, 470, 471, 472],
  midwayBetweenEyes: [168],
  noseTip: [1],
  noseBottom: [2],
  noseRightCorner: [98],
  noseLeftCorner: [327],
  rightCheek: [205],
  leftCheek: [425]
};
var meshLandmarks = {
  count: 468,
  mouth: 13,
  symmetryLine: [13, meshAnnotations["midwayBetweenEyes"][0]]
};
var blazeFaceLandmarks = {
  leftEye: 0,
  rightEye: 1,
  nose: 2,
  mouth: 3,
  leftEar: 4,
  rightEar: 5,
  symmetryLine: [3, 2]
};
var MESH_TO_IRIS_INDICES_MAP = [
  { key: "EyeUpper0", indices: [9, 10, 11, 12, 13, 14, 15] },
  { key: "EyeUpper1", indices: [25, 26, 27, 28, 29, 30, 31] },
  { key: "EyeUpper2", indices: [41, 42, 43, 44, 45, 46, 47] },
  { key: "EyeLower0", indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] },
  { key: "EyeLower1", indices: [16, 17, 18, 19, 20, 21, 22, 23, 24] },
  { key: "EyeLower2", indices: [32, 33, 34, 35, 36, 37, 38, 39, 40] },
  { key: "EyeLower3", indices: [54, 55, 56, 57, 58, 59, 60, 61, 62] }
];
var UV468 = [
  [0.499976992607117, 0.652534008026123],
  [0.500025987625122, 0.547487020492554],
  [0.499974012374878, 0.602371990680695],
  [0.482113003730774, 0.471979022026062],
  [0.500150978565216, 0.527155995368958],
  [0.499909996986389, 0.498252987861633],
  [0.499523013830185, 0.40106201171875],
  [0.289712011814117, 0.380764007568359],
  [0.499954998493195, 0.312398016452789],
  [0.499987006187439, 0.269918978214264],
  [0.500023007392883, 0.107050001621246],
  [0.500023007392883, 0.666234016418457],
  [0.5000159740448, 0.679224014282227],
  [0.500023007392883, 0.692348003387451],
  [0.499976992607117, 0.695277988910675],
  [0.499976992607117, 0.70593398809433],
  [0.499976992607117, 0.719385027885437],
  [0.499976992607117, 0.737019002437592],
  [0.499967992305756, 0.781370997428894],
  [0.499816000461578, 0.562981009483337],
  [0.473773002624512, 0.573909997940063],
  [0.104906998574734, 0.254140973091125],
  [0.365929991006851, 0.409575998783112],
  [0.338757991790771, 0.41302502155304],
  [0.311120003461838, 0.409460008144379],
  [0.274657994508743, 0.389131009578705],
  [0.393361985683441, 0.403706014156342],
  [0.345234006643295, 0.344011008739471],
  [0.370094001293182, 0.346076011657715],
  [0.319321990013123, 0.347265005111694],
  [0.297903001308441, 0.353591024875641],
  [0.24779200553894, 0.410809993743896],
  [0.396889001131058, 0.842755019664764],
  [0.280097991228104, 0.375599980354309],
  [0.106310002505779, 0.399955987930298],
  [0.2099249958992, 0.391353011131287],
  [0.355807989835739, 0.534406006336212],
  [0.471751004457474, 0.65040397644043],
  [0.474155008792877, 0.680191993713379],
  [0.439785003662109, 0.657229006290436],
  [0.414617002010345, 0.66654098033905],
  [0.450374007225037, 0.680860996246338],
  [0.428770989179611, 0.682690978050232],
  [0.374971002340317, 0.727805018424988],
  [0.486716985702515, 0.547628998756409],
  [0.485300987958908, 0.527395009994507],
  [0.257764995098114, 0.314490020275116],
  [0.401223003864288, 0.455172002315521],
  [0.429818987846375, 0.548614978790283],
  [0.421351999044418, 0.533740997314453],
  [0.276895999908447, 0.532056987285614],
  [0.483370006084442, 0.499586999416351],
  [0.33721199631691, 0.282882988452911],
  [0.296391993761063, 0.293242990970612],
  [0.169294998049736, 0.193813979625702],
  [0.447580009698868, 0.302609980106354],
  [0.392390012741089, 0.353887975215912],
  [0.354490011930466, 0.696784019470215],
  [0.067304998636246, 0.730105042457581],
  [0.442739009857178, 0.572826027870178],
  [0.457098007202148, 0.584792017936707],
  [0.381974011659622, 0.694710969924927],
  [0.392388999462128, 0.694203019142151],
  [0.277076005935669, 0.271932005882263],
  [0.422551989555359, 0.563233017921448],
  [0.385919004678726, 0.281364023685455],
  [0.383103013038635, 0.255840003490448],
  [0.331431001424789, 0.119714021682739],
  [0.229923993349075, 0.232002973556519],
  [0.364500999450684, 0.189113974571228],
  [0.229622006416321, 0.299540996551514],
  [0.173287004232407, 0.278747975826263],
  [0.472878992557526, 0.666198015213013],
  [0.446828007698059, 0.668527007102966],
  [0.422762006521225, 0.673889994621277],
  [0.445307999849319, 0.580065965652466],
  [0.388103008270264, 0.693961024284363],
  [0.403039008378983, 0.706539988517761],
  [0.403629004955292, 0.693953037261963],
  [0.460041999816895, 0.557139039039612],
  [0.431158006191254, 0.692366003990173],
  [0.452181994915009, 0.692366003990173],
  [0.475387006998062, 0.692366003990173],
  [0.465828001499176, 0.779190003871918],
  [0.472328990697861, 0.736225962638855],
  [0.473087012767792, 0.717857003211975],
  [0.473122000694275, 0.704625964164734],
  [0.473033010959625, 0.695277988910675],
  [0.427942007780075, 0.695277988910675],
  [0.426479011774063, 0.703539967536926],
  [0.423162013292313, 0.711845993995667],
  [0.4183090031147, 0.720062971115112],
  [0.390094995498657, 0.639572978019714],
  [0.013953999616206, 0.560034036636353],
  [0.499913990497589, 0.58014702796936],
  [0.413199990987778, 0.69539999961853],
  [0.409626007080078, 0.701822996139526],
  [0.468080013990402, 0.601534962654114],
  [0.422728985548019, 0.585985004901886],
  [0.463079988956451, 0.593783974647522],
  [0.37211999297142, 0.47341400384903],
  [0.334562003612518, 0.496073007583618],
  [0.411671012639999, 0.546965003013611],
  [0.242175996303558, 0.14767599105835],
  [0.290776997804642, 0.201445996761322],
  [0.327338010072708, 0.256527006626129],
  [0.399509996175766, 0.748921036720276],
  [0.441727995872498, 0.261676013469696],
  [0.429764986038208, 0.187834024429321],
  [0.412198007106781, 0.108901023864746],
  [0.288955003023148, 0.398952007293701],
  [0.218936994671822, 0.435410976409912],
  [0.41278201341629, 0.398970007896423],
  [0.257135003805161, 0.355440020561218],
  [0.427684992551804, 0.437960982322693],
  [0.448339998722076, 0.536936044692993],
  [0.178560003638268, 0.45755398273468],
  [0.247308000922203, 0.457193970680237],
  [0.286267012357712, 0.467674970626831],
  [0.332827985286713, 0.460712015628815],
  [0.368755996227264, 0.447206974029541],
  [0.398963987827301, 0.432654976844788],
  [0.476410001516342, 0.405806005001068],
  [0.189241006970406, 0.523923993110657],
  [0.228962004184723, 0.348950982093811],
  [0.490725994110107, 0.562400996685028],
  [0.404670000076294, 0.485132992267609],
  [0.019469000399113, 0.401564002037048],
  [0.426243007183075, 0.420431017875671],
  [0.396993011236191, 0.548797011375427],
  [0.266469985246658, 0.376977026462555],
  [0.439121007919312, 0.51895797252655],
  [0.032313998788595, 0.644356966018677],
  [0.419054001569748, 0.387154996395111],
  [0.462783008813858, 0.505746960639954],
  [0.238978996872902, 0.779744982719421],
  [0.198220998048782, 0.831938028335571],
  [0.107550002634525, 0.540755033493042],
  [0.183610007166862, 0.740257024765015],
  [0.134409993886948, 0.333683013916016],
  [0.385764002799988, 0.883153975009918],
  [0.490967005491257, 0.579378008842468],
  [0.382384985685349, 0.508572995662689],
  [0.174399003386497, 0.397670984268188],
  [0.318785011768341, 0.39623498916626],
  [0.343364000320435, 0.400596976280212],
  [0.396100014448166, 0.710216999053955],
  [0.187885001301765, 0.588537991046906],
  [0.430987000465393, 0.944064974784851],
  [0.318993002176285, 0.898285031318665],
  [0.266247987747192, 0.869701027870178],
  [0.500023007392883, 0.190576016902924],
  [0.499976992607117, 0.954452991485596],
  [0.366169989109039, 0.398822009563446],
  [0.393207013607025, 0.39553701877594],
  [0.410373002290726, 0.391080021858215],
  [0.194993004202843, 0.342101991176605],
  [0.388664990663528, 0.362284004688263],
  [0.365961998701096, 0.355970978736877],
  [0.343364000320435, 0.355356991291046],
  [0.318785011768341, 0.35834002494812],
  [0.301414996385574, 0.363156020641327],
  [0.058132998645306, 0.319076001644135],
  [0.301414996385574, 0.387449026107788],
  [0.499987989664078, 0.618434011936188],
  [0.415838003158569, 0.624195992946625],
  [0.445681989192963, 0.566076993942261],
  [0.465844005346298, 0.620640993118286],
  [0.49992299079895, 0.351523995399475],
  [0.288718998432159, 0.819945991039276],
  [0.335278987884521, 0.852819979190826],
  [0.440512001514435, 0.902418971061707],
  [0.128294005990028, 0.791940987110138],
  [0.408771991729736, 0.373893976211548],
  [0.455606997013092, 0.451801002025604],
  [0.499877005815506, 0.908990025520325],
  [0.375436991453171, 0.924192011356354],
  [0.11421000212431, 0.615022003650665],
  [0.448662012815475, 0.695277988910675],
  [0.4480200111866, 0.704632043838501],
  [0.447111994028091, 0.715808033943176],
  [0.444831997156143, 0.730794012546539],
  [0.430011987686157, 0.766808986663818],
  [0.406787008047104, 0.685672998428345],
  [0.400738000869751, 0.681069016456604],
  [0.392399996519089, 0.677703022956848],
  [0.367855995893478, 0.663918972015381],
  [0.247923001646996, 0.601333022117615],
  [0.452769994735718, 0.420849978923798],
  [0.43639200925827, 0.359887003898621],
  [0.416164010763168, 0.368713974952698],
  [0.413385987281799, 0.692366003990173],
  [0.228018000721931, 0.683571994304657],
  [0.468268007040024, 0.352671027183533],
  [0.411361992359161, 0.804327011108398],
  [0.499989002943039, 0.469825029373169],
  [0.479153990745544, 0.442654013633728],
  [0.499974012374878, 0.439637005329132],
  [0.432112008333206, 0.493588984012604],
  [0.499886006116867, 0.866917014122009],
  [0.49991300702095, 0.821729004383087],
  [0.456548988819122, 0.819200992584229],
  [0.344549000263214, 0.745438992977142],
  [0.37890899181366, 0.574010014533997],
  [0.374292999505997, 0.780184984207153],
  [0.319687992334366, 0.570737957954407],
  [0.357154995203018, 0.604269981384277],
  [0.295284003019333, 0.621580958366394],
  [0.447750002145767, 0.862477004528046],
  [0.410986006259918, 0.508723020553589],
  [0.31395098567009, 0.775308012962341],
  [0.354128003120422, 0.812552988529205],
  [0.324548006057739, 0.703992962837219],
  [0.189096003770828, 0.646299958229065],
  [0.279776990413666, 0.71465802192688],
  [0.1338230073452, 0.682700991630554],
  [0.336768001317978, 0.644733011722565],
  [0.429883986711502, 0.466521978378296],
  [0.455527991056442, 0.548622965812683],
  [0.437114000320435, 0.558896005153656],
  [0.467287987470627, 0.529924988746643],
  [0.414712011814117, 0.335219979286194],
  [0.37704598903656, 0.322777986526489],
  [0.344107985496521, 0.320150971412659],
  [0.312875986099243, 0.32233202457428],
  [0.283526003360748, 0.333190023899078],
  [0.241245999932289, 0.382785975933075],
  [0.102986000478268, 0.468762993812561],
  [0.267612010240555, 0.424560010433197],
  [0.297879010438919, 0.433175981044769],
  [0.333433985710144, 0.433878004550934],
  [0.366427004337311, 0.426115989685059],
  [0.396012008190155, 0.416696012020111],
  [0.420121014118195, 0.41022801399231],
  [0.007561000064015, 0.480777025222778],
  [0.432949006557465, 0.569517970085144],
  [0.458638995885849, 0.479089021682739],
  [0.473466008901596, 0.545744001865387],
  [0.476087987422943, 0.563830018043518],
  [0.468472003936768, 0.555056989192963],
  [0.433990985155106, 0.582361996173859],
  [0.483518004417419, 0.562983989715576],
  [0.482482999563217, 0.57784903049469],
  [0.42645001411438, 0.389798998832703],
  [0.438998997211456, 0.39649498462677],
  [0.450067013502121, 0.400434017181396],
  [0.289712011814117, 0.368252992630005],
  [0.276670008897781, 0.363372981548309],
  [0.517862021923065, 0.471948027610779],
  [0.710287988185883, 0.380764007568359],
  [0.526226997375488, 0.573909997940063],
  [0.895093023777008, 0.254140973091125],
  [0.634069979190826, 0.409575998783112],
  [0.661242008209229, 0.41302502155304],
  [0.688880026340485, 0.409460008144379],
  [0.725341975688934, 0.389131009578705],
  [0.606630027294159, 0.40370500087738],
  [0.654766023159027, 0.344011008739471],
  [0.629905998706818, 0.346076011657715],
  [0.680678009986877, 0.347265005111694],
  [0.702096998691559, 0.353591024875641],
  [0.75221198797226, 0.410804986953735],
  [0.602918028831482, 0.842862963676453],
  [0.719901978969574, 0.375599980354309],
  [0.893692970275879, 0.399959981441498],
  [0.790081977844238, 0.391354024410248],
  [0.643998026847839, 0.534487962722778],
  [0.528249025344849, 0.65040397644043],
  [0.525849997997284, 0.680191040039062],
  [0.560214996337891, 0.657229006290436],
  [0.585384011268616, 0.66654098033905],
  [0.549625992774963, 0.680860996246338],
  [0.57122802734375, 0.682691991329193],
  [0.624852001667023, 0.72809898853302],
  [0.513050019741058, 0.547281980514526],
  [0.51509702205658, 0.527251958847046],
  [0.742246985435486, 0.314507007598877],
  [0.598631024360657, 0.454979002475739],
  [0.570338010787964, 0.548575043678284],
  [0.578631997108459, 0.533622980117798],
  [0.723087012767792, 0.532054007053375],
  [0.516445994377136, 0.499638974666595],
  [0.662801027297974, 0.282917976379395],
  [0.70362401008606, 0.293271005153656],
  [0.830704987049103, 0.193813979625702],
  [0.552385985851288, 0.302568018436432],
  [0.607609987258911, 0.353887975215912],
  [0.645429015159607, 0.696707010269165],
  [0.932694971561432, 0.730105042457581],
  [0.557260990142822, 0.572826027870178],
  [0.542901992797852, 0.584792017936707],
  [0.6180260181427, 0.694710969924927],
  [0.607590973377228, 0.694203019142151],
  [0.722943007946014, 0.271963000297546],
  [0.577413976192474, 0.563166975975037],
  [0.614082992076874, 0.281386971473694],
  [0.616907000541687, 0.255886018276215],
  [0.668509006500244, 0.119913995265961],
  [0.770092010498047, 0.232020974159241],
  [0.635536015033722, 0.189248979091644],
  [0.77039098739624, 0.299556016921997],
  [0.826722025871277, 0.278755009174347],
  [0.527121007442474, 0.666198015213013],
  [0.553171992301941, 0.668527007102966],
  [0.577238023281097, 0.673889994621277],
  [0.554691970348358, 0.580065965652466],
  [0.611896991729736, 0.693961024284363],
  [0.59696102142334, 0.706539988517761],
  [0.596370995044708, 0.693953037261963],
  [0.539958000183105, 0.557139039039612],
  [0.568841993808746, 0.692366003990173],
  [0.547818005084991, 0.692366003990173],
  [0.52461302280426, 0.692366003990173],
  [0.534089982509613, 0.779141008853912],
  [0.527670979499817, 0.736225962638855],
  [0.526912987232208, 0.717857003211975],
  [0.526877999305725, 0.704625964164734],
  [0.526966989040375, 0.695277988910675],
  [0.572058022022247, 0.695277988910675],
  [0.573521018028259, 0.703539967536926],
  [0.57683801651001, 0.711845993995667],
  [0.581691026687622, 0.720062971115112],
  [0.609944999217987, 0.639909982681274],
  [0.986046016216278, 0.560034036636353],
  [0.5867999792099, 0.69539999961853],
  [0.590372025966644, 0.701822996139526],
  [0.531915009021759, 0.601536989212036],
  [0.577268004417419, 0.585934996604919],
  [0.536915004253387, 0.593786001205444],
  [0.627542972564697, 0.473352015018463],
  [0.665585994720459, 0.495950996875763],
  [0.588353991508484, 0.546862006187439],
  [0.757824003696442, 0.14767599105835],
  [0.709249973297119, 0.201507985591888],
  [0.672684013843536, 0.256581008434296],
  [0.600408971309662, 0.74900496006012],
  [0.55826598405838, 0.261672019958496],
  [0.570303976535797, 0.187870979309082],
  [0.588165998458862, 0.109044015407562],
  [0.711045026779175, 0.398952007293701],
  [0.781069993972778, 0.435405015945435],
  [0.587247014045715, 0.398931980133057],
  [0.742869973182678, 0.355445981025696],
  [0.572156012058258, 0.437651991844177],
  [0.55186802148819, 0.536570012569427],
  [0.821442008018494, 0.457556009292603],
  [0.752701997756958, 0.457181990146637],
  [0.71375697851181, 0.467626988887787],
  [0.66711300611496, 0.460672974586487],
  [0.631101012229919, 0.447153985500336],
  [0.6008620262146, 0.432473003864288],
  [0.523481011390686, 0.405627012252808],
  [0.810747981071472, 0.523926019668579],
  [0.771045982837677, 0.348959028720856],
  [0.509127020835876, 0.562718033790588],
  [0.595292985439301, 0.485023975372314],
  [0.980530977249146, 0.401564002037048],
  [0.573499977588654, 0.420000016689301],
  [0.602994978427887, 0.548687994480133],
  [0.733529984951019, 0.376977026462555],
  [0.560611009597778, 0.519016981124878],
  [0.967685997486115, 0.644356966018677],
  [0.580985009670258, 0.387160003185272],
  [0.537728011608124, 0.505385041236877],
  [0.760966002941132, 0.779752969741821],
  [0.801778972148895, 0.831938028335571],
  [0.892440974712372, 0.54076099395752],
  [0.816350996494293, 0.740260004997253],
  [0.865594983100891, 0.333687007427216],
  [0.614073991775513, 0.883246004581451],
  [0.508952975273132, 0.579437971115112],
  [0.617941975593567, 0.508316040039062],
  [0.825608015060425, 0.397674977779388],
  [0.681214988231659, 0.39623498916626],
  [0.656635999679565, 0.400596976280212],
  [0.603900015354156, 0.710216999053955],
  [0.81208598613739, 0.588539004325867],
  [0.56801301240921, 0.944564998149872],
  [0.681007981300354, 0.898285031318665],
  [0.733752012252808, 0.869701027870178],
  [0.633830010890961, 0.398822009563446],
  [0.606792986392975, 0.39553701877594],
  [0.589659988880157, 0.391062021255493],
  [0.805015981197357, 0.342108011245728],
  [0.611334979534149, 0.362284004688263],
  [0.634037971496582, 0.355970978736877],
  [0.656635999679565, 0.355356991291046],
  [0.681214988231659, 0.35834002494812],
  [0.698584973812103, 0.363156020641327],
  [0.941866993904114, 0.319076001644135],
  [0.698584973812103, 0.387449026107788],
  [0.584177017211914, 0.624107003211975],
  [0.554318010807037, 0.566076993942261],
  [0.534153997898102, 0.62064003944397],
  [0.711217999458313, 0.819975018501282],
  [0.664629995822906, 0.852871000766754],
  [0.559099972248077, 0.902631998062134],
  [0.871706008911133, 0.791940987110138],
  [0.591234028339386, 0.373893976211548],
  [0.544341027736664, 0.451583981513977],
  [0.624562978744507, 0.924192011356354],
  [0.88577002286911, 0.615028977394104],
  [0.551338016986847, 0.695277988910675],
  [0.551980018615723, 0.704632043838501],
  [0.552887976169586, 0.715808033943176],
  [0.555167973041534, 0.730794012546539],
  [0.569944024085999, 0.767035007476807],
  [0.593203008174896, 0.685675978660583],
  [0.599261999130249, 0.681069016456604],
  [0.607599973678589, 0.677703022956848],
  [0.631937980651855, 0.663500010967255],
  [0.752032995223999, 0.601315021514893],
  [0.547226011753082, 0.420395016670227],
  [0.563543975353241, 0.359827995300293],
  [0.583841025829315, 0.368713974952698],
  [0.586614012718201, 0.692366003990173],
  [0.771915018558502, 0.683578014373779],
  [0.531597018241882, 0.352482974529266],
  [0.588370978832245, 0.804440975189209],
  [0.52079701423645, 0.442565023899078],
  [0.567984998226166, 0.493479013442993],
  [0.543282985687256, 0.819254994392395],
  [0.655317008495331, 0.745514988899231],
  [0.621008992195129, 0.574018001556396],
  [0.625559985637665, 0.78031200170517],
  [0.680198013782501, 0.570719003677368],
  [0.64276397228241, 0.604337990283966],
  [0.704662978649139, 0.621529996395111],
  [0.552012026309967, 0.862591981887817],
  [0.589071989059448, 0.508637011051178],
  [0.685944974422455, 0.775357007980347],
  [0.645735025405884, 0.812640011310577],
  [0.675342977046967, 0.703978002071381],
  [0.810858011245728, 0.646304965019226],
  [0.72012197971344, 0.714666962623596],
  [0.866151988506317, 0.682704985141754],
  [0.663187026977539, 0.644596993923187],
  [0.570082008838654, 0.466325998306274],
  [0.544561982154846, 0.548375964164734],
  [0.562758982181549, 0.558784961700439],
  [0.531987011432648, 0.530140042304993],
  [0.585271000862122, 0.335177004337311],
  [0.622952997684479, 0.32277899980545],
  [0.655896008014679, 0.320163011550903],
  [0.687132000923157, 0.322345972061157],
  [0.716481983661652, 0.333200991153717],
  [0.758756995201111, 0.382786989212036],
  [0.897013008594513, 0.468769013881683],
  [0.732392013072968, 0.424547016620636],
  [0.70211398601532, 0.433162987232208],
  [0.66652500629425, 0.433866024017334],
  [0.633504986763, 0.426087975502014],
  [0.603875994682312, 0.416586995124817],
  [0.579657971858978, 0.409945011138916],
  [0.992439985275269, 0.480777025222778],
  [0.567192018032074, 0.569419980049133],
  [0.54136598110199, 0.478899002075195],
  [0.526564002037048, 0.546118021011353],
  [0.523913025856018, 0.563830018043518],
  [0.531529009342194, 0.555056989192963],
  [0.566035985946655, 0.582329034805298],
  [0.51631098985672, 0.563053965568542],
  [0.5174720287323, 0.577877044677734],
  [0.573594987392426, 0.389806985855103],
  [0.560697972774506, 0.395331978797913],
  [0.549755990505219, 0.399751007556915],
  [0.710287988185883, 0.368252992630005],
  [0.723330020904541, 0.363372981548309]
];
var TRI468 = [
  127,
  34,
  139,
  11,
  0,
  37,
  232,
  231,
  120,
  72,
  37,
  39,
  128,
  121,
  47,
  232,
  121,
  128,
  104,
  69,
  67,
  175,
  171,
  148,
  157,
  154,
  155,
  118,
  50,
  101,
  73,
  39,
  40,
  9,
  151,
  108,
  48,
  115,
  131,
  194,
  204,
  211,
  74,
  40,
  185,
  80,
  42,
  183,
  40,
  92,
  186,
  230,
  229,
  118,
  202,
  212,
  214,
  83,
  18,
  17,
  76,
  61,
  146,
  160,
  29,
  30,
  56,
  157,
  173,
  106,
  204,
  194,
  135,
  214,
  192,
  203,
  165,
  98,
  21,
  71,
  68,
  51,
  45,
  4,
  144,
  24,
  23,
  77,
  146,
  91,
  205,
  50,
  187,
  201,
  200,
  18,
  91,
  106,
  182,
  90,
  91,
  181,
  85,
  84,
  17,
  206,
  203,
  36,
  148,
  171,
  140,
  92,
  40,
  39,
  193,
  189,
  244,
  159,
  158,
  28,
  247,
  246,
  161,
  236,
  3,
  196,
  54,
  68,
  104,
  193,
  168,
  8,
  117,
  228,
  31,
  189,
  193,
  55,
  98,
  97,
  99,
  126,
  47,
  100,
  166,
  79,
  218,
  155,
  154,
  26,
  209,
  49,
  131,
  135,
  136,
  150,
  47,
  126,
  217,
  223,
  52,
  53,
  45,
  51,
  134,
  211,
  170,
  140,
  67,
  69,
  108,
  43,
  106,
  91,
  230,
  119,
  120,
  226,
  130,
  247,
  63,
  53,
  52,
  238,
  20,
  242,
  46,
  70,
  156,
  78,
  62,
  96,
  46,
  53,
  63,
  143,
  34,
  227,
  173,
  155,
  133,
  123,
  117,
  111,
  44,
  125,
  19,
  236,
  134,
  51,
  216,
  206,
  205,
  154,
  153,
  22,
  39,
  37,
  167,
  200,
  201,
  208,
  36,
  142,
  100,
  57,
  212,
  202,
  20,
  60,
  99,
  28,
  158,
  157,
  35,
  226,
  113,
  160,
  159,
  27,
  204,
  202,
  210,
  113,
  225,
  46,
  43,
  202,
  204,
  62,
  76,
  77,
  137,
  123,
  116,
  41,
  38,
  72,
  203,
  129,
  142,
  64,
  98,
  240,
  49,
  102,
  64,
  41,
  73,
  74,
  212,
  216,
  207,
  42,
  74,
  184,
  169,
  170,
  211,
  170,
  149,
  176,
  105,
  66,
  69,
  122,
  6,
  168,
  123,
  147,
  187,
  96,
  77,
  90,
  65,
  55,
  107,
  89,
  90,
  180,
  101,
  100,
  120,
  63,
  105,
  104,
  93,
  137,
  227,
  15,
  86,
  85,
  129,
  102,
  49,
  14,
  87,
  86,
  55,
  8,
  9,
  100,
  47,
  121,
  145,
  23,
  22,
  88,
  89,
  179,
  6,
  122,
  196,
  88,
  95,
  96,
  138,
  172,
  136,
  215,
  58,
  172,
  115,
  48,
  219,
  42,
  80,
  81,
  195,
  3,
  51,
  43,
  146,
  61,
  171,
  175,
  199,
  81,
  82,
  38,
  53,
  46,
  225,
  144,
  163,
  110,
  246,
  33,
  7,
  52,
  65,
  66,
  229,
  228,
  117,
  34,
  127,
  234,
  107,
  108,
  69,
  109,
  108,
  151,
  48,
  64,
  235,
  62,
  78,
  191,
  129,
  209,
  126,
  111,
  35,
  143,
  163,
  161,
  246,
  117,
  123,
  50,
  222,
  65,
  52,
  19,
  125,
  141,
  221,
  55,
  65,
  3,
  195,
  197,
  25,
  7,
  33,
  220,
  237,
  44,
  70,
  71,
  139,
  122,
  193,
  245,
  247,
  130,
  33,
  71,
  21,
  162,
  153,
  158,
  159,
  170,
  169,
  150,
  188,
  174,
  196,
  216,
  186,
  92,
  144,
  160,
  161,
  2,
  97,
  167,
  141,
  125,
  241,
  164,
  167,
  37,
  72,
  38,
  12,
  145,
  159,
  160,
  38,
  82,
  13,
  63,
  68,
  71,
  226,
  35,
  111,
  158,
  153,
  154,
  101,
  50,
  205,
  206,
  92,
  165,
  209,
  198,
  217,
  165,
  167,
  97,
  220,
  115,
  218,
  133,
  112,
  243,
  239,
  238,
  241,
  214,
  135,
  169,
  190,
  173,
  133,
  171,
  208,
  32,
  125,
  44,
  237,
  86,
  87,
  178,
  85,
  86,
  179,
  84,
  85,
  180,
  83,
  84,
  181,
  201,
  83,
  182,
  137,
  93,
  132,
  76,
  62,
  183,
  61,
  76,
  184,
  57,
  61,
  185,
  212,
  57,
  186,
  214,
  207,
  187,
  34,
  143,
  156,
  79,
  239,
  237,
  123,
  137,
  177,
  44,
  1,
  4,
  201,
  194,
  32,
  64,
  102,
  129,
  213,
  215,
  138,
  59,
  166,
  219,
  242,
  99,
  97,
  2,
  94,
  141,
  75,
  59,
  235,
  24,
  110,
  228,
  25,
  130,
  226,
  23,
  24,
  229,
  22,
  23,
  230,
  26,
  22,
  231,
  112,
  26,
  232,
  189,
  190,
  243,
  221,
  56,
  190,
  28,
  56,
  221,
  27,
  28,
  222,
  29,
  27,
  223,
  30,
  29,
  224,
  247,
  30,
  225,
  238,
  79,
  20,
  166,
  59,
  75,
  60,
  75,
  240,
  147,
  177,
  215,
  20,
  79,
  166,
  187,
  147,
  213,
  112,
  233,
  244,
  233,
  128,
  245,
  128,
  114,
  188,
  114,
  217,
  174,
  131,
  115,
  220,
  217,
  198,
  236,
  198,
  131,
  134,
  177,
  132,
  58,
  143,
  35,
  124,
  110,
  163,
  7,
  228,
  110,
  25,
  356,
  389,
  368,
  11,
  302,
  267,
  452,
  350,
  349,
  302,
  303,
  269,
  357,
  343,
  277,
  452,
  453,
  357,
  333,
  332,
  297,
  175,
  152,
  377,
  384,
  398,
  382,
  347,
  348,
  330,
  303,
  304,
  270,
  9,
  336,
  337,
  278,
  279,
  360,
  418,
  262,
  431,
  304,
  408,
  409,
  310,
  415,
  407,
  270,
  409,
  410,
  450,
  348,
  347,
  422,
  430,
  434,
  313,
  314,
  17,
  306,
  307,
  375,
  387,
  388,
  260,
  286,
  414,
  398,
  335,
  406,
  418,
  364,
  367,
  416,
  423,
  358,
  327,
  251,
  284,
  298,
  281,
  5,
  4,
  373,
  374,
  253,
  307,
  320,
  321,
  425,
  427,
  411,
  421,
  313,
  18,
  321,
  405,
  406,
  320,
  404,
  405,
  315,
  16,
  17,
  426,
  425,
  266,
  377,
  400,
  369,
  322,
  391,
  269,
  417,
  465,
  464,
  386,
  257,
  258,
  466,
  260,
  388,
  456,
  399,
  419,
  284,
  332,
  333,
  417,
  285,
  8,
  346,
  340,
  261,
  413,
  441,
  285,
  327,
  460,
  328,
  355,
  371,
  329,
  392,
  439,
  438,
  382,
  341,
  256,
  429,
  420,
  360,
  364,
  394,
  379,
  277,
  343,
  437,
  443,
  444,
  283,
  275,
  440,
  363,
  431,
  262,
  369,
  297,
  338,
  337,
  273,
  375,
  321,
  450,
  451,
  349,
  446,
  342,
  467,
  293,
  334,
  282,
  458,
  461,
  462,
  276,
  353,
  383,
  308,
  324,
  325,
  276,
  300,
  293,
  372,
  345,
  447,
  382,
  398,
  362,
  352,
  345,
  340,
  274,
  1,
  19,
  456,
  248,
  281,
  436,
  427,
  425,
  381,
  256,
  252,
  269,
  391,
  393,
  200,
  199,
  428,
  266,
  330,
  329,
  287,
  273,
  422,
  250,
  462,
  328,
  258,
  286,
  384,
  265,
  353,
  342,
  387,
  259,
  257,
  424,
  431,
  430,
  342,
  353,
  276,
  273,
  335,
  424,
  292,
  325,
  307,
  366,
  447,
  345,
  271,
  303,
  302,
  423,
  266,
  371,
  294,
  455,
  460,
  279,
  278,
  294,
  271,
  272,
  304,
  432,
  434,
  427,
  272,
  407,
  408,
  394,
  430,
  431,
  395,
  369,
  400,
  334,
  333,
  299,
  351,
  417,
  168,
  352,
  280,
  411,
  325,
  319,
  320,
  295,
  296,
  336,
  319,
  403,
  404,
  330,
  348,
  349,
  293,
  298,
  333,
  323,
  454,
  447,
  15,
  16,
  315,
  358,
  429,
  279,
  14,
  15,
  316,
  285,
  336,
  9,
  329,
  349,
  350,
  374,
  380,
  252,
  318,
  402,
  403,
  6,
  197,
  419,
  318,
  319,
  325,
  367,
  364,
  365,
  435,
  367,
  397,
  344,
  438,
  439,
  272,
  271,
  311,
  195,
  5,
  281,
  273,
  287,
  291,
  396,
  428,
  199,
  311,
  271,
  268,
  283,
  444,
  445,
  373,
  254,
  339,
  263,
  466,
  249,
  282,
  334,
  296,
  449,
  347,
  346,
  264,
  447,
  454,
  336,
  296,
  299,
  338,
  10,
  151,
  278,
  439,
  455,
  292,
  407,
  415,
  358,
  371,
  355,
  340,
  345,
  372,
  390,
  249,
  466,
  346,
  347,
  280,
  442,
  443,
  282,
  19,
  94,
  370,
  441,
  442,
  295,
  248,
  419,
  197,
  263,
  255,
  359,
  440,
  275,
  274,
  300,
  383,
  368,
  351,
  412,
  465,
  263,
  467,
  466,
  301,
  368,
  389,
  380,
  374,
  386,
  395,
  378,
  379,
  412,
  351,
  419,
  436,
  426,
  322,
  373,
  390,
  388,
  2,
  164,
  393,
  370,
  462,
  461,
  164,
  0,
  267,
  302,
  11,
  12,
  374,
  373,
  387,
  268,
  12,
  13,
  293,
  300,
  301,
  446,
  261,
  340,
  385,
  384,
  381,
  330,
  266,
  425,
  426,
  423,
  391,
  429,
  355,
  437,
  391,
  327,
  326,
  440,
  457,
  438,
  341,
  382,
  362,
  459,
  457,
  461,
  434,
  430,
  394,
  414,
  463,
  362,
  396,
  369,
  262,
  354,
  461,
  457,
  316,
  403,
  402,
  315,
  404,
  403,
  314,
  405,
  404,
  313,
  406,
  405,
  421,
  418,
  406,
  366,
  401,
  361,
  306,
  408,
  407,
  291,
  409,
  408,
  287,
  410,
  409,
  432,
  436,
  410,
  434,
  416,
  411,
  264,
  368,
  383,
  309,
  438,
  457,
  352,
  376,
  401,
  274,
  275,
  4,
  421,
  428,
  262,
  294,
  327,
  358,
  433,
  416,
  367,
  289,
  455,
  439,
  462,
  370,
  326,
  2,
  326,
  370,
  305,
  460,
  455,
  254,
  449,
  448,
  255,
  261,
  446,
  253,
  450,
  449,
  252,
  451,
  450,
  256,
  452,
  451,
  341,
  453,
  452,
  413,
  464,
  463,
  441,
  413,
  414,
  258,
  442,
  441,
  257,
  443,
  442,
  259,
  444,
  443,
  260,
  445,
  444,
  467,
  342,
  445,
  459,
  458,
  250,
  289,
  392,
  290,
  290,
  328,
  460,
  376,
  433,
  435,
  250,
  290,
  392,
  411,
  416,
  433,
  341,
  463,
  464,
  453,
  464,
  465,
  357,
  465,
  412,
  343,
  412,
  399,
  360,
  363,
  440,
  437,
  399,
  456,
  420,
  456,
  363,
  401,
  435,
  288,
  372,
  383,
  353,
  339,
  255,
  249,
  448,
  261,
  255,
  133,
  243,
  190,
  133,
  155,
  112,
  33,
  246,
  247,
  33,
  130,
  25,
  398,
  384,
  286,
  362,
  398,
  414,
  362,
  463,
  341,
  263,
  359,
  467,
  263,
  249,
  255,
  466,
  467,
  260,
  75,
  60,
  166,
  238,
  239,
  79,
  162,
  127,
  139,
  72,
  11,
  37,
  121,
  232,
  120,
  73,
  72,
  39,
  114,
  128,
  47,
  233,
  232,
  128,
  103,
  104,
  67,
  152,
  175,
  148,
  173,
  157,
  155,
  119,
  118,
  101,
  74,
  73,
  40,
  107,
  9,
  108,
  49,
  48,
  131,
  32,
  194,
  211,
  184,
  74,
  185,
  191,
  80,
  183,
  185,
  40,
  186,
  119,
  230,
  118,
  210,
  202,
  214,
  84,
  83,
  17,
  77,
  76,
  146,
  161,
  160,
  30,
  190,
  56,
  173,
  182,
  106,
  194,
  138,
  135,
  192,
  129,
  203,
  98,
  54,
  21,
  68,
  5,
  51,
  4,
  145,
  144,
  23,
  90,
  77,
  91,
  207,
  205,
  187,
  83,
  201,
  18,
  181,
  91,
  182,
  180,
  90,
  181,
  16,
  85,
  17,
  205,
  206,
  36,
  176,
  148,
  140,
  165,
  92,
  39,
  245,
  193,
  244,
  27,
  159,
  28,
  30,
  247,
  161,
  174,
  236,
  196,
  103,
  54,
  104,
  55,
  193,
  8,
  111,
  117,
  31,
  221,
  189,
  55,
  240,
  98,
  99,
  142,
  126,
  100,
  219,
  166,
  218,
  112,
  155,
  26,
  198,
  209,
  131,
  169,
  135,
  150,
  114,
  47,
  217,
  224,
  223,
  53,
  220,
  45,
  134,
  32,
  211,
  140,
  109,
  67,
  108,
  146,
  43,
  91,
  231,
  230,
  120,
  113,
  226,
  247,
  105,
  63,
  52,
  241,
  238,
  242,
  124,
  46,
  156,
  95,
  78,
  96,
  70,
  46,
  63,
  116,
  143,
  227,
  116,
  123,
  111,
  1,
  44,
  19,
  3,
  236,
  51,
  207,
  216,
  205,
  26,
  154,
  22,
  165,
  39,
  167,
  199,
  200,
  208,
  101,
  36,
  100,
  43,
  57,
  202,
  242,
  20,
  99,
  56,
  28,
  157,
  124,
  35,
  113,
  29,
  160,
  27,
  211,
  204,
  210,
  124,
  113,
  46,
  106,
  43,
  204,
  96,
  62,
  77,
  227,
  137,
  116,
  73,
  41,
  72,
  36,
  203,
  142,
  235,
  64,
  240,
  48,
  49,
  64,
  42,
  41,
  74,
  214,
  212,
  207,
  183,
  42,
  184,
  210,
  169,
  211,
  140,
  170,
  176,
  104,
  105,
  69,
  193,
  122,
  168,
  50,
  123,
  187,
  89,
  96,
  90,
  66,
  65,
  107,
  179,
  89,
  180,
  119,
  101,
  120,
  68,
  63,
  104,
  234,
  93,
  227,
  16,
  15,
  85,
  209,
  129,
  49,
  15,
  14,
  86,
  107,
  55,
  9,
  120,
  100,
  121,
  153,
  145,
  22,
  178,
  88,
  179,
  197,
  6,
  196,
  89,
  88,
  96,
  135,
  138,
  136,
  138,
  215,
  172,
  218,
  115,
  219,
  41,
  42,
  81,
  5,
  195,
  51,
  57,
  43,
  61,
  208,
  171,
  199,
  41,
  81,
  38,
  224,
  53,
  225,
  24,
  144,
  110,
  105,
  52,
  66,
  118,
  229,
  117,
  227,
  34,
  234,
  66,
  107,
  69,
  10,
  109,
  151,
  219,
  48,
  235,
  183,
  62,
  191,
  142,
  129,
  126,
  116,
  111,
  143,
  7,
  163,
  246,
  118,
  117,
  50,
  223,
  222,
  52,
  94,
  19,
  141,
  222,
  221,
  65,
  196,
  3,
  197,
  45,
  220,
  44,
  156,
  70,
  139,
  188,
  122,
  245,
  139,
  71,
  162,
  145,
  153,
  159,
  149,
  170,
  150,
  122,
  188,
  196,
  206,
  216,
  92,
  163,
  144,
  161,
  164,
  2,
  167,
  242,
  141,
  241,
  0,
  164,
  37,
  11,
  72,
  12,
  144,
  145,
  160,
  12,
  38,
  13,
  70,
  63,
  71,
  31,
  226,
  111,
  157,
  158,
  154,
  36,
  101,
  205,
  203,
  206,
  165,
  126,
  209,
  217,
  98,
  165,
  97,
  237,
  220,
  218,
  237,
  239,
  241,
  210,
  214,
  169,
  140,
  171,
  32,
  241,
  125,
  237,
  179,
  86,
  178,
  180,
  85,
  179,
  181,
  84,
  180,
  182,
  83,
  181,
  194,
  201,
  182,
  177,
  137,
  132,
  184,
  76,
  183,
  185,
  61,
  184,
  186,
  57,
  185,
  216,
  212,
  186,
  192,
  214,
  187,
  139,
  34,
  156,
  218,
  79,
  237,
  147,
  123,
  177,
  45,
  44,
  4,
  208,
  201,
  32,
  98,
  64,
  129,
  192,
  213,
  138,
  235,
  59,
  219,
  141,
  242,
  97,
  97,
  2,
  141,
  240,
  75,
  235,
  229,
  24,
  228,
  31,
  25,
  226,
  230,
  23,
  229,
  231,
  22,
  230,
  232,
  26,
  231,
  233,
  112,
  232,
  244,
  189,
  243,
  189,
  221,
  190,
  222,
  28,
  221,
  223,
  27,
  222,
  224,
  29,
  223,
  225,
  30,
  224,
  113,
  247,
  225,
  99,
  60,
  240,
  213,
  147,
  215,
  60,
  20,
  166,
  192,
  187,
  213,
  243,
  112,
  244,
  244,
  233,
  245,
  245,
  128,
  188,
  188,
  114,
  174,
  134,
  131,
  220,
  174,
  217,
  236,
  236,
  198,
  134,
  215,
  177,
  58,
  156,
  143,
  124,
  25,
  110,
  7,
  31,
  228,
  25,
  264,
  356,
  368,
  0,
  11,
  267,
  451,
  452,
  349,
  267,
  302,
  269,
  350,
  357,
  277,
  350,
  452,
  357,
  299,
  333,
  297,
  396,
  175,
  377,
  381,
  384,
  382,
  280,
  347,
  330,
  269,
  303,
  270,
  151,
  9,
  337,
  344,
  278,
  360,
  424,
  418,
  431,
  270,
  304,
  409,
  272,
  310,
  407,
  322,
  270,
  410,
  449,
  450,
  347,
  432,
  422,
  434,
  18,
  313,
  17,
  291,
  306,
  375,
  259,
  387,
  260,
  424,
  335,
  418,
  434,
  364,
  416,
  391,
  423,
  327,
  301,
  251,
  298,
  275,
  281,
  4,
  254,
  373,
  253,
  375,
  307,
  321,
  280,
  425,
  411,
  200,
  421,
  18,
  335,
  321,
  406,
  321,
  320,
  405,
  314,
  315,
  17,
  423,
  426,
  266,
  396,
  377,
  369,
  270,
  322,
  269,
  413,
  417,
  464,
  385,
  386,
  258,
  248,
  456,
  419,
  298,
  284,
  333,
  168,
  417,
  8,
  448,
  346,
  261,
  417,
  413,
  285,
  326,
  327,
  328,
  277,
  355,
  329,
  309,
  392,
  438,
  381,
  382,
  256,
  279,
  429,
  360,
  365,
  364,
  379,
  355,
  277,
  437,
  282,
  443,
  283,
  281,
  275,
  363,
  395,
  431,
  369,
  299,
  297,
  337,
  335,
  273,
  321,
  348,
  450,
  349,
  359,
  446,
  467,
  283,
  293,
  282,
  250,
  458,
  462,
  300,
  276,
  383,
  292,
  308,
  325,
  283,
  276,
  293,
  264,
  372,
  447,
  346,
  352,
  340,
  354,
  274,
  19,
  363,
  456,
  281,
  426,
  436,
  425,
  380,
  381,
  252,
  267,
  269,
  393,
  421,
  200,
  428,
  371,
  266,
  329,
  432,
  287,
  422,
  290,
  250,
  328,
  385,
  258,
  384,
  446,
  265,
  342,
  386,
  387,
  257,
  422,
  424,
  430,
  445,
  342,
  276,
  422,
  273,
  424,
  306,
  292,
  307,
  352,
  366,
  345,
  268,
  271,
  302,
  358,
  423,
  371,
  327,
  294,
  460,
  331,
  279,
  294,
  303,
  271,
  304,
  436,
  432,
  427,
  304,
  272,
  408,
  395,
  394,
  431,
  378,
  395,
  400,
  296,
  334,
  299,
  6,
  351,
  168,
  376,
  352,
  411,
  307,
  325,
  320,
  285,
  295,
  336,
  320,
  319,
  404,
  329,
  330,
  349,
  334,
  293,
  333,
  366,
  323,
  447,
  316,
  15,
  315,
  331,
  358,
  279,
  317,
  14,
  316,
  8,
  285,
  9,
  277,
  329,
  350,
  253,
  374,
  252,
  319,
  318,
  403,
  351,
  6,
  419,
  324,
  318,
  325,
  397,
  367,
  365,
  288,
  435,
  397,
  278,
  344,
  439,
  310,
  272,
  311,
  248,
  195,
  281,
  375,
  273,
  291,
  175,
  396,
  199,
  312,
  311,
  268,
  276,
  283,
  445,
  390,
  373,
  339,
  295,
  282,
  296,
  448,
  449,
  346,
  356,
  264,
  454,
  337,
  336,
  299,
  337,
  338,
  151,
  294,
  278,
  455,
  308,
  292,
  415,
  429,
  358,
  355,
  265,
  340,
  372,
  388,
  390,
  466,
  352,
  346,
  280,
  295,
  442,
  282,
  354,
  19,
  370,
  285,
  441,
  295,
  195,
  248,
  197,
  457,
  440,
  274,
  301,
  300,
  368,
  417,
  351,
  465,
  251,
  301,
  389,
  385,
  380,
  386,
  394,
  395,
  379,
  399,
  412,
  419,
  410,
  436,
  322,
  387,
  373,
  388,
  326,
  2,
  393,
  354,
  370,
  461,
  393,
  164,
  267,
  268,
  302,
  12,
  386,
  374,
  387,
  312,
  268,
  13,
  298,
  293,
  301,
  265,
  446,
  340,
  380,
  385,
  381,
  280,
  330,
  425,
  322,
  426,
  391,
  420,
  429,
  437,
  393,
  391,
  326,
  344,
  440,
  438,
  458,
  459,
  461,
  364,
  434,
  394,
  428,
  396,
  262,
  274,
  354,
  457,
  317,
  316,
  402,
  316,
  315,
  403,
  315,
  314,
  404,
  314,
  313,
  405,
  313,
  421,
  406,
  323,
  366,
  361,
  292,
  306,
  407,
  306,
  291,
  408,
  291,
  287,
  409,
  287,
  432,
  410,
  427,
  434,
  411,
  372,
  264,
  383,
  459,
  309,
  457,
  366,
  352,
  401,
  1,
  274,
  4,
  418,
  421,
  262,
  331,
  294,
  358,
  435,
  433,
  367,
  392,
  289,
  439,
  328,
  462,
  326,
  94,
  2,
  370,
  289,
  305,
  455,
  339,
  254,
  448,
  359,
  255,
  446,
  254,
  253,
  449,
  253,
  252,
  450,
  252,
  256,
  451,
  256,
  341,
  452,
  414,
  413,
  463,
  286,
  441,
  414,
  286,
  258,
  441,
  258,
  257,
  442,
  257,
  259,
  443,
  259,
  260,
  444,
  260,
  467,
  445,
  309,
  459,
  250,
  305,
  289,
  290,
  305,
  290,
  460,
  401,
  376,
  435,
  309,
  250,
  392,
  376,
  411,
  433,
  453,
  341,
  464,
  357,
  453,
  465,
  343,
  357,
  412,
  437,
  343,
  399,
  344,
  360,
  440,
  420,
  437,
  456,
  360,
  420,
  363,
  361,
  401,
  288,
  265,
  372,
  353,
  390,
  339,
  249,
  339,
  448,
  255
];
var VTX68 = [
  127,
  234,
  132,
  58,
  172,
  150,
  149,
  148,
  152,
  377,
  378,
  379,
  397,
  288,
  361,
  454,
  356,
  70,
  63,
  105,
  66,
  107,
  336,
  296,
  334,
  293,
  300,
  168,
  6,
  195,
  4,
  98,
  97,
  2,
  326,
  327,
  33,
  160,
  158,
  133,
  153,
  144,
  362,
  385,
  387,
  263,
  373,
  380,
  57,
  40,
  37,
  0,
  267,
  270,
  287,
  321,
  314,
  17,
  84,
  91,
  78,
  81,
  13,
  311,
  308,
  402,
  14,
  178
];
var VTX33 = [33, 133, 362, 263, 1, 62, 308, 159, 145, 386, 374, 6, 102, 331, 2, 13, 14, 70, 105, 107, 336, 334, 300, 54, 10, 284, 50, 280, 234, 454, 58, 288, 152];
var VTX7 = [33, 133, 362, 263, 1, 78, 308];
var UV68 = VTX68.map((x10) => UV468[x10]);
var UV33 = VTX33.map((x10) => UV468[x10]);
var UV7 = VTX7.map((x10) => UV468[x10]);
var getBoxSize = (box) => [Math.abs(box.endPoint[0] - box.startPoint[0]), Math.abs(box.endPoint[1] - box.startPoint[1])];
var getBoxCenter = (box) => [box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2, box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2, 1];
var clampBox = (box, input) => box ? [
  Math.trunc(Math.max(0, box.startPoint[0])),
  Math.trunc(Math.max(0, box.startPoint[1])),
  Math.trunc(Math.min(input.shape[2] || 0, box.endPoint[0]) - Math.max(0, box.startPoint[0])),
  Math.trunc(Math.min(input.shape[1] || 0, box.endPoint[1]) - Math.max(0, box.startPoint[1]))
] : [0, 0, 0, 0];
var getRawBox = (box, input) => box ? [
  box.startPoint[0] / (input.shape[2] || 0),
  box.startPoint[1] / (input.shape[1] || 0),
  (box.endPoint[0] - box.startPoint[0]) / (input.shape[2] || 0),
  (box.endPoint[1] - box.startPoint[1]) / (input.shape[1] || 0)
] : [0, 0, 0, 0];
var scaleBoxCoordinates = (box, factor) => {
  const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
  const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
  return { startPoint, endPoint, landmarks: box.landmarks, confidence: box.confidence };
};
var cutAndResize = (box, image, cropSize) => {
  const h10 = image.shape[1];
  const w10 = image.shape[2];
  const cutBox = [box.startPoint[1] / h10, box.startPoint[0] / w10, box.endPoint[1] / h10, box.endPoint[0] / w10];
  const crop = ds.cropAndResize(image, [cutBox], [0], cropSize);
  const norm = xe2(crop, constants.tf255);
  Re2(crop);
  return norm;
};
var enlargeBox = (box, factor) => {
  const center = getBoxCenter(box);
  const size2 = getBoxSize(box);
  const halfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
  return { startPoint: [center[0] - halfSize[0], center[1] - halfSize[1]], endPoint: [center[0] + halfSize[0], center[1] + halfSize[1]], landmarks: box.landmarks, confidence: box.confidence };
};
var squarifyBox = (box) => {
  const centers = getBoxCenter(box);
  const size2 = getBoxSize(box);
  const halfSize = Math.max(...size2) / 2;
  return { startPoint: [Math.round(centers[0] - halfSize), Math.round(centers[1] - halfSize)], endPoint: [Math.round(centers[0] + halfSize), Math.round(centers[1] + halfSize)], landmarks: box.landmarks, confidence: box.confidence };
};
var calculateLandmarksBoundingBox = (landmarks) => {
  const x10 = landmarks.map((d10) => d10[0]);
  const y10 = landmarks.map((d10) => d10[1]);
  return { startPoint: [Math.min(...x10), Math.min(...y10)], endPoint: [Math.max(...x10), Math.max(...y10)], landmarks };
};
var fixedRotationMatrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
var normalizeRadians = (angle2) => angle2 - 2 * Math.PI * Math.floor((angle2 + Math.PI) / (2 * Math.PI));
var computeRotation = (point1, point2) => normalizeRadians(Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]));
var buildTranslationMatrix = (x10, y10) => [[1, 0, x10], [0, 1, y10], [0, 0, 1]];
var dot = (v12, v22) => {
  let product = 0;
  for (let i10 = 0; i10 < v12.length; i10++)
    product += v12[i10] * v22[i10];
  return product;
};
var getColumnFrom2DArr = (arr, columnIndex) => {
  const column = [];
  for (let i10 = 0; i10 < arr.length; i10++)
    column.push(arr[i10][columnIndex]);
  return column;
};
var multiplyTransformMatrices = (mat1, mat2) => {
  const product = [];
  const size2 = mat1.length;
  for (let row = 0; row < size2; row++) {
    product.push([]);
    for (let col = 0; col < size2; col++)
      product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));
  }
  return product;
};
var buildRotationMatrix = (rotation, center) => {
  const cosA = Math.cos(rotation);
  const sinA = Math.sin(rotation);
  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
  const translationMatrix = buildTranslationMatrix(center[0], center[1]);
  const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);
  const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);
  return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);
};
var invertTransformMatrix = (matrix) => {
  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
  const translationComponent = [matrix[0][2], matrix[1][2]];
  const invertedTranslation = [-dot(rotationComponent[0], translationComponent), -dot(rotationComponent[1], translationComponent)];
  return [rotationComponent[0].concat(invertedTranslation[0]), rotationComponent[1].concat(invertedTranslation[1]), [0, 0, 1]];
};
var rotatePoint = (homogeneousCoordinate, rotationMatrix) => [dot(homogeneousCoordinate, rotationMatrix[0]), dot(homogeneousCoordinate, rotationMatrix[1])];
function generateAnchors(inputSize10) {
  const spec = { strides: [inputSize10 / 16, inputSize10 / 8], anchors: [2, 6] };
  const anchors3 = [];
  for (let i10 = 0; i10 < spec.strides.length; i10++) {
    const stride = spec.strides[i10];
    const gridRows = Math.floor((inputSize10 + stride - 1) / stride);
    const gridCols = Math.floor((inputSize10 + stride - 1) / stride);
    const anchorsNum = spec.anchors[i10];
    for (let gridY = 0; gridY < gridRows; gridY++) {
      const anchorY = stride * (gridY + 0.5);
      for (let gridX = 0; gridX < gridCols; gridX++) {
        const anchorX = stride * (gridX + 0.5);
        for (let n10 = 0; n10 < anchorsNum; n10++)
          anchors3.push([anchorX, anchorY]);
      }
    }
  }
  return anchors3;
}
function transformRawCoords(coordsRaw, box, angle2, rotationMatrix, inputSize10) {
  const boxSize = getBoxSize(box);
  const coordsScaled = coordsRaw.map((coord) => [
    boxSize[0] / inputSize10 * (coord[0] - inputSize10 / 2),
    boxSize[1] / inputSize10 * (coord[1] - inputSize10 / 2),
    coord[2] || 0
  ]);
  const largeAngle = angle2 && angle2 !== 0 && Math.abs(angle2) > 0.2;
  const coordsRotationMatrix = largeAngle ? buildRotationMatrix(angle2, [0, 0]) : fixedRotationMatrix;
  const coordsRotated = largeAngle ? coordsScaled.map((coord) => [...rotatePoint(coord, coordsRotationMatrix), coord[2]]) : coordsScaled;
  const inverseRotationMatrix = largeAngle ? invertTransformMatrix(rotationMatrix) : fixedRotationMatrix;
  const boxCenter = getBoxCenter(box);
  const offsets = [dot(boxCenter, inverseRotationMatrix[0]), dot(boxCenter, inverseRotationMatrix[1])];
  return coordsRotated.map((coord) => [
    Math.trunc(coord[0] + offsets[0]),
    Math.trunc(coord[1] + offsets[1]),
    Math.trunc(coord[2] || 0)
  ]);
}
function correctFaceRotation(rotate, box, input, inputSize10) {
  const symmetryLine = box.landmarks.length >= meshLandmarks.count ? meshLandmarks.symmetryLine : blazeFaceLandmarks.symmetryLine;
  let angle2 = 0;
  let rotationMatrix = fixedRotationMatrix;
  let face4;
  if (rotate && env.kernels.includes("rotatewithoffset")) {
    angle2 = computeRotation(box.landmarks[symmetryLine[0]], box.landmarks[symmetryLine[1]]);
    const largeAngle = angle2 && angle2 !== 0 && Math.abs(angle2) > 0.2;
    if (largeAngle) {
      const center = getBoxCenter(box);
      const centerRaw = [center[0] / input.shape[2], center[1] / input.shape[1]];
      const rotated = ds.rotateWithOffset(input, angle2, 0, centerRaw);
      rotationMatrix = buildRotationMatrix(-angle2, center);
      face4 = cutAndResize(box, rotated, [inputSize10, inputSize10]);
      Re2(rotated);
    } else {
      face4 = cutAndResize(box, input, [inputSize10, inputSize10]);
    }
  } else {
    face4 = cutAndResize(box, input, [inputSize10, inputSize10]);
  }
  return [angle2, rotationMatrix, face4];
}
var findFaceCenter = (mesh) => {
  const x10 = mesh.map((m10) => m10[0]);
  const y10 = mesh.map((m10) => m10[1]);
  return [Math.min(...x10) + (Math.max(...x10) - Math.min(...x10)) / 2, Math.min(...y10) + (Math.max(...y10) - Math.min(...y10)) / 2];
};
var calculateFaceBox = (mesh, previousBox) => {
  const center = findFaceCenter(mesh);
  const boxSize = getBoxSize(previousBox);
  const calculatedBox = {
    startPoint: [center[0] - boxSize[0] / 2, center[1] - boxSize[1] / 2],
    endPoint: [center[0] + boxSize[0] / 2, center[1] + boxSize[1] / 2]
  };
  return calculatedBox;
};
var keypointsCount = 6;
var faceBoxScaleFactor = 1.2;
var model5;
var anchors = null;
var inputSize = 0;
var inputSizeT = null;
var size = () => inputSize;
async function load5(config3) {
  var _a2;
  if (env.initial)
    model5 = null;
  if (!model5)
    model5 = await loadModel((_a2 = config3.face.detector) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model5["modelUrl"]);
  inputSize = model5.inputs[0].shape ? model5.inputs[0].shape[2] : 0;
  inputSizeT = Ie2(inputSize, "int32");
  anchors = ji(generateAnchors(inputSize));
  return model5;
}
function decodeBounds(boxOutputs) {
  const t = {};
  t.boxStarts = He(boxOutputs, [0, 1], [-1, 2]);
  t.centers = ie2(t.boxStarts, anchors);
  t.boxSizes = He(boxOutputs, [0, 3], [-1, 2]);
  t.boxSizesNormalized = xe2(t.boxSizes, inputSizeT);
  t.centersNormalized = xe2(t.centers, inputSizeT);
  t.halfBoxSize = xe2(t.boxSizesNormalized, constants.tf2);
  t.starts = ge2(t.centersNormalized, t.halfBoxSize);
  t.ends = ie2(t.centersNormalized, t.halfBoxSize);
  t.startNormalized = V2(t.starts, inputSizeT);
  t.endNormalized = V2(t.ends, inputSizeT);
  const boxes = FE([t.startNormalized, t.endNormalized], 1);
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  return boxes;
}
async function getBoxes(inputImage, config3) {
  var _a2, _b2, _c, _d2;
  if (!inputImage || inputImage["isDisposedInternal"] || inputImage.shape.length !== 4 || inputImage.shape[1] < 1 || inputImage.shape[2] < 1)
    return [];
  const t = {};
  t.resized = ds.resizeBilinear(inputImage, [inputSize, inputSize]);
  t.div = xe2(t.resized, constants.tf127);
  t.normalized = ge2(t.div, constants.tf05);
  const res2 = model5 == null ? void 0 : model5.execute(t.normalized);
  if (Array.isArray(res2)) {
    const sorted = res2.sort((a10, b10) => a10.size - b10.size);
    t.concat384 = Ft([sorted[0], sorted[2]], 2);
    t.concat512 = Ft([sorted[1], sorted[3]], 2);
    t.concat = Ft([t.concat512, t.concat384], 1);
    t.batch = mr(t.concat, 0);
  } else {
    t.batch = mr(res2);
  }
  Re2(res2);
  t.boxes = decodeBounds(t.batch);
  t.logits = He(t.batch, [0, 0], [-1, 1]);
  t.sigmoid = qs(t.logits);
  t.scores = mr(t.sigmoid);
  t.nms = await ds.nonMaxSuppressionAsync(t.boxes, t.scores, ((_a2 = config3.face.detector) == null ? void 0 : _a2.maxDetected) || 0, ((_b2 = config3.face.detector) == null ? void 0 : _b2.iouThreshold) || 0, ((_c = config3.face.detector) == null ? void 0 : _c.minConfidence) || 0);
  const nms = await t.nms.array();
  const boxes = [];
  const scores = await t.scores.data();
  for (let i10 = 0; i10 < nms.length; i10++) {
    const confidence = scores[nms[i10]];
    if (confidence > (((_d2 = config3.face.detector) == null ? void 0 : _d2.minConfidence) || 0)) {
      const b10 = {};
      b10.bbox = He(t.boxes, [nms[i10], 0], [1, -1]);
      b10.slice = He(t.batch, [nms[i10], keypointsCount - 1], [1, -1]);
      b10.squeeze = mr(b10.slice);
      b10.landmarks = G2(b10.squeeze, [keypointsCount, -1]);
      const points = await b10.bbox.data();
      const rawBox = {
        startPoint: [points[0], points[1]],
        endPoint: [points[2], points[3]],
        landmarks: await b10.landmarks.array(),
        confidence
      };
      const scaledBox = scaleBoxCoordinates(rawBox, [(inputImage.shape[2] || 0) / inputSize, (inputImage.shape[1] || 0) / inputSize]);
      const enlargedBox = enlargeBox(scaledBox, config3.face["scale"] || faceBoxScaleFactor);
      const squaredBox = squarifyBox(enlargedBox);
      boxes.push(squaredBox);
      Object.keys(b10).forEach((tensor) => Re2(b10[tensor]));
    }
  }
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  return boxes;
}
var blazeposecoords_exports = {};
__export(blazeposecoords_exports, {
  connected: () => connected,
  kpt: () => kpt
});
var kpt = [
  "nose",
  "leftEyeInside",
  "leftEye",
  "leftEyeOutside",
  "rightEyeInside",
  "rightEye",
  "rightEyeOutside",
  "leftEar",
  "rightEar",
  "leftMouth",
  "rightMouth",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftPinky",
  "rightPinky",
  "leftIndex",
  "rightIndex",
  "leftThumb",
  "rightThumb",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle",
  "leftHeel",
  "rightHeel",
  "leftFoot",
  "rightFoot",
  "bodyCenter",
  "bodyTop",
  "leftPalm",
  "leftHand",
  "rightPalm",
  "rightHand"
];
var connected = {
  shoulders: ["leftShoulder", "rightShoulder"],
  hips: ["rightHip", "leftHip"],
  mouth: ["leftMouth", "rightMouth"],
  leftLegUpper: ["leftHip", "leftKnee"],
  leftLegLower: ["leftKnee", "leftAnkle"],
  leftFoot: ["leftAnkle", "leftHeel", "leftFoot"],
  leftTorso: ["leftShoulder", "leftHip"],
  leftArmUpper: ["leftShoulder", "leftElbow"],
  leftArmLower: ["leftElbow", "leftWrist"],
  leftHand: ["leftWrist", "leftPalm"],
  leftHandPinky: ["leftPalm", "leftPinky"],
  leftHandIndex: ["leftPalm", "leftIndex"],
  leftHandThumb: ["leftPalm", "leftThumb"],
  leftEyeOutline: ["leftEyeInside", "leftEyeOutside"],
  rightLegUpper: ["rightHip", "rightKnee"],
  rightLegLower: ["rightKnee", "rightAnkle"],
  rightFoot: ["rightAnkle", "rightHeel", "rightFoot"],
  rightTorso: ["rightShoulder", "rightHip"],
  rightArmUpper: ["rightShoulder", "rightElbow"],
  rightArmLower: ["rightElbow", "rightWrist"],
  rightHand: ["rightWrist", "rightPalm"],
  rightHandPinky: ["rightPalm", "rightPinky"],
  rightHandIndex: ["rightPalm", "rightIndex"],
  rightHandThumb: ["rightPalm", "rightThumb"],
  rightEyeOutline: ["rightEyeInside", "rightEyeOutside"]
};
var inputSize2 = 224;
var anchorTensor;
var numLayers = 5;
var strides = [8, 16, 32, 32, 32];
async function createAnchors() {
  const anchors3 = [];
  let layerId = 0;
  while (layerId < numLayers) {
    let anchorCount = 0;
    let lastSameStrideLayer = layerId;
    while (lastSameStrideLayer < strides.length && strides[lastSameStrideLayer] === strides[layerId]) {
      anchorCount += 2;
      lastSameStrideLayer++;
    }
    const stride = strides[layerId];
    const featureMapHeight = Math.ceil(inputSize2 / stride);
    const featureMapWidth = Math.ceil(inputSize2 / stride);
    for (let y10 = 0; y10 < featureMapHeight; ++y10) {
      for (let x10 = 0; x10 < featureMapWidth; ++x10) {
        for (let anchorId = 0; anchorId < anchorCount; ++anchorId) {
          anchors3.push({ x: (x10 + 0.5) / featureMapWidth, y: (y10 + 0.5) / featureMapHeight });
        }
      }
    }
    layerId = lastSameStrideLayer;
  }
  anchorTensor = { x: Qt(anchors3.map((a10) => a10.x)), y: Qt(anchors3.map((a10) => a10.y)) };
}
function calc(keypoints, outputSize2 = [1, 1]) {
  const coords = [keypoints.map((pt2) => pt2[0]), keypoints.map((pt2) => pt2[1])];
  const min = [Math.min(...coords[0]), Math.min(...coords[1])];
  const max = [Math.max(...coords[0]), Math.max(...coords[1])];
  const box = [min[0], min[1], max[0] - min[0], max[1] - min[1]];
  const boxRaw = [box[0] / outputSize2[0], box[1] / outputSize2[1], box[2] / outputSize2[0], box[3] / outputSize2[1]];
  return { box, boxRaw };
}
function square(keypoints, outputSize2 = [1, 1]) {
  const coords = [keypoints.map((pt2) => pt2[0]), keypoints.map((pt2) => pt2[1])];
  const min = [Math.min(...coords[0]), Math.min(...coords[1])];
  const max = [Math.max(...coords[0]), Math.max(...coords[1])];
  const center = [(min[0] + max[0]) / 2, (min[1] + max[1]) / 2];
  const dist = Math.max(center[0] - min[0], center[1] - min[1], -center[0] + max[0], -center[1] + max[1]);
  const box = [Math.trunc(center[0] - dist), Math.trunc(center[1] - dist), Math.trunc(2 * dist), Math.trunc(2 * dist)];
  const boxRaw = [box[0] / outputSize2[0], box[1] / outputSize2[1], box[2] / outputSize2[0], box[3] / outputSize2[1]];
  return { box, boxRaw };
}
function scale(box, scaleFact) {
  const dist = [box[2] * scaleFact, box[3] * scaleFact];
  const newBox = [
    box[0] - (dist[0] - box[2]) / 2,
    box[1] - (dist[1] - box[3]) / 2,
    dist[0],
    dist[1]
  ];
  return newBox;
}
var env2 = { initial: true };
var models = { detector: null, landmarks: null };
var inputSize3 = { detector: [224, 224], landmarks: [256, 256] };
var skipped5 = Number.MAX_SAFE_INTEGER;
var outputNodes = {
  landmarks: ["ld_3d", "activation_segmentation", "activation_heatmap", "world_3d", "output_poseflag"],
  detector: []
};
var cache = null;
var cropBox;
var padding = [[0, 0], [0, 0], [0, 0], [0, 0]];
var lastTime5 = 0;
var sigmoid = (x10) => 1 - 1 / (1 + Math.exp(x10));
async function loadDetect(config3) {
  if (env2.initial)
    models.detector = null;
  if (!models.detector && config3.body["detector"] && config3.body["detector"]["modelPath"] || "") {
    models.detector = await loadModel(config3.body["detector"]["modelPath"]);
    const inputs = Object.values(models.detector.modelSignature["inputs"]);
    inputSize3.detector[0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize3.detector[1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug && models.detector)
    log("cached model:", models.detector["modelUrl"]);
  await createAnchors();
  return models.detector;
}
async function loadPose(config3) {
  if (env2.initial)
    models.landmarks = null;
  if (!models.landmarks) {
    models.landmarks = await loadModel(config3.body.modelPath);
    const inputs = Object.values(models.landmarks.modelSignature["inputs"]);
    inputSize3.landmarks[0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize3.landmarks[1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug)
    log("cached model:", models.landmarks["modelUrl"]);
  return models.landmarks;
}
async function prepareImage(input, size2) {
  const t = {};
  if (!input.shape || !input.shape[1] || !input.shape[2])
    return input;
  let final;
  if (cropBox) {
    t.cropped = ds.cropAndResize(input, [cropBox], [0], [input.shape[1], input.shape[2]]);
  }
  if (input.shape[1] !== input.shape[2]) {
    const height = [
      input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0,
      input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0
    ];
    const width = [
      input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0,
      input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0
    ];
    padding = [
      [0, 0],
      height,
      width,
      [0, 0]
    ];
    t.pad = pi(t.cropped || input, padding);
    t.resize = ds.resizeBilinear(t.pad, [size2, size2]);
    final = xe2(t.resize, constants.tf255);
  } else if (input.shape[1] !== size2) {
    t.resize = ds.resizeBilinear(t.cropped || input, [size2, size2]);
    final = xe2(t.resize, constants.tf255);
  } else {
    final = xe2(t.cropped || input, constants.tf255);
  }
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  return final;
}
function rescaleKeypoints(keypoints, outputSize2) {
  for (const kpt4 of keypoints) {
    kpt4.position = [
      Math.trunc(kpt4.position[0] * (outputSize2[0] + padding[2][0] + padding[2][1]) / outputSize2[0] - padding[2][0]),
      Math.trunc(kpt4.position[1] * (outputSize2[1] + padding[1][0] + padding[1][1]) / outputSize2[1] - padding[1][0]),
      kpt4.position[2]
    ];
    kpt4.positionRaw = [kpt4.position[0] / outputSize2[0], kpt4.position[1] / outputSize2[1], 2 * kpt4.position[2] / (outputSize2[0] + outputSize2[1])];
  }
  if (cropBox) {
    for (const kpt4 of keypoints) {
      kpt4.positionRaw = [
        kpt4.positionRaw[0] + cropBox[1],
        kpt4.positionRaw[1] + cropBox[0],
        kpt4.positionRaw[2]
      ];
      kpt4.position = [
        Math.trunc(kpt4.positionRaw[0] * outputSize2[0]),
        Math.trunc(kpt4.positionRaw[1] * outputSize2[1]),
        kpt4.positionRaw[2]
      ];
    }
  }
  return keypoints;
}
async function fixKeypoints(keypoints) {
  const leftPalm = keypoints.find((k10) => k10.part === "leftPalm");
  const leftWrist = keypoints.find((k10) => k10.part === "leftWrist");
  const leftIndex = keypoints.find((k10) => k10.part === "leftIndex");
  leftPalm.position[2] = ((leftWrist.position[2] || 0) + (leftIndex.position[2] || 0)) / 2;
  const rightPalm = keypoints.find((k10) => k10.part === "rightPalm");
  const rightWrist = keypoints.find((k10) => k10.part === "rightWrist");
  const rightIndex = keypoints.find((k10) => k10.part === "rightIndex");
  rightPalm.position[2] = ((rightWrist.position[2] || 0) + (rightIndex.position[2] || 0)) / 2;
}
async function detectLandmarks(input, config3, outputSize2) {
  var _a2;
  const t = {};
  [t.ld, t.segmentation, t.heatmap, t.world, t.poseflag] = (_a2 = models.landmarks) == null ? void 0 : _a2.execute(input, outputNodes.landmarks);
  const poseScore = (await t.poseflag.data())[0];
  const points = await t.ld.data();
  const distances = await t.world.data();
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  const keypointsRelative = [];
  const depth = 5;
  for (let i10 = 0; i10 < points.length / depth; i10++) {
    const score = sigmoid(points[depth * i10 + 3]);
    const presence = sigmoid(points[depth * i10 + 4]);
    const adjScore = Math.trunc(100 * score * presence * poseScore) / 100;
    const positionRaw = [points[depth * i10 + 0] / inputSize3.landmarks[0], points[depth * i10 + 1] / inputSize3.landmarks[1], points[depth * i10 + 2] + 0];
    const position = [Math.trunc(outputSize2[0] * positionRaw[0]), Math.trunc(outputSize2[1] * positionRaw[1]), positionRaw[2]];
    const distance2 = [distances[depth * i10 + 0], distances[depth * i10 + 1], distances[depth * i10 + 2] + 0];
    keypointsRelative.push({ part: kpt[i10], positionRaw, position, distance: distance2, score: adjScore });
  }
  if (poseScore < (config3.body.minConfidence || 0))
    return null;
  fixKeypoints(keypointsRelative);
  const keypoints = rescaleKeypoints(keypointsRelative, outputSize2);
  const kpts = keypoints.map((k10) => k10.position);
  const boxes = calc(kpts, [outputSize2[0], outputSize2[1]]);
  const annotations2 = {};
  for (const [name, indexes] of Object.entries(connected)) {
    const pt2 = [];
    for (let i10 = 0; i10 < indexes.length - 1; i10++) {
      const pt0 = keypoints.find((kpt4) => kpt4.part === indexes[i10]);
      const pt1 = keypoints.find((kpt4) => kpt4.part === indexes[i10 + 1]);
      if (pt0 && pt1)
        pt2.push([pt0.position, pt1.position]);
    }
    annotations2[name] = pt2;
  }
  const body4 = { id: 0, score: Math.trunc(100 * poseScore) / 100, box: boxes.box, boxRaw: boxes.boxRaw, keypoints, annotations: annotations2 };
  return body4;
}
async function predict5(input, config3) {
  const outputSize2 = [input.shape[2] || 0, input.shape[1] || 0];
  const skipTime = (config3.body.skipTime || 0) > now2() - lastTime5;
  const skipFrame = skipped5 < (config3.body.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame && cache !== null) {
    skipped5++;
  } else {
    const t = {};
    t.landmarks = await prepareImage(input, 256);
    cache = await detectLandmarks(t.landmarks, config3, outputSize2);
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    lastTime5 = now2();
    skipped5 = 0;
  }
  return cache ? [cache] : [];
}
var labels = [
  { class: 1, label: "person" },
  { class: 2, label: "bicycle" },
  { class: 3, label: "car" },
  { class: 4, label: "motorcycle" },
  { class: 5, label: "airplane" },
  { class: 6, label: "bus" },
  { class: 7, label: "train" },
  { class: 8, label: "truck" },
  { class: 9, label: "boat" },
  { class: 10, label: "traffic light" },
  { class: 11, label: "fire hydrant" },
  { class: 12, label: "stop sign" },
  { class: 13, label: "parking meter" },
  { class: 14, label: "bench" },
  { class: 15, label: "bird" },
  { class: 16, label: "cat" },
  { class: 17, label: "dog" },
  { class: 18, label: "horse" },
  { class: 19, label: "sheep" },
  { class: 20, label: "cow" },
  { class: 21, label: "elephant" },
  { class: 22, label: "bear" },
  { class: 23, label: "zebra" },
  { class: 24, label: "giraffe" },
  { class: 25, label: "backpack" },
  { class: 26, label: "umbrella" },
  { class: 27, label: "handbag" },
  { class: 28, label: "tie" },
  { class: 29, label: "suitcase" },
  { class: 30, label: "frisbee" },
  { class: 31, label: "skis" },
  { class: 32, label: "snowboard" },
  { class: 33, label: "sports ball" },
  { class: 34, label: "kite" },
  { class: 35, label: "baseball bat" },
  { class: 36, label: "baseball glove" },
  { class: 37, label: "skateboard" },
  { class: 38, label: "surfboard" },
  { class: 39, label: "tennis racket" },
  { class: 40, label: "bottle" },
  { class: 41, label: "wine glass" },
  { class: 42, label: "cup" },
  { class: 43, label: "fork" },
  { class: 44, label: "knife" },
  { class: 45, label: "spoon" },
  { class: 46, label: "bowl" },
  { class: 47, label: "banana" },
  { class: 48, label: "apple" },
  { class: 49, label: "sandwich" },
  { class: 50, label: "orange" },
  { class: 51, label: "broccoli" },
  { class: 52, label: "carrot" },
  { class: 53, label: "hot dog" },
  { class: 54, label: "pizza" },
  { class: 55, label: "donut" },
  { class: 56, label: "cake" },
  { class: 57, label: "chair" },
  { class: 58, label: "couch" },
  { class: 59, label: "potted plant" },
  { class: 60, label: "bed" },
  { class: 61, label: "dining table" },
  { class: 62, label: "toilet" },
  { class: 63, label: "tv" },
  { class: 64, label: "laptop" },
  { class: 65, label: "mouse" },
  { class: 66, label: "remote" },
  { class: 67, label: "keyboard" },
  { class: 68, label: "cell phone" },
  { class: 69, label: "microwave" },
  { class: 70, label: "oven" },
  { class: 71, label: "toaster" },
  { class: 72, label: "sink" },
  { class: 73, label: "refrigerator" },
  { class: 74, label: "book" },
  { class: 75, label: "clock" },
  { class: 76, label: "vase" },
  { class: 77, label: "scissors" },
  { class: 78, label: "teddy bear" },
  { class: 79, label: "hair drier" },
  { class: 80, label: "toothbrush" }
];
var model6;
var inputSize4 = 0;
var last5 = [];
var lastTime6 = 0;
var skipped6 = Number.MAX_SAFE_INTEGER;
async function load6(config3) {
  if (env.initial)
    model6 = null;
  if (!model6) {
    model6 = await loadModel(config3.object.modelPath);
    const inputs = Object.values(model6.modelSignature["inputs"]);
    inputSize4 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug)
    log("cached model:", model6["modelUrl"]);
  return model6;
}
async function process3(res2, outputShape, config3) {
  if (!res2)
    return [];
  const t = {};
  const results = [];
  const detections = await res2.array();
  t.squeeze = mr(res2);
  const arr = Ln(t.squeeze, 6, 1);
  t.stack = Qn([arr[1], arr[0], arr[3], arr[2]], 1);
  t.boxes = mr(t.stack);
  t.scores = mr(arr[4]);
  t.classes = mr(arr[5]);
  Re2([res2, ...arr]);
  t.nms = await ds.nonMaxSuppressionAsync(t.boxes, t.scores, config3.object.maxDetected, config3.object.iouThreshold, config3.object.minConfidence || 0);
  const nms = await t.nms.data();
  let i10 = 0;
  for (const id2 of Array.from(nms)) {
    const score = Math.trunc(100 * detections[0][id2][4]) / 100;
    const classVal = detections[0][id2][5];
    const label = labels[classVal].label;
    const [x10, y10] = [
      detections[0][id2][0] / inputSize4,
      detections[0][id2][1] / inputSize4
    ];
    const boxRaw = [
      x10,
      y10,
      detections[0][id2][2] / inputSize4 - x10,
      detections[0][id2][3] / inputSize4 - y10
    ];
    const box = [
      Math.trunc(boxRaw[0] * outputShape[0]),
      Math.trunc(boxRaw[1] * outputShape[1]),
      Math.trunc(boxRaw[2] * outputShape[0]),
      Math.trunc(boxRaw[3] * outputShape[1])
    ];
    results.push({ id: i10++, score, class: classVal, label, box, boxRaw });
  }
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  return results;
}
async function predict6(input, config3) {
  const skipTime = (config3.object.skipTime || 0) > now2() - lastTime6;
  const skipFrame = skipped6 < (config3.object.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame && last5.length > 0) {
    skipped6++;
    return last5;
  }
  skipped6 = 0;
  return new Promise(async (resolve) => {
    const outputSize2 = [input.shape[2] || 0, input.shape[1] || 0];
    const resize = ds.resizeBilinear(input, [inputSize4, inputSize4]);
    const objectT = config3.object.enabled ? model6 == null ? void 0 : model6.execute(resize, ["tower_0/detections"]) : null;
    lastTime6 = now2();
    Re2(resize);
    const obj = await process3(objectT, outputSize2, config3);
    last5 = obj;
    resolve(obj);
  });
}
var efficientposecoords_exports = {};
__export(efficientposecoords_exports, {
  connected: () => connected2,
  kpt: () => kpt2
});
var kpt2 = [
  "head",
  "neck",
  "rightShoulder",
  "rightElbow",
  "rightWrist",
  "chest",
  "leftShoulder",
  "leftElbow",
  "leftWrist",
  "bodyCenter",
  "rightHip",
  "rightKnee",
  "rightAnkle",
  "leftHip",
  "leftKnee",
  "leftAnkle"
];
var connected2 = {
  leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
  rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
  torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
  leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
  rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
  head: []
};
var model7;
var lastTime7 = 0;
var cache2 = { id: 0, keypoints: [], box: [0, 0, 0, 0], boxRaw: [0, 0, 0, 0], score: 0, annotations: {} };
var skipped7 = Number.MAX_SAFE_INTEGER;
async function load7(config3) {
  if (env.initial)
    model7 = null;
  if (!model7)
    model7 = await loadModel(config3.body.modelPath);
  else if (config3.debug)
    log("cached model:", model7["modelUrl"]);
  return model7;
}
async function max2d(inputs, minScore) {
  const [width, height] = inputs.shape;
  const reshaped = G2(inputs, [height * width]);
  const max = As(reshaped, 0);
  const newScore = (await max.data())[0];
  Re2([reshaped, max]);
  if (newScore > minScore) {
    const coordinates = Gu(reshaped, 0);
    const mod = dD(coordinates, width);
    const x10 = (await mod.data())[0];
    const div = xe2(coordinates, Ie2(width, "int32"));
    const y10 = (await div.data())[0];
    Re2([mod, div]);
    return [x10, y10, newScore];
  }
  return [0, 0, newScore];
}
async function predict7(image, config3) {
  const skipTime = (config3.body.skipTime || 0) > now2() - lastTime7;
  const skipFrame = skipped7 < (config3.body.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame && Object.keys(cache2.keypoints).length > 0) {
    skipped7++;
    return [cache2];
  }
  skipped7 = 0;
  return new Promise(async (resolve) => {
    var _a2;
    const tensor = j2(() => {
      if (!(model7 == null ? void 0 : model7.inputs[0].shape))
        return null;
      const resize = ds.resizeBilinear(image, [model7.inputs[0].shape[2], model7.inputs[0].shape[1]], false);
      const enhance2 = V2(resize, constants.tf2);
      const norm = ge2(enhance2, constants.tf1);
      return norm;
    });
    let resT;
    if (config3.body.enabled)
      resT = model7 == null ? void 0 : model7.execute(tensor);
    lastTime7 = now2();
    Re2(tensor);
    if (resT) {
      cache2.keypoints.length = 0;
      const squeeze = resT.squeeze();
      Re2(resT);
      const stack = squeeze.unstack(2);
      Re2(squeeze);
      for (let id2 = 0; id2 < stack.length; id2++) {
        const [x102, y102, partScore] = await max2d(stack[id2], config3.body.minConfidence);
        if (partScore > (((_a2 = config3.body) == null ? void 0 : _a2.minConfidence) || 0)) {
          cache2.keypoints.push({
            score: Math.round(100 * partScore) / 100,
            part: kpt2[id2],
            positionRaw: [
              x102 / model7.inputs[0].shape[2],
              y102 / model7.inputs[0].shape[1]
            ],
            position: [
              Math.round(image.shape[2] * x102 / model7.inputs[0].shape[2]),
              Math.round(image.shape[1] * y102 / model7.inputs[0].shape[1])
            ]
          });
        }
      }
      stack.forEach((s10) => Re2(s10));
    }
    cache2.score = cache2.keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
    const x10 = cache2.keypoints.map((a10) => a10.position[0]);
    const y10 = cache2.keypoints.map((a10) => a10.position[1]);
    cache2.box = [
      Math.min(...x10),
      Math.min(...y10),
      Math.max(...x10) - Math.min(...x10),
      Math.max(...y10) - Math.min(...y10)
    ];
    const xRaw = cache2.keypoints.map((a10) => a10.positionRaw[0]);
    const yRaw = cache2.keypoints.map((a10) => a10.positionRaw[1]);
    cache2.boxRaw = [
      Math.min(...xRaw),
      Math.min(...yRaw),
      Math.max(...xRaw) - Math.min(...xRaw),
      Math.max(...yRaw) - Math.min(...yRaw)
    ];
    for (const [name, indexes] of Object.entries(connected2)) {
      const pt2 = [];
      for (let i10 = 0; i10 < indexes.length - 1; i10++) {
        const pt0 = cache2.keypoints.find((kpt4) => kpt4.part === indexes[i10]);
        const pt1 = cache2.keypoints.find((kpt4) => kpt4.part === indexes[i10 + 1]);
        if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
          pt2.push([pt0.position, pt1.position]);
      }
      cache2.annotations[name] = pt2;
    }
    resolve([cache2]);
  });
}
var annotations = ["angry", "disgust", "fear", "happy", "sad", "surprise", "neutral"];
var model8;
var last6 = [];
var lastCount5 = 0;
var lastTime8 = 0;
var skipped8 = Number.MAX_SAFE_INTEGER;
async function load8(config3) {
  var _a2;
  if (env.initial)
    model8 = null;
  if (!model8)
    model8 = await loadModel((_a2 = config3.face.emotion) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model8["modelUrl"]);
  return model8;
}
async function predict8(image, config3, idx, count2) {
  var _a2, _b2;
  if (!model8)
    return [];
  const skipFrame = skipped8 < (((_a2 = config3.face.emotion) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face.emotion) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime8;
  if (config3.skipAllowed && skipTime && skipFrame && lastCount5 === count2 && last6[idx] && last6[idx].length > 0) {
    skipped8++;
    return last6[idx];
  }
  skipped8 = 0;
  return new Promise(async (resolve) => {
    var _a3, _b3;
    const obj = [];
    if ((_a3 = config3.face.emotion) == null ? void 0 : _a3.enabled) {
      const t = {};
      const inputSize10 = (model8 == null ? void 0 : model8.inputs[0].shape) ? model8.inputs[0].shape[2] : 0;
      t.resize = ds.resizeBilinear(image, [inputSize10, inputSize10], false);
      t.channels = V2(t.resize, constants.rgb);
      t.grayscale = ye2(t.channels, 3, true);
      t.grayscaleSub = ge2(t.grayscale, constants.tf05);
      t.grayscaleMul = V2(t.grayscaleSub, constants.tf2);
      t.emotion = model8 == null ? void 0 : model8.execute(t.grayscaleMul);
      lastTime8 = now2();
      const data = await t.emotion.data();
      for (let i10 = 0; i10 < data.length; i10++) {
        if (data[i10] > (((_b3 = config3.face.emotion) == null ? void 0 : _b3.minConfidence) || 0))
          obj.push({ score: Math.min(0.99, Math.trunc(100 * data[i10]) / 100), emotion: annotations[i10] });
      }
      obj.sort((a10, b10) => b10.score - a10.score);
      Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    }
    last6[idx] = obj;
    lastCount5 = count2;
    resolve(obj);
  });
}
var model9;
var last7 = [];
var lastCount6 = 0;
var lastTime9 = 0;
var skipped9 = Number.MAX_SAFE_INTEGER;
async function load9(config3) {
  if (env.initial)
    model9 = null;
  if (!model9)
    model9 = await loadModel(config3.face["mobilefacenet"].modelPath);
  else if (config3.debug)
    log("cached model:", model9["modelUrl"]);
  return model9;
}
async function predict9(input, config3, idx, count2) {
  var _a2, _b2;
  if (!model9)
    return [];
  const skipFrame = skipped9 < (((_a2 = config3.face["embedding"]) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face["embedding"]) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime9;
  if (config3.skipAllowed && skipTime && skipFrame && lastCount6 === count2 && last7[idx]) {
    skipped9++;
    return last7[idx];
  }
  return new Promise(async (resolve) => {
    var _a3;
    let data = [];
    if (((_a3 = config3.face["embedding"]) == null ? void 0 : _a3.enabled) && (model9 == null ? void 0 : model9.inputs[0].shape)) {
      const t = {};
      t.crop = ds.resizeBilinear(input, [model9.inputs[0].shape[2], model9.inputs[0].shape[1]], false);
      t.data = model9 == null ? void 0 : model9.execute(t.crop);
      const output = await t.data.data();
      data = Array.from(output);
    }
    last7[idx] = data;
    lastCount6 = count2;
    lastTime9 = now2();
    resolve(data);
  });
}
var model10;
var inputSize5 = 0;
var irisEnlarge = 2.3;
var leftOutline = meshAnnotations["leftEyeLower0"];
var rightOutline = meshAnnotations["rightEyeLower0"];
var eyeLandmarks = {
  leftBounds: [leftOutline[0], leftOutline[leftOutline.length - 1]],
  rightBounds: [rightOutline[0], rightOutline[rightOutline.length - 1]]
};
var irisLandmarks = {
  upperCenter: 3,
  lowerCenter: 4,
  index: 71,
  numCoordinates: 76
};
async function load10(config3) {
  var _a2;
  if (env.initial)
    model10 = null;
  if (!model10)
    model10 = await loadModel((_a2 = config3.face.iris) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model10["modelUrl"]);
  inputSize5 = model10.inputs[0].shape ? model10.inputs[0].shape[2] : 0;
  if (inputSize5 === -1)
    inputSize5 = 64;
  return model10;
}
function replaceRawCoordinates(rawCoords, newCoords, prefix, keys) {
  for (let i10 = 0; i10 < MESH_TO_IRIS_INDICES_MAP.length; i10++) {
    const { key, indices } = MESH_TO_IRIS_INDICES_MAP[i10];
    const originalIndices = meshAnnotations[`${prefix}${key}`];
    if (!keys || keys.includes(key)) {
      for (let j10 = 0; j10 < indices.length; j10++) {
        const index2 = indices[j10];
        rawCoords[originalIndices[j10]] = [
          newCoords[index2][0],
          newCoords[index2][1],
          (newCoords[index2][2] + rawCoords[originalIndices[j10]][2]) / 2
        ];
      }
    }
  }
}
var getLeftToRightEyeDepthDifference = (rawCoords) => {
  const leftEyeZ = rawCoords[eyeLandmarks.leftBounds[0]][2];
  const rightEyeZ = rawCoords[eyeLandmarks.rightBounds[0]][2];
  return leftEyeZ - rightEyeZ;
};
var getEyeBox = (rawCoords, face4, eyeInnerCornerIndex, eyeOuterCornerIndex, meshSize, flip = false) => {
  const box = squarifyBox(enlargeBox(calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), irisEnlarge));
  const boxSize = getBoxSize(box);
  let crop = ds.cropAndResize(face4, [[
    box.startPoint[1] / meshSize,
    box.startPoint[0] / meshSize,
    box.endPoint[1] / meshSize,
    box.endPoint[0] / meshSize
  ]], [0], [inputSize5, inputSize5]);
  if (flip && env.kernels.includes("flipleftright")) {
    const flipped = ds.flipLeftRight(crop);
    Re2(crop);
    crop = flipped;
  }
  return { box, boxSize, crop };
};
var getEyeCoords = (eyeData, eyeBox, eyeBoxSize, flip = false) => {
  const eyeRawCoords = [];
  for (let i10 = 0; i10 < irisLandmarks.numCoordinates; i10++) {
    const x10 = eyeData[i10 * 3];
    const y10 = eyeData[i10 * 3 + 1];
    const z10 = eyeData[i10 * 3 + 2];
    eyeRawCoords.push([
      (flip ? 1 - x10 / inputSize5 : x10 / inputSize5) * eyeBoxSize[0] + eyeBox.startPoint[0],
      y10 / inputSize5 * eyeBoxSize[1] + eyeBox.startPoint[1],
      z10
    ]);
  }
  return { rawCoords: eyeRawCoords, iris: eyeRawCoords.slice(irisLandmarks.index) };
};
var getAdjustedIrisCoords = (rawCoords, irisCoords, direction) => {
  const upperCenterZ = rawCoords[meshAnnotations[`${direction}EyeUpper0`][irisLandmarks.upperCenter]][2];
  const lowerCenterZ = rawCoords[meshAnnotations[`${direction}EyeLower0`][irisLandmarks.lowerCenter]][2];
  const averageZ = (upperCenterZ + lowerCenterZ) / 2;
  return irisCoords.map((coord, i10) => {
    let z10 = averageZ;
    if (i10 === 2) {
      z10 = upperCenterZ;
    } else if (i10 === 4) {
      z10 = lowerCenterZ;
    }
    return [coord[0], coord[1], z10];
  });
};
async function augmentIris(rawCoords, face4, config3, meshSize) {
  if (!model10) {
    if (config3.debug)
      log("face mesh iris detection requested, but model is not loaded");
    return rawCoords;
  }
  const { box: leftEyeBox, boxSize: leftEyeBoxSize, crop: leftEyeCrop } = getEyeBox(rawCoords, face4, eyeLandmarks.leftBounds[0], eyeLandmarks.leftBounds[1], meshSize, true);
  const { box: rightEyeBox, boxSize: rightEyeBoxSize, crop: rightEyeCrop } = getEyeBox(rawCoords, face4, eyeLandmarks.rightBounds[0], eyeLandmarks.rightBounds[1], meshSize, true);
  const combined = Ft([leftEyeCrop, rightEyeCrop]);
  Re2(leftEyeCrop);
  Re2(rightEyeCrop);
  const eyePredictions = model10.execute(combined);
  Re2(combined);
  const eyePredictionsData = await eyePredictions.data();
  Re2(eyePredictions);
  const leftEyeData = eyePredictionsData.slice(0, irisLandmarks.numCoordinates * 3);
  const { rawCoords: leftEyeRawCoords, iris: leftIrisRawCoords } = getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true);
  const rightEyeData = eyePredictionsData.slice(irisLandmarks.numCoordinates * 3);
  const { rawCoords: rightEyeRawCoords, iris: rightIrisRawCoords } = getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize);
  const leftToRightEyeDepthDifference = getLeftToRightEyeDepthDifference(rawCoords);
  if (Math.abs(leftToRightEyeDepthDifference) < 30) {
    replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left", null);
    replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right", null);
  } else if (leftToRightEyeDepthDifference < 1) {
    replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left", ["EyeUpper0", "EyeLower0"]);
  } else {
    replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right", ["EyeUpper0", "EyeLower0"]);
  }
  const adjustedLeftIrisCoords = getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, "left");
  const adjustedRightIrisCoords = getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, "right");
  const newCoords = rawCoords.concat(adjustedLeftIrisCoords).concat(adjustedRightIrisCoords);
  return newCoords;
}
var cache3 = {
  boxes: [],
  skipped: Number.MAX_SAFE_INTEGER,
  timestamp: 0
};
var model11 = null;
var inputSize6 = 0;
async function predict10(input, config3) {
  var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i;
  const skipTime = (((_a2 = config3.face.detector) == null ? void 0 : _a2.skipTime) || 0) > now2() - cache3.timestamp;
  const skipFrame = cache3.skipped < (((_b2 = config3.face.detector) == null ? void 0 : _b2.skipFrames) || 0);
  if (!config3.skipAllowed || !skipTime || !skipFrame || cache3.boxes.length === 0) {
    cache3.boxes = await getBoxes(input, config3);
    cache3.timestamp = now2();
    cache3.skipped = 0;
  } else {
    cache3.skipped++;
  }
  const faces = [];
  const newCache = [];
  let id2 = 0;
  for (let i10 = 0; i10 < cache3.boxes.length; i10++) {
    const box = cache3.boxes[i10];
    let angle2 = 0;
    let rotationMatrix;
    const face4 = {
      id: id2++,
      mesh: [],
      meshRaw: [],
      box: [0, 0, 0, 0],
      boxRaw: [0, 0, 0, 0],
      score: 0,
      boxScore: 0,
      faceScore: 0,
      annotations: {}
    };
    [angle2, rotationMatrix, face4.tensor] = correctFaceRotation((_c = config3.face.detector) == null ? void 0 : _c.rotation, box, input, ((_d2 = config3.face.mesh) == null ? void 0 : _d2.enabled) ? inputSize6 : size());
    if ((_e22 = config3 == null ? void 0 : config3.filter) == null ? void 0 : _e22.equalization) {
      const equilized = await histogramEqualization(face4.tensor);
      Re2(face4.tensor);
      face4.tensor = equilized;
    }
    face4.boxScore = Math.round(100 * box.confidence) / 100;
    if (!((_f = config3.face.mesh) == null ? void 0 : _f.enabled)) {
      face4.box = clampBox(box, input);
      face4.boxRaw = getRawBox(box, input);
      face4.score = face4.boxScore;
      face4.mesh = box.landmarks.map((pt2) => [
        (box.startPoint[0] + box.endPoint[0]) / 2 + (box.endPoint[0] + box.startPoint[0]) * pt2[0] / size(),
        (box.startPoint[1] + box.endPoint[1]) / 2 + (box.endPoint[1] + box.startPoint[1]) * pt2[1] / size()
      ]);
      face4.meshRaw = face4.mesh.map((pt2) => [pt2[0] / (input.shape[2] || 0), pt2[1] / (input.shape[1] || 0), (pt2[2] || 0) / inputSize6]);
      for (const key of Object.keys(blazeFaceLandmarks))
        face4.annotations[key] = [face4.mesh[blazeFaceLandmarks[key]]];
    } else if (!model11) {
      if (config3.debug)
        log("face mesh detection requested, but model is not loaded");
    } else {
      const [contours, confidence, contourCoords] = model11.execute(face4.tensor);
      const faceConfidence = await confidence.data();
      face4.faceScore = Math.round(100 * faceConfidence[0]) / 100;
      const coordsReshaped = G2(contourCoords, [-1, 3]);
      let rawCoords = await coordsReshaped.array();
      Re2([contourCoords, coordsReshaped, confidence, contours]);
      if (face4.faceScore < (((_g2 = config3.face.detector) == null ? void 0 : _g2.minConfidence) || 1)) {
        box.confidence = face4.faceScore;
      } else {
        if ((_h = config3.face.iris) == null ? void 0 : _h.enabled)
          rawCoords = await augmentIris(rawCoords, face4.tensor, config3, inputSize6);
        face4.mesh = transformRawCoords(rawCoords, box, angle2, rotationMatrix, inputSize6);
        face4.meshRaw = face4.mesh.map((pt2) => [pt2[0] / (input.shape[2] || 0), pt2[1] / (input.shape[1] || 0), (pt2[2] || 0) / inputSize6]);
        for (const key of Object.keys(meshAnnotations))
          face4.annotations[key] = meshAnnotations[key].map((index2) => face4.mesh[index2]);
        face4.score = face4.faceScore;
        const calculatedBox = { ...calculateFaceBox(face4.mesh, box), confidence: box.confidence, landmarks: box.landmarks };
        face4.box = clampBox(calculatedBox, input);
        face4.boxRaw = getRawBox(calculatedBox, input);
        newCache.push(calculatedBox);
      }
    }
    if (face4.score > (((_i = config3.face.detector) == null ? void 0 : _i.minConfidence) || 1))
      faces.push(face4);
    else
      Re2(face4.tensor);
  }
  cache3.boxes = newCache;
  return faces;
}
async function load11(config3) {
  var _a2;
  if (env.initial)
    model11 = null;
  if (!model11)
    model11 = await loadModel((_a2 = config3.face.mesh) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model11["modelUrl"]);
  inputSize6 = model11.inputs[0].shape ? model11.inputs[0].shape[2] : 0;
  return model11;
}
var triangulation = TRI468;
var uvmap = UV468;
var model12;
var last8 = [];
var lastTime10 = 0;
var lastCount7 = 0;
var skipped10 = Number.MAX_SAFE_INTEGER;
async function load12(config3) {
  var _a2;
  if (env.initial)
    model12 = null;
  if (!model12)
    model12 = await loadModel((_a2 = config3.face.description) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model12["modelUrl"]);
  return model12;
}
function enhance(input) {
  const tensor = input.image || input.tensor || input;
  if (!(model12 == null ? void 0 : model12.inputs[0].shape))
    return tensor;
  const crop = ds.resizeBilinear(tensor, [model12.inputs[0].shape[2], model12.inputs[0].shape[1]], false);
  const norm = V2(crop, constants.tf255);
  Re2(crop);
  return norm;
}
async function predict11(image, config3, idx, count2) {
  var _a2, _b2, _c, _d2;
  if (!model12)
    return { age: 0, gender: "unknown", genderScore: 0, descriptor: [] };
  const skipFrame = skipped10 < (((_a2 = config3.face.description) == null ? void 0 : _a2.skipFrames) || 0);
  const skipTime = (((_b2 = config3.face.description) == null ? void 0 : _b2.skipTime) || 0) > now2() - lastTime10;
  if (config3.skipAllowed && skipFrame && skipTime && lastCount7 === count2 && ((_c = last8[idx]) == null ? void 0 : _c.age) && ((_d2 = last8[idx]) == null ? void 0 : _d2.age) > 0) {
    skipped10++;
    return last8[idx];
  }
  skipped10 = 0;
  return new Promise(async (resolve) => {
    var _a3, _b3;
    const obj = {
      age: 0,
      gender: "unknown",
      genderScore: 0,
      descriptor: []
    };
    if ((_a3 = config3.face.description) == null ? void 0 : _a3.enabled) {
      const enhanced = enhance(image);
      const resT = model12 == null ? void 0 : model12.execute(enhanced);
      lastTime10 = now2();
      Re2(enhanced);
      const genderT = await resT.find((t) => t.shape[1] === 1);
      const gender = await genderT.data();
      const confidence = Math.trunc(200 * Math.abs(gender[0] - 0.5)) / 100;
      if (confidence > (((_b3 = config3.face.description) == null ? void 0 : _b3.minConfidence) || 0)) {
        obj.gender = gender[0] <= 0.5 ? "female" : "male";
        obj.genderScore = Math.min(0.99, confidence);
      }
      const argmax = Gu(resT.find((t) => t.shape[1] === 100), 1);
      const age = (await argmax.data())[0];
      Re2(argmax);
      const ageT = resT.find((t) => t.shape[1] === 100);
      const all2 = await ageT.data();
      obj.age = Math.round(all2[age - 1] > all2[age + 1] ? 10 * age - 100 * all2[age - 1] : 10 * age + 100 * all2[age + 1]) / 10;
      const desc = resT.find((t) => t.shape[1] === 1024);
      const descriptor = desc ? await desc.data() : [];
      obj.descriptor = Array.from(descriptor);
      resT.forEach((t) => Re2(t));
    }
    last8[idx] = obj;
    lastCount7 = count2;
    resolve(obj);
  });
}
function getBoxSize2(box) {
  return [
    Math.abs(box.endPoint[0] - box.startPoint[0]),
    Math.abs(box.endPoint[1] - box.startPoint[1])
  ];
}
function getBoxCenter2(box) {
  return [
    box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2,
    box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2
  ];
}
function cutBoxFromImageAndResize(box, image, cropSize) {
  const h10 = image.shape[1];
  const w10 = image.shape[2];
  const boxes = [[
    box.startPoint[1] / h10,
    box.startPoint[0] / w10,
    box.endPoint[1] / h10,
    box.endPoint[0] / w10
  ]];
  return ds.cropAndResize(image, boxes, [0], cropSize);
}
function scaleBoxCoordinates2(box, factor) {
  const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
  const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
  const palmLandmarks = box.palmLandmarks.map((coord) => {
    const scaledCoord = [coord[0] * factor[0], coord[1] * factor[1]];
    return scaledCoord;
  });
  return { startPoint, endPoint, palmLandmarks, confidence: box.confidence };
}
function enlargeBox2(box, factor = 1.5) {
  const center = getBoxCenter2(box);
  const size2 = getBoxSize2(box);
  const newHalfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
  const startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];
  const endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];
  return { startPoint, endPoint, palmLandmarks: box.palmLandmarks };
}
function squarifyBox2(box) {
  const centers = getBoxCenter2(box);
  const size2 = getBoxSize2(box);
  const maxEdge = Math.max(...size2);
  const halfSize = maxEdge / 2;
  const startPoint = [centers[0] - halfSize, centers[1] - halfSize];
  const endPoint = [centers[0] + halfSize, centers[1] + halfSize];
  return { startPoint, endPoint, palmLandmarks: box.palmLandmarks };
}
function normalizeRadians2(angle2) {
  return angle2 - 2 * Math.PI * Math.floor((angle2 + Math.PI) / (2 * Math.PI));
}
function computeRotation2(point1, point2) {
  const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);
  return normalizeRadians2(radians);
}
var buildTranslationMatrix2 = (x10, y10) => [[1, 0, x10], [0, 1, y10], [0, 0, 1]];
function dot2(v12, v22) {
  let product = 0;
  for (let i10 = 0; i10 < v12.length; i10++) {
    product += v12[i10] * v22[i10];
  }
  return product;
}
function getColumnFrom2DArr2(arr, columnIndex) {
  const column = [];
  for (let i10 = 0; i10 < arr.length; i10++) {
    column.push(arr[i10][columnIndex]);
  }
  return column;
}
function multiplyTransformMatrices2(mat1, mat2) {
  const product = [];
  const size2 = mat1.length;
  for (let row = 0; row < size2; row++) {
    product.push([]);
    for (let col = 0; col < size2; col++) {
      product[row].push(dot2(mat1[row], getColumnFrom2DArr2(mat2, col)));
    }
  }
  return product;
}
function buildRotationMatrix2(rotation, center) {
  const cosA = Math.cos(rotation);
  const sinA = Math.sin(rotation);
  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
  const translationMatrix = buildTranslationMatrix2(center[0], center[1]);
  const translationTimesRotation = multiplyTransformMatrices2(translationMatrix, rotationMatrix);
  const negativeTranslationMatrix = buildTranslationMatrix2(-center[0], -center[1]);
  return multiplyTransformMatrices2(translationTimesRotation, negativeTranslationMatrix);
}
function invertTransformMatrix2(matrix) {
  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
  const translationComponent = [matrix[0][2], matrix[1][2]];
  const invertedTranslation = [
    -dot2(rotationComponent[0], translationComponent),
    -dot2(rotationComponent[1], translationComponent)
  ];
  return [
    rotationComponent[0].concat(invertedTranslation[0]),
    rotationComponent[1].concat(invertedTranslation[1]),
    [0, 0, 1]
  ];
}
function rotatePoint2(homogeneousCoordinate, rotationMatrix) {
  return [
    dot2(homogeneousCoordinate, rotationMatrix[0]),
    dot2(homogeneousCoordinate, rotationMatrix[1])
  ];
}
var anchors2 = [
  { x: 0.015625, y: 0.015625 },
  { x: 0.015625, y: 0.015625 },
  { x: 0.046875, y: 0.015625 },
  { x: 0.046875, y: 0.015625 },
  { x: 0.078125, y: 0.015625 },
  { x: 0.078125, y: 0.015625 },
  { x: 0.109375, y: 0.015625 },
  { x: 0.109375, y: 0.015625 },
  { x: 0.140625, y: 0.015625 },
  { x: 0.140625, y: 0.015625 },
  { x: 0.171875, y: 0.015625 },
  { x: 0.171875, y: 0.015625 },
  { x: 0.203125, y: 0.015625 },
  { x: 0.203125, y: 0.015625 },
  { x: 0.234375, y: 0.015625 },
  { x: 0.234375, y: 0.015625 },
  { x: 0.265625, y: 0.015625 },
  { x: 0.265625, y: 0.015625 },
  { x: 0.296875, y: 0.015625 },
  { x: 0.296875, y: 0.015625 },
  { x: 0.328125, y: 0.015625 },
  { x: 0.328125, y: 0.015625 },
  { x: 0.359375, y: 0.015625 },
  { x: 0.359375, y: 0.015625 },
  { x: 0.390625, y: 0.015625 },
  { x: 0.390625, y: 0.015625 },
  { x: 0.421875, y: 0.015625 },
  { x: 0.421875, y: 0.015625 },
  { x: 0.453125, y: 0.015625 },
  { x: 0.453125, y: 0.015625 },
  { x: 0.484375, y: 0.015625 },
  { x: 0.484375, y: 0.015625 },
  { x: 0.515625, y: 0.015625 },
  { x: 0.515625, y: 0.015625 },
  { x: 0.546875, y: 0.015625 },
  { x: 0.546875, y: 0.015625 },
  { x: 0.578125, y: 0.015625 },
  { x: 0.578125, y: 0.015625 },
  { x: 0.609375, y: 0.015625 },
  { x: 0.609375, y: 0.015625 },
  { x: 0.640625, y: 0.015625 },
  { x: 0.640625, y: 0.015625 },
  { x: 0.671875, y: 0.015625 },
  { x: 0.671875, y: 0.015625 },
  { x: 0.703125, y: 0.015625 },
  { x: 0.703125, y: 0.015625 },
  { x: 0.734375, y: 0.015625 },
  { x: 0.734375, y: 0.015625 },
  { x: 0.765625, y: 0.015625 },
  { x: 0.765625, y: 0.015625 },
  { x: 0.796875, y: 0.015625 },
  { x: 0.796875, y: 0.015625 },
  { x: 0.828125, y: 0.015625 },
  { x: 0.828125, y: 0.015625 },
  { x: 0.859375, y: 0.015625 },
  { x: 0.859375, y: 0.015625 },
  { x: 0.890625, y: 0.015625 },
  { x: 0.890625, y: 0.015625 },
  { x: 0.921875, y: 0.015625 },
  { x: 0.921875, y: 0.015625 },
  { x: 0.953125, y: 0.015625 },
  { x: 0.953125, y: 0.015625 },
  { x: 0.984375, y: 0.015625 },
  { x: 0.984375, y: 0.015625 },
  { x: 0.015625, y: 0.046875 },
  { x: 0.015625, y: 0.046875 },
  { x: 0.046875, y: 0.046875 },
  { x: 0.046875, y: 0.046875 },
  { x: 0.078125, y: 0.046875 },
  { x: 0.078125, y: 0.046875 },
  { x: 0.109375, y: 0.046875 },
  { x: 0.109375, y: 0.046875 },
  { x: 0.140625, y: 0.046875 },
  { x: 0.140625, y: 0.046875 },
  { x: 0.171875, y: 0.046875 },
  { x: 0.171875, y: 0.046875 },
  { x: 0.203125, y: 0.046875 },
  { x: 0.203125, y: 0.046875 },
  { x: 0.234375, y: 0.046875 },
  { x: 0.234375, y: 0.046875 },
  { x: 0.265625, y: 0.046875 },
  { x: 0.265625, y: 0.046875 },
  { x: 0.296875, y: 0.046875 },
  { x: 0.296875, y: 0.046875 },
  { x: 0.328125, y: 0.046875 },
  { x: 0.328125, y: 0.046875 },
  { x: 0.359375, y: 0.046875 },
  { x: 0.359375, y: 0.046875 },
  { x: 0.390625, y: 0.046875 },
  { x: 0.390625, y: 0.046875 },
  { x: 0.421875, y: 0.046875 },
  { x: 0.421875, y: 0.046875 },
  { x: 0.453125, y: 0.046875 },
  { x: 0.453125, y: 0.046875 },
  { x: 0.484375, y: 0.046875 },
  { x: 0.484375, y: 0.046875 },
  { x: 0.515625, y: 0.046875 },
  { x: 0.515625, y: 0.046875 },
  { x: 0.546875, y: 0.046875 },
  { x: 0.546875, y: 0.046875 },
  { x: 0.578125, y: 0.046875 },
  { x: 0.578125, y: 0.046875 },
  { x: 0.609375, y: 0.046875 },
  { x: 0.609375, y: 0.046875 },
  { x: 0.640625, y: 0.046875 },
  { x: 0.640625, y: 0.046875 },
  { x: 0.671875, y: 0.046875 },
  { x: 0.671875, y: 0.046875 },
  { x: 0.703125, y: 0.046875 },
  { x: 0.703125, y: 0.046875 },
  { x: 0.734375, y: 0.046875 },
  { x: 0.734375, y: 0.046875 },
  { x: 0.765625, y: 0.046875 },
  { x: 0.765625, y: 0.046875 },
  { x: 0.796875, y: 0.046875 },
  { x: 0.796875, y: 0.046875 },
  { x: 0.828125, y: 0.046875 },
  { x: 0.828125, y: 0.046875 },
  { x: 0.859375, y: 0.046875 },
  { x: 0.859375, y: 0.046875 },
  { x: 0.890625, y: 0.046875 },
  { x: 0.890625, y: 0.046875 },
  { x: 0.921875, y: 0.046875 },
  { x: 0.921875, y: 0.046875 },
  { x: 0.953125, y: 0.046875 },
  { x: 0.953125, y: 0.046875 },
  { x: 0.984375, y: 0.046875 },
  { x: 0.984375, y: 0.046875 },
  { x: 0.015625, y: 0.078125 },
  { x: 0.015625, y: 0.078125 },
  { x: 0.046875, y: 0.078125 },
  { x: 0.046875, y: 0.078125 },
  { x: 0.078125, y: 0.078125 },
  { x: 0.078125, y: 0.078125 },
  { x: 0.109375, y: 0.078125 },
  { x: 0.109375, y: 0.078125 },
  { x: 0.140625, y: 0.078125 },
  { x: 0.140625, y: 0.078125 },
  { x: 0.171875, y: 0.078125 },
  { x: 0.171875, y: 0.078125 },
  { x: 0.203125, y: 0.078125 },
  { x: 0.203125, y: 0.078125 },
  { x: 0.234375, y: 0.078125 },
  { x: 0.234375, y: 0.078125 },
  { x: 0.265625, y: 0.078125 },
  { x: 0.265625, y: 0.078125 },
  { x: 0.296875, y: 0.078125 },
  { x: 0.296875, y: 0.078125 },
  { x: 0.328125, y: 0.078125 },
  { x: 0.328125, y: 0.078125 },
  { x: 0.359375, y: 0.078125 },
  { x: 0.359375, y: 0.078125 },
  { x: 0.390625, y: 0.078125 },
  { x: 0.390625, y: 0.078125 },
  { x: 0.421875, y: 0.078125 },
  { x: 0.421875, y: 0.078125 },
  { x: 0.453125, y: 0.078125 },
  { x: 0.453125, y: 0.078125 },
  { x: 0.484375, y: 0.078125 },
  { x: 0.484375, y: 0.078125 },
  { x: 0.515625, y: 0.078125 },
  { x: 0.515625, y: 0.078125 },
  { x: 0.546875, y: 0.078125 },
  { x: 0.546875, y: 0.078125 },
  { x: 0.578125, y: 0.078125 },
  { x: 0.578125, y: 0.078125 },
  { x: 0.609375, y: 0.078125 },
  { x: 0.609375, y: 0.078125 },
  { x: 0.640625, y: 0.078125 },
  { x: 0.640625, y: 0.078125 },
  { x: 0.671875, y: 0.078125 },
  { x: 0.671875, y: 0.078125 },
  { x: 0.703125, y: 0.078125 },
  { x: 0.703125, y: 0.078125 },
  { x: 0.734375, y: 0.078125 },
  { x: 0.734375, y: 0.078125 },
  { x: 0.765625, y: 0.078125 },
  { x: 0.765625, y: 0.078125 },
  { x: 0.796875, y: 0.078125 },
  { x: 0.796875, y: 0.078125 },
  { x: 0.828125, y: 0.078125 },
  { x: 0.828125, y: 0.078125 },
  { x: 0.859375, y: 0.078125 },
  { x: 0.859375, y: 0.078125 },
  { x: 0.890625, y: 0.078125 },
  { x: 0.890625, y: 0.078125 },
  { x: 0.921875, y: 0.078125 },
  { x: 0.921875, y: 0.078125 },
  { x: 0.953125, y: 0.078125 },
  { x: 0.953125, y: 0.078125 },
  { x: 0.984375, y: 0.078125 },
  { x: 0.984375, y: 0.078125 },
  { x: 0.015625, y: 0.109375 },
  { x: 0.015625, y: 0.109375 },
  { x: 0.046875, y: 0.109375 },
  { x: 0.046875, y: 0.109375 },
  { x: 0.078125, y: 0.109375 },
  { x: 0.078125, y: 0.109375 },
  { x: 0.109375, y: 0.109375 },
  { x: 0.109375, y: 0.109375 },
  { x: 0.140625, y: 0.109375 },
  { x: 0.140625, y: 0.109375 },
  { x: 0.171875, y: 0.109375 },
  { x: 0.171875, y: 0.109375 },
  { x: 0.203125, y: 0.109375 },
  { x: 0.203125, y: 0.109375 },
  { x: 0.234375, y: 0.109375 },
  { x: 0.234375, y: 0.109375 },
  { x: 0.265625, y: 0.109375 },
  { x: 0.265625, y: 0.109375 },
  { x: 0.296875, y: 0.109375 },
  { x: 0.296875, y: 0.109375 },
  { x: 0.328125, y: 0.109375 },
  { x: 0.328125, y: 0.109375 },
  { x: 0.359375, y: 0.109375 },
  { x: 0.359375, y: 0.109375 },
  { x: 0.390625, y: 0.109375 },
  { x: 0.390625, y: 0.109375 },
  { x: 0.421875, y: 0.109375 },
  { x: 0.421875, y: 0.109375 },
  { x: 0.453125, y: 0.109375 },
  { x: 0.453125, y: 0.109375 },
  { x: 0.484375, y: 0.109375 },
  { x: 0.484375, y: 0.109375 },
  { x: 0.515625, y: 0.109375 },
  { x: 0.515625, y: 0.109375 },
  { x: 0.546875, y: 0.109375 },
  { x: 0.546875, y: 0.109375 },
  { x: 0.578125, y: 0.109375 },
  { x: 0.578125, y: 0.109375 },
  { x: 0.609375, y: 0.109375 },
  { x: 0.609375, y: 0.109375 },
  { x: 0.640625, y: 0.109375 },
  { x: 0.640625, y: 0.109375 },
  { x: 0.671875, y: 0.109375 },
  { x: 0.671875, y: 0.109375 },
  { x: 0.703125, y: 0.109375 },
  { x: 0.703125, y: 0.109375 },
  { x: 0.734375, y: 0.109375 },
  { x: 0.734375, y: 0.109375 },
  { x: 0.765625, y: 0.109375 },
  { x: 0.765625, y: 0.109375 },
  { x: 0.796875, y: 0.109375 },
  { x: 0.796875, y: 0.109375 },
  { x: 0.828125, y: 0.109375 },
  { x: 0.828125, y: 0.109375 },
  { x: 0.859375, y: 0.109375 },
  { x: 0.859375, y: 0.109375 },
  { x: 0.890625, y: 0.109375 },
  { x: 0.890625, y: 0.109375 },
  { x: 0.921875, y: 0.109375 },
  { x: 0.921875, y: 0.109375 },
  { x: 0.953125, y: 0.109375 },
  { x: 0.953125, y: 0.109375 },
  { x: 0.984375, y: 0.109375 },
  { x: 0.984375, y: 0.109375 },
  { x: 0.015625, y: 0.140625 },
  { x: 0.015625, y: 0.140625 },
  { x: 0.046875, y: 0.140625 },
  { x: 0.046875, y: 0.140625 },
  { x: 0.078125, y: 0.140625 },
  { x: 0.078125, y: 0.140625 },
  { x: 0.109375, y: 0.140625 },
  { x: 0.109375, y: 0.140625 },
  { x: 0.140625, y: 0.140625 },
  { x: 0.140625, y: 0.140625 },
  { x: 0.171875, y: 0.140625 },
  { x: 0.171875, y: 0.140625 },
  { x: 0.203125, y: 0.140625 },
  { x: 0.203125, y: 0.140625 },
  { x: 0.234375, y: 0.140625 },
  { x: 0.234375, y: 0.140625 },
  { x: 0.265625, y: 0.140625 },
  { x: 0.265625, y: 0.140625 },
  { x: 0.296875, y: 0.140625 },
  { x: 0.296875, y: 0.140625 },
  { x: 0.328125, y: 0.140625 },
  { x: 0.328125, y: 0.140625 },
  { x: 0.359375, y: 0.140625 },
  { x: 0.359375, y: 0.140625 },
  { x: 0.390625, y: 0.140625 },
  { x: 0.390625, y: 0.140625 },
  { x: 0.421875, y: 0.140625 },
  { x: 0.421875, y: 0.140625 },
  { x: 0.453125, y: 0.140625 },
  { x: 0.453125, y: 0.140625 },
  { x: 0.484375, y: 0.140625 },
  { x: 0.484375, y: 0.140625 },
  { x: 0.515625, y: 0.140625 },
  { x: 0.515625, y: 0.140625 },
  { x: 0.546875, y: 0.140625 },
  { x: 0.546875, y: 0.140625 },
  { x: 0.578125, y: 0.140625 },
  { x: 0.578125, y: 0.140625 },
  { x: 0.609375, y: 0.140625 },
  { x: 0.609375, y: 0.140625 },
  { x: 0.640625, y: 0.140625 },
  { x: 0.640625, y: 0.140625 },
  { x: 0.671875, y: 0.140625 },
  { x: 0.671875, y: 0.140625 },
  { x: 0.703125, y: 0.140625 },
  { x: 0.703125, y: 0.140625 },
  { x: 0.734375, y: 0.140625 },
  { x: 0.734375, y: 0.140625 },
  { x: 0.765625, y: 0.140625 },
  { x: 0.765625, y: 0.140625 },
  { x: 0.796875, y: 0.140625 },
  { x: 0.796875, y: 0.140625 },
  { x: 0.828125, y: 0.140625 },
  { x: 0.828125, y: 0.140625 },
  { x: 0.859375, y: 0.140625 },
  { x: 0.859375, y: 0.140625 },
  { x: 0.890625, y: 0.140625 },
  { x: 0.890625, y: 0.140625 },
  { x: 0.921875, y: 0.140625 },
  { x: 0.921875, y: 0.140625 },
  { x: 0.953125, y: 0.140625 },
  { x: 0.953125, y: 0.140625 },
  { x: 0.984375, y: 0.140625 },
  { x: 0.984375, y: 0.140625 },
  { x: 0.015625, y: 0.171875 },
  { x: 0.015625, y: 0.171875 },
  { x: 0.046875, y: 0.171875 },
  { x: 0.046875, y: 0.171875 },
  { x: 0.078125, y: 0.171875 },
  { x: 0.078125, y: 0.171875 },
  { x: 0.109375, y: 0.171875 },
  { x: 0.109375, y: 0.171875 },
  { x: 0.140625, y: 0.171875 },
  { x: 0.140625, y: 0.171875 },
  { x: 0.171875, y: 0.171875 },
  { x: 0.171875, y: 0.171875 },
  { x: 0.203125, y: 0.171875 },
  { x: 0.203125, y: 0.171875 },
  { x: 0.234375, y: 0.171875 },
  { x: 0.234375, y: 0.171875 },
  { x: 0.265625, y: 0.171875 },
  { x: 0.265625, y: 0.171875 },
  { x: 0.296875, y: 0.171875 },
  { x: 0.296875, y: 0.171875 },
  { x: 0.328125, y: 0.171875 },
  { x: 0.328125, y: 0.171875 },
  { x: 0.359375, y: 0.171875 },
  { x: 0.359375, y: 0.171875 },
  { x: 0.390625, y: 0.171875 },
  { x: 0.390625, y: 0.171875 },
  { x: 0.421875, y: 0.171875 },
  { x: 0.421875, y: 0.171875 },
  { x: 0.453125, y: 0.171875 },
  { x: 0.453125, y: 0.171875 },
  { x: 0.484375, y: 0.171875 },
  { x: 0.484375, y: 0.171875 },
  { x: 0.515625, y: 0.171875 },
  { x: 0.515625, y: 0.171875 },
  { x: 0.546875, y: 0.171875 },
  { x: 0.546875, y: 0.171875 },
  { x: 0.578125, y: 0.171875 },
  { x: 0.578125, y: 0.171875 },
  { x: 0.609375, y: 0.171875 },
  { x: 0.609375, y: 0.171875 },
  { x: 0.640625, y: 0.171875 },
  { x: 0.640625, y: 0.171875 },
  { x: 0.671875, y: 0.171875 },
  { x: 0.671875, y: 0.171875 },
  { x: 0.703125, y: 0.171875 },
  { x: 0.703125, y: 0.171875 },
  { x: 0.734375, y: 0.171875 },
  { x: 0.734375, y: 0.171875 },
  { x: 0.765625, y: 0.171875 },
  { x: 0.765625, y: 0.171875 },
  { x: 0.796875, y: 0.171875 },
  { x: 0.796875, y: 0.171875 },
  { x: 0.828125, y: 0.171875 },
  { x: 0.828125, y: 0.171875 },
  { x: 0.859375, y: 0.171875 },
  { x: 0.859375, y: 0.171875 },
  { x: 0.890625, y: 0.171875 },
  { x: 0.890625, y: 0.171875 },
  { x: 0.921875, y: 0.171875 },
  { x: 0.921875, y: 0.171875 },
  { x: 0.953125, y: 0.171875 },
  { x: 0.953125, y: 0.171875 },
  { x: 0.984375, y: 0.171875 },
  { x: 0.984375, y: 0.171875 },
  { x: 0.015625, y: 0.203125 },
  { x: 0.015625, y: 0.203125 },
  { x: 0.046875, y: 0.203125 },
  { x: 0.046875, y: 0.203125 },
  { x: 0.078125, y: 0.203125 },
  { x: 0.078125, y: 0.203125 },
  { x: 0.109375, y: 0.203125 },
  { x: 0.109375, y: 0.203125 },
  { x: 0.140625, y: 0.203125 },
  { x: 0.140625, y: 0.203125 },
  { x: 0.171875, y: 0.203125 },
  { x: 0.171875, y: 0.203125 },
  { x: 0.203125, y: 0.203125 },
  { x: 0.203125, y: 0.203125 },
  { x: 0.234375, y: 0.203125 },
  { x: 0.234375, y: 0.203125 },
  { x: 0.265625, y: 0.203125 },
  { x: 0.265625, y: 0.203125 },
  { x: 0.296875, y: 0.203125 },
  { x: 0.296875, y: 0.203125 },
  { x: 0.328125, y: 0.203125 },
  { x: 0.328125, y: 0.203125 },
  { x: 0.359375, y: 0.203125 },
  { x: 0.359375, y: 0.203125 },
  { x: 0.390625, y: 0.203125 },
  { x: 0.390625, y: 0.203125 },
  { x: 0.421875, y: 0.203125 },
  { x: 0.421875, y: 0.203125 },
  { x: 0.453125, y: 0.203125 },
  { x: 0.453125, y: 0.203125 },
  { x: 0.484375, y: 0.203125 },
  { x: 0.484375, y: 0.203125 },
  { x: 0.515625, y: 0.203125 },
  { x: 0.515625, y: 0.203125 },
  { x: 0.546875, y: 0.203125 },
  { x: 0.546875, y: 0.203125 },
  { x: 0.578125, y: 0.203125 },
  { x: 0.578125, y: 0.203125 },
  { x: 0.609375, y: 0.203125 },
  { x: 0.609375, y: 0.203125 },
  { x: 0.640625, y: 0.203125 },
  { x: 0.640625, y: 0.203125 },
  { x: 0.671875, y: 0.203125 },
  { x: 0.671875, y: 0.203125 },
  { x: 0.703125, y: 0.203125 },
  { x: 0.703125, y: 0.203125 },
  { x: 0.734375, y: 0.203125 },
  { x: 0.734375, y: 0.203125 },
  { x: 0.765625, y: 0.203125 },
  { x: 0.765625, y: 0.203125 },
  { x: 0.796875, y: 0.203125 },
  { x: 0.796875, y: 0.203125 },
  { x: 0.828125, y: 0.203125 },
  { x: 0.828125, y: 0.203125 },
  { x: 0.859375, y: 0.203125 },
  { x: 0.859375, y: 0.203125 },
  { x: 0.890625, y: 0.203125 },
  { x: 0.890625, y: 0.203125 },
  { x: 0.921875, y: 0.203125 },
  { x: 0.921875, y: 0.203125 },
  { x: 0.953125, y: 0.203125 },
  { x: 0.953125, y: 0.203125 },
  { x: 0.984375, y: 0.203125 },
  { x: 0.984375, y: 0.203125 },
  { x: 0.015625, y: 0.234375 },
  { x: 0.015625, y: 0.234375 },
  { x: 0.046875, y: 0.234375 },
  { x: 0.046875, y: 0.234375 },
  { x: 0.078125, y: 0.234375 },
  { x: 0.078125, y: 0.234375 },
  { x: 0.109375, y: 0.234375 },
  { x: 0.109375, y: 0.234375 },
  { x: 0.140625, y: 0.234375 },
  { x: 0.140625, y: 0.234375 },
  { x: 0.171875, y: 0.234375 },
  { x: 0.171875, y: 0.234375 },
  { x: 0.203125, y: 0.234375 },
  { x: 0.203125, y: 0.234375 },
  { x: 0.234375, y: 0.234375 },
  { x: 0.234375, y: 0.234375 },
  { x: 0.265625, y: 0.234375 },
  { x: 0.265625, y: 0.234375 },
  { x: 0.296875, y: 0.234375 },
  { x: 0.296875, y: 0.234375 },
  { x: 0.328125, y: 0.234375 },
  { x: 0.328125, y: 0.234375 },
  { x: 0.359375, y: 0.234375 },
  { x: 0.359375, y: 0.234375 },
  { x: 0.390625, y: 0.234375 },
  { x: 0.390625, y: 0.234375 },
  { x: 0.421875, y: 0.234375 },
  { x: 0.421875, y: 0.234375 },
  { x: 0.453125, y: 0.234375 },
  { x: 0.453125, y: 0.234375 },
  { x: 0.484375, y: 0.234375 },
  { x: 0.484375, y: 0.234375 },
  { x: 0.515625, y: 0.234375 },
  { x: 0.515625, y: 0.234375 },
  { x: 0.546875, y: 0.234375 },
  { x: 0.546875, y: 0.234375 },
  { x: 0.578125, y: 0.234375 },
  { x: 0.578125, y: 0.234375 },
  { x: 0.609375, y: 0.234375 },
  { x: 0.609375, y: 0.234375 },
  { x: 0.640625, y: 0.234375 },
  { x: 0.640625, y: 0.234375 },
  { x: 0.671875, y: 0.234375 },
  { x: 0.671875, y: 0.234375 },
  { x: 0.703125, y: 0.234375 },
  { x: 0.703125, y: 0.234375 },
  { x: 0.734375, y: 0.234375 },
  { x: 0.734375, y: 0.234375 },
  { x: 0.765625, y: 0.234375 },
  { x: 0.765625, y: 0.234375 },
  { x: 0.796875, y: 0.234375 },
  { x: 0.796875, y: 0.234375 },
  { x: 0.828125, y: 0.234375 },
  { x: 0.828125, y: 0.234375 },
  { x: 0.859375, y: 0.234375 },
  { x: 0.859375, y: 0.234375 },
  { x: 0.890625, y: 0.234375 },
  { x: 0.890625, y: 0.234375 },
  { x: 0.921875, y: 0.234375 },
  { x: 0.921875, y: 0.234375 },
  { x: 0.953125, y: 0.234375 },
  { x: 0.953125, y: 0.234375 },
  { x: 0.984375, y: 0.234375 },
  { x: 0.984375, y: 0.234375 },
  { x: 0.015625, y: 0.265625 },
  { x: 0.015625, y: 0.265625 },
  { x: 0.046875, y: 0.265625 },
  { x: 0.046875, y: 0.265625 },
  { x: 0.078125, y: 0.265625 },
  { x: 0.078125, y: 0.265625 },
  { x: 0.109375, y: 0.265625 },
  { x: 0.109375, y: 0.265625 },
  { x: 0.140625, y: 0.265625 },
  { x: 0.140625, y: 0.265625 },
  { x: 0.171875, y: 0.265625 },
  { x: 0.171875, y: 0.265625 },
  { x: 0.203125, y: 0.265625 },
  { x: 0.203125, y: 0.265625 },
  { x: 0.234375, y: 0.265625 },
  { x: 0.234375, y: 0.265625 },
  { x: 0.265625, y: 0.265625 },
  { x: 0.265625, y: 0.265625 },
  { x: 0.296875, y: 0.265625 },
  { x: 0.296875, y: 0.265625 },
  { x: 0.328125, y: 0.265625 },
  { x: 0.328125, y: 0.265625 },
  { x: 0.359375, y: 0.265625 },
  { x: 0.359375, y: 0.265625 },
  { x: 0.390625, y: 0.265625 },
  { x: 0.390625, y: 0.265625 },
  { x: 0.421875, y: 0.265625 },
  { x: 0.421875, y: 0.265625 },
  { x: 0.453125, y: 0.265625 },
  { x: 0.453125, y: 0.265625 },
  { x: 0.484375, y: 0.265625 },
  { x: 0.484375, y: 0.265625 },
  { x: 0.515625, y: 0.265625 },
  { x: 0.515625, y: 0.265625 },
  { x: 0.546875, y: 0.265625 },
  { x: 0.546875, y: 0.265625 },
  { x: 0.578125, y: 0.265625 },
  { x: 0.578125, y: 0.265625 },
  { x: 0.609375, y: 0.265625 },
  { x: 0.609375, y: 0.265625 },
  { x: 0.640625, y: 0.265625 },
  { x: 0.640625, y: 0.265625 },
  { x: 0.671875, y: 0.265625 },
  { x: 0.671875, y: 0.265625 },
  { x: 0.703125, y: 0.265625 },
  { x: 0.703125, y: 0.265625 },
  { x: 0.734375, y: 0.265625 },
  { x: 0.734375, y: 0.265625 },
  { x: 0.765625, y: 0.265625 },
  { x: 0.765625, y: 0.265625 },
  { x: 0.796875, y: 0.265625 },
  { x: 0.796875, y: 0.265625 },
  { x: 0.828125, y: 0.265625 },
  { x: 0.828125, y: 0.265625 },
  { x: 0.859375, y: 0.265625 },
  { x: 0.859375, y: 0.265625 },
  { x: 0.890625, y: 0.265625 },
  { x: 0.890625, y: 0.265625 },
  { x: 0.921875, y: 0.265625 },
  { x: 0.921875, y: 0.265625 },
  { x: 0.953125, y: 0.265625 },
  { x: 0.953125, y: 0.265625 },
  { x: 0.984375, y: 0.265625 },
  { x: 0.984375, y: 0.265625 },
  { x: 0.015625, y: 0.296875 },
  { x: 0.015625, y: 0.296875 },
  { x: 0.046875, y: 0.296875 },
  { x: 0.046875, y: 0.296875 },
  { x: 0.078125, y: 0.296875 },
  { x: 0.078125, y: 0.296875 },
  { x: 0.109375, y: 0.296875 },
  { x: 0.109375, y: 0.296875 },
  { x: 0.140625, y: 0.296875 },
  { x: 0.140625, y: 0.296875 },
  { x: 0.171875, y: 0.296875 },
  { x: 0.171875, y: 0.296875 },
  { x: 0.203125, y: 0.296875 },
  { x: 0.203125, y: 0.296875 },
  { x: 0.234375, y: 0.296875 },
  { x: 0.234375, y: 0.296875 },
  { x: 0.265625, y: 0.296875 },
  { x: 0.265625, y: 0.296875 },
  { x: 0.296875, y: 0.296875 },
  { x: 0.296875, y: 0.296875 },
  { x: 0.328125, y: 0.296875 },
  { x: 0.328125, y: 0.296875 },
  { x: 0.359375, y: 0.296875 },
  { x: 0.359375, y: 0.296875 },
  { x: 0.390625, y: 0.296875 },
  { x: 0.390625, y: 0.296875 },
  { x: 0.421875, y: 0.296875 },
  { x: 0.421875, y: 0.296875 },
  { x: 0.453125, y: 0.296875 },
  { x: 0.453125, y: 0.296875 },
  { x: 0.484375, y: 0.296875 },
  { x: 0.484375, y: 0.296875 },
  { x: 0.515625, y: 0.296875 },
  { x: 0.515625, y: 0.296875 },
  { x: 0.546875, y: 0.296875 },
  { x: 0.546875, y: 0.296875 },
  { x: 0.578125, y: 0.296875 },
  { x: 0.578125, y: 0.296875 },
  { x: 0.609375, y: 0.296875 },
  { x: 0.609375, y: 0.296875 },
  { x: 0.640625, y: 0.296875 },
  { x: 0.640625, y: 0.296875 },
  { x: 0.671875, y: 0.296875 },
  { x: 0.671875, y: 0.296875 },
  { x: 0.703125, y: 0.296875 },
  { x: 0.703125, y: 0.296875 },
  { x: 0.734375, y: 0.296875 },
  { x: 0.734375, y: 0.296875 },
  { x: 0.765625, y: 0.296875 },
  { x: 0.765625, y: 0.296875 },
  { x: 0.796875, y: 0.296875 },
  { x: 0.796875, y: 0.296875 },
  { x: 0.828125, y: 0.296875 },
  { x: 0.828125, y: 0.296875 },
  { x: 0.859375, y: 0.296875 },
  { x: 0.859375, y: 0.296875 },
  { x: 0.890625, y: 0.296875 },
  { x: 0.890625, y: 0.296875 },
  { x: 0.921875, y: 0.296875 },
  { x: 0.921875, y: 0.296875 },
  { x: 0.953125, y: 0.296875 },
  { x: 0.953125, y: 0.296875 },
  { x: 0.984375, y: 0.296875 },
  { x: 0.984375, y: 0.296875 },
  { x: 0.015625, y: 0.328125 },
  { x: 0.015625, y: 0.328125 },
  { x: 0.046875, y: 0.328125 },
  { x: 0.046875, y: 0.328125 },
  { x: 0.078125, y: 0.328125 },
  { x: 0.078125, y: 0.328125 },
  { x: 0.109375, y: 0.328125 },
  { x: 0.109375, y: 0.328125 },
  { x: 0.140625, y: 0.328125 },
  { x: 0.140625, y: 0.328125 },
  { x: 0.171875, y: 0.328125 },
  { x: 0.171875, y: 0.328125 },
  { x: 0.203125, y: 0.328125 },
  { x: 0.203125, y: 0.328125 },
  { x: 0.234375, y: 0.328125 },
  { x: 0.234375, y: 0.328125 },
  { x: 0.265625, y: 0.328125 },
  { x: 0.265625, y: 0.328125 },
  { x: 0.296875, y: 0.328125 },
  { x: 0.296875, y: 0.328125 },
  { x: 0.328125, y: 0.328125 },
  { x: 0.328125, y: 0.328125 },
  { x: 0.359375, y: 0.328125 },
  { x: 0.359375, y: 0.328125 },
  { x: 0.390625, y: 0.328125 },
  { x: 0.390625, y: 0.328125 },
  { x: 0.421875, y: 0.328125 },
  { x: 0.421875, y: 0.328125 },
  { x: 0.453125, y: 0.328125 },
  { x: 0.453125, y: 0.328125 },
  { x: 0.484375, y: 0.328125 },
  { x: 0.484375, y: 0.328125 },
  { x: 0.515625, y: 0.328125 },
  { x: 0.515625, y: 0.328125 },
  { x: 0.546875, y: 0.328125 },
  { x: 0.546875, y: 0.328125 },
  { x: 0.578125, y: 0.328125 },
  { x: 0.578125, y: 0.328125 },
  { x: 0.609375, y: 0.328125 },
  { x: 0.609375, y: 0.328125 },
  { x: 0.640625, y: 0.328125 },
  { x: 0.640625, y: 0.328125 },
  { x: 0.671875, y: 0.328125 },
  { x: 0.671875, y: 0.328125 },
  { x: 0.703125, y: 0.328125 },
  { x: 0.703125, y: 0.328125 },
  { x: 0.734375, y: 0.328125 },
  { x: 0.734375, y: 0.328125 },
  { x: 0.765625, y: 0.328125 },
  { x: 0.765625, y: 0.328125 },
  { x: 0.796875, y: 0.328125 },
  { x: 0.796875, y: 0.328125 },
  { x: 0.828125, y: 0.328125 },
  { x: 0.828125, y: 0.328125 },
  { x: 0.859375, y: 0.328125 },
  { x: 0.859375, y: 0.328125 },
  { x: 0.890625, y: 0.328125 },
  { x: 0.890625, y: 0.328125 },
  { x: 0.921875, y: 0.328125 },
  { x: 0.921875, y: 0.328125 },
  { x: 0.953125, y: 0.328125 },
  { x: 0.953125, y: 0.328125 },
  { x: 0.984375, y: 0.328125 },
  { x: 0.984375, y: 0.328125 },
  { x: 0.015625, y: 0.359375 },
  { x: 0.015625, y: 0.359375 },
  { x: 0.046875, y: 0.359375 },
  { x: 0.046875, y: 0.359375 },
  { x: 0.078125, y: 0.359375 },
  { x: 0.078125, y: 0.359375 },
  { x: 0.109375, y: 0.359375 },
  { x: 0.109375, y: 0.359375 },
  { x: 0.140625, y: 0.359375 },
  { x: 0.140625, y: 0.359375 },
  { x: 0.171875, y: 0.359375 },
  { x: 0.171875, y: 0.359375 },
  { x: 0.203125, y: 0.359375 },
  { x: 0.203125, y: 0.359375 },
  { x: 0.234375, y: 0.359375 },
  { x: 0.234375, y: 0.359375 },
  { x: 0.265625, y: 0.359375 },
  { x: 0.265625, y: 0.359375 },
  { x: 0.296875, y: 0.359375 },
  { x: 0.296875, y: 0.359375 },
  { x: 0.328125, y: 0.359375 },
  { x: 0.328125, y: 0.359375 },
  { x: 0.359375, y: 0.359375 },
  { x: 0.359375, y: 0.359375 },
  { x: 0.390625, y: 0.359375 },
  { x: 0.390625, y: 0.359375 },
  { x: 0.421875, y: 0.359375 },
  { x: 0.421875, y: 0.359375 },
  { x: 0.453125, y: 0.359375 },
  { x: 0.453125, y: 0.359375 },
  { x: 0.484375, y: 0.359375 },
  { x: 0.484375, y: 0.359375 },
  { x: 0.515625, y: 0.359375 },
  { x: 0.515625, y: 0.359375 },
  { x: 0.546875, y: 0.359375 },
  { x: 0.546875, y: 0.359375 },
  { x: 0.578125, y: 0.359375 },
  { x: 0.578125, y: 0.359375 },
  { x: 0.609375, y: 0.359375 },
  { x: 0.609375, y: 0.359375 },
  { x: 0.640625, y: 0.359375 },
  { x: 0.640625, y: 0.359375 },
  { x: 0.671875, y: 0.359375 },
  { x: 0.671875, y: 0.359375 },
  { x: 0.703125, y: 0.359375 },
  { x: 0.703125, y: 0.359375 },
  { x: 0.734375, y: 0.359375 },
  { x: 0.734375, y: 0.359375 },
  { x: 0.765625, y: 0.359375 },
  { x: 0.765625, y: 0.359375 },
  { x: 0.796875, y: 0.359375 },
  { x: 0.796875, y: 0.359375 },
  { x: 0.828125, y: 0.359375 },
  { x: 0.828125, y: 0.359375 },
  { x: 0.859375, y: 0.359375 },
  { x: 0.859375, y: 0.359375 },
  { x: 0.890625, y: 0.359375 },
  { x: 0.890625, y: 0.359375 },
  { x: 0.921875, y: 0.359375 },
  { x: 0.921875, y: 0.359375 },
  { x: 0.953125, y: 0.359375 },
  { x: 0.953125, y: 0.359375 },
  { x: 0.984375, y: 0.359375 },
  { x: 0.984375, y: 0.359375 },
  { x: 0.015625, y: 0.390625 },
  { x: 0.015625, y: 0.390625 },
  { x: 0.046875, y: 0.390625 },
  { x: 0.046875, y: 0.390625 },
  { x: 0.078125, y: 0.390625 },
  { x: 0.078125, y: 0.390625 },
  { x: 0.109375, y: 0.390625 },
  { x: 0.109375, y: 0.390625 },
  { x: 0.140625, y: 0.390625 },
  { x: 0.140625, y: 0.390625 },
  { x: 0.171875, y: 0.390625 },
  { x: 0.171875, y: 0.390625 },
  { x: 0.203125, y: 0.390625 },
  { x: 0.203125, y: 0.390625 },
  { x: 0.234375, y: 0.390625 },
  { x: 0.234375, y: 0.390625 },
  { x: 0.265625, y: 0.390625 },
  { x: 0.265625, y: 0.390625 },
  { x: 0.296875, y: 0.390625 },
  { x: 0.296875, y: 0.390625 },
  { x: 0.328125, y: 0.390625 },
  { x: 0.328125, y: 0.390625 },
  { x: 0.359375, y: 0.390625 },
  { x: 0.359375, y: 0.390625 },
  { x: 0.390625, y: 0.390625 },
  { x: 0.390625, y: 0.390625 },
  { x: 0.421875, y: 0.390625 },
  { x: 0.421875, y: 0.390625 },
  { x: 0.453125, y: 0.390625 },
  { x: 0.453125, y: 0.390625 },
  { x: 0.484375, y: 0.390625 },
  { x: 0.484375, y: 0.390625 },
  { x: 0.515625, y: 0.390625 },
  { x: 0.515625, y: 0.390625 },
  { x: 0.546875, y: 0.390625 },
  { x: 0.546875, y: 0.390625 },
  { x: 0.578125, y: 0.390625 },
  { x: 0.578125, y: 0.390625 },
  { x: 0.609375, y: 0.390625 },
  { x: 0.609375, y: 0.390625 },
  { x: 0.640625, y: 0.390625 },
  { x: 0.640625, y: 0.390625 },
  { x: 0.671875, y: 0.390625 },
  { x: 0.671875, y: 0.390625 },
  { x: 0.703125, y: 0.390625 },
  { x: 0.703125, y: 0.390625 },
  { x: 0.734375, y: 0.390625 },
  { x: 0.734375, y: 0.390625 },
  { x: 0.765625, y: 0.390625 },
  { x: 0.765625, y: 0.390625 },
  { x: 0.796875, y: 0.390625 },
  { x: 0.796875, y: 0.390625 },
  { x: 0.828125, y: 0.390625 },
  { x: 0.828125, y: 0.390625 },
  { x: 0.859375, y: 0.390625 },
  { x: 0.859375, y: 0.390625 },
  { x: 0.890625, y: 0.390625 },
  { x: 0.890625, y: 0.390625 },
  { x: 0.921875, y: 0.390625 },
  { x: 0.921875, y: 0.390625 },
  { x: 0.953125, y: 0.390625 },
  { x: 0.953125, y: 0.390625 },
  { x: 0.984375, y: 0.390625 },
  { x: 0.984375, y: 0.390625 },
  { x: 0.015625, y: 0.421875 },
  { x: 0.015625, y: 0.421875 },
  { x: 0.046875, y: 0.421875 },
  { x: 0.046875, y: 0.421875 },
  { x: 0.078125, y: 0.421875 },
  { x: 0.078125, y: 0.421875 },
  { x: 0.109375, y: 0.421875 },
  { x: 0.109375, y: 0.421875 },
  { x: 0.140625, y: 0.421875 },
  { x: 0.140625, y: 0.421875 },
  { x: 0.171875, y: 0.421875 },
  { x: 0.171875, y: 0.421875 },
  { x: 0.203125, y: 0.421875 },
  { x: 0.203125, y: 0.421875 },
  { x: 0.234375, y: 0.421875 },
  { x: 0.234375, y: 0.421875 },
  { x: 0.265625, y: 0.421875 },
  { x: 0.265625, y: 0.421875 },
  { x: 0.296875, y: 0.421875 },
  { x: 0.296875, y: 0.421875 },
  { x: 0.328125, y: 0.421875 },
  { x: 0.328125, y: 0.421875 },
  { x: 0.359375, y: 0.421875 },
  { x: 0.359375, y: 0.421875 },
  { x: 0.390625, y: 0.421875 },
  { x: 0.390625, y: 0.421875 },
  { x: 0.421875, y: 0.421875 },
  { x: 0.421875, y: 0.421875 },
  { x: 0.453125, y: 0.421875 },
  { x: 0.453125, y: 0.421875 },
  { x: 0.484375, y: 0.421875 },
  { x: 0.484375, y: 0.421875 },
  { x: 0.515625, y: 0.421875 },
  { x: 0.515625, y: 0.421875 },
  { x: 0.546875, y: 0.421875 },
  { x: 0.546875, y: 0.421875 },
  { x: 0.578125, y: 0.421875 },
  { x: 0.578125, y: 0.421875 },
  { x: 0.609375, y: 0.421875 },
  { x: 0.609375, y: 0.421875 },
  { x: 0.640625, y: 0.421875 },
  { x: 0.640625, y: 0.421875 },
  { x: 0.671875, y: 0.421875 },
  { x: 0.671875, y: 0.421875 },
  { x: 0.703125, y: 0.421875 },
  { x: 0.703125, y: 0.421875 },
  { x: 0.734375, y: 0.421875 },
  { x: 0.734375, y: 0.421875 },
  { x: 0.765625, y: 0.421875 },
  { x: 0.765625, y: 0.421875 },
  { x: 0.796875, y: 0.421875 },
  { x: 0.796875, y: 0.421875 },
  { x: 0.828125, y: 0.421875 },
  { x: 0.828125, y: 0.421875 },
  { x: 0.859375, y: 0.421875 },
  { x: 0.859375, y: 0.421875 },
  { x: 0.890625, y: 0.421875 },
  { x: 0.890625, y: 0.421875 },
  { x: 0.921875, y: 0.421875 },
  { x: 0.921875, y: 0.421875 },
  { x: 0.953125, y: 0.421875 },
  { x: 0.953125, y: 0.421875 },
  { x: 0.984375, y: 0.421875 },
  { x: 0.984375, y: 0.421875 },
  { x: 0.015625, y: 0.453125 },
  { x: 0.015625, y: 0.453125 },
  { x: 0.046875, y: 0.453125 },
  { x: 0.046875, y: 0.453125 },
  { x: 0.078125, y: 0.453125 },
  { x: 0.078125, y: 0.453125 },
  { x: 0.109375, y: 0.453125 },
  { x: 0.109375, y: 0.453125 },
  { x: 0.140625, y: 0.453125 },
  { x: 0.140625, y: 0.453125 },
  { x: 0.171875, y: 0.453125 },
  { x: 0.171875, y: 0.453125 },
  { x: 0.203125, y: 0.453125 },
  { x: 0.203125, y: 0.453125 },
  { x: 0.234375, y: 0.453125 },
  { x: 0.234375, y: 0.453125 },
  { x: 0.265625, y: 0.453125 },
  { x: 0.265625, y: 0.453125 },
  { x: 0.296875, y: 0.453125 },
  { x: 0.296875, y: 0.453125 },
  { x: 0.328125, y: 0.453125 },
  { x: 0.328125, y: 0.453125 },
  { x: 0.359375, y: 0.453125 },
  { x: 0.359375, y: 0.453125 },
  { x: 0.390625, y: 0.453125 },
  { x: 0.390625, y: 0.453125 },
  { x: 0.421875, y: 0.453125 },
  { x: 0.421875, y: 0.453125 },
  { x: 0.453125, y: 0.453125 },
  { x: 0.453125, y: 0.453125 },
  { x: 0.484375, y: 0.453125 },
  { x: 0.484375, y: 0.453125 },
  { x: 0.515625, y: 0.453125 },
  { x: 0.515625, y: 0.453125 },
  { x: 0.546875, y: 0.453125 },
  { x: 0.546875, y: 0.453125 },
  { x: 0.578125, y: 0.453125 },
  { x: 0.578125, y: 0.453125 },
  { x: 0.609375, y: 0.453125 },
  { x: 0.609375, y: 0.453125 },
  { x: 0.640625, y: 0.453125 },
  { x: 0.640625, y: 0.453125 },
  { x: 0.671875, y: 0.453125 },
  { x: 0.671875, y: 0.453125 },
  { x: 0.703125, y: 0.453125 },
  { x: 0.703125, y: 0.453125 },
  { x: 0.734375, y: 0.453125 },
  { x: 0.734375, y: 0.453125 },
  { x: 0.765625, y: 0.453125 },
  { x: 0.765625, y: 0.453125 },
  { x: 0.796875, y: 0.453125 },
  { x: 0.796875, y: 0.453125 },
  { x: 0.828125, y: 0.453125 },
  { x: 0.828125, y: 0.453125 },
  { x: 0.859375, y: 0.453125 },
  { x: 0.859375, y: 0.453125 },
  { x: 0.890625, y: 0.453125 },
  { x: 0.890625, y: 0.453125 },
  { x: 0.921875, y: 0.453125 },
  { x: 0.921875, y: 0.453125 },
  { x: 0.953125, y: 0.453125 },
  { x: 0.953125, y: 0.453125 },
  { x: 0.984375, y: 0.453125 },
  { x: 0.984375, y: 0.453125 },
  { x: 0.015625, y: 0.484375 },
  { x: 0.015625, y: 0.484375 },
  { x: 0.046875, y: 0.484375 },
  { x: 0.046875, y: 0.484375 },
  { x: 0.078125, y: 0.484375 },
  { x: 0.078125, y: 0.484375 },
  { x: 0.109375, y: 0.484375 },
  { x: 0.109375, y: 0.484375 },
  { x: 0.140625, y: 0.484375 },
  { x: 0.140625, y: 0.484375 },
  { x: 0.171875, y: 0.484375 },
  { x: 0.171875, y: 0.484375 },
  { x: 0.203125, y: 0.484375 },
  { x: 0.203125, y: 0.484375 },
  { x: 0.234375, y: 0.484375 },
  { x: 0.234375, y: 0.484375 },
  { x: 0.265625, y: 0.484375 },
  { x: 0.265625, y: 0.484375 },
  { x: 0.296875, y: 0.484375 },
  { x: 0.296875, y: 0.484375 },
  { x: 0.328125, y: 0.484375 },
  { x: 0.328125, y: 0.484375 },
  { x: 0.359375, y: 0.484375 },
  { x: 0.359375, y: 0.484375 },
  { x: 0.390625, y: 0.484375 },
  { x: 0.390625, y: 0.484375 },
  { x: 0.421875, y: 0.484375 },
  { x: 0.421875, y: 0.484375 },
  { x: 0.453125, y: 0.484375 },
  { x: 0.453125, y: 0.484375 },
  { x: 0.484375, y: 0.484375 },
  { x: 0.484375, y: 0.484375 },
  { x: 0.515625, y: 0.484375 },
  { x: 0.515625, y: 0.484375 },
  { x: 0.546875, y: 0.484375 },
  { x: 0.546875, y: 0.484375 },
  { x: 0.578125, y: 0.484375 },
  { x: 0.578125, y: 0.484375 },
  { x: 0.609375, y: 0.484375 },
  { x: 0.609375, y: 0.484375 },
  { x: 0.640625, y: 0.484375 },
  { x: 0.640625, y: 0.484375 },
  { x: 0.671875, y: 0.484375 },
  { x: 0.671875, y: 0.484375 },
  { x: 0.703125, y: 0.484375 },
  { x: 0.703125, y: 0.484375 },
  { x: 0.734375, y: 0.484375 },
  { x: 0.734375, y: 0.484375 },
  { x: 0.765625, y: 0.484375 },
  { x: 0.765625, y: 0.484375 },
  { x: 0.796875, y: 0.484375 },
  { x: 0.796875, y: 0.484375 },
  { x: 0.828125, y: 0.484375 },
  { x: 0.828125, y: 0.484375 },
  { x: 0.859375, y: 0.484375 },
  { x: 0.859375, y: 0.484375 },
  { x: 0.890625, y: 0.484375 },
  { x: 0.890625, y: 0.484375 },
  { x: 0.921875, y: 0.484375 },
  { x: 0.921875, y: 0.484375 },
  { x: 0.953125, y: 0.484375 },
  { x: 0.953125, y: 0.484375 },
  { x: 0.984375, y: 0.484375 },
  { x: 0.984375, y: 0.484375 },
  { x: 0.015625, y: 0.515625 },
  { x: 0.015625, y: 0.515625 },
  { x: 0.046875, y: 0.515625 },
  { x: 0.046875, y: 0.515625 },
  { x: 0.078125, y: 0.515625 },
  { x: 0.078125, y: 0.515625 },
  { x: 0.109375, y: 0.515625 },
  { x: 0.109375, y: 0.515625 },
  { x: 0.140625, y: 0.515625 },
  { x: 0.140625, y: 0.515625 },
  { x: 0.171875, y: 0.515625 },
  { x: 0.171875, y: 0.515625 },
  { x: 0.203125, y: 0.515625 },
  { x: 0.203125, y: 0.515625 },
  { x: 0.234375, y: 0.515625 },
  { x: 0.234375, y: 0.515625 },
  { x: 0.265625, y: 0.515625 },
  { x: 0.265625, y: 0.515625 },
  { x: 0.296875, y: 0.515625 },
  { x: 0.296875, y: 0.515625 },
  { x: 0.328125, y: 0.515625 },
  { x: 0.328125, y: 0.515625 },
  { x: 0.359375, y: 0.515625 },
  { x: 0.359375, y: 0.515625 },
  { x: 0.390625, y: 0.515625 },
  { x: 0.390625, y: 0.515625 },
  { x: 0.421875, y: 0.515625 },
  { x: 0.421875, y: 0.515625 },
  { x: 0.453125, y: 0.515625 },
  { x: 0.453125, y: 0.515625 },
  { x: 0.484375, y: 0.515625 },
  { x: 0.484375, y: 0.515625 },
  { x: 0.515625, y: 0.515625 },
  { x: 0.515625, y: 0.515625 },
  { x: 0.546875, y: 0.515625 },
  { x: 0.546875, y: 0.515625 },
  { x: 0.578125, y: 0.515625 },
  { x: 0.578125, y: 0.515625 },
  { x: 0.609375, y: 0.515625 },
  { x: 0.609375, y: 0.515625 },
  { x: 0.640625, y: 0.515625 },
  { x: 0.640625, y: 0.515625 },
  { x: 0.671875, y: 0.515625 },
  { x: 0.671875, y: 0.515625 },
  { x: 0.703125, y: 0.515625 },
  { x: 0.703125, y: 0.515625 },
  { x: 0.734375, y: 0.515625 },
  { x: 0.734375, y: 0.515625 },
  { x: 0.765625, y: 0.515625 },
  { x: 0.765625, y: 0.515625 },
  { x: 0.796875, y: 0.515625 },
  { x: 0.796875, y: 0.515625 },
  { x: 0.828125, y: 0.515625 },
  { x: 0.828125, y: 0.515625 },
  { x: 0.859375, y: 0.515625 },
  { x: 0.859375, y: 0.515625 },
  { x: 0.890625, y: 0.515625 },
  { x: 0.890625, y: 0.515625 },
  { x: 0.921875, y: 0.515625 },
  { x: 0.921875, y: 0.515625 },
  { x: 0.953125, y: 0.515625 },
  { x: 0.953125, y: 0.515625 },
  { x: 0.984375, y: 0.515625 },
  { x: 0.984375, y: 0.515625 },
  { x: 0.015625, y: 0.546875 },
  { x: 0.015625, y: 0.546875 },
  { x: 0.046875, y: 0.546875 },
  { x: 0.046875, y: 0.546875 },
  { x: 0.078125, y: 0.546875 },
  { x: 0.078125, y: 0.546875 },
  { x: 0.109375, y: 0.546875 },
  { x: 0.109375, y: 0.546875 },
  { x: 0.140625, y: 0.546875 },
  { x: 0.140625, y: 0.546875 },
  { x: 0.171875, y: 0.546875 },
  { x: 0.171875, y: 0.546875 },
  { x: 0.203125, y: 0.546875 },
  { x: 0.203125, y: 0.546875 },
  { x: 0.234375, y: 0.546875 },
  { x: 0.234375, y: 0.546875 },
  { x: 0.265625, y: 0.546875 },
  { x: 0.265625, y: 0.546875 },
  { x: 0.296875, y: 0.546875 },
  { x: 0.296875, y: 0.546875 },
  { x: 0.328125, y: 0.546875 },
  { x: 0.328125, y: 0.546875 },
  { x: 0.359375, y: 0.546875 },
  { x: 0.359375, y: 0.546875 },
  { x: 0.390625, y: 0.546875 },
  { x: 0.390625, y: 0.546875 },
  { x: 0.421875, y: 0.546875 },
  { x: 0.421875, y: 0.546875 },
  { x: 0.453125, y: 0.546875 },
  { x: 0.453125, y: 0.546875 },
  { x: 0.484375, y: 0.546875 },
  { x: 0.484375, y: 0.546875 },
  { x: 0.515625, y: 0.546875 },
  { x: 0.515625, y: 0.546875 },
  { x: 0.546875, y: 0.546875 },
  { x: 0.546875, y: 0.546875 },
  { x: 0.578125, y: 0.546875 },
  { x: 0.578125, y: 0.546875 },
  { x: 0.609375, y: 0.546875 },
  { x: 0.609375, y: 0.546875 },
  { x: 0.640625, y: 0.546875 },
  { x: 0.640625, y: 0.546875 },
  { x: 0.671875, y: 0.546875 },
  { x: 0.671875, y: 0.546875 },
  { x: 0.703125, y: 0.546875 },
  { x: 0.703125, y: 0.546875 },
  { x: 0.734375, y: 0.546875 },
  { x: 0.734375, y: 0.546875 },
  { x: 0.765625, y: 0.546875 },
  { x: 0.765625, y: 0.546875 },
  { x: 0.796875, y: 0.546875 },
  { x: 0.796875, y: 0.546875 },
  { x: 0.828125, y: 0.546875 },
  { x: 0.828125, y: 0.546875 },
  { x: 0.859375, y: 0.546875 },
  { x: 0.859375, y: 0.546875 },
  { x: 0.890625, y: 0.546875 },
  { x: 0.890625, y: 0.546875 },
  { x: 0.921875, y: 0.546875 },
  { x: 0.921875, y: 0.546875 },
  { x: 0.953125, y: 0.546875 },
  { x: 0.953125, y: 0.546875 },
  { x: 0.984375, y: 0.546875 },
  { x: 0.984375, y: 0.546875 },
  { x: 0.015625, y: 0.578125 },
  { x: 0.015625, y: 0.578125 },
  { x: 0.046875, y: 0.578125 },
  { x: 0.046875, y: 0.578125 },
  { x: 0.078125, y: 0.578125 },
  { x: 0.078125, y: 0.578125 },
  { x: 0.109375, y: 0.578125 },
  { x: 0.109375, y: 0.578125 },
  { x: 0.140625, y: 0.578125 },
  { x: 0.140625, y: 0.578125 },
  { x: 0.171875, y: 0.578125 },
  { x: 0.171875, y: 0.578125 },
  { x: 0.203125, y: 0.578125 },
  { x: 0.203125, y: 0.578125 },
  { x: 0.234375, y: 0.578125 },
  { x: 0.234375, y: 0.578125 },
  { x: 0.265625, y: 0.578125 },
  { x: 0.265625, y: 0.578125 },
  { x: 0.296875, y: 0.578125 },
  { x: 0.296875, y: 0.578125 },
  { x: 0.328125, y: 0.578125 },
  { x: 0.328125, y: 0.578125 },
  { x: 0.359375, y: 0.578125 },
  { x: 0.359375, y: 0.578125 },
  { x: 0.390625, y: 0.578125 },
  { x: 0.390625, y: 0.578125 },
  { x: 0.421875, y: 0.578125 },
  { x: 0.421875, y: 0.578125 },
  { x: 0.453125, y: 0.578125 },
  { x: 0.453125, y: 0.578125 },
  { x: 0.484375, y: 0.578125 },
  { x: 0.484375, y: 0.578125 },
  { x: 0.515625, y: 0.578125 },
  { x: 0.515625, y: 0.578125 },
  { x: 0.546875, y: 0.578125 },
  { x: 0.546875, y: 0.578125 },
  { x: 0.578125, y: 0.578125 },
  { x: 0.578125, y: 0.578125 },
  { x: 0.609375, y: 0.578125 },
  { x: 0.609375, y: 0.578125 },
  { x: 0.640625, y: 0.578125 },
  { x: 0.640625, y: 0.578125 },
  { x: 0.671875, y: 0.578125 },
  { x: 0.671875, y: 0.578125 },
  { x: 0.703125, y: 0.578125 },
  { x: 0.703125, y: 0.578125 },
  { x: 0.734375, y: 0.578125 },
  { x: 0.734375, y: 0.578125 },
  { x: 0.765625, y: 0.578125 },
  { x: 0.765625, y: 0.578125 },
  { x: 0.796875, y: 0.578125 },
  { x: 0.796875, y: 0.578125 },
  { x: 0.828125, y: 0.578125 },
  { x: 0.828125, y: 0.578125 },
  { x: 0.859375, y: 0.578125 },
  { x: 0.859375, y: 0.578125 },
  { x: 0.890625, y: 0.578125 },
  { x: 0.890625, y: 0.578125 },
  { x: 0.921875, y: 0.578125 },
  { x: 0.921875, y: 0.578125 },
  { x: 0.953125, y: 0.578125 },
  { x: 0.953125, y: 0.578125 },
  { x: 0.984375, y: 0.578125 },
  { x: 0.984375, y: 0.578125 },
  { x: 0.015625, y: 0.609375 },
  { x: 0.015625, y: 0.609375 },
  { x: 0.046875, y: 0.609375 },
  { x: 0.046875, y: 0.609375 },
  { x: 0.078125, y: 0.609375 },
  { x: 0.078125, y: 0.609375 },
  { x: 0.109375, y: 0.609375 },
  { x: 0.109375, y: 0.609375 },
  { x: 0.140625, y: 0.609375 },
  { x: 0.140625, y: 0.609375 },
  { x: 0.171875, y: 0.609375 },
  { x: 0.171875, y: 0.609375 },
  { x: 0.203125, y: 0.609375 },
  { x: 0.203125, y: 0.609375 },
  { x: 0.234375, y: 0.609375 },
  { x: 0.234375, y: 0.609375 },
  { x: 0.265625, y: 0.609375 },
  { x: 0.265625, y: 0.609375 },
  { x: 0.296875, y: 0.609375 },
  { x: 0.296875, y: 0.609375 },
  { x: 0.328125, y: 0.609375 },
  { x: 0.328125, y: 0.609375 },
  { x: 0.359375, y: 0.609375 },
  { x: 0.359375, y: 0.609375 },
  { x: 0.390625, y: 0.609375 },
  { x: 0.390625, y: 0.609375 },
  { x: 0.421875, y: 0.609375 },
  { x: 0.421875, y: 0.609375 },
  { x: 0.453125, y: 0.609375 },
  { x: 0.453125, y: 0.609375 },
  { x: 0.484375, y: 0.609375 },
  { x: 0.484375, y: 0.609375 },
  { x: 0.515625, y: 0.609375 },
  { x: 0.515625, y: 0.609375 },
  { x: 0.546875, y: 0.609375 },
  { x: 0.546875, y: 0.609375 },
  { x: 0.578125, y: 0.609375 },
  { x: 0.578125, y: 0.609375 },
  { x: 0.609375, y: 0.609375 },
  { x: 0.609375, y: 0.609375 },
  { x: 0.640625, y: 0.609375 },
  { x: 0.640625, y: 0.609375 },
  { x: 0.671875, y: 0.609375 },
  { x: 0.671875, y: 0.609375 },
  { x: 0.703125, y: 0.609375 },
  { x: 0.703125, y: 0.609375 },
  { x: 0.734375, y: 0.609375 },
  { x: 0.734375, y: 0.609375 },
  { x: 0.765625, y: 0.609375 },
  { x: 0.765625, y: 0.609375 },
  { x: 0.796875, y: 0.609375 },
  { x: 0.796875, y: 0.609375 },
  { x: 0.828125, y: 0.609375 },
  { x: 0.828125, y: 0.609375 },
  { x: 0.859375, y: 0.609375 },
  { x: 0.859375, y: 0.609375 },
  { x: 0.890625, y: 0.609375 },
  { x: 0.890625, y: 0.609375 },
  { x: 0.921875, y: 0.609375 },
  { x: 0.921875, y: 0.609375 },
  { x: 0.953125, y: 0.609375 },
  { x: 0.953125, y: 0.609375 },
  { x: 0.984375, y: 0.609375 },
  { x: 0.984375, y: 0.609375 },
  { x: 0.015625, y: 0.640625 },
  { x: 0.015625, y: 0.640625 },
  { x: 0.046875, y: 0.640625 },
  { x: 0.046875, y: 0.640625 },
  { x: 0.078125, y: 0.640625 },
  { x: 0.078125, y: 0.640625 },
  { x: 0.109375, y: 0.640625 },
  { x: 0.109375, y: 0.640625 },
  { x: 0.140625, y: 0.640625 },
  { x: 0.140625, y: 0.640625 },
  { x: 0.171875, y: 0.640625 },
  { x: 0.171875, y: 0.640625 },
  { x: 0.203125, y: 0.640625 },
  { x: 0.203125, y: 0.640625 },
  { x: 0.234375, y: 0.640625 },
  { x: 0.234375, y: 0.640625 },
  { x: 0.265625, y: 0.640625 },
  { x: 0.265625, y: 0.640625 },
  { x: 0.296875, y: 0.640625 },
  { x: 0.296875, y: 0.640625 },
  { x: 0.328125, y: 0.640625 },
  { x: 0.328125, y: 0.640625 },
  { x: 0.359375, y: 0.640625 },
  { x: 0.359375, y: 0.640625 },
  { x: 0.390625, y: 0.640625 },
  { x: 0.390625, y: 0.640625 },
  { x: 0.421875, y: 0.640625 },
  { x: 0.421875, y: 0.640625 },
  { x: 0.453125, y: 0.640625 },
  { x: 0.453125, y: 0.640625 },
  { x: 0.484375, y: 0.640625 },
  { x: 0.484375, y: 0.640625 },
  { x: 0.515625, y: 0.640625 },
  { x: 0.515625, y: 0.640625 },
  { x: 0.546875, y: 0.640625 },
  { x: 0.546875, y: 0.640625 },
  { x: 0.578125, y: 0.640625 },
  { x: 0.578125, y: 0.640625 },
  { x: 0.609375, y: 0.640625 },
  { x: 0.609375, y: 0.640625 },
  { x: 0.640625, y: 0.640625 },
  { x: 0.640625, y: 0.640625 },
  { x: 0.671875, y: 0.640625 },
  { x: 0.671875, y: 0.640625 },
  { x: 0.703125, y: 0.640625 },
  { x: 0.703125, y: 0.640625 },
  { x: 0.734375, y: 0.640625 },
  { x: 0.734375, y: 0.640625 },
  { x: 0.765625, y: 0.640625 },
  { x: 0.765625, y: 0.640625 },
  { x: 0.796875, y: 0.640625 },
  { x: 0.796875, y: 0.640625 },
  { x: 0.828125, y: 0.640625 },
  { x: 0.828125, y: 0.640625 },
  { x: 0.859375, y: 0.640625 },
  { x: 0.859375, y: 0.640625 },
  { x: 0.890625, y: 0.640625 },
  { x: 0.890625, y: 0.640625 },
  { x: 0.921875, y: 0.640625 },
  { x: 0.921875, y: 0.640625 },
  { x: 0.953125, y: 0.640625 },
  { x: 0.953125, y: 0.640625 },
  { x: 0.984375, y: 0.640625 },
  { x: 0.984375, y: 0.640625 },
  { x: 0.015625, y: 0.671875 },
  { x: 0.015625, y: 0.671875 },
  { x: 0.046875, y: 0.671875 },
  { x: 0.046875, y: 0.671875 },
  { x: 0.078125, y: 0.671875 },
  { x: 0.078125, y: 0.671875 },
  { x: 0.109375, y: 0.671875 },
  { x: 0.109375, y: 0.671875 },
  { x: 0.140625, y: 0.671875 },
  { x: 0.140625, y: 0.671875 },
  { x: 0.171875, y: 0.671875 },
  { x: 0.171875, y: 0.671875 },
  { x: 0.203125, y: 0.671875 },
  { x: 0.203125, y: 0.671875 },
  { x: 0.234375, y: 0.671875 },
  { x: 0.234375, y: 0.671875 },
  { x: 0.265625, y: 0.671875 },
  { x: 0.265625, y: 0.671875 },
  { x: 0.296875, y: 0.671875 },
  { x: 0.296875, y: 0.671875 },
  { x: 0.328125, y: 0.671875 },
  { x: 0.328125, y: 0.671875 },
  { x: 0.359375, y: 0.671875 },
  { x: 0.359375, y: 0.671875 },
  { x: 0.390625, y: 0.671875 },
  { x: 0.390625, y: 0.671875 },
  { x: 0.421875, y: 0.671875 },
  { x: 0.421875, y: 0.671875 },
  { x: 0.453125, y: 0.671875 },
  { x: 0.453125, y: 0.671875 },
  { x: 0.484375, y: 0.671875 },
  { x: 0.484375, y: 0.671875 },
  { x: 0.515625, y: 0.671875 },
  { x: 0.515625, y: 0.671875 },
  { x: 0.546875, y: 0.671875 },
  { x: 0.546875, y: 0.671875 },
  { x: 0.578125, y: 0.671875 },
  { x: 0.578125, y: 0.671875 },
  { x: 0.609375, y: 0.671875 },
  { x: 0.609375, y: 0.671875 },
  { x: 0.640625, y: 0.671875 },
  { x: 0.640625, y: 0.671875 },
  { x: 0.671875, y: 0.671875 },
  { x: 0.671875, y: 0.671875 },
  { x: 0.703125, y: 0.671875 },
  { x: 0.703125, y: 0.671875 },
  { x: 0.734375, y: 0.671875 },
  { x: 0.734375, y: 0.671875 },
  { x: 0.765625, y: 0.671875 },
  { x: 0.765625, y: 0.671875 },
  { x: 0.796875, y: 0.671875 },
  { x: 0.796875, y: 0.671875 },
  { x: 0.828125, y: 0.671875 },
  { x: 0.828125, y: 0.671875 },
  { x: 0.859375, y: 0.671875 },
  { x: 0.859375, y: 0.671875 },
  { x: 0.890625, y: 0.671875 },
  { x: 0.890625, y: 0.671875 },
  { x: 0.921875, y: 0.671875 },
  { x: 0.921875, y: 0.671875 },
  { x: 0.953125, y: 0.671875 },
  { x: 0.953125, y: 0.671875 },
  { x: 0.984375, y: 0.671875 },
  { x: 0.984375, y: 0.671875 },
  { x: 0.015625, y: 0.703125 },
  { x: 0.015625, y: 0.703125 },
  { x: 0.046875, y: 0.703125 },
  { x: 0.046875, y: 0.703125 },
  { x: 0.078125, y: 0.703125 },
  { x: 0.078125, y: 0.703125 },
  { x: 0.109375, y: 0.703125 },
  { x: 0.109375, y: 0.703125 },
  { x: 0.140625, y: 0.703125 },
  { x: 0.140625, y: 0.703125 },
  { x: 0.171875, y: 0.703125 },
  { x: 0.171875, y: 0.703125 },
  { x: 0.203125, y: 0.703125 },
  { x: 0.203125, y: 0.703125 },
  { x: 0.234375, y: 0.703125 },
  { x: 0.234375, y: 0.703125 },
  { x: 0.265625, y: 0.703125 },
  { x: 0.265625, y: 0.703125 },
  { x: 0.296875, y: 0.703125 },
  { x: 0.296875, y: 0.703125 },
  { x: 0.328125, y: 0.703125 },
  { x: 0.328125, y: 0.703125 },
  { x: 0.359375, y: 0.703125 },
  { x: 0.359375, y: 0.703125 },
  { x: 0.390625, y: 0.703125 },
  { x: 0.390625, y: 0.703125 },
  { x: 0.421875, y: 0.703125 },
  { x: 0.421875, y: 0.703125 },
  { x: 0.453125, y: 0.703125 },
  { x: 0.453125, y: 0.703125 },
  { x: 0.484375, y: 0.703125 },
  { x: 0.484375, y: 0.703125 },
  { x: 0.515625, y: 0.703125 },
  { x: 0.515625, y: 0.703125 },
  { x: 0.546875, y: 0.703125 },
  { x: 0.546875, y: 0.703125 },
  { x: 0.578125, y: 0.703125 },
  { x: 0.578125, y: 0.703125 },
  { x: 0.609375, y: 0.703125 },
  { x: 0.609375, y: 0.703125 },
  { x: 0.640625, y: 0.703125 },
  { x: 0.640625, y: 0.703125 },
  { x: 0.671875, y: 0.703125 },
  { x: 0.671875, y: 0.703125 },
  { x: 0.703125, y: 0.703125 },
  { x: 0.703125, y: 0.703125 },
  { x: 0.734375, y: 0.703125 },
  { x: 0.734375, y: 0.703125 },
  { x: 0.765625, y: 0.703125 },
  { x: 0.765625, y: 0.703125 },
  { x: 0.796875, y: 0.703125 },
  { x: 0.796875, y: 0.703125 },
  { x: 0.828125, y: 0.703125 },
  { x: 0.828125, y: 0.703125 },
  { x: 0.859375, y: 0.703125 },
  { x: 0.859375, y: 0.703125 },
  { x: 0.890625, y: 0.703125 },
  { x: 0.890625, y: 0.703125 },
  { x: 0.921875, y: 0.703125 },
  { x: 0.921875, y: 0.703125 },
  { x: 0.953125, y: 0.703125 },
  { x: 0.953125, y: 0.703125 },
  { x: 0.984375, y: 0.703125 },
  { x: 0.984375, y: 0.703125 },
  { x: 0.015625, y: 0.734375 },
  { x: 0.015625, y: 0.734375 },
  { x: 0.046875, y: 0.734375 },
  { x: 0.046875, y: 0.734375 },
  { x: 0.078125, y: 0.734375 },
  { x: 0.078125, y: 0.734375 },
  { x: 0.109375, y: 0.734375 },
  { x: 0.109375, y: 0.734375 },
  { x: 0.140625, y: 0.734375 },
  { x: 0.140625, y: 0.734375 },
  { x: 0.171875, y: 0.734375 },
  { x: 0.171875, y: 0.734375 },
  { x: 0.203125, y: 0.734375 },
  { x: 0.203125, y: 0.734375 },
  { x: 0.234375, y: 0.734375 },
  { x: 0.234375, y: 0.734375 },
  { x: 0.265625, y: 0.734375 },
  { x: 0.265625, y: 0.734375 },
  { x: 0.296875, y: 0.734375 },
  { x: 0.296875, y: 0.734375 },
  { x: 0.328125, y: 0.734375 },
  { x: 0.328125, y: 0.734375 },
  { x: 0.359375, y: 0.734375 },
  { x: 0.359375, y: 0.734375 },
  { x: 0.390625, y: 0.734375 },
  { x: 0.390625, y: 0.734375 },
  { x: 0.421875, y: 0.734375 },
  { x: 0.421875, y: 0.734375 },
  { x: 0.453125, y: 0.734375 },
  { x: 0.453125, y: 0.734375 },
  { x: 0.484375, y: 0.734375 },
  { x: 0.484375, y: 0.734375 },
  { x: 0.515625, y: 0.734375 },
  { x: 0.515625, y: 0.734375 },
  { x: 0.546875, y: 0.734375 },
  { x: 0.546875, y: 0.734375 },
  { x: 0.578125, y: 0.734375 },
  { x: 0.578125, y: 0.734375 },
  { x: 0.609375, y: 0.734375 },
  { x: 0.609375, y: 0.734375 },
  { x: 0.640625, y: 0.734375 },
  { x: 0.640625, y: 0.734375 },
  { x: 0.671875, y: 0.734375 },
  { x: 0.671875, y: 0.734375 },
  { x: 0.703125, y: 0.734375 },
  { x: 0.703125, y: 0.734375 },
  { x: 0.734375, y: 0.734375 },
  { x: 0.734375, y: 0.734375 },
  { x: 0.765625, y: 0.734375 },
  { x: 0.765625, y: 0.734375 },
  { x: 0.796875, y: 0.734375 },
  { x: 0.796875, y: 0.734375 },
  { x: 0.828125, y: 0.734375 },
  { x: 0.828125, y: 0.734375 },
  { x: 0.859375, y: 0.734375 },
  { x: 0.859375, y: 0.734375 },
  { x: 0.890625, y: 0.734375 },
  { x: 0.890625, y: 0.734375 },
  { x: 0.921875, y: 0.734375 },
  { x: 0.921875, y: 0.734375 },
  { x: 0.953125, y: 0.734375 },
  { x: 0.953125, y: 0.734375 },
  { x: 0.984375, y: 0.734375 },
  { x: 0.984375, y: 0.734375 },
  { x: 0.015625, y: 0.765625 },
  { x: 0.015625, y: 0.765625 },
  { x: 0.046875, y: 0.765625 },
  { x: 0.046875, y: 0.765625 },
  { x: 0.078125, y: 0.765625 },
  { x: 0.078125, y: 0.765625 },
  { x: 0.109375, y: 0.765625 },
  { x: 0.109375, y: 0.765625 },
  { x: 0.140625, y: 0.765625 },
  { x: 0.140625, y: 0.765625 },
  { x: 0.171875, y: 0.765625 },
  { x: 0.171875, y: 0.765625 },
  { x: 0.203125, y: 0.765625 },
  { x: 0.203125, y: 0.765625 },
  { x: 0.234375, y: 0.765625 },
  { x: 0.234375, y: 0.765625 },
  { x: 0.265625, y: 0.765625 },
  { x: 0.265625, y: 0.765625 },
  { x: 0.296875, y: 0.765625 },
  { x: 0.296875, y: 0.765625 },
  { x: 0.328125, y: 0.765625 },
  { x: 0.328125, y: 0.765625 },
  { x: 0.359375, y: 0.765625 },
  { x: 0.359375, y: 0.765625 },
  { x: 0.390625, y: 0.765625 },
  { x: 0.390625, y: 0.765625 },
  { x: 0.421875, y: 0.765625 },
  { x: 0.421875, y: 0.765625 },
  { x: 0.453125, y: 0.765625 },
  { x: 0.453125, y: 0.765625 },
  { x: 0.484375, y: 0.765625 },
  { x: 0.484375, y: 0.765625 },
  { x: 0.515625, y: 0.765625 },
  { x: 0.515625, y: 0.765625 },
  { x: 0.546875, y: 0.765625 },
  { x: 0.546875, y: 0.765625 },
  { x: 0.578125, y: 0.765625 },
  { x: 0.578125, y: 0.765625 },
  { x: 0.609375, y: 0.765625 },
  { x: 0.609375, y: 0.765625 },
  { x: 0.640625, y: 0.765625 },
  { x: 0.640625, y: 0.765625 },
  { x: 0.671875, y: 0.765625 },
  { x: 0.671875, y: 0.765625 },
  { x: 0.703125, y: 0.765625 },
  { x: 0.703125, y: 0.765625 },
  { x: 0.734375, y: 0.765625 },
  { x: 0.734375, y: 0.765625 },
  { x: 0.765625, y: 0.765625 },
  { x: 0.765625, y: 0.765625 },
  { x: 0.796875, y: 0.765625 },
  { x: 0.796875, y: 0.765625 },
  { x: 0.828125, y: 0.765625 },
  { x: 0.828125, y: 0.765625 },
  { x: 0.859375, y: 0.765625 },
  { x: 0.859375, y: 0.765625 },
  { x: 0.890625, y: 0.765625 },
  { x: 0.890625, y: 0.765625 },
  { x: 0.921875, y: 0.765625 },
  { x: 0.921875, y: 0.765625 },
  { x: 0.953125, y: 0.765625 },
  { x: 0.953125, y: 0.765625 },
  { x: 0.984375, y: 0.765625 },
  { x: 0.984375, y: 0.765625 },
  { x: 0.015625, y: 0.796875 },
  { x: 0.015625, y: 0.796875 },
  { x: 0.046875, y: 0.796875 },
  { x: 0.046875, y: 0.796875 },
  { x: 0.078125, y: 0.796875 },
  { x: 0.078125, y: 0.796875 },
  { x: 0.109375, y: 0.796875 },
  { x: 0.109375, y: 0.796875 },
  { x: 0.140625, y: 0.796875 },
  { x: 0.140625, y: 0.796875 },
  { x: 0.171875, y: 0.796875 },
  { x: 0.171875, y: 0.796875 },
  { x: 0.203125, y: 0.796875 },
  { x: 0.203125, y: 0.796875 },
  { x: 0.234375, y: 0.796875 },
  { x: 0.234375, y: 0.796875 },
  { x: 0.265625, y: 0.796875 },
  { x: 0.265625, y: 0.796875 },
  { x: 0.296875, y: 0.796875 },
  { x: 0.296875, y: 0.796875 },
  { x: 0.328125, y: 0.796875 },
  { x: 0.328125, y: 0.796875 },
  { x: 0.359375, y: 0.796875 },
  { x: 0.359375, y: 0.796875 },
  { x: 0.390625, y: 0.796875 },
  { x: 0.390625, y: 0.796875 },
  { x: 0.421875, y: 0.796875 },
  { x: 0.421875, y: 0.796875 },
  { x: 0.453125, y: 0.796875 },
  { x: 0.453125, y: 0.796875 },
  { x: 0.484375, y: 0.796875 },
  { x: 0.484375, y: 0.796875 },
  { x: 0.515625, y: 0.796875 },
  { x: 0.515625, y: 0.796875 },
  { x: 0.546875, y: 0.796875 },
  { x: 0.546875, y: 0.796875 },
  { x: 0.578125, y: 0.796875 },
  { x: 0.578125, y: 0.796875 },
  { x: 0.609375, y: 0.796875 },
  { x: 0.609375, y: 0.796875 },
  { x: 0.640625, y: 0.796875 },
  { x: 0.640625, y: 0.796875 },
  { x: 0.671875, y: 0.796875 },
  { x: 0.671875, y: 0.796875 },
  { x: 0.703125, y: 0.796875 },
  { x: 0.703125, y: 0.796875 },
  { x: 0.734375, y: 0.796875 },
  { x: 0.734375, y: 0.796875 },
  { x: 0.765625, y: 0.796875 },
  { x: 0.765625, y: 0.796875 },
  { x: 0.796875, y: 0.796875 },
  { x: 0.796875, y: 0.796875 },
  { x: 0.828125, y: 0.796875 },
  { x: 0.828125, y: 0.796875 },
  { x: 0.859375, y: 0.796875 },
  { x: 0.859375, y: 0.796875 },
  { x: 0.890625, y: 0.796875 },
  { x: 0.890625, y: 0.796875 },
  { x: 0.921875, y: 0.796875 },
  { x: 0.921875, y: 0.796875 },
  { x: 0.953125, y: 0.796875 },
  { x: 0.953125, y: 0.796875 },
  { x: 0.984375, y: 0.796875 },
  { x: 0.984375, y: 0.796875 },
  { x: 0.015625, y: 0.828125 },
  { x: 0.015625, y: 0.828125 },
  { x: 0.046875, y: 0.828125 },
  { x: 0.046875, y: 0.828125 },
  { x: 0.078125, y: 0.828125 },
  { x: 0.078125, y: 0.828125 },
  { x: 0.109375, y: 0.828125 },
  { x: 0.109375, y: 0.828125 },
  { x: 0.140625, y: 0.828125 },
  { x: 0.140625, y: 0.828125 },
  { x: 0.171875, y: 0.828125 },
  { x: 0.171875, y: 0.828125 },
  { x: 0.203125, y: 0.828125 },
  { x: 0.203125, y: 0.828125 },
  { x: 0.234375, y: 0.828125 },
  { x: 0.234375, y: 0.828125 },
  { x: 0.265625, y: 0.828125 },
  { x: 0.265625, y: 0.828125 },
  { x: 0.296875, y: 0.828125 },
  { x: 0.296875, y: 0.828125 },
  { x: 0.328125, y: 0.828125 },
  { x: 0.328125, y: 0.828125 },
  { x: 0.359375, y: 0.828125 },
  { x: 0.359375, y: 0.828125 },
  { x: 0.390625, y: 0.828125 },
  { x: 0.390625, y: 0.828125 },
  { x: 0.421875, y: 0.828125 },
  { x: 0.421875, y: 0.828125 },
  { x: 0.453125, y: 0.828125 },
  { x: 0.453125, y: 0.828125 },
  { x: 0.484375, y: 0.828125 },
  { x: 0.484375, y: 0.828125 },
  { x: 0.515625, y: 0.828125 },
  { x: 0.515625, y: 0.828125 },
  { x: 0.546875, y: 0.828125 },
  { x: 0.546875, y: 0.828125 },
  { x: 0.578125, y: 0.828125 },
  { x: 0.578125, y: 0.828125 },
  { x: 0.609375, y: 0.828125 },
  { x: 0.609375, y: 0.828125 },
  { x: 0.640625, y: 0.828125 },
  { x: 0.640625, y: 0.828125 },
  { x: 0.671875, y: 0.828125 },
  { x: 0.671875, y: 0.828125 },
  { x: 0.703125, y: 0.828125 },
  { x: 0.703125, y: 0.828125 },
  { x: 0.734375, y: 0.828125 },
  { x: 0.734375, y: 0.828125 },
  { x: 0.765625, y: 0.828125 },
  { x: 0.765625, y: 0.828125 },
  { x: 0.796875, y: 0.828125 },
  { x: 0.796875, y: 0.828125 },
  { x: 0.828125, y: 0.828125 },
  { x: 0.828125, y: 0.828125 },
  { x: 0.859375, y: 0.828125 },
  { x: 0.859375, y: 0.828125 },
  { x: 0.890625, y: 0.828125 },
  { x: 0.890625, y: 0.828125 },
  { x: 0.921875, y: 0.828125 },
  { x: 0.921875, y: 0.828125 },
  { x: 0.953125, y: 0.828125 },
  { x: 0.953125, y: 0.828125 },
  { x: 0.984375, y: 0.828125 },
  { x: 0.984375, y: 0.828125 },
  { x: 0.015625, y: 0.859375 },
  { x: 0.015625, y: 0.859375 },
  { x: 0.046875, y: 0.859375 },
  { x: 0.046875, y: 0.859375 },
  { x: 0.078125, y: 0.859375 },
  { x: 0.078125, y: 0.859375 },
  { x: 0.109375, y: 0.859375 },
  { x: 0.109375, y: 0.859375 },
  { x: 0.140625, y: 0.859375 },
  { x: 0.140625, y: 0.859375 },
  { x: 0.171875, y: 0.859375 },
  { x: 0.171875, y: 0.859375 },
  { x: 0.203125, y: 0.859375 },
  { x: 0.203125, y: 0.859375 },
  { x: 0.234375, y: 0.859375 },
  { x: 0.234375, y: 0.859375 },
  { x: 0.265625, y: 0.859375 },
  { x: 0.265625, y: 0.859375 },
  { x: 0.296875, y: 0.859375 },
  { x: 0.296875, y: 0.859375 },
  { x: 0.328125, y: 0.859375 },
  { x: 0.328125, y: 0.859375 },
  { x: 0.359375, y: 0.859375 },
  { x: 0.359375, y: 0.859375 },
  { x: 0.390625, y: 0.859375 },
  { x: 0.390625, y: 0.859375 },
  { x: 0.421875, y: 0.859375 },
  { x: 0.421875, y: 0.859375 },
  { x: 0.453125, y: 0.859375 },
  { x: 0.453125, y: 0.859375 },
  { x: 0.484375, y: 0.859375 },
  { x: 0.484375, y: 0.859375 },
  { x: 0.515625, y: 0.859375 },
  { x: 0.515625, y: 0.859375 },
  { x: 0.546875, y: 0.859375 },
  { x: 0.546875, y: 0.859375 },
  { x: 0.578125, y: 0.859375 },
  { x: 0.578125, y: 0.859375 },
  { x: 0.609375, y: 0.859375 },
  { x: 0.609375, y: 0.859375 },
  { x: 0.640625, y: 0.859375 },
  { x: 0.640625, y: 0.859375 },
  { x: 0.671875, y: 0.859375 },
  { x: 0.671875, y: 0.859375 },
  { x: 0.703125, y: 0.859375 },
  { x: 0.703125, y: 0.859375 },
  { x: 0.734375, y: 0.859375 },
  { x: 0.734375, y: 0.859375 },
  { x: 0.765625, y: 0.859375 },
  { x: 0.765625, y: 0.859375 },
  { x: 0.796875, y: 0.859375 },
  { x: 0.796875, y: 0.859375 },
  { x: 0.828125, y: 0.859375 },
  { x: 0.828125, y: 0.859375 },
  { x: 0.859375, y: 0.859375 },
  { x: 0.859375, y: 0.859375 },
  { x: 0.890625, y: 0.859375 },
  { x: 0.890625, y: 0.859375 },
  { x: 0.921875, y: 0.859375 },
  { x: 0.921875, y: 0.859375 },
  { x: 0.953125, y: 0.859375 },
  { x: 0.953125, y: 0.859375 },
  { x: 0.984375, y: 0.859375 },
  { x: 0.984375, y: 0.859375 },
  { x: 0.015625, y: 0.890625 },
  { x: 0.015625, y: 0.890625 },
  { x: 0.046875, y: 0.890625 },
  { x: 0.046875, y: 0.890625 },
  { x: 0.078125, y: 0.890625 },
  { x: 0.078125, y: 0.890625 },
  { x: 0.109375, y: 0.890625 },
  { x: 0.109375, y: 0.890625 },
  { x: 0.140625, y: 0.890625 },
  { x: 0.140625, y: 0.890625 },
  { x: 0.171875, y: 0.890625 },
  { x: 0.171875, y: 0.890625 },
  { x: 0.203125, y: 0.890625 },
  { x: 0.203125, y: 0.890625 },
  { x: 0.234375, y: 0.890625 },
  { x: 0.234375, y: 0.890625 },
  { x: 0.265625, y: 0.890625 },
  { x: 0.265625, y: 0.890625 },
  { x: 0.296875, y: 0.890625 },
  { x: 0.296875, y: 0.890625 },
  { x: 0.328125, y: 0.890625 },
  { x: 0.328125, y: 0.890625 },
  { x: 0.359375, y: 0.890625 },
  { x: 0.359375, y: 0.890625 },
  { x: 0.390625, y: 0.890625 },
  { x: 0.390625, y: 0.890625 },
  { x: 0.421875, y: 0.890625 },
  { x: 0.421875, y: 0.890625 },
  { x: 0.453125, y: 0.890625 },
  { x: 0.453125, y: 0.890625 },
  { x: 0.484375, y: 0.890625 },
  { x: 0.484375, y: 0.890625 },
  { x: 0.515625, y: 0.890625 },
  { x: 0.515625, y: 0.890625 },
  { x: 0.546875, y: 0.890625 },
  { x: 0.546875, y: 0.890625 },
  { x: 0.578125, y: 0.890625 },
  { x: 0.578125, y: 0.890625 },
  { x: 0.609375, y: 0.890625 },
  { x: 0.609375, y: 0.890625 },
  { x: 0.640625, y: 0.890625 },
  { x: 0.640625, y: 0.890625 },
  { x: 0.671875, y: 0.890625 },
  { x: 0.671875, y: 0.890625 },
  { x: 0.703125, y: 0.890625 },
  { x: 0.703125, y: 0.890625 },
  { x: 0.734375, y: 0.890625 },
  { x: 0.734375, y: 0.890625 },
  { x: 0.765625, y: 0.890625 },
  { x: 0.765625, y: 0.890625 },
  { x: 0.796875, y: 0.890625 },
  { x: 0.796875, y: 0.890625 },
  { x: 0.828125, y: 0.890625 },
  { x: 0.828125, y: 0.890625 },
  { x: 0.859375, y: 0.890625 },
  { x: 0.859375, y: 0.890625 },
  { x: 0.890625, y: 0.890625 },
  { x: 0.890625, y: 0.890625 },
  { x: 0.921875, y: 0.890625 },
  { x: 0.921875, y: 0.890625 },
  { x: 0.953125, y: 0.890625 },
  { x: 0.953125, y: 0.890625 },
  { x: 0.984375, y: 0.890625 },
  { x: 0.984375, y: 0.890625 },
  { x: 0.015625, y: 0.921875 },
  { x: 0.015625, y: 0.921875 },
  { x: 0.046875, y: 0.921875 },
  { x: 0.046875, y: 0.921875 },
  { x: 0.078125, y: 0.921875 },
  { x: 0.078125, y: 0.921875 },
  { x: 0.109375, y: 0.921875 },
  { x: 0.109375, y: 0.921875 },
  { x: 0.140625, y: 0.921875 },
  { x: 0.140625, y: 0.921875 },
  { x: 0.171875, y: 0.921875 },
  { x: 0.171875, y: 0.921875 },
  { x: 0.203125, y: 0.921875 },
  { x: 0.203125, y: 0.921875 },
  { x: 0.234375, y: 0.921875 },
  { x: 0.234375, y: 0.921875 },
  { x: 0.265625, y: 0.921875 },
  { x: 0.265625, y: 0.921875 },
  { x: 0.296875, y: 0.921875 },
  { x: 0.296875, y: 0.921875 },
  { x: 0.328125, y: 0.921875 },
  { x: 0.328125, y: 0.921875 },
  { x: 0.359375, y: 0.921875 },
  { x: 0.359375, y: 0.921875 },
  { x: 0.390625, y: 0.921875 },
  { x: 0.390625, y: 0.921875 },
  { x: 0.421875, y: 0.921875 },
  { x: 0.421875, y: 0.921875 },
  { x: 0.453125, y: 0.921875 },
  { x: 0.453125, y: 0.921875 },
  { x: 0.484375, y: 0.921875 },
  { x: 0.484375, y: 0.921875 },
  { x: 0.515625, y: 0.921875 },
  { x: 0.515625, y: 0.921875 },
  { x: 0.546875, y: 0.921875 },
  { x: 0.546875, y: 0.921875 },
  { x: 0.578125, y: 0.921875 },
  { x: 0.578125, y: 0.921875 },
  { x: 0.609375, y: 0.921875 },
  { x: 0.609375, y: 0.921875 },
  { x: 0.640625, y: 0.921875 },
  { x: 0.640625, y: 0.921875 },
  { x: 0.671875, y: 0.921875 },
  { x: 0.671875, y: 0.921875 },
  { x: 0.703125, y: 0.921875 },
  { x: 0.703125, y: 0.921875 },
  { x: 0.734375, y: 0.921875 },
  { x: 0.734375, y: 0.921875 },
  { x: 0.765625, y: 0.921875 },
  { x: 0.765625, y: 0.921875 },
  { x: 0.796875, y: 0.921875 },
  { x: 0.796875, y: 0.921875 },
  { x: 0.828125, y: 0.921875 },
  { x: 0.828125, y: 0.921875 },
  { x: 0.859375, y: 0.921875 },
  { x: 0.859375, y: 0.921875 },
  { x: 0.890625, y: 0.921875 },
  { x: 0.890625, y: 0.921875 },
  { x: 0.921875, y: 0.921875 },
  { x: 0.921875, y: 0.921875 },
  { x: 0.953125, y: 0.921875 },
  { x: 0.953125, y: 0.921875 },
  { x: 0.984375, y: 0.921875 },
  { x: 0.984375, y: 0.921875 },
  { x: 0.015625, y: 0.953125 },
  { x: 0.015625, y: 0.953125 },
  { x: 0.046875, y: 0.953125 },
  { x: 0.046875, y: 0.953125 },
  { x: 0.078125, y: 0.953125 },
  { x: 0.078125, y: 0.953125 },
  { x: 0.109375, y: 0.953125 },
  { x: 0.109375, y: 0.953125 },
  { x: 0.140625, y: 0.953125 },
  { x: 0.140625, y: 0.953125 },
  { x: 0.171875, y: 0.953125 },
  { x: 0.171875, y: 0.953125 },
  { x: 0.203125, y: 0.953125 },
  { x: 0.203125, y: 0.953125 },
  { x: 0.234375, y: 0.953125 },
  { x: 0.234375, y: 0.953125 },
  { x: 0.265625, y: 0.953125 },
  { x: 0.265625, y: 0.953125 },
  { x: 0.296875, y: 0.953125 },
  { x: 0.296875, y: 0.953125 },
  { x: 0.328125, y: 0.953125 },
  { x: 0.328125, y: 0.953125 },
  { x: 0.359375, y: 0.953125 },
  { x: 0.359375, y: 0.953125 },
  { x: 0.390625, y: 0.953125 },
  { x: 0.390625, y: 0.953125 },
  { x: 0.421875, y: 0.953125 },
  { x: 0.421875, y: 0.953125 },
  { x: 0.453125, y: 0.953125 },
  { x: 0.453125, y: 0.953125 },
  { x: 0.484375, y: 0.953125 },
  { x: 0.484375, y: 0.953125 },
  { x: 0.515625, y: 0.953125 },
  { x: 0.515625, y: 0.953125 },
  { x: 0.546875, y: 0.953125 },
  { x: 0.546875, y: 0.953125 },
  { x: 0.578125, y: 0.953125 },
  { x: 0.578125, y: 0.953125 },
  { x: 0.609375, y: 0.953125 },
  { x: 0.609375, y: 0.953125 },
  { x: 0.640625, y: 0.953125 },
  { x: 0.640625, y: 0.953125 },
  { x: 0.671875, y: 0.953125 },
  { x: 0.671875, y: 0.953125 },
  { x: 0.703125, y: 0.953125 },
  { x: 0.703125, y: 0.953125 },
  { x: 0.734375, y: 0.953125 },
  { x: 0.734375, y: 0.953125 },
  { x: 0.765625, y: 0.953125 },
  { x: 0.765625, y: 0.953125 },
  { x: 0.796875, y: 0.953125 },
  { x: 0.796875, y: 0.953125 },
  { x: 0.828125, y: 0.953125 },
  { x: 0.828125, y: 0.953125 },
  { x: 0.859375, y: 0.953125 },
  { x: 0.859375, y: 0.953125 },
  { x: 0.890625, y: 0.953125 },
  { x: 0.890625, y: 0.953125 },
  { x: 0.921875, y: 0.953125 },
  { x: 0.921875, y: 0.953125 },
  { x: 0.953125, y: 0.953125 },
  { x: 0.953125, y: 0.953125 },
  { x: 0.984375, y: 0.953125 },
  { x: 0.984375, y: 0.953125 },
  { x: 0.015625, y: 0.984375 },
  { x: 0.015625, y: 0.984375 },
  { x: 0.046875, y: 0.984375 },
  { x: 0.046875, y: 0.984375 },
  { x: 0.078125, y: 0.984375 },
  { x: 0.078125, y: 0.984375 },
  { x: 0.109375, y: 0.984375 },
  { x: 0.109375, y: 0.984375 },
  { x: 0.140625, y: 0.984375 },
  { x: 0.140625, y: 0.984375 },
  { x: 0.171875, y: 0.984375 },
  { x: 0.171875, y: 0.984375 },
  { x: 0.203125, y: 0.984375 },
  { x: 0.203125, y: 0.984375 },
  { x: 0.234375, y: 0.984375 },
  { x: 0.234375, y: 0.984375 },
  { x: 0.265625, y: 0.984375 },
  { x: 0.265625, y: 0.984375 },
  { x: 0.296875, y: 0.984375 },
  { x: 0.296875, y: 0.984375 },
  { x: 0.328125, y: 0.984375 },
  { x: 0.328125, y: 0.984375 },
  { x: 0.359375, y: 0.984375 },
  { x: 0.359375, y: 0.984375 },
  { x: 0.390625, y: 0.984375 },
  { x: 0.390625, y: 0.984375 },
  { x: 0.421875, y: 0.984375 },
  { x: 0.421875, y: 0.984375 },
  { x: 0.453125, y: 0.984375 },
  { x: 0.453125, y: 0.984375 },
  { x: 0.484375, y: 0.984375 },
  { x: 0.484375, y: 0.984375 },
  { x: 0.515625, y: 0.984375 },
  { x: 0.515625, y: 0.984375 },
  { x: 0.546875, y: 0.984375 },
  { x: 0.546875, y: 0.984375 },
  { x: 0.578125, y: 0.984375 },
  { x: 0.578125, y: 0.984375 },
  { x: 0.609375, y: 0.984375 },
  { x: 0.609375, y: 0.984375 },
  { x: 0.640625, y: 0.984375 },
  { x: 0.640625, y: 0.984375 },
  { x: 0.671875, y: 0.984375 },
  { x: 0.671875, y: 0.984375 },
  { x: 0.703125, y: 0.984375 },
  { x: 0.703125, y: 0.984375 },
  { x: 0.734375, y: 0.984375 },
  { x: 0.734375, y: 0.984375 },
  { x: 0.765625, y: 0.984375 },
  { x: 0.765625, y: 0.984375 },
  { x: 0.796875, y: 0.984375 },
  { x: 0.796875, y: 0.984375 },
  { x: 0.828125, y: 0.984375 },
  { x: 0.828125, y: 0.984375 },
  { x: 0.859375, y: 0.984375 },
  { x: 0.859375, y: 0.984375 },
  { x: 0.890625, y: 0.984375 },
  { x: 0.890625, y: 0.984375 },
  { x: 0.921875, y: 0.984375 },
  { x: 0.921875, y: 0.984375 },
  { x: 0.953125, y: 0.984375 },
  { x: 0.953125, y: 0.984375 },
  { x: 0.984375, y: 0.984375 },
  { x: 0.984375, y: 0.984375 },
  { x: 0.03125, y: 0.03125 },
  { x: 0.03125, y: 0.03125 },
  { x: 0.09375, y: 0.03125 },
  { x: 0.09375, y: 0.03125 },
  { x: 0.15625, y: 0.03125 },
  { x: 0.15625, y: 0.03125 },
  { x: 0.21875, y: 0.03125 },
  { x: 0.21875, y: 0.03125 },
  { x: 0.28125, y: 0.03125 },
  { x: 0.28125, y: 0.03125 },
  { x: 0.34375, y: 0.03125 },
  { x: 0.34375, y: 0.03125 },
  { x: 0.40625, y: 0.03125 },
  { x: 0.40625, y: 0.03125 },
  { x: 0.46875, y: 0.03125 },
  { x: 0.46875, y: 0.03125 },
  { x: 0.53125, y: 0.03125 },
  { x: 0.53125, y: 0.03125 },
  { x: 0.59375, y: 0.03125 },
  { x: 0.59375, y: 0.03125 },
  { x: 0.65625, y: 0.03125 },
  { x: 0.65625, y: 0.03125 },
  { x: 0.71875, y: 0.03125 },
  { x: 0.71875, y: 0.03125 },
  { x: 0.78125, y: 0.03125 },
  { x: 0.78125, y: 0.03125 },
  { x: 0.84375, y: 0.03125 },
  { x: 0.84375, y: 0.03125 },
  { x: 0.90625, y: 0.03125 },
  { x: 0.90625, y: 0.03125 },
  { x: 0.96875, y: 0.03125 },
  { x: 0.96875, y: 0.03125 },
  { x: 0.03125, y: 0.09375 },
  { x: 0.03125, y: 0.09375 },
  { x: 0.09375, y: 0.09375 },
  { x: 0.09375, y: 0.09375 },
  { x: 0.15625, y: 0.09375 },
  { x: 0.15625, y: 0.09375 },
  { x: 0.21875, y: 0.09375 },
  { x: 0.21875, y: 0.09375 },
  { x: 0.28125, y: 0.09375 },
  { x: 0.28125, y: 0.09375 },
  { x: 0.34375, y: 0.09375 },
  { x: 0.34375, y: 0.09375 },
  { x: 0.40625, y: 0.09375 },
  { x: 0.40625, y: 0.09375 },
  { x: 0.46875, y: 0.09375 },
  { x: 0.46875, y: 0.09375 },
  { x: 0.53125, y: 0.09375 },
  { x: 0.53125, y: 0.09375 },
  { x: 0.59375, y: 0.09375 },
  { x: 0.59375, y: 0.09375 },
  { x: 0.65625, y: 0.09375 },
  { x: 0.65625, y: 0.09375 },
  { x: 0.71875, y: 0.09375 },
  { x: 0.71875, y: 0.09375 },
  { x: 0.78125, y: 0.09375 },
  { x: 0.78125, y: 0.09375 },
  { x: 0.84375, y: 0.09375 },
  { x: 0.84375, y: 0.09375 },
  { x: 0.90625, y: 0.09375 },
  { x: 0.90625, y: 0.09375 },
  { x: 0.96875, y: 0.09375 },
  { x: 0.96875, y: 0.09375 },
  { x: 0.03125, y: 0.15625 },
  { x: 0.03125, y: 0.15625 },
  { x: 0.09375, y: 0.15625 },
  { x: 0.09375, y: 0.15625 },
  { x: 0.15625, y: 0.15625 },
  { x: 0.15625, y: 0.15625 },
  { x: 0.21875, y: 0.15625 },
  { x: 0.21875, y: 0.15625 },
  { x: 0.28125, y: 0.15625 },
  { x: 0.28125, y: 0.15625 },
  { x: 0.34375, y: 0.15625 },
  { x: 0.34375, y: 0.15625 },
  { x: 0.40625, y: 0.15625 },
  { x: 0.40625, y: 0.15625 },
  { x: 0.46875, y: 0.15625 },
  { x: 0.46875, y: 0.15625 },
  { x: 0.53125, y: 0.15625 },
  { x: 0.53125, y: 0.15625 },
  { x: 0.59375, y: 0.15625 },
  { x: 0.59375, y: 0.15625 },
  { x: 0.65625, y: 0.15625 },
  { x: 0.65625, y: 0.15625 },
  { x: 0.71875, y: 0.15625 },
  { x: 0.71875, y: 0.15625 },
  { x: 0.78125, y: 0.15625 },
  { x: 0.78125, y: 0.15625 },
  { x: 0.84375, y: 0.15625 },
  { x: 0.84375, y: 0.15625 },
  { x: 0.90625, y: 0.15625 },
  { x: 0.90625, y: 0.15625 },
  { x: 0.96875, y: 0.15625 },
  { x: 0.96875, y: 0.15625 },
  { x: 0.03125, y: 0.21875 },
  { x: 0.03125, y: 0.21875 },
  { x: 0.09375, y: 0.21875 },
  { x: 0.09375, y: 0.21875 },
  { x: 0.15625, y: 0.21875 },
  { x: 0.15625, y: 0.21875 },
  { x: 0.21875, y: 0.21875 },
  { x: 0.21875, y: 0.21875 },
  { x: 0.28125, y: 0.21875 },
  { x: 0.28125, y: 0.21875 },
  { x: 0.34375, y: 0.21875 },
  { x: 0.34375, y: 0.21875 },
  { x: 0.40625, y: 0.21875 },
  { x: 0.40625, y: 0.21875 },
  { x: 0.46875, y: 0.21875 },
  { x: 0.46875, y: 0.21875 },
  { x: 0.53125, y: 0.21875 },
  { x: 0.53125, y: 0.21875 },
  { x: 0.59375, y: 0.21875 },
  { x: 0.59375, y: 0.21875 },
  { x: 0.65625, y: 0.21875 },
  { x: 0.65625, y: 0.21875 },
  { x: 0.71875, y: 0.21875 },
  { x: 0.71875, y: 0.21875 },
  { x: 0.78125, y: 0.21875 },
  { x: 0.78125, y: 0.21875 },
  { x: 0.84375, y: 0.21875 },
  { x: 0.84375, y: 0.21875 },
  { x: 0.90625, y: 0.21875 },
  { x: 0.90625, y: 0.21875 },
  { x: 0.96875, y: 0.21875 },
  { x: 0.96875, y: 0.21875 },
  { x: 0.03125, y: 0.28125 },
  { x: 0.03125, y: 0.28125 },
  { x: 0.09375, y: 0.28125 },
  { x: 0.09375, y: 0.28125 },
  { x: 0.15625, y: 0.28125 },
  { x: 0.15625, y: 0.28125 },
  { x: 0.21875, y: 0.28125 },
  { x: 0.21875, y: 0.28125 },
  { x: 0.28125, y: 0.28125 },
  { x: 0.28125, y: 0.28125 },
  { x: 0.34375, y: 0.28125 },
  { x: 0.34375, y: 0.28125 },
  { x: 0.40625, y: 0.28125 },
  { x: 0.40625, y: 0.28125 },
  { x: 0.46875, y: 0.28125 },
  { x: 0.46875, y: 0.28125 },
  { x: 0.53125, y: 0.28125 },
  { x: 0.53125, y: 0.28125 },
  { x: 0.59375, y: 0.28125 },
  { x: 0.59375, y: 0.28125 },
  { x: 0.65625, y: 0.28125 },
  { x: 0.65625, y: 0.28125 },
  { x: 0.71875, y: 0.28125 },
  { x: 0.71875, y: 0.28125 },
  { x: 0.78125, y: 0.28125 },
  { x: 0.78125, y: 0.28125 },
  { x: 0.84375, y: 0.28125 },
  { x: 0.84375, y: 0.28125 },
  { x: 0.90625, y: 0.28125 },
  { x: 0.90625, y: 0.28125 },
  { x: 0.96875, y: 0.28125 },
  { x: 0.96875, y: 0.28125 },
  { x: 0.03125, y: 0.34375 },
  { x: 0.03125, y: 0.34375 },
  { x: 0.09375, y: 0.34375 },
  { x: 0.09375, y: 0.34375 },
  { x: 0.15625, y: 0.34375 },
  { x: 0.15625, y: 0.34375 },
  { x: 0.21875, y: 0.34375 },
  { x: 0.21875, y: 0.34375 },
  { x: 0.28125, y: 0.34375 },
  { x: 0.28125, y: 0.34375 },
  { x: 0.34375, y: 0.34375 },
  { x: 0.34375, y: 0.34375 },
  { x: 0.40625, y: 0.34375 },
  { x: 0.40625, y: 0.34375 },
  { x: 0.46875, y: 0.34375 },
  { x: 0.46875, y: 0.34375 },
  { x: 0.53125, y: 0.34375 },
  { x: 0.53125, y: 0.34375 },
  { x: 0.59375, y: 0.34375 },
  { x: 0.59375, y: 0.34375 },
  { x: 0.65625, y: 0.34375 },
  { x: 0.65625, y: 0.34375 },
  { x: 0.71875, y: 0.34375 },
  { x: 0.71875, y: 0.34375 },
  { x: 0.78125, y: 0.34375 },
  { x: 0.78125, y: 0.34375 },
  { x: 0.84375, y: 0.34375 },
  { x: 0.84375, y: 0.34375 },
  { x: 0.90625, y: 0.34375 },
  { x: 0.90625, y: 0.34375 },
  { x: 0.96875, y: 0.34375 },
  { x: 0.96875, y: 0.34375 },
  { x: 0.03125, y: 0.40625 },
  { x: 0.03125, y: 0.40625 },
  { x: 0.09375, y: 0.40625 },
  { x: 0.09375, y: 0.40625 },
  { x: 0.15625, y: 0.40625 },
  { x: 0.15625, y: 0.40625 },
  { x: 0.21875, y: 0.40625 },
  { x: 0.21875, y: 0.40625 },
  { x: 0.28125, y: 0.40625 },
  { x: 0.28125, y: 0.40625 },
  { x: 0.34375, y: 0.40625 },
  { x: 0.34375, y: 0.40625 },
  { x: 0.40625, y: 0.40625 },
  { x: 0.40625, y: 0.40625 },
  { x: 0.46875, y: 0.40625 },
  { x: 0.46875, y: 0.40625 },
  { x: 0.53125, y: 0.40625 },
  { x: 0.53125, y: 0.40625 },
  { x: 0.59375, y: 0.40625 },
  { x: 0.59375, y: 0.40625 },
  { x: 0.65625, y: 0.40625 },
  { x: 0.65625, y: 0.40625 },
  { x: 0.71875, y: 0.40625 },
  { x: 0.71875, y: 0.40625 },
  { x: 0.78125, y: 0.40625 },
  { x: 0.78125, y: 0.40625 },
  { x: 0.84375, y: 0.40625 },
  { x: 0.84375, y: 0.40625 },
  { x: 0.90625, y: 0.40625 },
  { x: 0.90625, y: 0.40625 },
  { x: 0.96875, y: 0.40625 },
  { x: 0.96875, y: 0.40625 },
  { x: 0.03125, y: 0.46875 },
  { x: 0.03125, y: 0.46875 },
  { x: 0.09375, y: 0.46875 },
  { x: 0.09375, y: 0.46875 },
  { x: 0.15625, y: 0.46875 },
  { x: 0.15625, y: 0.46875 },
  { x: 0.21875, y: 0.46875 },
  { x: 0.21875, y: 0.46875 },
  { x: 0.28125, y: 0.46875 },
  { x: 0.28125, y: 0.46875 },
  { x: 0.34375, y: 0.46875 },
  { x: 0.34375, y: 0.46875 },
  { x: 0.40625, y: 0.46875 },
  { x: 0.40625, y: 0.46875 },
  { x: 0.46875, y: 0.46875 },
  { x: 0.46875, y: 0.46875 },
  { x: 0.53125, y: 0.46875 },
  { x: 0.53125, y: 0.46875 },
  { x: 0.59375, y: 0.46875 },
  { x: 0.59375, y: 0.46875 },
  { x: 0.65625, y: 0.46875 },
  { x: 0.65625, y: 0.46875 },
  { x: 0.71875, y: 0.46875 },
  { x: 0.71875, y: 0.46875 },
  { x: 0.78125, y: 0.46875 },
  { x: 0.78125, y: 0.46875 },
  { x: 0.84375, y: 0.46875 },
  { x: 0.84375, y: 0.46875 },
  { x: 0.90625, y: 0.46875 },
  { x: 0.90625, y: 0.46875 },
  { x: 0.96875, y: 0.46875 },
  { x: 0.96875, y: 0.46875 },
  { x: 0.03125, y: 0.53125 },
  { x: 0.03125, y: 0.53125 },
  { x: 0.09375, y: 0.53125 },
  { x: 0.09375, y: 0.53125 },
  { x: 0.15625, y: 0.53125 },
  { x: 0.15625, y: 0.53125 },
  { x: 0.21875, y: 0.53125 },
  { x: 0.21875, y: 0.53125 },
  { x: 0.28125, y: 0.53125 },
  { x: 0.28125, y: 0.53125 },
  { x: 0.34375, y: 0.53125 },
  { x: 0.34375, y: 0.53125 },
  { x: 0.40625, y: 0.53125 },
  { x: 0.40625, y: 0.53125 },
  { x: 0.46875, y: 0.53125 },
  { x: 0.46875, y: 0.53125 },
  { x: 0.53125, y: 0.53125 },
  { x: 0.53125, y: 0.53125 },
  { x: 0.59375, y: 0.53125 },
  { x: 0.59375, y: 0.53125 },
  { x: 0.65625, y: 0.53125 },
  { x: 0.65625, y: 0.53125 },
  { x: 0.71875, y: 0.53125 },
  { x: 0.71875, y: 0.53125 },
  { x: 0.78125, y: 0.53125 },
  { x: 0.78125, y: 0.53125 },
  { x: 0.84375, y: 0.53125 },
  { x: 0.84375, y: 0.53125 },
  { x: 0.90625, y: 0.53125 },
  { x: 0.90625, y: 0.53125 },
  { x: 0.96875, y: 0.53125 },
  { x: 0.96875, y: 0.53125 },
  { x: 0.03125, y: 0.59375 },
  { x: 0.03125, y: 0.59375 },
  { x: 0.09375, y: 0.59375 },
  { x: 0.09375, y: 0.59375 },
  { x: 0.15625, y: 0.59375 },
  { x: 0.15625, y: 0.59375 },
  { x: 0.21875, y: 0.59375 },
  { x: 0.21875, y: 0.59375 },
  { x: 0.28125, y: 0.59375 },
  { x: 0.28125, y: 0.59375 },
  { x: 0.34375, y: 0.59375 },
  { x: 0.34375, y: 0.59375 },
  { x: 0.40625, y: 0.59375 },
  { x: 0.40625, y: 0.59375 },
  { x: 0.46875, y: 0.59375 },
  { x: 0.46875, y: 0.59375 },
  { x: 0.53125, y: 0.59375 },
  { x: 0.53125, y: 0.59375 },
  { x: 0.59375, y: 0.59375 },
  { x: 0.59375, y: 0.59375 },
  { x: 0.65625, y: 0.59375 },
  { x: 0.65625, y: 0.59375 },
  { x: 0.71875, y: 0.59375 },
  { x: 0.71875, y: 0.59375 },
  { x: 0.78125, y: 0.59375 },
  { x: 0.78125, y: 0.59375 },
  { x: 0.84375, y: 0.59375 },
  { x: 0.84375, y: 0.59375 },
  { x: 0.90625, y: 0.59375 },
  { x: 0.90625, y: 0.59375 },
  { x: 0.96875, y: 0.59375 },
  { x: 0.96875, y: 0.59375 },
  { x: 0.03125, y: 0.65625 },
  { x: 0.03125, y: 0.65625 },
  { x: 0.09375, y: 0.65625 },
  { x: 0.09375, y: 0.65625 },
  { x: 0.15625, y: 0.65625 },
  { x: 0.15625, y: 0.65625 },
  { x: 0.21875, y: 0.65625 },
  { x: 0.21875, y: 0.65625 },
  { x: 0.28125, y: 0.65625 },
  { x: 0.28125, y: 0.65625 },
  { x: 0.34375, y: 0.65625 },
  { x: 0.34375, y: 0.65625 },
  { x: 0.40625, y: 0.65625 },
  { x: 0.40625, y: 0.65625 },
  { x: 0.46875, y: 0.65625 },
  { x: 0.46875, y: 0.65625 },
  { x: 0.53125, y: 0.65625 },
  { x: 0.53125, y: 0.65625 },
  { x: 0.59375, y: 0.65625 },
  { x: 0.59375, y: 0.65625 },
  { x: 0.65625, y: 0.65625 },
  { x: 0.65625, y: 0.65625 },
  { x: 0.71875, y: 0.65625 },
  { x: 0.71875, y: 0.65625 },
  { x: 0.78125, y: 0.65625 },
  { x: 0.78125, y: 0.65625 },
  { x: 0.84375, y: 0.65625 },
  { x: 0.84375, y: 0.65625 },
  { x: 0.90625, y: 0.65625 },
  { x: 0.90625, y: 0.65625 },
  { x: 0.96875, y: 0.65625 },
  { x: 0.96875, y: 0.65625 },
  { x: 0.03125, y: 0.71875 },
  { x: 0.03125, y: 0.71875 },
  { x: 0.09375, y: 0.71875 },
  { x: 0.09375, y: 0.71875 },
  { x: 0.15625, y: 0.71875 },
  { x: 0.15625, y: 0.71875 },
  { x: 0.21875, y: 0.71875 },
  { x: 0.21875, y: 0.71875 },
  { x: 0.28125, y: 0.71875 },
  { x: 0.28125, y: 0.71875 },
  { x: 0.34375, y: 0.71875 },
  { x: 0.34375, y: 0.71875 },
  { x: 0.40625, y: 0.71875 },
  { x: 0.40625, y: 0.71875 },
  { x: 0.46875, y: 0.71875 },
  { x: 0.46875, y: 0.71875 },
  { x: 0.53125, y: 0.71875 },
  { x: 0.53125, y: 0.71875 },
  { x: 0.59375, y: 0.71875 },
  { x: 0.59375, y: 0.71875 },
  { x: 0.65625, y: 0.71875 },
  { x: 0.65625, y: 0.71875 },
  { x: 0.71875, y: 0.71875 },
  { x: 0.71875, y: 0.71875 },
  { x: 0.78125, y: 0.71875 },
  { x: 0.78125, y: 0.71875 },
  { x: 0.84375, y: 0.71875 },
  { x: 0.84375, y: 0.71875 },
  { x: 0.90625, y: 0.71875 },
  { x: 0.90625, y: 0.71875 },
  { x: 0.96875, y: 0.71875 },
  { x: 0.96875, y: 0.71875 },
  { x: 0.03125, y: 0.78125 },
  { x: 0.03125, y: 0.78125 },
  { x: 0.09375, y: 0.78125 },
  { x: 0.09375, y: 0.78125 },
  { x: 0.15625, y: 0.78125 },
  { x: 0.15625, y: 0.78125 },
  { x: 0.21875, y: 0.78125 },
  { x: 0.21875, y: 0.78125 },
  { x: 0.28125, y: 0.78125 },
  { x: 0.28125, y: 0.78125 },
  { x: 0.34375, y: 0.78125 },
  { x: 0.34375, y: 0.78125 },
  { x: 0.40625, y: 0.78125 },
  { x: 0.40625, y: 0.78125 },
  { x: 0.46875, y: 0.78125 },
  { x: 0.46875, y: 0.78125 },
  { x: 0.53125, y: 0.78125 },
  { x: 0.53125, y: 0.78125 },
  { x: 0.59375, y: 0.78125 },
  { x: 0.59375, y: 0.78125 },
  { x: 0.65625, y: 0.78125 },
  { x: 0.65625, y: 0.78125 },
  { x: 0.71875, y: 0.78125 },
  { x: 0.71875, y: 0.78125 },
  { x: 0.78125, y: 0.78125 },
  { x: 0.78125, y: 0.78125 },
  { x: 0.84375, y: 0.78125 },
  { x: 0.84375, y: 0.78125 },
  { x: 0.90625, y: 0.78125 },
  { x: 0.90625, y: 0.78125 },
  { x: 0.96875, y: 0.78125 },
  { x: 0.96875, y: 0.78125 },
  { x: 0.03125, y: 0.84375 },
  { x: 0.03125, y: 0.84375 },
  { x: 0.09375, y: 0.84375 },
  { x: 0.09375, y: 0.84375 },
  { x: 0.15625, y: 0.84375 },
  { x: 0.15625, y: 0.84375 },
  { x: 0.21875, y: 0.84375 },
  { x: 0.21875, y: 0.84375 },
  { x: 0.28125, y: 0.84375 },
  { x: 0.28125, y: 0.84375 },
  { x: 0.34375, y: 0.84375 },
  { x: 0.34375, y: 0.84375 },
  { x: 0.40625, y: 0.84375 },
  { x: 0.40625, y: 0.84375 },
  { x: 0.46875, y: 0.84375 },
  { x: 0.46875, y: 0.84375 },
  { x: 0.53125, y: 0.84375 },
  { x: 0.53125, y: 0.84375 },
  { x: 0.59375, y: 0.84375 },
  { x: 0.59375, y: 0.84375 },
  { x: 0.65625, y: 0.84375 },
  { x: 0.65625, y: 0.84375 },
  { x: 0.71875, y: 0.84375 },
  { x: 0.71875, y: 0.84375 },
  { x: 0.78125, y: 0.84375 },
  { x: 0.78125, y: 0.84375 },
  { x: 0.84375, y: 0.84375 },
  { x: 0.84375, y: 0.84375 },
  { x: 0.90625, y: 0.84375 },
  { x: 0.90625, y: 0.84375 },
  { x: 0.96875, y: 0.84375 },
  { x: 0.96875, y: 0.84375 },
  { x: 0.03125, y: 0.90625 },
  { x: 0.03125, y: 0.90625 },
  { x: 0.09375, y: 0.90625 },
  { x: 0.09375, y: 0.90625 },
  { x: 0.15625, y: 0.90625 },
  { x: 0.15625, y: 0.90625 },
  { x: 0.21875, y: 0.90625 },
  { x: 0.21875, y: 0.90625 },
  { x: 0.28125, y: 0.90625 },
  { x: 0.28125, y: 0.90625 },
  { x: 0.34375, y: 0.90625 },
  { x: 0.34375, y: 0.90625 },
  { x: 0.40625, y: 0.90625 },
  { x: 0.40625, y: 0.90625 },
  { x: 0.46875, y: 0.90625 },
  { x: 0.46875, y: 0.90625 },
  { x: 0.53125, y: 0.90625 },
  { x: 0.53125, y: 0.90625 },
  { x: 0.59375, y: 0.90625 },
  { x: 0.59375, y: 0.90625 },
  { x: 0.65625, y: 0.90625 },
  { x: 0.65625, y: 0.90625 },
  { x: 0.71875, y: 0.90625 },
  { x: 0.71875, y: 0.90625 },
  { x: 0.78125, y: 0.90625 },
  { x: 0.78125, y: 0.90625 },
  { x: 0.84375, y: 0.90625 },
  { x: 0.84375, y: 0.90625 },
  { x: 0.90625, y: 0.90625 },
  { x: 0.90625, y: 0.90625 },
  { x: 0.96875, y: 0.90625 },
  { x: 0.96875, y: 0.90625 },
  { x: 0.03125, y: 0.96875 },
  { x: 0.03125, y: 0.96875 },
  { x: 0.09375, y: 0.96875 },
  { x: 0.09375, y: 0.96875 },
  { x: 0.15625, y: 0.96875 },
  { x: 0.15625, y: 0.96875 },
  { x: 0.21875, y: 0.96875 },
  { x: 0.21875, y: 0.96875 },
  { x: 0.28125, y: 0.96875 },
  { x: 0.28125, y: 0.96875 },
  { x: 0.34375, y: 0.96875 },
  { x: 0.34375, y: 0.96875 },
  { x: 0.40625, y: 0.96875 },
  { x: 0.40625, y: 0.96875 },
  { x: 0.46875, y: 0.96875 },
  { x: 0.46875, y: 0.96875 },
  { x: 0.53125, y: 0.96875 },
  { x: 0.53125, y: 0.96875 },
  { x: 0.59375, y: 0.96875 },
  { x: 0.59375, y: 0.96875 },
  { x: 0.65625, y: 0.96875 },
  { x: 0.65625, y: 0.96875 },
  { x: 0.71875, y: 0.96875 },
  { x: 0.71875, y: 0.96875 },
  { x: 0.78125, y: 0.96875 },
  { x: 0.78125, y: 0.96875 },
  { x: 0.84375, y: 0.96875 },
  { x: 0.84375, y: 0.96875 },
  { x: 0.90625, y: 0.96875 },
  { x: 0.90625, y: 0.96875 },
  { x: 0.96875, y: 0.96875 },
  { x: 0.96875, y: 0.96875 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.0625, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.1875, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.3125, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.4375, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.5625, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.6875, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.8125, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.9375, y: 0.0625 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.0625, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.1875, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.3125, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.4375, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.5625, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.6875, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.8125, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.9375, y: 0.1875 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.0625, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.1875, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.3125, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.4375, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.5625, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.6875, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.8125, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.9375, y: 0.3125 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.0625, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.1875, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.3125, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.4375, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.5625, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.6875, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.8125, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.9375, y: 0.4375 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.0625, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.1875, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.3125, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.4375, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.5625, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.6875, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.8125, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.9375, y: 0.5625 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.0625, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.1875, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.3125, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.4375, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.5625, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.6875, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.8125, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.9375, y: 0.6875 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.0625, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.1875, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.3125, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.4375, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.5625, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.6875, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.8125, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.9375, y: 0.8125 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.0625, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.1875, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.3125, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.4375, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.5625, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.6875, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.8125, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 },
  { x: 0.9375, y: 0.9375 }
];
var HandDetector = class {
  constructor(model182) {
    __publicField(this, "model");
    __publicField(this, "anchors");
    __publicField(this, "anchorsTensor");
    __publicField(this, "inputSize");
    __publicField(this, "inputSizeTensor");
    __publicField(this, "doubleInputSizeTensor");
    this.model = model182;
    this.anchors = anchors2.map((anchor) => [anchor.x, anchor.y]);
    this.anchorsTensor = ji(this.anchors);
    this.inputSize = this.model && this.model.inputs && this.model.inputs[0].shape ? this.model.inputs[0].shape[2] : 0;
    this.inputSizeTensor = Qt([this.inputSize, this.inputSize]);
    this.doubleInputSizeTensor = Qt([this.inputSize * 2, this.inputSize * 2]);
  }
  normalizeBoxes(boxes) {
    const t = {};
    t.boxOffsets = He(boxes, [0, 0], [-1, 2]);
    t.boxSizes = He(boxes, [0, 2], [-1, 2]);
    t.div = xe2(t.boxOffsets, this.inputSizeTensor);
    t.boxCenterPoints = ie2(t.div, this.anchorsTensor);
    t.halfBoxSizes = xe2(t.boxSizes, this.doubleInputSizeTensor);
    t.sub = ge2(t.boxCenterPoints, t.halfBoxSizes);
    t.startPoints = V2(t.sub, this.inputSizeTensor);
    t.add = ie2(t.boxCenterPoints, t.halfBoxSizes);
    t.endPoints = V2(t.add, this.inputSizeTensor);
    const res2 = FE([t.startPoints, t.endPoints], 1);
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    return res2;
  }
  normalizeLandmarks(rawPalmLandmarks, index2) {
    const t = {};
    t.reshape = G2(rawPalmLandmarks, [-1, 7, 2]);
    t.div = xe2(t.reshape, this.inputSizeTensor);
    t.landmarks = ie2(t.div, this.anchors[index2]);
    const res2 = V2(t.landmarks, this.inputSizeTensor);
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    return res2;
  }
  async predict(input, config3) {
    const t = {};
    t.resize = ds.resizeBilinear(input, [this.inputSize, this.inputSize]);
    t.div = xe2(t.resize, constants.tf127);
    t.image = ge2(t.div, constants.tf1);
    t.batched = this.model.execute(t.image);
    t.predictions = mr(t.batched);
    t.slice = He(t.predictions, [0, 0], [-1, 1]);
    t.sigmoid = qs(t.slice);
    t.scores = mr(t.sigmoid);
    const scores = await t.scores.data();
    t.boxes = He(t.predictions, [0, 1], [-1, 4]);
    t.norm = this.normalizeBoxes(t.boxes);
    t.nms = await ds.nonMaxSuppressionAsync(t.norm, t.scores, 3 * config3.hand.maxDetected, config3.hand.iouThreshold, config3.hand.minConfidence);
    const nms = await t.nms.array();
    const hands = [];
    for (const index2 of nms) {
      const p10 = {};
      p10.box = He(t.norm, [index2, 0], [1, -1]);
      p10.slice = He(t.predictions, [index2, 5], [1, 14]);
      p10.norm = this.normalizeLandmarks(p10.slice, index2);
      p10.palmLandmarks = G2(p10.norm, [-1, 2]);
      const box = await p10.box.data();
      const startPoint = box.slice(0, 2);
      const endPoint = box.slice(2, 4);
      const palmLandmarks = await p10.palmLandmarks.array();
      const hand3 = { startPoint, endPoint, palmLandmarks, confidence: scores[index2] };
      const scaled = scaleBoxCoordinates2(hand3, [input.shape[2] / this.inputSize, input.shape[1] / this.inputSize]);
      hands.push(scaled);
      Object.keys(p10).forEach((tensor) => Re2(p10[tensor]));
    }
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    return hands;
  }
};
var palmBoxEnlargeFactor = 5;
var handBoxEnlargeFactor = 1.65;
var palmLandmarkIds = [0, 5, 9, 13, 17, 1, 2];
var palmLandmarksPalmBase = 0;
var palmLandmarksMiddleFingerBase = 2;
var lastTime11 = 0;
var HandPipeline = class {
  constructor(handDetector, handPoseModel2) {
    __publicField(this, "handDetector");
    __publicField(this, "handPoseModel");
    __publicField(this, "inputSize");
    __publicField(this, "storedBoxes");
    __publicField(this, "skipped");
    __publicField(this, "detectedHands");
    this.handDetector = handDetector;
    this.handPoseModel = handPoseModel2;
    this.inputSize = this.handPoseModel && this.handPoseModel.inputs[0].shape ? this.handPoseModel.inputs[0].shape[2] : 0;
    this.storedBoxes = [];
    this.skipped = Number.MAX_SAFE_INTEGER;
    this.detectedHands = 0;
  }
  calculateLandmarksBoundingBox(landmarks) {
    const xs2 = landmarks.map((d10) => d10[0]);
    const ys2 = landmarks.map((d10) => d10[1]);
    const startPoint = [Math.min(...xs2), Math.min(...ys2)];
    const endPoint = [Math.max(...xs2), Math.max(...ys2)];
    return { startPoint, endPoint };
  }
  getBoxForPalmLandmarks(palmLandmarks, rotationMatrix) {
    const rotatedPalmLandmarks = palmLandmarks.map((coord) => rotatePoint2([...coord, 1], rotationMatrix));
    const boxAroundPalm = this.calculateLandmarksBoundingBox(rotatedPalmLandmarks);
    return enlargeBox2(squarifyBox2(boxAroundPalm), palmBoxEnlargeFactor);
  }
  getBoxForHandLandmarks(landmarks) {
    const boundingBox = this.calculateLandmarksBoundingBox(landmarks);
    const boxAroundHand = enlargeBox2(squarifyBox2(boundingBox), handBoxEnlargeFactor);
    boxAroundHand.palmLandmarks = [];
    for (let i10 = 0; i10 < palmLandmarkIds.length; i10++) {
      boxAroundHand.palmLandmarks.push(landmarks[palmLandmarkIds[i10]].slice(0, 2));
    }
    return boxAroundHand;
  }
  transformRawCoords(rawCoords, box2, angle2, rotationMatrix) {
    const boxSize = getBoxSize2(box2);
    const scaleFactor = [boxSize[0] / this.inputSize, boxSize[1] / this.inputSize, (boxSize[0] + boxSize[1]) / this.inputSize / 2];
    const coordsScaled = rawCoords.map((coord) => [
      scaleFactor[0] * (coord[0] - this.inputSize / 2),
      scaleFactor[1] * (coord[1] - this.inputSize / 2),
      scaleFactor[2] * coord[2]
    ]);
    const coordsRotationMatrix = buildRotationMatrix2(angle2, [0, 0]);
    const coordsRotated = coordsScaled.map((coord) => {
      const rotated = rotatePoint2(coord, coordsRotationMatrix);
      return [...rotated, coord[2]];
    });
    const inverseRotationMatrix = invertTransformMatrix2(rotationMatrix);
    const boxCenter = [...getBoxCenter2(box2), 1];
    const originalBoxCenter = [
      dot2(boxCenter, inverseRotationMatrix[0]),
      dot2(boxCenter, inverseRotationMatrix[1])
    ];
    return coordsRotated.map((coord) => [
      Math.trunc(coord[0] + originalBoxCenter[0]),
      Math.trunc(coord[1] + originalBoxCenter[1]),
      Math.trunc(coord[2])
    ]);
  }
  async estimateHands(image, config3) {
    let useFreshBox = false;
    let boxes;
    const skipTime = (config3.hand.skipTime || 0) > now2() - lastTime11;
    const skipFrame = this.skipped < (config3.hand.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame) {
      boxes = await this.handDetector.predict(image, config3);
      this.skipped = 0;
    }
    if (config3.skipAllowed)
      this.skipped++;
    if (boxes && boxes.length > 0 && (boxes.length !== this.detectedHands && this.detectedHands !== config3.hand.maxDetected || !config3.hand.landmarks)) {
      this.detectedHands = 0;
      this.storedBoxes = [...boxes];
      if (this.storedBoxes.length > 0)
        useFreshBox = true;
    }
    const hands = [];
    for (let i10 = 0; i10 < this.storedBoxes.length; i10++) {
      const currentBox = this.storedBoxes[i10];
      if (!currentBox)
        continue;
      if (config3.hand.landmarks) {
        const angle2 = config3.hand.rotation ? computeRotation2(currentBox.palmLandmarks[palmLandmarksPalmBase], currentBox.palmLandmarks[palmLandmarksMiddleFingerBase]) : 0;
        const palmCenter = getBoxCenter2(currentBox);
        const palmCenterNormalized = [palmCenter[0] / image.shape[2], palmCenter[1] / image.shape[1]];
        const rotatedImage = config3.hand.rotation && env.kernels.includes("rotatewithoffset") ? ds.rotateWithOffset(image, angle2, 0, palmCenterNormalized) : image.clone();
        const rotationMatrix = buildRotationMatrix2(-angle2, palmCenter);
        const newBox = useFreshBox ? this.getBoxForPalmLandmarks(currentBox.palmLandmarks, rotationMatrix) : currentBox;
        const croppedInput = cutBoxFromImageAndResize(newBox, rotatedImage, [this.inputSize, this.inputSize]);
        const handImage = xe2(croppedInput, constants.tf255);
        Re2(croppedInput);
        Re2(rotatedImage);
        const [confidenceT, keypoints] = this.handPoseModel.execute(handImage);
        lastTime11 = now2();
        Re2(handImage);
        const confidence = (await confidenceT.data())[0];
        Re2(confidenceT);
        if (confidence >= config3.hand.minConfidence / 4) {
          const keypointsReshaped = G2(keypoints, [-1, 3]);
          const rawCoords = await keypointsReshaped.array();
          Re2(keypoints);
          Re2(keypointsReshaped);
          const coords = this.transformRawCoords(rawCoords, newBox, angle2, rotationMatrix);
          const nextBoundingBox = this.getBoxForHandLandmarks(coords);
          this.storedBoxes[i10] = { ...nextBoundingBox, confidence };
          const result = {
            landmarks: coords,
            confidence,
            boxConfidence: currentBox.confidence,
            fingerConfidence: confidence,
            box: { topLeft: nextBoundingBox.startPoint, bottomRight: nextBoundingBox.endPoint }
          };
          hands.push(result);
        } else {
          this.storedBoxes[i10] = null;
        }
        Re2(keypoints);
      } else {
        const enlarged = enlargeBox2(squarifyBox2(currentBox), handBoxEnlargeFactor);
        const result = {
          confidence: currentBox.confidence,
          boxConfidence: currentBox.confidence,
          fingerConfidence: 0,
          box: { topLeft: enlarged.startPoint, bottomRight: enlarged.endPoint },
          landmarks: []
        };
        hands.push(result);
      }
    }
    this.storedBoxes = this.storedBoxes.filter((a10) => a10 !== null);
    this.detectedHands = hands.length;
    if (hands.length > config3.hand.maxDetected)
      hands.length = config3.hand.maxDetected;
    return hands;
  }
};
var Finger = {
  thumb: 0,
  index: 1,
  middle: 2,
  ring: 3,
  pinky: 4,
  all: [0, 1, 2, 3, 4],
  nameMapping: { 0: "thumb", 1: "index", 2: "middle", 3: "ring", 4: "pinky" },
  pointsMapping: {
    0: [[0, 1], [1, 2], [2, 3], [3, 4]],
    1: [[0, 5], [5, 6], [6, 7], [7, 8]],
    2: [[0, 9], [9, 10], [10, 11], [11, 12]],
    3: [[0, 13], [13, 14], [14, 15], [15, 16]],
    4: [[0, 17], [17, 18], [18, 19], [19, 20]]
  },
  getName: (value) => Finger.nameMapping[value],
  getPoints: (value) => Finger.pointsMapping[value]
};
var FingerCurl = {
  none: 0,
  half: 1,
  full: 2,
  nameMapping: { 0: "none", 1: "half", 2: "full" },
  getName: (value) => FingerCurl.nameMapping[value]
};
var FingerDirection = {
  verticalUp: 0,
  verticalDown: 1,
  horizontalLeft: 2,
  horizontalRight: 3,
  diagonalUpRight: 4,
  diagonalUpLeft: 5,
  diagonalDownRight: 6,
  diagonalDownLeft: 7,
  nameMapping: { 0: "verticalUp", 1: "verticalDown", 2: "horizontalLeft", 3: "horizontalRight", 4: "diagonalUpRight", 5: "diagonalUpLeft", 6: "diagonalDownRight", 7: "diagonalDownLeft" },
  getName: (value) => FingerDirection.nameMapping[value]
};
var FingerGesture = class {
  constructor(name) {
    __publicField(this, "name");
    __publicField(this, "curls");
    __publicField(this, "directions");
    __publicField(this, "weights");
    __publicField(this, "weightsRelative");
    this.name = name;
    this.curls = {};
    this.directions = {};
    this.weights = [1, 1, 1, 1, 1];
    this.weightsRelative = [1, 1, 1, 1, 1];
  }
  curl(finger, curl, confidence) {
    if (typeof this.curls[finger] === "undefined")
      this.curls[finger] = [];
    this.curls[finger].push([curl, confidence]);
  }
  direction(finger, position, confidence) {
    if (!this.directions[finger])
      this.directions[finger] = [];
    this.directions[finger].push([position, confidence]);
  }
  weight(finger, weight) {
    this.weights[finger] = weight;
    const total = this.weights.reduce((a10, b10) => a10 + b10, 0);
    this.weightsRelative = this.weights.map((el2) => el2 * 5 / total);
  }
  matchAgainst(detectedCurls, detectedDirections) {
    let confidence = 0;
    for (const fingerIdx in detectedCurls) {
      const detectedCurl = detectedCurls[fingerIdx];
      const expectedCurls = this.curls[fingerIdx];
      if (typeof expectedCurls === "undefined") {
        confidence += this.weightsRelative[fingerIdx];
        continue;
      }
      for (const [expectedCurl, score] of expectedCurls) {
        if (detectedCurl === expectedCurl) {
          confidence += score * this.weightsRelative[fingerIdx];
          break;
        }
      }
    }
    for (const fingerIdx in detectedDirections) {
      const detectedDirection = detectedDirections[fingerIdx];
      const expectedDirections = this.directions[fingerIdx];
      if (typeof expectedDirections === "undefined") {
        confidence += this.weightsRelative[fingerIdx];
        continue;
      }
      for (const [expectedDirection, score] of expectedDirections) {
        if (detectedDirection === expectedDirection) {
          confidence += score * this.weightsRelative[fingerIdx];
          break;
        }
      }
    }
    return confidence / 10;
  }
};
var { thumb, index, middle, ring, pinky } = Finger;
var { none, half, full } = FingerCurl;
var { verticalUp, verticalDown, horizontalLeft, horizontalRight, diagonalUpRight, diagonalUpLeft, diagonalDownRight, diagonalDownLeft } = FingerDirection;
var ThumbsUp = new FingerGesture("thumbs up");
ThumbsUp.curl(thumb, none, 1);
ThumbsUp.direction(thumb, verticalUp, 1);
ThumbsUp.direction(thumb, diagonalUpLeft, 0.25);
ThumbsUp.direction(thumb, diagonalUpRight, 0.25);
for (const finger of [Finger.index, Finger.middle, Finger.ring, Finger.pinky]) {
  ThumbsUp.curl(finger, full, 1);
  ThumbsUp.direction(finger, horizontalLeft, 1);
  ThumbsUp.direction(finger, horizontalRight, 1);
}
var Victory = new FingerGesture("victory");
Victory.curl(thumb, half, 0.5);
Victory.curl(thumb, none, 0.5);
Victory.direction(thumb, verticalUp, 1);
Victory.direction(thumb, diagonalUpLeft, 1);
Victory.curl(index, none, 1);
Victory.direction(index, verticalUp, 0.75);
Victory.direction(index, diagonalUpLeft, 1);
Victory.curl(middle, none, 1);
Victory.direction(middle, verticalUp, 1);
Victory.direction(middle, diagonalUpLeft, 0.75);
Victory.curl(ring, full, 1);
Victory.direction(ring, verticalUp, 0.2);
Victory.direction(ring, diagonalUpLeft, 1);
Victory.direction(ring, horizontalLeft, 0.2);
Victory.curl(pinky, full, 1);
Victory.direction(pinky, verticalUp, 0.2);
Victory.direction(pinky, diagonalUpLeft, 1);
Victory.direction(pinky, horizontalLeft, 0.2);
Victory.weight(index, 2);
Victory.weight(middle, 2);
var Point = new FingerGesture("point");
Point.curl(thumb, full, 1);
Point.curl(index, none, 0.5);
Point.curl(middle, full, 0.5);
Point.curl(ring, full, 0.5);
Point.curl(pinky, full, 0.5);
Point.weight(index, 2);
Point.weight(middle, 2);
var MiddleFinger = new FingerGesture("middle finger");
MiddleFinger.curl(thumb, none, 1);
MiddleFinger.curl(index, full, 0.5);
MiddleFinger.curl(middle, full, 0.5);
MiddleFinger.curl(ring, full, 0.5);
MiddleFinger.curl(pinky, full, 0.5);
MiddleFinger.weight(index, 2);
MiddleFinger.weight(middle, 2);
var OpenPalm = new FingerGesture("open palm");
OpenPalm.curl(thumb, none, 0.75);
OpenPalm.curl(index, none, 0.75);
OpenPalm.curl(middle, none, 0.75);
OpenPalm.curl(ring, none, 0.75);
OpenPalm.curl(pinky, none, 0.75);
var fingergesture_default = [ThumbsUp, Victory, Point, MiddleFinger, OpenPalm];
var minConfidence = 0.7;
var options2 = {
  HALF_CURL_START_LIMIT: 60,
  NO_CURL_START_LIMIT: 130,
  DISTANCE_VOTE_POWER: 1.1,
  SINGLE_ANGLE_VOTE_POWER: 0.9,
  TOTAL_ANGLE_VOTE_POWER: 1.6
};
function calculateSlope(point1x, point1y, point2x, point2y) {
  const value = (point1y - point2y) / (point1x - point2x);
  let slope = Math.atan(value) * 180 / Math.PI;
  if (slope <= 0)
    slope = -slope;
  else if (slope > 0)
    slope = 180 - slope;
  return slope;
}
function getSlopes(point1, point2) {
  if (!point1 || !point2)
    return [0, 0];
  const slopeXY = calculateSlope(point1[0], point1[1], point2[0], point2[1]);
  if (point1.length === 2)
    return slopeXY;
  const slopeYZ = calculateSlope(point1[1], point1[2], point2[1], point2[2]);
  return [slopeXY, slopeYZ];
}
function angleOrientationAt(angle2, weightageAt = 1) {
  let isVertical = 0;
  let isDiagonal = 0;
  let isHorizontal = 0;
  if (angle2 >= 75 && angle2 <= 105)
    isVertical = 1 * weightageAt;
  else if (angle2 >= 25 && angle2 <= 155)
    isDiagonal = 1 * weightageAt;
  else
    isHorizontal = 1 * weightageAt;
  return [isVertical, isDiagonal, isHorizontal];
}
function estimateFingerCurl(startPoint, midPoint, endPoint) {
  const start_mid_x_dist = startPoint[0] - midPoint[0];
  const start_end_x_dist = startPoint[0] - endPoint[0];
  const mid_end_x_dist = midPoint[0] - endPoint[0];
  const start_mid_y_dist = startPoint[1] - midPoint[1];
  const start_end_y_dist = startPoint[1] - endPoint[1];
  const mid_end_y_dist = midPoint[1] - endPoint[1];
  const start_mid_z_dist = startPoint[2] - midPoint[2];
  const start_end_z_dist = startPoint[2] - endPoint[2];
  const mid_end_z_dist = midPoint[2] - endPoint[2];
  const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist + start_mid_z_dist * start_mid_z_dist);
  const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist + start_end_z_dist * start_end_z_dist);
  const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist + mid_end_z_dist * mid_end_z_dist);
  let cos_in = (mid_end_dist * mid_end_dist + start_mid_dist * start_mid_dist - start_end_dist * start_end_dist) / (2 * mid_end_dist * start_mid_dist);
  if (cos_in > 1)
    cos_in = 1;
  else if (cos_in < -1)
    cos_in = -1;
  let angleOfCurve = Math.acos(cos_in);
  angleOfCurve = 57.2958 * angleOfCurve % 180;
  let fingerCurl;
  if (angleOfCurve > options2.NO_CURL_START_LIMIT)
    fingerCurl = FingerCurl.none;
  else if (angleOfCurve > options2.HALF_CURL_START_LIMIT)
    fingerCurl = FingerCurl.half;
  else
    fingerCurl = FingerCurl.full;
  return fingerCurl;
}
function estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
  let estimatedDirection;
  if (max_dist_x === Math.abs(start_end_x_dist)) {
    if (start_end_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  } else if (max_dist_x === Math.abs(start_mid_x_dist)) {
    if (start_mid_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  } else {
    if (mid_end_x_dist > 0)
      estimatedDirection = FingerDirection.horizontalLeft;
    else
      estimatedDirection = FingerDirection.horizontalRight;
  }
  return estimatedDirection;
}
function estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y) {
  let estimatedDirection;
  if (max_dist_y === Math.abs(start_end_y_dist)) {
    if (start_end_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  } else if (max_dist_y === Math.abs(start_mid_y_dist)) {
    if (start_mid_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  } else {
    if (mid_end_y_dist < 0)
      estimatedDirection = FingerDirection.verticalDown;
    else
      estimatedDirection = FingerDirection.verticalUp;
  }
  return estimatedDirection;
}
function estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
  let estimatedDirection;
  const reqd_vertical_direction = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
  const reqd_horizontal_direction = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  if (reqd_vertical_direction === FingerDirection.verticalUp) {
    if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
      estimatedDirection = FingerDirection.diagonalUpLeft;
    else
      estimatedDirection = FingerDirection.diagonalUpRight;
  } else {
    if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
      estimatedDirection = FingerDirection.diagonalDownLeft;
    else
      estimatedDirection = FingerDirection.diagonalDownRight;
  }
  return estimatedDirection;
}
function calculateFingerDirection(startPoint, midPoint, endPoint, fingerSlopes) {
  const start_mid_x_dist = startPoint[0] - midPoint[0];
  const start_end_x_dist = startPoint[0] - endPoint[0];
  const mid_end_x_dist = midPoint[0] - endPoint[0];
  const start_mid_y_dist = startPoint[1] - midPoint[1];
  const start_end_y_dist = startPoint[1] - endPoint[1];
  const mid_end_y_dist = midPoint[1] - endPoint[1];
  const max_dist_x = Math.max(Math.abs(start_mid_x_dist), Math.abs(start_end_x_dist), Math.abs(mid_end_x_dist));
  const max_dist_y = Math.max(Math.abs(start_mid_y_dist), Math.abs(start_end_y_dist), Math.abs(mid_end_y_dist));
  let voteVertical = 0;
  let voteDiagonal = 0;
  let voteHorizontal = 0;
  const start_end_x_y_dist_ratio = max_dist_y / (max_dist_x + 1e-5);
  if (start_end_x_y_dist_ratio > 1.5)
    voteVertical += options2.DISTANCE_VOTE_POWER;
  else if (start_end_x_y_dist_ratio > 0.66)
    voteDiagonal += options2.DISTANCE_VOTE_POWER;
  else
    voteHorizontal += options2.DISTANCE_VOTE_POWER;
  const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist);
  const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist);
  const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist);
  const max_dist = Math.max(start_mid_dist, start_end_dist, mid_end_dist);
  let calc_start_point_x = startPoint[0];
  let calc_start_point_y = startPoint[1];
  let calc_end_point_x = endPoint[0];
  let calc_end_point_y = endPoint[1];
  if (max_dist === start_mid_dist) {
    calc_end_point_x = endPoint[0];
    calc_end_point_y = endPoint[1];
  } else if (max_dist === mid_end_dist) {
    calc_start_point_x = midPoint[0];
    calc_start_point_y = midPoint[1];
  }
  const calcStartPoint = [calc_start_point_x, calc_start_point_y];
  const calcEndPoint = [calc_end_point_x, calc_end_point_y];
  const totalAngle = getSlopes(calcStartPoint, calcEndPoint);
  const votes = angleOrientationAt(totalAngle, options2.TOTAL_ANGLE_VOTE_POWER);
  voteVertical += votes[0];
  voteDiagonal += votes[1];
  voteHorizontal += votes[2];
  for (const fingerSlope of fingerSlopes) {
    const fingerVotes = angleOrientationAt(fingerSlope, options2.SINGLE_ANGLE_VOTE_POWER);
    voteVertical += fingerVotes[0];
    voteDiagonal += fingerVotes[1];
    voteHorizontal += fingerVotes[2];
  }
  let estimatedDirection;
  if (voteVertical === Math.max(voteVertical, voteDiagonal, voteHorizontal)) {
    estimatedDirection = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
  } else if (voteHorizontal === Math.max(voteDiagonal, voteHorizontal)) {
    estimatedDirection = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  } else {
    estimatedDirection = estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
  }
  return estimatedDirection;
}
function estimate(landmarks) {
  const slopesXY = [];
  const slopesYZ = [];
  const fingerCurls = [];
  const fingerDirections = [];
  if (!landmarks)
    return { curls: fingerCurls, directions: fingerDirections };
  for (const finger of Finger.all) {
    const points = Finger.getPoints(finger);
    const slopeAtXY = [];
    const slopeAtYZ = [];
    for (const point2 of points) {
      const point1 = landmarks[point2[0]];
      const point22 = landmarks[point2[1]];
      const slopes = getSlopes(point1, point22);
      const slopeXY = slopes[0];
      const slopeYZ = slopes[1];
      slopeAtXY.push(slopeXY);
      slopeAtYZ.push(slopeYZ);
    }
    slopesXY.push(slopeAtXY);
    slopesYZ.push(slopeAtYZ);
  }
  for (const finger of Finger.all) {
    const pointIndexAt = finger === Finger.thumb ? 1 : 0;
    const fingerPointsAt = Finger.getPoints(finger);
    const startPoint = landmarks[fingerPointsAt[pointIndexAt][0]];
    const midPoint = landmarks[fingerPointsAt[pointIndexAt + 1][1]];
    const endPoint = landmarks[fingerPointsAt[3][1]];
    const fingerCurled = estimateFingerCurl(startPoint, midPoint, endPoint);
    const fingerPosition = calculateFingerDirection(startPoint, midPoint, endPoint, slopesXY[finger].slice(pointIndexAt));
    fingerCurls[finger] = fingerCurled;
    fingerDirections[finger] = fingerPosition;
  }
  return { curls: fingerCurls, directions: fingerDirections };
}
function analyze(keypoints) {
  if (!keypoints || keypoints.length === 0)
    return null;
  const estimatorRes = estimate(keypoints);
  const landmarks = {};
  for (const fingerIdx of Finger.all) {
    landmarks[Finger.getName(fingerIdx)] = {
      curl: FingerCurl.getName(estimatorRes.curls[fingerIdx]),
      direction: FingerDirection.getName(estimatorRes.directions[fingerIdx])
    };
  }
  return landmarks;
}
function match(keypoints) {
  const poses = [];
  if (!keypoints || keypoints.length === 0)
    return poses;
  const estimatorRes = estimate(keypoints);
  for (const gesture2 of fingergesture_default) {
    const confidence = gesture2.matchAgainst(estimatorRes.curls, estimatorRes.directions);
    if (confidence >= minConfidence)
      poses.push({ name: gesture2.name, confidence });
  }
  return poses;
}
var meshAnnotations2 = {
  thumb: [1, 2, 3, 4],
  index: [5, 6, 7, 8],
  middle: [9, 10, 11, 12],
  ring: [13, 14, 15, 16],
  pinky: [17, 18, 19, 20],
  palm: [0]
};
var handDetectorModel;
var handPoseModel;
var handPipeline;
async function predict12(input, config3) {
  const predictions = await handPipeline.estimateHands(input, config3);
  if (!predictions)
    return [];
  const hands = [];
  for (let i10 = 0; i10 < predictions.length; i10++) {
    const annotations2 = {};
    if (predictions[i10].landmarks) {
      for (const key of Object.keys(meshAnnotations2)) {
        annotations2[key] = meshAnnotations2[key].map((index2) => predictions[i10].landmarks[index2]);
      }
    }
    const keypoints = predictions[i10].landmarks;
    let box = [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0, 0];
    let boxRaw = [0, 0, 0, 0];
    if (keypoints && keypoints.length > 0) {
      for (const pt2 of keypoints) {
        if (pt2[0] < box[0])
          box[0] = pt2[0];
        if (pt2[1] < box[1])
          box[1] = pt2[1];
        if (pt2[0] > box[2])
          box[2] = pt2[0];
        if (pt2[1] > box[3])
          box[3] = pt2[1];
      }
      box[2] -= box[0];
      box[3] -= box[1];
      boxRaw = [box[0] / (input.shape[2] || 0), box[1] / (input.shape[1] || 0), box[2] / (input.shape[2] || 0), box[3] / (input.shape[1] || 0)];
    } else {
      box = predictions[i10].box ? [
        Math.trunc(Math.max(0, predictions[i10].box.topLeft[0])),
        Math.trunc(Math.max(0, predictions[i10].box.topLeft[1])),
        Math.trunc(Math.min(input.shape[2] || 0, predictions[i10].box.bottomRight[0]) - Math.max(0, predictions[i10].box.topLeft[0])),
        Math.trunc(Math.min(input.shape[1] || 0, predictions[i10].box.bottomRight[1]) - Math.max(0, predictions[i10].box.topLeft[1]))
      ] : [0, 0, 0, 0];
      boxRaw = [
        predictions[i10].box.topLeft[0] / (input.shape[2] || 0),
        predictions[i10].box.topLeft[1] / (input.shape[1] || 0),
        (predictions[i10].box.bottomRight[0] - predictions[i10].box.topLeft[0]) / (input.shape[2] || 0),
        (predictions[i10].box.bottomRight[1] - predictions[i10].box.topLeft[1]) / (input.shape[1] || 0)
      ];
    }
    const landmarks = analyze(keypoints);
    hands.push({
      id: i10,
      score: Math.round(100 * predictions[i10].confidence) / 100,
      boxScore: Math.round(100 * predictions[i10].boxConfidence) / 100,
      fingerScore: Math.round(100 * predictions[i10].fingerConfidence) / 100,
      label: "hand",
      box,
      boxRaw,
      keypoints,
      annotations: annotations2,
      landmarks
    });
  }
  return hands;
}
async function load13(config3) {
  var _a2, _b2;
  if (env.initial) {
    handDetectorModel = null;
    handPoseModel = null;
  }
  if (!handDetectorModel || !handPoseModel) {
    [handDetectorModel, handPoseModel] = await Promise.all([
      config3.hand.enabled ? loadModel((_a2 = config3.hand.detector) == null ? void 0 : _a2.modelPath) : null,
      config3.hand.landmarks ? loadModel((_b2 = config3.hand.skeleton) == null ? void 0 : _b2.modelPath) : null
    ]);
  } else {
    if (config3.debug)
      log("cached model:", handDetectorModel["modelUrl"]);
    if (config3.debug)
      log("cached model:", handPoseModel["modelUrl"]);
  }
  const handDetector = new HandDetector(handDetectorModel);
  handPipeline = new HandPipeline(handDetector, handPoseModel);
  return [handDetectorModel, handPoseModel];
}
var models2 = [null, null];
var modelOutputNodes = ["StatefulPartitionedCall/Postprocessor/Slice", "StatefulPartitionedCall/Postprocessor/ExpandDims_1"];
var inputSize7 = [[0, 0], [0, 0]];
var classes = ["hand", "fist", "pinch", "point", "face", "tip", "pinchtip"];
var faceIndex = 4;
var boxExpandFact = 1.6;
var maxDetectorResolution = 512;
var detectorExpandFact = 1.4;
var skipped11 = Number.MAX_SAFE_INTEGER;
var lastTime12 = 0;
var outputSize = [0, 0];
var cache4 = {
  boxes: [],
  hands: []
};
var fingerMap = {
  thumb: [1, 2, 3, 4],
  index: [5, 6, 7, 8],
  middle: [9, 10, 11, 12],
  ring: [13, 14, 15, 16],
  pinky: [17, 18, 19, 20],
  base: [0],
  palm: [0, 17, 13, 9, 5, 1, 0]
};
async function loadDetect2(config3) {
  var _a2;
  if (env.initial)
    models2[0] = null;
  if (!models2[0]) {
    fakeOps(["tensorlistreserve", "enter", "tensorlistfromtensor", "merge", "loopcond", "switch", "exit", "tensorliststack", "nextiteration", "tensorlistsetitem", "tensorlistgetitem", "reciprocal", "shape", "split", "where"], config3);
    models2[0] = await loadModel((_a2 = config3.hand.detector) == null ? void 0 : _a2.modelPath);
    const inputs = Object.values(models2[0].modelSignature["inputs"]);
    inputSize7[0][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize7[0][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug)
    log("cached model:", models2[0]["modelUrl"]);
  return models2[0];
}
async function loadSkeleton(config3) {
  var _a2;
  if (env.initial)
    models2[1] = null;
  if (!models2[1]) {
    models2[1] = await loadModel((_a2 = config3.hand.skeleton) == null ? void 0 : _a2.modelPath);
    const inputs = Object.values(models2[1].modelSignature["inputs"]);
    inputSize7[1][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    inputSize7[1][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug)
    log("cached model:", models2[1]["modelUrl"]);
  return models2[1];
}
async function detectHands(input, config3) {
  const hands = [];
  if (!input || !models2[0])
    return hands;
  const t = {};
  const ratio = (input.shape[2] || 1) / (input.shape[1] || 1);
  const height = Math.min(Math.round((input.shape[1] || 0) / 8) * 8, maxDetectorResolution);
  const width = Math.round(height * ratio / 8) * 8;
  t.resize = ds.resizeBilinear(input, [height, width]);
  t.cast = ce2(t.resize, "int32");
  [t.rawScores, t.rawBoxes] = await models2[0].executeAsync(t.cast, modelOutputNodes);
  t.boxes = mr(t.rawBoxes, [0, 2]);
  t.scores = mr(t.rawScores, [0]);
  const classScores = Fs(t.scores, 1);
  Re2(classScores[faceIndex]);
  classScores.splice(faceIndex, 1);
  t.filtered = Qn(classScores, 1);
  Re2(classScores);
  t.max = As(t.filtered, 1);
  t.argmax = Gu(t.filtered, 1);
  let id2 = 0;
  t.nms = await ds.nonMaxSuppressionAsync(t.boxes, t.max, (config3.hand.maxDetected || 0) + 1, config3.hand.iouThreshold || 0, config3.hand.minConfidence || 1);
  const nms = await t.nms.data();
  const scores = await t.max.data();
  const classNum = await t.argmax.data();
  for (const nmsIndex of Array.from(nms)) {
    const boxSlice = He(t.boxes, nmsIndex, 1);
    const boxYX = await boxSlice.data();
    Re2(boxSlice);
    const boxData = [boxYX[1], boxYX[0], boxYX[3] - boxYX[1], boxYX[2] - boxYX[0]];
    const boxRaw = scale(boxData, detectorExpandFact);
    const boxFull = [Math.trunc(boxData[0] * outputSize[0]), Math.trunc(boxData[1] * outputSize[1]), Math.trunc(boxData[2] * outputSize[0]), Math.trunc(boxData[3] * outputSize[1])];
    const score = scores[nmsIndex];
    const label = classes[classNum[nmsIndex]];
    const hand3 = { id: id2++, score, box: boxFull, boxRaw, label };
    hands.push(hand3);
  }
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  hands.sort((a10, b10) => b10.score - a10.score);
  if (hands.length > (config3.hand.maxDetected || 1))
    hands.length = config3.hand.maxDetected || 1;
  return hands;
}
async function detectFingers(input, h10, config3) {
  const hand3 = {
    id: h10.id,
    score: Math.round(100 * h10.score) / 100,
    boxScore: Math.round(100 * h10.score) / 100,
    fingerScore: 0,
    box: h10.box,
    boxRaw: h10.boxRaw,
    label: h10.label,
    keypoints: [],
    landmarks: {},
    annotations: {}
  };
  if (input && models2[1] && config3.hand.landmarks && h10.score > (config3.hand.minConfidence || 0)) {
    const t = {};
    const boxCrop = [h10.boxRaw[1], h10.boxRaw[0], h10.boxRaw[3] + h10.boxRaw[1], h10.boxRaw[2] + h10.boxRaw[0]];
    t.crop = ds.cropAndResize(input, [boxCrop], [0], [inputSize7[1][0], inputSize7[1][1]], "bilinear");
    t.div = xe2(t.crop, constants.tf255);
    [t.score, t.keypoints] = models2[1].execute(t.div, ["Identity_1", "Identity"]);
    const rawScore = (await t.score.data())[0];
    const score = (100 - Math.trunc(100 / (1 + Math.exp(rawScore)))) / 100;
    if (score >= (config3.hand.minConfidence || 0)) {
      hand3.fingerScore = score;
      t.reshaped = G2(t.keypoints, [-1, 3]);
      const coordsData = await t.reshaped.array();
      const coordsRaw = coordsData.map((kpt4) => [kpt4[0] / inputSize7[1][1], kpt4[1] / inputSize7[1][0], kpt4[2] || 0]);
      const coordsNorm = coordsRaw.map((kpt4) => [kpt4[0] * h10.boxRaw[2], kpt4[1] * h10.boxRaw[3], kpt4[2] || 0]);
      hand3.keypoints = coordsNorm.map((kpt4) => [outputSize[0] * (kpt4[0] + h10.boxRaw[0]), outputSize[1] * (kpt4[1] + h10.boxRaw[1]), kpt4[2] || 0]);
      hand3.landmarks = analyze(hand3.keypoints);
      for (const key of Object.keys(fingerMap)) {
        hand3.annotations[key] = fingerMap[key].map((index2) => hand3.landmarks && hand3.keypoints[index2] ? hand3.keypoints[index2] : null);
      }
    }
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  }
  return hand3;
}
async function predict13(input, config3) {
  var _a2, _b2;
  if (!models2[0] || !models2[1] || !((_a2 = models2[0]) == null ? void 0 : _a2.inputs[0].shape) || !((_b2 = models2[1]) == null ? void 0 : _b2.inputs[0].shape))
    return [];
  outputSize = [input.shape[2] || 0, input.shape[1] || 0];
  skipped11++;
  const skipTime = (config3.hand.skipTime || 0) > now2() - lastTime12;
  const skipFrame = skipped11 < (config3.hand.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame) {
    return cache4.hands;
  }
  return new Promise(async (resolve) => {
    const skipTimeExtended = 3 * (config3.hand.skipTime || 0) > now2() - lastTime12;
    const skipFrameExtended = skipped11 < 3 * (config3.hand.skipFrames || 0);
    if (config3.skipAllowed && cache4.hands.length === config3.hand.maxDetected) {
      cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
    } else if (config3.skipAllowed && skipTimeExtended && skipFrameExtended && cache4.hands.length > 0) {
      cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
    } else {
      cache4.boxes = await detectHands(input, config3);
      lastTime12 = now2();
      cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
      skipped11 = 0;
    }
    const oldCache = [...cache4.boxes];
    cache4.boxes.length = 0;
    if (config3.cacheSensitivity > 0) {
      for (let i10 = 0; i10 < cache4.hands.length; i10++) {
        const boxKpt = square(cache4.hands[i10].keypoints, outputSize);
        if (boxKpt.box[2] / (input.shape[2] || 1) > 0.05 && boxKpt.box[3] / (input.shape[1] || 1) > 0.05 && cache4.hands[i10].fingerScore && cache4.hands[i10].fingerScore > (config3.hand.minConfidence || 0)) {
          const boxScale = scale(boxKpt.box, boxExpandFact);
          const boxScaleRaw = scale(boxKpt.boxRaw, boxExpandFact);
          cache4.boxes.push({ ...oldCache[i10], box: boxScale, boxRaw: boxScaleRaw });
        }
      }
    }
    for (let i10 = 0; i10 < cache4.hands.length; i10++) {
      const bbox = calc(cache4.hands[i10].keypoints, outputSize);
      cache4.hands[i10].box = bbox.box;
      cache4.hands[i10].boxRaw = bbox.boxRaw;
    }
    resolve(cache4.hands);
  });
}
var model13;
var cached2 = [];
var skipped12 = Number.MAX_SAFE_INTEGER;
var lastCount8 = 0;
var lastTime13 = 0;
async function load14(config3) {
  var _a2;
  if (env.initial)
    model13 = null;
  if (!model13)
    model13 = await loadModel((_a2 = config3.face.liveness) == null ? void 0 : _a2.modelPath);
  else if (config3.debug)
    log("cached model:", model13["modelUrl"]);
  return model13;
}
async function predict14(image, config3, idx, count2) {
  var _a2, _b2;
  if (!model13)
    return 0;
  const skipTime = (((_a2 = config3.face.liveness) == null ? void 0 : _a2.skipTime) || 0) > now2() - lastTime13;
  const skipFrame = skipped12 < (((_b2 = config3.face.liveness) == null ? void 0 : _b2.skipFrames) || 0);
  if (config3.skipAllowed && skipTime && skipFrame && lastCount8 === count2 && cached2[idx]) {
    skipped12++;
    return cached2[idx];
  }
  skipped12 = 0;
  return new Promise(async (resolve) => {
    const resize = ds.resizeBilinear(image, [(model13 == null ? void 0 : model13.inputs[0].shape) ? model13.inputs[0].shape[2] : 0, (model13 == null ? void 0 : model13.inputs[0].shape) ? model13.inputs[0].shape[1] : 0], false);
    const res2 = model13 == null ? void 0 : model13.execute(resize);
    const num = (await res2.data())[0];
    cached2[idx] = Math.round(100 * num) / 100;
    lastCount8 = count2;
    lastTime13 = now2();
    Re2([resize, res2]);
    resolve(cached2[idx]);
  });
}
var movenetcoords_exports = {};
__export(movenetcoords_exports, {
  connected: () => connected3,
  horizontal: () => horizontal,
  kpt: () => kpt3,
  relative: () => relative,
  vertical: () => vertical
});
var kpt3 = [
  "nose",
  "leftEye",
  "rightEye",
  "leftEar",
  "rightEar",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle"
];
var horizontal = [
  ["leftEye", "rightEye"],
  ["leftEar", "rightEar"],
  ["leftShoulder", "rightShoulder"],
  ["leftElbow", "rightElbow"],
  ["leftWrist", "rightWrist"],
  ["leftHip", "rightHip"],
  ["leftKnee", "rightKnee"],
  ["leftAnkle", "rightAnkle"]
];
var vertical = [
  ["leftKnee", "leftShoulder"],
  ["rightKnee", "rightShoulder"],
  ["leftAnkle", "leftKnee"],
  ["rightAnkle", "rightKnee"]
];
var relative = [
  [["leftHip", "rightHip"], ["leftShoulder", "rightShoulder"]],
  [["leftElbow", "rightElbow"], ["leftShoulder", "rightShoulder"]]
];
var connected3 = {
  leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
  rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
  torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
  leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
  rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
  head: []
};
var maxJitter = 5e-3;
var cache5 = {
  keypoints: [],
  padding: [[0, 0], [0, 0], [0, 0], [0, 0]]
};
function bodyParts(body4) {
  for (const pair of horizontal) {
    const left = body4.keypoints.findIndex((kp2) => kp2.part === pair[0]);
    const right = body4.keypoints.findIndex((kp2) => kp2.part === pair[1]);
    if (body4.keypoints[left] && body4.keypoints[right]) {
      if (body4.keypoints[left].position[0] < body4.keypoints[right].position[0]) {
        const tmp2 = body4.keypoints[left];
        body4.keypoints[left] = body4.keypoints[right];
        body4.keypoints[right] = tmp2;
      }
    }
  }
  for (const pair of vertical) {
    const lower = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[0]);
    const higher = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[1]);
    if (body4.keypoints[lower] && body4.keypoints[higher]) {
      if (body4.keypoints[lower].position[1] < body4.keypoints[higher].position[1]) {
        body4.keypoints.splice(lower, 1);
      }
    }
  }
  for (const [pair, compare2] of relative) {
    const left = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[0]);
    const right = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[1]);
    const leftTo = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === compare2[0]);
    const rightTo = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === compare2[1]);
    if (!body4.keypoints[leftTo] || !body4.keypoints[rightTo])
      continue;
    const distanceLeft = body4.keypoints[left] ? [
      Math.abs(body4.keypoints[leftTo].position[0] - body4.keypoints[left].position[0]),
      Math.abs(body4.keypoints[rightTo].position[0] - body4.keypoints[left].position[0])
    ] : [0, 0];
    const distanceRight = body4.keypoints[right] ? [
      Math.abs(body4.keypoints[rightTo].position[0] - body4.keypoints[right].position[0]),
      Math.abs(body4.keypoints[leftTo].position[0] - body4.keypoints[right].position[0])
    ] : [0, 0];
    if (distanceLeft[0] > distanceLeft[1] || distanceRight[0] > distanceRight[1]) {
      const tmp2 = body4.keypoints[left];
      body4.keypoints[left] = body4.keypoints[right];
      body4.keypoints[right] = tmp2;
    }
  }
}
function jitter(keypoints) {
  for (let i10 = 0; i10 < keypoints.length; i10++) {
    if (keypoints[i10] && cache5.keypoints[i10]) {
      const diff = [Math.abs(keypoints[i10].positionRaw[0] - cache5.keypoints[i10].positionRaw[0]), Math.abs(keypoints[i10].positionRaw[1] - cache5.keypoints[i10].positionRaw[1])];
      if (diff[0] < maxJitter && diff[1] < maxJitter) {
        keypoints[i10] = cache5.keypoints[i10];
      } else {
        cache5.keypoints[i10] = keypoints[i10];
      }
    } else {
      cache5.keypoints[i10] = keypoints[i10];
    }
  }
  return keypoints;
}
function padInput(input, inputSize10) {
  const t = {};
  if (!input.shape || !input.shape[1] || !input.shape[2])
    return input;
  cache5.padding = [
    [0, 0],
    [input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0, input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0],
    [input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0, input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0],
    [0, 0]
  ];
  t.pad = pi(input, cache5.padding);
  t.resize = ds.resizeBilinear(t.pad, [inputSize10, inputSize10]);
  const final = ce2(t.resize, "int32");
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  return final;
}
function rescaleBody(body4, outputSize2) {
  body4.keypoints = body4.keypoints.filter((kpt4) => kpt4 && kpt4.position);
  for (const kpt4 of body4.keypoints) {
    kpt4.position = [
      kpt4.position[0] * (outputSize2[0] + cache5.padding[2][0] + cache5.padding[2][1]) / outputSize2[0] - cache5.padding[2][0],
      kpt4.position[1] * (outputSize2[1] + cache5.padding[1][0] + cache5.padding[1][1]) / outputSize2[1] - cache5.padding[1][0]
    ];
    kpt4.positionRaw = [
      kpt4.position[0] / outputSize2[0],
      kpt4.position[1] / outputSize2[1]
    ];
  }
  const rescaledBoxes = calc(body4.keypoints.map((pt2) => pt2.position), outputSize2);
  body4.box = rescaledBoxes.box;
  body4.boxRaw = rescaledBoxes.boxRaw;
  return body4;
}
var model14;
var inputSize8 = 0;
var skipped13 = Number.MAX_SAFE_INTEGER;
var cache6 = {
  boxes: [],
  bodies: [],
  last: 0
};
async function load15(config3) {
  if (env.initial)
    model14 = null;
  if (!model14) {
    fakeOps(["size"], config3);
    model14 = await loadModel(config3.body.modelPath);
  } else if (config3.debug)
    log("cached model:", model14["modelUrl"]);
  inputSize8 = model14.inputs[0].shape ? model14.inputs[0].shape[2] : 0;
  if (inputSize8 < 64)
    inputSize8 = 256;
  return model14;
}
async function parseSinglePose(res2, config3, image) {
  const kpt4 = res2[0][0];
  const keypoints = [];
  let score = 0;
  for (let id2 = 0; id2 < kpt4.length; id2++) {
    score = kpt4[id2][2];
    if (score > config3.body.minConfidence) {
      const positionRaw = [kpt4[id2][1], kpt4[id2][0]];
      keypoints.push({
        score: Math.round(100 * score) / 100,
        part: kpt3[id2],
        positionRaw,
        position: [
          Math.round((image.shape[2] || 0) * positionRaw[0]),
          Math.round((image.shape[1] || 0) * positionRaw[1])
        ]
      });
    }
  }
  score = keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
  const bodies = [];
  const newBox = calc(keypoints.map((pt2) => pt2.position), [image.shape[2], image.shape[1]]);
  const annotations2 = {};
  for (const [name, indexes] of Object.entries(connected3)) {
    const pt2 = [];
    for (let i10 = 0; i10 < indexes.length - 1; i10++) {
      const pt0 = keypoints.find((kp2) => kp2.part === indexes[i10]);
      const pt1 = keypoints.find((kp2) => kp2.part === indexes[i10 + 1]);
      if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
        pt2.push([pt0.position, pt1.position]);
    }
    annotations2[name] = pt2;
  }
  const body4 = { id: 0, score, box: newBox.box, boxRaw: newBox.boxRaw, keypoints, annotations: annotations2 };
  bodyParts(body4);
  bodies.push(body4);
  return bodies;
}
async function parseMultiPose(res2, config3, image) {
  const bodies = [];
  for (let id2 = 0; id2 < res2[0].length; id2++) {
    const kpt4 = res2[0][id2];
    const totalScore = Math.round(100 * kpt4[51 + 4]) / 100;
    if (totalScore > config3.body.minConfidence) {
      const keypoints = [];
      for (let i10 = 0; i10 < 17; i10++) {
        const score = kpt4[3 * i10 + 2];
        if (score > config3.body.minConfidence) {
          const positionRaw = [kpt4[3 * i10 + 1], kpt4[3 * i10 + 0]];
          keypoints.push({
            part: kpt3[i10],
            score: Math.round(100 * score) / 100,
            positionRaw,
            position: [Math.round((image.shape[2] || 0) * positionRaw[0]), Math.round((image.shape[1] || 0) * positionRaw[1])]
          });
        }
      }
      const newBox = calc(keypoints.map((pt2) => pt2.position), [image.shape[2], image.shape[1]]);
      const annotations2 = {};
      for (const [name, indexes] of Object.entries(connected3)) {
        const pt2 = [];
        for (let i10 = 0; i10 < indexes.length - 1; i10++) {
          const pt0 = keypoints.find((kp2) => kp2.part === indexes[i10]);
          const pt1 = keypoints.find((kp2) => kp2.part === indexes[i10 + 1]);
          if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
            pt2.push([pt0.position, pt1.position]);
        }
        annotations2[name] = pt2;
      }
      const body4 = { id: id2, score: totalScore, box: newBox.box, boxRaw: newBox.boxRaw, keypoints: [...keypoints], annotations: annotations2 };
      bodyParts(body4);
      bodies.push(body4);
    }
  }
  bodies.sort((a10, b10) => b10.score - a10.score);
  if (bodies.length > config3.body.maxDetected)
    bodies.length = config3.body.maxDetected;
  return bodies;
}
async function predict15(input, config3) {
  if (!model14 || !(model14 == null ? void 0 : model14.inputs[0].shape))
    return [];
  if (!config3.skipAllowed)
    cache6.boxes.length = 0;
  skipped13++;
  const skipTime = (config3.body.skipTime || 0) > now2() - cache6.last;
  const skipFrame = skipped13 < (config3.body.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame) {
    return cache6.bodies;
  }
  return new Promise(async (resolve) => {
    const t = {};
    skipped13 = 0;
    t.input = padInput(input, inputSize8);
    t.res = model14 == null ? void 0 : model14.execute(t.input);
    cache6.last = now2();
    const res2 = await t.res.array();
    cache6.bodies = t.res.shape[2] === 17 ? await parseSinglePose(res2, config3, input) : await parseMultiPose(res2, config3, input);
    for (const body4 of cache6.bodies) {
      rescaleBody(body4, [input.shape[2] || 1, input.shape[1] || 1]);
      jitter(body4.keypoints);
    }
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    resolve(cache6.bodies);
  });
}
var model15;
var last9 = [];
var lastTime14 = 0;
var skipped14 = Number.MAX_SAFE_INTEGER;
var inputSize9 = 0;
var scaleBox = 2.5;
async function load16(config3) {
  if (!model15 || env.initial) {
    model15 = await loadModel(config3.object.modelPath);
    const inputs = Object.values(model15.modelSignature["inputs"]);
    inputSize9 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
  } else if (config3.debug)
    log("cached model:", model15["modelUrl"]);
  return model15;
}
async function process4(res2, outputShape, config3) {
  let id2 = 0;
  let results = [];
  for (const strideSize of [1, 2, 4]) {
    j2(async () => {
      const baseSize = strideSize * 13;
      const scoresT = mr(res2.find((a10) => a10.shape[1] === baseSize ** 2 && (a10.shape[2] || 0) === labels.length));
      const featuresT = mr(res2.find((a10) => a10.shape[1] === baseSize ** 2 && (a10.shape[2] || 0) < labels.length));
      const boxesMax = featuresT.reshape([-1, 4, featuresT.shape[1] / 4]);
      const boxIdx = await boxesMax.argMax(2).array();
      const scores = await scoresT.array();
      for (let i10 = 0; i10 < scoresT.shape[0]; i10++) {
        for (let j10 = 0; j10 < scoresT.shape[1]; j10++) {
          const score = scores[i10][j10];
          if (score > (config3.object.minConfidence || 0) && j10 !== 61) {
            const cx2 = (0.5 + Math.trunc(i10 % baseSize)) / baseSize;
            const cy2 = (0.5 + Math.trunc(i10 / baseSize)) / baseSize;
            const boxOffset = boxIdx[i10].map((a10) => a10 * (baseSize / strideSize / inputSize9));
            const [x10, y10] = [
              cx2 - scaleBox / strideSize * boxOffset[0],
              cy2 - scaleBox / strideSize * boxOffset[1]
            ];
            const [w10, h10] = [
              cx2 + scaleBox / strideSize * boxOffset[2] - x10,
              cy2 + scaleBox / strideSize * boxOffset[3] - y10
            ];
            let boxRaw = [x10, y10, w10, h10];
            boxRaw = boxRaw.map((a10) => Math.max(0, Math.min(a10, 1)));
            const box = [
              boxRaw[0] * outputShape[0],
              boxRaw[1] * outputShape[1],
              boxRaw[2] * outputShape[0],
              boxRaw[3] * outputShape[1]
            ];
            const result = {
              id: id2++,
              score: Math.round(100 * score) / 100,
              class: j10 + 1,
              label: labels[j10].label,
              box: box.map((a10) => Math.trunc(a10)),
              boxRaw
            };
            results.push(result);
          }
        }
      }
    });
  }
  res2.forEach((t) => Re2(t));
  const nmsBoxes = results.map((a10) => [a10.boxRaw[1], a10.boxRaw[0], a10.boxRaw[3], a10.boxRaw[2]]);
  const nmsScores = results.map((a10) => a10.score);
  let nmsIdx = [];
  if (nmsBoxes && nmsBoxes.length > 0) {
    const nms = await ds.nonMaxSuppressionAsync(nmsBoxes, nmsScores, config3.object.maxDetected, config3.object.iouThreshold, config3.object.minConfidence);
    nmsIdx = await nms.data();
    Re2(nms);
  }
  results = results.filter((_val, idx) => nmsIdx.includes(idx)).sort((a10, b10) => b10.score - a10.score);
  return results;
}
async function predict16(image, config3) {
  const skipTime = (config3.object.skipTime || 0) > now2() - lastTime14;
  const skipFrame = skipped14 < (config3.object.skipFrames || 0);
  if (config3.skipAllowed && skipTime && skipFrame && last9.length > 0) {
    skipped14++;
    return last9;
  }
  skipped14 = 0;
  if (!env.kernels.includes("mod") || !env.kernels.includes("sparsetodense"))
    return last9;
  return new Promise(async (resolve) => {
    const outputSize2 = [image.shape[2] || 0, image.shape[1] || 0];
    const resize = ds.resizeBilinear(image, [inputSize9, inputSize9], false);
    const norm = xe2(resize, constants.tf255);
    const transpose = norm.transpose([0, 3, 1, 2]);
    Re2(norm);
    Re2(resize);
    let objectT;
    if (config3.object.enabled)
      objectT = model15.execute(transpose);
    lastTime14 = now2();
    Re2(transpose);
    const obj = await process4(objectT, outputSize2, config3);
    last9 = obj;
    resolve(obj);
  });
}
var partNames = [
  "nose",
  "leftEye",
  "rightEye",
  "leftEar",
  "rightEar",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle"
];
var count = partNames.length;
var partIds = partNames.reduce((result, jointName, i10) => {
  result[jointName] = i10;
  return result;
}, {});
var connectedPartNames = [
  ["leftHip", "leftShoulder"],
  ["leftElbow", "leftShoulder"],
  ["leftElbow", "leftWrist"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["rightHip", "rightShoulder"],
  ["rightElbow", "rightShoulder"],
  ["rightElbow", "rightWrist"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"],
  ["leftShoulder", "rightShoulder"],
  ["leftHip", "rightHip"]
];
var connectedPartIndices = connectedPartNames.map(([jointNameA, jointNameB]) => [partIds[jointNameA], partIds[jointNameB]]);
var poseChain = [
  ["nose", "leftEye"],
  ["leftEye", "leftEar"],
  ["nose", "rightEye"],
  ["rightEye", "rightEar"],
  ["nose", "leftShoulder"],
  ["leftShoulder", "leftElbow"],
  ["leftElbow", "leftWrist"],
  ["leftShoulder", "leftHip"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["nose", "rightShoulder"],
  ["rightShoulder", "rightElbow"],
  ["rightElbow", "rightWrist"],
  ["rightShoulder", "rightHip"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"]
];
function getBoundingBox(keypoints) {
  const coord = keypoints.reduce(({ maxX, maxY, minX, minY }, { position: { x: x10, y: y10 } }) => ({
    maxX: Math.max(maxX, x10),
    maxY: Math.max(maxY, y10),
    minX: Math.min(minX, x10),
    minY: Math.min(minY, y10)
  }), {
    maxX: Number.NEGATIVE_INFINITY,
    maxY: Number.NEGATIVE_INFINITY,
    minX: Number.POSITIVE_INFINITY,
    minY: Number.POSITIVE_INFINITY
  });
  return [coord.minX, coord.minY, coord.maxX - coord.minX, coord.maxY - coord.minY];
}
function scalePoses(poses, [height, width], [inputResolutionHeight, inputResolutionWidth]) {
  const scaleY = height / inputResolutionHeight;
  const scaleX = width / inputResolutionWidth;
  const scalePose = (pose, i10) => ({
    id: i10,
    score: pose.score,
    boxRaw: [pose.box[0] / inputResolutionWidth, pose.box[1] / inputResolutionHeight, pose.box[2] / inputResolutionWidth, pose.box[3] / inputResolutionHeight],
    box: [Math.trunc(pose.box[0] * scaleX), Math.trunc(pose.box[1] * scaleY), Math.trunc(pose.box[2] * scaleX), Math.trunc(pose.box[3] * scaleY)],
    keypoints: pose.keypoints.map(({ score, part, position }) => ({
      score,
      part,
      position: [Math.trunc(position.x * scaleX), Math.trunc(position.y * scaleY)],
      positionRaw: [position.x / inputResolutionHeight, position.y / inputResolutionHeight]
    })),
    annotations: {}
  });
  const scaledPoses = poses.map((pose, i10) => scalePose(pose, i10));
  return scaledPoses;
}
var MaxHeap = class {
  constructor(maxSize2, getElementValue) {
    __publicField(this, "priorityQueue");
    __publicField(this, "numberOfElements");
    __publicField(this, "getElementValue");
    this.priorityQueue = new Array(maxSize2);
    this.numberOfElements = -1;
    this.getElementValue = getElementValue;
  }
  enqueue(x10) {
    this.priorityQueue[++this.numberOfElements] = x10;
    this.swim(this.numberOfElements);
  }
  dequeue() {
    const max = this.priorityQueue[0];
    this.exchange(0, this.numberOfElements--);
    this.sink(0);
    this.priorityQueue[this.numberOfElements + 1] = null;
    return max;
  }
  empty() {
    return this.numberOfElements === -1;
  }
  size() {
    return this.numberOfElements + 1;
  }
  all() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }
  max() {
    return this.priorityQueue[0];
  }
  swim(k10) {
    while (k10 > 0 && this.less(Math.floor(k10 / 2), k10)) {
      this.exchange(k10, Math.floor(k10 / 2));
      k10 = Math.floor(k10 / 2);
    }
  }
  sink(k10) {
    while (2 * k10 <= this.numberOfElements) {
      let j10 = 2 * k10;
      if (j10 < this.numberOfElements && this.less(j10, j10 + 1))
        j10++;
      if (!this.less(k10, j10))
        break;
      this.exchange(k10, j10);
      k10 = j10;
    }
  }
  getValueAt(i10) {
    return this.getElementValue(this.priorityQueue[i10]);
  }
  less(i10, j10) {
    return this.getValueAt(i10) < this.getValueAt(j10);
  }
  exchange(i10, j10) {
    const t = this.priorityQueue[i10];
    this.priorityQueue[i10] = this.priorityQueue[j10];
    this.priorityQueue[j10] = t;
  }
};
function getOffsetPoint(y10, x10, keypoint, offsets) {
  return {
    y: offsets.get(y10, x10, keypoint),
    x: offsets.get(y10, x10, keypoint + count)
  };
}
function getImageCoords(part, outputStride2, offsets) {
  const { heatmapY, heatmapX, id: keypoint } = part;
  const { y: y10, x: x10 } = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);
  return {
    x: part.heatmapX * outputStride2 + x10,
    y: part.heatmapY * outputStride2 + y10
  };
}
function clamp2(a10, min, max) {
  if (a10 < min)
    return min;
  if (a10 > max)
    return max;
  return a10;
}
function squaredDistance(y12, x12, y22, x22) {
  const dy2 = y22 - y12;
  const dx2 = x22 - x12;
  return dy2 * dy2 + dx2 * dx2;
}
function addVectors(a10, b10) {
  return { x: a10.x + b10.x, y: a10.y + b10.y };
}
var model16;
var poseNetOutputs = ["MobilenetV1/offset_2/BiasAdd", "MobilenetV1/heatmap_2/BiasAdd", "MobilenetV1/displacement_fwd_2/BiasAdd", "MobilenetV1/displacement_bwd_2/BiasAdd"];
var localMaximumRadius = 1;
var outputStride = 16;
var squaredNmsRadius = 50 ** 2;
function traverse(edgeId, sourceKeypoint, targetId, scores, offsets, displacements, offsetRefineStep = 2) {
  const getDisplacement = (point2) => ({
    y: displacements.get(point2.y, point2.x, edgeId),
    x: displacements.get(point2.y, point2.x, displacements.shape[2] / 2 + edgeId)
  });
  const getStridedIndexNearPoint = (point2, height2, width2) => ({
    y: clamp2(Math.round(point2.y / outputStride), 0, height2 - 1),
    x: clamp2(Math.round(point2.x / outputStride), 0, width2 - 1)
  });
  const [height, width] = scores.shape;
  const sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, height, width);
  const displacement = getDisplacement(sourceKeypointIndices);
  const displacedPoint = addVectors(sourceKeypoint.position, displacement);
  let targetKeypoint = displacedPoint;
  for (let i10 = 0; i10 < offsetRefineStep; i10++) {
    const targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
    const offsetPoint = getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetId, offsets);
    targetKeypoint = addVectors({ x: targetKeypointIndices.x * outputStride, y: targetKeypointIndices.y * outputStride }, { x: offsetPoint.x, y: offsetPoint.y });
  }
  const targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
  const score = scores.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetId);
  return { position: targetKeypoint, part: partNames[targetId], score };
}
function decodePose(root, scores, offsets, displacementsFwd, displacementsBwd) {
  const tuples = poseChain.map(([parentJoinName, childJoinName]) => [partIds[parentJoinName], partIds[childJoinName]]);
  const edgesFwd = tuples.map(([, childJointId]) => childJointId);
  const edgesBwd = tuples.map(([parentJointId]) => parentJointId);
  const numParts = scores.shape[2];
  const numEdges = edgesFwd.length;
  const keypoints = new Array(numParts);
  const rootPoint = getImageCoords(root.part, outputStride, offsets);
  keypoints[root.part.id] = {
    score: root.score,
    part: partNames[root.part.id],
    position: rootPoint
  };
  for (let edge = numEdges - 1; edge >= 0; --edge) {
    const sourceId = edgesFwd[edge];
    const targetId = edgesBwd[edge];
    if (keypoints[sourceId] && !keypoints[targetId]) {
      keypoints[targetId] = traverse(edge, keypoints[sourceId], targetId, scores, offsets, displacementsBwd);
    }
  }
  for (let edge = 0; edge < numEdges; ++edge) {
    const sourceId = edgesBwd[edge];
    const targetId = edgesFwd[edge];
    if (keypoints[sourceId] && !keypoints[targetId]) {
      keypoints[targetId] = traverse(edge, keypoints[sourceId], targetId, scores, offsets, displacementsFwd);
    }
  }
  return keypoints;
}
function scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores) {
  const [height, width] = scores.shape;
  let localMaximum = true;
  const yStart = Math.max(heatmapY - localMaximumRadius, 0);
  const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
  for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
    const xStart = Math.max(heatmapX - localMaximumRadius, 0);
    const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
    for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
      if (scores.get(yCurrent, xCurrent, keypointId) > score) {
        localMaximum = false;
        break;
      }
    }
    if (!localMaximum)
      break;
  }
  return localMaximum;
}
function buildPartWithScoreQueue(minConfidence2, scores) {
  const [height, width, numKeypoints] = scores.shape;
  const queue = new MaxHeap(height * width * numKeypoints, ({ score }) => score);
  for (let heatmapY = 0; heatmapY < height; ++heatmapY) {
    for (let heatmapX = 0; heatmapX < width; ++heatmapX) {
      for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {
        const score = scores.get(heatmapY, heatmapX, keypointId);
        if (score < minConfidence2)
          continue;
        if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores))
          queue.enqueue({ score, part: { heatmapY, heatmapX, id: keypointId } });
      }
    }
  }
  return queue;
}
function withinRadius(poses, { x: x10, y: y10 }, keypointId) {
  return poses.some(({ keypoints }) => {
    var _a2;
    const correspondingKeypoint = (_a2 = keypoints[keypointId]) == null ? void 0 : _a2.position;
    if (!correspondingKeypoint)
      return false;
    return squaredDistance(y10, x10, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
  });
}
function getInstanceScore(existingPoses, keypoints) {
  const notOverlappedKeypointScores = keypoints.reduce((result, { position, score }, keypointId) => {
    if (!withinRadius(existingPoses, position, keypointId))
      result += score;
    return result;
  }, 0);
  return notOverlappedKeypointScores / keypoints.length;
}
function decode(offsets, scores, displacementsFwd, displacementsBwd, maxDetected, minConfidence2) {
  const poses = [];
  const queue = buildPartWithScoreQueue(minConfidence2, scores);
  while (poses.length < maxDetected && !queue.empty()) {
    const root = queue.dequeue();
    const rootImageCoords = getImageCoords(root.part, outputStride, offsets);
    if (withinRadius(poses, rootImageCoords, root.part.id))
      continue;
    let keypoints = decodePose(root, scores, offsets, displacementsFwd, displacementsBwd);
    keypoints = keypoints.filter((a10) => a10.score > minConfidence2);
    const score = getInstanceScore(poses, keypoints);
    const box = getBoundingBox(keypoints);
    if (score > minConfidence2)
      poses.push({ keypoints, box, score: Math.round(100 * score) / 100 });
  }
  return poses;
}
async function predict17(input, config3) {
  const res2 = j2(() => {
    if (!model16.inputs[0].shape)
      return [];
    const resized = ds.resizeBilinear(input, [model16.inputs[0].shape[2], model16.inputs[0].shape[1]]);
    const normalized = ge2(xe2(ce2(resized, "float32"), 127.5), 1);
    const results = model16.execute(normalized, poseNetOutputs);
    const results3d = results.map((y10) => mr(y10, [0]));
    results3d[1] = qs(results3d[1]);
    return results3d;
  });
  const buffers = await Promise.all(res2.map((tensor) => tensor.buffer()));
  for (const t of res2)
    Re2(t);
  const decoded = await decode(buffers[0], buffers[1], buffers[2], buffers[3], config3.body.maxDetected, config3.body.minConfidence);
  if (!model16.inputs[0].shape)
    return [];
  const scaled = scalePoses(decoded, [input.shape[1], input.shape[2]], [model16.inputs[0].shape[2], model16.inputs[0].shape[1]]);
  return scaled;
}
async function load17(config3) {
  if (!model16 || env.initial)
    model16 = await loadModel(config3.body.modelPath);
  else if (config3.debug)
    log("cached model:", model16["modelUrl"]);
  return model16;
}
var model17;
var busy = false;
async function load18(config3) {
  if (!model17 || env.initial)
    model17 = await loadModel(config3.segmentation.modelPath);
  else if (config3.debug)
    log("cached model:", model17["modelUrl"]);
  return model17;
}
async function process5(input, background, config3) {
  var _a2, _b2;
  if (busy)
    return { data: [], canvas: null, alpha: null };
  busy = true;
  if (!model17)
    await load18(config3);
  const inputImage = await process2(input, config3);
  const width = ((_a2 = inputImage.tensor) == null ? void 0 : _a2.shape[2]) || 0;
  const height = ((_b2 = inputImage.tensor) == null ? void 0 : _b2.shape[1]) || 0;
  if (!inputImage.tensor)
    return { data: [], canvas: null, alpha: null };
  const t = {};
  t.resize = ds.resizeBilinear(inputImage.tensor, [model17.inputs[0].shape ? model17.inputs[0].shape[1] : 0, model17.inputs[0].shape ? model17.inputs[0].shape[2] : 0], false);
  Re2(inputImage.tensor);
  t.norm = xe2(t.resize, constants.tf255);
  t.res = model17.execute(t.norm);
  t.squeeze = mr(t.res, 0);
  if (t.squeeze.shape[2] === 2) {
    t.softmax = ib(t.squeeze);
    [t.bg, t.fg] = Fs(t.softmax, 2);
    t.expand = On(t.fg, 2);
    t.pad = On(t.expand, 0);
    t.crop = ds.cropAndResize(t.pad, [[0, 0, 0.5, 0.5]], [0], [width, height]);
    t.data = mr(t.crop, 0);
  } else {
    t.data = ds.resizeBilinear(t.squeeze, [height, width]);
  }
  const data = Array.from(await t.data.data());
  if (env.node && !env.Canvas && typeof ImageData === "undefined") {
    if (config3.debug)
      log("canvas support missing");
    Object.keys(t).forEach((tensor) => Re2(t[tensor]));
    return { data, canvas: null, alpha: null };
  }
  const alphaCanvas = canvas(width, height);
  if (xk)
    await xk.toPixels(t.data, alphaCanvas);
  const alphaCtx = alphaCanvas.getContext("2d");
  if (config3.segmentation.blur && config3.segmentation.blur > 0)
    alphaCtx.filter = `blur(${config3.segmentation.blur}px)`;
  const alphaData = alphaCtx.getImageData(0, 0, width, height);
  const compositeCanvas = canvas(width, height);
  const compositeCtx = compositeCanvas.getContext("2d");
  if (inputImage.canvas)
    compositeCtx.drawImage(inputImage.canvas, 0, 0);
  compositeCtx.globalCompositeOperation = "darken";
  if (config3.segmentation.blur && config3.segmentation.blur > 0)
    compositeCtx.filter = `blur(${config3.segmentation.blur}px)`;
  compositeCtx.drawImage(alphaCanvas, 0, 0);
  compositeCtx.globalCompositeOperation = "source-over";
  compositeCtx.filter = "none";
  const compositeData = compositeCtx.getImageData(0, 0, width, height);
  for (let i10 = 0; i10 < width * height; i10++)
    compositeData.data[4 * i10 + 3] = alphaData.data[4 * i10 + 0];
  compositeCtx.putImageData(compositeData, 0, 0);
  let mergedCanvas = null;
  if (background && compositeCanvas) {
    mergedCanvas = canvas(width, height);
    const bgImage = await process2(background, config3);
    Re2(bgImage.tensor);
    const ctxMerge = mergedCanvas.getContext("2d");
    ctxMerge.drawImage(bgImage.canvas, 0, 0, mergedCanvas.width, mergedCanvas.height);
    ctxMerge.drawImage(compositeCanvas, 0, 0);
  }
  Object.keys(t).forEach((tensor) => Re2(t[tensor]));
  busy = false;
  return { data, canvas: compositeCanvas, alpha: alphaCanvas };
}
var Models = class {
  constructor() {
    __publicField(this, "ssrnetage", null);
    __publicField(this, "gear", null);
    __publicField(this, "blazeposedetect", null);
    __publicField(this, "blazepose", null);
    __publicField(this, "centernet", null);
    __publicField(this, "efficientpose", null);
    __publicField(this, "mobilefacenet", null);
    __publicField(this, "emotion", null);
    __publicField(this, "facedetect", null);
    __publicField(this, "faceiris", null);
    __publicField(this, "facemesh", null);
    __publicField(this, "faceres", null);
    __publicField(this, "ssrnetgender", null);
    __publicField(this, "handpose", null);
    __publicField(this, "handskeleton", null);
    __publicField(this, "handtrack", null);
    __publicField(this, "liveness", null);
    __publicField(this, "movenet", null);
    __publicField(this, "nanodet", null);
    __publicField(this, "posenet", null);
    __publicField(this, "segmentation", null);
    __publicField(this, "antispoof", null);
  }
};
function reset(instance) {
  for (const model182 of Object.keys(instance.models))
    instance.models[model182] = null;
}
async function load19(instance) {
  var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q22, _r2, _s2, _t2, _u2, _v2, _w2, _x22, _y22, _z22, _A2, _B2, _C2, _D2;
  if (env.initial)
    reset(instance);
  if (instance.config.hand.enabled) {
    if (!instance.models.handpose && ((_b2 = (_a2 = instance.config.hand.detector) == null ? void 0 : _a2.modelPath) == null ? void 0 : _b2.includes("handdetect")))
      [instance.models.handpose, instance.models.handskeleton] = await load13(instance.config);
    if (!instance.models.handskeleton && instance.config.hand.landmarks && ((_d2 = (_c = instance.config.hand.detector) == null ? void 0 : _c.modelPath) == null ? void 0 : _d2.includes("handdetect")))
      [instance.models.handpose, instance.models.handskeleton] = await load13(instance.config);
  }
  if (instance.config.body.enabled && !instance.models.blazepose && ((_f = (_e22 = instance.config.body) == null ? void 0 : _e22.modelPath) == null ? void 0 : _f.includes("blazepose")))
    instance.models.blazepose = loadPose(instance.config);
  if (instance.config.body.enabled && !instance.models.blazeposedetect && instance.config.body["detector"] && instance.config.body["detector"]["modelPath"])
    instance.models.blazeposedetect = loadDetect(instance.config);
  if (instance.config.body.enabled && !instance.models.efficientpose && ((_h = (_g2 = instance.config.body) == null ? void 0 : _g2.modelPath) == null ? void 0 : _h.includes("efficientpose")))
    instance.models.efficientpose = load7(instance.config);
  if (instance.config.body.enabled && !instance.models.movenet && ((_j2 = (_i = instance.config.body) == null ? void 0 : _i.modelPath) == null ? void 0 : _j2.includes("movenet")))
    instance.models.movenet = load15(instance.config);
  if (instance.config.body.enabled && !instance.models.posenet && ((_l2 = (_k2 = instance.config.body) == null ? void 0 : _k2.modelPath) == null ? void 0 : _l2.includes("posenet")))
    instance.models.posenet = load17(instance.config);
  if (instance.config.face.enabled && !instance.models.facedetect)
    instance.models.facedetect = load5(instance.config);
  if (instance.config.face.enabled && ((_m2 = instance.config.face.antispoof) == null ? void 0 : _m2.enabled) && !instance.models.antispoof)
    instance.models.antispoof = load4(instance.config);
  if (instance.config.face.enabled && ((_n2 = instance.config.face.liveness) == null ? void 0 : _n2.enabled) && !instance.models.liveness)
    instance.models.liveness = load14(instance.config);
  if (instance.config.face.enabled && ((_o2 = instance.config.face.description) == null ? void 0 : _o2.enabled) && !instance.models.faceres)
    instance.models.faceres = load12(instance.config);
  if (instance.config.face.enabled && ((_p2 = instance.config.face.emotion) == null ? void 0 : _p2.enabled) && !instance.models.emotion)
    instance.models.emotion = load8(instance.config);
  if (instance.config.face.enabled && ((_q22 = instance.config.face.iris) == null ? void 0 : _q22.enabled) && !instance.models.faceiris)
    instance.models.faceiris = load10(instance.config);
  if (instance.config.face.enabled && ((_r2 = instance.config.face.mesh) == null ? void 0 : _r2.enabled) && !instance.models.facemesh)
    instance.models.facemesh = load11(instance.config);
  if (instance.config.face.enabled && ((_s2 = instance.config.face["gear"]) == null ? void 0 : _s2.enabled) && !instance.models.gear)
    instance.models.gear = load(instance.config);
  if (instance.config.face.enabled && ((_t2 = instance.config.face["ssrnet"]) == null ? void 0 : _t2.enabled) && !instance.models.ssrnetage)
    instance.models.ssrnetage = load2(instance.config);
  if (instance.config.face.enabled && ((_u2 = instance.config.face["ssrnet"]) == null ? void 0 : _u2.enabled) && !instance.models.ssrnetgender)
    instance.models.ssrnetgender = load3(instance.config);
  if (instance.config.face.enabled && ((_v2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _v2.enabled) && !instance.models.mobilefacenet)
    instance.models.mobilefacenet = load9(instance.config);
  if (instance.config.hand.enabled && !instance.models.handtrack && ((_x22 = (_w2 = instance.config.hand.detector) == null ? void 0 : _w2.modelPath) == null ? void 0 : _x22.includes("handtrack")))
    instance.models.handtrack = loadDetect2(instance.config);
  if (instance.config.hand.enabled && instance.config.hand.landmarks && !instance.models.handskeleton && ((_z22 = (_y22 = instance.config.hand.detector) == null ? void 0 : _y22.modelPath) == null ? void 0 : _z22.includes("handtrack")))
    instance.models.handskeleton = loadSkeleton(instance.config);
  if (instance.config.object.enabled && !instance.models.centernet && ((_B2 = (_A2 = instance.config.object) == null ? void 0 : _A2.modelPath) == null ? void 0 : _B2.includes("centernet")))
    instance.models.centernet = load6(instance.config);
  if (instance.config.object.enabled && !instance.models.nanodet && ((_D2 = (_C2 = instance.config.object) == null ? void 0 : _C2.modelPath) == null ? void 0 : _D2.includes("nanodet")))
    instance.models.nanodet = load16(instance.config);
  if (instance.config.segmentation.enabled && !instance.models.segmentation)
    instance.models.segmentation = load18(instance.config);
  for await (const model182 of Object.keys(instance.models)) {
    if (instance.models[model182] && typeof instance.models[model182] !== "undefined")
      instance.models[model182] = await instance.models[model182];
  }
}
async function validate2(instance) {
  const simpleOps = ["const", "placeholder", "noop", "pad", "squeeze", "add", "sub", "mul", "div"];
  for (const defined of Object.keys(instance.models)) {
    const model182 = instance.models[defined];
    if (!model182)
      continue;
    const ops = [];
    const executor = model182 == null ? void 0 : model182.executor;
    if (executor && executor.graph.nodes) {
      for (const kernel of Object.values(executor.graph.nodes)) {
        const op2 = kernel.op.toLowerCase();
        if (!ops.includes(op2))
          ops.push(op2);
      }
    } else {
      if (!executor && instance.config.debug)
        log("model signature not determined:", defined);
    }
    const missing = [];
    for (const op2 of ops) {
      if (!simpleOps.includes(op2) && !instance.env.kernels.includes(op2) && !instance.env.kernels.includes(op2.replace("_", "")) && !instance.env.kernels.includes(op2.replace("native", "")) && !instance.env.kernels.includes(op2.replace("v2", ""))) {
        missing.push(op2);
      }
    }
    if (instance.config.debug && missing.length > 0)
      log("model validation failed:", defined, missing);
  }
}
var config2 = {
  name: "humangl",
  priority: 999,
  canvas: null,
  gl: null,
  extensions: [],
  webGLattr: {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: false,
    desynchronized: true
  }
};
function extensions() {
  const gl2 = config2.gl;
  if (!gl2)
    return;
  config2.extensions = gl2.getSupportedExtensions();
}
async function register(instance) {
  var _a2;
  if (instance.config.backend !== "humangl")
    return;
  if (config2.name in Ss().registry && (!config2.gl || !config2.gl.getParameter(config2.gl.VERSION))) {
    log("error: humangl backend invalid context");
    reset(instance);
  }
  if (!Tde(config2.name)) {
    try {
      config2.canvas = await canvas(100, 100);
    } catch (err) {
      log("error: cannot create canvas:", err);
      return;
    }
    try {
      config2.gl = (_a2 = config2.canvas) == null ? void 0 : _a2.getContext("webgl2", config2.webGLattr);
      const glv2 = config2.gl.getParameter(config2.gl.VERSION).includes("2.0");
      if (!glv2) {
        log("override: using fallback webgl backend as webgl 2.0 is not detected");
        instance.config.backend = "webgl";
        return;
      }
      if (config2.canvas) {
        config2.canvas.addEventListener("webglcontextlost", async (e) => {
          log("error: humangl:", e.type);
          log("possible browser memory leak using webgl or conflict with multiple backend registrations");
          instance.emit("error");
          throw new Error("backend error: webgl context lost");
        });
        config2.canvas.addEventListener("webglcontextrestored", (e) => {
          log("error: humangl context restored:", e);
        });
        config2.canvas.addEventListener("webglcontextcreationerror", (e) => {
          log("error: humangl context create:", e);
        });
      }
    } catch (err) {
      log("error: cannot get WebGL context:", err);
      return;
    }
    try {
      p5(2, config2.gl);
    } catch (err) {
      log("error: cannot set WebGL context:", err);
      return;
    }
    try {
      const ctx = new qf(config2.gl);
      dp(config2.name, () => new A1(ctx), config2.priority);
    } catch (err) {
      log("error: cannot register WebGL backend:", err);
      return;
    }
    try {
      const kernels = Qf("webgl");
      kernels.forEach((kernelConfig) => {
        const newKernelConfig = { ...kernelConfig, backendName: config2.name };
        _l(newKernelConfig);
      });
    } catch (err) {
      log("error: cannot update WebGL backend registration:", err);
      return;
    }
    const current = $A().getGPGPUContext ? $A().getGPGPUContext().gl : null;
    if (current) {
      log(`humangl webgl version:${current.getParameter(current.VERSION)} renderer:${current.getParameter(current.RENDERER)}`);
    } else {
      log("error: no current gl context:", current, config2.gl);
      return;
    }
    try {
      jw.set("WEBGL_VERSION", 2);
    } catch (err) {
      log("error: cannot set WebGL backend flags:", err);
      return;
    }
    extensions();
    log("backend registered:", config2.name);
  }
}
function registerCustomOps() {
  if (!env.kernels.includes("mod")) {
    const kernelMod = {
      kernelName: "Mod",
      backendName: Cde(),
      kernelFunc: (op2) => j2(() => ge2(op2.inputs.a, V2(xe2(op2.inputs.a, op2.inputs.b), op2.inputs.b)))
    };
    _l(kernelMod);
    env.kernels.push("mod");
  }
  if (!env.kernels.includes("floormod")) {
    const kernelMod = {
      kernelName: "FloorMod",
      backendName: Cde(),
      kernelFunc: (op2) => j2(() => Lk(op2.inputs.a / op2.inputs.b) * op2.inputs.b + dD(op2.inputs.a, op2.inputs.b))
    };
    _l(kernelMod);
    env.kernels.push("floormod");
  }
}
async function check(instance, force = false) {
  instance.state = "backend";
  if (force || env.initial || instance.config.backend && instance.config.backend.length > 0 && Cde() !== instance.config.backend) {
    const timeStamp = now2();
    if (instance.config.backend && instance.config.backend.length > 0) {
      if (typeof window === "undefined" && typeof WorkerGlobalScope !== "undefined" && instance.config.debug) {
        if (instance.config.debug)
          log("running inside web worker");
      }
      if (env.browser && instance.config.backend === "tensorflow") {
        if (instance.config.debug)
          log("override: backend set to tensorflow while running in browser");
        instance.config.backend = "humangl";
      }
      if (env.node && (instance.config.backend === "webgl" || instance.config.backend === "humangl")) {
        if (instance.config.debug)
          log(`override: backend set to ${instance.config.backend} while running in nodejs`);
        instance.config.backend = "tensorflow";
      }
      if (env.browser && instance.config.backend === "webgpu") {
        if (typeof navigator === "undefined" || typeof navigator["gpu"] === "undefined") {
          log("override: backend set to webgpu but browser does not support webgpu");
          instance.config.backend = "humangl";
        } else {
          const adapter = await navigator["gpu"].requestAdapter();
          if (instance.config.debug)
            log("enumerated webgpu adapter:", adapter);
        }
      }
      if (instance.config.backend === "humangl")
        await register(instance);
      const available = Object.keys(Ss().registryFactory);
      if (instance.config.debug)
        log("available backends:", available);
      if (!available.includes(instance.config.backend)) {
        log(`error: backend ${instance.config.backend} not found in registry`);
        instance.config.backend = env.node ? "tensorflow" : "webgl";
        if (instance.config.debug)
          log(`override: setting backend ${instance.config.backend}`);
      }
      if (instance.config.debug)
        log("setting backend:", instance.config.backend);
      if (instance.config.backend === "wasm") {
        if (instance.config.debug)
          log("wasm path:", instance.config.wasmPath);
        if (typeof (tfjs_esm_exports == null ? void 0 : tfjs_esm_exports.setWasmPaths) !== "undefined")
          await Spe(instance.config.wasmPath, instance.config.wasmPlatformFetch);
        else
          throw new Error("backend error: attempting to use wasm backend but wasm path is not set");
        const simd = await X2().getAsync("WASM_HAS_SIMD_SUPPORT");
        const mt2 = await X2().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
        if (instance.config.debug)
          log(`wasm execution: ${simd ? "SIMD" : "no SIMD"} ${mt2 ? "multithreaded" : "singlethreaded"}`);
        if (instance.config.debug && !simd)
          log("warning: wasm simd support is not enabled");
      }
      try {
        await Ide(instance.config.backend);
        await Sde();
        init();
      } catch (err) {
        log("error: cannot set backend:", instance.config.backend, err);
        return false;
      }
    }
    if (Cde() === "humangl") {
      jw.set("CHECK_COMPUTATION_FOR_ERRORS", false);
      jw.set("WEBGL_CPU_FORWARD", true);
      jw.set("WEBGL_USE_SHAPES_UNIFORMS", true);
      jw.set("CPU_HANDOFF_SIZE_THRESHOLD", 256);
      if (typeof instance.config["deallocate"] !== "undefined" && instance.config["deallocate"]) {
        log("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:", true);
        jw.set("WEBGL_DELETE_TEXTURE_THRESHOLD", 0);
      }
      if ($A().getGPGPUContext) {
        const gl2 = await $A().getGPGPUContext().gl;
        if (instance.config.debug)
          log(`gl version:${gl2.getParameter(gl2.VERSION)} renderer:${gl2.getParameter(gl2.RENDERER)}`);
      }
    }
    if (Cde() === "webgpu") {
    }
    bde();
    await Sde();
    instance.performance.initBackend = Math.trunc(now2() - timeStamp);
    instance.config.backend = Cde();
    await env.updateBackend();
    registerCustomOps();
  }
  return true;
}
function fakeOps(kernelNames, config3) {
  for (const kernelName of kernelNames) {
    const kernelConfig = {
      kernelName,
      backendName: config3.backend,
      kernelFunc: () => {
        if (config3.debug)
          log("kernelFunc", kernelName, config3.backend);
      }
    };
    _l(kernelConfig);
  }
  env.kernels = Qf(Cde()).map((kernel) => kernel.kernelName.toLowerCase());
}
var options3 = {
  color: "rgba(173, 216, 230, 0.6)",
  labelColor: "rgba(173, 216, 230, 1)",
  shadowColor: "black",
  font: 'small-caps 16px "Segoe UI"',
  lineHeight: 18,
  lineWidth: 4,
  pointSize: 2,
  roundRect: 8,
  drawPoints: false,
  drawLabels: true,
  drawBoxes: true,
  drawGestures: true,
  drawPolygons: true,
  drawGaze: true,
  fillPolygons: false,
  useDepth: true,
  useCurves: false
};
var drawTime = 0;
var getCanvasContext = (input) => {
  if (!input)
    log("draw error: invalid canvas");
  else if (!input.getContext)
    log("draw error: canvas context not defined");
  else {
    const ctx = input.getContext("2d");
    if (!ctx)
      log("draw error: cannot get canvas context");
    else
      return ctx;
  }
  return null;
};
var rad2deg = (theta) => Math.round(theta * 180 / Math.PI);
function point(ctx, x10, y10, z10, localOptions) {
  z10 = z10 || 0;
  ctx.fillStyle = localOptions.useDepth && z10 ? `rgba(${127.5 + 2 * z10}, ${127.5 - 2 * z10}, 255, 0.3)` : localOptions.color;
  ctx.beginPath();
  ctx.arc(x10, y10, localOptions.pointSize, 0, 2 * Math.PI);
  ctx.fill();
}
function rect(ctx, x10, y10, width, height, localOptions) {
  ctx.beginPath();
  ctx.lineWidth = localOptions.lineWidth;
  if (localOptions.useCurves) {
    const cx2 = (x10 + x10 + width) / 2;
    const cy2 = (y10 + y10 + height) / 2;
    ctx.ellipse(cx2, cy2, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    ctx.moveTo(x10 + localOptions.roundRect, y10);
    ctx.lineTo(x10 + width - localOptions.roundRect, y10);
    ctx.quadraticCurveTo(x10 + width, y10, x10 + width, y10 + localOptions.roundRect);
    ctx.lineTo(x10 + width, y10 + height - localOptions.roundRect);
    ctx.quadraticCurveTo(x10 + width, y10 + height, x10 + width - localOptions.roundRect, y10 + height);
    ctx.lineTo(x10 + localOptions.roundRect, y10 + height);
    ctx.quadraticCurveTo(x10, y10 + height, x10, y10 + height - localOptions.roundRect);
    ctx.lineTo(x10, y10 + localOptions.roundRect);
    ctx.quadraticCurveTo(x10, y10, x10 + localOptions.roundRect, y10);
    ctx.closePath();
  }
  ctx.stroke();
}
function lines(ctx, points, localOptions) {
  if (points.length < 2)
    return;
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1]);
  for (const pt2 of points) {
    const z10 = pt2[2] || 0;
    ctx.strokeStyle = localOptions.useDepth && z10 !== 0 ? `rgba(${127.5 + 2 * z10}, ${127.5 - 2 * z10}, 255, 0.3)` : localOptions.color;
    ctx.fillStyle = localOptions.useDepth && z10 !== 0 ? `rgba(${127.5 + 2 * z10}, ${127.5 - 2 * z10}, 255, 0.3)` : localOptions.color;
    ctx.lineTo(pt2[0], Math.round(pt2[1]));
  }
  ctx.stroke();
  if (localOptions.fillPolygons) {
    ctx.closePath();
    ctx.fill();
  }
}
function curves(ctx, points, localOptions) {
  if (points.length < 2)
    return;
  ctx.lineWidth = localOptions.lineWidth;
  if (!localOptions.useCurves || points.length <= 2) {
    lines(ctx, points, localOptions);
    return;
  }
  ctx.moveTo(points[0][0], points[0][1]);
  for (let i10 = 0; i10 < points.length - 2; i10++) {
    const xc = (points[i10][0] + points[i10 + 1][0]) / 2;
    const yc = (points[i10][1] + points[i10 + 1][1]) / 2;
    ctx.quadraticCurveTo(points[i10][0], points[i10][1], xc, yc);
  }
  ctx.quadraticCurveTo(points[points.length - 2][0], points[points.length - 2][1], points[points.length - 1][0], points[points.length - 1][1]);
  ctx.stroke();
  if (localOptions.fillPolygons) {
    ctx.closePath();
    ctx.fill();
  }
}
function arrow(ctx, from, to2, radius = 5) {
  let angle2;
  let x10;
  let y10;
  ctx.beginPath();
  ctx.moveTo(from[0], from[1]);
  ctx.lineTo(to2[0], to2[1]);
  angle2 = Math.atan2(to2[1] - from[1], to2[0] - from[0]);
  x10 = radius * Math.cos(angle2) + to2[0];
  y10 = radius * Math.sin(angle2) + to2[1];
  ctx.moveTo(x10, y10);
  angle2 += 1 / 3 * (2 * Math.PI);
  x10 = radius * Math.cos(angle2) + to2[0];
  y10 = radius * Math.sin(angle2) + to2[1];
  ctx.lineTo(x10, y10);
  angle2 += 1 / 3 * (2 * Math.PI);
  x10 = radius * Math.cos(angle2) + to2[0];
  y10 = radius * Math.sin(angle2) + to2[1];
  ctx.lineTo(x10, y10);
  ctx.closePath();
  ctx.stroke();
  ctx.fill();
}
async function gesture(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  if (localOptions.drawGestures) {
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.font = localOptions.font;
    ctx.fillStyle = localOptions.color;
    let i10 = 1;
    for (let j10 = 0; j10 < result.length; j10++) {
      let where = [];
      let what = [];
      [where, what] = Object.entries(result[j10]);
      if (what.length > 1 && what[1].length > 0) {
        const who = where[1] > 0 ? `#${where[1]}` : "";
        const label = `${where[0]} ${who}: ${what[1]}`;
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(label, 8, 2 + i10 * localOptions.lineHeight);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(label, 6, 0 + i10 * localOptions.lineHeight);
        i10 += 1;
      }
    }
  }
}
async function face(inCanvas2, result, drawOptions) {
  var _a2, _b2, _c, _d2, _e22;
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  if (!ctx)
    return;
  for (const f10 of result) {
    ctx.font = localOptions.font;
    ctx.strokeStyle = localOptions.color;
    ctx.fillStyle = localOptions.color;
    if (localOptions.drawBoxes)
      rect(ctx, f10.box[0], f10.box[1], f10.box[2], f10.box[3], localOptions);
    if (localOptions.drawLabels) {
      const labels2 = [];
      labels2.push(`face: ${Math.trunc(100 * f10.score)}%`);
      if (f10.genderScore)
        labels2.push(`${f10.gender || ""} ${Math.trunc(100 * f10.genderScore)}%`);
      if (f10.age)
        labels2.push(`age: ${f10.age || ""}`);
      if (f10.iris)
        labels2.push(`distance: ${f10.iris}`);
      if (f10.real)
        labels2.push(`real: ${Math.trunc(100 * f10.real)}%`);
      if (f10.live)
        labels2.push(`live: ${Math.trunc(100 * f10.live)}%`);
      if (f10.emotion && f10.emotion.length > 0) {
        const emotion = f10.emotion.map((a10) => `${Math.trunc(100 * a10.score)}% ${a10.emotion}`);
        if (emotion.length > 3)
          emotion.length = 3;
        labels2.push(emotion.join(" "));
      }
      if (f10.rotation && f10.rotation.angle && f10.rotation.gaze) {
        if (f10.rotation.angle.roll)
          labels2.push(`roll: ${rad2deg(f10.rotation.angle.roll)}\xB0 yaw:${rad2deg(f10.rotation.angle.yaw)}\xB0 pitch:${rad2deg(f10.rotation.angle.pitch)}\xB0`);
        if (f10.rotation.gaze.bearing)
          labels2.push(`gaze: ${rad2deg(f10.rotation.gaze.bearing)}\xB0`);
      }
      if (labels2.length === 0)
        labels2.push("face");
      ctx.fillStyle = localOptions.color;
      for (let i10 = labels2.length - 1; i10 >= 0; i10--) {
        const x10 = Math.max(f10.box[0], 0);
        const y10 = i10 * localOptions.lineHeight + f10.box[1];
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(labels2[i10], x10 + 5, y10 + 16);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(labels2[i10], x10 + 4, y10 + 15);
      }
    }
    ctx.lineWidth = 2;
    if (f10.mesh && f10.mesh.length > 0) {
      if (localOptions.drawPoints) {
        for (const pt2 of f10.mesh)
          point(ctx, pt2[0], pt2[1], pt2[2], localOptions);
      }
      if (localOptions.drawPolygons) {
        if (f10.mesh.length > 450) {
          for (let i10 = 0; i10 < TRI468.length / 3; i10++) {
            const points = [
              TRI468[i10 * 3 + 0],
              TRI468[i10 * 3 + 1],
              TRI468[i10 * 3 + 2]
            ].map((index2) => f10.mesh[index2]);
            lines(ctx, points, localOptions);
          }
        }
        if (f10.annotations && f10.annotations["leftEyeIris"] && f10.annotations["leftEyeIris"][0]) {
          ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
          ctx.beginPath();
          const sizeX = Math.abs(f10.annotations["leftEyeIris"][3][0] - f10.annotations["leftEyeIris"][1][0]) / 2;
          const sizeY = Math.abs(f10.annotations["leftEyeIris"][4][1] - f10.annotations["leftEyeIris"][2][1]) / 2;
          ctx.ellipse(f10.annotations["leftEyeIris"][0][0], f10.annotations["leftEyeIris"][0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (localOptions.fillPolygons) {
            ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
            ctx.fill();
          }
        }
        if (f10.annotations && f10.annotations["rightEyeIris"] && f10.annotations["rightEyeIris"][0]) {
          ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
          ctx.beginPath();
          const sizeX = Math.abs(f10.annotations["rightEyeIris"][3][0] - f10.annotations["rightEyeIris"][1][0]) / 2;
          const sizeY = Math.abs(f10.annotations["rightEyeIris"][4][1] - f10.annotations["rightEyeIris"][2][1]) / 2;
          ctx.ellipse(f10.annotations["rightEyeIris"][0][0], f10.annotations["rightEyeIris"][0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (localOptions.fillPolygons) {
            ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
            ctx.fill();
          }
        }
        if (localOptions.drawGaze && ((_a2 = f10.rotation) == null ? void 0 : _a2.angle) && typeof Path2D !== "undefined") {
          ctx.strokeStyle = "pink";
          const valX = f10.box[0] + f10.box[2] / 2 - f10.box[3] * rad2deg(f10.rotation.angle.yaw) / 90;
          const valY = f10.box[1] + f10.box[3] / 2 + f10.box[2] * rad2deg(f10.rotation.angle.pitch) / 90;
          const pathV = new Path2D(`
            M ${f10.box[0] + f10.box[2] / 2} ${f10.box[1]}
            C
              ${valX} ${f10.box[1]},
              ${valX} ${f10.box[1] + f10.box[3]},
              ${f10.box[0] + f10.box[2] / 2} ${f10.box[1] + f10.box[3]}
          `);
          const pathH = new Path2D(`
            M ${f10.box[0]} ${f10.box[1] + f10.box[3] / 2}
            C 
              ${f10.box[0]} ${valY},
              ${f10.box[0] + f10.box[2]} ${valY},
              ${f10.box[0] + f10.box[2]} ${f10.box[1] + f10.box[3] / 2}
          `);
          ctx.stroke(pathH);
          ctx.stroke(pathV);
        }
        if (localOptions.drawGaze && ((_c = (_b2 = f10.rotation) == null ? void 0 : _b2.gaze) == null ? void 0 : _c.strength) && ((_e22 = (_d2 = f10.rotation) == null ? void 0 : _d2.gaze) == null ? void 0 : _e22.bearing) && f10.annotations["leftEyeIris"] && f10.annotations["rightEyeIris"] && f10.annotations["leftEyeIris"][0] && f10.annotations["rightEyeIris"][0]) {
          ctx.strokeStyle = "pink";
          ctx.fillStyle = "pink";
          const leftGaze = [
            f10.annotations["leftEyeIris"][0][0] + Math.sin(f10.rotation.gaze.bearing) * f10.rotation.gaze.strength * f10.box[3],
            f10.annotations["leftEyeIris"][0][1] + Math.cos(f10.rotation.gaze.bearing) * f10.rotation.gaze.strength * f10.box[2]
          ];
          arrow(ctx, [f10.annotations["leftEyeIris"][0][0], f10.annotations["leftEyeIris"][0][1]], [leftGaze[0], leftGaze[1]], 4);
          const rightGaze = [
            f10.annotations["rightEyeIris"][0][0] + Math.sin(f10.rotation.gaze.bearing) * f10.rotation.gaze.strength * f10.box[3],
            f10.annotations["rightEyeIris"][0][1] + Math.cos(f10.rotation.gaze.bearing) * f10.rotation.gaze.strength * f10.box[2]
          ];
          arrow(ctx, [f10.annotations["rightEyeIris"][0][0], f10.annotations["rightEyeIris"][0][1]], [rightGaze[0], rightGaze[1]], 4);
        }
      }
    }
  }
}
async function body(inCanvas2, result, drawOptions) {
  var _a2;
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  if (!ctx)
    return;
  ctx.lineJoin = "round";
  for (let i10 = 0; i10 < result.length; i10++) {
    ctx.strokeStyle = localOptions.color;
    ctx.fillStyle = localOptions.color;
    ctx.lineWidth = localOptions.lineWidth;
    ctx.font = localOptions.font;
    if (localOptions.drawBoxes && result[i10].box && ((_a2 = result[i10].box) == null ? void 0 : _a2.length) === 4) {
      rect(ctx, result[i10].box[0], result[i10].box[1], result[i10].box[2], result[i10].box[3], localOptions);
      if (localOptions.drawLabels) {
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(`body ${100 * result[i10].score}%`, result[i10].box[0] + 3, 1 + result[i10].box[1] + localOptions.lineHeight, result[i10].box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(`body ${100 * result[i10].score}%`, result[i10].box[0] + 2, 0 + result[i10].box[1] + localOptions.lineHeight, result[i10].box[2]);
      }
    }
    if (localOptions.drawPoints && result[i10].keypoints) {
      for (let pt2 = 0; pt2 < result[i10].keypoints.length; pt2++) {
        if (!result[i10].keypoints[pt2].score || result[i10].keypoints[pt2].score === 0)
          continue;
        ctx.fillStyle = localOptions.useDepth && result[i10].keypoints[pt2].position[2] ? `rgba(${127.5 + 2 * (result[i10].keypoints[pt2].position[2] || 0)}, ${127.5 - 2 * (result[i10].keypoints[pt2].position[2] || 0)}, 255, 0.5)` : localOptions.color;
        point(ctx, result[i10].keypoints[pt2].position[0], result[i10].keypoints[pt2].position[1], 0, localOptions);
      }
    }
    if (localOptions.drawLabels && result[i10].keypoints) {
      ctx.font = localOptions.font;
      for (const pt2 of result[i10].keypoints) {
        if (!pt2.score || pt2.score === 0)
          continue;
        ctx.fillStyle = localOptions.useDepth && pt2.position[2] ? `rgba(${127.5 + 2 * pt2.position[2]}, ${127.5 - 2 * pt2.position[2]}, 255, 0.5)` : localOptions.color;
        ctx.fillText(`${pt2.part} ${Math.trunc(100 * pt2.score)}%`, pt2.position[0] + 4, pt2.position[1] + 4);
      }
    }
    if (localOptions.drawPolygons && result[i10].keypoints && result[i10].annotations) {
      for (const part of Object.values(result[i10].annotations)) {
        for (const connected4 of part)
          curves(ctx, connected4, localOptions);
      }
    }
  }
}
async function hand(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  if (!ctx)
    return;
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (const h10 of result) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, h10.box[0], h10.box[1], h10.box[2], h10.box[3], localOptions);
      if (localOptions.drawLabels) {
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(`hand:${Math.trunc(100 * h10.score)}%`, h10.box[0] + 3, 1 + h10.box[1] + localOptions.lineHeight, h10.box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(`hand:${Math.trunc(100 * h10.score)}%`, h10.box[0] + 2, 0 + h10.box[1] + localOptions.lineHeight, h10.box[2]);
      }
      ctx.stroke();
    }
    if (localOptions.drawPoints) {
      if (h10.keypoints && h10.keypoints.length > 0) {
        for (const pt2 of h10.keypoints) {
          ctx.fillStyle = localOptions.useDepth ? `rgba(${127.5 + 2 * (pt2[2] || 0)}, ${127.5 - 2 * (pt2[2] || 0)}, 255, 0.5)` : localOptions.color;
          point(ctx, pt2[0], pt2[1], 0, localOptions);
        }
      }
    }
    if (localOptions.drawLabels && h10.annotations) {
      const addHandLabel = (part, title) => {
        if (!part || part.length === 0 || !part[0])
          return;
        const z10 = part[part.length - 1][2] || 0;
        ctx.fillStyle = localOptions.useDepth ? `rgba(${127.5 + 2 * z10}, ${127.5 - 2 * z10}, 255, 0.5)` : localOptions.color;
        ctx.fillText(title, part[part.length - 1][0] + 4, part[part.length - 1][1] + 4);
      };
      ctx.font = localOptions.font;
      addHandLabel(h10.annotations["index"], "index");
      addHandLabel(h10.annotations["middle"], "middle");
      addHandLabel(h10.annotations["ring"], "ring");
      addHandLabel(h10.annotations["pinky"], "pinky");
      addHandLabel(h10.annotations["thumb"], "thumb");
      addHandLabel(h10.annotations["palm"], "palm");
    }
    if (localOptions.drawPolygons && h10.annotations) {
      const addHandLine = (part) => {
        if (!part || part.length === 0 || !part[0])
          return;
        for (let i10 = 0; i10 < part.length; i10++) {
          ctx.beginPath();
          const z10 = part[i10][2] || 0;
          ctx.strokeStyle = localOptions.useDepth ? `rgba(${127.5 + i10 * z10}, ${127.5 - i10 * z10}, 255, 0.5)` : localOptions.color;
          ctx.moveTo(part[i10 > 0 ? i10 - 1 : 0][0], part[i10 > 0 ? i10 - 1 : 0][1]);
          ctx.lineTo(part[i10][0], part[i10][1]);
          ctx.stroke();
        }
      };
      ctx.lineWidth = localOptions.lineWidth;
      addHandLine(h10.annotations["index"]);
      addHandLine(h10.annotations["middle"]);
      addHandLine(h10.annotations["ring"]);
      addHandLine(h10.annotations["pinky"]);
      addHandLine(h10.annotations["thumb"]);
    }
  }
}
async function object(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  if (!ctx)
    return;
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (const h10 of result) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, h10.box[0], h10.box[1], h10.box[2], h10.box[3], localOptions);
      if (localOptions.drawLabels) {
        const label = `${h10.label} ${Math.round(100 * h10.score)}%`;
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(label, h10.box[0] + 3, 1 + h10.box[1] + localOptions.lineHeight, h10.box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(label, h10.box[0] + 2, 0 + h10.box[1] + localOptions.lineHeight, h10.box[2]);
      }
      ctx.stroke();
    }
  }
}
async function person(inCanvas2, result, drawOptions) {
  const localOptions = mergeDeep(options3, drawOptions);
  if (!result || !inCanvas2)
    return;
  const ctx = getCanvasContext(inCanvas2);
  if (!ctx)
    return;
  ctx.lineJoin = "round";
  ctx.font = localOptions.font;
  for (let i10 = 0; i10 < result.length; i10++) {
    if (localOptions.drawBoxes) {
      ctx.strokeStyle = localOptions.color;
      ctx.fillStyle = localOptions.color;
      rect(ctx, result[i10].box[0], result[i10].box[1], result[i10].box[2], result[i10].box[3], localOptions);
      if (localOptions.drawLabels) {
        const label = `person #${i10}`;
        if (localOptions.shadowColor && localOptions.shadowColor !== "") {
          ctx.fillStyle = localOptions.shadowColor;
          ctx.fillText(label, result[i10].box[0] + 3, 1 + result[i10].box[1] + localOptions.lineHeight, result[i10].box[2]);
        }
        ctx.fillStyle = localOptions.labelColor;
        ctx.fillText(label, result[i10].box[0] + 2, 0 + result[i10].box[1] + localOptions.lineHeight, result[i10].box[2]);
      }
      ctx.stroke();
    }
  }
}
async function canvas2(input, output) {
  if (!input || !output)
    return;
  const ctx = getCanvasContext(output);
  if (!ctx)
    return;
  ctx.drawImage(input, 0, 0);
}
async function all(inCanvas2, result, drawOptions) {
  if (!result || !result.performance || !result || !inCanvas2)
    return null;
  const timeStamp = now2();
  const localOptions = mergeDeep(options3, drawOptions);
  const promise = Promise.all([
    face(inCanvas2, result.face, localOptions),
    body(inCanvas2, result.body, localOptions),
    hand(inCanvas2, result.hand, localOptions),
    object(inCanvas2, result.object, localOptions),
    gesture(inCanvas2, result.gesture, localOptions)
  ]);
  drawTime = env.perfadd ? drawTime + Math.round(now2() - timeStamp) : Math.round(now2() - timeStamp);
  result.performance.draw = drawTime;
  return promise;
}
var expandFact = 0.1;
var alpha = 0.5;
function insidePoly(x10, y10, polygon) {
  let inside = false;
  let j10 = polygon.length - 1;
  for (let i10 = 0; i10 < polygon.length; j10 = i10++) {
    if (polygon[i10].y > y10 !== polygon[j10].y > y10 && x10 < (polygon[j10].x - polygon[i10].x) * (y10 - polygon[i10].y) / (polygon[j10].y - polygon[i10].y) + polygon[i10].x)
      inside = !inside;
  }
  return inside;
}
async function mask(face4) {
  if (!face4.tensor)
    return face4.tensor;
  if (!face4.mesh || face4.mesh.length < 100)
    return face4.tensor;
  const width = face4.tensor.shape[2] || 0;
  const height = face4.tensor.shape[1] || 0;
  const buffer = await face4.tensor.buffer();
  let silhouette = [];
  for (const pt2 of meshAnnotations.silhouette)
    silhouette.push({ x: (face4.mesh[pt2][0] - face4.box[0]) / face4.box[2], y: (face4.mesh[pt2][1] - face4.box[1]) / face4.box[3] });
  if (expandFact && expandFact > 0)
    silhouette = silhouette.map((pt2) => ({ x: pt2.x > 0.5 ? pt2.x + expandFact : pt2.x - expandFact, y: pt2.y > 0.5 ? pt2.y + expandFact : pt2.y - expandFact }));
  for (let x10 = 0; x10 < width; x10++) {
    for (let y10 = 0; y10 < height; y10++) {
      const inside = insidePoly(x10 / width, y10 / width, silhouette);
      if (!inside) {
        buffer.set(alpha * buffer.get(0, y10, x10, 0), 0, y10, x10, 0);
        buffer.set(alpha * buffer.get(0, y10, x10, 1), 0, y10, x10, 1);
        buffer.set(alpha * buffer.get(0, y10, x10, 2), 0, y10, x10, 2);
      }
    }
  }
  const output = buffer.toTensor();
  Re2(buffer);
  return output;
}
var calculateGaze = (face4) => {
  const radians = (pt1, pt2) => Math.atan2(pt1[1] - pt2[1], pt1[0] - pt2[0]);
  if (!face4.annotations["rightEyeIris"] || !face4.annotations["leftEyeIris"])
    return { bearing: 0, strength: 0 };
  const offsetIris = [0, -0.1];
  const eyeRatio = 1;
  const left = (face4.mesh[33][2] || 0) > (face4.mesh[263][2] || 0);
  const irisCenter = left ? face4.mesh[473] : face4.mesh[468];
  const eyeCenter = left ? [(face4.mesh[133][0] + face4.mesh[33][0]) / 2, (face4.mesh[133][1] + face4.mesh[33][1]) / 2] : [(face4.mesh[263][0] + face4.mesh[362][0]) / 2, (face4.mesh[263][1] + face4.mesh[362][1]) / 2];
  const eyeSize = left ? [face4.mesh[133][0] - face4.mesh[33][0], face4.mesh[23][1] - face4.mesh[27][1]] : [face4.mesh[263][0] - face4.mesh[362][0], face4.mesh[253][1] - face4.mesh[257][1]];
  const eyeDiff = [
    (eyeCenter[0] - irisCenter[0]) / eyeSize[0] - offsetIris[0],
    eyeRatio * (irisCenter[1] - eyeCenter[1]) / eyeSize[1] - offsetIris[1]
  ];
  let strength = Math.sqrt(eyeDiff[0] * eyeDiff[0] + eyeDiff[1] * eyeDiff[1]);
  strength = Math.min(strength, face4.boxRaw[2] / 2, face4.boxRaw[3] / 2);
  const bearing = (radians([0, 0], eyeDiff) + Math.PI / 2) % Math.PI;
  return { bearing, strength };
};
var calculateFaceAngle = (face4, imageSize) => {
  const normalize = (v10) => {
    const length = Math.sqrt(v10[0] * v10[0] + v10[1] * v10[1] + v10[2] * v10[2]);
    v10[0] /= length;
    v10[1] /= length;
    v10[2] /= length;
    return v10;
  };
  const subVectors = (a10, b10) => {
    const x10 = a10[0] - b10[0];
    const y10 = a10[1] - b10[1];
    const z10 = a10[2] - b10[2];
    return [x10, y10, z10];
  };
  const crossVectors = (a10, b10) => {
    const x10 = a10[1] * b10[2] - a10[2] * b10[1];
    const y10 = a10[2] * b10[0] - a10[0] * b10[2];
    const z10 = a10[0] * b10[1] - a10[1] * b10[0];
    return [x10, y10, z10];
  };
  const rotationMatrixToEulerAngle = (r10) => {
    const [r00, _r01, _r02, r102, r11, r12, r20, r21, r22] = r10;
    let thetaX;
    let thetaY;
    let thetaZ;
    if (r102 < 1) {
      if (r102 > -1) {
        thetaZ = Math.asin(r102);
        thetaY = Math.atan2(-r20, r00);
        thetaX = Math.atan2(-r12, r11);
      } else {
        thetaZ = -Math.PI / 2;
        thetaY = -Math.atan2(r21, r22);
        thetaX = 0;
      }
    } else {
      thetaZ = Math.PI / 2;
      thetaY = Math.atan2(r21, r22);
      thetaX = 0;
    }
    if (isNaN(thetaX))
      thetaX = 0;
    if (isNaN(thetaY))
      thetaY = 0;
    if (isNaN(thetaZ))
      thetaZ = 0;
    return { pitch: 2 * -thetaX, yaw: 2 * -thetaY, roll: 2 * -thetaZ };
  };
  const mesh = face4.meshRaw;
  if (!mesh || mesh.length < 300)
    return { angle: { pitch: 0, yaw: 0, roll: 0 }, matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1], gaze: { bearing: 0, strength: 0 } };
  const size2 = Math.max(face4.boxRaw[2] * imageSize[0], face4.boxRaw[3] * imageSize[1]) / 1.5;
  const pts = [mesh[10], mesh[152], mesh[234], mesh[454]].map((pt2) => [pt2[0] * imageSize[0] / size2, pt2[1] * imageSize[1] / size2, pt2[2]]);
  const y_axis = normalize(subVectors(pts[1], pts[0]));
  let x_axis = normalize(subVectors(pts[3], pts[2]));
  const z_axis = normalize(crossVectors(x_axis, y_axis));
  x_axis = crossVectors(y_axis, z_axis);
  const matrix = [
    x_axis[0],
    x_axis[1],
    x_axis[2],
    y_axis[0],
    y_axis[1],
    y_axis[2],
    z_axis[0],
    z_axis[1],
    z_axis[2]
  ];
  const angle2 = rotationMatrixToEulerAngle(matrix);
  const gaze = mesh.length === 478 ? calculateGaze(face4) : { bearing: 0, strength: 0 };
  return { angle: angle2, matrix, gaze };
};
var detectFace = async (instance, input) => {
  var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q22, _r2, _s2, _t2, _u2, _v2;
  let timeStamp = now2();
  let ageRes;
  let gearRes;
  let genderRes;
  let emotionRes;
  let mobilefacenetRes;
  let antispoofRes;
  let livenessRes;
  let descRes;
  const faceRes = [];
  instance.state = "run:face";
  const faces = await predict10(input, instance.config);
  instance.performance.face = env.perfadd ? (instance.performance.face || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
  if (!input.shape || input.shape.length !== 4)
    return [];
  if (!faces)
    return [];
  for (let i10 = 0; i10 < faces.length; i10++) {
    instance.analyze("Get Face");
    if (!faces[i10].tensor || faces[i10].tensor["isDisposedInternal"]) {
      log("Face object is disposed:", faces[i10].tensor);
      continue;
    }
    if ((_a2 = instance.config.face.detector) == null ? void 0 : _a2.mask) {
      const masked = await mask(faces[i10]);
      Re2(faces[i10].tensor);
      faces[i10].tensor = masked;
    }
    const rotation = faces[i10].mesh && faces[i10].mesh.length > 200 ? calculateFaceAngle(faces[i10], [input.shape[2], input.shape[1]]) : null;
    instance.analyze("Start Emotion:");
    if (instance.config.async) {
      emotionRes = ((_b2 = instance.config.face.emotion) == null ? void 0 : _b2.enabled) ? predict8(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : [];
    } else {
      instance.state = "run:emotion";
      timeStamp = now2();
      emotionRes = ((_c = instance.config.face.emotion) == null ? void 0 : _c.enabled) ? await predict8(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : [];
      instance.performance.emotion = env.perfadd ? (instance.performance.emotion || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End Emotion:");
    instance.analyze("Start AntiSpoof:");
    if (instance.config.async) {
      antispoofRes = ((_d2 = instance.config.face.antispoof) == null ? void 0 : _d2.enabled) ? predict4(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : 0;
    } else {
      instance.state = "run:antispoof";
      timeStamp = now2();
      antispoofRes = ((_e22 = instance.config.face.antispoof) == null ? void 0 : _e22.enabled) ? await predict4(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : 0;
      instance.performance.antispoof = env.perfadd ? (instance.performance.antispoof || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End AntiSpoof:");
    instance.analyze("Start Liveness:");
    if (instance.config.async) {
      livenessRes = ((_f = instance.config.face.liveness) == null ? void 0 : _f.enabled) ? predict14(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : 0;
    } else {
      instance.state = "run:liveness";
      timeStamp = now2();
      livenessRes = ((_g2 = instance.config.face.liveness) == null ? void 0 : _g2.enabled) ? await predict14(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : 0;
      instance.performance.liveness = env.perfadd ? (instance.performance.antispoof || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End Liveness:");
    instance.analyze("Start GEAR:");
    if (instance.config.async) {
      gearRes = ((_h = instance.config.face["gear"]) == null ? void 0 : _h.enabled) ? predict(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
    } else {
      instance.state = "run:gear";
      timeStamp = now2();
      gearRes = ((_i = instance.config.face["gear"]) == null ? void 0 : _i.enabled) ? await predict(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      instance.performance.gear = Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End GEAR:");
    instance.analyze("Start SSRNet:");
    if (instance.config.async) {
      ageRes = ((_j2 = instance.config.face["ssrnet"]) == null ? void 0 : _j2.enabled) ? predict2(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      genderRes = ((_k2 = instance.config.face["ssrnet"]) == null ? void 0 : _k2.enabled) ? predict3(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
    } else {
      instance.state = "run:ssrnet";
      timeStamp = now2();
      ageRes = ((_l2 = instance.config.face["ssrnet"]) == null ? void 0 : _l2.enabled) ? await predict2(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      genderRes = ((_m2 = instance.config.face["ssrnet"]) == null ? void 0 : _m2.enabled) ? await predict3(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      instance.performance.ssrnet = Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End SSRNet:");
    instance.analyze("Start MobileFaceNet:");
    if (instance.config.async) {
      mobilefacenetRes = ((_n2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _n2.enabled) ? predict9(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
    } else {
      instance.state = "run:mobilefacenet";
      timeStamp = now2();
      mobilefacenetRes = ((_o2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _o2.enabled) ? await predict9(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      instance.performance.mobilefacenet = Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End MobileFaceNet:");
    instance.analyze("Start Description:");
    if (instance.config.async) {
      descRes = ((_p2 = instance.config.face.description) == null ? void 0 : _p2.enabled) ? predict11(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
    } else {
      instance.state = "run:description";
      timeStamp = now2();
      descRes = ((_q22 = instance.config.face.description) == null ? void 0 : _q22.enabled) ? await predict11(faces[i10].tensor || hs([]), instance.config, i10, faces.length) : null;
      instance.performance.description = env.perfadd ? (instance.performance.description || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
    }
    instance.analyze("End Description:");
    if (instance.config.async) {
      [ageRes, genderRes, emotionRes, mobilefacenetRes, descRes, gearRes, antispoofRes, livenessRes] = await Promise.all([ageRes, genderRes, emotionRes, mobilefacenetRes, descRes, gearRes, antispoofRes, livenessRes]);
    }
    instance.analyze("Finish Face:");
    if (((_r2 = instance.config.face["ssrnet"]) == null ? void 0 : _r2.enabled) && ageRes && genderRes) {
      descRes = {
        ...descRes,
        age: ageRes.age,
        gender: genderRes.gender,
        genderScore: genderRes.genderScore
      };
    }
    if (((_s2 = instance.config.face["gear"]) == null ? void 0 : _s2.enabled) && gearRes) {
      descRes = {
        ...descRes,
        age: gearRes.age,
        gender: gearRes.gender,
        genderScore: gearRes.genderScore,
        race: gearRes.race
      };
    }
    if (((_t2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _t2.enabled) && mobilefacenetRes) {
      descRes.descriptor = mobilefacenetRes;
    }
    if (!((_u2 = instance.config.face.iris) == null ? void 0 : _u2.enabled)) {
    }
    const irisSize = faces[i10].annotations && faces[i10].annotations.leftEyeIris && faces[i10].annotations.leftEyeIris[0] && faces[i10].annotations.rightEyeIris && faces[i10].annotations.rightEyeIris[0] && faces[i10].annotations.leftEyeIris.length > 0 && faces[i10].annotations.rightEyeIris.length > 0 && faces[i10].annotations.leftEyeIris[0] !== null && faces[i10].annotations.rightEyeIris[0] !== null ? Math.max(Math.abs(faces[i10].annotations.leftEyeIris[3][0] - faces[i10].annotations.leftEyeIris[1][0]), Math.abs(faces[i10].annotations.rightEyeIris[4][1] - faces[i10].annotations.rightEyeIris[2][1])) / input.shape[2] : 0;
    const tensor = ((_v2 = instance.config.face.detector) == null ? void 0 : _v2.return) ? mr(faces[i10].tensor) : null;
    Re2(faces[i10].tensor);
    if (faces[i10].tensor)
      delete faces[i10].tensor;
    const res2 = {
      ...faces[i10],
      id: i10
    };
    if (descRes == null ? void 0 : descRes.age)
      res2.age = descRes.age;
    if (descRes == null ? void 0 : descRes.gender)
      res2.gender = descRes.gender;
    if (descRes == null ? void 0 : descRes.genderScore)
      res2.genderScore = descRes == null ? void 0 : descRes.genderScore;
    if (descRes == null ? void 0 : descRes.descriptor)
      res2.embedding = descRes == null ? void 0 : descRes.descriptor;
    if (descRes == null ? void 0 : descRes.race)
      res2.race = descRes == null ? void 0 : descRes.race;
    if (emotionRes)
      res2.emotion = emotionRes;
    if (antispoofRes)
      res2.real = antispoofRes;
    if (livenessRes)
      res2.live = livenessRes;
    if (irisSize && irisSize !== 0)
      res2.iris = Math.trunc(500 / irisSize / 11.7) / 100;
    if (rotation)
      res2.rotation = rotation;
    if (tensor)
      res2.tensor = tensor;
    faceRes.push(res2);
    instance.analyze("End Face");
  }
  instance.analyze("End FaceMesh:");
  if (instance.config.async) {
    if (instance.performance.face)
      delete instance.performance.face;
    if (instance.performance.age)
      delete instance.performance.age;
    if (instance.performance.gender)
      delete instance.performance.gender;
    if (instance.performance.emotion)
      delete instance.performance.emotion;
  }
  return faceRes;
};
var body2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i10 = 0; i10 < res2.length; i10++) {
    const leftWrist = res2[i10].keypoints.find((a10) => a10.part === "leftWrist");
    const rightWrist = res2[i10].keypoints.find((a10) => a10.part === "rightWrist");
    const nose = res2[i10].keypoints.find((a10) => a10.part === "nose");
    if (nose && leftWrist && rightWrist && leftWrist.position[1] < nose.position[1] && rightWrist.position[1] < nose.position[1])
      gestures.push({ body: i10, gesture: "i give up" });
    else if (nose && leftWrist && leftWrist.position[1] < nose.position[1])
      gestures.push({ body: i10, gesture: "raise left hand" });
    else if (nose && rightWrist && rightWrist.position[1] < nose.position[1])
      gestures.push({ body: i10, gesture: "raise right hand" });
    const leftShoulder = res2[i10].keypoints.find((a10) => a10.part === "leftShoulder");
    const rightShoulder = res2[i10].keypoints.find((a10) => a10.part === "rightShoulder");
    if (leftShoulder && rightShoulder && Math.abs(leftShoulder.positionRaw[1] - rightShoulder.positionRaw[1]) > 0.1) {
      gestures.push({ body: i10, gesture: `leaning ${leftShoulder.position[1] > rightShoulder.position[1] ? "left" : "right"}` });
    }
  }
  return gestures;
};
var face2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i10 = 0; i10 < res2.length; i10++) {
    if (res2[i10].mesh && res2[i10].mesh.length > 450) {
      const zDiff = (res2[i10].mesh[33][2] || 0) - (res2[i10].mesh[263][2] || 0);
      const xDiff = res2[i10].mesh[33][0] - res2[i10].mesh[263][0];
      if (Math.abs(zDiff / xDiff) <= 0.15)
        gestures.push({ face: i10, gesture: "facing center" });
      else
        gestures.push({ face: i10, gesture: `facing ${zDiff < 0 ? "left" : "right"}` });
      const openLeft = Math.abs(res2[i10].mesh[374][1] - res2[i10].mesh[386][1]) / Math.abs(res2[i10].mesh[443][1] - res2[i10].mesh[450][1]);
      if (openLeft < 0.2)
        gestures.push({ face: i10, gesture: "blink left eye" });
      const openRight = Math.abs(res2[i10].mesh[145][1] - res2[i10].mesh[159][1]) / Math.abs(res2[i10].mesh[223][1] - res2[i10].mesh[230][1]);
      if (openRight < 0.2)
        gestures.push({ face: i10, gesture: "blink right eye" });
      const mouthOpen = Math.min(100, 500 * Math.abs(res2[i10].mesh[13][1] - res2[i10].mesh[14][1]) / Math.abs(res2[i10].mesh[10][1] - res2[i10].mesh[152][1]));
      if (mouthOpen > 10)
        gestures.push({ face: i10, gesture: `mouth ${Math.trunc(mouthOpen)}% open` });
      const chinDepth = res2[i10].mesh[152][2] || 0;
      if (Math.abs(chinDepth) > 10)
        gestures.push({ face: i10, gesture: `head ${chinDepth < 0 ? "up" : "down"}` });
    }
  }
  return gestures;
};
var iris = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i10 = 0; i10 < res2.length; i10++) {
    if (!res2[i10].annotations || !res2[i10].annotations.leftEyeIris || !res2[i10].annotations.leftEyeIris[0] || !res2[i10].annotations.rightEyeIris || !res2[i10].annotations.rightEyeIris[0])
      continue;
    const sizeXLeft = res2[i10].annotations.leftEyeIris[3][0] - res2[i10].annotations.leftEyeIris[1][0];
    const sizeYLeft = res2[i10].annotations.leftEyeIris[4][1] - res2[i10].annotations.leftEyeIris[2][1];
    const areaLeft = Math.abs(sizeXLeft * sizeYLeft);
    const sizeXRight = res2[i10].annotations.rightEyeIris[3][0] - res2[i10].annotations.rightEyeIris[1][0];
    const sizeYRight = res2[i10].annotations.rightEyeIris[4][1] - res2[i10].annotations.rightEyeIris[2][1];
    const areaRight = Math.abs(sizeXRight * sizeYRight);
    let center = false;
    const difference = Math.abs(areaLeft - areaRight) / Math.max(areaLeft, areaRight);
    if (difference < 0.25) {
      center = true;
      gestures.push({ iris: i10, gesture: "facing center" });
    }
    const leftIrisCenterX = Math.abs(res2[i10].mesh[263][0] - res2[i10].annotations.leftEyeIris[0][0]) / res2[i10].box[2];
    const rightIrisCenterX = Math.abs(res2[i10].mesh[33][0] - res2[i10].annotations.rightEyeIris[0][0]) / res2[i10].box[2];
    if (leftIrisCenterX > 0.06 || rightIrisCenterX > 0.06)
      center = false;
    if (leftIrisCenterX > rightIrisCenterX) {
      if (leftIrisCenterX > 0.05)
        gestures.push({ iris: i10, gesture: "looking right" });
    } else {
      if (rightIrisCenterX > 0.05)
        gestures.push({ iris: i10, gesture: "looking left" });
    }
    const rightIrisCenterY = Math.abs(res2[i10].mesh[145][1] - res2[i10].annotations.rightEyeIris[0][1]) / res2[i10].box[3];
    const leftIrisCenterY = Math.abs(res2[i10].mesh[374][1] - res2[i10].annotations.leftEyeIris[0][1]) / res2[i10].box[3];
    if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01 || leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
      center = false;
    if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01)
      gestures.push({ iris: i10, gesture: "looking down" });
    if (leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
      gestures.push({ iris: i10, gesture: "looking up" });
    if (center)
      gestures.push({ iris: i10, gesture: "looking center" });
  }
  return gestures;
};
var hand2 = (res2) => {
  if (!res2)
    return [];
  const gestures = [];
  for (let i10 = 0; i10 < res2.length; i10++) {
    const fingers = [];
    if (res2[i10]["annotations"]) {
      for (const [finger, pos] of Object.entries(res2[i10]["annotations"])) {
        if (finger !== "palmBase" && Array.isArray(pos) && pos[0])
          fingers.push({ name: finger.toLowerCase(), position: pos[0] });
      }
    }
    if (fingers && fingers.length > 0) {
      const closest = fingers.reduce((best, a10) => (best.position[2] || 0) < (a10.position[2] || 0) ? best : a10);
      gestures.push({ hand: i10, gesture: `${closest.name} forward` });
      const highest = fingers.reduce((best, a10) => best.position[1] < a10.position[1] ? best : a10);
      gestures.push({ hand: i10, gesture: `${highest.name} up` });
    }
    if (res2[i10]["keypoints"]) {
      const poses = match(res2[i10]["keypoints"]);
      for (const pose of poses)
        gestures.push({ hand: i10, gesture: pose.name });
    }
  }
  return gestures;
};
var bufferedResult = { face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0, error: null };
var interpolateTime = 0;
function calc2(newResult, config3) {
  var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q22, _r2, _s2, _t2, _u2, _v2, _w2, _x22, _y22, _z22, _A2;
  const t02 = now2();
  if (!newResult)
    return { face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0, error: null };
  const elapsed = Date.now() - newResult.timestamp;
  const bufferedFactor = elapsed < 1e3 ? 8 - Math.log(elapsed + 1) : 1;
  if (newResult.canvas)
    bufferedResult.canvas = newResult.canvas;
  if (newResult.error)
    bufferedResult.error = newResult.error;
  if (!bufferedResult.body || newResult.body.length !== bufferedResult.body.length) {
    bufferedResult.body = JSON.parse(JSON.stringify(newResult.body));
  } else {
    for (let i10 = 0; i10 < newResult.body.length; i10++) {
      const box = newResult.body[i10].box.map((newBoxCoord, j10) => ((bufferedFactor - 1) * bufferedResult.body[i10].box[j10] + newBoxCoord) / bufferedFactor);
      const boxRaw = newResult.body[i10].boxRaw.map((newBoxCoord, j10) => ((bufferedFactor - 1) * bufferedResult.body[i10].boxRaw[j10] + newBoxCoord) / bufferedFactor);
      const keypoints = newResult.body[i10].keypoints.map((newKpt, j10) => {
        var _a3, _b3, _c2, _d3, _e3, _f22, _g3, _h2, _i2;
        return {
          score: newKpt.score,
          part: newKpt.part,
          position: [
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].position[0] || 0) + (newKpt.position[0] || 0)) / bufferedFactor : newKpt.position[0],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].position[1] || 0) + (newKpt.position[1] || 0)) / bufferedFactor : newKpt.position[1],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].position[2] || 0) + (newKpt.position[2] || 0)) / bufferedFactor : newKpt.position[2]
          ],
          positionRaw: [
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].positionRaw[0] || 0) + (newKpt.positionRaw[0] || 0)) / bufferedFactor : newKpt.positionRaw[0],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].positionRaw[1] || 0) + (newKpt.positionRaw[1] || 0)) / bufferedFactor : newKpt.positionRaw[1],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j10].positionRaw[2] || 0) + (newKpt.positionRaw[2] || 0)) / bufferedFactor : newKpt.positionRaw[2]
          ],
          distance: [
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (((_a3 = bufferedResult.body[i10].keypoints[j10].distance) == null ? void 0 : _a3[0]) || 0) + (((_b3 = newKpt.distance) == null ? void 0 : _b3[0]) || 0)) / bufferedFactor : (_c2 = newKpt.distance) == null ? void 0 : _c2[0],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (((_d3 = bufferedResult.body[i10].keypoints[j10].distance) == null ? void 0 : _d3[1]) || 0) + (((_e3 = newKpt.distance) == null ? void 0 : _e3[1]) || 0)) / bufferedFactor : (_f22 = newKpt.distance) == null ? void 0 : _f22[1],
            bufferedResult.body[i10].keypoints[j10] ? ((bufferedFactor - 1) * (((_g3 = bufferedResult.body[i10].keypoints[j10].distance) == null ? void 0 : _g3[2]) || 0) + (((_h2 = newKpt.distance) == null ? void 0 : _h2[2]) || 0)) / bufferedFactor : (_i2 = newKpt.distance) == null ? void 0 : _i2[2]
          ]
        };
      });
      const annotations2 = {};
      let coords = { connected: {} };
      if ((_b2 = (_a2 = config3.body) == null ? void 0 : _a2.modelPath) == null ? void 0 : _b2.includes("efficientpose"))
        coords = efficientposecoords_exports;
      else if ((_d2 = (_c = config3.body) == null ? void 0 : _c.modelPath) == null ? void 0 : _d2.includes("blazepose"))
        coords = blazeposecoords_exports;
      else if ((_f = (_e22 = config3.body) == null ? void 0 : _e22.modelPath) == null ? void 0 : _f.includes("movenet"))
        coords = movenetcoords_exports;
      for (const [name, indexes] of Object.entries(coords.connected)) {
        const pt2 = [];
        for (let j10 = 0; j10 < indexes.length - 1; j10++) {
          const pt0 = keypoints.find((kp2) => kp2.part === indexes[j10]);
          const pt1 = keypoints.find((kp2) => kp2.part === indexes[j10 + 1]);
          if (pt0 && pt1)
            pt2.push([pt0.position, pt1.position]);
        }
        annotations2[name] = pt2;
      }
      bufferedResult.body[i10] = { ...newResult.body[i10], box, boxRaw, keypoints, annotations: annotations2 };
    }
  }
  if (!bufferedResult.hand || newResult.hand.length !== bufferedResult.hand.length) {
    bufferedResult.hand = JSON.parse(JSON.stringify(newResult.hand));
  } else {
    for (let i10 = 0; i10 < newResult.hand.length; i10++) {
      const box = newResult.hand[i10].box.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.hand[i10].box[j10] + b10) / bufferedFactor);
      const boxRaw = newResult.hand[i10].boxRaw.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.hand[i10].boxRaw[j10] + b10) / bufferedFactor);
      if (bufferedResult.hand[i10].keypoints.length !== newResult.hand[i10].keypoints.length)
        bufferedResult.hand[i10].keypoints = newResult.hand[i10].keypoints;
      const keypoints = newResult.hand[i10].keypoints && newResult.hand[i10].keypoints.length > 0 ? newResult.hand[i10].keypoints.map((landmark, j10) => landmark.map((coord, k10) => ((bufferedFactor - 1) * (bufferedResult.hand[i10].keypoints[j10][k10] || 1) + (coord || 0)) / bufferedFactor)) : [];
      let annotations2 = {};
      if (Object.keys(bufferedResult.hand[i10].annotations).length !== Object.keys(newResult.hand[i10].annotations).length) {
        bufferedResult.hand[i10].annotations = newResult.hand[i10].annotations;
        annotations2 = bufferedResult.hand[i10].annotations;
      } else if (newResult.hand[i10].annotations) {
        for (const key of Object.keys(newResult.hand[i10].annotations)) {
          annotations2[key] = newResult.hand[i10].annotations[key] && newResult.hand[i10].annotations[key][0] ? newResult.hand[i10].annotations[key].map((val, j10) => val.map((coord, k10) => ((bufferedFactor - 1) * bufferedResult.hand[i10].annotations[key][j10][k10] + coord) / bufferedFactor)) : null;
        }
      }
      bufferedResult.hand[i10] = { ...newResult.hand[i10], box, boxRaw, keypoints, annotations: annotations2 };
    }
  }
  if (!bufferedResult.face || newResult.face.length !== bufferedResult.face.length) {
    bufferedResult.face = JSON.parse(JSON.stringify(newResult.face));
  } else {
    for (let i10 = 0; i10 < newResult.face.length; i10++) {
      const box = newResult.face[i10].box.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.face[i10].box[j10] + b10) / bufferedFactor);
      const boxRaw = newResult.face[i10].boxRaw.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.face[i10].boxRaw[j10] + b10) / bufferedFactor);
      if (newResult.face[i10].rotation) {
        const rotation = { matrix: [0, 0, 0, 0, 0, 0, 0, 0, 0], angle: { roll: 0, yaw: 0, pitch: 0 }, gaze: { bearing: 0, strength: 0 } };
        rotation.matrix = (_g2 = newResult.face[i10].rotation) == null ? void 0 : _g2.matrix;
        rotation.angle = {
          roll: ((bufferedFactor - 1) * (((_i = (_h = bufferedResult.face[i10].rotation) == null ? void 0 : _h.angle) == null ? void 0 : _i.roll) || 0) + (((_k2 = (_j2 = newResult.face[i10].rotation) == null ? void 0 : _j2.angle) == null ? void 0 : _k2.roll) || 0)) / bufferedFactor,
          yaw: ((bufferedFactor - 1) * (((_m2 = (_l2 = bufferedResult.face[i10].rotation) == null ? void 0 : _l2.angle) == null ? void 0 : _m2.yaw) || 0) + (((_o2 = (_n2 = newResult.face[i10].rotation) == null ? void 0 : _n2.angle) == null ? void 0 : _o2.yaw) || 0)) / bufferedFactor,
          pitch: ((bufferedFactor - 1) * (((_q22 = (_p2 = bufferedResult.face[i10].rotation) == null ? void 0 : _p2.angle) == null ? void 0 : _q22.pitch) || 0) + (((_s2 = (_r2 = newResult.face[i10].rotation) == null ? void 0 : _r2.angle) == null ? void 0 : _s2.pitch) || 0)) / bufferedFactor
        };
        rotation.gaze = {
          bearing: ((bufferedFactor - 1) * (((_u2 = (_t2 = bufferedResult.face[i10].rotation) == null ? void 0 : _t2.gaze) == null ? void 0 : _u2.bearing) || 0) + (((_w2 = (_v2 = newResult.face[i10].rotation) == null ? void 0 : _v2.gaze) == null ? void 0 : _w2.bearing) || 0)) / bufferedFactor,
          strength: ((bufferedFactor - 1) * (((_y22 = (_x22 = bufferedResult.face[i10].rotation) == null ? void 0 : _x22.gaze) == null ? void 0 : _y22.strength) || 0) + (((_A2 = (_z22 = newResult.face[i10].rotation) == null ? void 0 : _z22.gaze) == null ? void 0 : _A2.strength) || 0)) / bufferedFactor
        };
        bufferedResult.face[i10] = { ...newResult.face[i10], rotation, box, boxRaw };
      }
      bufferedResult.face[i10] = { ...newResult.face[i10], box, boxRaw };
    }
  }
  if (!bufferedResult.object || newResult.object.length !== bufferedResult.object.length) {
    bufferedResult.object = JSON.parse(JSON.stringify(newResult.object));
  } else {
    for (let i10 = 0; i10 < newResult.object.length; i10++) {
      const box = newResult.object[i10].box.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.object[i10].box[j10] + b10) / bufferedFactor);
      const boxRaw = newResult.object[i10].boxRaw.map((b10, j10) => ((bufferedFactor - 1) * bufferedResult.object[i10].boxRaw[j10] + b10) / bufferedFactor);
      bufferedResult.object[i10] = { ...newResult.object[i10], box, boxRaw };
    }
  }
  if (newResult.persons) {
    const newPersons = newResult.persons;
    if (!bufferedResult.persons || newPersons.length !== bufferedResult.persons.length) {
      bufferedResult.persons = JSON.parse(JSON.stringify(newPersons));
    } else {
      for (let i10 = 0; i10 < newPersons.length; i10++) {
        bufferedResult.persons[i10].box = newPersons[i10].box.map((box, j10) => ((bufferedFactor - 1) * bufferedResult.persons[i10].box[j10] + box) / bufferedFactor);
      }
    }
  }
  if (newResult.gesture)
    bufferedResult.gesture = newResult.gesture;
  const t12 = now2();
  interpolateTime = env.perfadd ? interpolateTime + Math.round(t12 - t02) : Math.round(t12 - t02);
  if (newResult.performance)
    bufferedResult.performance = { ...newResult.performance, interpolate: interpolateTime };
  return bufferedResult;
}
function distance(descriptor1, descriptor2, options4 = { order: 2, multiplier: 25 }) {
  let sum = 0;
  for (let i10 = 0; i10 < descriptor1.length; i10++) {
    const diff = !options4.order || options4.order === 2 ? descriptor1[i10] - descriptor2[i10] : Math.abs(descriptor1[i10] - descriptor2[i10]);
    sum += !options4.order || options4.order === 2 ? diff * diff : diff ** options4.order;
  }
  return (options4.multiplier || 20) * sum;
}
var normalizeDistance = (dist, order, min, max) => {
  if (dist === 0)
    return 1;
  const root = order === 2 ? Math.sqrt(dist) : dist ** (1 / order);
  const norm = (1 - root / 100 - min) / (max - min);
  const clamp22 = Math.max(Math.min(norm, 1), 0);
  return clamp22;
};
function similarity(descriptor1, descriptor2, options4 = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }) {
  const dist = distance(descriptor1, descriptor2, options4);
  return normalizeDistance(dist, options4.order || 2, options4.min || 0, options4.max || 1);
}
function match2(descriptor, descriptors, options4 = { order: 2, multiplier: 25, threshold: 0, min: 0.2, max: 0.8 }) {
  if (!Array.isArray(descriptor) || !Array.isArray(descriptors) || descriptor.length < 64 || descriptors.length === 0 || descriptor.length !== descriptors[0].length) {
    return { index: -1, distance: Number.POSITIVE_INFINITY, similarity: 0 };
  }
  let lowestDistance = Number.MAX_SAFE_INTEGER;
  let index2 = -1;
  for (let i10 = 0; i10 < descriptors.length; i10++) {
    const res2 = distance(descriptor, descriptors[i10], options4);
    if (res2 < lowestDistance) {
      lowestDistance = res2;
      index2 = i10;
    }
    if (lowestDistance < (options4.threshold || 0))
      break;
  }
  const normalizedSimilarity = normalizeDistance(lowestDistance, options4.order || 2, options4.min || 0, options4.max || 1);
  return { index: index2, distance: lowestDistance, similarity: normalizedSimilarity };
}
function join2(faces, bodies, hands, gestures, shape) {
  var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i, _j2, _k2, _l2, _m2, _n2, _o2, _p2;
  let id2 = 0;
  const persons = [];
  for (const face4 of faces) {
    const person2 = { id: id2++, face: face4, body: null, hands: { left: null, right: null }, gestures: [], box: [0, 0, 0, 0] };
    for (const body4 of bodies) {
      if (face4.box[0] > body4.box[0] && face4.box[0] < body4.box[0] + body4.box[2] && face4.box[1] + face4.box[3] > body4.box[1] && face4.box[1] + face4.box[3] < body4.box[1] + body4.box[3]) {
        person2.body = body4;
      }
    }
    if (person2.body) {
      for (const hand3 of hands) {
        if (hand3.box[0] + hand3.box[2] > person2.body.box[0] && hand3.box[0] + hand3.box[2] < person2.body.box[0] + person2.body.box[2] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
          if (person2.hands)
            person2.hands.left = hand3;
        }
        if (hand3.box[0] < person2.body.box[0] + person2.body.box[2] && hand3.box[0] > person2.body.box[0] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
          if (person2.hands)
            person2.hands.right = hand3;
        }
      }
    }
    for (const gesture2 of gestures) {
      if (gesture2["face"] !== void 0 && gesture2["face"] === face4.id)
        (_a2 = person2.gestures) == null ? void 0 : _a2.push(gesture2);
      else if (gesture2["iris"] !== void 0 && gesture2["iris"] === face4.id)
        (_b2 = person2.gestures) == null ? void 0 : _b2.push(gesture2);
      else if (gesture2["body"] !== void 0 && gesture2["body"] === ((_c = person2.body) == null ? void 0 : _c.id))
        (_d2 = person2.gestures) == null ? void 0 : _d2.push(gesture2);
      else if (gesture2["hand"] !== void 0 && gesture2["hand"] === ((_f = (_e22 = person2.hands) == null ? void 0 : _e22.left) == null ? void 0 : _f.id))
        (_g2 = person2.gestures) == null ? void 0 : _g2.push(gesture2);
      else if (gesture2["hand"] !== void 0 && gesture2["hand"] === ((_i = (_h = person2.hands) == null ? void 0 : _h.right) == null ? void 0 : _i.id))
        (_j2 = person2.gestures) == null ? void 0 : _j2.push(gesture2);
    }
    const x10 = [];
    const y10 = [];
    const extractXY = (box) => {
      if (box && box.length === 4) {
        x10.push(box[0], box[0] + box[2]);
        y10.push(box[1], box[1] + box[3]);
      }
    };
    extractXY((_k2 = person2.face) == null ? void 0 : _k2.box);
    extractXY((_l2 = person2.body) == null ? void 0 : _l2.box);
    extractXY((_n2 = (_m2 = person2.hands) == null ? void 0 : _m2.left) == null ? void 0 : _n2.box);
    extractXY((_p2 = (_o2 = person2.hands) == null ? void 0 : _o2.right) == null ? void 0 : _p2.box);
    const minX = Math.min(...x10);
    const minY = Math.min(...y10);
    person2.box = [minX, minY, Math.max(...x10) - minX, Math.max(...y10) - minY];
    if (shape && shape[1] && shape[2])
      person2.boxRaw = [person2.box[0] / shape[2], person2.box[1] / shape[1], person2.box[2] / shape[2], person2.box[3] / shape[1]];
    persons.push(person2);
  }
  return persons;
}
var face3 = `
/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA
AAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu
bmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob
IxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo
KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E
AB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE
EQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH
SElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1
tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB
AQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET
IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla
Y2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML
Xp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF
PUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/
AJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z
5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9
zZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO
tHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6
8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W
wA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk
EtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6
GhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT
A7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep
rBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb
LCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ
ih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K
KAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l
pBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x
UqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4
HaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr
xL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS
NO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD
1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX
+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3
GBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K
q4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0
nhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm
uic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH
ArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV
wF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8
87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P
FQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD
YNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv
JmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ
QmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el
UJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681
ly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly
CK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc
UDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF
63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x
XY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2
ZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk
Xb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK
cBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef
eNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4
/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5
rl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru
/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A
zviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO
I4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1
jfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ
GRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG
cZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb
WmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis
ZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH
ckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi
lbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO
xuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK
JtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX
PaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c
W0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t
C6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk
4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn
xHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW
vHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi
qr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV
hamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F
j4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6
wqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm
oy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ
k7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg
nQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP
1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1
H1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ
1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx
zSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt
fFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp
Oxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj
VtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy
rFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe
5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D
d/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69
MlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ
Fbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ
MA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP
ByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn
0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU
yOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is
pNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz
TSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu
uCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem
gGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk
HvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy
s9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu
m6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb
0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz
9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN
DNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n
R6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk
nmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu
6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd
9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb
Sms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S
MSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz
FEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8
VSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx
Y0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ
mupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+
5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh
05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd
ua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ
5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR
Mqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8
1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4
B9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag
Bc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA
3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn
3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx
1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU
tzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6
f3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA
bvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ
zyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup
6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM
350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0
/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a
YfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ
agBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO
mAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl
mOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR
nqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo
EPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt
4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ
ScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p
iMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj
PQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l
c6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1
8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3
ylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY
euPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==`;
var body3 = `
/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk
JyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF
RUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA
AhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA
AQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA
AAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA
AhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj
+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt
Fh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR
PLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl
mZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp
+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa
zhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D
h1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2
ex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67
d4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y
Rv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP
Ld3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC
vy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi
eSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/
Mx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+
r3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO
O0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s
tfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN
TmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc
0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj
q83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w
+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s
d8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t
cI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4
Yibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe
bzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi
KxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6
rNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ
9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf
Jvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V
bxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q
Vbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM
lorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/
/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme
E4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv
fauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6
jkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN
+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk
Rvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK
cGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop
yW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn
E8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX
12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW
iI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS
RWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf
0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx
DS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL
G8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK
xC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ
a9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4
ZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6
tvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+
fJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE
erk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR
Md5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9
lcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD
j8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV
5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt
Cu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/
+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c
vUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p
jrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0
77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP
Sel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8
5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe
Y0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R
Hwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV
rWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU
z7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8
to6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X
y8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt
stcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/
w9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT
DpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l
XV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t
ydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS
34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX
e09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn
26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf
3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q
6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P
NbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO
yZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN
3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8
2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h
dqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx
kr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t
DHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb
eFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc
1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka
c258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE
xEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu
s5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK
0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9
dM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt
PXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T
Md/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T
adq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b
SVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt
pdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm
vfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr
EejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N
vwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh
ZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I
tkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW
d43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe
N4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218
8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG
PNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY
V1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw
w18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT
Ex5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1
axqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/
tDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I
mbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe
XRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1
izjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2
crFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4
OadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2
r8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx
zc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz
+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v
Mevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu
ryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095
YZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE
9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8
mNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O
uSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O
fft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6
Olty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT
uTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3
6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1
Mb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF
feH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq
xVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v
ed7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ
mtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz
mWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP
B39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0
5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1
mkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt
mxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO
1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq
ZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q
ky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7
ROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK
GEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i
tMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T
+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+
O8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO
esd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es
vPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz
XV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1
+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY
36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL
q555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY
3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz
p7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr
1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV
xUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt
pCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS
fP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH
mMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z
1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+
n3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d
MRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df
zXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl
J2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs
zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH
DpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ
dHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR
tER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j
admFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC
b2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X
qdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh
ydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O
8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L
T7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0
Za1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr
vNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer
rWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL
oNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq
j/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh
odZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8
8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1
lNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+
oza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL
knU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK
EtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N
mtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm
9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N
IpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W
MYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2
+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql
o+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37
O99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE
TE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1
L7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4
izsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt
1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb
V5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum
L37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12
CvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE
ebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo
Gvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu
L8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh
5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3
6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9
XO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM
feKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj
SZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF
XaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr
79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h
yeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT
OC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223
2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt
adohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y
cnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX
DpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p
7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso
S24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l
bPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe
vVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG
H6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7
x3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz
5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY
q+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn
vLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2
IjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK
z0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ
YYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON
ZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW
ekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf
cjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c
biuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO
CkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw
y1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi
QXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E
bL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r
tv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t
LRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP
RqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm
s7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el
XX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1
vK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq
qrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v
VYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0
ZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q
mT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm
6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG
f63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo
dPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22
gtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M
MoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb
c2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX
6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn
1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK
fOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ
EqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u
7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT
qPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa
S2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf
Lp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU
IiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O
8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c
vU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx
5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V
KTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm
2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu
j8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB
TTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9
RUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL
CWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA
AAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8
cTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj
qKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF
0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK
ZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK
66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu
XT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9
XOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN
M2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv
VrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK
7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI
3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m
XY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m
1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A
JUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC
EgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9
8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL
OrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H
M+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA
TsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8
elpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp
BjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS
CRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r
rcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY
jbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW
UsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB
KUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb
Sz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL
+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v
T471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM
sfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj
FontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl
5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q
7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv
6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa
0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/
AOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM
d8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5
6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP
bFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu
LJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy
wt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX
0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK
3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn
KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0
vobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t
zya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps
uOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi
Fdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2
O3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z
aK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz
0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb
T/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l
qMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t
trJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn
mvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa
eq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe
PwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of
TdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O
1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG
f/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi
0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY
5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc
V2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L
/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM
t/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd
VknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD
KLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R
fwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3
Vxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ
DJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ
3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv
x7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
weqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI
6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew
PnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk
j3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm
OqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/
AKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez
N9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ
92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp
+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue
V9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv
avHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0
vQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP
8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt
n1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw
nUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3
7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P
0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U
x8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG
0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L
faQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ
QKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA
BAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A
tLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv
9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr
jn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm
b7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB
ACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk
dEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1
rMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+
x+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA
AAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr
YvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4
5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V
kK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg
BIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA
AAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g
Wbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx
OEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2
H/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF
+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V
h6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA
EgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu
ZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml
HMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl
n0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN
3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi
/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00
+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC
UACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2
M2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp
5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn
N1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS
OjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL
/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo
stLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3
GyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA
AAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4
qmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy
WEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a
fJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI
rTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2
rz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc
3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3
Tur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA
AAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx
skA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F
o7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx
NO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h
2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te
pSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7
cvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7
mZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA
AAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA
hGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J
qx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI
XRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy
RHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX
qNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX
kaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P
ya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC
ExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA
lAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA
AAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o
b9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP
y6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae
kzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu
9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ
k7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1
8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp
DXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh
nyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ
AAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA
AAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO
yvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5
PM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii
IpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r
O3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE
yTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX
6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2
JgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS
AAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA
AAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx
Wa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI
6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5
K2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7
Vv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id
PW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ
2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4
eF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7
piVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR
ACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ
JQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i
UiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61
rZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq
ZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2
f0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO
IjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts
bAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA
AAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA
BAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2
SbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T
lBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/
2Q==`;
async function warmupBitmap(instance) {
  const b64toBlob = (base64, type = "application/octet-stream") => fetch(`data:${type};base64,${base64}`).then((res22) => res22.blob());
  let blob;
  let res2;
  switch (instance.config.warmup) {
    case "face":
      blob = await b64toBlob(face3);
      break;
    case "body":
    case "full":
      blob = await b64toBlob(body3);
      break;
    default:
      blob = null;
  }
  if (blob) {
    const bitmap = await createImageBitmap(blob);
    res2 = await instance.detect(bitmap, instance.config);
    bitmap.close();
  }
  return res2;
}
async function warmupCanvas(instance) {
  return new Promise((resolve) => {
    let src;
    switch (instance.config.warmup) {
      case "face":
        src = "data:image/jpeg;base64," + face3;
        break;
      case "full":
      case "body":
        src = "data:image/jpeg;base64," + body3;
        break;
      default:
        src = null;
    }
    let img;
    if (typeof Image !== "undefined")
      img = new Image();
    else if (env.Image)
      img = new env.Image();
    else
      return;
    img.onload = async () => {
      const canvas3 = canvas(img.naturalWidth, img.naturalHeight);
      if (!canvas3) {
        log("Warmup: Canvas not found");
        resolve(void 0);
      } else {
        const ctx = canvas3.getContext("2d");
        if (ctx)
          ctx.drawImage(img, 0, 0);
        const tensor = await instance.image(canvas3);
        const res2 = await instance.detect(tensor.tensor, instance.config);
        resolve(res2);
      }
    };
    if (src)
      img.src = src;
    else
      resolve(void 0);
  });
}
async function warmupNode(instance) {
  const atob2 = (str) => Buffer.from(str, "base64");
  let img;
  if (instance.config.warmup === "face")
    img = atob2(face3);
  else
    img = atob2(body3);
  let res2;
  if ("node" in tfjs_esm_exports) {
    const data = (void 0).decodeJpeg(img);
    const expanded = data.expandDims(0);
    instance.tf.dispose(data);
    res2 = await instance.detect(expanded, instance.config);
    instance.tf.dispose(expanded);
  } else {
    if (instance.config.debug)
      log("Warmup tfjs-node not loaded");
  }
  return res2;
}
async function warmup(instance, userConfig) {
  const t02 = now2();
  instance.state = "warmup";
  if (userConfig)
    instance.config = mergeDeep(instance.config, userConfig);
  if (!instance.config.warmup || instance.config.warmup.length === 0 || instance.config.warmup === "none") {
    return { face: [], body: [], hand: [], gesture: [], object: [], performance: instance.performance, timestamp: now2(), persons: [], error: null };
  }
  let res2;
  return new Promise(async (resolve) => {
    if (typeof createImageBitmap === "function")
      res2 = await warmupBitmap(instance);
    else if (typeof Image !== "undefined" || env.Canvas !== void 0)
      res2 = await warmupCanvas(instance);
    else
      res2 = await warmupNode(instance);
    const t12 = now2();
    if (instance.config.debug)
      log("Warmup", instance.config.warmup, Math.round(t12 - t02), "ms");
    instance.emit("warmup");
    resolve(res2);
  });
}
var _numTensors;
var _analyzeMemoryLeaks;
var _checkSanity;
var _sanity;
var Human = class {
  constructor(userConfig) {
    __publicField(this, "version");
    __publicField(this, "config");
    __publicField(this, "result");
    __publicField(this, "state");
    __publicField(this, "process");
    __publicField(this, "tf");
    __publicField(this, "env");
    __publicField(this, "draw");
    __publicField(this, "models");
    __publicField(this, "events");
    __publicField(this, "faceTriangulation");
    __publicField(this, "faceUVMap");
    __publicField(this, "performance");
    __privateAdd(this, _numTensors, void 0);
    __privateAdd(this, _analyzeMemoryLeaks, void 0);
    __privateAdd(this, _checkSanity, void 0);
    __publicField(this, "gl");
    __publicField(this, "analyze", (...msg) => {
      if (!__privateGet(this, _analyzeMemoryLeaks))
        return;
      const currentTensors = this.tf.engine().state.numTensors;
      const previousTensors = __privateGet(this, _numTensors);
      __privateSet(this, _numTensors, currentTensors);
      const leaked = currentTensors - previousTensors;
      if (leaked !== 0)
        log(...msg, leaked);
    });
    __privateAdd(this, _sanity, (input) => {
      if (!__privateGet(this, _checkSanity))
        return null;
      if (!input)
        return "input is not defined";
      if (this.env.node && !(input instanceof et))
        return "input must be a tensor";
      try {
        this.tf.getBackend();
      } catch (e) {
        return "backend not loaded";
      }
      return null;
    });
    __publicField(this, "similarity", similarity);
    __publicField(this, "distance", distance);
    __publicField(this, "match", match2);
    __publicField(this, "emit", (event) => {
      var _a2;
      if (this.events && this.events.dispatchEvent)
        (_a2 = this.events) == null ? void 0 : _a2.dispatchEvent(new Event(event));
    });
    this.env = env;
    config.wasmPath = $pe["tfjs-core"].includes("-") ? "https://vladmandic.github.io/tfjs/dist/" : `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${gde}/dist/`;
    config.modelBasePath = env.browser ? "../models/" : "file://models/";
    config.backend = env.browser ? "humangl" : "tensorflow";
    this.version = version;
    Object.defineProperty(this, "version", { value: version });
    this.config = JSON.parse(JSON.stringify(config));
    Object.seal(this.config);
    if (userConfig)
      this.config = mergeDeep(this.config, userConfig);
    this.config.cacheModels = typeof indexedDB !== "undefined";
    setModelLoadOptions(this.config);
    this.tf = tfjs_esm_exports;
    this.state = "idle";
    __privateSet(this, _numTensors, 0);
    __privateSet(this, _analyzeMemoryLeaks, false);
    __privateSet(this, _checkSanity, false);
    this.performance = {};
    this.events = typeof EventTarget !== "undefined" ? new EventTarget() : void 0;
    this.models = new Models();
    this.draw = {
      options: options3,
      canvas: (input, output) => canvas2(input, output),
      face: (output, result, options4) => face(output, result, options4),
      body: (output, result, options4) => body(output, result, options4),
      hand: (output, result, options4) => hand(output, result, options4),
      gesture: (output, result, options4) => gesture(output, result, options4),
      object: (output, result, options4) => object(output, result, options4),
      person: (output, result, options4) => person(output, result, options4),
      all: (output, result, options4) => all(output, result, options4)
    };
    this.result = { face: [], body: [], hand: [], gesture: [], object: [], performance: {}, timestamp: 0, persons: [], error: null };
    this.process = { tensor: null, canvas: null };
    this.faceTriangulation = triangulation;
    this.faceUVMap = uvmap;
    this.gl = config2;
    this.emit("create");
  }
  reset() {
    const currentBackend = this.config.backend;
    this.config = JSON.parse(JSON.stringify(config));
    this.config.backend = currentBackend;
  }
  validate(userConfig) {
    return validate(config, userConfig || this.config);
  }
  now() {
    return now2();
  }
  image(input, getTensor = true) {
    return process2(input, this.config, getTensor);
  }
  async segmentation(input, background) {
    return process5(input, background, this.config);
  }
  enhance(input) {
    return enhance(input);
  }
  compare(firstImageTensor, secondImageTensor) {
    return compare(this.config, firstImageTensor, secondImageTensor);
  }
  async init() {
    await check(this, true);
    await this.tf.ready();
  }
  async load(userConfig) {
    this.state = "load";
    const timeStamp = now2();
    const count2 = Object.values(this.models).filter((model182) => model182).length;
    if (userConfig)
      this.config = mergeDeep(this.config, userConfig);
    if (this.env.initial) {
      if (this.config.debug)
        log(`version: ${this.version}`);
      if (this.config.debug)
        log(`tfjs version: ${this.tf.version["tfjs-core"]}`);
      if (!await check(this))
        log("error: backend check failed");
      await Sde();
      if (this.env.browser) {
        if (this.config.debug)
          log("configuration:", this.config);
        if (this.config.debug)
          log("environment:", this.env);
        if (this.config.debug)
          log("tf flags:", this.tf.ENV["flags"]);
      }
    }
    await load19(this);
    if (this.env.initial && this.config.debug)
      log("tf engine state:", this.tf.engine().state.numBytes, "bytes", this.tf.engine().state.numTensors, "tensors");
    this.env.initial = false;
    const loaded = Object.values(this.models).filter((model182) => model182).length;
    if (loaded !== count2) {
      await validate2(this);
      this.emit("load");
    }
    const current = Math.trunc(now2() - timeStamp);
    if (current > (this.performance.loadModels || 0))
      this.performance.loadModels = this.env.perfadd ? (this.performance.loadModels || 0) + current : current;
  }
  next(result = this.result) {
    return calc2(result, this.config);
  }
  async warmup(userConfig) {
    const t02 = now2();
    const res2 = await warmup(this, userConfig);
    const t12 = now2();
    this.performance.warmup = Math.trunc(t12 - t02);
    return res2;
  }
  async profile(input, userConfig) {
    const profile = await this.tf.profile(() => this.detect(input, userConfig));
    const kernels = {};
    for (const kernel of profile.kernels) {
      if (kernels[kernel.name])
        kernels[kernel.name] += kernel.kernelTimeMs;
      else
        kernels[kernel.name] = kernel.kernelTimeMs;
    }
    const kernelArr = [];
    Object.entries(kernels).forEach((key) => kernelArr.push({ name: key[0], ms: key[1] }));
    kernelArr.sort((a10, b10) => b10.ms - a10.ms);
    kernelArr.length = 20;
    const res2 = {};
    for (const kernel of kernelArr)
      res2[kernel.name] = kernel.ms;
    return res2;
  }
  async detect(input, userConfig) {
    this.state = "detect";
    return new Promise(async (resolve) => {
      var _a2, _b2, _c, _d2, _e22, _f, _g2, _h, _i, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q22, _r2, _s2, _t2, _u2, _v2;
      this.state = "config";
      let timeStamp;
      this.config = mergeDeep(this.config, userConfig);
      this.state = "check";
      const error = __privateGet(this, _sanity).call(this, input);
      if (error) {
        log(error, input);
        this.emit("error");
        resolve({ face: [], body: [], hand: [], gesture: [], object: [], performance: this.performance, timestamp: now2(), persons: [], error });
      }
      const timeStart = now2();
      await check(this);
      await this.load();
      timeStamp = now2();
      this.state = "image";
      const img = await process2(input, this.config);
      this.process = img;
      this.performance.inputProcess = this.env.perfadd ? (this.performance.inputProcess || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      this.analyze("Get Image:");
      if (!img.tensor) {
        if (this.config.debug)
          log("could not convert input to tensor");
        this.emit("error");
        resolve({ face: [], body: [], hand: [], gesture: [], object: [], performance: this.performance, timestamp: now2(), persons: [], error: "could not convert input to tensor" });
        return;
      }
      this.emit("image");
      timeStamp = now2();
      this.config.skipAllowed = await skip(this.config, img.tensor);
      if (!this.performance.totalFrames)
        this.performance.totalFrames = 0;
      if (!this.performance.cachedFrames)
        this.performance.cachedFrames = 0;
      this.performance.totalFrames++;
      if (this.config.skipAllowed)
        this.performance.cachedFrames++;
      this.performance.cacheCheck = this.env.perfadd ? (this.performance.cacheCheck || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      this.analyze("Check Changed:");
      let faceRes = [];
      let bodyRes = [];
      let handRes = [];
      let objectRes = [];
      this.state = "detect:face";
      if (this.config.async) {
        faceRes = this.config.face.enabled ? detectFace(this, img.tensor) : [];
        if (this.performance.face)
          delete this.performance.face;
      } else {
        timeStamp = now2();
        faceRes = this.config.face.enabled ? await detectFace(this, img.tensor) : [];
        this.performance.face = this.env.perfadd ? (this.performance.face || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      }
      if (this.config.async && (this.config.body.maxDetected === -1 || this.config.hand.maxDetected === -1))
        faceRes = await faceRes;
      this.analyze("Start Body:");
      this.state = "detect:body";
      const bodyConfig = this.config.body.maxDetected === -1 ? mergeDeep(this.config, { body: { maxDetected: this.config.face.enabled ? 1 * faceRes.length : 1 } }) : this.config;
      if (this.config.async) {
        if ((_a2 = this.config.body.modelPath) == null ? void 0 : _a2.includes("posenet"))
          bodyRes = this.config.body.enabled ? predict17(img.tensor, bodyConfig) : [];
        else if ((_b2 = this.config.body.modelPath) == null ? void 0 : _b2.includes("blazepose"))
          bodyRes = this.config.body.enabled ? predict5(img.tensor, bodyConfig) : [];
        else if ((_c = this.config.body.modelPath) == null ? void 0 : _c.includes("efficientpose"))
          bodyRes = this.config.body.enabled ? predict7(img.tensor, bodyConfig) : [];
        else if ((_d2 = this.config.body.modelPath) == null ? void 0 : _d2.includes("movenet"))
          bodyRes = this.config.body.enabled ? predict15(img.tensor, bodyConfig) : [];
        if (this.performance.body)
          delete this.performance.body;
      } else {
        timeStamp = now2();
        if ((_e22 = this.config.body.modelPath) == null ? void 0 : _e22.includes("posenet"))
          bodyRes = this.config.body.enabled ? await predict17(img.tensor, bodyConfig) : [];
        else if ((_f = this.config.body.modelPath) == null ? void 0 : _f.includes("blazepose"))
          bodyRes = this.config.body.enabled ? await predict5(img.tensor, bodyConfig) : [];
        else if ((_g2 = this.config.body.modelPath) == null ? void 0 : _g2.includes("efficientpose"))
          bodyRes = this.config.body.enabled ? await predict7(img.tensor, bodyConfig) : [];
        else if ((_h = this.config.body.modelPath) == null ? void 0 : _h.includes("movenet"))
          bodyRes = this.config.body.enabled ? await predict15(img.tensor, bodyConfig) : [];
        this.performance.body = this.env.perfadd ? (this.performance.body || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Body:");
      this.analyze("Start Hand:");
      this.state = "detect:hand";
      const handConfig = this.config.hand.maxDetected === -1 ? mergeDeep(this.config, { hand: { maxDetected: this.config.face.enabled ? 2 * faceRes.length : 1 } }) : this.config;
      if (this.config.async) {
        if ((_j2 = (_i = this.config.hand.detector) == null ? void 0 : _i.modelPath) == null ? void 0 : _j2.includes("handdetect"))
          handRes = this.config.hand.enabled ? predict12(img.tensor, handConfig) : [];
        else if ((_l2 = (_k2 = this.config.hand.detector) == null ? void 0 : _k2.modelPath) == null ? void 0 : _l2.includes("handtrack"))
          handRes = this.config.hand.enabled ? predict13(img.tensor, handConfig) : [];
        if (this.performance.hand)
          delete this.performance.hand;
      } else {
        timeStamp = now2();
        if ((_n2 = (_m2 = this.config.hand.detector) == null ? void 0 : _m2.modelPath) == null ? void 0 : _n2.includes("handdetect"))
          handRes = this.config.hand.enabled ? await predict12(img.tensor, handConfig) : [];
        else if ((_p2 = (_o2 = this.config.hand.detector) == null ? void 0 : _o2.modelPath) == null ? void 0 : _p2.includes("handtrack"))
          handRes = this.config.hand.enabled ? await predict13(img.tensor, handConfig) : [];
        this.performance.hand = this.env.perfadd ? (this.performance.hand || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Hand:");
      this.analyze("Start Object:");
      this.state = "detect:object";
      if (this.config.async) {
        if ((_q22 = this.config.object.modelPath) == null ? void 0 : _q22.includes("nanodet"))
          objectRes = this.config.object.enabled ? predict16(img.tensor, this.config) : [];
        else if ((_r2 = this.config.object.modelPath) == null ? void 0 : _r2.includes("centernet"))
          objectRes = this.config.object.enabled ? predict6(img.tensor, this.config) : [];
        if (this.performance.object)
          delete this.performance.object;
      } else {
        timeStamp = now2();
        if ((_s2 = this.config.object.modelPath) == null ? void 0 : _s2.includes("nanodet"))
          objectRes = this.config.object.enabled ? await predict16(img.tensor, this.config) : [];
        else if ((_t2 = this.config.object.modelPath) == null ? void 0 : _t2.includes("centernet"))
          objectRes = this.config.object.enabled ? await predict6(img.tensor, this.config) : [];
        this.performance.object = this.env.perfadd ? (this.performance.object || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Object:");
      this.state = "detect:await";
      if (this.config.async)
        [faceRes, bodyRes, handRes, objectRes] = await Promise.all([faceRes, bodyRes, handRes, objectRes]);
      this.state = "detect:gesture";
      let gestureRes = [];
      if (this.config.gesture.enabled) {
        timeStamp = now2();
        gestureRes = [...face2(faceRes), ...body2(bodyRes), ...hand2(handRes), ...iris(faceRes)];
        if (!this.config.async)
          this.performance.gesture = this.env.perfadd ? (this.performance.gesture || 0) + Math.trunc(now2() - timeStamp) : Math.trunc(now2() - timeStamp);
        else if (this.performance.gesture)
          delete this.performance.gesture;
      }
      this.performance.total = this.env.perfadd ? (this.performance.total || 0) + Math.trunc(now2() - timeStart) : Math.trunc(now2() - timeStart);
      const shape = ((_v2 = (_u2 = this.process) == null ? void 0 : _u2.tensor) == null ? void 0 : _v2.shape) || [];
      this.result = {
        face: faceRes,
        body: bodyRes,
        hand: handRes,
        gesture: gestureRes,
        object: objectRes,
        performance: this.performance,
        canvas: this.process.canvas,
        timestamp: Date.now(),
        error: null,
        get persons() {
          return join2(faceRes, bodyRes, handRes, gestureRes, shape);
        }
      };
      Re2(img.tensor);
      this.emit("detect");
      this.state = "idle";
      resolve(this.result);
    });
  }
};
_numTensors = /* @__PURE__ */ new WeakMap();
_analyzeMemoryLeaks = /* @__PURE__ */ new WeakMap();
_checkSanity = /* @__PURE__ */ new WeakMap();
_sanity = /* @__PURE__ */ new WeakMap();

// src/vrm-calculate.ts
var leanBody = 0;
var posLeftWrist;
var posRightWrist;
var angle = (pt1, pt2) => {
  if (!pt1 || !pt2 || pt1.length < 2 || pt2.length < 2)
    return 0;
  const radians = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
  return radians;
};
async function updateBody(vrm2, res2) {
  const body4 = res2 && res2.body ? res2.body[0] : null;
  if (!body4)
    return;
  const part = (what) => {
    const found = body4.keypoints.find((a10) => a10.part === what);
    const pos = found ? found.positionRaw : null;
    return pos;
  };
  const posLeftShoulder = part("leftShoulder");
  const posRightShoulder = part("rightShoulder");
  leanBody = angle(posRightShoulder, posLeftShoulder);
  if (posLeftShoulder && posRightShoulder)
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Chest).rotation.z = leanBody;
  const posRightElbow = part("rightElbow");
  if (posRightShoulder && posRightElbow)
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName.RightUpperArm).rotation.y = angle(posRightElbow, posRightShoulder);
  const posLeftElbow = part("leftElbow");
  if (posLeftShoulder && posLeftElbow)
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName.LeftUpperArm).rotation.y = angle(posLeftShoulder, posLeftElbow);
  posRightWrist = part("rightWrist");
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.RightLowerArm).rotation.y = posRightWrist && posRightElbow && posRightShoulder ? angle(posRightWrist, posRightElbow) - angle(posRightElbow, posRightShoulder) : 0;
  posLeftWrist = part("leftWrist");
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.LeftLowerArm).rotation.y = posLeftWrist && posLeftElbow ? angle(posLeftElbow, posLeftWrist) - angle(posLeftShoulder, posLeftElbow) : 0;
  const posRightHip = part("rightHip");
  const posRightKnee = part("rightKnee");
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.RightUpperLeg).rotation.z = posRightHip && posRightKnee ? angle(posRightHip, posRightKnee) - Math.PI / 2 : 0;
  const posLeftHip = part("leftHip");
  const posLeftKnee = part("leftKnee");
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.LeftUpperLeg).rotation.z = posLeftHip && posLeftKnee ? angle(posLeftHip, posLeftKnee) - Math.PI / 2 : 0;
}
async function updateHands(vrm2, res2) {
  const hands = res2 && res2.hand ? res2.hand : [];
  for (const hand3 of hands) {
    const distanceLeft = posLeftWrist ? Math.sqrt((hand3.boxRaw[0] - posLeftWrist[0]) ** 2) + (hand3.boxRaw[1] - posLeftWrist[1]) ** 2 : Number.MAX_VALUE;
    const distanceRight = posRightWrist ? Math.sqrt((hand3.boxRaw[0] - posRightWrist[0]) ** 2) + (hand3.boxRaw[1] - posRightWrist[1]) ** 2 : Number.MAX_VALUE;
    if (distanceLeft > 1 && distanceRight > 1)
      continue;
    const left = distanceLeft < distanceRight;
    const handSize = Math.sqrt((hand3.box[2] || 1) ** 2 + (hand3.box[3] || 1) ** 2) / Math.PI;
    const handRotation = (hand3.annotations.pinky[0][2] - hand3.annotations.thumb[0][2]) / handSize;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[left ? "LeftHand" : "RightHand"]).rotation.z = -handRotation * Math.PI / 2;
    const getCurl = (finger) => {
      let val2 = 0;
      if (hand3.landmarks[finger].curl === "half")
        val2 = Math.PI / 8;
      else if (hand3.landmarks[finger].curl === "full")
        val2 = Math.PI / 4;
      return val2;
    };
    let val;
    val = getCurl("index");
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}IndexIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}IndexProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}IndexDistal`]).rotation.z = val;
    val = getCurl("middle");
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}MiddleDistal`]).rotation.z = val;
    val = getCurl("ring");
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}RingIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}RingProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}RingDistal`]).rotation.z = val;
    val = getCurl("pinky");
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}LittleIntermediate`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}LittleProximal`]).rotation.z = val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}LittleDistal`]).rotation.z = val;
    val = getCurl("thumb");
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbIntermediate`]).rotation.x = 2 * -val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbProximal`]).rotation.x = 2 * -val;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}ThumbDistal`]).rotation.x = 2 * -val;
    const q10 = angle(hand3.annotations.index[3], hand3.annotations.palm[0]) - Math.PI / 2;
    vrm2.humanoid.getBoneNode(u.HumanoidBoneName[`${left ? "Left" : "Right"}Hand`]).rotation.y = q10;
  }
}
async function updateFace(vrm2, res2) {
  var _a2, _b2, _c;
  const face4 = res2 && res2.face ? res2.face[0] : null;
  if (!face4)
    return;
  const faceAngle = ((_a2 = face4.rotation) == null ? void 0 : _a2.angle) || { roll: 0, yaw: 0, pitch: 0 };
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Head).rotation.x = -faceAngle.pitch / 2;
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Head).rotation.y = -faceAngle.yaw / 2;
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Head).rotation.z = faceAngle.roll / 2 - leanBody;
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Neck).rotation.x = -faceAngle.pitch / 2;
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Neck).rotation.y = -faceAngle.yaw / 2;
  vrm2.humanoid.getBoneNode(u.HumanoidBoneName.Neck).rotation.z = (faceAngle.roll / 2 - leanBody) / 2;
  if (face4.mesh.length > 300) {
    const blinkL = 3 * (Math.abs(face4.mesh[374][1] - face4.mesh[386][1]) / Math.abs(face4.mesh[443][1] - face4.mesh[450][1]) - 0.15);
    const blinkR = 3 * (Math.abs(face4.mesh[145][1] - face4.mesh[159][1]) / Math.abs(face4.mesh[223][1] - face4.mesh[230][1]) - 0.15);
    vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.BlinkL, 1 - blinkL);
    vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.BlinkR, 1 - blinkR);
  }
  vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Fun, 0);
  vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Angry, 0);
  vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Sorrow, 0);
  vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Neutral, 0);
  const emotion = (_b2 = face4.emotion) == null ? void 0 : _b2.reduce((prev, curr) => prev.score > curr.score ? prev : curr);
  switch ((emotion == null ? void 0 : emotion.emotion) || "") {
    case "happy":
      vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Fun, 1);
      break;
    case "angry":
      vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Angry, 1);
      break;
    case "sad":
      vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Sorrow, 1);
      break;
    default:
      vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.Neutral, 1);
  }
  if (face4.mesh.length > 300) {
    const mouth = Math.min(1, 5 * Math.abs(face4.mesh[13][1] - face4.mesh[14][1]) / Math.abs(face4.mesh[10][1] - face4.mesh[152][1]));
    vrm2.blendShapeProxy.setValue(u.BlendShapePresetName.O, mouth);
  }
  const gaze = (_c = face4.rotation) == null ? void 0 : _c.gaze;
  if (gaze) {
    const target = new Object3D();
    if (gaze)
      target.position.x = 10 * gaze.strength * Math.sin(gaze.bearing);
    if (gaze)
      target.position.y = 10 * gaze.strength * Math.cos(gaze.bearing);
    vrm2.lookAt.target = target;
  }
}
async function update(vrm2, res2) {
  if (!vrm2 || !vrm2.humanoid)
    return;
  await updateBody(vrm2, res2);
  await updateFace(vrm2, res2);
  await updateHands(vrm2, res2);
}

// src/human-vrm.ts
var model18 = "../assets/victoria-jeans.vrm";
var vrm;
var renderer;
var camera;
var scene;
var light;
var clock;
var stats;
var human;
var res;
var humanConfig = {
  modelBasePath: "https://vladmandic.github.io/human/models",
  face: {
    enabled: true,
    detector: { return: false, rotation: true },
    mesh: { enabled: true },
    iris: { enabled: true },
    description: { enabled: false },
    emotion: { enabled: true }
  },
  body: { enabled: true },
  hand: { enabled: true },
  object: { enabled: false },
  gesture: { enabled: false },
  segmentation: { enabled: false }
};
async function log2(...msg) {
  console.log(...msg);
  const div = document.getElementById("log");
  div.innerText = msg.join(" ");
}
async function setupScene() {
  const canvas3 = document.getElementById("canvas");
  renderer = new WebGLRenderer({ antialias: true, alpha: true, canvas: canvas3 });
  renderer.setClearColor(0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  camera = new PerspectiveCamera(22, canvas3.width / canvas3.height, 0.1, 20);
  camera.position.set(0, 0.9, 15);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.screenSpacePanning = true;
  controls.target.set(0, 0.9, 0);
  controls.enabled = true;
  controls.update();
  scene = new Scene();
  light = new DirectionalLight(16777215);
  light.position.set(1, 1, 1).normalize();
  scene.add(light);
  const gridHelper = new GridHelper(100, 100);
  scene.add(gridHelper);
  const loader = new TextureLoader();
  loader.load("../assets/background.jpg", (texture) => scene.background = texture);
  clock = new Clock();
  stats = stats_module_default();
  document.body.appendChild(stats.dom);
  renderer.render(scene, camera);
}
async function loadVRM(f10) {
  const loader = new GLTFLoader();
  return new Promise((resolve, reject) => {
    loader.load(f10, (gltf) => {
      we.removeUnnecessaryJoints(gltf.scene);
      xe.from(gltf).then((vrmInstance) => resolve(vrmInstance));
    }, () => {
    }, (error) => {
      log2("error:", error);
      reject(error);
    });
  });
}
async function initHuman() {
  human = new Human(humanConfig);
  log2(`human ${human.version}`);
  await human.load();
  await human.warmup();
}
async function animateFrame() {
  const deltaTime = clock.getDelta();
  const interpolated = human.next(res);
  const detected = document.getElementById("detected");
  const ctx = detected.getContext("2d");
  const video = document.getElementById("video");
  ctx == null ? void 0 : ctx.drawImage(video, 0, 0, 640, 480);
  human.draw.all(detected, interpolated);
  light.position.set(Math.sin(Math.PI * clock.elapsedTime), Math.cos(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime) + Math.cos(Math.PI * clock.elapsedTime)).normalize();
  await update(vrm, interpolated);
  vrm.update(deltaTime);
  renderer.render(scene, camera);
  stats.update();
  requestAnimationFrame(animateFrame);
}
async function detectionLoop() {
  const video = document.getElementById("video");
  res = await human.detect(video);
  if (!video.paused)
    requestAnimationFrame(detectionLoop);
}
async function initWebCam() {
  if (!navigator.mediaDevices)
    return;
  const video = document.getElementById("video");
  const constraints = { audio: false, video: { facingMode: "user", resizeMode: "none", width: { ideal: 640 } } };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  window.addEventListener("click", () => {
    if (video.paused) {
      video.play();
      detectionLoop();
    } else {
      video.pause();
    }
  });
  const videoReady = new Promise((resolve) => {
    video.onloadeddata = () => resolve(true);
  });
  video.srcObject = stream;
  await videoReady;
  video.play();
}
async function startupAnimation() {
  const wait = async (t) => new Promise((resolve) => {
    setTimeout(() => resolve(true), t);
  });
  if (!vrm.humanoid || !vrm.blendShapeProxy)
    return;
  while (clock.elapsedTime < Math.PI) {
    const deltaTime = clock.getDelta();
    vrm.humanoid.getBoneNode(u.HumanoidBoneName.Hips).rotation.y = clock.elapsedTime;
    vrm.humanoid.getBoneNode(u.HumanoidBoneName.LeftUpperArm).rotation.x = clock.elapsedTime / 2;
    vrm.humanoid.getBoneNode(u.HumanoidBoneName.RightUpperArm).rotation.x = clock.elapsedTime / 2;
    vrm.humanoid.getBoneNode(u.HumanoidBoneName.LeftUpperArm).rotation.y = clock.elapsedTime / 3;
    vrm.humanoid.getBoneNode(u.HumanoidBoneName.RightUpperArm).rotation.y = -clock.elapsedTime / 3;
    vrm.blendShapeProxy.setValue(u.BlendShapePresetName.Blink, Math.PI - clock.elapsedTime);
    light.position.set(Math.cos(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime), Math.sin(Math.PI * clock.elapsedTime) + Math.cos(Math.PI * clock.elapsedTime)).normalize();
    camera.position.set(0, 0.9, 10 * (1 - clock.elapsedTime / Math.PI) + 5);
    vrm.update(deltaTime);
    renderer.render(scene, camera);
    await wait(10);
  }
}
async function main() {
  await setupScene();
  vrm = await loadVRM(model18);
  log2("vrm model:", model18);
  scene.add(vrm.scene);
  if (!vrm.humanoid)
    return;
  renderer.render(scene, camera);
  await initHuman();
  await initWebCam();
  log2("vrm schema", u);
  log2("vrm scene:", vrm);
  log2("vrm pose:", vrm.humanoid.getPose());
  window["light"] = light;
  window["camera"] = camera;
  window["human"] = human;
  window["vrm"] = vrm;
  window["VRMSchema"] = u;
  await startupAnimation();
  animateFrame();
  detectionLoop();
  log2("");
}
window.onload = main;
/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Human main module
 * @default Human Library
 * @summary <https://github.com/vladmandic/human>
 * @author <https://github.com/vladmandic>
 * @copyright <https://github.com/vladmandic>
 * @license MIT
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=human-vrm.esm.js.map
